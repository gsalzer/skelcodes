{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-11-03\r\n*/\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract UtilOpenFair {\r\n\t/* https://openfair.me */\r\n\tuint ethWei = 1 ether;\r\n\r\n\tfunction getLevel(uint value) public view returns (uint) {\r\n\t\tif (value >= 1 * ethWei && value <= 5 * ethWei) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (value >= 6 * ethWei && value <= 10 * ethWei) {\r\n\t\t\treturn 2;\r\n\t\t}\r\n\t\tif (value >= 11 * ethWei && value <= 15 * ethWei) {\r\n\t\t\treturn 3;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction getNodeLevel(uint value) public view returns (uint) {\r\n\t\tif (value >= 1 * ethWei && value <= 5 * ethWei) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (value >= 6 * ethWei && value <= 10 * ethWei) {\r\n\t\t\treturn 2;\r\n\t\t}\r\n\t\tif (value >= 11 * ethWei) {\r\n\t\t\treturn 3;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction getScByLevel(uint level) public pure returns (uint) {\r\n\t\tif (level == 1) {\r\n\t\t\treturn 5;\r\n\t\t}\r\n\t\tif (level == 2) {\r\n\t\t\treturn 7;\r\n\t\t}\r\n\t\tif (level == 3) {\r\n\t\t\treturn 10;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction getFireScByLevel(uint level) public pure returns (uint) {\r\n\t\tif (level == 1) {\r\n\t\t\treturn 3;\r\n\t\t}\r\n\t\tif (level == 2) {\r\n\t\t\treturn 6;\r\n\t\t}\r\n\t\tif (level == 3) {\r\n\t\t\treturn 10;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction getRecommendScaleByLevelAndTim(uint level, uint times) public pure returns (uint){\r\n\t\tif (level == 1 && times == 1) {\r\n\t\t\treturn 50;\r\n\t\t}\r\n\t\tif (level == 2 && times == 1) {\r\n\t\t\treturn 70;\r\n\t\t}\r\n\t\tif (level == 2 && times == 2) {\r\n\t\t\treturn 50;\r\n\t\t}\r\n\t\tif (level == 3) {\r\n\t\t\tif (times == 1) {\r\n\t\t\t\treturn 100;\r\n\t\t\t}\r\n\t\t\tif (times == 2) {\r\n\t\t\t\treturn 70;\r\n\t\t\t}\r\n\t\t\tif (times == 3) {\r\n\t\t\t\treturn 50;\r\n\t\t\t}\r\n\t\t\tif (times >= 4 && times <= 10) {\r\n\t\t\t\treturn 10;\r\n\t\t\t}\r\n\t\t\tif (times >= 11 && times <= 20) {\r\n\t\t\t\treturn 5;\r\n\t\t\t}\r\n\t\t\tif (times >= 21) {\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction compareStr(string memory _str, string memory str) public pure returns (bool) {\r\n\t\tif (keccak256(abi.encodePacked(_str)) == keccak256(abi.encodePacked(str))) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n\t/* https://openfair.me */\r\n\t// Empty internal constructor, to prevent people from mistakenly deploying\r\n\t// an instance of this contract, which should be used via inheritance.\r\n\tconstructor() internal {}\r\n\t// solhint-disable-previous-line no-empty-blocks\r\n\r\n\tfunction _msgSender() internal view returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n\t/* https://openfair.me */\r\n\taddress private _owner;\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor () internal {\r\n\t\t_owner = _msgSender();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(isOwner(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns true if the caller is the current owner.\r\n\t */\r\n\tfunction isOwner() public view returns (bool) {\r\n\t\treturn _msgSender() == _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Can only be called by the current owner.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\t\t_owner = newOwner;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n\t/* https://openfair.me */\r\n\tstruct Role {\r\n\t\tmapping(address => bool) bearer;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Give an account access to this role.\r\n\t */\r\n\tfunction add(Role storage role, address account) internal {\r\n\t\trequire(!has(role, account), \"Roles: account already has role\");\r\n\t\trole.bearer[account] = true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove an account's access to this role.\r\n\t */\r\n\tfunction remove(Role storage role, address account) internal {\r\n\t\trequire(has(role, account), \"Roles: account does not have role\");\r\n\t\trole.bearer[account] = false;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Check if an account has this role.\r\n\t * @return bool\r\n\t */\r\n\tfunction has(Role storage role, address account) internal view returns (bool) {\r\n\t\trequire(account != address(0), \"Roles: account is the zero address\");\r\n\t\treturn role.bearer[account];\r\n\t}\r\n}\r\n\r\n/**\r\n * @title WhitelistAdminRole\r\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n */\r\ncontract WhitelistAdminRole is Context, Ownable {\r\n\t/* https://openfair.me */\r\n\tusing Roles for Roles.Role;\r\n\r\n\tRoles.Role private _whitelistAdmins;\r\n\r\n\tconstructor () internal {\r\n\t}\r\n\r\n\tmodifier onlyWhitelistAdmin() {\r\n\t\trequire(isWhitelistAdmin(_msgSender()) || isOwner(), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction isWhitelistAdmin(address account) public view returns (bool) {\r\n\t\treturn _whitelistAdmins.has(account) || isOwner();\r\n\t}\r\n\r\n\tfunction addWhitelistAdmin(address account) public onlyOwner {\r\n\t\t_whitelistAdmins.add(account);\r\n\t}\r\n\r\n\tfunction removeWhitelistAdmin(address account) public onlyOwner {\r\n\t\t_whitelistAdmins.remove(account);\r\n\t}\r\n}\r\n\r\ncontract OpenFair is UtilOpenFair, WhitelistAdminRole {\r\n\t/* https://openfair.me */\r\n\tusing SafeMath for *;\r\n\tuint ethWei = 1 ether;\r\n\taddress payable private devAddr = address(0xcff60168c81DD3aB8c128e119229348d8ac145ee);\r\n\taddress payable private comfortAddr = address(0x67cd378709cf6CBEBCAc7D71A924acEa33627fb8);\r\n\r\n\tstruct User {\r\n\t\tuint id;\r\n\t\taddress userAddress;\r\n\t\tuint freeAmount;\r\n\t\tuint freezeAmount;\r\n\t\tuint lineAmount;\r\n\t\tuint inviteAmonut;\r\n\t\tuint dayBonusAmount;\r\n\t\tuint bonusAmount;\r\n\t\tuint level;\r\n\t\tuint lineLevel;\r\n\t\tuint resTime;\r\n\t\tuint investTimes;\r\n\t\tstring inviteCode;\r\n\t\tstring beCode;\r\n\t\tuint rewardIndex;\r\n\t\tuint lastRwTime;\r\n\t}\r\n\r\n\tstruct UserGlobal {\r\n\t\tuint id;\r\n\t\taddress userAddress;\r\n\t\tstring inviteCode;\r\n\t\tstring beCode;\r\n\t\tuint status;\r\n\t}\r\n\r\n\tstruct AwardData {\r\n\t\tuint oneInvAmount;\r\n\t\tuint twoInvAmount;\r\n\t\tuint threeInvAmount;\r\n\t}\r\n\r\n\tuint startTime;\r\n\tuint lineStatus = 0;\r\n\tmapping(uint => uint) rInvestCount;\r\n\tmapping(uint => uint) rInvestMoney;\r\n\tuint period = 1 days;\r\n\tuint uid = 0;\r\n\tuint rid = 1;\r\n\tmapping(uint => uint[]) lineArrayMapping;\r\n\tmapping(uint => mapping(address => User)) userRoundMapping;\r\n\tmapping(address => UserGlobal) userMapping;\r\n\tmapping(string => address) addressMapping;\r\n\tmapping(uint => address) indexMapping;\r\n\tmapping(uint => mapping(address => mapping(uint => AwardData))) userAwardDataMapping;\r\n\tuint bonuslimit = 15 ether;\r\n\tuint sendLimit = 100 ether;\r\n\tuint withdrawLimit = 15 ether;\r\n\tuint canImport = 1;\r\n\tuint canSetStartTime = 1;\r\n\r\n\tmodifier isHuman() {\r\n\t\taddress addr = msg.sender;\r\n\t\tuint codeLength;\r\n\t\tassembly {codeLength := extcodesize(addr)}\r\n\t\trequire(codeLength == 0, \"sorry humans only\");\r\n\t\trequire(tx.origin == msg.sender, \"sorry, humans only\");\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor () public {\r\n\t}\r\n\r\n\tfunction() external payable {\r\n\t}\r\n\r\n\tfunction verydangerous(uint time) external onlyOwner {\r\n\t\trequire(canSetStartTime == 1, \"verydangerous, limited!\");\r\n\t\trequire(time > now, \"no, verydangerous\");\r\n\t\tstartTime = time;\r\n\t\tcanSetStartTime = 0;\r\n\t}\r\n\r\n\tfunction donnotimitate() public view returns (bool) {\r\n\t\treturn startTime != 0 && now > startTime;\r\n\t}\r\n\r\n\tfunction updateLine(uint line) external onlyWhitelistAdmin {\r\n\t\tlineStatus = line;\r\n\t}\r\n\r\n\tfunction isLine() private view returns (bool) {\r\n\t\treturn lineStatus != 0;\r\n\t}\r\n\r\n\tfunction actAllLimit(uint bonusLi, uint sendLi, uint withdrawLi) external onlyOwner {\r\n\t\trequire(bonusLi >= 15 ether && sendLi >= 100 ether && withdrawLi >= 15 ether, \"invalid amount\");\r\n\t\tbonuslimit = bonusLi;\r\n\t\tsendLimit = sendLi;\r\n\t\twithdrawLimit = withdrawLi;\r\n\t}\r\n\r\n\tfunction stopImport() external onlyOwner {\r\n\t\tcanImport = 0;\r\n\t}\r\n\r\n\tfunction actUserStatus(address addr, uint status) external onlyWhitelistAdmin {\r\n\t\trequire(status == 0 || status == 1 || status == 2, \"bad parameter status\");\r\n\t\tUserGlobal storage userGlobal = userMapping[addr];\r\n\t\tuserGlobal.status = status;\r\n\t}\r\n\r\n\tfunction exit(string memory inviteCode, string memory beCode) public isHuman() payable {\r\n\t\trequire(donnotimitate(), \"no, donnotimitate\");\r\n\t\trequire(msg.value >= 1 * ethWei && msg.value <= 15 * ethWei, \"between 1 and 15\");\r\n\t\trequire(msg.value == msg.value.div(ethWei).mul(ethWei), \"invalid msg value\");\r\n\r\n\t\tUserGlobal storage userGlobal = userMapping[msg.sender];\r\n\t\tif (userGlobal.id == 0) {\r\n\t\t\trequire(!compareStr(inviteCode, \"\") && bytes(inviteCode).length == 6, \"invalid invite code\");\r\n\t\t\taddress beCodeAddr = addressMapping[beCode];\r\n\t\t\trequire(isUsed(beCode), \"beCode not exist\");\r\n\t\t\trequire(beCodeAddr != msg.sender, \"beCodeAddr can't be self\");\r\n\t\t\trequire(!isUsed(inviteCode), \"invite code is used\");\r\n\t\t\tregisterUser(msg.sender, inviteCode, beCode);\r\n\t\t}\r\n\t\tuint investAmout;\r\n\t\tuint lineAmount;\r\n\t\tif (isLine()) {\r\n\t\t\tlineAmount = msg.value;\r\n\t\t} else {\r\n\t\t\tinvestAmout = msg.value;\r\n\t\t}\r\n\t\tUser storage user = userRoundMapping[rid][msg.sender];\r\n\t\tif (user.id != 0) {\r\n\t\t\trequire(user.freezeAmount.add(user.lineAmount) == 0, \"only once invest\");\r\n\t\t\tuser.freezeAmount = investAmout;\r\n\t\t\tuser.lineAmount = lineAmount;\r\n\t\t\tuser.level = getLevel(user.freezeAmount);\r\n\t\t\tuser.lineLevel = getNodeLevel(user.freezeAmount.add(user.freeAmount).add(user.lineAmount));\r\n\t\t} else {\r\n\t\t\tuser.id = userGlobal.id;\r\n\t\t\tuser.userAddress = msg.sender;\r\n\t\t\tuser.freezeAmount = investAmout;\r\n\t\t\tuser.level = getLevel(investAmout);\r\n\t\t\tuser.lineAmount = lineAmount;\r\n\t\t\tuser.lineLevel = getNodeLevel(user.freezeAmount.add(user.freeAmount).add(user.lineAmount));\r\n\t\t\tuser.inviteCode = userGlobal.inviteCode;\r\n\t\t\tuser.beCode = userGlobal.beCode;\r\n\t\t}\r\n\r\n\t\trInvestCount[rid] = rInvestCount[rid].add(1);\r\n\t\trInvestMoney[rid] = rInvestMoney[rid].add(msg.value);\r\n\t\tif (!isLine()) {\r\n\t\t\tsendFeetoAdmin(msg.value);\r\n\t\t\tcountBonus(user.userAddress);\r\n\t\t} else {\r\n\t\t\tlineArrayMapping[rid].push(user.id);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction importGlobal(address addr, string calldata inviteCode, string calldata beCode) external onlyWhitelistAdmin {\r\n\t\trequire(canImport == 1, \"import stopped\");\r\n\t\tUserGlobal storage user = userMapping[addr];\r\n\t\trequire(user.id == 0, \"user already exists\");\r\n\t\trequire(!compareStr(inviteCode, \"\"), \"empty invite code\");\r\n\t\tif (uid != 0) {\r\n\t\t\trequire(!compareStr(beCode, \"\"), \"empty beCode\");\r\n\t\t}\r\n\t\taddress beCodeAddr = addressMapping[beCode];\r\n\t\trequire(beCodeAddr != addr, \"beCodeAddr can't be self\");\r\n\t\trequire(!isUsed(inviteCode), \"invite code is used\");\r\n\r\n\t\tregisterUser(addr, inviteCode, beCode);\r\n\t}\r\n\r\n\tfunction helloworld(uint start, uint end, uint isUser) external onlyWhitelistAdmin {\r\n\t\tfor (uint i = start; i <= end; i++) {\r\n\t\t\tuint userId = 0;\r\n\t\t\tif (isUser == 0) {\r\n\t\t\t\tuserId = lineArrayMapping[rid][i];\r\n\t\t\t} else {\r\n\t\t\t\tuserId = i;\r\n\t\t\t}\r\n\t\t\taddress userAddr = indexMapping[userId];\r\n\t\t\tUser storage user = userRoundMapping[rid][userAddr];\r\n\t\t\tif (user.freezeAmount == 0 && user.lineAmount >= 1 ether && user.lineAmount <= 15 ether) {\r\n\t\t\t\tuser.freezeAmount = user.lineAmount;\r\n\t\t\t\tuser.level = getLevel(user.freezeAmount);\r\n\t\t\t\tuser.lineAmount = 0;\r\n\t\t\t\tsendFeetoAdmin(user.freezeAmount);\r\n\t\t\t\tcountBonus(user.userAddress);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction countBonus(address userAddr) private {\r\n\t\tUser storage user = userRoundMapping[rid][userAddr];\r\n\t\tif (user.id == 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tuint scale = getScByLevel(user.level);\r\n\t\tuser.dayBonusAmount = user.freezeAmount.mul(scale).div(1000);\r\n\t\tuser.investTimes = 0;\r\n\t\tUserGlobal memory userGlobal = userMapping[userAddr];\r\n\t\tif (user.freezeAmount >= 1 ether && user.freezeAmount <= bonuslimit && userGlobal.status == 0) {\r\n\t\t\tgetaway(user.beCode, user.freezeAmount, scale);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getaway(string memory beCode, uint money, uint shareSc) private {\r\n\t\tstring memory tmpReferrer = beCode;\r\n\r\n\t\tfor (uint i = 1; i <= 25; i++) {\r\n\t\t\tif (compareStr(tmpReferrer, \"\")) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\taddress tmpUserAddr = addressMapping[tmpReferrer];\r\n\t\t\tUserGlobal storage userGlobal = userMapping[tmpUserAddr];\r\n\t\t\tUser storage calUser = userRoundMapping[rid][tmpUserAddr];\r\n\r\n\t\t\tif (calUser.freezeAmount.add(calUser.freeAmount).add(calUser.lineAmount) == 0) {\r\n\t\t\t\ttmpReferrer = userGlobal.beCode;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tuint recommendSc = getRecommendScaleByLevelAndTim(3, i);\r\n\t\t\tuint moneyResult = 0;\r\n\t\t\tif (money <= 15 ether) {\r\n\t\t\t\tmoneyResult = money;\r\n\t\t\t} else {\r\n\t\t\t\tmoneyResult = 15 ether;\r\n\t\t\t}\r\n\r\n\t\t\tif (recommendSc != 0) {\r\n\t\t\t\tuint tmpDynamicAmount = moneyResult.mul(shareSc).mul(recommendSc);\r\n\t\t\t\ttmpDynamicAmount = tmpDynamicAmount.div(1000).div(100);\r\n\t\t\t\tearneth(userGlobal.userAddress, tmpDynamicAmount, calUser.rewardIndex, i);\r\n\t\t\t}\r\n\t\t\ttmpReferrer = userGlobal.beCode;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction earneth(address userAddr, uint dayInvAmount, uint rewardIndex, uint times) private {\r\n\t\tfor (uint i = 0; i < 5; i++) {\r\n\t\t\tAwardData storage awData = userAwardDataMapping[rid][userAddr][rewardIndex.add(i)];\r\n\t\t\tif (times == 1) {\r\n\t\t\t\tawData.oneInvAmount += dayInvAmount;\r\n\t\t\t}\r\n\t\t\tif (times == 2) {\r\n\t\t\t\tawData.twoInvAmount += dayInvAmount;\r\n\t\t\t}\r\n\t\t\tawData.threeInvAmount += dayInvAmount;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction happy() public isHuman() {\r\n\t\trequire(donnotimitate(), \"no donnotimitate\");\r\n\t\tUser storage user = userRoundMapping[rid][msg.sender];\r\n\t\trequire(user.id != 0, \"user not exist\");\r\n\t\tuint sendMoney = user.freeAmount + user.lineAmount;\r\n\t\tbool isEnough = false;\r\n\t\tuint resultMoney = 0;\r\n\r\n\t\t(isEnough, resultMoney) = isEnoughBalance(sendMoney);\r\n\r\n\t\tif (resultMoney > 0 && resultMoney <= withdrawLimit) {\r\n\t\t\tsendMoneyToUser(msg.sender, resultMoney);\r\n\t\t\tuser.freeAmount = 0;\r\n\t\t\tuser.lineAmount = 0;\r\n\t\t\tuser.lineLevel = getNodeLevel(user.freezeAmount);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction christmas(uint start, uint end) external onlyWhitelistAdmin {\r\n\t\tfor (uint i = start; i <= end; i++) {\r\n\t\t\taddress userAddr = indexMapping[i];\r\n\t\t\tUser storage user = userRoundMapping[rid][userAddr];\r\n\t\t\tUserGlobal memory userGlobal = userMapping[userAddr];\r\n\t\t\tif (now.sub(user.lastRwTime) <= 12 hours) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tuser.lastRwTime = now;\r\n\t\t\tif (userGlobal.status == 1) {\r\n\t\t\t\tuser.rewardIndex = user.rewardIndex.add(1);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tuint bonusSend = 0;\r\n\t\t\tif (user.id != 0 && user.freezeAmount >= 1 ether && user.freezeAmount <= bonuslimit) {\r\n\t\t\t\tif (user.investTimes < 5) {\r\n\t\t\t\t\tbonusSend += user.dayBonusAmount;\r\n\t\t\t\t\tuser.bonusAmount = user.bonusAmount.add(bonusSend);\r\n\t\t\t\t\tuser.investTimes = user.investTimes.add(1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tuser.freeAmount = user.freeAmount.add(user.freezeAmount);\r\n\t\t\t\t\tuser.freezeAmount = 0;\r\n\t\t\t\t\tuser.dayBonusAmount = 0;\r\n\t\t\t\t\tuser.level = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tuint lineAmount = user.freezeAmount.add(user.freeAmount).add(user.lineAmount);\r\n\t\t\tif (lineAmount < 1 ether || lineAmount > withdrawLimit) {\r\n\t\t\t\tuser.rewardIndex = user.rewardIndex.add(1);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tuint inviteSend = 0;\r\n\t\t\tif (userGlobal.status == 0) {\r\n\t\t\t\tAwardData memory awData = userAwardDataMapping[rid][userAddr][user.rewardIndex];\r\n\t\t\t\tuser.rewardIndex = user.rewardIndex.add(1);\r\n\t\t\t\tuint lineValue = lineAmount.div(ethWei);\r\n\t\t\t\tif (lineValue >= 15) {\r\n\t\t\t\t\tinviteSend += awData.threeInvAmount;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (user.lineLevel == 1 && lineAmount >= 1 ether && awData.oneInvAmount > 0) {\r\n\t\t\t\t\t\tinviteSend += awData.oneInvAmount.div(15).mul(lineValue).div(2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (user.lineLevel == 2 && lineAmount >= 6 ether && (awData.oneInvAmount > 0 || awData.twoInvAmount > 0)) {\r\n\t\t\t\t\t\tinviteSend += awData.oneInvAmount.div(15).mul(lineValue).mul(7).div(10);\r\n\t\t\t\t\t\tinviteSend += awData.twoInvAmount.div(15).mul(lineValue).mul(5).div(7);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (user.lineLevel == 3 && lineAmount >= 11 ether && awData.threeInvAmount > 0) {\r\n\t\t\t\t\t\tinviteSend += awData.threeInvAmount.div(15).mul(lineValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (user.lineLevel < 3) {\r\n\t\t\t\t\t\tuint fireSc = getFireScByLevel(user.lineLevel);\r\n\t\t\t\t\t\tinviteSend = inviteSend.mul(fireSc).div(10);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (userGlobal.status == 2) {\r\n\t\t\t\tuser.rewardIndex = user.rewardIndex.add(1);\r\n\t\t\t}\r\n\r\n\t\t\tif (bonusSend.add(inviteSend) <= sendLimit) {\r\n\t\t\t\tuser.inviteAmonut = user.inviteAmonut.add(inviteSend);\r\n\t\t\t\tbool isEnough = false;\r\n\t\t\t\tuint resultMoney = 0;\r\n\t\t\t\t(isEnough, resultMoney) = isEnoughBalance(bonusSend.add(inviteSend));\r\n\t\t\t\tif (resultMoney > 0) {\r\n\t\t\t\t\tuint confortMoney = resultMoney.div(10);\r\n\t\t\t\t\tsendMoneyToUser(comfortAddr, confortMoney);\r\n\t\t\t\t\tresultMoney = resultMoney.sub(confortMoney);\r\n\t\t\t\t\taddress payable sendAddr = address(uint160(userAddr));\r\n\t\t\t\t\tsendMoneyToUser(sendAddr, resultMoney);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction isEnoughBalance(uint sendMoney) private view returns (bool, uint){\r\n\t\tif (sendMoney >= address(this).balance) {\r\n\t\t\treturn (false, address(this).balance);\r\n\t\t} else {\r\n\t\t\treturn (true, sendMoney);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction sendFeetoAdmin(uint amount) private {\r\n\t\tdevAddr.transfer(amount.div(25));\r\n\t}\r\n\r\n\tfunction sendMoneyToUser(address payable userAddress, uint money) private {\r\n\t\tif (money > 0) {\r\n\t\t\tuserAddress.transfer(money);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction isUsed(string memory code) public view returns (bool) {\r\n\t\taddress addr = addressMapping[code];\r\n\t\treturn uint(addr) != 0;\r\n\t}\r\n\r\n\tfunction getUserAddressByCode(string memory code) public view returns (address) {\r\n\t\trequire(isWhitelistAdmin(msg.sender), \"Permission denied\");\r\n\t\treturn addressMapping[code];\r\n\t}\r\n\r\n\tfunction registerUser(address addr, string memory inviteCode, string memory beCode) private {\r\n\t\tUserGlobal storage userGlobal = userMapping[addr];\r\n\t\tuid++;\r\n\t\tuserGlobal.id = uid;\r\n\t\tuserGlobal.userAddress = addr;\r\n\t\tuserGlobal.inviteCode = inviteCode;\r\n\t\tuserGlobal.beCode = beCode;\r\n\r\n\t\taddressMapping[inviteCode] = addr;\r\n\t\tindexMapping[uid] = addr;\r\n\t}\r\n\r\n\tfunction endRound() external onlyOwner {\r\n\t\trequire(address(this).balance < 1 ether, \"contract balance must be lower than 1 ether\");\r\n\t\trid++;\r\n\t\tstartTime = now.add(period).div(1 days).mul(1 days);\r\n\t\tcanSetStartTime = 1;\r\n\t}\r\n\r\n\tfunction donnottouch() public view returns (uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint, uint) {\r\n\t\treturn (\r\n\t\trid,\r\n\t\tuid,\r\n\t\tstartTime,\r\n\t\trInvestCount[rid],\r\n\t\trInvestMoney[rid],\r\n\t\tbonuslimit,\r\n\t\tsendLimit,\r\n\t\twithdrawLimit,\r\n\t\tcanImport,\r\n\t\tlineStatus,\r\n\t\tlineArrayMapping[rid].length,\r\n\t\tcanSetStartTime\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getUserByAddress(address addr, uint roundId) public view returns (uint[14] memory info, string memory inviteCode, string memory beCode) {\r\n\t\trequire(isWhitelistAdmin(msg.sender) || msg.sender == addr, \"Permission denied for view user's privacy\");\r\n\r\n\t\tif (roundId == 0) {\r\n\t\t\troundId = rid;\r\n\t\t}\r\n\r\n\t\tUserGlobal memory userGlobal = userMapping[addr];\r\n\t\tUser memory user = userRoundMapping[roundId][addr];\r\n\t\tinfo[0] = userGlobal.id;\r\n\t\tinfo[1] = user.lineAmount;\r\n\t\tinfo[2] = user.freeAmount;\r\n\t\tinfo[3] = user.freezeAmount;\r\n\t\tinfo[4] = user.inviteAmonut;\r\n\t\tinfo[5] = user.bonusAmount;\r\n\t\tinfo[6] = user.lineLevel;\r\n\t\tinfo[7] = user.dayBonusAmount;\r\n\t\tinfo[8] = user.rewardIndex;\r\n\t\tinfo[9] = user.investTimes;\r\n\t\tinfo[10] = user.level;\r\n\t\tuint grantAmount = 0;\r\n\t\tif (user.id > 0 && user.freezeAmount >= 1 ether && user.freezeAmount <= bonuslimit && user.investTimes < 5 && userGlobal.status != 1) {\r\n\t\t\tgrantAmount += user.dayBonusAmount;\r\n\t\t}\r\n\t\tif (userGlobal.status == 0) {\r\n\t\t\tuint inviteSend = 0;\r\n\t\t\tAwardData memory awData = userAwardDataMapping[rid][user.userAddress][user.rewardIndex];\r\n\t\t\tuint lineAmount = user.freezeAmount.add(user.freeAmount).add(user.lineAmount);\r\n\t\t\tif (lineAmount >= 1 ether) {\r\n\t\t\t\tuint lineValue = lineAmount.div(ethWei);\r\n\t\t\t\tif (lineValue >= 15) {\r\n\t\t\t\t\tinviteSend += awData.threeInvAmount;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (user.lineLevel == 1 && lineAmount >= 1 ether && awData.oneInvAmount > 0) {\r\n\t\t\t\t\t\tinviteSend += awData.oneInvAmount.div(15).mul(lineValue).div(2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (user.lineLevel == 2 && lineAmount >= 1 ether && (awData.oneInvAmount > 0 || awData.twoInvAmount > 0)) {\r\n\t\t\t\t\t\tinviteSend += awData.oneInvAmount.div(15).mul(lineValue).mul(7).div(10);\r\n\t\t\t\t\t\tinviteSend += awData.twoInvAmount.div(15).mul(lineValue).mul(5).div(7);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (user.lineLevel == 3 && lineAmount >= 1 ether && awData.threeInvAmount > 0) {\r\n\t\t\t\t\t\tinviteSend += awData.threeInvAmount.div(15).mul(lineValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (user.lineLevel < 3) {\r\n\t\t\t\t\t\tuint fireSc = getFireScByLevel(user.lineLevel);\r\n\t\t\t\t\t\tinviteSend = inviteSend.mul(fireSc).div(10);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tgrantAmount += inviteSend;\r\n\t\t\t}\r\n\t\t}\r\n\t\tinfo[11] = grantAmount;\r\n\t\tinfo[12] = user.lastRwTime;\r\n\t\tinfo[13] = userGlobal.status;\r\n\r\n\t\treturn (info, userGlobal.inviteCode, userGlobal.beCode);\r\n\t}\r\n\r\n\tfunction getUserAddressById(uint id) public view returns (address) {\r\n\t\trequire(isWhitelistAdmin(msg.sender), \"Permission denied\");\r\n\t\treturn indexMapping[id];\r\n\t}\r\n\r\n\tfunction getLineUserId(uint index, uint rouId) public view returns (uint) {\r\n\t\trequire(isWhitelistAdmin(msg.sender), \"Permission denied\");\r\n\t\tif (rouId == 0) {\r\n\t\t\trouId = rid;\r\n\t\t}\r\n\t\treturn lineArrayMapping[rid][index];\r\n\t}\r\n}\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that revert on error\r\n*/\r\nlibrary SafeMath {\r\n\t/* https://openfair.me */\r\n\t/**\r\n\t* @dev Multiplies two numbers, reverts on overflow.\r\n\t*/\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a * b;\r\n\t\trequire(c / a == b, \"mul overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n\t*/\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b > 0, \"div zero\");\r\n\t\t// Solidity only automatically asserts when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n\t*/\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b <= a, \"lower sub bigger\");\r\n\t\tuint256 c = a - b;\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Adds two numbers, reverts on overflow.\r\n\t*/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"overflow\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n\t* reverts when dividing by zero.\r\n\t*/\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b != 0, \"mod zero\");\r\n\t\treturn a % b;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev compare two numbers and returns the smaller one.\r\n\t*/\r\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a > b ? b : a;\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"getNodeLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"getRecommendScaleByLevelAndTim\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inviteCode\",\"type\":\"string\"},{\"name\":\"beCode\",\"type\":\"string\"}],\"name\":\"exit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopImport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getUserByAddress\",\"outputs\":[{\"name\":\"info\",\"type\":\"uint256[14]\"},{\"name\":\"inviteCode\",\"type\":\"string\"},{\"name\":\"beCode\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"rouId\",\"type\":\"uint256\"}],\"name\":\"getLineUserId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"verydangerous\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"code\",\"type\":\"string\"}],\"name\":\"isUsed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"christmas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donnottouch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"getLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_str\",\"type\":\"string\"},{\"name\":\"str\",\"type\":\"string\"}],\"name\":\"compareStr\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUserAddressById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"actUserStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"line\",\"type\":\"uint256\"}],\"name\":\"updateLine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"code\",\"type\":\"string\"}],\"name\":\"getUserAddressByCode\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"isUser\",\"type\":\"uint256\"}],\"name\":\"helloworld\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bonusLi\",\"type\":\"uint256\"},{\"name\":\"sendLi\",\"type\":\"uint256\"},{\"name\":\"withdrawLi\",\"type\":\"uint256\"}],\"name\":\"actAllLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"inviteCode\",\"type\":\"string\"},{\"name\":\"beCode\",\"type\":\"string\"}],\"name\":\"importGlobal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getFireScByLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"happy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donnotimitate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getScByLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"OpenFair","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://110909248871b4e50c43d2039a1ff47c855a133d761e0938877efce9e7d421e0"}]}