{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Kryptium House Smart Contract v.3.0.0\r\n * Copyright Â© 2019 Kryptium Team <info@kryptium.io>\r\n * Author: Giannis Zarifis <jzarifis@kryptium.io>\r\n * \r\n * A decentralised betting house in the form of an Ethereum smart contract which \r\n * registers bets, escrows the amounts wagered and transfers funds following the \r\n * outcomes of the corresponding events. It can be fully autonomous or managed \r\n * and might charge a commission for its services.\r\n *\r\n * This program is free to use according the Terms of Use available at\r\n * <https://kryptium.io/terms-of-use/>. You cannot resell it or copy any\r\n * part of it or modify it without permission from the Kryptium Team.\r\n *\r\n * This program is distributed in the hope that it will be useful, but WITHOUT \r\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\r\n * FOR A PARTICULAR PURPOSE. See the Terms of Use for more details.\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * SafeMath\r\n * Math operations with safety checks that throw on error\r\n */\r\ncontract SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b != 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mulByFraction(uint256 number, uint256 numerator, uint256 denominator) internal pure returns (uint256) {\r\n        return div(mul(number, numerator), denominator);\r\n    }\r\n}\r\n\r\ncontract Owned {\r\n\r\n    address payable public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable newOwner) onlyOwner public {\r\n        require(newOwner != address(0x0));\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/*\r\nOracle smart contract interface\r\n*/\r\ninterface OracleContract {\r\n    function getEventOutputPossibleResultsCount(uint id, uint outputId) external view returns(uint possibleResultsCount); \r\n    function getOracleVersion() external view returns(uint version);\r\n    function owner() external view returns (address);\r\n    function getEventDataForHouse(uint id, uint outputId) external view returns(uint startDateTime, uint outputDateTime, bool isCancelled, uint timeStamp);\r\n    function getEventOutcomeIsSet(uint eventId, uint outputId) external view returns (bool isSet);\r\n    function getEventOutcome(uint eventId, uint outputId) external view returns (uint outcome); \r\n    function getEventOutcomeNumeric(uint eventId, uint outputId) external view returns(uint256 outcome1, uint256 outcome2,uint256 outcome3,uint256 outcome4, uint256 outcome5, uint256 outcome6);\r\n}\r\n\r\n/*\r\nHouse smart contract interface\r\n*/\r\ninterface HouseContract {\r\n    function owner() external view returns (address payable); \r\n    function isHouse() external view returns (bool); \r\n}\r\n\r\n\r\n\r\n/*\r\n * Kryptium House Smart Contract.\r\n */\r\ncontract House is SafeMath, Owned {\r\n\r\n    uint constant mimumumSupportedOracle = 105;\r\n\r\n    enum BetType { headtohead, multiuser, poolbet }\r\n\r\n    enum BetEvent { placeBet, callBet, removeBet, refuteBet, settleWinnedBet, settleCancelledBet, increaseWager, cancelledByHouse }\r\n\r\n    uint private betNextId;\r\n\r\n\r\n\r\n\r\n    struct Bet { \r\n        address oracleAddress;\r\n        uint256 dataCombined;\r\n        bool isOutcomeSet;\r\n        bool isCancelled;\r\n        uint256 minimumWager;\r\n        uint256 maximumWager;\r\n        address createdBy;\r\n        BetType betType;\r\n    } \r\n\r\n    struct HouseData { \r\n        bool managed;\r\n        string  name;\r\n        string  creatorName;\r\n        address oracleAddress;\r\n        address oldOracleAddress;       \r\n        bool  newBetsPaused;\r\n        uint  housePercentage;\r\n        uint oraclePercentage;   \r\n        uint version;\r\n        string shortMessage;          \r\n    } \r\n\r\n    address public _newHouseAddress;\r\n\r\n    HouseData public houseData;  \r\n\r\n    // This creates an array with all bets\r\n    mapping (uint => Bet) public bets;\r\n\r\n    // User balances\r\n    mapping (address => uint256) public balance;\r\n\r\n\r\n    //Last betting activity timestamp\r\n    uint public lastBettingActivity;\r\n\r\n    uint public closeBeforeStartTime;\r\n        \r\n    uint public closeEventOutcomeTime;  \r\n\r\n    //Total amount on Bet\r\n    mapping (uint => uint256) public betTotalAmount;\r\n\r\n    //Totalbets on bet\r\n    mapping (uint => uint) public betTotalBets;\r\n\r\n    //Bet Refutes amount\r\n    mapping (uint => uint256) public betRefutedAmount;\r\n\r\n    //Total amount placed on a bet forecast\r\n    mapping (uint => mapping (uint => uint256)) public betForcastTotalAmount;    \r\n\r\n    //Player bet total amount on a Bet\r\n    mapping (address => mapping (uint => uint256)) public playerBetTotalAmount;\r\n\r\n    //Player bet total bets on a Bet\r\n    mapping (address => mapping (uint => uint)) public playerBetTotalBets;\r\n\r\n    //Player wager for a Bet.Output.Forecast\r\n    mapping (address => mapping (uint => mapping (uint => uint256))) public playerBetForecastWager;\r\n\r\n    //head to head bets forecasts\r\n    mapping (uint => mapping (address => uint)) public headToHeadForecasts;  \r\n\r\n    //Player bet Refuted\r\n    mapping (address => mapping (uint => bool)) public playerBetRefuted;    \r\n\r\n    //Player bet Settled\r\n    mapping (address => mapping (uint => bool)) public playerBetSettled; \r\n\r\n    //The House and Oracle edge has been paid\r\n    mapping (uint => bool) public housePaid;\r\n\r\n    //Player has placed at leat one bet\r\n    mapping (address => bool) public playerHasBet;\r\n\r\n    // Notifies clients that a new house is launched\r\n    event HouseCreated();\r\n\r\n    // Notifies clients that a house data has changed\r\n    event HousePropertiesUpdated();    \r\n\r\n    event BetPlacedOrModified(uint id, address sender, BetEvent betEvent, uint256 amount, uint forecast, string createdBy, uint closeDateTime);\r\n\r\n\r\n    event transfer(address indexed wallet, uint256 amount,bool inbound);\r\n\r\n\r\n    /**\r\n     * Constructor function\r\n     * Initializes House contract\r\n     */\r\n    constructor(bool managed, string memory houseName, string memory houseCreatorName, address oracleAddress, uint housePercentage,uint oraclePercentage, uint closeTime, uint freezeTime, uint version) public {\r\n        require(add(housePercentage,oraclePercentage)<1000,\"House + Oracle percentage should be lower than 100%\");\r\n        require(OracleContract(oracleAddress).getOracleVersion() >= mimumumSupportedOracle , \"Oracle version don't supported\");\r\n        houseData.managed = managed;\r\n        houseData.name = houseName;\r\n        houseData.creatorName = houseCreatorName;\r\n        houseData.housePercentage = housePercentage;\r\n        houseData.oraclePercentage = oraclePercentage; \r\n        houseData.oracleAddress = oracleAddress;      \r\n        houseData.shortMessage = \"\";\r\n        houseData.newBetsPaused = true;\r\n        houseData.version = version;\r\n\r\n        closeBeforeStartTime = closeTime;\r\n        closeEventOutcomeTime = freezeTime;\r\n\r\n        emit HouseCreated();\r\n    }\r\n\r\n\r\n    function getBetInternal(uint id) public view returns (uint eventId, uint outputId, uint outcome, uint closeDateTime, uint freezeDateTime, uint payoutRate, uint timeStamp) {\r\n        uint256 dataCombined = bets[id].dataCombined;\r\n        return (uint32(dataCombined), uint32(dataCombined >> 32), uint32(dataCombined >> 64), uint32(dataCombined >> 96), uint32(dataCombined >> 128), uint24(dataCombined >> 160), uint32(dataCombined >> 184));\r\n    }\r\n\r\n    function getBetEventId(uint id) public view returns (uint eventId) {\r\n        return (uint32(bets[id].dataCombined));\r\n    }\r\n\r\n    function getBetEventOutputId(uint id) public view returns (uint eventOutputId) {\r\n        return (uint32(bets[id].dataCombined >> 32));\r\n    }\r\n\r\n    function getBetOutcome(uint id) public view returns (uint eventOutcome) {\r\n        return (uint32(bets[id].dataCombined >> 64));\r\n    }\r\n\r\n    function getBetCloseTime(uint id) public view returns (uint betCloseTime) {\r\n        return (uint32(bets[id].dataCombined >> 96));\r\n    }\r\n\r\n    function getBetFreezeTime(uint id) public view returns (uint betFreezeTime) {\r\n        return (uint32(bets[id].dataCombined >> 128));\r\n    }\r\n\r\n    function getBetPayoutRate(uint id) public view returns (uint eventId) {\r\n        return (uint24(bets[id].dataCombined >> 160));\r\n    }\r\n\r\n    function getBetEventTimeStamp(uint id) public view returns (uint timeStamp) {\r\n        return (uint32(bets[id].dataCombined >> 184));\r\n    }\r\n\r\n    function setBetInternal(uint id, uint eventId, uint outputId, uint outcome, uint closeDateTime, uint freezeDateTime, uint payoutRate, uint timeStamp) private {\r\n        bets[id].dataCombined = (eventId & 0xFFFFFFFF) | ((outputId & 0xFFFFFFFF) << 32) | ((outcome & 0xFFFFFFFF) << 64) | ((closeDateTime & 0xFFFFFFFF) << 96) | ((freezeDateTime & 0xFFFFFFFF) << 128 | ((payoutRate & 0xFFFFFF) << 160) | ((timeStamp & 0xFFFFFFFF) << 184));\r\n    }\r\n\r\n    function setBetEventTimeStamp(uint id, uint timeStamp) private {\r\n        (uint  eventId, uint  outputId, uint  outcome, uint  closeDateTime, uint freezeDateTime, uint payoutRate, ) = getBetInternal(id);\r\n        bets[id].dataCombined = (eventId & 0xFFFFFFFF) | ((outputId & 0xFFFFFFFF) << 32) | ((outcome & 0xFFFFFFFF) << 64) | ((closeDateTime & 0xFFFFFFFF) << 96) | ((freezeDateTime & 0xFFFFFFFF) << 128) | ((payoutRate & 0xFFFFFF) << 160) | ((timeStamp & 0xFFFFFFFF) << 184);\r\n    }\r\n\r\n    function setBetEventId(uint id, uint eventId) private {\r\n        (, uint  outputId, uint  outcome, uint  closeDateTime, uint freezeDateTime, uint payoutRate, uint timeStamp) = getBetInternal(id);\r\n        bets[id].dataCombined = (eventId & 0xFFFFFFFF) | ((outputId & 0xFFFFFFFF) << 32) | ((outcome & 0xFFFFFFFF) << 64) | ((closeDateTime & 0xFFFFFFFF) << 96) | ((freezeDateTime & 0xFFFFFFFF) << 128) | ((payoutRate & 0xFFFFFF) << 160) | ((timeStamp & 0xFFFFFFFF) << 184);\r\n    }\r\n\r\n    function setBetEventOutputId(uint id, uint outputId) private {\r\n        (uint  eventId, , uint  outcome, uint  closeDateTime, uint freezeDateTime, uint payoutRate, uint timeStamp ) = getBetInternal(id);\r\n        bets[id].dataCombined = (eventId & 0xFFFFFFFF) | ((outputId & 0xFFFFFFFF) << 32) | ((outcome & 0xFFFFFFFF) << 64) | ((closeDateTime & 0xFFFFFFFF) << 96) | ((freezeDateTime & 0xFFFFFFFF) << 128) | ((payoutRate & 0xFFFFFF) << 160) | ((timeStamp & 0xFFFFFFFF) << 184);\r\n    }\r\n\r\n    function setBetOutcome(uint id, uint outcome) private {\r\n        (uint  eventId, uint  outputId, , uint  closeDateTime, uint freezeDateTime, uint payoutRate, uint timeStamp) = getBetInternal(id);\r\n        bets[id].dataCombined = (eventId & 0xFFFFFFFF) | ((outputId & 0xFFFFFFFF) << 32) | ((outcome & 0xFFFFFFFF) << 64) | ((closeDateTime & 0xFFFFFFFF) << 96) | ((freezeDateTime & 0xFFFFFFFF) << 128) | ((payoutRate & 0xFFFFFF) << 160) | ((timeStamp & 0xFFFFFFFF) << 184);\r\n    }\r\n\r\n    function setBetCloseTime(uint id, uint closeDateTime) private {\r\n        (uint  eventId, uint  outputId, uint  outcome, , uint freezeDateTime, uint payoutRate, uint timeStamp) = getBetInternal(id);\r\n        bets[id].dataCombined = (eventId & 0xFFFFFFFF) | ((outputId & 0xFFFFFFFF) << 32) | ((outcome & 0xFFFFFFFF) << 64) | ((closeDateTime & 0xFFFFFFFF) << 96) | ((freezeDateTime & 0xFFFFFFFF) << 128) | ((payoutRate & 0xFFFFFF) << 160) | ((timeStamp & 0xFFFFFFFF) << 184);\r\n    }\r\n\r\n    function setBetFreezeTime(uint id, uint freezeDateTime) private {\r\n        (uint  eventId, uint  outputId, uint  outcome, uint  closeDateTime, , uint payoutRate, uint timeStamp) = getBetInternal(id);\r\n        bets[id].dataCombined = (eventId & 0xFFFFFFFF) | ((outputId & 0xFFFFFFFF) << 32) | ((outcome & 0xFFFFFFFF) << 64) | ((closeDateTime & 0xFFFFFFFF) << 96) | ((freezeDateTime & 0xFFFFFFFF) << 128) | ((payoutRate & 0xFFFFFF) << 160) | ((timeStamp & 0xFFFFFFFF) << 184);\r\n    }\r\n\r\n    function setBetPayoutRate(uint id, uint payoutRate) private {\r\n        (uint  eventId, uint  outputId, uint  outcome, uint  closeDateTime, uint freezeDateTime, , uint timeStamp) = getBetInternal(id);\r\n        bets[id].dataCombined = (eventId & 0xFFFFFFFF) | ((outputId & 0xFFFFFFFF) << 32) | ((outcome & 0xFFFFFFFF) << 64) | ((closeDateTime & 0xFFFFFFFF) << 96) | ((freezeDateTime & 0xFFFFFFFF) << 128 | ((payoutRate & 0xFFFFFF) << 160) | ((timeStamp & 0xFFFFFFFF) << 184));\r\n    }\r\n\r\n    \r\n\r\n\r\n    /**\r\n     * Check if valid house contract\r\n     */\r\n    function isHouse() public pure returns(bool response) {\r\n        return true;    \r\n    }\r\n\r\n     /**\r\n     * Updates House Data function\r\n     *\r\n     */\r\n    function updateHouseProperties(string memory houseName, string memory houseCreatorName) onlyOwner public {\r\n        houseData.name = houseName;\r\n        houseData.creatorName = houseCreatorName; \r\n        emit HousePropertiesUpdated();\r\n    }    \r\n\r\n    /**\r\n     * Updates House Time Constants\r\n     */\r\n    function setTimeConstants(uint closeTime, uint freezeTime) onlyOwner public {\r\n        closeBeforeStartTime = closeTime;\r\n        closeEventOutcomeTime = freezeTime;\r\n        emit HousePropertiesUpdated();\r\n    }   \r\n\r\n    /**\r\n     * Updates House Oracle function\r\n     *\r\n     */\r\n    function changeHouseOracle(address oracleAddress, uint oraclePercentage) onlyOwner public {\r\n        require(add(houseData.housePercentage,oraclePercentage)<1000,\"House + Oracle percentage should be lower than 100%\");\r\n        if (oracleAddress != houseData.oracleAddress) {\r\n            houseData.oldOracleAddress = houseData.oracleAddress;\r\n            houseData.oracleAddress = oracleAddress;\r\n        }\r\n        houseData.oraclePercentage = oraclePercentage;\r\n        emit HousePropertiesUpdated();\r\n    } \r\n\r\n    /**\r\n     * Updates House percentage function\r\n     *\r\n     */\r\n    function changeHouseEdge(uint housePercentage) onlyOwner public {\r\n        require(housePercentage != houseData.housePercentage,\"New percentage is identical with current\");\r\n        require(add(housePercentage,houseData.oraclePercentage)<1000,\"House + Oracle percentage should be lower than 100%\");\r\n        houseData.housePercentage = housePercentage;\r\n        emit HousePropertiesUpdated();\r\n    } \r\n\r\n\r\n\r\n    function updateBetDataFromOracle(uint betId, uint eventId, uint eventOutputId) private {\r\n        if (!bets[betId].isOutcomeSet) {\r\n            (bets[betId].isOutcomeSet) = OracleContract(bets[betId].oracleAddress).getEventOutcomeIsSet(eventId,eventOutputId); \r\n        }\r\n        if (bets[betId].isOutcomeSet) {\r\n            (uint outcome) = OracleContract(bets[betId].oracleAddress).getEventOutcome(eventId,eventOutputId); \r\n            setBetOutcome(betId,outcome);\r\n        }\r\n            \r\n        if (!bets[betId].isCancelled) {\r\n            uint eventStart;\r\n            uint eventOutcomeDateTime;\r\n            uint eventTimeStamp;\r\n            (eventStart, eventOutcomeDateTime, bets[betId].isCancelled, eventTimeStamp) = OracleContract(bets[betId].oracleAddress).getEventDataForHouse(eventId, eventOutputId); \r\n            uint currentEventTimeStamp = getBetEventTimeStamp(betId);\r\n            if (currentEventTimeStamp==0) {\r\n                setBetEventTimeStamp(betId, eventTimeStamp);\r\n            } else if (currentEventTimeStamp != eventTimeStamp) {\r\n                bets[betId].isCancelled = true;\r\n            }\r\n            setBetFreezeTime(betId, eventOutcomeDateTime + closeEventOutcomeTime * 1 minutes);\r\n            if (getBetCloseTime(betId) == 0) {\r\n                setBetCloseTime(betId, eventStart - closeBeforeStartTime * 1 minutes);\r\n            }  \r\n            if (!bets[betId].isOutcomeSet && getBetFreezeTime(betId) <= now) {\r\n            bets[betId].isCancelled = true;\r\n            }  \r\n        }  \r\n        \r\n    }\r\n\r\n    /*\r\n     * Get the possibleResultsCount of an Event.Output as uint.\r\n     * Should be changed in a future version to use an Oracle function that directly returns possibleResultsCount instead of receive the whole eventOutputs structure\r\n     */\r\n    function getEventOutputMaxUint(address oracleAddress, uint eventId, uint outputId) private view returns (uint) {\r\n        return 2 ** OracleContract(oracleAddress).getEventOutputPossibleResultsCount(eventId,outputId) - 1;\r\n    }\r\n\r\n\r\n    function checkPayoutRate(uint256 payoutRate) public view {\r\n        uint256 multBase = 10 ** 18;\r\n        uint256 houseFees = houseData.housePercentage + houseData.oraclePercentage;\r\n        uint256 check1 = div(multBase , (1000 - houseFees));\r\n        check1 = div(mul(100000 , check1), multBase);\r\n        uint256 check2 = 10000;\r\n        if (houseFees > 0) {\r\n            check2 =  div(multBase , houseFees);\r\n            check2 = div(mul(100000 ,check2), multBase);\r\n        }\r\n        require(payoutRate>check1 && payoutRate<check2,\"Payout rate out of accepted range\");\r\n    }\r\n\r\n\r\n    /*\r\n     * Places a Pool Bet\r\n     */\r\n    function placePoolBet(uint eventId, uint outputId, uint forecast, uint closingDateTime, uint256 minimumWager, uint256 maximumWager, string memory createdBy) payable public {\r\n        require(msg.value > 0,\"Wager should be greater than zero\");\r\n        require(!houseData.newBetsPaused,\"Bets are paused right now\");\r\n        betNextId += 1;\r\n        bets[betNextId].oracleAddress = houseData.oracleAddress;\r\n        bets[betNextId].betType = BetType.poolbet;\r\n        bets[betNextId].createdBy = msg.sender;\r\n\r\n        updateBetDataFromOracle(betNextId, eventId, outputId);\r\n        require(!bets[betNextId].isCancelled,\"Event has been cancelled\");\r\n        require(!bets[betNextId].isOutcomeSet,\"Event has already an outcome\");\r\n        if (closingDateTime>0) {\r\n            setBetCloseTime(betNextId, closingDateTime);\r\n        } \r\n        uint betCloseTime = getBetCloseTime(betNextId);\r\n        require(betCloseTime >= now,\"Close time has passed\");\r\n        setBetEventId(betNextId, eventId);\r\n        setBetEventOutputId(betNextId, outputId);\r\n        if (minimumWager != 0) {\r\n            bets[betNextId].minimumWager = minimumWager;\r\n        } else {\r\n            bets[betNextId].minimumWager = msg.value;\r\n        }\r\n        if (maximumWager != 0) {\r\n            bets[betNextId].maximumWager = maximumWager;\r\n        }\r\n \r\n        playerBetTotalBets[msg.sender][betNextId] = 1;\r\n        betTotalBets[betNextId] = 1;\r\n        betTotalAmount[betNextId] = msg.value;\r\n \r\n        betForcastTotalAmount[betNextId][forecast] = msg.value;\r\n\r\n        playerBetTotalAmount[msg.sender][betNextId] = msg.value;\r\n\r\n        playerBetForecastWager[msg.sender][betNextId][forecast] = msg.value;\r\n\r\n        lastBettingActivity = block.number;\r\n\r\n        playerHasBet[msg.sender] = true;\r\n        \r\n        emit BetPlacedOrModified(betNextId, msg.sender, BetEvent.placeBet, msg.value, forecast, createdBy, betCloseTime);\r\n    }  \r\n\r\n    /*\r\n     * Places a HeadToHEad Bet\r\n     */\r\n    function placeH2HBet(uint eventId, uint outputId, uint forecast, uint closingDateTime, uint256 payoutRate, string memory createdBy) payable public {\r\n        require(msg.value > 0,\"Wager should be greater than zero\");\r\n        require(!houseData.newBetsPaused,\"Bets are paused right now\");\r\n        betNextId += 1;\r\n        bets[betNextId].oracleAddress = houseData.oracleAddress;\r\n        bets[betNextId].betType = BetType.headtohead;\r\n        bets[betNextId].createdBy = msg.sender;\r\n        updateBetDataFromOracle(betNextId, eventId, outputId);\r\n        require(!bets[betNextId].isCancelled,\"Event has been cancelled\");\r\n        require(!bets[betNextId].isOutcomeSet,\"Event has already an outcome\");\r\n        if (closingDateTime>0) {\r\n            setBetCloseTime(betNextId, closingDateTime);\r\n        } \r\n        uint betCloseTime = getBetCloseTime(betNextId);\r\n        require( betCloseTime >= now,\"Close time has passed\");\r\n        setBetEventId(betNextId, eventId);\r\n        setBetEventOutputId(betNextId, outputId);\r\n        checkPayoutRate(payoutRate);\r\n        require(forecast>0 && forecast < getEventOutputMaxUint(bets[betNextId].oracleAddress, eventId, outputId),\"Forecast should be greater than zero and less than Max accepted forecast(All options true)\");\r\n        setBetPayoutRate(betNextId, payoutRate);\r\n        headToHeadForecasts[betNextId][msg.sender] = forecast;\r\n        \r\n              \r\n        playerBetTotalBets[msg.sender][betNextId] = 1;\r\n        betTotalBets[betNextId] = 1;\r\n        betTotalAmount[betNextId] = msg.value;\r\n \r\n        betForcastTotalAmount[betNextId][forecast] = msg.value;\r\n\r\n        playerBetTotalAmount[msg.sender][betNextId] = msg.value;\r\n\r\n        playerBetForecastWager[msg.sender][betNextId][forecast] = msg.value;\r\n\r\n        lastBettingActivity = block.number;\r\n        \r\n        playerHasBet[msg.sender] = true;\r\n\r\n        emit BetPlacedOrModified(betNextId, msg.sender, BetEvent.placeBet, msg.value, forecast, createdBy, betCloseTime);\r\n    }\r\n\r\n \r\n\r\n\r\n    /*\r\n     * Call a Bet\r\n     */\r\n    function callBet(uint betId, uint forecast, string memory createdBy) payable public {\r\n        require(msg.value>0,\"Wager should be greater than zero\");\r\n        require(bets[betId].betType == BetType.headtohead || bets[betId].betType == BetType.poolbet,\"Only poolbet and headtohead bets are implemented\");\r\n        require(bets[betId].betType != BetType.headtohead || betTotalBets[betId] == 1,\"Head to head bet has been already called\");\r\n        require(msg.value>=bets[betId].minimumWager,\"Wager is lower than the minimum accepted\");\r\n        require(bets[betId].maximumWager==0 || msg.value<=bets[betId].maximumWager,\"Wager is higher then the maximum accepted\");\r\n        uint eventId = getBetEventId(betId);\r\n        uint outputId = getBetEventOutputId(betId);\r\n        updateBetDataFromOracle(betId, eventId, outputId);\r\n        require(!bets[betId].isCancelled,\"Bet has been cancelled\");\r\n        require(!bets[betId].isOutcomeSet,\"Event has already an outcome\");\r\n        uint betCloseTime = getBetCloseTime(betId);\r\n        require(betCloseTime >= now,\"Close time has passed\");\r\n        if (bets[betId].betType == BetType.headtohead) {\r\n            require(bets[betId].createdBy != msg.sender,\"Player has been opened the bet\");\r\n            require(msg.value == mulByFraction( betTotalAmount[betId], getBetPayoutRate(betId) - 100, 100),\"Wager should be equal to [Opened bet Wager  * PayoutRate - 100]\");\r\n            require(headToHeadForecasts[betId][bets[betId].createdBy] & forecast == 0,\"Forecast overlaps opened bet forecast\");\r\n            require(headToHeadForecasts[betId][bets[betId].createdBy] | forecast == getEventOutputMaxUint(bets[betId].oracleAddress, eventId, outputId),\"Forecast should be opposite to the opened\");\r\n            headToHeadForecasts[betId][msg.sender] = forecast;           \r\n        } else if (bets[betId].betType == BetType.poolbet) {\r\n            require(playerBetForecastWager[msg.sender][betId][forecast] == 0,\"Already placed a bet on this forecast, use increaseWager method instead\");\r\n        }\r\n\r\n        betTotalBets[betId] += 1;\r\n        betTotalAmount[betId] += msg.value;\r\n\r\n        playerBetTotalBets[msg.sender][betId] += 1;\r\n\r\n        betForcastTotalAmount[betId][forecast] += msg.value;\r\n\r\n        playerBetTotalAmount[msg.sender][betId] += msg.value;\r\n\r\n        playerBetForecastWager[msg.sender][betId][forecast] = msg.value;\r\n\r\n        lastBettingActivity = block.number;\r\n\r\n        playerHasBet[msg.sender] = true;\r\n\r\n        emit BetPlacedOrModified(betId, msg.sender, BetEvent.callBet, msg.value, forecast, createdBy, betCloseTime);   \r\n    }  \r\n\r\n    /*\r\n     * Increase wager\r\n     */\r\n    function increaseWager(uint betId, uint forecast, string memory createdBy) payable public {\r\n        require(msg.value > 0,\"Increase wager amount should be greater than zero\");\r\n        require(bets[betId].betType == BetType.poolbet,\"Only poolbet supports the increaseWager\");\r\n        require(playerBetForecastWager[msg.sender][betId][forecast] > 0,\"Haven't placed any bet for this forecast. Use callBet instead\");\r\n        uint256 wager = playerBetForecastWager[msg.sender][betId][forecast] + msg.value;\r\n        require(bets[betId].maximumWager==0 || wager<=bets[betId].maximumWager,\"The updated wager is higher then the maximum accepted\");\r\n        updateBetDataFromOracle(betId, getBetEventId(betId), getBetEventOutputId(betId));\r\n        require(!bets[betId].isCancelled,\"Bet has been cancelled\");\r\n        require(!bets[betId].isOutcomeSet,\"Event has already an outcome\");\r\n        uint betCloseTime = getBetCloseTime(betId);\r\n        require(betCloseTime >= now,\"Close time has passed\");\r\n        betTotalAmount[betId] += msg.value;\r\n\r\n        betForcastTotalAmount[betId][forecast] += msg.value;\r\n\r\n        playerBetTotalAmount[msg.sender][betId] += msg.value;\r\n\r\n        playerBetForecastWager[msg.sender][betId][forecast] += msg.value;\r\n\r\n        lastBettingActivity = block.number;\r\n\r\n        emit BetPlacedOrModified(betId, msg.sender, BetEvent.increaseWager, msg.value, forecast, createdBy, betCloseTime);       \r\n    }\r\n\r\n    /*\r\n     * Remove a Bet\r\n     */\r\n    function removeBet(uint betId, string memory createdBy) public {\r\n        require(bets[betId].createdBy == msg.sender,\"Caller and player created don't match\");\r\n        require(playerBetTotalBets[msg.sender][betId] > 0, \"Player should has placed at least one bet\");\r\n        require(betTotalBets[betId] == playerBetTotalBets[msg.sender][betId],\"The bet has been called by other player\");\r\n        require(bets[betId].betType == BetType.headtohead || bets[betId].betType == BetType.poolbet,\"Only poolbet and headtohead bets are implemented\");\r\n        updateBetDataFromOracle(betId, getBetEventId(betId), getBetEventOutputId(betId));\r\n        bets[betId].isCancelled = true;\r\n        uint256 wager = betTotalAmount[betId];\r\n        betTotalBets[betId] = 0;\r\n        betTotalAmount[betId] = 0;\r\n        playerBetTotalAmount[msg.sender][betId] = 0;\r\n        playerBetTotalBets[msg.sender][betId] = 0;\r\n        lastBettingActivity = block.number;    \r\n        msg.sender.transfer(wager);   \r\n        emit BetPlacedOrModified(betId, msg.sender, BetEvent.removeBet, wager, 0, createdBy, getBetCloseTime(betId));      \r\n    } \r\n\r\n    /*\r\n     * Refute a Bet\r\n     */\r\n    function refuteBet(uint betId, string memory createdBy) public {\r\n        require(playerBetTotalAmount[msg.sender][betId]>0,\"Caller hasn't placed any bet\");\r\n        require(!playerBetRefuted[msg.sender][betId],\"Already refuted\");\r\n        require(bets[betId].betType == BetType.headtohead || bets[betId].betType == BetType.poolbet,\"Only poolbet and headtohead bets are implemented\");\r\n        updateBetDataFromOracle(betId, getBetEventId(betId), getBetEventOutputId(betId)); \r\n        require(bets[betId].isOutcomeSet, \"Refute isn't allowed when no outcome has been set\");\r\n        require(getBetFreezeTime(betId) > now, \"Refute isn't allowed when Event freeze has passed\");\r\n        playerBetRefuted[msg.sender][betId] = true;\r\n        betRefutedAmount[betId] += playerBetTotalAmount[msg.sender][betId];\r\n        if (betRefutedAmount[betId] >= betTotalAmount[betId]) {\r\n            bets[betId].isCancelled = true;   \r\n        }\r\n        lastBettingActivity = block.number;       \r\n        emit BetPlacedOrModified(betId, msg.sender, BetEvent.refuteBet, 0, 0, createdBy, getBetCloseTime(betId));    \r\n    } \r\n\r\n    function settleHouseFees(uint betId, uint256 houseEdgeAmountForBet, uint256 oracleEdgeAmountForBet) private {\r\n            if (!housePaid[betId]) {\r\n                housePaid[betId] = true;\r\n                if (houseEdgeAmountForBet > 0) {\r\n                    owner.transfer(houseEdgeAmountForBet);\r\n                } \r\n                if (oracleEdgeAmountForBet > 0) {\r\n                    address payable oracleOwner = HouseContract(bets[betId].oracleAddress).owner();\r\n                    oracleOwner.transfer(oracleEdgeAmountForBet);\r\n                } \r\n            }\r\n    }\r\n\r\n    /*\r\n     * Settle a Bet\r\n     */\r\n    function settleBet(uint betId, string memory createdBy) public {\r\n        require(playerBetTotalAmount[msg.sender][betId]>0, \"Caller hasn't placed any bet\");\r\n        require(!playerBetSettled[msg.sender][betId],\"Already settled\");\r\n        require(bets[betId].betType == BetType.headtohead || bets[betId].betType == BetType.poolbet,\"Only poolbet and headtohead bets are implemented\");\r\n        updateBetDataFromOracle(betId, getBetEventId(betId), getBetEventOutputId(betId));\r\n        require(bets[betId].isCancelled || bets[betId].isOutcomeSet,\"Bet should be cancelled or has an outcome\");\r\n        require(getBetFreezeTime(betId) <= now,\"Bet payments are freezed\");\r\n        BetEvent betEvent;\r\n        uint256 playerOutputFromBet = 0;\r\n        if (bets[betId].isCancelled) {\r\n            betEvent = BetEvent.settleCancelledBet;\r\n            playerOutputFromBet = playerBetTotalAmount[msg.sender][betId];            \r\n        } else {\r\n            uint betOutcome = getBetOutcome(betId);\r\n            uint256 houseEdgeAmountForBet = mulByFraction(betTotalAmount[betId], houseData.housePercentage, 1000);\r\n            uint256 oracleEdgeAmountForBet = mulByFraction(betTotalAmount[betId], houseData.oraclePercentage, 1000);\r\n            settleHouseFees(betId, houseEdgeAmountForBet, oracleEdgeAmountForBet);\r\n            uint256 totalBetAmountAfterFees = betTotalAmount[betId] - houseEdgeAmountForBet - oracleEdgeAmountForBet;\r\n            betEvent = BetEvent.settleWinnedBet;\r\n            if (bets[betId].betType == BetType.poolbet) {\r\n                if (betForcastTotalAmount[betId][betOutcome]>0) {                  \r\n                    playerOutputFromBet = mulByFraction(totalBetAmountAfterFees, playerBetForecastWager[msg.sender][betId][betOutcome], betForcastTotalAmount[betId][betOutcome]);            \r\n                } else {\r\n                    playerOutputFromBet = playerBetTotalAmount[msg.sender][betId] - mulByFraction(playerBetTotalAmount[msg.sender][betId], houseData.housePercentage, 1000) - mulByFraction(playerBetTotalAmount[msg.sender][betId], houseData.oraclePercentage, 1000);\r\n                    betEvent = BetEvent.settleCancelledBet;\r\n                }\r\n            } else if (bets[betId].betType == BetType.headtohead) {\r\n                if (headToHeadForecasts[betId][msg.sender] & (2 ** betOutcome) > 0) {\r\n                    playerOutputFromBet = totalBetAmountAfterFees;\r\n                } else {\r\n                    playerOutputFromBet = 0;\r\n                }\r\n            }\r\n            require(playerOutputFromBet > 0,\"Settled amount should be greater than zero\");         \r\n        }      \r\n        playerBetSettled[msg.sender][betId] = true;\r\n        lastBettingActivity = block.number;\r\n        msg.sender.transfer(playerOutputFromBet); \r\n        emit BetPlacedOrModified(betId, msg.sender, betEvent, playerOutputFromBet,0, createdBy, getBetCloseTime(betId));  \r\n    } \r\n\r\n    function() external payable {\r\n        revert();\r\n    }\r\n\r\n    /**\r\n    * Withdraw the requested amount to the sender address\r\n    */\r\n    function withdraw(uint256 amount) public {\r\n        require(address(this).balance>=amount,\"Insufficient House balance. Shouldn't have happened\");\r\n        require(balance[msg.sender]>=amount,\"Insufficient balance\");\r\n        balance[msg.sender] = sub(balance[msg.sender],amount);\r\n        msg.sender.transfer(amount);\r\n        emit transfer(msg.sender,amount,false);\r\n    }\r\n\r\n    /**\r\n    * Withdraw the requested amount to an address\r\n    */\r\n    function withdrawToAddress(address payable destinationAddress,uint256 amount) public {\r\n        require(address(this).balance>=amount);\r\n        require(balance[msg.sender]>=amount,\"Insufficient balance\");\r\n        balance[msg.sender] = sub(balance[msg.sender],amount);\r\n        destinationAddress.transfer(amount);\r\n        emit transfer(msg.sender,amount,false);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n    * Checks if a player has betting activity on House \r\n    */\r\n    function isPlayer(address playerAddress) public view returns(bool) {\r\n        return (playerHasBet[playerAddress]);\r\n    }\r\n\r\n    /**\r\n    * Update House short message \r\n    */\r\n    function updateShortMessage(string memory shortMessage) onlyOwner public {\r\n        houseData.shortMessage = shortMessage;\r\n        emit HousePropertiesUpdated();\r\n    }\r\n\r\n\r\n    /**\r\n    * Starts betting\r\n    */\r\n    function startNewBets(string memory shortMessage) onlyOwner public {\r\n        houseData.shortMessage = shortMessage;\r\n        houseData.newBetsPaused = false;\r\n        emit HousePropertiesUpdated();\r\n    }\r\n\r\n    /**\r\n    * Pauses betting\r\n    */\r\n    function stopNewBets(string memory shortMessage) onlyOwner public {\r\n        houseData.shortMessage = shortMessage;\r\n        houseData.newBetsPaused = true;\r\n        emit HousePropertiesUpdated();\r\n    }\r\n\r\n    /**\r\n    * Link House to a new version\r\n    */\r\n    function linkToNewHouse(address newHouseAddress) onlyOwner public {\r\n        require(newHouseAddress!=address(this),\"New address is current address\");\r\n        require(HouseContract(newHouseAddress).isHouse(),\"New address should be a House smart contract\");\r\n        _newHouseAddress = newHouseAddress;\r\n        houseData.newBetsPaused = true;\r\n        emit HousePropertiesUpdated();\r\n    }\r\n\r\n    /**\r\n    * UnLink House from a newer version\r\n    */\r\n    function unLinkNewHouse() onlyOwner public {\r\n        _newHouseAddress = address(0);\r\n        houseData.newBetsPaused = false;\r\n        emit HousePropertiesUpdated();\r\n    }\r\n\r\n    /**\r\n     * Get House version\r\n    */\r\n    function getHouseVersion() public view returns(uint version) {\r\n        return houseData.version;\r\n    }\r\n\r\n    /**\r\n    * Cancels a Bet\r\n    */\r\n    function cancelBet(uint betId) onlyOwner public {\r\n        require(houseData.managed, \"Cancel available on managed Houses\");\r\n        updateBetDataFromOracle(betId, getBetEventId(betId), getBetEventOutputId(betId));\r\n        require(getBetFreezeTime(betId) > now,\"Freeze time passed\");       \r\n        bets[betId].isCancelled = true;\r\n        emit BetPlacedOrModified(betId, msg.sender, BetEvent.cancelledByHouse, 0, 0, \"\", getBetCloseTime(betId));  \r\n    }\r\n\r\n    /**\r\n    * Settle fees of Oracle and House for a bet\r\n    */\r\n    function settleBetFees(uint betId) onlyOwner public {\r\n        require(bets[betId].isCancelled || bets[betId].isOutcomeSet,\"Bet should be cancelled or has an outcome\");\r\n        require(getBetFreezeTime(betId) <= now,\"Bet payments are freezed\");\r\n        settleHouseFees(betId, mulByFraction(betTotalAmount[betId], houseData.housePercentage, 1000), mulByFraction(betTotalAmount[betId], houseData.oraclePercentage, 1000));\r\n    }\r\n\r\n\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"playerAddress\",\"type\":\"address\"}],\"name\":\"isPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"string\"}],\"name\":\"refuteBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBetOutcome\",\"outputs\":[{\"name\":\"eventOutcome\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"housePaid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"dataCombined\",\"type\":\"uint256\"},{\"name\":\"isOutcomeSet\",\"type\":\"bool\"},{\"name\":\"isCancelled\",\"type\":\"bool\"},{\"name\":\"minimumWager\",\"type\":\"uint256\"},{\"name\":\"maximumWager\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"address\"},{\"name\":\"betType\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payoutRate\",\"type\":\"uint256\"}],\"name\":\"checkPayoutRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"string\"}],\"name\":\"settleBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBetEventTimeStamp\",\"outputs\":[{\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerBetTotalBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"cancelBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destinationAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"settleBetFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerBetRefuted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"shortMessage\",\"type\":\"string\"}],\"name\":\"startNewBets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerHasBet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"headToHeadForecasts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betTotalBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBetCloseTime\",\"outputs\":[{\"name\":\"betCloseTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"forecast\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"string\"}],\"name\":\"increaseWager\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerBetForecastWager\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isHouse\",\"outputs\":[{\"name\":\"response\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"outputId\",\"type\":\"uint256\"},{\"name\":\"forecast\",\"type\":\"uint256\"},{\"name\":\"closingDateTime\",\"type\":\"uint256\"},{\"name\":\"payoutRate\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"string\"}],\"name\":\"placeH2HBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unLinkNewHouse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerBetTotalAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"shortMessage\",\"type\":\"string\"}],\"name\":\"stopNewBets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseData\",\"outputs\":[{\"name\":\"managed\",\"type\":\"bool\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"creatorName\",\"type\":\"string\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"oldOracleAddress\",\"type\":\"address\"},{\"name\":\"newBetsPaused\",\"type\":\"bool\"},{\"name\":\"housePercentage\",\"type\":\"uint256\"},{\"name\":\"oraclePercentage\",\"type\":\"uint256\"},{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"shortMessage\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betRefutedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBetPayoutRate\",\"outputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHouseVersion\",\"outputs\":[{\"name\":\"version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"oraclePercentage\",\"type\":\"uint256\"}],\"name\":\"changeHouseOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_newHouseAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerBetSettled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betForcastTotalAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBetFreezeTime\",\"outputs\":[{\"name\":\"betFreezeTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBetEventOutputId\",\"outputs\":[{\"name\":\"eventOutputId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHouseAddress\",\"type\":\"address\"}],\"name\":\"linkToNewHouse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"string\"}],\"name\":\"removeBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betTotalAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closeBeforeStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"closeTime\",\"type\":\"uint256\"},{\"name\":\"freezeTime\",\"type\":\"uint256\"}],\"name\":\"setTimeConstants\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"outputId\",\"type\":\"uint256\"},{\"name\":\"forecast\",\"type\":\"uint256\"},{\"name\":\"closingDateTime\",\"type\":\"uint256\"},{\"name\":\"minimumWager\",\"type\":\"uint256\"},{\"name\":\"maximumWager\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"string\"}],\"name\":\"placePoolBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBetEventId\",\"outputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"shortMessage\",\"type\":\"string\"}],\"name\":\"updateShortMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closeEventOutcomeTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBetInternal\",\"outputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"outputId\",\"type\":\"uint256\"},{\"name\":\"outcome\",\"type\":\"uint256\"},{\"name\":\"closeDateTime\",\"type\":\"uint256\"},{\"name\":\"freezeDateTime\",\"type\":\"uint256\"},{\"name\":\"payoutRate\",\"type\":\"uint256\"},{\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"housePercentage\",\"type\":\"uint256\"}],\"name\":\"changeHouseEdge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBettingActivity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"houseName\",\"type\":\"string\"},{\"name\":\"houseCreatorName\",\"type\":\"string\"}],\"name\":\"updateHouseProperties\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"forecast\",\"type\":\"uint256\"},{\"name\":\"createdBy\",\"type\":\"string\"}],\"name\":\"callBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"managed\",\"type\":\"bool\"},{\"name\":\"houseName\",\"type\":\"string\"},{\"name\":\"houseCreatorName\",\"type\":\"string\"},{\"name\":\"oracleAddress\",\"type\":\"address\"},{\"name\":\"housePercentage\",\"type\":\"uint256\"},{\"name\":\"oraclePercentage\",\"type\":\"uint256\"},{\"name\":\"closeTime\",\"type\":\"uint256\"},{\"name\":\"freezeTime\",\"type\":\"uint256\"},{\"name\":\"version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"HouseCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"HousePropertiesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betEvent\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"forecast\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"createdBy\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"closeDateTime\",\"type\":\"uint256\"}],\"name\":\"BetPlacedOrModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"inbound\",\"type\":\"bool\"}],\"name\":\"transfer\",\"type\":\"event\"}]","ContractName":"House","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001600000000000000000000000007238223d1baa660de5603bb87f301db71810b33100000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000002d00000000000000000000000000000000000000000000000000000000000000069000000000000000000000000000000000000000000000000000000000000000a4e657742657420762e3500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b4e6577426574205465616d000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://797b38b908e8e0aed4fddc93ed0f0d68812954ebb3e1ca43ad369a15fd6d84d2"}]}