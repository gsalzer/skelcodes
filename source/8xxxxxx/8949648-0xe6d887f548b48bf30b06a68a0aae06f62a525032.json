{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.21 <0.6.0;\r\n\r\ncontract MultiSig{\r\n\r\n  struct invoke_status{\r\n    uint propose_height;\r\n    bytes32 invoke_hash;\r\n    string func_name;\r\n    uint64 invoke_id;\r\n    bool called;\r\n    address[] invoke_signers;\r\n    bool processing;\r\n    bool exists;\r\n  }\r\n\r\n  uint public signer_number;\r\n  address[] public signers;\r\n  address public owner;\r\n  mapping (bytes32 => invoke_status) public invokes;\r\n  mapping (bytes32 => uint64) public used_invoke_ids;\r\n  mapping(address => uint) public signer_join_height;\r\n\r\n  event signers_reformed(address[] old_signers, address[] new_signers);\r\n  event valid_function_sign(string name, uint64 id, uint64 current_signed_number, uint propose_height);\r\n  event function_called(string name, uint64 id, uint propose_height);\r\n\r\n  modifier enough_signers(address[] memory s){\r\n    require(s.length >=3, \"the number of signers must be >=3\");\r\n    _;\r\n  }\r\n  constructor(address[] memory s) public enough_signers(s){\r\n    signer_number = s.length;\r\n    owner = msg.sender;\r\n    for(uint i = 0; i < s.length; i++){\r\n      signers.push(s[i]);\r\n      signer_join_height[s[i]] = block.number;\r\n    }\r\n  }\r\n\r\n  modifier only_signer{\r\n    require(array_exist(signers, msg.sender), \"only a signer can call this\");\r\n    _;\r\n  }\r\n\r\n  function is_signer(address _addr) public view returns(bool){\r\n    return array_exist(signers, _addr);\r\n  }\r\n\r\n  function get_majority_number() private view returns(uint){\r\n    return signer_number/2 + 1;\r\n  }\r\n\r\n  function array_exist (address[] memory accounts, address p) private pure returns (bool){\r\n    for (uint i = 0; i< accounts.length;i++){\r\n      if (accounts[i]==p){\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function is_all_minus_sig(uint number, uint64 id, string memory name, bytes32 hash, address sender) internal returns (bool){\r\n    bytes32 b = keccak256(abi.encodePacked(name));\r\n    require(id <= used_invoke_ids[b] + 1, \"you're using a too big id.\");\r\n\r\n    if(id > used_invoke_ids[b]){\r\n      used_invoke_ids[b] = id;\r\n    }\r\n\r\n    if(!invokes[hash].exists){\r\n      invokes[hash].propose_height = block.number;\r\n      invokes[hash].invoke_hash = hash;\r\n      invokes[hash].func_name= name;\r\n      invokes[hash].invoke_id= id;\r\n      invokes[hash].called= false;\r\n      invokes[hash].invoke_signers.push(sender);\r\n      invokes[hash].processing= false;\r\n      invokes[hash].exists= true;\r\n      emit valid_function_sign(name, id, 1, block.number);\r\n      return false;\r\n    }\r\n\r\n    invoke_status storage invoke = invokes[hash];\r\n    require(!array_exist(invoke.invoke_signers, sender), \"you already called this method\");\r\n\r\n    uint valid_invoke_num = 0;\r\n    uint join_height = signer_join_height[sender];\r\n    for(uint i = 0; i < invoke.invoke_signers.length; i++){\r\n      require(join_height < invoke.propose_height, \"this proposal is already exist before you become a signer\");\r\n      if(array_exist(signers, invoke.invoke_signers[i])){\r\n        valid_invoke_num ++;\r\n      }\r\n    }\r\n    invoke.invoke_signers.push(sender);\r\n    valid_invoke_num ++;\r\n    emit valid_function_sign(name, id, uint64(valid_invoke_num), invoke.propose_height);\r\n    if(invoke.called) return false;\r\n    if(valid_invoke_num < signer_number-number) return false;\r\n    invoke.processing = true;\r\n    return true;\r\n  }\r\n\r\n  function update_and_check_reach_majority(uint64 id, string memory name, bytes32 hash, address sender) public returns (bool){\r\n    //bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));\r\n    uint minority = signer_number - get_majority_number();\r\n    if(!is_all_minus_sig(minority, id, name, hash, sender))\r\n      return false;\r\n    set_called(hash);\r\n    return true;\r\n  }\r\n\r\n  modifier is_majority_sig(uint64 id, string memory name) {\r\n    bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));\r\n    uint minority = signer_number - get_majority_number();\r\n    if(!is_all_minus_sig(minority, id, name, hash, msg.sender))\r\n      return ;\r\n    set_called(hash);\r\n    _;\r\n  }\r\n\r\n  modifier is_all_sig(uint64 id, string memory name) {\r\n    bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));\r\n    if(!is_all_minus_sig(0, id, name, hash, msg.sender)) return ;\r\n    set_called(hash);\r\n    _;\r\n  }\r\n\r\n  function set_called(bytes32 hash) internal {\r\n    invoke_status storage invoke = invokes[hash];\r\n    require(invoke.exists, \"no such function\");\r\n    require(!invoke.called, \"already called\");\r\n    require(invoke.processing, \"cannot call this separately\");\r\n    invoke.called = true;\r\n    invoke.processing = false;\r\n    emit function_called(invoke.func_name, invoke.invoke_id, invoke.propose_height);\r\n  }\r\n\r\n  function reform_signers(uint64 id, address[] calldata s)\r\n    external\r\n    only_signer\r\n    enough_signers(s)\r\n    is_majority_sig(id, \"reform_signers\"){\r\n    address[] memory old_signers = signers;\r\n    for(uint i = 0; i < s.length; i++){\r\n      if(array_exist(old_signers, s[i])){\r\n      }else{\r\n        signer_join_height[s[i]] = block.number;\r\n      }\r\n    }\r\n    for(uint i = 0; i < old_signers.length; i++){\r\n      if(array_exist(s, old_signers[i])){\r\n      }else{\r\n        signer_join_height[old_signers[i]] = 0;\r\n      }\r\n    }\r\n    signer_number = s.length;\r\n    signers = s;\r\n    emit signers_reformed(old_signers, signers);\r\n  }\r\n\r\n  function get_unused_invoke_id(string memory name) public view returns(uint64){\r\n    return used_invoke_ids[keccak256(abi.encodePacked(name))] + 1;\r\n  }\r\n  function get_signers() public view returns(address[] memory){\r\n    return signers;\r\n  }\r\n}\r\n\r\ncontract MultiSigFactory{\r\n  event NewMultiSig(address addr, address[] signers);\r\n\r\n  function createMultiSig(address[] memory _signers) public returns(address){\r\n    MultiSig ms = new MultiSig(_signers);\r\n    emit NewMultiSig(address(ms), _signers);\r\n    return address(ms);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_signers\",\"type\":\"address[]\"}],\"name\":\"createMultiSig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"signers\",\"type\":\"address[]\"}],\"name\":\"NewMultiSig\",\"type\":\"event\"}]","ContractName":"MultiSigFactory","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://e6d3fb6309082e984b42fbddec93d6a519f1d4ba22c99b239b4de7a93980feb5"}]}