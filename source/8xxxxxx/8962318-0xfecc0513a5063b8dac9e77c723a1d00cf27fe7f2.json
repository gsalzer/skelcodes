{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\n\ncontract BaseMigration {\n\n    function convertPurity(uint16 purity)\n        public\n        pure\n        returns (uint8)\n    {\n        return uint8(4 - (purity / 1000));\n    }\n\n    function convertProto(uint16 proto)\n        public\n        view\n        returns (uint16)\n    {\n        if (proto >= 1 && proto <= 377) {\n            return proto;\n        }\n        // first phoenix\n        if (proto == 380) {\n            return 400;\n        }\n        // light's bidding\n        if (proto == 381) {\n            return 401;\n        }\n        // chimera\n        if (proto == 394) {\n            return 402;\n        }\n        // etherbots\n        (bool found, uint index) = getEtherbotsIndex(proto);\n        if (found) {\n            return uint16(380 + index);\n        }\n        // hyperion\n        if (proto == 378) {\n            return 65000;\n        }\n        // prometheus\n        if (proto == 379) {\n            return 65001;\n        }\n        // atlas\n        if (proto == 383) {\n            return 65002;\n        }\n        // tethys\n        if (proto == 384) {\n            return 65003;\n        }\n        require(false, \"BM: unrecognised proto\");\n    }\n\n    uint16[] internal ebs = [\n        400,\n        413,\n        414,\n        421,\n        427,\n        428,\n        389,\n        415,\n        416,\n        422,\n        424,\n        425,\n        426,\n        382,\n        420,\n        417\n    ];\n\n    function getEtherbotsIndex(uint16 proto)\n        public\n        view\n        returns (bool, uint16)\n    {\n        for (uint16 i = 0; i < ebs.length; i++) {\n            if (ebs[i] == proto) {\n                return (true, i);\n            }\n        }\n        return (false, 0);\n    }\n\n}\n\ncontract Pack {\n\n    enum Type {\n        Rare,\n        Epic,\n        Legendary,\n        Shiny\n    }\n\n}\n\ncontract LegacyICards {\n\n    enum Rarity {\n        Common,\n        Rare,\n        Epic,\n        Legendary,\n        Mythic\n    }\n\n    function getRandomCard(\n        Rarity rarity,\n        uint16 random\n    )\n        public\n        view\n        returns (uint16);\n\n    function createCard(\n        address user,\n        uint16 proto,\n        uint16 purity\n    )\n        public\n        returns (uint);\n\n\n}\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\n/**\n * This file's sole purpose is because in v2 Migrations importing PackFive.sol to use the PackFive \n * type causes a circular depedency via the import of ICards inside RarityProvider.sol.\n * We can probably get rid of this in the case v2 Migrations aren't needed.\n */\n\ncontract IPackFive {\n\n    struct Purchase {\n        uint count;\n        uint randomness;\n        uint[] state;\n        Pack.Type packType;\n        uint64 commit;\n        uint64 lockup;\n        bool revoked;\n        address user;\n    }\n\n    Purchase[] public purchases;\n\n    function getPurchaseState(uint purchaseID) public view returns (uint[] memory state);\n    function predictPacks(uint id) external view returns (uint16[] memory protos, uint16[] memory purities);\n    function canActivatePurchase(uint id) public view returns (bool);\n\n}\n\n\ncontract RarityProvider {\n\n    LegacyICards cards;\n\n    constructor(LegacyICards _cards) public {\n        cards = _cards;\n    }\n\n    struct RandomnessComponents {\n        uint random;\n        uint32 rarity;\n        uint16 quality;\n        uint16 purity;\n        uint16 proto;\n    }\n\n    // return 'length' bytes of 'num' starting at 'start'\n    function extract(uint num, uint length, uint start) internal pure returns (uint) {\n        return (((1 << (length * 8)) - 1) & (num >> ((start - 1) * 8)));\n    }\n\n    // divides the random seed into components\n    function getComponents(\n        uint cardIndex, uint rand\n    ) internal pure returns (\n        RandomnessComponents memory\n    ) {\n        uint random = uint(keccak256(abi.encodePacked(cardIndex, rand)));\n        return RandomnessComponents({\n            random: random,\n            rarity: uint32(extract(random, 4, 10) % 1000000),\n            quality: uint16(extract(random, 2, 4) % 1000),\n            purity: uint16(extract(random, 2, 6) % 1000),\n            proto: uint16(extract(random, 2, 8) % (2**16-1))\n        });\n    }\n\n    function getCardDetails(Pack.Type packType, uint cardIndex, uint result) internal view returns (uint16, uint16) {\n        if (packType == Pack.Type.Shiny) {\n            return _getShinyCardDetails(cardIndex, result);\n        } else if (packType == Pack.Type.Legendary) {\n            return _getLegendaryCardDetails(cardIndex, result);\n        } else if (packType == Pack.Type.Epic) {\n            return _getEpicCardDetails(cardIndex, result);\n        }\n        return _getRareCardDetails(cardIndex, result);\n    }\n\n    function _getShinyCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\n\n        RandomnessComponents memory rc = getComponents(cardIndex, result);\n\n        LegacyICards.Rarity rarity;\n\n        if (cardIndex % 5 == 0) {\n            rarity = _getLegendaryPlusRarity(rc.rarity);\n            purity = _getShinyPurityBase(rc.quality) + rc.purity;\n        } else if (cardIndex % 5 == 1) {\n            rarity = _getRarePlusRarity(rc.rarity);\n            purity = _getPurityBase(rc.quality) + rc.purity;\n        } else {\n            rarity = _getCommonPlusRarity(rc.rarity);\n            purity = _getPurityBase(rc.quality) + rc.purity;\n        }\n        proto = cards.getRandomCard(rarity, rc.proto);\n        return (proto, purity);\n    }\n\n    function _getLegendaryCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\n\n        RandomnessComponents memory rc = getComponents(cardIndex, result);\n\n        LegacyICards.Rarity rarity;\n\n        if (cardIndex % 5 == 0) {\n            rarity = _getLegendaryPlusRarity(rc.rarity);\n        } else if (cardIndex % 5 == 1) {\n            rarity = _getRarePlusRarity(rc.rarity);\n        } else {\n            rarity = _getCommonPlusRarity(rc.rarity);\n        }\n\n        purity = _getPurityBase(rc.quality) + rc.purity;\n\n        proto = cards.getRandomCard(rarity, rc.proto);\n\n        return (proto, purity);\n    }\n\n\n    function _getEpicCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\n\n        RandomnessComponents memory rc = getComponents(cardIndex, result);\n\n        LegacyICards.Rarity rarity;\n\n        if (cardIndex % 5 == 0) {\n            rarity = _getEpicPlusRarity(rc.rarity);\n        } else {\n            rarity = _getCommonPlusRarity(rc.rarity);\n        }\n\n        purity = _getPurityBase(rc.quality) + rc.purity;\n\n        proto = cards.getRandomCard(rarity, rc.proto);\n\n        return (proto, purity);\n    }\n\n    function _getRareCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\n\n        RandomnessComponents memory rc = getComponents(cardIndex, result);\n\n        LegacyICards.Rarity rarity;\n\n        if (cardIndex % 5 == 0) {\n            rarity = _getRarePlusRarity(rc.rarity);\n        } else {\n            rarity = _getCommonPlusRarity(rc.rarity);\n        }\n\n        purity = _getPurityBase(rc.quality) + rc.purity;\n\n        proto = cards.getRandomCard(rarity, rc.proto);\n        return (proto, purity);\n    }\n\n\n    function _getCommonPlusRarity(uint32 rand) internal pure returns (LegacyICards.Rarity) {\n        if (rand == 999999) {\n            return LegacyICards.Rarity.Mythic;\n        } else if (rand >= 998345) {\n            return LegacyICards.Rarity.Legendary;\n        } else if (rand >= 986765) {\n            return LegacyICards.Rarity.Epic;\n        } else if (rand >= 924890) {\n            return LegacyICards.Rarity.Rare;\n        } else {\n            return LegacyICards.Rarity.Common;\n        }\n    }\n\n    function _getRarePlusRarity(uint32 rand) internal pure returns (LegacyICards.Rarity) {\n        if (rand == 999999) {\n            return LegacyICards.Rarity.Mythic;\n        } else if (rand >= 981615) {\n            return LegacyICards.Rarity.Legendary;\n        } else if (rand >= 852940) {\n            return LegacyICards.Rarity.Epic;\n        } else {\n            return LegacyICards.Rarity.Rare;\n        }\n    }\n\n    function _getEpicPlusRarity(uint32 rand) internal pure returns (LegacyICards.Rarity) {\n        if (rand == 999999) {\n            return LegacyICards.Rarity.Mythic;\n        } else if (rand >= 981615) {\n            return LegacyICards.Rarity.Legendary;\n        } else {\n            return LegacyICards.Rarity.Epic;\n        }\n    }\n\n    function _getLegendaryPlusRarity(uint32 rand) internal pure returns (LegacyICards.Rarity) {\n        if (rand == 999999) {\n            return LegacyICards.Rarity.Mythic;\n        } else {\n            return LegacyICards.Rarity.Legendary;\n        }\n    }\n\n    // store purity and shine as one number to save users gas\n    function _getPurityBase(uint16 randOne) internal pure returns (uint16) {\n        if (randOne >= 998) {\n            return 3000;\n        } else if (randOne >= 988) {\n            return 2000;\n        } else if (randOne >= 938) {\n            return 1000;\n        }\n        return 0;\n    }\n\n    function _getShinyPurityBase(uint16 randOne) internal pure returns (uint16) {\n        if (randOne >= 998) {\n            return 3000;\n        } else if (randOne >= 748) {\n            return 2000;\n        } else {\n            return 1000;\n        }\n    }\n\n    function getShine(uint16 purity) public pure returns (uint8) {\n        return uint8(purity / 1000);\n    }\n\n}\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\n\ncontract ICards is IERC721 {\n\n    struct Batch {\n        uint48 userID;\n        uint16 size;\n    }\n\n    function batches(uint index) public view returns (uint48 userID, uint16 size);\n\n    function userIDToAddress(uint48 id) public view returns (address);\n\n    function getDetails(\n        uint tokenId\n    )\n        public\n        view\n        returns (\n        uint16 proto,\n        uint8 quality\n    );\n\n    function setQuality(\n        uint tokenId,\n        uint8 quality\n    ) public;\n\n    function mintCards(\n        address to,\n        uint16[] memory _protos,\n        uint8[] memory _qualities\n    )\n        public\n        returns (uint);\n\n    function mintCard(\n        address to,\n        uint16 _proto,\n        uint8 _quality\n    )\n        public\n        returns (uint);\n\n    function burn(uint tokenId) public;\n\n    function batchSize()\n        public\n        view\n        returns (uint);\n}\n\n\n\n\ncontract v2Migration is BaseMigration, RarityProvider {\n\n    ICards cards;\n    uint16 public limit;\n\n    constructor(\n        LegacyICards _legacy,\n        ICards _cards,\n        address[] memory _packs,\n        uint16 _limit\n    )\n        public RarityProvider(_legacy)\n    {\n        for (uint i = 0; i < _packs.length; i++) {\n            canMigrate[_packs[i]] = true;\n        }\n\n        limit = _limit;\n        cards = _cards;\n    }\n\n    struct StackDepthLimit {\n        uint16 proto;\n        uint16 purity;\n        uint16[] protos;\n        uint8[] qualities;\n    }\n\n    mapping (address => bool) public canMigrate;\n    mapping (address => mapping (uint => uint16)) public v2Migrated;\n\n    event Migrated(\n        address indexed user,\n        uint id,\n        uint start,\n        uint end,\n        uint startID\n    );\n\n    // PackFive = pack factory which creates packs and cards\n\n    function migrate(\n        IPackFive pack,\n        uint id\n    )\n        public\n    {\n        require(\n            canMigrate[address(pack)],\n            \"V2: must be migrating from an approved pack\"\n        );\n\n        (uint count, uint randomness,Pack.Type packType,,,, address user) = pack.purchases(id);\n        uint[] memory state = pack.getPurchaseState(id);\n\n        require(\n            noCardsActivated(state),\n            \"V2: must have no cards activated\"\n        );\n\n        // Check if randomness set\n        require(\n            randomness != 0,\n            \"V2: must have had randomness set\"\n        );\n\n        uint16 size = uint16(count * 5);\n        require(size > count, \"check overflow\");\n\n        uint16 migrated = v2Migrated[address(pack)][id];\n\n        // If no cards activated, then we just create all of the cards (count * 5)\n        require(\n            size > migrated,\n            \"V2: must not have been migrated previously\"\n        );\n\n        uint16 remaining = size - migrated;\n\n        uint16 len = remaining > limit ? limit : remaining;\n\n        StackDepthLimit memory sdl;\n\n        sdl.protos = new uint16[](len);\n        sdl.qualities = new uint8[](len);\n\n        for (uint16 i = 0; i < len; i++) {\n            (sdl.proto, sdl.purity) = getCardDetails(packType, migrated+i, randomness);\n            sdl.protos[i] = convertProto(sdl.proto);\n            sdl.qualities[i] = convertPurity(sdl.purity);\n        }\n\n        // Mint cards (details passed as function args)\n        uint startID = cards.mintCards(user, sdl.protos, sdl.qualities);\n\n        emit Migrated(user, id, migrated, len, startID);\n\n        v2Migrated[address(pack)][id] += len;\n\n    }\n\n    function noCardsActivated(\n        uint[] memory state\n    )\n        public\n        pure\n        returns (bool)\n    {\n        for (uint i = 0; i < state.length; i++) {\n            if (state[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"}],\"name\":\"getEtherbotsIndex\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"v2Migrated\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"state\",\"type\":\"uint256[]\"}],\"name\":\"noCardsActivated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"}],\"name\":\"convertProto\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"purity\",\"type\":\"uint16\"}],\"name\":\"convertPurity\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canMigrate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"purity\",\"type\":\"uint16\"}],\"name\":\"getShine\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limit\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IPackFive\",\"name\":\"pack\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LegacyICards\",\"name\":\"_legacy\",\"type\":\"address\"},{\"internalType\":\"contract ICards\",\"name\":\"_cards\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_packs\",\"type\":\"address[]\"},{\"internalType\":\"uint16\",\"name\":\"_limit\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startID\",\"type\":\"uint256\"}],\"name\":\"Migrated\",\"type\":\"event\"}]","ContractName":"v2Migration","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006ebeaf8e8e946f0716e6533a6f2cefc83f60e8ab0000000000000000000000000e3a2a1f2146d86a604adc220b4967a898d7fe070000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000012c00000000000000000000000000000000000000000000000000000000000000010000000000000000000000003ae323c0589d32067c07b4a351b10bc900d8b50d","Library":"","LicenseType":"","SwarmSource":"bzzr://3785c699f3688ec04bba2a7017f74d3e032f03555dfde1551254db9272da5d8b"}]}