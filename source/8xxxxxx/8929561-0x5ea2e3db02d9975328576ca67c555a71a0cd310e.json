{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC20Detailed token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @return the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @return the symbol of the token.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @return the number of decimals of the token.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/Math.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the average of two numbers. Since these are integers,\r\n     * averages of an even and odd number cannot be represented, and will be\r\n     * rounded down.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/lib/CommonMath.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\nlibrary CommonMath {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Calculates and returns the maximum value for a uint256\r\n     *\r\n     * @return  The maximum value for uint256\r\n     */\r\n    function maxUInt256()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 2 ** 256 - 1;\r\n    }\r\n\r\n    /**\r\n    * @dev Performs the power on a specified value, reverts on overflow.\r\n    */\r\n    function safePower(\r\n        uint256 a,\r\n        uint256 pow\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(a > 0);\r\n\r\n        uint256 result = 1;\r\n        for (uint256 i = 0; i < pow; i++){\r\n            uint256 previousResult = result;\r\n\r\n            // Using safemath multiplication prevents overflows\r\n            result = previousResult.mul(a);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Checks for rounding errors and returns value of potential partial amounts of a principal\r\n     *\r\n     * @param  _principal       Number fractional amount is derived from\r\n     * @param  _numerator       Numerator of fraction\r\n     * @param  _denominator     Denominator of fraction\r\n     * @return uint256          Fractional amount of principal calculated\r\n     */\r\n    function getPartialAmount(\r\n        uint256 _principal,\r\n        uint256 _numerator,\r\n        uint256 _denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // Get remainder of partial amount (if 0 not a partial amount)\r\n        uint256 remainder = mulmod(_principal, _numerator, _denominator);\r\n\r\n        // Return if not a partial amount\r\n        if (remainder == 0) {\r\n            return _principal.mul(_numerator).div(_denominator);\r\n        }\r\n\r\n        // Calculate error percentage\r\n        uint256 errPercentageTimes1000000 = remainder.mul(1000000).div(_numerator.mul(_principal));\r\n\r\n        // Require error percentage is less than 0.1%.\r\n        require(\r\n            errPercentageTimes1000000 < 1000,\r\n            \"CommonMath.getPartialAmount: Rounding error exceeds bounds\"\r\n        );\r\n\r\n        return _principal.mul(_numerator).div(_denominator);\r\n    }\r\n\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/interfaces/ICore.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title ICore\r\n * @author Set Protocol\r\n *\r\n * The ICore Contract defines all the functions exposed in the Core through its\r\n * various extensions and is a light weight way to interact with the contract.\r\n */\r\ninterface ICore {\r\n    /**\r\n     * Return transferProxy address.\r\n     *\r\n     * @return address       transferProxy address\r\n     */\r\n    function transferProxy()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * Return vault address.\r\n     *\r\n     * @return address       vault address\r\n     */\r\n    function vault()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * Return address belonging to given exchangeId.\r\n     *\r\n     * @param  _exchangeId       ExchangeId number\r\n     * @return address           Address belonging to given exchangeId\r\n     */\r\n    function exchangeIds(\r\n        uint8 _exchangeId\r\n    )\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /*\r\n     * Returns if valid set\r\n     *\r\n     * @return  bool      Returns true if Set created through Core and isn't disabled\r\n     */\r\n    function validSets(address)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /*\r\n     * Returns if valid module\r\n     *\r\n     * @return  bool      Returns true if valid module\r\n     */\r\n    function validModules(address)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * Return boolean indicating if address is a valid Rebalancing Price Library.\r\n     *\r\n     * @param  _priceLibrary    Price library address\r\n     * @return bool             Boolean indicating if valid Price Library\r\n     */\r\n    function validPriceLibraries(\r\n        address _priceLibrary\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * Exchanges components for Set Tokens\r\n     *\r\n     * @param  _set          Address of set to issue\r\n     * @param  _quantity     Quantity of set to issue\r\n     */\r\n    function issue(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Issues a specified Set for a specified quantity to the recipient\r\n     * using the caller's components from the wallet and vault.\r\n     *\r\n     * @param  _recipient    Address to issue to\r\n     * @param  _set          Address of the Set to issue\r\n     * @param  _quantity     Number of tokens to issue\r\n     */\r\n    function issueTo(\r\n        address _recipient,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Converts user's components into Set Tokens held directly in Vault instead of user's account\r\n     *\r\n     * @param _set          Address of the Set\r\n     * @param _quantity     Number of tokens to redeem\r\n     */\r\n    function issueInVault(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Function to convert Set Tokens into underlying components\r\n     *\r\n     * @param _set          The address of the Set token\r\n     * @param _quantity     The number of tokens to redeem. Should be multiple of natural unit.\r\n     */\r\n    function redeem(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Redeem Set token and return components to specified recipient. The components\r\n     * are left in the vault\r\n     *\r\n     * @param _recipient    Recipient of Set being issued\r\n     * @param _set          Address of the Set\r\n     * @param _quantity     Number of tokens to redeem\r\n     */\r\n    function redeemTo(\r\n        address _recipient,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Function to convert Set Tokens held in vault into underlying components\r\n     *\r\n     * @param _set          The address of the Set token\r\n     * @param _quantity     The number of tokens to redeem. Should be multiple of natural unit.\r\n     */\r\n    function redeemInVault(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Composite method to redeem and withdraw with a single transaction\r\n     *\r\n     * Normally, you should expect to be able to withdraw all of the tokens.\r\n     * However, some have central abilities to freeze transfers (e.g. EOS). _toExclude\r\n     * allows you to optionally specify which component tokens to exclude when\r\n     * redeeming. They will remain in the vault under the users' addresses.\r\n     *\r\n     * @param _set          Address of the Set\r\n     * @param _to           Address to withdraw or attribute tokens to\r\n     * @param _quantity     Number of tokens to redeem\r\n     * @param _toExclude    Mask of indexes of tokens to exclude from withdrawing\r\n     */\r\n    function redeemAndWithdrawTo(\r\n        address _set,\r\n        address _to,\r\n        uint256 _quantity,\r\n        uint256 _toExclude\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Deposit multiple tokens to the vault. Quantities should be in the\r\n     * order of the addresses of the tokens being deposited.\r\n     *\r\n     * @param  _tokens           Array of the addresses of the ERC20 tokens\r\n     * @param  _quantities       Array of the number of tokens to deposit\r\n     */\r\n    function batchDeposit(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Withdraw multiple tokens from the vault. Quantities should be in the\r\n     * order of the addresses of the tokens being withdrawn.\r\n     *\r\n     * @param  _tokens            Array of the addresses of the ERC20 tokens\r\n     * @param  _quantities        Array of the number of tokens to withdraw\r\n     */\r\n    function batchWithdraw(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Deposit any quantity of tokens into the vault.\r\n     *\r\n     * @param  _token           The address of the ERC20 token\r\n     * @param  _quantity        The number of tokens to deposit\r\n     */\r\n    function deposit(\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Withdraw a quantity of tokens from the vault.\r\n     *\r\n     * @param  _token           The address of the ERC20 token\r\n     * @param  _quantity        The number of tokens to withdraw\r\n     */\r\n    function withdraw(\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Transfer tokens associated with the sender's account in vault to another user's\r\n     * account in vault.\r\n     *\r\n     * @param  _token           Address of token being transferred\r\n     * @param  _to              Address of user receiving tokens\r\n     * @param  _quantity        Amount of tokens being transferred\r\n     */\r\n    function internalTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Deploys a new Set Token and adds it to the valid list of SetTokens\r\n     *\r\n     * @param  _factory              The address of the Factory to create from\r\n     * @param  _components           The address of component tokens\r\n     * @param  _units                The units of each component token\r\n     * @param  _naturalUnit          The minimum unit to be issued or redeemed\r\n     * @param  _name                 The bytes32 encoded name of the new Set\r\n     * @param  _symbol               The bytes32 encoded symbol of the new Set\r\n     * @param  _callData             Byte string containing additional call parameters\r\n     * @return setTokenAddress       The address of the new Set\r\n     */\r\n    function createSet(\r\n        address _factory,\r\n        address[] calldata _components,\r\n        uint256[] calldata _units,\r\n        uint256 _naturalUnit,\r\n        bytes32 _name,\r\n        bytes32 _symbol,\r\n        bytes calldata _callData\r\n    )\r\n        external\r\n        returns (address);\r\n\r\n    /**\r\n     * Exposes internal function that deposits a quantity of tokens to the vault and attributes\r\n     * the tokens respectively, to system modules.\r\n     *\r\n     * @param  _from            Address to transfer tokens from\r\n     * @param  _to              Address to credit for deposit\r\n     * @param  _token           Address of token being deposited\r\n     * @param  _quantity        Amount of tokens to deposit\r\n     */\r\n    function depositModule(\r\n        address _from,\r\n        address _to,\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Exposes internal function that withdraws a quantity of tokens from the vault and\r\n     * deattributes the tokens respectively, to system modules.\r\n     *\r\n     * @param  _from            Address to decredit for withdraw\r\n     * @param  _to              Address to transfer tokens to\r\n     * @param  _token           Address of token being withdrawn\r\n     * @param  _quantity        Amount of tokens to withdraw\r\n     */\r\n    function withdrawModule(\r\n        address _from,\r\n        address _to,\r\n        address _token,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Exposes internal function that deposits multiple tokens to the vault, to system\r\n     * modules. Quantities should be in the order of the addresses of the tokens being\r\n     * deposited.\r\n     *\r\n     * @param  _from              Address to transfer tokens from\r\n     * @param  _to                Address to credit for deposits\r\n     * @param  _tokens            Array of the addresses of the tokens being deposited\r\n     * @param  _quantities        Array of the amounts of tokens to deposit\r\n     */\r\n    function batchDepositModule(\r\n        address _from,\r\n        address _to,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Exposes internal function that withdraws multiple tokens from the vault, to system\r\n     * modules. Quantities should be in the order of the addresses of the tokens being withdrawn.\r\n     *\r\n     * @param  _from              Address to decredit for withdrawals\r\n     * @param  _to                Address to transfer tokens to\r\n     * @param  _tokens            Array of the addresses of the tokens being withdrawn\r\n     * @param  _quantities        Array of the amounts of tokens to withdraw\r\n     */\r\n    function batchWithdrawModule(\r\n        address _from,\r\n        address _to,\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose internal function that exchanges components for Set tokens,\r\n     * accepting any owner, to system modules\r\n     *\r\n     * @param  _owner        Address to use tokens from\r\n     * @param  _recipient    Address to issue Set to\r\n     * @param  _set          Address of the Set to issue\r\n     * @param  _quantity     Number of tokens to issue\r\n     */\r\n    function issueModule(\r\n        address _owner,\r\n        address _recipient,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose internal function that exchanges Set tokens for components,\r\n     * accepting any owner, to system modules\r\n     *\r\n     * @param  _burnAddress         Address to burn token from\r\n     * @param  _incrementAddress    Address to increment component tokens to\r\n     * @param  _set                 Address of the Set to redeem\r\n     * @param  _quantity            Number of tokens to redeem\r\n     */\r\n    function redeemModule(\r\n        address _burnAddress,\r\n        address _incrementAddress,\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose vault function that increments user's balance in the vault.\r\n     * Available to system modules\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchIncrementTokenOwnerModule(\r\n        address[] calldata _tokens,\r\n        address _owner,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose vault function that decrement user's balance in the vault\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _tokens          The addresses of the ERC20 tokens\r\n     * @param  _owner           The address of the token owner\r\n     * @param  _quantities      The numbers of tokens to attribute to owner\r\n     */\r\n    function batchDecrementTokenOwnerModule(\r\n        address[] calldata _tokens,\r\n        address _owner,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose vault function that transfer vault balances between users\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _tokens           Addresses of tokens being transferred\r\n     * @param  _from             Address tokens being transferred from\r\n     * @param  _to               Address tokens being transferred to\r\n     * @param  _quantities       Amounts of tokens being transferred\r\n     */\r\n    function batchTransferBalanceModule(\r\n        address[] calldata _tokens,\r\n        address _from,\r\n        address _to,\r\n        uint256[] calldata _quantities\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Transfers token from one address to another using the transfer proxy.\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _token          The address of the ERC20 token\r\n     * @param  _quantity       The number of tokens to transfer\r\n     * @param  _from           The address to transfer from\r\n     * @param  _to             The address to transfer to\r\n     */\r\n    function transferModule(\r\n        address _token,\r\n        uint256 _quantity,\r\n        address _from,\r\n        address _to\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * Expose transfer proxy function to transfer tokens from one address to another\r\n     * Only available to system modules.\r\n     *\r\n     * @param  _tokens         The addresses of the ERC20 token\r\n     * @param  _quantities     The numbers of tokens to transfer\r\n     * @param  _from           The address to transfer from\r\n     * @param  _to             The address to transfer to\r\n     */\r\n    function batchTransferModule(\r\n        address[] calldata _tokens,\r\n        uint256[] calldata _quantities,\r\n        address _from,\r\n        address _to\r\n    )\r\n        external;\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/interfaces/ISetToken.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n/**\r\n * @title ISetToken\r\n * @author Set Protocol\r\n *\r\n * The ISetToken interface provides a light-weight, structured way to interact with the\r\n * SetToken contract from another contract.\r\n */\r\ninterface ISetToken {\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /*\r\n     * Get natural unit of Set\r\n     *\r\n     * @return  uint256       Natural unit of Set\r\n     */\r\n    function naturalUnit()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get addresses of all components in the Set\r\n     *\r\n     * @return  componentAddresses       Array of component tokens\r\n     */\r\n    function getComponents()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /*\r\n     * Get units of all tokens in Set\r\n     *\r\n     * @return  units       Array of component units\r\n     */\r\n    function getUnits()\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /*\r\n     * Checks to make sure token is component of Set\r\n     *\r\n     * @param  _tokenAddress     Address of token being checked\r\n     * @return  bool             True if token is component of Set\r\n     */\r\n    function tokenIsComponent(\r\n        address _tokenAddress\r\n    )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /*\r\n     * Mint set token for given address.\r\n     * Can only be called by authorized contracts.\r\n     *\r\n     * @param  _issuer      The address of the issuing account\r\n     * @param  _quantity    The number of sets to attribute to issuer\r\n     */\r\n    function mint(\r\n        address _issuer,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Burn set token for given address\r\n     * Can only be called by authorized contracts\r\n     *\r\n     * @param  _from        The address of the redeeming account\r\n     * @param  _quantity    The number of sets to burn from redeemer\r\n     */\r\n    function burn(\r\n        address _from,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /**\r\n    * Transfer token for a specified address\r\n    *\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external;\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/lib/SetTokenLibrary.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\nlibrary SetTokenLibrary {\r\n    using SafeMath for uint256;\r\n\r\n    struct SetDetails {\r\n        uint256 naturalUnit;\r\n        address[] components;\r\n        uint256[] units;\r\n    }\r\n\r\n    /**\r\n     * Validates that passed in tokens are all components of the Set\r\n     *\r\n     * @param _set                      Address of the Set\r\n     * @param _tokens                   List of tokens to check\r\n     */\r\n    function validateTokensAreComponents(\r\n        address _set,\r\n        address[] calldata _tokens\r\n    )\r\n        external\r\n        view\r\n    {\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            // Make sure all tokens are members of the Set\r\n            require(\r\n                ISetToken(_set).tokenIsComponent(_tokens[i]),\r\n                \"SetTokenLibrary.validateTokensAreComponents: Component must be a member of Set\"\r\n            );\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates that passed in quantity is a multiple of the natural unit of the Set.\r\n     *\r\n     * @param _set                      Address of the Set\r\n     * @param _quantity                 Quantity to validate\r\n     */\r\n    function isMultipleOfSetNaturalUnit(\r\n        address _set,\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        view\r\n    {\r\n        require(\r\n            _quantity.mod(ISetToken(_set).naturalUnit()) == 0,\r\n            \"SetTokenLibrary.isMultipleOfSetNaturalUnit: Quantity is not a multiple of nat unit\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Retrieves the Set's natural unit, components, and units.\r\n     *\r\n     * @param _set                      Address of the Set\r\n     * @return SetDetails               Struct containing the natural unit, components, and units\r\n     */\r\n    function getSetDetails(\r\n        address _set\r\n    )\r\n        internal\r\n        view\r\n        returns (SetDetails memory)\r\n    {\r\n        // Declare interface variables\r\n        ISetToken setToken = ISetToken(_set);\r\n\r\n        // Fetch set token properties\r\n        uint256 naturalUnit = setToken.naturalUnit();\r\n        address[] memory components = setToken.getComponents();\r\n        uint256[] memory units = setToken.getUnits();\r\n\r\n        return SetDetails({\r\n            naturalUnit: naturalUnit,\r\n            components: components,\r\n            units: units\r\n        });\r\n    }\r\n}\r\n\r\n// File: contracts/managers/lib/AllocatorMathLibrary.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title AllocatorMathLibrary\r\n * @author Set Protocol\r\n *\r\n * Library containing math helper function for Allocator.\r\n */\r\nlibrary AllocatorMathLibrary {\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n     * Rounds passed value to the nearest power of 2.\r\n     *\r\n     * @param  _value         Value to be rounded to nearest power of 2\r\n     * @return uint256        Rounded value\r\n     */\r\n    function roundToNearestPowerOfTwo(\r\n        uint256 _value\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // Multiply by 1.5 to roughly approximate sqrt(2). Needed to round to nearest power of two.\r\n        uint256 scaledValue = _value.mul(3) >> 1;\r\n        uint256 nearestValue = 1;\r\n\r\n        // Calculate nearest power of two\r\n        if (scaledValue >= 0x100000000000000000000000000000000) { scaledValue >>= 128; nearestValue <<= 128; }\r\n        if (scaledValue >= 0x10000000000000000) { scaledValue >>= 64; nearestValue <<= 64; }\r\n        if (scaledValue >= 0x100000000) { scaledValue >>= 32; nearestValue <<= 32; }\r\n        if (scaledValue >= 0x10000) { scaledValue >>= 16; nearestValue <<= 16; }\r\n        if (scaledValue >= 0x100) { scaledValue >>= 8; nearestValue <<= 8; }\r\n        if (scaledValue >= 0x10) { scaledValue >>= 4; nearestValue <<= 4; }\r\n        if (scaledValue >= 0x4) { scaledValue >>= 2; nearestValue <<= 2; }\r\n        if (scaledValue >= 0x2) nearestValue <<= 1; // No need to shift x anymore\r\n\r\n        return nearestValue;\r\n    }\r\n\r\n    /*\r\n     * Gets the rounded up log10 of passed value\r\n     *\r\n     * @param  _value         Value to calculate ceil(log()) on\r\n     * @return uint256        Output value\r\n     */\r\n    function ceilLog10(\r\n        uint256 _value\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // Make sure passed value is greater than 0\r\n        require (\r\n            _value > 0,\r\n            \"AllocatorMathLibrary.ceilLog10: Value must be greater than zero.\"\r\n        );\r\n\r\n        // Since log10(1) = 0, if _value = 1 return 0\r\n        if (_value == 1) return 0;\r\n\r\n        // Calcualte ceil(log10())\r\n        uint256 x = _value - 1;\r\n\r\n        uint256 result = 0;\r\n\r\n        if (x >= 10 ** 64) {\r\n            x /= 10 ** 64;\r\n            result += 64;\r\n        }\r\n        if (x >= 10 ** 32) {\r\n            x /= 10 ** 32;\r\n            result += 32;\r\n        }\r\n        if (x >= 10 ** 16) {\r\n            x /= 10 ** 16;\r\n            result += 16;\r\n        }\r\n        if (x >= 10 ** 8) {\r\n            x /= 10 ** 8;\r\n            result += 8;\r\n        }\r\n        if (x >= 10 ** 4) {\r\n            x /= 10 ** 4;\r\n            result += 4;\r\n        }\r\n        if (x >= 100) {\r\n            x /= 100;\r\n            result += 2;\r\n        }\r\n        if (x >= 10) {\r\n            result += 1;\r\n        }\r\n\r\n        return result + 1;\r\n    }\r\n\r\n    /*\r\n     * Round up division by subtracting one from numerator, dividing, then adding one.\r\n     *\r\n     * @param  _numerator         Numerator of expression\r\n     * @param  _denominator       Denominator of expression\r\n     * @return uint256            Output value\r\n     */\r\n    function roundUpDivision(\r\n        uint256 _numerator,\r\n        uint256 _denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return _numerator.sub(1).div(_denominator).add(1);\r\n    }\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/lib/RebalancingLibrary.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title RebalancingLibrary\r\n * @author Set Protocol\r\n *\r\n * The RebalancingLibrary contains functions for facilitating the rebalancing process for\r\n * Rebalancing Set Tokens. Removes the old calculation functions\r\n *\r\n */\r\nlibrary RebalancingLibrary {\r\n\r\n    /* ============ Enums ============ */\r\n\r\n    enum State { Default, Proposal, Rebalance, Drawdown }\r\n\r\n    /* ============ Structs ============ */\r\n\r\n    struct AuctionPriceParameters {\r\n        uint256 auctionStartTime;\r\n        uint256 auctionTimeToPivot;\r\n        uint256 auctionStartPrice;\r\n        uint256 auctionPivotPrice;\r\n    }\r\n\r\n    struct BiddingParameters {\r\n        uint256 minimumBid;\r\n        uint256 remainingCurrentSets;\r\n        uint256[] combinedCurrentUnits;\r\n        uint256[] combinedNextSetUnits;\r\n        address[] combinedTokenArray;\r\n    }\r\n}\r\n\r\n// File: set-protocol-contracts/contracts/core/interfaces/IRebalancingSetToken.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title IRebalancingSetToken\r\n * @author Set Protocol\r\n *\r\n * The IRebalancingSetToken interface provides a light-weight, structured way to interact with the\r\n * RebalancingSetToken contract from another contract.\r\n */\r\n\r\ninterface IRebalancingSetToken {\r\n\r\n    /*\r\n     * Get the auction library contract used for the current rebalance\r\n     *\r\n     * @return address    Address of auction library used in the upcoming auction\r\n     */\r\n    function auctionLibrary()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /*\r\n     * Get totalSupply of Rebalancing Set\r\n     *\r\n     * @return  totalSupply\r\n     */\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get proposalTimeStamp of Rebalancing Set\r\n     *\r\n     * @return  proposalTimeStamp\r\n     */\r\n    function proposalStartTime()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get lastRebalanceTimestamp of Rebalancing Set\r\n     *\r\n     * @return  lastRebalanceTimestamp\r\n     */\r\n    function lastRebalanceTimestamp()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get rebalanceInterval of Rebalancing Set\r\n     *\r\n     * @return  rebalanceInterval\r\n     */\r\n    function rebalanceInterval()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get rebalanceState of Rebalancing Set\r\n     *\r\n     * @return RebalancingLibrary.State    Current rebalance state of the RebalancingSetToken\r\n     */\r\n    function rebalanceState()\r\n        external\r\n        view\r\n        returns (RebalancingLibrary.State);\r\n\r\n    /*\r\n     * Get the starting amount of current SetToken for the current auction\r\n     *\r\n     * @return  rebalanceState\r\n     */\r\n    function startingCurrentSetAmount()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Gets the balance of the specified address.\r\n     *\r\n     * @param owner      The address to query the balance of.\r\n     * @return           A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(\r\n        address owner\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Function used to set the terms of the next rebalance and start the proposal period\r\n     *\r\n     * @param _nextSet                      The Set to rebalance into\r\n     * @param _auctionLibrary               The library used to calculate the Dutch Auction price\r\n     * @param _auctionTimeToPivot           The amount of time for the auction to go ffrom start to pivot price\r\n     * @param _auctionStartPrice            The price to start the auction at\r\n     * @param _auctionPivotPrice            The price at which the price curve switches from linear to exponential\r\n     */\r\n    function propose(\r\n        address _nextSet,\r\n        address _auctionLibrary,\r\n        uint256 _auctionTimeToPivot,\r\n        uint256 _auctionStartPrice,\r\n        uint256 _auctionPivotPrice\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Get natural unit of Set\r\n     *\r\n     * @return  uint256       Natural unit of Set\r\n     */\r\n    function naturalUnit()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Returns the address of the current base SetToken with the current allocation\r\n     *\r\n     * @return           A address representing the base SetToken\r\n     */\r\n    function currentSet()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * Returns the address of the next base SetToken with the post auction allocation\r\n     *\r\n     * @return  address    Address representing the base SetToken\r\n     */\r\n    function nextSet()\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /*\r\n     * Get the unit shares of the rebalancing Set\r\n     *\r\n     * @return  unitShares       Unit Shares of the base Set\r\n     */\r\n    function unitShares()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Burn set token for given address.\r\n     * Can only be called by authorized contracts.\r\n     *\r\n     * @param  _from        The address of the redeeming account\r\n     * @param  _quantity    The number of sets to burn from redeemer\r\n     */\r\n    function burn(\r\n        address _from,\r\n        uint256 _quantity\r\n    )\r\n        external;\r\n\r\n    /*\r\n     * Place bid during rebalance auction. Can only be called by Core.\r\n     *\r\n     * @param _quantity                 The amount of currentSet to be rebalanced\r\n     * @return combinedTokenArray       Array of token addresses invovled in rebalancing\r\n     * @return inflowUnitArray          Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray         Array of amount of tokens taken out of system in bid\r\n     */\r\n    function placeBid(\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        returns (address[] memory, uint256[] memory, uint256[] memory);\r\n\r\n    /*\r\n     * Get combinedTokenArray of Rebalancing Set\r\n     *\r\n     * @return  combinedTokenArray\r\n     */\r\n    function getCombinedTokenArrayLength()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /*\r\n     * Get combinedTokenArray of Rebalancing Set\r\n     *\r\n     * @return  combinedTokenArray\r\n     */\r\n    function getCombinedTokenArray()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /*\r\n     * Get failedAuctionWithdrawComponents of Rebalancing Set\r\n     *\r\n     * @return  failedAuctionWithdrawComponents\r\n     */\r\n    function getFailedAuctionWithdrawComponents()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /*\r\n     * Get auctionPriceParameters for current auction\r\n     *\r\n     * @return uint256[4]    AuctionPriceParameters for current rebalance auction\r\n     */\r\n    function getAuctionPriceParameters()\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /*\r\n     * Get biddingParameters for current auction\r\n     *\r\n     * @return uint256[2]    BiddingParameters for current rebalance auction\r\n     */\r\n    function getBiddingParameters()\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /*\r\n     * Get token inflows and outflows required for bid. Also the amount of Rebalancing\r\n     * Sets that would be generated.\r\n     *\r\n     * @param _quantity               The amount of currentSet to be rebalanced\r\n     * @return inflowUnitArray        Array of amount of tokens inserted into system in bid\r\n     * @return outflowUnitArray       Array of amount of tokens taken out of system in bid\r\n     */\r\n    function getBidPrice(\r\n        uint256 _quantity\r\n    )\r\n        external\r\n        view\r\n        returns (uint256[] memory, uint256[] memory);\r\n\r\n}\r\n\r\n// File: contracts/external/DappHub/interfaces/IMedian.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title IMedian\r\n * @author Set Protocol\r\n *\r\n * Interface for operating with a price feed Medianizer contract\r\n */\r\ninterface IMedian {\r\n\r\n    /**\r\n     * Returns the current price set on the medianizer. Throws if the price is set to 0 (initialization)\r\n     *\r\n     * @return  Current price of asset represented in hex as bytes32\r\n     */\r\n    function read()\r\n        external\r\n        view\r\n        returns (bytes32);\r\n\r\n    /**\r\n     * Returns the current price set on the medianizer and whether the value has been initialized\r\n     *\r\n     * @return  Current price of asset represented in hex as bytes32, and whether value is non-zero\r\n     */\r\n    function peek()\r\n        external\r\n        view\r\n        returns (bytes32, bool);\r\n}\r\n\r\n// File: contracts/managers/lib/FlexibleTimingManagerLibrary.sol\r\n\r\n/*\r\n    Copyright 2018 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title FlexibleTimingManagerLibrary\r\n * @author Set Protocol\r\n *\r\n * The FlexibleTimingManagerLibrary contains functions for helping Managers create proposals\r\n *\r\n */\r\nlibrary FlexibleTimingManagerLibrary {\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n     * Validates whether the Rebalancing Set is in the correct state and sufficient time has elapsed.\r\n     *\r\n     * @param  _rebalancingSetInterface      Instance of the Rebalancing Set Token\r\n     */\r\n    function validateManagerPropose(\r\n        IRebalancingSetToken _rebalancingSetInterface\r\n    )\r\n        internal\r\n    {\r\n        // Require that enough time has passed from last rebalance\r\n        uint256 lastRebalanceTimestamp = _rebalancingSetInterface.lastRebalanceTimestamp();\r\n        uint256 rebalanceInterval = _rebalancingSetInterface.rebalanceInterval();\r\n        require(\r\n            block.timestamp >= lastRebalanceTimestamp.add(rebalanceInterval),\r\n            \"FlexibleTimingManagerLibrary.proposeNewRebalance: Rebalance interval not elapsed\"\r\n        );\r\n\r\n        // Require that Rebalancing Set Token is in Default state, won't allow for re-proposals\r\n        // because malicious actor could prevent token from ever rebalancing\r\n        require(\r\n            _rebalancingSetInterface.rebalanceState() == RebalancingLibrary.State.Default,\r\n            \"FlexibleTimingManagerLibrary.proposeNewRebalance: State must be in Default\"\r\n        );\r\n    }\r\n\r\n    /*\r\n    /*\r\n     * Calculates the auction price parameters, targetting 1% slippage every 10 minutes. Fair value\r\n     * placed in middle of price range.\r\n     *\r\n     * @param  _currentSetDollarAmount      The 18 decimal value of one currenSet\r\n     * @param  _nextSetDollarAmount         The 18 decimal value of one nextSet\r\n     * @param  _timeIncrement               Amount of time to explore 1% of fair value price change\r\n     * @param  _auctionLibraryPriceDivisor  The auction library price divisor\r\n     * @param  _auctionTimeToPivot          The auction time to pivot\r\n     * @return uint256                      The auctionStartPrice for rebalance auction\r\n     * @return uint256                      The auctionPivotPrice for rebalance auction\r\n     */\r\n    function calculateAuctionPriceParameters(\r\n        uint256 _currentSetDollarAmount,\r\n        uint256 _nextSetDollarAmount,\r\n        uint256 _timeIncrement,\r\n        uint256 _auctionLibraryPriceDivisor,\r\n        uint256 _auctionTimeToPivot\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        // Determine fair value of nextSet/currentSet and put in terms of auction library price divisor\r\n        uint256 fairValue = _nextSetDollarAmount.mul(_auctionLibraryPriceDivisor).div(_currentSetDollarAmount);\r\n        // Calculate how much one percent slippage from fair value is\r\n        uint256 onePercentSlippage = fairValue.div(100);\r\n\r\n        // Calculate how many time increments are in auctionTimeToPivot\r\n        uint256 timeIncrements = _auctionTimeToPivot.div(_timeIncrement);\r\n        // Since we are targeting a 1% slippage every time increment the price range is defined as\r\n        // the price of a 1% move multiplied by the amount of time increments in the auctionTimeToPivot\r\n        // This value is then divided by two to get half the price range\r\n        uint256 halfPriceRange = timeIncrements.mul(onePercentSlippage).div(2);\r\n\r\n        // Auction start price is fair value minus half price range to center the auction at fair value\r\n        uint256 auctionStartPrice = fairValue.sub(halfPriceRange);\r\n        // Auction pivot price is fair value plus half price range to center the auction at fair value\r\n        uint256 auctionPivotPrice = fairValue.add(halfPriceRange);\r\n\r\n        return (auctionStartPrice, auctionPivotPrice);\r\n    }\r\n\r\n    /*\r\n     * Query the Medianizer price feeds for a value that is returned as a Uint. Prices\r\n     * have 18 decimals.\r\n     *\r\n     * @param  _priceFeedAddress            Address of the medianizer price feed\r\n     * @return uint256                      The price from the price feed with 18 decimals\r\n     */\r\n    function queryPriceData(\r\n        address _priceFeedAddress\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Get prices from oracles\r\n        bytes32 priceInBytes = IMedian(_priceFeedAddress).read();\r\n\r\n        return uint256(priceInBytes);\r\n    }\r\n\r\n    /*\r\n     * Calculates the USD Value of a Set Token - by taking the individual token prices, units\r\n     * and decimals.\r\n     *\r\n     * @param  _tokenPrices         The 18 decimal values of components\r\n     * @param  _naturalUnit         The naturalUnit of the set being component belongs to\r\n     * @param  _units               The units of the components in the Set\r\n     * @param  _tokenDecimals       The components decimal values\r\n     * @return uint256              The USD value of the Set (in cents)\r\n     */\r\n    function calculateSetTokenDollarValue(\r\n        uint256[] memory _tokenPrices,\r\n        uint256 _naturalUnit,\r\n        uint256[] memory _units,\r\n        uint256[] memory _tokenDecimals\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 setDollarAmount = 0;\r\n\r\n        // Loop through assets\r\n        for (uint256 i = 0; i < _tokenPrices.length; i++) {\r\n            uint256 tokenDollarValue = calculateTokenAllocationAmountUSD(\r\n                _tokenPrices[i],\r\n                _naturalUnit,\r\n                _units[i],\r\n                _tokenDecimals[i]\r\n            );\r\n\r\n            setDollarAmount = setDollarAmount.add(tokenDollarValue);\r\n        }\r\n\r\n        return setDollarAmount;\r\n    }\r\n\r\n    /*\r\n     * Get USD value of one component in a Set to 18 decimals\r\n     *\r\n     * @param  _tokenPrice          The 18 decimal value of one full token\r\n     * @param  _naturalUnit         The naturalUnit of the set being component belongs to\r\n     * @param  _unit                The unit of the component in the set\r\n     * @param  _tokenDecimals       The component token's decimal value\r\n     * @return uint256              The USD value of the component's allocation in the Set\r\n     */\r\n    function calculateTokenAllocationAmountUSD(\r\n        uint256 _tokenPrice,\r\n        uint256 _naturalUnit,\r\n        uint256 _unit,\r\n        uint256 _tokenDecimals\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 SET_TOKEN_DECIMALS = 18;\r\n\r\n        // Calculate the amount of component base units are in one full set token\r\n        uint256 componentUnitsInFullToken = _unit\r\n            .mul(10 ** SET_TOKEN_DECIMALS)\r\n            .div(_naturalUnit);\r\n\r\n        // Return value of component token in one full set token, to 18 decimals\r\n        uint256 allocationUSDValue = _tokenPrice\r\n            .mul(componentUnitsInFullToken)\r\n            .div(10 ** _tokenDecimals);\r\n\r\n        require(\r\n            allocationUSDValue > 0,\r\n            \"FlexibleTimingManagerLibrary.calculateTokenAllocationAmountUSD: Value must be > 0\"\r\n        );\r\n\r\n        return allocationUSDValue;\r\n    }\r\n}\r\n\r\n// File: contracts/managers/allocators/IAllocator.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title IAllocator\r\n * @author Set Protocol\r\n *\r\n * Interface for interacting with Allocator contracts\r\n */\r\ninterface IAllocator {\r\n\r\n    /*\r\n     * Determine the next allocation to rebalance into.\r\n     *\r\n     * @param  _targetBaseAssetAllocation       Target allocation of the base asset\r\n     * @param  _allocationPrecision             Precision of allocation percentage\r\n     * @param  _currentCollateralSet            Instance of current set collateralizing RebalancingSetToken\r\n     * @return address                          The address of the proposed nextSet\r\n     */\r\n    function determineNewAllocation(\r\n        uint256 _targetBaseAssetAllocation,\r\n        uint256 _allocationPrecision,\r\n        ISetToken _currentCollateralSet\r\n    )\r\n        external\r\n        returns (ISetToken);\r\n\r\n    /*\r\n     * Calculate value of passed collateral set.\r\n     *\r\n     * @param  _collateralSet        Instance of current set collateralizing RebalancingSetToken\r\n     * @return uint256               USD value of passed Set\r\n     */\r\n    function calculateCollateralSetValue(\r\n        ISetToken _collateralSet\r\n    )\r\n        external\r\n        view\r\n        returns(uint256);\r\n}\r\n\r\n// File: contracts/meta-oracles/interfaces/IOracle.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title IOracle\r\n * @author Set Protocol\r\n *\r\n * Interface for operating with any external Oracle that returns uint256 or\r\n * an adapting contract that converts oracle output to uint256\r\n */\r\ninterface IOracle {\r\n\r\n    /**\r\n     * Returns the queried data from an oracle returning uint256\r\n     *\r\n     * @return  Current price of asset represented in uint256\r\n     */\r\n    function read()\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/managers/allocators/BinaryAllocator.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\npragma experimental \"ABIEncoderV2\";\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title BinaryAllocator\r\n * @author Set Protocol\r\n *\r\n * Implementing IAllocator the BinaryAllocator flips between two all or nothing\r\n * allocations of the base asset depending what allocation the calling manager is seeking. In\r\n * addition, if either collateral Set becomes 4x more valuable than the other the contract will\r\n * create a new collateral Set and use that Set going forward.\r\n */\r\ncontract BinaryAllocator is\r\n    IAllocator\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    /* ============ Events ============ */\r\n\r\n    event NewCollateralTracked(\r\n        bytes32 indexed _hash,\r\n        address indexed _collateralAddress\r\n    );\r\n\r\n    /* ============ Constants ============ */\r\n    uint256 constant public MINIMUM_COLLATERAL_NATURAL_UNIT_DECIMALS = 6;\r\n\r\n    /* ============ State Variables ============ */\r\n    ICore public core;\r\n    address public setTokenFactory;\r\n\r\n    ERC20Detailed public baseAsset;\r\n    ERC20Detailed public quoteAsset;\r\n    IOracle public baseAssetOracle;\r\n    IOracle public quoteAssetOracle;\r\n    uint8 public baseAssetDecimals;\r\n    uint8 public quoteAssetDecimals;\r\n\r\n    // Hash of collateral units, naturalUnit, and component maps to collateral address\r\n    mapping(bytes32 => ISetToken) public storedCollateral;\r\n\r\n    /*\r\n     * BinaryAllocator constructor.\r\n     *\r\n     * @param  _baseAsset                   The baseAsset address\r\n     * @param  _quoteAsset                  The quoteAsset address\r\n     * @param  _baseAssetOracle             The baseAsset oracle\r\n     * @param  _quoteAssetOracle            The quoteAsset oracle\r\n     * @param  _baseAssetCollateral         The baseAsset collateral Set\r\n     * @param  _quoteAssetCollateral        The quoteAsset collateral Set\r\n     * @param  _core                        The address of the Core contract\r\n     * @param  _setTokenFactory             The address of SetTokenFactory used to create new collateral\r\n     */\r\n    constructor(\r\n        ERC20Detailed _baseAsset,\r\n        ERC20Detailed _quoteAsset,\r\n        IOracle _baseAssetOracle,\r\n        IOracle _quoteAssetOracle,\r\n        ISetToken _baseAssetCollateral,\r\n        ISetToken _quoteAssetCollateral,\r\n        ICore _core,\r\n        address _setTokenFactory\r\n    )\r\n        public\r\n    {\r\n        // Get components of collateral instances\r\n        address[] memory baseAssetCollateralComponents = _baseAssetCollateral.getComponents();\r\n        address[] memory quoteAssetCollateralComponents = _quoteAssetCollateral.getComponents();\r\n\r\n        // Check that component arrays only have one component\r\n        validateSingleItemArray(baseAssetCollateralComponents);\r\n        validateSingleItemArray(quoteAssetCollateralComponents);\r\n\r\n        // Make sure collateral instances are using the correct base and quote asset\r\n        require(\r\n            baseAssetCollateralComponents[0] == address(_baseAsset),\r\n            \"BinaryAllocator.constructor: Base collateral component must match base asset.\"\r\n        );\r\n\r\n        require(\r\n            quoteAssetCollateralComponents[0] == address(_quoteAsset),\r\n            \"BinaryAllocator.constructor: Quote collateral component must match quote asset.\"\r\n        );\r\n\r\n        baseAsset = _baseAsset;\r\n        quoteAsset = _quoteAsset;\r\n\r\n        baseAssetOracle = _baseAssetOracle;\r\n        quoteAssetOracle = _quoteAssetOracle;\r\n\r\n        // Query decimals of base and quote assets\r\n        baseAssetDecimals = _baseAsset.decimals();\r\n        quoteAssetDecimals = _quoteAsset.decimals();\r\n\r\n        // Set Core and setTokenFactory\r\n        core = _core;\r\n        setTokenFactory = _setTokenFactory;\r\n\r\n        // Store passed in collateral in mapping\r\n        bytes32 baseCollateralHash = calculateCollateralIDHashFromSet(\r\n            _baseAssetCollateral\r\n        );\r\n        bytes32 quoteCollateralHash = calculateCollateralIDHashFromSet(\r\n            _quoteAssetCollateral\r\n        );\r\n        storedCollateral[baseCollateralHash] = _baseAssetCollateral;\r\n        storedCollateral[quoteCollateralHash] = _quoteAssetCollateral;\r\n\r\n        emit NewCollateralTracked(baseCollateralHash, address(_baseAssetCollateral));\r\n        emit NewCollateralTracked(quoteCollateralHash, address(_quoteAssetCollateral));\r\n    }\r\n\r\n    /* ============ External ============ */\r\n\r\n    /*\r\n     * Determine the next allocation to rebalance into. If the dollar value of the two collateral sets is more\r\n     * than 4x different from each other then create a new collateral set. If currently 100% in baseAsset then\r\n     * a new quote collateral set is created if 0% in baseAsset then a new base collateral set is created.\r\n     *\r\n     * @param  _targetBaseAssetAllocation       Target allocation of the base asset\r\n     * @param  _allocationPrecision             Precision of allocation percentage\r\n     * @param  _currentCollateralSet            Instance of current set collateralizing RebalancingSetToken\r\n     * @return address                          The address of the proposed nextSet\r\n     */\r\n    function determineNewAllocation(\r\n        uint256 _targetBaseAssetAllocation,\r\n        uint256 _allocationPrecision,\r\n        ISetToken _currentCollateralSet\r\n    )\r\n        external\r\n        returns (ISetToken)\r\n    {\r\n        require(\r\n            _targetBaseAssetAllocation == _allocationPrecision || _targetBaseAssetAllocation == 0,\r\n            \"BinaryAllocator.determineNewAllocation: Passed allocation must be equal to allocationPrecision or 0.\"\r\n        );\r\n\r\n        // Determine if rebalance is to the baseAsset\r\n        bool toBaseAsset = (_targetBaseAssetAllocation == _allocationPrecision);\r\n\r\n        validateCurrentCollateralSet(\r\n            _currentCollateralSet,\r\n            toBaseAsset\r\n        );\r\n\r\n        // Calculate currentSetValue, toBaseAsset inverted here because calculating currentSet value which would be\r\n        // using opposite collateral asset of toBaseAsset\r\n        uint256 currentSetValue = calculateCollateralSetValueInternal(\r\n            address(_currentCollateralSet),\r\n            !toBaseAsset\r\n        );\r\n\r\n        // Check to see if new collateral must be created in order to keep collateral price ratio in line.\r\n        // If not just return the dollar value of current collateral sets\r\n        (\r\n            ERC20Detailed nextSetComponent,\r\n            uint256 nextSetUnit,\r\n            uint256 nextSetNaturalUnit\r\n        ) = calculateNextCollateralParameters(\r\n            currentSetValue,\r\n            toBaseAsset\r\n        );\r\n\r\n        ISetToken nextSet = createOrSelectNextSet(\r\n            nextSetComponent,\r\n            nextSetUnit,\r\n            nextSetNaturalUnit\r\n        );\r\n\r\n        return nextSet;\r\n    }\r\n\r\n    /*\r\n     * Calculate value of passed collateral set.\r\n     *\r\n     * @param  _collateralSet         of current set collateralizing RebalancingSetToken\r\n     * @return uint256               USD value of passed Set\r\n     */\r\n    function calculateCollateralSetValue(\r\n        ISetToken _collateralSet\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        address[] memory setComponents = _collateralSet.getComponents();\r\n\r\n        // Check that setComponents only has one component\r\n        validateSingleItemArray(setComponents);\r\n\r\n        return calculateCollateralSetValueInternal(\r\n            address(_collateralSet),\r\n            setComponents[0] == address(baseAsset)\r\n        );\r\n    }\r\n\r\n    /* ============ Internal ============ */\r\n\r\n    /*\r\n     * Create CollateralIDHash based on nextSet parameters. If hash already exists then use collateral\r\n     * set associated with that hash. If hash does not already exist then create new collateral set and\r\n     * store in storedCollateral mapping.\r\n     *\r\n     * @param  _nextSetComponent        Component of nextSet\r\n     * @param  _nextSetUnit             Unit of nextSet\r\n     * @param  _nextSetNaturalUnit      NaturalUnit of nextSet\r\n     * @return address                  Address of nextSet\r\n     */\r\n    function createOrSelectNextSet(\r\n        ERC20Detailed _nextSetComponent,\r\n        uint256 _nextSetUnit,\r\n        uint256 _nextSetNaturalUnit\r\n    )\r\n        internal\r\n        returns (ISetToken)\r\n    {\r\n        // Create collateralIDHash\r\n        bytes32 collateralIDHash = calculateCollateralIDHash(\r\n            _nextSetUnit,\r\n            _nextSetNaturalUnit,\r\n            address(_nextSetComponent)\r\n        );\r\n\r\n        // If collateralIDHash exists then use existing collateral set otherwise create new collateral and\r\n        // store in mapping\r\n        if (address(storedCollateral[collateralIDHash]) != address(0)) {\r\n            return storedCollateral[collateralIDHash];\r\n        } else {\r\n            // Determine new collateral name and symbol\r\n            (\r\n                bytes32 nextCollateralName,\r\n                bytes32 nextCollateralSymbol\r\n            ) = _nextSetComponent == baseAsset ? (bytes32(\"BaseAssetCollateral\"), bytes32(\"BACOL\")) :\r\n                (bytes32(\"QuoteAssetCollateral\"), bytes32(\"QACOL\"));\r\n\r\n            // Create unit and component arrays for SetToken creation\r\n            uint256[] memory nextSetUnits = new uint256[](1);\r\n            address[] memory nextSetComponents = new address[](1);\r\n            nextSetUnits[0] = _nextSetUnit;\r\n            nextSetComponents[0] = address(_nextSetComponent);\r\n\r\n            // Create new collateral set with passed components, units, and naturalUnit\r\n            address nextSetAddress = core.createSet(\r\n                setTokenFactory,\r\n                nextSetComponents,\r\n                nextSetUnits,\r\n                _nextSetNaturalUnit,\r\n                nextCollateralName,\r\n                nextCollateralSymbol,\r\n                \"\"\r\n            );\r\n\r\n            // Store new collateral in mapping\r\n            storedCollateral[collateralIDHash] = ISetToken(nextSetAddress);\r\n\r\n            emit NewCollateralTracked(collateralIDHash, nextSetAddress);\r\n\r\n            return ISetToken(nextSetAddress);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Validate passed parameters to make sure target allocation is either 0 or 100 and that the currentSet\r\n     * was created by core and is made up of the correct component. Finally, return a boolean indicating\r\n     * whether new allocation should be in baseAsset.\r\n     *\r\n     * @param  _currentCollateralSet            Instance of current set collateralizing RebalancingSetToken\r\n     * @param  _toBaseAsset                     Boolean indicating whether new collateral is made of baseAsset\r\n     */\r\n    function validateCurrentCollateralSet(\r\n        ISetToken _currentCollateralSet,\r\n        bool _toBaseAsset\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        // Make sure passed currentSet was created by Core\r\n        require(\r\n            core.validSets(address(_currentCollateralSet)),\r\n            \"BinaryAllocator.validateCurrentCollateralSet: Passed collateralSet must be tracked by Core.\"\r\n        );\r\n\r\n        // Get current set components\r\n        address[] memory currentSetComponents = _currentCollateralSet.getComponents();\r\n\r\n        // Make sure current set component array is one item long\r\n        require(\r\n            currentSetComponents.length == 1,\r\n            \"BinaryAllocator.validateCurrentCollateralSet: Passed collateral set must have one component.\"\r\n        );\r\n\r\n        // Make sure that currentSet component is opposite of expected component to be rebalanced into\r\n        address requiredComponent = _toBaseAsset ? address(quoteAsset) : address(baseAsset);\r\n        require(\r\n            currentSetComponents[0] == requiredComponent,\r\n            \"BinaryAllocator.validateCurrentCollateralSet: New allocation doesn't match currentSet component.\"\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Calculate value of passed collateral set.\r\n     *\r\n     * @param  _currentCollateralSet        Instance of current set collateralizing RebalancingSetToken\r\n     * @param  _usingBaseAsset              Boolean indicating whether collateral set uses base asset\r\n     * @return uint256                      USD value of passed Set\r\n     */\r\n    function calculateCollateralSetValueInternal(\r\n        address _collateralSet,\r\n        bool _usingBaseAsset\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Gather price and decimal information for current collateral component\r\n        (\r\n            uint256 currentComponentPrice,\r\n            uint256 currentComponentDecimals\r\n        ) = getComponentPriceAndDecimalData(_usingBaseAsset);\r\n\r\n        // Get currentSet Details and use to value passed currentSet\r\n        SetTokenLibrary.SetDetails memory currentSetDetails = SetTokenLibrary.getSetDetails(\r\n            address(_collateralSet)\r\n        );\r\n\r\n        // Calculate collateral set value\r\n        return FlexibleTimingManagerLibrary.calculateTokenAllocationAmountUSD(\r\n            currentComponentPrice,\r\n            currentSetDetails.naturalUnit,\r\n            currentSetDetails.units[0],\r\n            currentComponentDecimals\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Calculate new collateral units and natural unit. Return new component address The system of\r\n     * equations to determine unit and naturalUnit is as follows:\r\n     *\r\n     * naturalUnit = 10 ** k\r\n     * unit = log2(round(10^(d + k - 18) * V / P))\r\n     * k = max(6, log10(10^(18 - d) * P / V), 18-d)\r\n     *\r\n     * Where d is the decimals of the new component, P is the price of the new component, and V is the\r\n     * target value of the new Set.\r\n     *\r\n     * Implementation for k will be split as such,\r\n     * kOne = max(6, 18-d)\r\n     * kTwo = log10(10^(18 - d) * P / V)\r\n     * k = max(kOne, kTwo)\r\n     *\r\n     * @param  _targetCollateralUSDValue      USD Value of current collateral set\r\n     * @param  _newComponentPrice             Price of underlying token to be rebalanced into\r\n     * @param  _newComponentDecimals          Amount of decimals in replacement token\r\n     * @return ERCDetailed                    Instance of new collateral component\r\n     * @return uint256                        Units for new collateral set\r\n     * @return uint256                        NaturalUnit for new collateral set\r\n     */\r\n    function calculateNextCollateralParameters(\r\n        uint256 _currentSetValue,\r\n        bool _toBaseAsset\r\n    )\r\n        internal\r\n        view\r\n        returns (ERC20Detailed, uint256, uint256)\r\n    {\r\n        // Gather price and decimal information for next collateral components\r\n        (\r\n            uint256 nextSetComponentPrice,\r\n            uint8 nextSetComponentDecimals\r\n        ) = getComponentPriceAndDecimalData(_toBaseAsset);\r\n\r\n        // Determine minimum natural unit based on max of pre-defined minimum or (18 - decimals) of the\r\n        // component in the new Set.\r\n        uint256 kOne = Math.max(\r\n            MINIMUM_COLLATERAL_NATURAL_UNIT_DECIMALS,\r\n            uint256(18).sub(nextSetComponentDecimals)\r\n        );\r\n\r\n        // Intermediate step to calculate kTwo\r\n        uint256 intermediate = AllocatorMathLibrary.roundUpDivision(\r\n            CommonMath.safePower(uint256(10), uint256(18).sub(nextSetComponentDecimals)).mul(nextSetComponentPrice),\r\n            _currentSetValue\r\n        );\r\n\r\n        // Complete kTwo calculation by taking ceil(log10()) of intermediate\r\n        uint256 kTwo = AllocatorMathLibrary.ceilLog10(intermediate);\r\n\r\n        // k is max of kOne and kTwo\r\n        uint256 k = Math.max(kOne, kTwo);\r\n\r\n        // Get raw unit amount for nextSet\r\n        uint256 unroundedNextUnit = (uint256(10) ** uint256(nextSetComponentDecimals + k - 18))\r\n            .mul(_currentSetValue)\r\n            .div(nextSetComponentPrice);\r\n\r\n        // Round raw nextSet unit to nearest power of 2\r\n        uint256 nextSetUnit = AllocatorMathLibrary.roundToNearestPowerOfTwo(\r\n            unroundedNextUnit\r\n        );\r\n\r\n        // Get nextSetComponent\r\n        ERC20Detailed nextSetComponent = _toBaseAsset ? baseAsset : quoteAsset;\r\n\r\n        return (nextSetComponent, nextSetUnit, CommonMath.safePower(10, k));\r\n    }\r\n\r\n    /*\r\n     * Gets price and decimal information for component based on if looking for base or quote asset data\r\n     *\r\n     * @param  _usingBaseAsset         Boolean indicating whether to get information for base asset\r\n     * @return uint256                 USD Price of component\r\n     * @return uint8                   Decimal of component\r\n     */\r\n    function getComponentPriceAndDecimalData(\r\n        bool _usingBaseAsset\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256, uint8)\r\n    {\r\n        // If using base asset return baseAsset price and decimals and vice versa\r\n        if (_usingBaseAsset) {\r\n            return (baseAssetOracle.read(), baseAssetDecimals);\r\n        } else {\r\n            return (quoteAssetOracle.read(), quoteAssetDecimals);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Creates a CollateralIDHash from a passed SetToken instance.\r\n     *\r\n     * @param  _setToken         SetToken to make CollateralIDHash of\r\n     * @return bytes32           CollateralIDHash of SetToken\r\n     */\r\n    function calculateCollateralIDHashFromSet(\r\n        ISetToken _setToken\r\n    )\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        // Get SetToken details for use in calculating collateralIDHash\r\n        SetTokenLibrary.SetDetails memory setDetails = SetTokenLibrary.getSetDetails(\r\n            address(_setToken)\r\n        );\r\n\r\n        // Calculate CollateralIDHash\r\n        return calculateCollateralIDHash(\r\n            setDetails.units[0],\r\n            setDetails.naturalUnit,\r\n            setDetails.components[0]\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Creates a CollateralIDHash from passed SetToken parameters.\r\n     *\r\n     * @param  _units           Units of SetToken\r\n     * @param  _naturalUnit     NaturalUnit of SetToken\r\n     * @param  _component       Component of SetToken\r\n     * @return bytes32          CollateralIDHash of SetToken\r\n     */\r\n    function calculateCollateralIDHash(\r\n        uint256 _units,\r\n        uint256 _naturalUnit,\r\n        address _component\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                _units,\r\n                _naturalUnit,\r\n                _component\r\n            )\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Check that passed component array contains one component, else revert.\r\n     *\r\n     * @param  _array     Array to be evaluated\r\n     */\r\n    function validateSingleItemArray(\r\n        address[] memory _array\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        require(\r\n            _array.length == 1,\r\n            \"BinaryAllocator.validateSingleItemArray: Array contains more than one component.\"\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"baseAssetOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"storedCollateral\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseAssetDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"quoteAssetOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targetBaseAssetAllocation\",\"type\":\"uint256\"},{\"name\":\"_allocationPrecision\",\"type\":\"uint256\"},{\"name\":\"_currentCollateralSet\",\"type\":\"address\"}],\"name\":\"determineNewAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_collateralSet\",\"type\":\"address\"}],\"name\":\"calculateCollateralSetValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_COLLATERAL_NATURAL_UNIT_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"setTokenFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"quoteAssetDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"core\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"quoteAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_baseAsset\",\"type\":\"address\"},{\"name\":\"_quoteAsset\",\"type\":\"address\"},{\"name\":\"_baseAssetOracle\",\"type\":\"address\"},{\"name\":\"_quoteAssetOracle\",\"type\":\"address\"},{\"name\":\"_baseAssetCollateral\",\"type\":\"address\"},{\"name\":\"_quoteAssetCollateral\",\"type\":\"address\"},{\"name\":\"_core\",\"type\":\"address\"},{\"name\":\"_setTokenFactory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_collateralAddress\",\"type\":\"address\"}],\"name\":\"NewCollateralTracked\",\"type\":\"event\"}]","ContractName":"BinaryAllocator","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000898b1323292fce6f66404aed4c88fae4e5051db50000000000000000000000008920ab172362e42fcf576e17432359de1b1e463d000000000000000000000000b0b3aa8a76bf99cdbf17a0c1a0223d018138716a000000000000000000000000e82609a5f55f6f79bdb82013b0cb6dd8b01facf3000000000000000000000000345ab8af61d107c3972f0d73640e33d8ac545a07000000000000000000000000045f019a6d5d6e2e59bd11da4d00595d8d621fc3","Library":"","LicenseType":"Apache-2.0","SwarmSource":"bzzr://c9246931680ad93b39102df2d332230cbd0c6defd782173204311334ef61f40e"}]}