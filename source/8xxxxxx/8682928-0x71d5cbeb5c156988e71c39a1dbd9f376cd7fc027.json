{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/zeppelin/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/App5.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\ncontract FomoFeast5 {\r\n\r\n    /**\r\n     * MATH\r\n     */\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct User {\r\n        uint256 totalInvestCount;\r\n        uint256 totalInvestAmount;\r\n        uint256 totalStaticCommissionWithdrawAmount;\r\n        uint256 totalDynamicCommissionWithdrawAmount;\r\n        uint256 totalWithdrawAmount;\r\n        uint256 downlineCount;\r\n        uint256 nodeCount;\r\n        uint256 totalDownlineInvestAmount;\r\n        uint256 currentInvestTime;\r\n        uint256 currentInvestAmount;\r\n        uint256 currentInvestCycle;\r\n        uint256 currentlevel;\r\n        uint256 currentStaticCommissionRatio;\r\n        uint256 currentStaticCommissionWithdrawAmount;\r\n        uint256 staticCommissionBalance;\r\n        uint256 dynamicCommissionBalance;\r\n        uint256 calcDynamicCommissionAmount;\r\n        address sponsorAddress;\r\n    }\r\n\r\n    struct InvestRecord {\r\n        uint256 time;\r\n        uint256 amount;\r\n        uint256 cycle;\r\n    }\r\n\r\n    struct CommissionRecord {\r\n        uint256 time;\r\n        uint256 amount;\r\n    }\r\n\r\n    /**\r\n     * DATA\r\n     */\r\n\r\n    uint256 private constant ONE_ETH = 1 ether;\r\n    uint256 private constant ONE_DAY = 1 days;\r\n    address private constant GENESIS_USER_ADDRESS = 0xe00d13D53Ba180EAD5F4838BD56b15629026A8C9;\r\n    address private constant ENGINEER_ADDRESS = 0xddf0bB01f81059CCdB3D5bF5b1C7Bd540aDDFEac;\r\n    address payable private constant NOAH_ADDRESS = 0x696b5D0D5dB7c3320636341C2dBe2c11de332d50;\r\n\r\n    // INITIALIZATION DATA\r\n    bool private initialized = false;\r\n\r\n    // OWNER DATA\r\n    address public owner;\r\n\r\n    uint256 public totalInvestCount;\r\n    uint256 public totalInvestAmount;\r\n    uint256 public totalStaticCommissionWithdrawAmount;\r\n    uint256 public totalDynamicCommissionWithdrawAmount;\r\n    uint256 public totalWithdrawAmount;\r\n    uint256 public totalUserCount;\r\n    uint256 public engineerFunds;\r\n    uint256 public engineerWithdrawAmount;\r\n    uint256 public operatorFunds;\r\n    uint256 public operatorWithdrawAmount;\r\n\r\n    mapping (address => User) private userMapping;\r\n    mapping (uint256 => address) private addressMapping;\r\n    mapping (address => InvestRecord[9]) private investRecordMapping;\r\n    mapping (address => CommissionRecord[9]) private staticCommissionRecordMapping;\r\n    mapping (address => CommissionRecord[9]) private dynamicCommissionRecordMapping;\r\n\r\n    /**\r\n     * FUNCTIONALITY\r\n     */\r\n\r\n    // INITIALIZATION FUNCTIONALITY\r\n\r\n    /**\r\n     * @dev sets 0 initials tokens, the owner, and the supplyController.\r\n     * this serves as the constructor for the proxy but compiles to the\r\n     * memory model of the Implementation contract.\r\n     */\r\n    function initialize() public {\r\n        require(!initialized, \"already initialized\");\r\n        owner = msg.sender;\r\n        userMapping[GENESIS_USER_ADDRESS] = User(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, address(0));\r\n        initialized = true;\r\n    }\r\n\r\n    /**\r\n     * The constructor is used here to ensure that the implementation\r\n     * contract is initialized. An uncontrolled implementation\r\n     * contract might lead to misleading state\r\n     * for users who accidentally interact with it.\r\n     */\r\n    constructor() public {\r\n        initialize();\r\n    }\r\n\r\n    // OWNER FUNCTIONALITY\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"onlyOwner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyEngineer() {\r\n        require(msg.sender == ENGINEER_ADDRESS, \"onlyEngineer\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"cannot transfer ownership to address zero\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    function getLevelByInvestAmount(uint256 investAmount) private pure returns (uint256 level) {\r\n        if (investAmount >= ONE_ETH.mul(11)) {\r\n            level = 3;\r\n        } else if (investAmount >= ONE_ETH.mul(6)) {\r\n            level = 2;\r\n        } else {\r\n            level = 1;\r\n        }\r\n    }\r\n\r\n    function isInvestExpired(User memory user) private view returns (bool expired) {\r\n        expired = (user.currentInvestTime.add(user.currentInvestCycle.mul(ONE_DAY)) < now);\r\n    }\r\n\r\n    function getAbortInvestAmount(User memory user) private view returns (uint256 amount) {\r\n        uint256 commissionDays = now.sub(user.currentInvestTime).div(ONE_DAY);\r\n        require(commissionDays >= 15, \"Invest time must >= 15days\");\r\n        uint256 lossRatio = 15;\r\n        if (commissionDays >= 60) {\r\n            lossRatio = 5;\r\n        } else if (commissionDays >= 30) {\r\n            lossRatio = 10;\r\n        }\r\n        amount = user.currentInvestAmount;\r\n        amount = amount.sub(user.currentInvestAmount.mul(lossRatio).div(100));\r\n    }\r\n\r\n    function getStaticCommissionRatio(uint256 level, uint256 investCycle) private pure returns (uint256 ratio) {\r\n        if (level == 1) {\r\n            if (investCycle == 30) {\r\n                ratio = 7;\r\n            } else if(investCycle == 60) {\r\n                ratio = 8;\r\n            } else {\r\n                ratio = 9;\r\n            }\r\n        } else if (level == 2) {\r\n            if (investCycle == 30) {\r\n                ratio = 8;\r\n            } else if(investCycle == 60) {\r\n                ratio = 9;\r\n            } else {\r\n                ratio = 10;\r\n            }\r\n        } else {\r\n            if (investCycle == 30) {\r\n                ratio = 9;\r\n            } else if(investCycle == 60) {\r\n                ratio = 10;\r\n            } else {\r\n                ratio = 11;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getDynamicCommissionRatio(User memory user, uint256 depth) private pure returns (uint256 ratio) {\r\n        if (user.currentlevel == 1) {\r\n            if (depth == 1) {\r\n                ratio = 50;\r\n            } else {\r\n                ratio = 0;\r\n            }\r\n        } else if (user.currentlevel == 2) {\r\n            if (depth == 1) {\r\n                ratio = 70;\r\n            } else if (depth == 2) {\r\n                ratio = 50;\r\n            } else {\r\n                ratio = 0;\r\n            }\r\n        } else {\r\n            if (depth == 1) {\r\n                ratio = 100;\r\n            } else if (depth == 2) {\r\n                ratio = 50;\r\n            } else if (depth == 3) {\r\n                ratio = 30;\r\n            } else if (depth >= 4 && depth <= 10) {\r\n                ratio = 10;\r\n            } else if (depth >= 11 && depth <= 20) {\r\n                ratio = 5;\r\n            } else {\r\n                ratio = 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getAvaliableStaticCommissionAmount(User memory user) private view returns (uint256 amount) {\r\n        if (user.currentInvestAmount == 0) {\r\n            amount = 0;\r\n        } else {\r\n            uint256 commissionDays = now.sub(user.currentInvestTime).div(ONE_DAY);\r\n            if (commissionDays > user.currentInvestCycle) {\r\n                commissionDays = user.currentInvestCycle;\r\n            }\r\n            amount = user.currentInvestAmount.mul(user.currentStaticCommissionRatio).mul(commissionDays);\r\n            amount = amount.div(1000);\r\n            amount = amount.sub(user.currentStaticCommissionWithdrawAmount);\r\n        }\r\n    }\r\n\r\n    function addInvestRecord(address userAddress, uint256 time, uint256 amount, uint256 cycle) private {\r\n        InvestRecord[9] storage records = investRecordMapping[userAddress];\r\n        for (uint256 i = 8; i > 0; --i) {\r\n            InvestRecord memory prevRecord = records[i - 1];\r\n            records[i] = prevRecord;\r\n        }\r\n        records[0] = InvestRecord(time, amount, cycle);\r\n    }\r\n\r\n    function addStaticCommissionRecord(address userAddress, uint256 time, uint256 amount) private {\r\n        CommissionRecord[9] storage records = staticCommissionRecordMapping[userAddress];\r\n        for (uint256 i = 8; i > 0; --i) {\r\n            CommissionRecord memory prevRecord = records[i - 1];\r\n            records[i] = prevRecord;\r\n        }\r\n        records[0] = CommissionRecord(time, amount);\r\n    }\r\n\r\n    function addDynamicCommissionRecord(address userAddress, uint256 time, uint256 amount) private {\r\n        CommissionRecord[9] storage records = dynamicCommissionRecordMapping[userAddress];\r\n        for (uint256 i = 8; i > 0; --i) {\r\n            CommissionRecord memory prevRecord = records[i - 1];\r\n            records[i] = prevRecord;\r\n        }\r\n        records[0] = CommissionRecord(time, amount);\r\n    }\r\n\r\n    function invest(address sponsorAddress, uint256 investCycle) external payable {\r\n        User storage sponsor = userMapping[sponsorAddress];\r\n        require(sponsor.totalInvestCount > 0, \"Invalid sponsor address\");\r\n        require(investCycle == 30 || investCycle == 60 || investCycle == 90, \"Invalid invest cycle\");\r\n        uint256 investAmount = msg.value.div(ONE_ETH);\r\n        investAmount = investAmount.mul(ONE_ETH);\r\n        require(investAmount == msg.value, \"Invest amount is not integer\");\r\n        require(investAmount >= ONE_ETH.mul(1) && investAmount <= ONE_ETH.mul(15), \"Invalid invest amount\");\r\n\r\n        User memory user = userMapping[msg.sender];\r\n        uint256 level = getLevelByInvestAmount(investAmount);\r\n        if (user.totalInvestCount > 0) {\r\n            require(user.sponsorAddress == sponsorAddress, \"sponsor address is inconsistent\");\r\n            require(user.currentInvestAmount == 0, \"Dumplicate invest\");\r\n            require(user.currentInvestTime == 0, \"Invalid state\");\r\n            require(user.currentInvestCycle == 0, \"Invalid state\");\r\n            require(user.currentlevel == 0, \"Invalid state\");\r\n            require(user.currentStaticCommissionRatio == 0, \"Invalid state\");\r\n            require(user.currentStaticCommissionWithdrawAmount == 0, \"Invalid state\");\r\n            user.totalInvestCount = user.totalInvestCount.add(1);\r\n            user.totalInvestAmount = user.totalInvestAmount.add(investAmount);\r\n            user.currentInvestTime = now;\r\n            user.currentInvestAmount = investAmount;\r\n            user.currentInvestCycle = investCycle;\r\n            user.currentlevel = level;\r\n            user.currentStaticCommissionRatio = getStaticCommissionRatio(level, investCycle);\r\n            userMapping[msg.sender] = user;\r\n            address addressWalker = sponsorAddress;\r\n            while (addressWalker != GENESIS_USER_ADDRESS) {\r\n                sponsor = userMapping[addressWalker];\r\n                sponsor.totalDownlineInvestAmount = sponsor.totalDownlineInvestAmount.add(investAmount);\r\n                addressWalker = sponsor.sponsorAddress;\r\n            }\r\n        } else {\r\n            userMapping[msg.sender] = User(1, investAmount, 0, 0, 0, 1, 0, investAmount,\r\n                                           now, investAmount, investCycle, level,\r\n                                           getStaticCommissionRatio(level, investCycle),\r\n                                           0, 0, 0, 0, sponsorAddress);\r\n            addressMapping[totalUserCount] = msg.sender;\r\n            totalUserCount = totalUserCount.add(1);\r\n            address addressWalker = sponsorAddress;\r\n            while (addressWalker != GENESIS_USER_ADDRESS) {\r\n                sponsor = userMapping[addressWalker];\r\n                sponsor.downlineCount = sponsor.downlineCount.add(1);\r\n                if (addressWalker == sponsorAddress) {\r\n                    sponsor.nodeCount = sponsor.nodeCount.add(1);\r\n                }\r\n                sponsor.totalDownlineInvestAmount = sponsor.totalDownlineInvestAmount.add(investAmount);\r\n                addressWalker = sponsor.sponsorAddress;\r\n            }\r\n        }\r\n\r\n        addInvestRecord(msg.sender, now, investAmount, investCycle);\r\n        totalInvestCount = totalInvestCount.add(1);\r\n        totalInvestAmount = totalInvestAmount.add(investAmount);\r\n        engineerFunds = engineerFunds.add(investAmount.div(50));\r\n        operatorFunds = operatorFunds.add(investAmount.mul(3).div(100));\r\n        NOAH_ADDRESS.transfer(investAmount.mul(5).div(100));\r\n    }\r\n\r\n    function userWithdraw() external {\r\n        User storage user = userMapping[msg.sender];\r\n        if (user.currentInvestAmount > 0) {\r\n            uint256 avaliableIA = user.currentInvestAmount;\r\n            if (!isInvestExpired(user)) {\r\n                avaliableIA = getAbortInvestAmount(user);\r\n            }\r\n            uint256 avaliableSCA = getAvaliableStaticCommissionAmount(user);\r\n            user.staticCommissionBalance = user.staticCommissionBalance.add(avaliableSCA);\r\n            user.currentInvestTime = 0;\r\n            user.currentInvestAmount = 0;\r\n            user.currentInvestCycle = 0;\r\n            user.currentlevel = 0;\r\n            user.currentStaticCommissionRatio = 0;\r\n            user.currentStaticCommissionWithdrawAmount = 0;\r\n            user.totalWithdrawAmount = user.totalWithdrawAmount.add(avaliableIA);\r\n            totalWithdrawAmount = totalWithdrawAmount.add(avaliableIA);\r\n            msg.sender.transfer(avaliableIA);\r\n        }\r\n    }\r\n\r\n    function userWithdrawCommission() external {\r\n        User storage user = userMapping[msg.sender];\r\n        uint256 avaliableDCB = user.dynamicCommissionBalance;\r\n        uint256 avaliableSCA = getAvaliableStaticCommissionAmount(user);\r\n        uint256 avaliableSCB = user.staticCommissionBalance.add(avaliableSCA);\r\n        uint256 avaliableWithdrawAmount = avaliableDCB.add(avaliableSCB);\r\n        if (avaliableWithdrawAmount >= ONE_ETH.div(10)) {\r\n            user.staticCommissionBalance = 0;\r\n            user.dynamicCommissionBalance = 0;\r\n            user.currentStaticCommissionWithdrawAmount = user.currentStaticCommissionWithdrawAmount.add(avaliableSCA);\r\n            user.totalStaticCommissionWithdrawAmount = user.totalStaticCommissionWithdrawAmount.add(avaliableSCB);\r\n            user.totalDynamicCommissionWithdrawAmount = user.totalDynamicCommissionWithdrawAmount.add(avaliableDCB);\r\n            user.totalWithdrawAmount = user.totalWithdrawAmount.add(avaliableWithdrawAmount);\r\n            totalStaticCommissionWithdrawAmount = totalStaticCommissionWithdrawAmount.add(avaliableSCB);\r\n            totalDynamicCommissionWithdrawAmount = totalDynamicCommissionWithdrawAmount.add(avaliableDCB);\r\n            totalWithdrawAmount = totalWithdrawAmount.add(avaliableWithdrawAmount);\r\n            if (avaliableSCB > 0) {\r\n                addStaticCommissionRecord(msg.sender, now, avaliableSCB);\r\n            }\r\n            msg.sender.transfer(avaliableWithdrawAmount);\r\n        }\r\n    }\r\n\r\n    function engineerWithdraw() external onlyEngineer {\r\n        uint256 avaliableAmount = engineerFunds;\r\n        if (avaliableAmount > 0) {\r\n            engineerFunds = 0;\r\n            engineerWithdrawAmount = engineerWithdrawAmount.add(avaliableAmount);\r\n            msg.sender.transfer(avaliableAmount);\r\n        }\r\n    }\r\n\r\n    function operatorWithdraw() external onlyOwner {\r\n        uint256 avaliableAmount = operatorFunds;\r\n        if (avaliableAmount > 0) {\r\n            operatorFunds = 0;\r\n            operatorWithdrawAmount = operatorWithdrawAmount.add(avaliableAmount);\r\n            msg.sender.transfer(avaliableAmount);\r\n        }\r\n    }\r\n\r\n    function getSummary() public view returns (uint256[11] memory) {\r\n        return ([address(this).balance, totalInvestCount, totalInvestAmount,\r\n                 totalStaticCommissionWithdrawAmount,\r\n                 totalDynamicCommissionWithdrawAmount,\r\n                 totalWithdrawAmount,\r\n                 totalUserCount,\r\n                 engineerFunds, engineerWithdrawAmount,\r\n                 operatorFunds, operatorWithdrawAmount]);\r\n    }\r\n\r\n    function getUserByAddress(address userAddress) public view returns(uint256[16] memory,\r\n                                                                       address) {\r\n        User memory user = userMapping[userAddress];\r\n        return ([user.totalInvestCount, user.totalInvestAmount,\r\n                 user.totalStaticCommissionWithdrawAmount,\r\n                 user.totalDynamicCommissionWithdrawAmount,\r\n                 user.totalWithdrawAmount,\r\n                 user.downlineCount, user.nodeCount,\r\n                 user.totalDownlineInvestAmount,\r\n                 user.currentInvestTime, user.currentInvestAmount,\r\n                 user.currentInvestCycle, user.currentlevel,\r\n                 user.currentStaticCommissionRatio,\r\n                 user.staticCommissionBalance.add(getAvaliableStaticCommissionAmount(user)),\r\n                 user.dynamicCommissionBalance,\r\n                 user.calcDynamicCommissionAmount],\r\n                user.sponsorAddress);\r\n    }\r\n\r\n    function getUserByAddress2(address userAddress) public view returns(uint256[15] memory,\r\n                                                                        address) {\r\n        User memory user = userMapping[userAddress];\r\n        return ([user.totalInvestCount, user.totalInvestAmount,\r\n                 user.totalStaticCommissionWithdrawAmount,\r\n                 user.totalDynamicCommissionWithdrawAmount,\r\n                 user.totalWithdrawAmount,\r\n                 user.downlineCount, user.nodeCount,\r\n                 user.totalDownlineInvestAmount,\r\n                 user.currentInvestTime, user.currentInvestAmount,\r\n                 user.currentInvestCycle, user.currentlevel,\r\n                 user.currentStaticCommissionRatio,\r\n                 user.dynamicCommissionBalance,\r\n                 user.calcDynamicCommissionAmount],\r\n                user.sponsorAddress);\r\n    }\r\n\r\n    function getUserByIndex(uint256 index) external view onlyOwner returns(uint256[16] memory,\r\n                                                                           address) {\r\n        return getUserByAddress(addressMapping[index]);\r\n    }\r\n\r\n    function getUserAddress(uint256 index) external view onlyOwner returns(address) {\r\n        return addressMapping[index];\r\n    }\r\n\r\n    function patchStaticCommissionRatio() external onlyOwner {\r\n        for (uint256 i = 0; i < totalUserCount; ++i) {\r\n            User storage user = userMapping[addressMapping[i]];\r\n            if (user.currentInvestAmount == 0) {\r\n                user.currentStaticCommissionRatio = 0;\r\n            } else {\r\n                user.currentStaticCommissionRatio = getStaticCommissionRatio(user.currentlevel, user.currentInvestCycle);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getInvestRecords(address userAddress) external view returns(uint256[3] memory,\r\n                                                                         uint256[3] memory,\r\n                                                                         uint256[3] memory,\r\n                                                                         uint256[3] memory,\r\n                                                                         uint256[3] memory,\r\n                                                                         uint256[3] memory,\r\n                                                                         uint256[3] memory,\r\n                                                                         uint256[3] memory,\r\n                                                                         uint256[3] memory) {\r\n        InvestRecord[9] memory records = investRecordMapping[userAddress];\r\n        return ([records[0].time, records[0].amount, records[0].cycle],\r\n                [records[1].time, records[1].amount, records[1].cycle],\r\n                [records[2].time, records[2].amount, records[2].cycle],\r\n                [records[3].time, records[3].amount, records[3].cycle],\r\n                [records[4].time, records[4].amount, records[4].cycle],\r\n                [records[5].time, records[5].amount, records[5].cycle],\r\n                [records[6].time, records[6].amount, records[6].cycle],\r\n                [records[7].time, records[7].amount, records[7].cycle],\r\n                [records[8].time, records[8].amount, records[8].cycle]);\r\n    }\r\n\r\n    function getStaticCommissionRecords(address userAddress) external view returns(uint256[2] memory,\r\n                                                                                   uint256[2] memory,\r\n                                                                                   uint256[2] memory,\r\n                                                                                   uint256[2] memory,\r\n                                                                                   uint256[2] memory,\r\n                                                                                   uint256[2] memory,\r\n                                                                                   uint256[2] memory,\r\n                                                                                   uint256[2] memory,\r\n                                                                                   uint256[2] memory) {\r\n        CommissionRecord[9] memory records = staticCommissionRecordMapping[userAddress];\r\n        return ([records[0].time, records[0].amount],\r\n                [records[1].time, records[1].amount],\r\n                [records[2].time, records[2].amount],\r\n                [records[3].time, records[3].amount],\r\n                [records[4].time, records[4].amount],\r\n                [records[5].time, records[5].amount],\r\n                [records[6].time, records[6].amount],\r\n                [records[7].time, records[7].amount],\r\n                [records[8].time, records[8].amount]);\r\n    }\r\n\r\n    function getDynamicCommissionRecords(address userAddress) external view returns(uint256[2] memory,\r\n                                                                                    uint256[2] memory,\r\n                                                                                    uint256[2] memory,\r\n                                                                                    uint256[2] memory,\r\n                                                                                    uint256[2] memory,\r\n                                                                                    uint256[2] memory,\r\n                                                                                    uint256[2] memory,\r\n                                                                                    uint256[2] memory,\r\n                                                                                    uint256[2] memory) {\r\n        CommissionRecord[9] memory records = dynamicCommissionRecordMapping[userAddress];\r\n        return ([records[0].time, records[0].amount],\r\n                [records[1].time, records[1].amount],\r\n                [records[2].time, records[2].amount],\r\n                [records[3].time, records[3].amount],\r\n                [records[4].time, records[4].amount],\r\n                [records[5].time, records[5].amount],\r\n                [records[6].time, records[6].amount],\r\n                [records[7].time, records[7].amount],\r\n                [records[8].time, records[8].amount]);\r\n    }\r\n\r\n    function calcDynamicCommission() external onlyOwner {\r\n        for (uint256 i = 0; i < totalUserCount; ++i) {\r\n            User storage user = userMapping[addressMapping[i]];\r\n            user.calcDynamicCommissionAmount = 0;\r\n        }\r\n\r\n        for (uint256 i = 0; i < totalUserCount; ++i) {\r\n            User memory user = userMapping[addressMapping[i]];\r\n            if (user.currentInvestAmount > 0) {\r\n                uint256 commissionDays = now.sub(user.currentInvestTime).div(ONE_DAY);\r\n                if (commissionDays >= 1 && commissionDays <= user.currentInvestCycle) {\r\n                    uint256 depth = 1;\r\n                    address addressWalker = user.sponsorAddress;\r\n                    while (addressWalker != GENESIS_USER_ADDRESS) {\r\n                        User storage sponsor = userMapping[addressWalker];\r\n                        if (sponsor.currentInvestAmount > 0) {\r\n                            uint256 dynamicCommissionRatio = getDynamicCommissionRatio(sponsor, depth);\r\n                            if (dynamicCommissionRatio > 0) {\r\n                                uint256 dynamicCA = sponsor.currentInvestAmount;\r\n                                if (dynamicCA > user.currentInvestAmount) {\r\n                                    dynamicCA = user.currentInvestAmount;\r\n                                }\r\n                                dynamicCA = dynamicCA.mul(user.currentStaticCommissionRatio);\r\n                                dynamicCA = dynamicCA.mul(dynamicCommissionRatio);\r\n                                if (sponsor.currentlevel == 1) {\r\n                                    dynamicCA = dynamicCA.mul(3).div(1000 * 100 * 10);\r\n                                } else if (sponsor.currentlevel == 2) {\r\n                                    dynamicCA = dynamicCA.mul(6).div(1000 * 100 * 10);\r\n                                } else {\r\n                                    dynamicCA = dynamicCA.div(1000 * 100);\r\n                                }\r\n                                sponsor.calcDynamicCommissionAmount = sponsor.calcDynamicCommissionAmount.add(dynamicCA);\r\n                            }\r\n                        }\r\n                        addressWalker = sponsor.sponsorAddress;\r\n                        depth = depth.add(1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (uint256 i = 0; i < totalUserCount; ++i) {\r\n            address userAddress = addressMapping[i];\r\n            User storage user = userMapping[userAddress];\r\n            if (user.calcDynamicCommissionAmount > 0) {\r\n                user.dynamicCommissionBalance = user.dynamicCommissionBalance.add(user.calcDynamicCommissionAmount);\r\n                addDynamicCommissionRecord(userAddress, now, user.calcDynamicCommissionAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function calcDynamicCommissionBegin(uint256 index, uint256 length) external onlyOwner {\r\n        for (uint256 i = index; i < (index + length); ++i) {\r\n            User storage user = userMapping[addressMapping[i]];\r\n            user.calcDynamicCommissionAmount = 0;\r\n        }\r\n    }\r\n\r\n    function calcDynamicCommissionRange(uint256 index, uint256 length) external onlyOwner {\r\n        for (uint256 i = index; i < (index + length); ++i) {\r\n            User memory user = userMapping[addressMapping[i]];\r\n            if (user.currentInvestAmount > 0) {\r\n                uint256 commissionDays = now.sub(user.currentInvestTime).div(ONE_DAY);\r\n                if (commissionDays >= 1 && commissionDays <= user.currentInvestCycle) {\r\n                    uint256 depth = 1;\r\n                    address addressWalker = user.sponsorAddress;\r\n                    while (addressWalker != GENESIS_USER_ADDRESS) {\r\n                        User storage sponsor = userMapping[addressWalker];\r\n                        if (sponsor.currentInvestAmount > 0) {\r\n                            uint256 dynamicCommissionRatio = getDynamicCommissionRatio(sponsor, depth);\r\n                            if (dynamicCommissionRatio > 0) {\r\n                                uint256 dynamicCA = sponsor.currentInvestAmount;\r\n                                if (dynamicCA > user.currentInvestAmount) {\r\n                                    dynamicCA = user.currentInvestAmount;\r\n                                }\r\n                                dynamicCA = dynamicCA.mul(user.currentStaticCommissionRatio);\r\n                                dynamicCA = dynamicCA.mul(dynamicCommissionRatio);\r\n                                if (sponsor.currentlevel == 1) {\r\n                                    dynamicCA = dynamicCA.mul(3).div(1000 * 100 * 10);\r\n                                } else if (sponsor.currentlevel == 2) {\r\n                                    dynamicCA = dynamicCA.mul(6).div(1000 * 100 * 10);\r\n                                } else {\r\n                                    dynamicCA = dynamicCA.div(1000 * 100);\r\n                                }\r\n                                sponsor.calcDynamicCommissionAmount = sponsor.calcDynamicCommissionAmount.add(dynamicCA);\r\n                            }\r\n                        }\r\n                        addressWalker = sponsor.sponsorAddress;\r\n                        depth = depth.add(1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function calcDynamicCommissionEnd(uint256 index, uint256 length) external onlyOwner {\r\n        for (uint256 i = index; i < (index + length); ++i) {\r\n            address userAddress = addressMapping[i];\r\n            User storage user = userMapping[userAddress];\r\n            if (user.calcDynamicCommissionAmount > 0) {\r\n                user.dynamicCommissionBalance = user.dynamicCommissionBalance.add(user.calcDynamicCommissionAmount);\r\n                addDynamicCommissionRecord(userAddress, now, user.calcDynamicCommissionAmount);\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"calcDynamicCommissionEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"calcDynamicCommissionBegin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"engineerWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvestCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"calcDynamicCommissionRange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operatorWithdrawAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSummary\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[11]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operatorFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUserCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStaticCommissionWithdrawAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"patchStaticCommissionRatio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWithdrawAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDynamicCommissionWithdrawAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvestAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[16]\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"calcDynamicCommission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getInvestRecords\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"},{\"name\":\"\",\"type\":\"uint256[3]\"},{\"name\":\"\",\"type\":\"uint256[3]\"},{\"name\":\"\",\"type\":\"uint256[3]\"},{\"name\":\"\",\"type\":\"uint256[3]\"},{\"name\":\"\",\"type\":\"uint256[3]\"},{\"name\":\"\",\"type\":\"uint256[3]\"},{\"name\":\"\",\"type\":\"uint256[3]\"},{\"name\":\"\",\"type\":\"uint256[3]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getUserAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"userWithdrawCommission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserByAddress2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[15]\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"engineerWithdrawAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"userWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sponsorAddress\",\"type\":\"address\"},{\"name\":\"investCycle\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"operatorWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getStaticCommissionRecords\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"engineerFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getDynamicCommissionRecords\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getUserByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[16]\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"FomoFeast5","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://cbf9311c7eb7335844ed035ae669295904acafcf031ab958b25f3d1d46fc0628"}]}