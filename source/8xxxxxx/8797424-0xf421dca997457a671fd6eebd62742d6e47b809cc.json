{"status":"1","message":"OK","result":[{"SourceCode":"// File: @laborx/solidity-shared-contracts/contracts/ERC20Interface.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/// @title Defines an interface for EIP20 token smart contract\r\ncontract ERC20Interface {\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n\r\n    string public symbol;\r\n\r\n    function decimals() public view returns (uint8);\r\n    function totalSupply() public view returns (uint256 supply);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n}\r\n\r\n// File: @laborx/solidity-shared-contracts/contracts/Owned.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n/// @title Owned contract with safe ownership pass.\r\n///\r\n/// Note: all the non constant functions return false instead of throwing in case if state change\r\n/// didn't happen yet.\r\ncontract Owned {\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    address public contractOwner;\r\n    address public pendingContractOwner;\r\n\r\n    modifier onlyContractOwner {\r\n        if (msg.sender == contractOwner) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    constructor()\r\n    public\r\n    {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    /// @notice Prepares ownership pass.\r\n    /// Can only be called by current owner.\r\n    /// @param _to address of the next owner.\r\n    /// @return success.\r\n    function changeContractOwnership(address _to)\r\n    public\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        if (_to == 0x0) {\r\n            return false;\r\n        }\r\n        pendingContractOwner = _to;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Finalize ownership pass.\r\n    /// Can only be called by pending owner.\r\n    /// @return success.\r\n    function claimContractOwnership()\r\n    public\r\n    returns (bool)\r\n    {\r\n        if (msg.sender != pendingContractOwner) {\r\n            return false;\r\n        }\r\n\r\n        emit OwnershipTransferred(contractOwner, pendingContractOwner);\r\n        contractOwner = pendingContractOwner;\r\n        delete pendingContractOwner;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address newOwner)\r\n    public\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        if (newOwner == 0x0) {\r\n            return false;\r\n        }\r\n\r\n        emit OwnershipTransferred(contractOwner, newOwner);\r\n        contractOwner = newOwner;\r\n        delete pendingContractOwner;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @dev Backward compatibility only.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferContractOwnership(address newOwner)\r\n    public\r\n    returns (bool)\r\n    {\r\n        return transferOwnership(newOwner);\r\n    }\r\n\r\n    /// @notice Withdraw given tokens from contract to owner.\r\n    /// This method is only allowed for contact owner.\r\n    function withdrawTokens(address[] tokens)\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        address _contractOwner = contractOwner;\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            ERC20Interface token = ERC20Interface(tokens[i]);\r\n            uint balance = token.balanceOf(this);\r\n            if (balance > 0) {\r\n                token.transfer(_contractOwner, balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraw ether from contract to owner.\r\n    /// This method is only allowed for contact owner.\r\n    function withdrawEther()\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        uint balance = address(this).balance;\r\n        if (balance > 0)  {\r\n            contractOwner.transfer(balance);\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers ether to another address.\r\n    /// Allowed only for contract owners.\r\n    /// @param _to recepient address\r\n    /// @param _value wei to transfer; must be less or equal to total balance on the contract\r\n    function transferEther(address _to, uint256 _value)\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        require(_to != 0x0, \"INVALID_ETHER_RECEPIENT_ADDRESS\");\r\n        if (_value > address(this).balance) {\r\n            revert(\"INVALID_VALUE_TO_TRANSFER_ETHER\");\r\n        }\r\n\r\n        _to.transfer(_value);\r\n    }\r\n}\r\n\r\n// File: @laborx/solidity-storage-contracts/contracts/Storage.sol\r\n\r\n/**\r\n * Copyright 2017–2018, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\ncontract Manager {\r\n    function isAllowed(address _actor, bytes32 _role) public view returns (bool);\r\n    function hasAccess(address _actor) public view returns (bool);\r\n}\r\n\r\n\r\ncontract Storage is Owned {\r\n    struct Crate {\r\n        mapping(bytes32 => uint) uints;\r\n        mapping(bytes32 => address) addresses;\r\n        mapping(bytes32 => bool) bools;\r\n        mapping(bytes32 => int) ints;\r\n        mapping(bytes32 => uint8) uint8s;\r\n        mapping(bytes32 => bytes32) bytes32s;\r\n        mapping(bytes32 => AddressUInt8) addressUInt8s;\r\n        mapping(bytes32 => string) strings;\r\n        mapping(bytes32 => bytes) bytesSequences;\r\n    }\r\n\r\n    struct AddressUInt8 {\r\n        address _address;\r\n        uint8 _uint8;\r\n    }\r\n\r\n    mapping(bytes32 => Crate) internal crates;\r\n    Manager public manager;\r\n\r\n    modifier onlyAllowed(bytes32 _role) {\r\n        if (!(msg.sender == address(this) || manager.isAllowed(msg.sender, _role))) {\r\n            revert(\"STORAGE_FAILED_TO_ACCESS_PROTECTED_FUNCTION\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    function setManager(Manager _manager)\r\n    external\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        manager = _manager;\r\n        return true;\r\n    }\r\n\r\n    function setUInt(bytes32 _crate, bytes32 _key, uint _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setUInt(_crate, _key, _value);\r\n    }\r\n\r\n    function _setUInt(bytes32 _crate, bytes32 _key, uint _value)\r\n    internal\r\n    {\r\n        crates[_crate].uints[_key] = _value;\r\n    }\r\n\r\n\r\n    function getUInt(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (uint)\r\n    {\r\n        return crates[_crate].uints[_key];\r\n    }\r\n\r\n    function setAddress(bytes32 _crate, bytes32 _key, address _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setAddress(_crate, _key, _value);\r\n    }\r\n\r\n    function _setAddress(bytes32 _crate, bytes32 _key, address _value)\r\n    internal\r\n    {\r\n        crates[_crate].addresses[_key] = _value;\r\n    }\r\n\r\n    function getAddress(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        return crates[_crate].addresses[_key];\r\n    }\r\n\r\n    function setBool(bytes32 _crate, bytes32 _key, bool _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setBool(_crate, _key, _value);\r\n    }\r\n\r\n    function _setBool(bytes32 _crate, bytes32 _key, bool _value)\r\n    internal\r\n    {\r\n        crates[_crate].bools[_key] = _value;\r\n    }\r\n\r\n    function getBool(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return crates[_crate].bools[_key];\r\n    }\r\n\r\n    function setInt(bytes32 _crate, bytes32 _key, int _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setInt(_crate, _key, _value);\r\n    }\r\n\r\n    function _setInt(bytes32 _crate, bytes32 _key, int _value)\r\n    internal\r\n    {\r\n        crates[_crate].ints[_key] = _value;\r\n    }\r\n\r\n    function getInt(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (int)\r\n    {\r\n        return crates[_crate].ints[_key];\r\n    }\r\n\r\n    function setUInt8(bytes32 _crate, bytes32 _key, uint8 _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setUInt8(_crate, _key, _value);\r\n    }\r\n\r\n    function _setUInt8(bytes32 _crate, bytes32 _key, uint8 _value)\r\n    internal\r\n    {\r\n        crates[_crate].uint8s[_key] = _value;\r\n    }\r\n\r\n    function getUInt8(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (uint8)\r\n    {\r\n        return crates[_crate].uint8s[_key];\r\n    }\r\n\r\n    function setBytes32(bytes32 _crate, bytes32 _key, bytes32 _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setBytes32(_crate, _key, _value);\r\n    }\r\n\r\n    function _setBytes32(bytes32 _crate, bytes32 _key, bytes32 _value)\r\n    internal\r\n    {\r\n        crates[_crate].bytes32s[_key] = _value;\r\n    }\r\n\r\n    function getBytes32(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (bytes32)\r\n    {\r\n        return crates[_crate].bytes32s[_key];\r\n    }\r\n\r\n    function setAddressUInt8(\r\n        bytes32 _crate,\r\n        bytes32 _key,\r\n        address _value,\r\n        uint8 _value2\r\n    )\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setAddressUInt8(_crate, _key, _value, _value2);\r\n    }\r\n\r\n    function _setAddressUInt8(\r\n        bytes32 _crate,\r\n        bytes32 _key,\r\n        address _value,\r\n        uint8 _value2\r\n    )\r\n    internal\r\n    {\r\n        crates[_crate].addressUInt8s[_key] = AddressUInt8(_value, _value2);\r\n    }\r\n\r\n    function getAddressUInt8(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (address, uint8)\r\n    {\r\n        return (crates[_crate].addressUInt8s[_key]._address, crates[_crate].addressUInt8s[_key]._uint8);\r\n    }\r\n\r\n    function setString(bytes32 _crate, bytes32 _key, string _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setString(_crate, _key, _value);\r\n    }\r\n\r\n    function _setString(bytes32 _crate, bytes32 _key, string _value)\r\n    internal\r\n    {\r\n        crates[_crate].strings[_key] = _value;\r\n    }\r\n\r\n    function getString(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (string)\r\n    {\r\n        return crates[_crate].strings[_key];\r\n    }\r\n\r\n    function setBytesSequence(bytes32 _crate, bytes32 _key, bytes _value)\r\n    public\r\n    onlyAllowed(_crate)\r\n    {\r\n        _setBytesSequence(_crate, _key, _value);\r\n    }\r\n\r\n    function _setBytesSequence(bytes32 _crate, bytes32 _key, bytes _value)\r\n    internal\r\n    {\r\n        crates[_crate].bytesSequences[_key] = _value;\r\n    }\r\n\r\n    function getBytesSequence(bytes32 _crate, bytes32 _key)\r\n    public\r\n    view\r\n    returns (bytes)\r\n    {\r\n        return crates[_crate].bytesSequences[_key];\r\n    }\r\n}\r\n\r\n// File: @laborx/solidity-storage-contracts/contracts/StorageInterface.sol\r\n\r\n/**\r\n * Copyright 2017–2018, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\nlibrary StorageInterface {\r\n    struct Config {\r\n        Storage store;\r\n        bytes32 crate;\r\n    }\r\n\r\n    struct UInt {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct UInt8 {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Int {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Address {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Bool {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Bytes32 {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct String {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct BytesSequence {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct Mapping {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct StringMapping {\r\n        String id;\r\n    }\r\n\r\n    struct BytesSequenceMapping {\r\n        BytesSequence id;\r\n    }\r\n\r\n    struct UIntBoolMapping {\r\n        Bool innerMapping;\r\n    }\r\n\r\n    struct UIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntBytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntEnumMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBoolMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUInt8Mapping {\r\n        bytes32 id;\r\n    }\r\n\r\n    struct AddressUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressAddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UInt8Mapping {\r\n        UInt8 innerMapping;\r\n    }\r\n\r\n    struct Bytes32BoolMapping {\r\n        Bool innerMapping;\r\n    }\r\n\r\n    struct Bytes32Bytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32AddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UIntBoolMapping {\r\n        Bool innerMapping;\r\n    }\r\n\r\n    struct AddressAddressUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressAddressUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBytes32Bytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBytes4BoolMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressBytes4Bytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressAddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressBoolMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntUIntAddressMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntUIntBytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntUIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntStructAddressUInt8Mapping {\r\n        AddressUInt8Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntStructAddressUInt8Mapping {\r\n        AddressUInt8Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntUIntStructAddressUInt8Mapping {\r\n        AddressUInt8Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntUIntUIntStructAddressUInt8Mapping {\r\n        AddressUInt8Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntAddressUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntAddressUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct AddressUIntUIntUIntAddressUInt8Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct UIntAddressAddressBoolMapping {\r\n        Bool innerMapping;\r\n    }\r\n\r\n    struct UIntUIntUIntBytes32Mapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32UIntUIntUIntMapping {\r\n        Mapping innerMapping;\r\n    }\r\n\r\n    bytes32 constant SET_IDENTIFIER = \"set\";\r\n\r\n    struct Set {\r\n        UInt count;\r\n        Mapping indexes;\r\n        Mapping values;\r\n    }\r\n\r\n    struct AddressesSet {\r\n        Set innerSet;\r\n    }\r\n\r\n    struct CounterSet {\r\n        Set innerSet;\r\n    }\r\n\r\n    bytes32 constant ORDERED_SET_IDENTIFIER = \"ordered_set\";\r\n\r\n    struct OrderedSet {\r\n        UInt count;\r\n        Bytes32 first;\r\n        Bytes32 last;\r\n        Mapping nextValues;\r\n        Mapping previousValues;\r\n    }\r\n\r\n    struct OrderedUIntSet {\r\n        OrderedSet innerSet;\r\n    }\r\n\r\n    struct OrderedAddressesSet {\r\n        OrderedSet innerSet;\r\n    }\r\n\r\n    struct Bytes32SetMapping {\r\n        Set innerMapping;\r\n    }\r\n\r\n    struct AddressesSetMapping {\r\n        Bytes32SetMapping innerMapping;\r\n    }\r\n\r\n    struct UIntSetMapping {\r\n        Bytes32SetMapping innerMapping;\r\n    }\r\n\r\n    struct Bytes32OrderedSetMapping {\r\n        OrderedSet innerMapping;\r\n    }\r\n\r\n    struct UIntOrderedSetMapping {\r\n        Bytes32OrderedSetMapping innerMapping;\r\n    }\r\n\r\n    struct AddressOrderedSetMapping {\r\n        Bytes32OrderedSetMapping innerMapping;\r\n    }\r\n\r\n    // Can't use modifier due to a Solidity bug.\r\n    function sanityCheck(bytes32 _currentId, bytes32 _newId) internal pure {\r\n        if (_currentId != 0 || _newId == 0) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function init(Config storage self, Storage _store, bytes32 _crate) internal {\r\n        self.store = _store;\r\n        self.crate = _crate;\r\n    }\r\n\r\n    function init(UInt8 storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(UInt storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Int storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Address storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Bool storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Bytes32 storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(String storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(BytesSequence storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(Mapping storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(StringMapping storage self, bytes32 _id) internal {\r\n        init(self.id, _id);\r\n    }\r\n\r\n    function init(BytesSequenceMapping storage self, bytes32 _id) internal {\r\n        init(self.id, _id);\r\n    }\r\n\r\n    function init(UIntAddressMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntEnumMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntBoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntBytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressAddressUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBytes32Bytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntAddressUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntAddressBoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntAddressMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntAddressAddressMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntBytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntAddressAddressBoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntUIntUIntBytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UIntUIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        sanityCheck(self.id, _id);\r\n        self.id = _id;\r\n    }\r\n\r\n    function init(AddressUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressAddressMapping  storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBytes4BoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressBytes4Bytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntUIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntStructAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntStructAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntUIntStructAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntUIntUIntStructAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressUIntUIntUIntAddressUInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UIntMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UInt8Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32BoolMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32Bytes32Mapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32AddressMapping  storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32UIntBoolMapping  storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Set storage self, bytes32 _id) internal {\r\n        init(self.count, keccak256(abi.encodePacked(_id, \"count\")));\r\n        init(self.indexes, keccak256(abi.encodePacked(_id, \"indexes\")));\r\n        init(self.values, keccak256(abi.encodePacked(_id, \"values\")));\r\n    }\r\n\r\n    function init(AddressesSet storage self, bytes32 _id) internal {\r\n        init(self.innerSet, _id);\r\n    }\r\n\r\n    function init(CounterSet storage self, bytes32 _id) internal {\r\n        init(self.innerSet, _id);\r\n    }\r\n\r\n    function init(OrderedSet storage self, bytes32 _id) internal {\r\n        init(self.count, keccak256(abi.encodePacked(_id, \"uint/count\")));\r\n        init(self.first, keccak256(abi.encodePacked(_id, \"uint/first\")));\r\n        init(self.last, keccak256(abi.encodePacked(_id, \"uint/last\")));\r\n        init(self.nextValues, keccak256(abi.encodePacked(_id, \"uint/next\")));\r\n        init(self.previousValues, keccak256(abi.encodePacked(_id, \"uint/prev\")));\r\n    }\r\n\r\n    function init(OrderedUIntSet storage self, bytes32 _id) internal {\r\n        init(self.innerSet, _id);\r\n    }\r\n\r\n    function init(OrderedAddressesSet storage self, bytes32 _id) internal {\r\n        init(self.innerSet, _id);\r\n    }\r\n\r\n    function init(Bytes32SetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressesSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(Bytes32OrderedSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(UIntOrderedSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    function init(AddressOrderedSetMapping storage self, bytes32 _id) internal {\r\n        init(self.innerMapping, _id);\r\n    }\r\n\r\n    /** `set` operation */\r\n\r\n    function set(Config storage self, UInt storage item, uint _value) internal {\r\n        self.store.setUInt(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, UInt storage item, bytes32 _salt, uint _value) internal {\r\n        self.store.setUInt(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, UInt8 storage item, uint8 _value) internal {\r\n        self.store.setUInt8(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, UInt8 storage item, bytes32 _salt, uint8 _value) internal {\r\n        self.store.setUInt8(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Int storage item, int _value) internal {\r\n        self.store.setInt(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, Int storage item, bytes32 _salt, int _value) internal {\r\n        self.store.setInt(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Address storage item, address _value) internal {\r\n        self.store.setAddress(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, Address storage item, bytes32 _salt, address _value) internal {\r\n        self.store.setAddress(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bool storage item, bool _value) internal {\r\n        self.store.setBool(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bool storage item, bytes32 _salt, bool _value) internal {\r\n        self.store.setBool(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32 storage item, bytes32 _value) internal {\r\n        self.store.setBytes32(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32 storage item, bytes32 _salt, bytes32 _value) internal {\r\n        self.store.setBytes32(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, String storage item, string _value) internal {\r\n        self.store.setString(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, String storage item, bytes32 _salt, string _value) internal {\r\n        self.store.setString(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, BytesSequence storage item,  bytes _value) internal {\r\n        self.store.setBytesSequence(self.crate, item.id, _value);\r\n    }\r\n\r\n    function set(Config storage self, BytesSequence storage item, bytes32 _salt, bytes _value) internal {\r\n        self.store.setBytesSequence(self.crate, keccak256(abi.encodePacked(item.id, _salt)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Mapping storage item, uint _key, uint _value) internal {\r\n        self.store.setUInt(self.crate, keccak256(abi.encodePacked(item.id, _key)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Mapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        self.store.setBytes32(self.crate, keccak256(abi.encodePacked(item.id, _key)), _value);\r\n    }\r\n\r\n    function set(Config storage self, StringMapping storage item, bytes32 _key, string _value) internal {\r\n        set(self, item.id, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, BytesSequenceMapping storage item, bytes32 _key, bytes _value) internal {\r\n        set(self, item.id, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, AddressUInt8Mapping storage item, bytes32 _key, address _value1, uint8 _value2) internal {\r\n        self.store.setAddressUInt8(self.crate, keccak256(abi.encodePacked(item.id, _key)), _value1, _value2);\r\n    }\r\n\r\n    function set(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2, bytes32 _value) internal {\r\n        set(self, item, keccak256(abi.encodePacked(_key, _key2)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2, bytes32 _key3, bytes32 _value) internal {\r\n        set(self, item, keccak256(abi.encodePacked(_key, _key2, _key3)), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bool storage item, bytes32 _key, bytes32 _key2, bytes32 _key3, bool _value) internal {\r\n        set(self, item, keccak256(abi.encodePacked(_key, _key2, _key3)), _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressMapping storage item, uint _key, address _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntMapping storage item, uint _key, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntBoolMapping storage item, uint _key, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntEnumMapping storage item, uint _key, uint8 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntBytes32Mapping storage item, uint _key, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UIntMapping storage item, bytes32 _key, uint _value) internal {\r\n        set(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UInt8Mapping storage item, bytes32 _key, uint8 _value) internal {\r\n        set(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32BoolMapping storage item, bytes32 _key, bool _value) internal {\r\n        set(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32Bytes32Mapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        set(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32AddressMapping storage item, bytes32 _key, address _value) internal {\r\n        set(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UIntBoolMapping storage item, bytes32 _key, uint _key2, bool _value) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2)), _value);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntMapping storage item, address _key, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBoolMapping storage item, address _key, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), toBytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBytes32Mapping storage item, address _key, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), _value);\r\n    }\r\n\r\n    function set(Config storage self, AddressAddressMapping storage item, address _key, address _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressAddressUIntMapping storage item, address _key, address _key2, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntMapping storage item, address _key, uint _key2, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressAddressUInt8Mapping storage item, address _key, address _key2, uint8 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUInt8Mapping storage item, address _key, uint _key2, uint8 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBytes32Bytes32Mapping storage item, address _key, bytes32 _key2, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), _key2, _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressUIntMapping storage item, uint _key, address _key2, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressBoolMapping storage item, uint _key, address _key2, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), toBytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressAddressMapping storage item, uint _key, address _key2, address _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntAddressMapping storage item, uint _key, uint _key2, address _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntBytes32Mapping storage item, uint _key, uint _key2, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntUIntMapping storage item, uint _key, uint _key2, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, UIntAddressAddressBoolMapping storage item, uint _key, address _key2, address _key3, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3), _value);\r\n    }\r\n\r\n    function set(Config storage self, UIntUIntUIntBytes32Mapping storage item, uint _key, uint _key2,  uint _key3, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3), _value);\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UIntUIntMapping storage item, bytes32 _key, uint _key2, uint _value) internal {\r\n        set(self, item.innerMapping, _key, bytes32(_key2), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, Bytes32UIntUIntUIntMapping storage item, bytes32 _key, uint _key2,  uint _key3, uint _value) internal {\r\n        set(self, item.innerMapping, _key, bytes32(_key2), bytes32(_key3), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntUIntMapping storage item, address _key, uint _key2,  uint _key3, uint _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, address _value, uint8 _value2) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2)), _value, _value2);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, address _value, uint8 _value2) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3)), _value, _value2);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2,  uint _key3, uint _key4, address _value, uint8 _value2) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4)), _value, _value2);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2,  uint _key3, uint _key4, uint _key5, address _value, uint8 _value2) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4, _key5)), _value, _value2);\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntAddressUInt8Mapping storage item, address _key, uint _key2, address _key3, uint8 _value) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3)), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, address _key4, uint8 _value) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4)), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressUIntUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2,  uint _key3, uint _key4, address _key5, uint8 _value) internal {\r\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4, _key5)), bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBytes4BoolMapping storage item, address _key, bytes4 _key2, bool _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), toBytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, AddressBytes4Bytes32Mapping storage item, address _key, bytes4 _key2, bytes32 _value) internal {\r\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), _value);\r\n    }\r\n\r\n\r\n    /** `add` operation */\r\n\r\n    function add(Config storage self, Set storage item, bytes32 _value) internal {\r\n        add(self, item, SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function add(Config storage self, Set storage item, bytes32 _salt, bytes32 _value) private {\r\n        if (includes(self, item, _salt, _value)) {\r\n            return;\r\n        }\r\n        uint newCount = count(self, item, _salt) + 1;\r\n        set(self, item.values, _salt, bytes32(newCount), _value);\r\n        set(self, item.indexes, _salt, _value, bytes32(newCount));\r\n        set(self, item.count, _salt, newCount);\r\n    }\r\n\r\n    function add(Config storage self, AddressesSet storage item, address _value) internal {\r\n        add(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, CounterSet storage item) internal {\r\n        add(self, item.innerSet, bytes32(count(self, item) + 1));\r\n    }\r\n\r\n    function add(Config storage self, OrderedSet storage item, bytes32 _value) internal {\r\n        add(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function add(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private {\r\n        if (_value == 0x0) { revert(); }\r\n\r\n        if (includes(self, item, _salt, _value)) { return; }\r\n\r\n        if (count(self, item, _salt) == 0x0) {\r\n            set(self, item.first, _salt, _value);\r\n        }\r\n\r\n        if (get(self, item.last, _salt) != 0x0) {\r\n            _setOrderedSetLink(self, item.nextValues, _salt, get(self, item.last, _salt), _value);\r\n            _setOrderedSetLink(self, item.previousValues, _salt, _value, get(self, item.last, _salt));\r\n        }\r\n\r\n        _setOrderedSetLink(self, item.nextValues, _salt,  _value, 0x0);\r\n        set(self, item.last, _salt, _value);\r\n        set(self, item.count, _salt, get(self, item.count, _salt) + 1);\r\n    }\r\n\r\n    function add(Config storage self, Bytes32SetMapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        add(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function add(Config storage self, AddressesSetMapping storage item, bytes32 _key, address _value) internal {\r\n        add(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _value) internal {\r\n        add(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        add(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function add(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key, uint _value) internal {\r\n        add(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key, address _value) internal {\r\n        add(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, OrderedUIntSet storage item, uint _value) internal {\r\n        add(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function add(Config storage self, OrderedAddressesSet storage item, address _value) internal {\r\n        add(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function set(Config storage self, Set storage item, bytes32 _oldValue, bytes32 _newValue) internal {\r\n        set(self, item, SET_IDENTIFIER, _oldValue, _newValue);\r\n    }\r\n\r\n    function set(Config storage self, Set storage item, bytes32 _salt, bytes32 _oldValue, bytes32 _newValue) private {\r\n        if (!includes(self, item, _salt, _oldValue)) {\r\n            return;\r\n        }\r\n        uint index = uint(get(self, item.indexes, _salt, _oldValue));\r\n        set(self, item.values, _salt, bytes32(index), _newValue);\r\n        set(self, item.indexes, _salt, _newValue, bytes32(index));\r\n        set(self, item.indexes, _salt, _oldValue, bytes32(0));\r\n    }\r\n\r\n    function set(Config storage self, AddressesSet storage item, address _oldValue, address _newValue) internal {\r\n        set(self, item.innerSet, bytes32(_oldValue), bytes32(_newValue));\r\n    }\r\n\r\n    /** `remove` operation */\r\n\r\n    function remove(Config storage self, Set storage item, bytes32 _value) internal {\r\n        remove(self, item, SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function remove(Config storage self, Set storage item, bytes32 _salt, bytes32 _value) private {\r\n        if (!includes(self, item, _salt, _value)) {\r\n            return;\r\n        }\r\n        uint lastIndex = count(self, item, _salt);\r\n        bytes32 lastValue = get(self, item.values, _salt, bytes32(lastIndex));\r\n        uint index = uint(get(self, item.indexes, _salt, _value));\r\n        if (index < lastIndex) {\r\n            set(self, item.indexes, _salt, lastValue, bytes32(index));\r\n            set(self, item.values, _salt, bytes32(index), lastValue);\r\n        }\r\n        set(self, item.indexes, _salt, _value, bytes32(0));\r\n        set(self, item.values, _salt, bytes32(lastIndex), bytes32(0));\r\n        set(self, item.count, _salt, lastIndex - 1);\r\n    }\r\n\r\n    function remove(Config storage self, AddressesSet storage item, address _value) internal {\r\n        remove(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, CounterSet storage item, uint _value) internal {\r\n        remove(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, OrderedSet storage item, bytes32 _value) internal {\r\n        remove(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function remove(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private {\r\n        if (!includes(self, item, _salt, _value)) { return; }\r\n\r\n        _setOrderedSetLink(self, item.nextValues, _salt, get(self, item.previousValues, _salt, _value), get(self, item.nextValues, _salt, _value));\r\n        _setOrderedSetLink(self, item.previousValues, _salt, get(self, item.nextValues, _salt, _value), get(self, item.previousValues, _salt, _value));\r\n\r\n        if (_value == get(self, item.first, _salt)) {\r\n            set(self, item.first, _salt, get(self, item.nextValues, _salt, _value));\r\n        }\r\n\r\n        if (_value == get(self, item.last, _salt)) {\r\n            set(self, item.last, _salt, get(self, item.previousValues, _salt, _value));\r\n        }\r\n\r\n        _deleteOrderedSetLink(self, item.nextValues, _salt, _value);\r\n        _deleteOrderedSetLink(self, item.previousValues, _salt, _value);\r\n\r\n        set(self, item.count, _salt, get(self, item.count, _salt) - 1);\r\n    }\r\n\r\n    function remove(Config storage self, OrderedUIntSet storage item, uint _value) internal {\r\n        remove(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, OrderedAddressesSet storage item, address _value) internal {\r\n        remove(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, Bytes32SetMapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        remove(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function remove(Config storage self, AddressesSetMapping storage item, bytes32 _key, address _value) internal {\r\n        remove(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _value) internal {\r\n        remove(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key, bytes32 _value) internal {\r\n        remove(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function remove(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key, uint _value) internal {\r\n        remove(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function remove(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key, address _value) internal {\r\n        remove(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    /** 'copy` operation */\r\n\r\n    function copy(Config storage self, Set storage source, Set storage dest) internal {\r\n        uint _destCount = count(self, dest);\r\n        bytes32[] memory _toRemoveFromDest = new bytes32[](_destCount);\r\n        uint _idx;\r\n        uint _pointer = 0;\r\n        for (_idx = 0; _idx < _destCount; ++_idx) {\r\n            bytes32 _destValue = get(self, dest, _idx);\r\n            if (!includes(self, source, _destValue)) {\r\n                _toRemoveFromDest[_pointer++] = _destValue;\r\n            }\r\n        }\r\n\r\n        uint _sourceCount = count(self, source);\r\n        for (_idx = 0; _idx < _sourceCount; ++_idx) {\r\n            add(self, dest, get(self, source, _idx));\r\n        }\r\n\r\n        for (_idx = 0; _idx < _pointer; ++_idx) {\r\n            remove(self, dest, _toRemoveFromDest[_idx]);\r\n        }\r\n    }\r\n\r\n    function copy(Config storage self, AddressesSet storage source, AddressesSet storage dest) internal {\r\n        copy(self, source.innerSet, dest.innerSet);\r\n    }\r\n\r\n    function copy(Config storage self, CounterSet storage source, CounterSet storage dest) internal {\r\n        copy(self, source.innerSet, dest.innerSet);\r\n    }\r\n\r\n    /** `get` operation */\r\n\r\n    function get(Config storage self, UInt storage item) internal view returns (uint) {\r\n        return self.store.getUInt(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, UInt storage item, bytes32 salt) internal view returns (uint) {\r\n        return self.store.getUInt(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, UInt8 storage item) internal view returns (uint8) {\r\n        return self.store.getUInt8(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, UInt8 storage item, bytes32 salt) internal view returns (uint8) {\r\n        return self.store.getUInt8(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Int storage item) internal view returns (int) {\r\n        return self.store.getInt(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, Int storage item, bytes32 salt) internal view returns (int) {\r\n        return self.store.getInt(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Address storage item) internal view returns (address) {\r\n        return self.store.getAddress(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, Address storage item, bytes32 salt) internal view returns (address) {\r\n        return self.store.getAddress(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Bool storage item) internal view returns (bool) {\r\n        return self.store.getBool(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, Bool storage item, bytes32 salt) internal view returns (bool) {\r\n        return self.store.getBool(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32 storage item) internal view returns (bytes32) {\r\n        return self.store.getBytes32(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, Bytes32 storage item, bytes32 salt) internal view returns (bytes32) {\r\n        return self.store.getBytes32(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, String storage item) internal view returns (string) {\r\n        return self.store.getString(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, String storage item, bytes32 salt) internal view returns (string) {\r\n        return self.store.getString(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, BytesSequence storage item) internal view returns (bytes) {\r\n        return self.store.getBytesSequence(self.crate, item.id);\r\n    }\r\n\r\n    function get(Config storage self, BytesSequence storage item, bytes32 salt) internal view returns (bytes) {\r\n        return self.store.getBytesSequence(self.crate, keccak256(abi.encodePacked(item.id, salt)));\r\n    }\r\n\r\n    function get(Config storage self, Mapping storage item, uint _key) internal view returns (uint) {\r\n        return self.store.getUInt(self.crate, keccak256(abi.encodePacked(item.id, _key)));\r\n    }\r\n\r\n    function get(Config storage self, Mapping storage item, bytes32 _key) internal view returns (bytes32) {\r\n        return self.store.getBytes32(self.crate, keccak256(abi.encodePacked(item.id, _key)));\r\n    }\r\n\r\n    function get(Config storage self, StringMapping storage item, bytes32 _key) internal view returns (string) {\r\n        return get(self, item.id, _key);\r\n    }\r\n\r\n    function get(Config storage self, BytesSequenceMapping storage item, bytes32 _key) internal view returns (bytes) {\r\n        return get(self, item.id, _key);\r\n    }\r\n\r\n    function get(Config storage self, AddressUInt8Mapping storage item, bytes32 _key) internal view returns (address, uint8) {\r\n        return self.store.getAddressUInt8(self.crate, keccak256(abi.encodePacked(item.id, _key)));\r\n    }\r\n\r\n    function get(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2) internal view returns (bytes32) {\r\n        return get(self, item, keccak256(abi.encodePacked(_key, _key2)));\r\n    }\r\n\r\n    function get(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2, bytes32 _key3) internal view returns (bytes32) {\r\n        return get(self, item, keccak256(abi.encodePacked(_key, _key2, _key3)));\r\n    }\r\n\r\n    function get(Config storage self, Bool storage item, bytes32 _key, bytes32 _key2, bytes32 _key3) internal view returns (bool) {\r\n        return get(self, item, keccak256(abi.encodePacked(_key, _key2, _key3)));\r\n    }\r\n\r\n    function get(Config storage self, UIntBoolMapping storage item, uint _key) internal view returns (bool) {\r\n        return get(self, item.innerMapping, bytes32(_key));\r\n    }\r\n\r\n    function get(Config storage self, UIntEnumMapping storage item, uint _key) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntMapping storage item, uint _key) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressMapping storage item, uint _key) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UIntMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, _key));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32AddressMapping storage item, bytes32 _key) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, _key));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UInt8Mapping storage item, bytes32 _key) internal view returns (uint8) {\r\n        return get(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, Bytes32BoolMapping storage item, bytes32 _key) internal view returns (bool) {\r\n        return get(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, Bytes32Bytes32Mapping storage item, bytes32 _key) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UIntBoolMapping storage item, bytes32 _key, uint _key2) internal view returns (bool) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntBytes32Mapping storage item, uint _key) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntMapping storage item, address _key) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, AddressBoolMapping storage item, address _key) internal view returns (bool) {\r\n        return toBool(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, AddressAddressMapping storage item, address _key) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, bytes32(_key)));\r\n    }\r\n\r\n    function get(Config storage self, AddressBytes32Mapping storage item, address _key) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntBytes32Mapping storage item, uint _key, uint _key2) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key), bytes32(_key2));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntAddressMapping storage item, uint _key, uint _key2) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntUIntMapping storage item, uint _key, uint _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UIntUIntMapping storage item, bytes32 _key, uint _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, _key, bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32UIntUIntUIntMapping storage item, bytes32 _key, uint _key2, uint _key3) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, _key, bytes32(_key2), bytes32(_key3)));\r\n    }\r\n\r\n    function get(Config storage self, AddressAddressUIntMapping storage item, address _key, address _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressAddressUInt8Mapping storage item, address _key, address _key2) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntMapping storage item, address _key, uint _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUInt8Mapping storage item, address _key, uint _key2) internal view returns (uint) {\r\n        return uint8(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressBytes32Bytes32Mapping storage item, address _key, bytes32 _key2) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key), _key2);\r\n    }\r\n\r\n    function get(Config storage self, AddressBytes4BoolMapping storage item, address _key, bytes4 _key2) internal view returns (bool) {\r\n        return toBool(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressBytes4Bytes32Mapping storage item, address _key, bytes4 _key2) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key), bytes32(_key2));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressUIntMapping storage item, uint _key, address _key2) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressBoolMapping storage item, uint _key, address _key2) internal view returns (bool) {\r\n        return toBool(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressAddressMapping storage item, uint _key, address _key2) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\r\n    }\r\n\r\n    function get(Config storage self, UIntAddressAddressBoolMapping storage item, uint _key, address _key2, address _key3) internal view returns (bool) {\r\n        return get(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3));\r\n    }\r\n\r\n    function get(Config storage self, UIntUIntUIntBytes32Mapping storage item, uint _key, uint _key2, uint _key3) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntUIntMapping storage item, address _key, uint _key2, uint _key3) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntStructAddressUInt8Mapping storage item, address _key, uint _key2) internal view returns (address, uint8) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3) internal view returns (address, uint8) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, uint _key4) internal view returns (address, uint8) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntUIntUIntStructAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, uint _key4, uint _key5) internal view returns (address, uint8) {\r\n        return get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4, _key5)));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntAddressUInt8Mapping storage item, address _key, uint _key2, address _key3) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3))));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, address _key4) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4))));\r\n    }\r\n\r\n    function get(Config storage self, AddressUIntUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, uint _key4, address _key5) internal view returns (uint8) {\r\n        return uint8(get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4, _key5))));\r\n    }\r\n\r\n    /** `includes` operation */\r\n\r\n    function includes(Config storage self, Set storage item, bytes32 _value) internal view returns (bool) {\r\n        return includes(self, item, SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function includes(Config storage self, Set storage item, bytes32 _salt, bytes32 _value) internal view returns (bool) {\r\n        return get(self, item.indexes, _salt, _value) != 0;\r\n    }\r\n\r\n    function includes(Config storage self, AddressesSet storage item, address _value) internal view returns (bool) {\r\n        return includes(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, CounterSet storage item, uint _value) internal view returns (bool) {\r\n        return includes(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, OrderedSet storage item, bytes32 _value) internal view returns (bool) {\r\n        return includes(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function includes(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private view returns (bool) {\r\n        return _value != 0x0 && (get(self, item.nextValues, _salt, _value) != 0x0 || get(self, item.last, _salt) == _value);\r\n    }\r\n\r\n    function includes(Config storage self, OrderedUIntSet storage item, uint _value) internal view returns (bool) {\r\n        return includes(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, OrderedAddressesSet storage item, address _value) internal view returns (bool) {\r\n        return includes(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, Bytes32SetMapping storage item, bytes32 _key, bytes32 _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function includes(Config storage self, AddressesSetMapping storage item, bytes32 _key, address _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key, bytes32 _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function includes(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key, uint _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function includes(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key, address _value) internal view returns (bool) {\r\n        return includes(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function getIndex(Config storage self, Set storage item, bytes32 _value) internal view returns (uint) {\r\n        return getIndex(self, item, SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function getIndex(Config storage self, Set storage item, bytes32 _salt, bytes32 _value) private view returns (uint) {\r\n        return uint(get(self, item.indexes, _salt, _value));\r\n    }\r\n\r\n    function getIndex(Config storage self, AddressesSet storage item, address _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function getIndex(Config storage self, CounterSet storage item, uint _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerSet, bytes32(_value));\r\n    }\r\n\r\n    function getIndex(Config storage self, Bytes32SetMapping storage item, bytes32 _key, bytes32 _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerMapping, _key, _value);\r\n    }\r\n\r\n    function getIndex(Config storage self, AddressesSetMapping storage item, bytes32 _key, address _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    function getIndex(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _value) internal view returns (uint) {\r\n        return getIndex(self, item.innerMapping, _key, bytes32(_value));\r\n    }\r\n\r\n    /** `count` operation */\r\n\r\n    function count(Config storage self, Set storage item) internal view returns (uint) {\r\n        return count(self, item, SET_IDENTIFIER);\r\n    }\r\n\r\n    function count(Config storage self, Set storage item, bytes32 _salt) internal view returns (uint) {\r\n        return get(self, item.count, _salt);\r\n    }\r\n\r\n    function count(Config storage self, AddressesSet storage item) internal view returns (uint) {\r\n        return count(self, item.innerSet);\r\n    }\r\n\r\n    function count(Config storage self, CounterSet storage item) internal view returns (uint) {\r\n        return count(self, item.innerSet);\r\n    }\r\n\r\n    function count(Config storage self, OrderedSet storage item) internal view returns (uint) {\r\n        return count(self, item, ORDERED_SET_IDENTIFIER);\r\n    }\r\n\r\n    function count(Config storage self, OrderedSet storage item, bytes32 _salt) private view returns (uint) {\r\n        return get(self, item.count, _salt);\r\n    }\r\n\r\n    function count(Config storage self, OrderedUIntSet storage item) internal view returns (uint) {\r\n        return count(self, item.innerSet);\r\n    }\r\n\r\n    function count(Config storage self, OrderedAddressesSet storage item) internal view returns (uint) {\r\n        return count(self, item.innerSet);\r\n    }\r\n\r\n    function count(Config storage self, Bytes32SetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, AddressesSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, UIntSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function count(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key) internal view returns (uint) {\r\n        return count(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, Set storage item) internal view returns (bytes32[] result) {\r\n        result = get(self, item, SET_IDENTIFIER);\r\n    }\r\n\r\n    function get(Config storage self, Set storage item, bytes32 _salt) private view returns (bytes32[] result) {\r\n        uint valuesCount = count(self, item, _salt);\r\n        result = new bytes32[](valuesCount);\r\n        for (uint i = 0; i < valuesCount; i++) {\r\n            result[i] = get(self, item, _salt, i);\r\n        }\r\n    }\r\n\r\n    function get(Config storage self, AddressesSet storage item) internal view returns (address[]) {\r\n        return toAddresses(get(self, item.innerSet));\r\n    }\r\n\r\n    function get(Config storage self, CounterSet storage item) internal view returns (uint[]) {\r\n        return toUInt(get(self, item.innerSet));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32SetMapping storage item, bytes32 _key) internal view returns (bytes32[]) {\r\n        return get(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function get(Config storage self, AddressesSetMapping storage item, bytes32 _key) internal view returns (address[]) {\r\n        return toAddresses(get(self, item.innerMapping, _key));\r\n    }\r\n\r\n    function get(Config storage self, UIntSetMapping storage item, bytes32 _key) internal view returns (uint[]) {\r\n        return toUInt(get(self, item.innerMapping, _key));\r\n    }\r\n\r\n    function get(Config storage self, Set storage item, uint _index) internal view returns (bytes32) {\r\n        return get(self, item, SET_IDENTIFIER, _index);\r\n    }\r\n\r\n    function get(Config storage self, Set storage item, bytes32 _salt, uint _index) private view returns (bytes32) {\r\n        return get(self, item.values, _salt, bytes32(_index+1));\r\n    }\r\n\r\n    function get(Config storage self, AddressesSet storage item, uint _index) internal view returns (address) {\r\n        return address(get(self, item.innerSet, _index));\r\n    }\r\n\r\n    function get(Config storage self, CounterSet storage item, uint _index) internal view returns (uint) {\r\n        return uint(get(self, item.innerSet, _index));\r\n    }\r\n\r\n    function get(Config storage self, Bytes32SetMapping storage item, bytes32 _key, uint _index) internal view returns (bytes32) {\r\n        return get(self, item.innerMapping, _key, _index);\r\n    }\r\n\r\n    function get(Config storage self, AddressesSetMapping storage item, bytes32 _key, uint _index) internal view returns (address) {\r\n        return address(get(self, item.innerMapping, _key, _index));\r\n    }\r\n\r\n    function get(Config storage self, UIntSetMapping storage item, bytes32 _key, uint _index) internal view returns (uint) {\r\n        return uint(get(self, item.innerMapping, _key, _index));\r\n    }\r\n\r\n    function getNextValue(Config storage self, OrderedSet storage item, bytes32 _value) internal view returns (bytes32) {\r\n        return getNextValue(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function getNextValue(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private view returns (bytes32) {\r\n        return get(self, item.nextValues, _salt, _value);\r\n    }\r\n\r\n    function getNextValue(Config storage self, OrderedUIntSet storage item, uint _value) internal view returns (uint) {\r\n        return uint(getNextValue(self, item.innerSet, bytes32(_value)));\r\n    }\r\n\r\n    function getNextValue(Config storage self, OrderedAddressesSet storage item, address _value) internal view returns (address) {\r\n        return address(getNextValue(self, item.innerSet, bytes32(_value)));\r\n    }\r\n\r\n    function getPreviousValue(Config storage self, OrderedSet storage item, bytes32 _value) internal view returns (bytes32) {\r\n        return getPreviousValue(self, item, ORDERED_SET_IDENTIFIER, _value);\r\n    }\r\n\r\n    function getPreviousValue(Config storage self, OrderedSet storage item, bytes32 _salt, bytes32 _value) private view returns (bytes32) {\r\n        return get(self, item.previousValues, _salt, _value);\r\n    }\r\n\r\n    function getPreviousValue(Config storage self, OrderedUIntSet storage item, uint _value) internal view returns (uint) {\r\n        return uint(getPreviousValue(self, item.innerSet, bytes32(_value)));\r\n    }\r\n\r\n    function getPreviousValue(Config storage self, OrderedAddressesSet storage item, address _value) internal view returns (address) {\r\n        return address(getPreviousValue(self, item.innerSet, bytes32(_value)));\r\n    }\r\n\r\n    function toBool(bytes32 self) internal pure returns (bool) {\r\n        return self != bytes32(0);\r\n    }\r\n\r\n    function toBytes32(bool self) internal pure returns (bytes32) {\r\n        return bytes32(self ? 1 : 0);\r\n    }\r\n\r\n    function toAddresses(bytes32[] memory self) internal pure returns (address[]) {\r\n        address[] memory result = new address[](self.length);\r\n        for (uint i = 0; i < self.length; i++) {\r\n            result[i] = address(self[i]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function toUInt(bytes32[] memory self) internal pure returns (uint[]) {\r\n        uint[] memory result = new uint[](self.length);\r\n        for (uint i = 0; i < self.length; i++) {\r\n            result[i] = uint(self[i]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function _setOrderedSetLink(Config storage self, Mapping storage link, bytes32 _salt, bytes32 from, bytes32 to) private {\r\n        if (from != 0x0) {\r\n            set(self, link, _salt, from, to);\r\n        }\r\n    }\r\n\r\n    function _deleteOrderedSetLink(Config storage self, Mapping storage link, bytes32 _salt, bytes32 from) private {\r\n        if (from != 0x0) {\r\n            set(self, link, _salt, from, 0x0);\r\n        }\r\n    }\r\n\r\n    /** @title Structure to incapsulate and organize iteration through different kinds of collections */\r\n    struct Iterator {\r\n        uint limit;\r\n        uint valuesLeft;\r\n        bytes32 currentValue;\r\n        bytes32 anchorKey;\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item, bytes32 anchorKey, bytes32 startValue, uint limit) internal view returns (Iterator) {\r\n        if (startValue == 0x0) {\r\n            return listIterator(self, item, anchorKey, limit);\r\n        }\r\n\r\n        return createIterator(anchorKey, startValue, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item, bytes32 anchorKey, uint startValue, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey, bytes32(startValue), limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item, bytes32 anchorKey, address startValue, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey, bytes32(startValue), limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item, ORDERED_SET_IDENTIFIER, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item, bytes32 anchorKey, uint limit) internal view returns (Iterator) {\r\n        return createIterator(anchorKey, get(self, item.first, anchorKey), limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item, bytes32 anchorKey, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item, uint limit) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item, uint limit, bytes32 anchorKey) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey, limit);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item) internal view returns (Iterator) {\r\n        return listIterator(self, item, ORDERED_SET_IDENTIFIER);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedSet storage item, bytes32 anchorKey) internal view returns (Iterator) {\r\n        return listIterator(self, item, anchorKey, get(self, item.count, anchorKey));\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedUIntSet storage item, bytes32 anchorKey) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet);\r\n    }\r\n\r\n    function listIterator(Config storage self, OrderedAddressesSet storage item, bytes32 anchorKey) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerSet, anchorKey);\r\n    }\r\n\r\n    function listIterator(Config storage self, Bytes32OrderedSetMapping storage item, bytes32 _key) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function listIterator(Config storage self, UIntOrderedSetMapping storage item, bytes32 _key) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function listIterator(Config storage self, AddressOrderedSetMapping storage item, bytes32 _key) internal view returns (Iterator) {\r\n        return listIterator(self, item.innerMapping, _key);\r\n    }\r\n\r\n    function createIterator(bytes32 anchorKey, bytes32 startValue, uint limit) internal pure returns (Iterator) {\r\n        return Iterator({\r\n            currentValue: startValue,\r\n            limit: limit,\r\n            valuesLeft: limit,\r\n            anchorKey: anchorKey\r\n        });\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, OrderedSet storage item, Iterator iterator) internal view returns (bytes32 _nextValue) {\r\n        if (!canGetNextWithIterator(self, item, iterator)) { revert(); }\r\n\r\n        _nextValue = iterator.currentValue;\r\n\r\n        iterator.currentValue = getNextValue(self, item, iterator.anchorKey, iterator.currentValue);\r\n        iterator.valuesLeft -= 1;\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, OrderedUIntSet storage item, Iterator iterator) internal view returns (uint _nextValue) {\r\n        return uint(getNextWithIterator(self, item.innerSet, iterator));\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, OrderedAddressesSet storage item, Iterator iterator) internal view returns (address _nextValue) {\r\n        return address(getNextWithIterator(self, item.innerSet, iterator));\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, Bytes32OrderedSetMapping storage item, Iterator iterator) internal view returns (bytes32 _nextValue) {\r\n        return getNextWithIterator(self, item.innerMapping, iterator);\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, UIntOrderedSetMapping storage item, Iterator iterator) internal view returns (uint _nextValue) {\r\n        return uint(getNextWithIterator(self, item.innerMapping, iterator));\r\n    }\r\n\r\n    function getNextWithIterator(Config storage self, AddressOrderedSetMapping storage item, Iterator iterator) internal view returns (address _nextValue) {\r\n        return address(getNextWithIterator(self, item.innerMapping, iterator));\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, OrderedSet storage item, Iterator iterator) internal view returns (bool) {\r\n        if (iterator.valuesLeft == 0 || !includes(self, item, iterator.anchorKey, iterator.currentValue)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, OrderedUIntSet storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerSet, iterator);\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, OrderedAddressesSet storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerSet, iterator);\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, Bytes32OrderedSetMapping storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerMapping, iterator);\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, UIntOrderedSetMapping storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerMapping, iterator);\r\n    }\r\n\r\n    function canGetNextWithIterator(Config storage self, AddressOrderedSetMapping storage item, Iterator iterator) internal view returns (bool) {\r\n        return canGetNextWithIterator(self, item.innerMapping, iterator);\r\n    }\r\n\r\n    function count(Iterator iterator) internal pure returns (uint) {\r\n        return iterator.valuesLeft;\r\n    }\r\n}\r\n\r\n// File: @laborx/solidity-storage-contracts/contracts/StorageAdapter.sol\r\n\r\n/**\r\n * Copyright 2017–2018, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\ncontract StorageAdapter {\r\n\r\n    using StorageInterface for *;\r\n\r\n    StorageInterface.Config internal store;\r\n\r\n    constructor(Storage _store, bytes32 _crate) public {\r\n        store.init(_store, _crate);\r\n    }\r\n}\r\n\r\n// File: contracts/common/initializable/InitializableOwned.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\ncontract InitializableOwned is Owned {\r\n\r\n\tfunction _initOwned(address _owner) internal {\r\n\t\trequire(_owner != 0x0);\r\n\t\trequire(contractOwner == 0x0);\r\n\t\tcontractOwner = _owner;\r\n\t}\r\n}\r\n\r\n// File: contracts/common/initializable/InitializableStorageAdapter.sol\r\n\r\n/**\r\n* Copyright 2017–2019, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\ncontract InitializableStorageAdapter is StorageAdapter {\r\n\r\n    function _initStorageAdapter(Storage _storage, bytes32 _crate) internal {\r\n        require(address(store.store) == 0x0);\r\n        store.init(_storage, _crate);\r\n    }\r\n}\r\n\r\n// File: contracts/libs/Bits.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\nlibrary Bits {\r\n\r\n    uint constant internal ONE = uint(1);\r\n    uint constant internal ONES = uint(~0);\r\n\r\n    // Sets the bit at the given 'index' in 'self' to '1'.\r\n    // Returns the modified value.\r\n    function setBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self | ONE << index;\r\n    }\r\n\r\n    // Sets the bit at the given 'index' in 'self' to '0'.\r\n    // Returns the modified value.\r\n    function clearBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self & ~(ONE << index);\r\n    }\r\n\r\n    // Sets the bit at the given 'index' in 'self' to:\r\n    //  '1' - if the bit is '0'\r\n    //  '0' - if the bit is '1'\r\n    // Returns the modified value.\r\n    function toggleBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self ^ ONE << index;\r\n    }\r\n\r\n    // Get the value of the bit at the given 'index' in 'self'.\r\n    function bit(uint self, uint8 index) internal pure returns (uint8) {\r\n        return uint8(self >> index & 1);\r\n    }\r\n\r\n    // Check if the bit at the given 'index' in 'self' is set.\r\n    // Returns:\r\n    //  'true' - if the value of the bit is '1'\r\n    //  'false' - if the value of the bit is '0'\r\n    function bitSet(uint self, uint8 index) internal pure returns (bool) {\r\n        return self >> index & 1 == 1;\r\n    }\r\n\r\n    // Checks if the bit at the given 'index' in 'self' is equal to the corresponding\r\n    // bit in 'other'.\r\n    // Returns:\r\n    //  'true' - if both bits are '0' or both bits are '1'\r\n    //  'false' - otherwise\r\n    function bitEqual(uint self, uint other, uint8 index) internal pure returns (bool) {\r\n        return (self ^ other) >> index & 1 == 0;\r\n    }\r\n\r\n    // Get the bitwise NOT of the bit at the given 'index' in 'self'.\r\n    function bitNot(uint self, uint8 index) internal pure returns (uint8) {\r\n        return uint8(1 - (self >> index & 1));\r\n    }\r\n\r\n    // Computes the bitwise AND of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitAnd(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self & other) >> index & 1);\r\n    }\r\n\r\n    // Computes the bitwise OR of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitOr(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self | other) >> index & 1);\r\n    }\r\n\r\n    // Computes the bitwise XOR of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitXor(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self ^ other) >> index & 1);\r\n    }\r\n\r\n    // Gets 'numBits' consecutive bits from 'self', starting from the bit at 'startIndex'.\r\n    // Returns the bits as a 'uint'.\r\n    // Requires that:\r\n    //  - '0 < numBits <= 256'\r\n    //  - 'startIndex < 256'\r\n    //  - 'numBits + startIndex <= 256'\r\n    function bits(uint self, uint8 startIndex, uint16 numBits) internal pure returns (uint) {\r\n        require(0 < numBits && startIndex < 256 && startIndex + numBits <= 256);\r\n        return self >> startIndex & ONES >> 256 - numBits;\r\n    }\r\n\r\n    // Computes the index of the highest bit set in 'self'.\r\n    // Returns the highest bit set as an 'uint8'.\r\n    // Requires that 'self != 0'.\r\n    function highestBitSet(uint self) internal pure returns (uint8 highest) {\r\n        require(self != 0);\r\n        uint val = self;\r\n        for (uint8 i = 128; i >= 1; i >>= 1) {\r\n            if (val & (ONE << i) - 1 << i != 0) {\r\n                highest += i;\r\n                val >>= i;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Computes the index of the lowest bit set in 'self'.\r\n    // Returns the lowest bit set as an 'uint8'.\r\n    // Requires that 'self != 0'.\r\n    function lowestBitSet(uint self) internal pure returns (uint8 lowest) {\r\n        require(self != 0);\r\n        uint val = self;\r\n        for (uint8 i = 128; i >= 1; i >>= 1) {\r\n            if (val & (ONE << i) - 1 == 0) {\r\n                lowest += i;\r\n                val >>= i;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/common/FeeConstants.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\ncontract FeeConstants {\r\n\r\n    using Bits for uint8;\r\n\r\n    uint8 constant SELLER_FLAG_BIT_IDX = 0;\r\n    uint8 constant BUYER_FLAG_BIT_IDX = 1;\r\n\r\n    function _getSellerFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return uint8(_feeStatus.setBit(SELLER_FLAG_BIT_IDX));\r\n    }\r\n\r\n    function _getBuyerFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return uint8(_feeStatus.setBit(BUYER_FLAG_BIT_IDX));\r\n    }\r\n\r\n    function _getAllFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return uint8(uint8(_feeStatus\r\n            .setBit(SELLER_FLAG_BIT_IDX))\r\n            .setBit(BUYER_FLAG_BIT_IDX));\r\n    }\r\n\r\n    function _getNoFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return 0;\r\n    }\r\n\r\n    function _isFeeFlagAppliedFor(uint8 _feeStatus, uint8 _userBit) internal pure returns (bool) {\r\n        return _feeStatus.bitSet(_userBit);\r\n    }\r\n}\r\n\r\n// File: contracts/escrow/EscrowBaseInterface.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ninterface EscrowBaseInterface {\r\n\r\n\tfunction hasCurrencySupport(bytes32 _symbol) public view returns (bool);\r\n\r\n\tfunction getServiceFeeInfo() external view returns (address, uint16, uint);\r\n\tfunction setServiceFee(uint16 _feeValue) external returns (uint);\r\n\tfunction setServiceFeeAddress(address _feeReceiver) external returns (uint);\r\n\r\n\t/// @notice Gets balance locked on escrow.\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @return currency symbol\r\n    /// @return currence balance on escrow\r\n    function getBalanceOf(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer\r\n    ) external view returns (bytes32, uint);\r\n\r\n\t/// @notice Creates an escrow record for provided symbol \"`_symbol`\"\r\n\t/// @dev Escrow is reusable so the same tradeRecordId could be reused after an escrow\r\n\t///\t\twith the same identifier is resolved.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _symbol symbol of payment currency\r\n\t/// @param _value amount to initially deposit to escrow; could be 0\r\n\t/// @param _transferImmediatelyToBuyerAmount amount to transfer immediately to a buyer\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction createEscrow(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tbytes32 _symbol,\r\n\t\tuint _value,\r\n\t\tuint _transferImmediatelyToBuyerAmount,\r\n\t\tuint8 _feeStatus\r\n\t) external payable returns (uint);\r\n\r\n\t/// @notice Deposits to an escrow provided amount `_value`\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _value amount to deposit\r\n\t/// @param _transferImmediatelyToBuyerAmount amount to transfer immediately to a buyer\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction deposit(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _value,\r\n\t\tuint _transferImmediatelyToBuyerAmount, // transfers _transferImmediatelyToBuyerAmount directly to _buyer.\r\n\t\tuint8 _feeStatus\r\n\t) external payable returns (uint);\r\n\r\n\t/// @notice Transfers `_value` from escrow to buyer `_buyer`\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller shoud sign hash of (message, escrow address, msg.sig, _value, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _value amount to withdraw from escrow\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _sellerSignature signature produced by seller\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction releaseBuyerPayment(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _value,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _sellerSignature,\r\n\t\tuint8 _feeStatus\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Transfers `_value` from escrow to seller `_seller`\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Buyer shoud sign hash of (message, escrow address, msg.sig, _value, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _value amount to withdraw from escrow\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _buyerSignature signature produced by buyer\r\n\t/// @return result code of an operation\r\n\tfunction sendSellerPayback(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _value,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _buyerSignature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Transfers `_value` from escrow to seller `_seller` and buyer `_buyer`\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _sellerValue, _buyerValue, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _sellerValue amount to withdraw from escrow to the seller\r\n\t/// @param _buyerValue amount to withdraw from escrow to the buyer\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signatures concatenated signatures produced by seller and buyer\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction releaseNegotiatedPayment(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _sellerValue,\r\n\t\tuint _buyerValue,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _signatures,\r\n\t\tuint8 _feeStatus\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Starts a dispute process between seller `_seller` and buyer `_buyer`.\r\n\t/// \tCould start only if an arbiter was specified.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signature signature of an initiator\r\n\t/// @return result code of an operation\r\n\tfunction initiateDispute(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _signature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Cancels an initiated dispute process\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signature signature of an initiator\r\n\t/// @return result code of an operation\r\n\tfunction cancelDispute(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _signature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Transfers disputed value from escrow to the seller `_seller` and the buyer `_buyer` according\r\n\t/// \tto provided buyer value `_buyerValue`. The value of escrow - _buyerValue will be transferred to the seller.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Arbiter should sign hash of (message, escrow address, msg.sig, _buyerValue, _expireAtBlock) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _buyerValue value that will be transferred to the buyer\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _arbiterSignature signature of an arbiter\r\n\t/// @return result code of an operation\r\n\tfunction releaseDisputedPayment(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _buyerValue,\r\n\t\tuint _expireAtBlock,\r\n\t\tbytes _arbiterSignature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Deletes escrow record when it is no more needed.\r\n    ///     Escrow should be empty to be deleted.\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    function deleteEscrow(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer\r\n    ) external returns (uint);\r\n\r\n\tfunction getArbiter(bytes32 _tradeRecordId, address _seller, address _buyer) external view returns (address);\r\n\r\n\t/// @notice Sets a new arbiter `_arbiter`. His address should be approved by both parties.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _arbiter, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _bothSignatures signatures of seller and buyer\r\n\tfunction setArbiter(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\taddress _arbiter,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _bothSignatures\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Performs transfer of a currency `_symbol`\r\n\t///\t\tfrom a `msg.sender` to service fee recepient\r\n\t/// @param _symbol target currency symbol\r\n\t/// @param _from holder address of the `_symbol`\r\n\t/// @param _amount amount to retransfer\r\n\t/// @return result code of an operation\r\n\tfunction retranslateToFeeRecipient(bytes32 _symbol, address _from, uint _amount) external payable returns (uint);\r\n}\r\n\r\n// File: contracts/workflow/WorkflowBase.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ninterface WorkflowBase {\r\n\r\n    /// @param _contractHost smart contract address that will be requested for payments\r\n    function registerContract(bytes32 _contractId, address _contractHost) external returns (uint);\r\n    function addWorkflowData(\r\n        bytes32 _contractId,\r\n        address _contractHost,\r\n        bytes _data\r\n        ) external returns (uint _budget, uint _upfront);\r\n\r\n    function precalculateWorkflowData(\r\n        bytes32 _contractId,\r\n        address _contractHost,\r\n        bytes _data\r\n        ) external view returns (uint _budget, uint _upfront);\r\n\r\n    /// @notice Gets upfront amount from tasks that have not been finished (completed) yet\r\n    /// @param _contractId contract identifier\r\n    /// @param _contractHost contract smart contract address\r\n    function getUnspentUpfrontAmount(bytes32 _contractId, address _contractHost) external view returns (uint);\r\n}\r\n\r\n\r\ninterface WorkflowContractBlacklistable {\r\n    function isAllowedContractHost(address _contractHost) external view returns (bool);\r\n    function addContractHost(address _contractHost) external returns (uint);\r\n    function removeContractHost(address _contractHost) external returns (uint);\r\n}\r\n\r\n\r\ninterface WorkflowCheckpointBase {\r\n    /// @notice Gets numbers of how much employer will pay for a task `_taskId` in contract `_contractId` at `_contract`\r\n    /// @param _contractId contract ID\r\n    /// @param _contract address of a smart contract\r\n    /// @param _taskId task ID to confirm to\r\n    /// @param _skippedPenalties penalty IDs that will be skipped during payment calculations\r\n    /// @return _totalValue how much task costs\r\n    /// @return _paymentValue how much should be paid immediately\r\n    /// @return _depositValue how much should be additionally deposited\r\n    function getTaskCompletionReward(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint32[] _skippedPenalties\r\n    )\r\n    public\r\n    view\r\n    returns (\r\n        uint _totalValue,\r\n        uint _paymentValue,\r\n        uint _depositValue,\r\n        uint _paidValue\r\n    );\r\n\r\n    /// @dev Gets task details.\r\n    /// @return\r\n    /// @return _values[0] budget amount\r\n    /// @return _values[1] paid amount\r\n    /// @return _values[2] upfront amount\r\n    /// @return _values[3] withdraw fee amount of paid amount\r\n    function getTaskDetails(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    )\r\n    external\r\n    view\r\n    returns (uint[] _values);\r\n\r\n    function getTaskCompletionRewardWithoutPenalties(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId\r\n    )\r\n    public\r\n    view\r\n    returns (\r\n        uint _totalValue,\r\n        uint _paymentValue,\r\n        uint _depositValue,\r\n        uint _paidValue\r\n    );\r\n\r\n    /// @notice Gets numbers of how much should be additionally deposited to the assignee received `_value`\r\n    /// @param _contractId contract ID\r\n    /// @param _contract address of a smart contract\r\n    /// @param _value how much should be paid immediately\r\n    /// @return _paymentValue how much should be paid immediately\r\n    /// @return _depositValue how much should be additionally deposited\r\n    function getTaskSinglePaymentReward(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint _value\r\n    )\r\n    public\r\n    view\r\n    returns (uint _paymentValue, uint _depositValue);\r\n\r\n    function startTask(bytes32 _contractId, address _contract,  uint32 _taskId) external returns (uint);\r\n    function pauseTask(bytes32 _contractId, address _contract, uint32 _taskId) external returns (uint);\r\n    function resumeTask(bytes32 _contractId, address _contract, uint32 _taskId) external returns (uint);\r\n\r\n    /// @notice Prepaid expense to the assignee for task `_taskId` in context of contract `_contractId`.\r\n    ///     Assignee's penalties will not be applied to payment value.\r\n    ///     Employer should provide signature for releasing buyer's value from 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _contractId contract ID\r\n    /// @param _contract address of a smart contract\r\n    /// @param _taskId task ID for payment\r\n    /// @param _expireAtBlock bound with signature. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _salt bound with signature. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _signature signature for releasing blocked amount. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @return result code of an operation\r\n    function payPartialTaskExpenses(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n        ) external payable returns (uint);\r\n\r\n    /// @notice Confirms task `_taskId` completion in context of contract `_contractId` and frees\r\n    ///     budget to be send to the assignee.\r\n    ///     Assignee's penalties will not be applied to the final paycheck.\r\n    ///     Employer should provide signature for releasing buyer's value from 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _contractId contract ID\r\n    /// @param _contract address of a smart contract\r\n    /// @param _taskId task ID to confirm to\r\n    /// @param _expireAtBlock bound with signature. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _salt bound with signature. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _signature signature for releasing blocked amount. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @return result code of an operation\r\n    function completeTaskAndPay(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n        ) external payable returns (uint);\r\n\r\n    function completeTask(bytes32 _contractId, address _contract, uint32 _taskId) external returns (uint);\r\n\r\n    /// @notice Confirms task `_taskId` completion in context of contract `_contractId` and frees\r\n    ///     budget to be send to the assignee.\r\n    ///     Assignee's penalties could be skipped and they will not be applied to the final paycheck.\r\n    ///     Employer should provide signature for releasing buyer's value from 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _contractId contract ID\r\n    /// @param _contract address of a smart contract\r\n    /// @param _taskId task ID to confirm to\r\n    /// @param _skippedPenalties penalty IDs that will be skipped during payment calculations\r\n    /// @param _expireAtBlock bound with signature. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _salt bound with signature. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @param _signature signature for releasing blocked amount. See 'EscrowBaseInterface#releaseBuyerPayment'\r\n    /// @return result code of an operation\r\n    function confirmTaskCompletion(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        uint32[] _skippedPenalties,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n        ) external payable returns (uint);\r\n\r\n    function declineTaskAndSendToRework(\r\n        bytes32 _contractId,\r\n        address _contract,\r\n        uint32 _taskId,\r\n        string _reason\r\n        ) external returns (uint);\r\n}\r\n\r\n// File: contracts/libs/SafeMath.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b, \"SAFE_MATH_MUL\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SAFE_MATH_SUB\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SAFE_MATH_ADD\");\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n}\r\n\r\n// File: contracts/libs/PercentCalculator.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\nlibrary PercentCalculator {\r\n\r\n    using SafeMath for uint;\r\n\r\n    function getPercent(\r\n        uint _value,\r\n        uint _percent,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint)\r\n    {\r\n        return _value.mul(_percent).div(_precision);\r\n    }\r\n\r\n    function getValueWithPercent(\r\n        uint _value,\r\n        uint _percent,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint)\r\n    {\r\n        return _value.add(getPercent(_value, _percent, _precision));\r\n    }\r\n\r\n    function getFullValueFromPercentedValue(\r\n        uint _value,\r\n        uint _percent,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint)\r\n    {\r\n        return _value.mul(_precision).div(_percent);\r\n    }\r\n}\r\n\r\n// File: contracts/libs/DataParser.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n/// @title Provides functions to parse and copy input data stream for LX Contract module.\r\nlibrary DataParser {\r\n\r\n    using SafeMath for uint;\r\n\r\n    // constant uint CONTRACT_DATA_STRUCT_LENGTH = 232;\r\n    // constant uint TASK_DATA_STRUCT_LENGTH = 102;\r\n    // constant uint PENALTY_DATA_STRUCT_LENGTH = 74;\r\n    // constant uint TERMINATION_DATA_STRUCT_LENGTH = 70;\r\n\r\n    /** @dev DATA_STRUCTURE_TYPE {\r\n            CONTRACT = 1,\r\n            TASK = 2,\r\n            PENALTY = 3,\r\n            TERMINATION = 4\r\n        }\r\n    */\r\n    /// @dev CONTRACT_TYPE { JOB = 1, DISPUTE = 2 }\r\n    /// @dev PAYMENT_TIMELINE { PAY_BY_TASK = 1, PAY_BY_PROJECT = 2 }\r\n    /// @dev PAYMENT_VALUE_TYPE { CURRENCY = 1; PERCENT = 2 }\r\n    /// @dev PENALTY_APPLICATION_TYPE { MISS_DEADLINE = 1, LATE_PAYMENT = 2 }\r\n    /// @dev TERMINATION_PARTY { TERMINATION_EMPLOYER = 1, TERMINATION_ASSIGNEE = 2 }\r\n\r\n    enum ContractType { INVALID, JOB, DISPUTE }\r\n    enum PaymentValueType { INVALID, CURRENCY, PERCENT }\r\n    enum PaymentTimeline { INVALID, PAY_BY_TASK, PAY_BY_PROJECT }\r\n    enum TerminationParty { INVALID, TERMINATION_EMPLOYER, TERMINATION_ASSIGNEE }\r\n    enum PenaltyApplicationType { INVALID, MISS_DEADLINE, LATE_PAYMENT }\r\n\r\n    enum DataStructureType {\r\n        INVALID,\r\n        CONTRACT,\r\n        TASK,\r\n        PENALTY,\r\n        TERMINATION\r\n    }\r\n\r\n    /// @dev Contract data structure\r\n    struct ContractData {\r\n        /// @dev CONTRACT_TYPE type\r\n        uint8 contractType;\r\n        bytes32 documentHash;\r\n        /// @dev for dispute contracts\r\n        bytes32 linkedContractId;\r\n        address employer;\r\n        address assignee;\r\n        address arbiter;\r\n        address participant;\r\n        /// @dev timestamp\r\n        uint256 beginDate;\r\n        bytes32 paymentCurrencySymbol;\r\n        address paymentCurrencyAddress; // @deprecated\r\n        bool lockFullBudget;\r\n        /// @dev PAYMENT_TIMELINE type\r\n        uint8 paymentTimeline;\r\n        bool refundUpfrontOnTermination;\r\n        bool allowDynamicTasks;\r\n    }\r\n\r\n    /// @dev Task data structure\r\n    struct TaskData {\r\n        uint32 id;\r\n        bool isUpfront;\r\n        /// @dev PAYMENT_VALUE_TYPE type\r\n        uint8 upfrontValueType;\r\n        /// @dev interpretation is based on valueType\r\n        uint256 upfrontValue;\r\n        /// @dev total amount to pay\r\n        uint256 budget;\r\n        /// @dev timestamp\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct TaskPenaltyData {\r\n        uint32 id;\r\n        /// @dev penalized task id\r\n        uint32 taskId;\r\n        /// @dev PENALTY_APPLICATION_TYPE type\r\n        uint8 applicationType;\r\n        /// @dev PAYMENT_VALUE_TYPE type\r\n        uint8 valueType;\r\n        /// @dev interpretation is based on valueType\r\n        uint256 value;\r\n        /// @dev reserved for future purposes\r\n        bytes32 reserved1;\r\n    }\r\n\r\n    struct TerminationData {\r\n        uint32 id;\r\n        /// @dev TERMINATION_PARTY\r\n        uint8 initiatorType;\r\n        /// @dev TERMINATION_PARTY\r\n        uint8 payToType;\r\n        bytes32 description;\r\n        /// @dev PAYMENT_VALUE_TYPE type\r\n        uint8 valueType;\r\n        /// @dev interpretation is based on valueType\r\n        uint256 value;\r\n    }\r\n\r\n    function _getRawLengthForDataStructure(uint8 _dataStructureType) internal pure returns (uint _length) {\r\n        assembly {\r\n            switch _dataStructureType\r\n            case 1 { _length := 233 } // CONTRACT_DATA_STRUCT_LENGTH\r\n            case 2 { _length := 102 } // TASK_DATA_STRUCT_LENGTH\r\n            case 3 { _length := 74 } // PENALTY_DATA_STRUCT_LENGTH\r\n            case 4 { _length := 71 } // TERMINATION_DATA_STRUCT_LENGTH\r\n            default { revert(0,0) }\r\n        }\r\n    }\r\n\r\n    function _getFieldsNumberForDataStructure(uint8 _dataStructureType) private pure returns (uint _fields) {\r\n        assembly {\r\n            switch _dataStructureType\r\n            case 1 { _fields := 14 } // CONTRACT_DATA_STRUCT_LENGTH\r\n            case 2 { _fields := 6 } // TASK_DATA_STRUCT_LENGTH\r\n            case 3 { _fields := 6 } // PENALTY_DATA_STRUCT_LENGTH\r\n            case 4 { _fields := 6 } // TERMINATION_DATA_STRUCT_LENGTH\r\n            default { revert(0,0) }\r\n        }\r\n    }\r\n\r\n    function _countRawInputStructures(bytes memory _inputData, uint8 _dataStructureType) private pure returns (uint _counter) {\r\n        uint _pointerOffset;\r\n        while (_pointerOffset < _inputData.length) {\r\n            uint8 header;\r\n            assembly {\r\n                let pointer := add(_inputData, add(_pointerOffset, 0x1))\r\n                header := and(mload(pointer), 0xff)\r\n                if eq(header, _dataStructureType) {\r\n                    _counter := add(_counter, 1)\r\n                }\r\n            }\r\n\r\n            _pointerOffset += _getRawLengthForDataStructure(header) + 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Copies data from `_input` by length of `_cutLength` and pastes into\r\n    ///     `_output` with offset `_outputPointer`\r\n    function _cutDataFromInput(\r\n        bytes memory _input,\r\n        uint _cutLength,\r\n        bytes memory _output,\r\n        uint _outputPointer\r\n    )\r\n    private\r\n    pure\r\n    {\r\n        assembly {\r\n            let dataPointer := add(_output, _outputPointer)\r\n            let end := add(dataPointer, _cutLength)\r\n\r\n            for {\r\n                let cc := _input\r\n            } lt(dataPointer, end) {\r\n                dataPointer := add(dataPointer, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(dataPointer, mload(cc))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Allocates bytes array for keeping a struct data by providing number of struct items\r\n    ///     and number of fields in a struct.\r\n    ///     Reserves prefix memory slots for future struct casting.\r\n    function _allocUnpackedMemoryBytesArray(uint _structCount, uint _structFieldsNumber) private pure returns (bytes memory _arr) {\r\n        assembly {\r\n            _arr := add(mload(0x40), mul(_structCount, 0x20)) // prepend new memory area with _structCount more empty slots (for structure item references)\r\n            let _length := mul(mul(_structFieldsNumber, 0x20), _structCount)\r\n            mstore(_arr, _length)\r\n\r\n            mstore(0x40, add(_arr, add(_length, 0x20)))\r\n        }\r\n    }\r\n\r\n    /// @dev Allocates bytes array for keeping data\r\n    function _allocMemoryBytesArray(uint _structCount, uint _structDataLength) private pure returns (bytes memory _arr) {\r\n        assembly {\r\n            _arr := mload(0x40)\r\n            let _length := mul(_structDataLength, _structCount)\r\n            mstore(_arr, _length)\r\n\r\n            mstore(0x40, add(_arr, add(_length, 0x20)))\r\n        }\r\n    }\r\n\r\n    /// @dev Transforms provided array to have struct-like array presentation.\r\n    ///     Should provide array with preserved memory slots.\r\n    function _castMemoryArrayToStructureArray(\r\n        bytes memory _arr,\r\n        uint _structFieldsNumber\r\n    )\r\n    private\r\n    pure\r\n    returns (\r\n        bytes memory _castedArr\r\n    ) {\r\n        /**\r\n         * Transform raw bytes array into array of structures.\r\n         * It should have the following structure:\r\n         * - first byte: number of structures\r\n         * - n-bytes (n - number of structures): references into memory to structures' items ()\r\n         * - n+m-bytes: data\r\n         */\r\n        assembly {\r\n            let _structLength := mul(_structFieldsNumber, 0x20)\r\n            let _structuresCount := div(mload(_arr), _structLength)\r\n            _castedArr := sub(_arr, mul(_structuresCount, 0x20)) // set offset in opposite way to expand memory with structures' refs\r\n            mstore(_castedArr, _structuresCount)\r\n\r\n            let _writePointer := add(_castedArr, 0x20)\r\n            for { let _offsetIdx := 0 } lt(_offsetIdx, _structuresCount) { _offsetIdx := add(_offsetIdx, 1) } {\r\n                mstore(_writePointer, add(_arr, add(0x20, mul(_offsetIdx, _structLength))))\r\n                _writePointer := add(_writePointer, 0x20)\r\n            }\r\n        }\r\n    }\r\n\r\n    function cutCleanArrayFromRawInput(bytes memory _inputData, uint8 _dataStructureType)\r\n    internal\r\n    pure\r\n    returns (\r\n        bytes memory _packedData\r\n    ) {\r\n        uint _dataLength = _getRawLengthForDataStructure(_dataStructureType);\r\n        uint _structuresCount = _countRawInputStructures(_inputData, _dataStructureType);\r\n        _packedData = _allocMemoryBytesArray(_structuresCount, _dataLength);\r\n\r\n        bytes memory _offsetInputData;\r\n        uint _counter;\r\n        uint _pointerOffset;\r\n        while ((_pointerOffset < _inputData.length) && (_counter < _structuresCount)) {\r\n            uint8 header;\r\n            assembly {\r\n                let pointer := add(_inputData, add(_pointerOffset, 0x1))\r\n                header := and(mload(pointer), 0xff)\r\n                if eq(header, _dataStructureType) {\r\n                    _offsetInputData := add(pointer, 0x20)\r\n                }\r\n            }\r\n\r\n            if (header == _dataStructureType) {\r\n                _cutDataFromInput(_offsetInputData, _dataLength, _packedData, 0x20 + _counter * _dataLength);\r\n                _counter += 1;\r\n            }\r\n            _pointerOffset += _getRawLengthForDataStructure(header) + 1; // +1 for DATA_STRUCTURE_TYPE header byte\r\n        }\r\n    }\r\n\r\n    function unpackRawInputIntoMemoryArray(\r\n        bytes memory _inputData,\r\n        uint8 _dataStructureType,\r\n        function (bytes memory, bytes memory) internal pure _unpack\r\n    )\r\n    internal\r\n    pure\r\n    returns (\r\n        bytes memory _unpackedData\r\n    ) {\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(_dataStructureType);\r\n        uint _structCount = _countRawInputStructures(_inputData, _dataStructureType);\r\n        _unpackedData = _allocUnpackedMemoryBytesArray(_structCount, _fieldsNumber);\r\n\r\n        bytes memory _offsetInputData;\r\n        bytes memory _unpackDataPointer;\r\n        uint _pointerOffset;\r\n        uint _structCounter;\r\n        while ((_pointerOffset < _inputData.length) && (_structCounter < _structCount)) {\r\n            uint8 header;\r\n            assembly {\r\n                // read the first byte - DATA_STRUCTURE_TYPE\r\n                let pointer := add(_inputData, add(_pointerOffset, 0x1))\r\n                header := and(mload(pointer), 0xff)\r\n                if eq(header, _dataStructureType) {\r\n                    _offsetInputData := pointer\r\n                    _unpackDataPointer := add(_unpackedData, add(0x20, mul(mul(_structCounter, _fieldsNumber), 0x20)))\r\n                    _structCounter := add(_structCounter, 1)\r\n                }\r\n            }\r\n\r\n            if (header == _dataStructureType) {\r\n                _unpack(_offsetInputData, _unpackDataPointer);\r\n            }\r\n\r\n            _pointerOffset += _getRawLengthForDataStructure(header) + 1;\r\n        }\r\n    }\r\n\r\n    function unpackCleanArrayIntoMemoryArray(\r\n        bytes memory _inputData,\r\n        uint8 _dataStructureType,\r\n        function (bytes memory, bytes memory) internal pure _unpack\r\n    ) internal pure returns (bytes memory _unpackedData) {\r\n        uint _dataStructureLength = _getRawLengthForDataStructure(_dataStructureType);\r\n        require(_inputData.length % _dataStructureLength == 0, \"PARSER_INVALID_DATA_PADDING\");\r\n\r\n        bytes memory _offsetInputPointer;\r\n        bytes memory _offsetOutputPointer;\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(_dataStructureType);\r\n        uint _unpackedDataItemLength = _fieldsNumber * 32;\r\n\r\n        _unpackedData = _allocUnpackedMemoryBytesArray(_inputData.length / _dataStructureLength, _fieldsNumber);\r\n        assembly {\r\n            _offsetOutputPointer := add(_unpackedData, 0x20)\r\n        }\r\n        for (uint _inputOffset = 0; _inputOffset < _inputData.length; _inputOffset += _dataStructureLength) {\r\n            assembly {\r\n                _offsetInputPointer := add(_inputData, _inputOffset)\r\n            }\r\n\r\n            _unpack(_offsetInputPointer, _offsetOutputPointer);\r\n\r\n            assembly {\r\n                _offsetOutputPointer := add(_offsetOutputPointer, _unpackedDataItemLength)\r\n            }\r\n        }\r\n    }\r\n\r\n    function _unpackContractIntoMemory(bytes memory _inputData, bytes memory _unpackedData) private pure {\r\n        assembly {\r\n            mstore(_unpackedData, and(mload(add(_inputData, 0x1)), 0xff)) // 1 byte\r\n            mstore(add(_unpackedData, 0x20), and(mload(add(_inputData, 0x21)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_unpackedData, 0x40), and(mload(add(_inputData, 0x41)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_unpackedData, 0x60), and(mload(add(_inputData, 0x55)), 0xffffffffffffffffffffffffffffffffffffffff)) // 20 bytes\r\n            mstore(add(_unpackedData, 0x80), and(mload(add(_inputData, 0x69)), 0xffffffffffffffffffffffffffffffffffffffff)) // 20 bytes\r\n            mstore(add(_unpackedData, 0xa0), and(mload(add(_inputData, 0x7d)), 0xffffffffffffffffffffffffffffffffffffffff)) // 20 bytes\r\n            mstore(add(_unpackedData, 0xc0), and(mload(add(_inputData, 0x91)), 0xffffffffffffffffffffffffffffffffffffffff)) // 20 bytes\r\n            mstore(add(_unpackedData, 0xe0), and(mload(add(_inputData, 0xb1)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_unpackedData, 0x100), and(mload(add(_inputData, 0xd1)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_unpackedData, 0x120), and(mload(add(_inputData, 0xe5)), 0xffffffffffffffffffffffffffffffffffffffff)) // 20 bytes\r\n            mstore(add(_unpackedData, 0x140), and(mload(add(_inputData, 0xe6)), 0xff)) // 1 byte\r\n            mstore(add(_unpackedData, 0x160), and(mload(add(_inputData, 0xe7)), 0xff)) // 1 byte\r\n            mstore(add(_unpackedData, 0x180), and(mload(add(_inputData, 0xe8)), 0xff)) // 1 byte\r\n            mstore(add(_unpackedData, 0x1a0), and(mload(add(_inputData, 0xe9)), 0xff)) // 1 byte\r\n        }\r\n    }\r\n\r\n    function _unpackTaskIntoMemory(bytes memory _inputData, bytes memory _taskData) private pure {\r\n        assembly {\r\n            mstore(_taskData, and(mload(add(_inputData, 0x4)), 0xffffffff)) // 4 byte\r\n            mstore(add(_taskData, 0x20), and(mload(add(_inputData, 0x5)), 0xff)) // 1 byte\r\n            mstore(add(_taskData, 0x40), and(mload(add(_inputData, 0x6)), 0xff)) // 1 byte\r\n            mstore(add(_taskData, 0x60), and(mload(add(_inputData, 0x26)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_taskData, 0x80), and(mload(add(_inputData, 0x46)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_taskData, 0xa0), and(mload(add(_inputData, 0x66)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n        }\r\n    }\r\n\r\n    function _unpackTaskPenaltyIntoMemory(bytes memory _inputData, bytes memory _penaltyData) private pure {\r\n        assembly {\r\n            mstore(_penaltyData, and(mload(add(_inputData, 0x4)), 0xffffffff)) // 4 byte\r\n            mstore(add(_penaltyData, 0x20), and(mload(add(_inputData, 0x8)), 0xffffffff)) // 4 byte\r\n            mstore(add(_penaltyData, 0x40), and(mload(add(_inputData, 0x9)), 0xff)) // 1 byte\r\n            mstore(add(_penaltyData, 0x60), and(mload(add(_inputData, 0xa)), 0xff)) // 1 byte\r\n            mstore(add(_penaltyData, 0x80), and(mload(add(_inputData, 0x2a)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_penaltyData, 0xa0), and(mload(add(_inputData, 0x4a)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n        }\r\n    }\r\n\r\n    function _unpackTerminationIntoMemory(bytes memory _inputData, bytes memory _terminationData) private pure {\r\n        assembly {\r\n            mstore(_terminationData, and(mload(add(_inputData, 0x4)), 0xffffffff)) // 4 byte\r\n            mstore(add(_terminationData, 0x20), and(mload(add(_inputData, 0x5)), 0xff)) // 1 byte\r\n            mstore(add(_terminationData, 0x40), and(mload(add(_inputData, 0x6)), 0xff)) // 1 byte\r\n            mstore(add(_terminationData, 0x60), and(mload(add(_inputData, 0x26)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n            mstore(add(_terminationData, 0x80), and(mload(add(_inputData, 0x27)), 0xff)) // 1 byte\r\n            mstore(add(_terminationData, 0xa0), and(mload(add(_inputData, 0x47)), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) // 32 bytes\r\n        }\r\n    }\r\n\r\n    /** RAW INPUT PARSING */\r\n\r\n    function parseContractDataRawInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        ContractData memory _entity\r\n    ) {\r\n        bytes memory _data = unpackRawInputIntoMemoryArray(_inputData, 1, _unpackContractIntoMemory); // DATA_STRUCTURE_TYPE = CONTRACT\r\n\r\n        assembly {\r\n            _entity := add(_data, 0x20)\r\n        }\r\n    }\r\n\r\n    function parseTaskDataRawInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        TaskData[] memory _entities\r\n    ) {\r\n        bytes memory _data = unpackRawInputIntoMemoryArray(_inputData, 2, _unpackTaskIntoMemory); // DATA_STRUCTURE_TYPE = TASK\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(2);\r\n        bytes memory _structures = _castMemoryArrayToStructureArray(_data, _fieldsNumber);\r\n\r\n        assembly {\r\n            _entities := _structures\r\n        }\r\n    }\r\n\r\n    function parseTaskPenaltyDataRawInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        TaskPenaltyData[] memory _entities\r\n    ) {\r\n        bytes memory _data = unpackRawInputIntoMemoryArray(_inputData, 3, _unpackTaskPenaltyIntoMemory); // DATA_STRUCTURE_TYPE = PENALTY\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(3);\r\n        bytes memory _structures = _castMemoryArrayToStructureArray(_data, _fieldsNumber);\r\n\r\n        assembly {\r\n            _entities := _structures\r\n        }\r\n    }\r\n\r\n    function parseTerminationDataRawInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        TerminationData[] memory _entities\r\n    ) {\r\n        bytes memory _data = unpackRawInputIntoMemoryArray(_inputData, 4, _unpackTerminationIntoMemory); // DATA_STRUCTURE_TYPE = TERMINATION\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(4);\r\n        bytes memory _structures = _castMemoryArrayToStructureArray(_data, _fieldsNumber);\r\n\r\n        assembly {\r\n            _entities := _structures\r\n        }\r\n    }\r\n\r\n    /** CLEAN INPUT PARSING */\r\n\r\n    function parseContractDataCleanInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        ContractData memory _entity\r\n    ) {\r\n        bytes memory _data = unpackCleanArrayIntoMemoryArray(_inputData, 1, _unpackContractIntoMemory); // DATA_STRUCTURE_TYPE = CONTRACT\r\n\r\n        assembly {\r\n            _entity := add(_data, 0x20)\r\n        }\r\n    }\r\n\r\n    function parseTaskDataCleanInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        TaskData[] memory _entities\r\n    ) {\r\n        bytes memory _data = unpackCleanArrayIntoMemoryArray(_inputData, 2, _unpackTaskIntoMemory); // DATA_STRUCTURE_TYPE = TASK\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(2);\r\n        bytes memory _structures = _castMemoryArrayToStructureArray(_data, _fieldsNumber);\r\n\r\n        assembly {\r\n            _entities := _structures\r\n        }\r\n    }\r\n\r\n    function parseTaskPenaltyDataCleanInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        TaskPenaltyData[] memory _entities\r\n    ) {\r\n        bytes memory _data = unpackCleanArrayIntoMemoryArray(_inputData, 3, _unpackTaskPenaltyIntoMemory); // DATA_STRUCTURE_TYPE = PENALTY\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(3);\r\n        bytes memory _structures = _castMemoryArrayToStructureArray(_data, _fieldsNumber);\r\n\r\n        assembly {\r\n            _entities := _structures\r\n        }\r\n    }\r\n\r\n    function parseTerminationDataCleanInput(bytes memory _inputData)\r\n    internal\r\n    pure\r\n    returns (\r\n        TerminationData[] memory _entities\r\n    ) {\r\n        bytes memory _data = unpackCleanArrayIntoMemoryArray(_inputData, 4, _unpackTerminationIntoMemory); // DATA_STRUCTURE_TYPE = TERMINATION\r\n        uint _fieldsNumber = _getFieldsNumberForDataStructure(4);\r\n        bytes memory _structures = _castMemoryArrayToStructureArray(_data, _fieldsNumber);\r\n\r\n        assembly {\r\n            _entities := _structures\r\n        }\r\n    }\r\n\r\n    /** ASSERTIONS */\r\n\r\n    function assertContractData(ContractData memory _contract) internal view {\r\n        require(\r\n            _contract.contractType == uint8(ContractType.JOB) ||\r\n            _contract.contractType == uint8(ContractType.DISPUTE)\r\n        );\r\n        require(_contract.documentHash != bytes32(0));\r\n        require(_contract.employer != 0x0);\r\n        require(_contract.assignee != 0x0);\r\n        require(_contract.assignee != _contract.employer);\r\n        require(_contract.arbiter != _contract.assignee && _contract.arbiter != _contract.employer); // still allow _contract.arbiter to be 0x0\r\n        require(_contract.beginDate > block.timestamp);\r\n        require(_contract.paymentCurrencySymbol != bytes32(0)); // TODO: check if escrow supports this symbol\r\n        require(\r\n            _contract.paymentTimeline == uint8(PaymentTimeline.PAY_BY_TASK) ||\r\n            _contract.paymentTimeline == uint8(PaymentTimeline.PAY_BY_PROJECT)\r\n        );\r\n\r\n        if (_contract.contractType == 2) {\r\n            assertDisputeContractData(_contract);\r\n        }\r\n    }\r\n\r\n    function assertDisputeContractData(ContractData memory _contract) internal pure {\r\n        require(_contract.contractType == uint8(ContractType.DISPUTE));\r\n        require(_contract.linkedContractId != 0); // TODO: check linked contract for existance; check it is started, not under_dispute\r\n        require(_contract.participant != 0x0);\r\n        require(\r\n            _contract.participant != _contract.employer &&\r\n            _contract.participant != _contract.assignee &&\r\n            _contract.participant != _contract.arbiter\r\n        );\r\n    }\r\n\r\n    function assertDisputeContractWithLinkedContract(\r\n        ContractData memory _linkedContract,\r\n        ContractData memory _disputeContract\r\n    )\r\n    internal\r\n    pure\r\n    {\r\n        require(_disputeContract.arbiter == 0x0, \"PARSER_DISPUTE_SHOULD_NOT_PROVIDE_ARBITER\");\r\n        require(_linkedContract.arbiter == _disputeContract.assignee, \"PARSER_ARBITER_SHOULD_BE_ASSIGNEE_IN_DISPUTE\");\r\n        require(\r\n            _linkedContract.assignee == _disputeContract.employer ||\r\n            _linkedContract.assignee == _disputeContract.participant,\r\n            \"PARSER_ASSIGNEE_SHOULD_BE_EMPLOYER_OR_PARTICIPANT_IN_DISPUTE\"\r\n        );\r\n        require(\r\n            _linkedContract.employer == _disputeContract.employer ||\r\n            _linkedContract.employer == _disputeContract.participant,\r\n            \"PARSER_EMPLOYER_SHOULD_BE_EMPLOYER_OR_PARTICIPANT_IN_DISPUTE\"\r\n        );\r\n    }\r\n\r\n    function assertTaskPenalty(TaskPenaltyData memory _penalty) internal pure {\r\n        require(\r\n            _penalty.applicationType == uint8(PenaltyApplicationType.MISS_DEADLINE),/*  ||\r\n            _penalty.applicationType == uint8(DataParser.PenaltyApplicationType.LATE_PAYMENT) */\r\n            \"PARSER_PENALTY_INVALID_APPLICATION_TYPE\"\r\n        );\r\n    }\r\n\r\n    /** SEARCH */\r\n\r\n    function getTerminationResultValue(\r\n        TerminationData memory _terminationInfo,\r\n        uint _baseBudget,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint _fullTerminationAmount)\r\n    {\r\n        if (_terminationInfo.valueType == uint(PaymentValueType.CURRENCY)) {\r\n            _fullTerminationAmount = _terminationInfo.value;\r\n        } else if (_terminationInfo.valueType == uint(PaymentValueType.PERCENT)) {\r\n            require(_terminationInfo.value <= _precision, \"PARSER_INVALID_TERMINATION_PERCENT_VALUE\");\r\n            _fullTerminationAmount = PercentCalculator.getPercent(_baseBudget, _terminationInfo.value, _precision);\r\n        } else {\r\n            revert(\"PARSER_INVALID_TERMINATION_PAYMENT_VALUE_TYPE\");\r\n        }\r\n    }\r\n\r\n    function getTaskPenaltyResultValue(\r\n        TaskPenaltyData memory _penalty,\r\n        uint _baseBudget,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint _penaltyValue)\r\n    {\r\n        if (_penalty.valueType == uint(PaymentValueType.CURRENCY)) {\r\n            _penaltyValue = _penalty.value;\r\n        } else if (_penalty.valueType == uint(PaymentValueType.PERCENT)) {\r\n            require(_penalty.value <= _precision, \"PARSER_INVALID_TASK_PENALTY_PERCENT_VALUE\");\r\n            _penaltyValue = PercentCalculator.getPercent(_baseBudget, _penalty.value, _precision);\r\n        } else {\r\n            revert(\"PARSER_INVALID_TASK_PENALTY_PAYMENT_VALUE_TYPE\");\r\n        }\r\n    }\r\n\r\n    function getTaskUpfrontResultValue(\r\n        TaskData memory _task,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint _upfrontValue)\r\n    {\r\n        if (_task.upfrontValueType == uint(PaymentValueType.CURRENCY)) {\r\n            require(_task.upfrontValue <= _task.budget, \"PARSER_INVALID_TASK_UPFRONT_CURRENCY_VALUE\");\r\n            _upfrontValue = _task.upfrontValue;\r\n        } else if (_task.upfrontValueType == uint(PaymentValueType.PERCENT)) {\r\n            require(_task.upfrontValue <= _precision, \"PARSER_INVALID_TASK_UPFRONT_PERCENT_VALUE\");\r\n            _upfrontValue = PercentCalculator.getPercent(_task.budget, _task.upfrontValue, _precision);\r\n        } else {\r\n            revert(\"PARSER_INVALID_TASK_UPFRONT_PAYMENT_VALUE_TYPE\");\r\n        }\r\n    }\r\n\r\n    function getTerminationById(\r\n        uint _terminationId,\r\n        bytes memory _clearData\r\n    )\r\n    internal\r\n    pure\r\n    returns (TerminationData memory)\r\n    {\r\n        TerminationData[] memory _terminations = parseTerminationDataCleanInput(_clearData);\r\n\r\n        for (uint _idx = 0; _idx < _terminations.length; ++_idx) {\r\n            if (_terminations[_idx].id == _terminationId) {\r\n                return _terminations[_idx];\r\n            }\r\n        }\r\n    }\r\n\r\n    function getTerminationParty(ContractData memory _contractInfo, address _account) internal pure returns (TerminationParty) {\r\n        if (_account == _contractInfo.employer) {\r\n            return TerminationParty.TERMINATION_EMPLOYER;\r\n        } else if (_account == _contractInfo.assignee) {\r\n            return TerminationParty.TERMINATION_ASSIGNEE;\r\n        }\r\n\r\n        revert(\"PARSER_INVALID_INITIATOR_PARTY_ACCOUNT\");\r\n    }\r\n\r\n    function getOppositeTerminationParty(TerminationParty _terminationParty) internal pure returns (TerminationParty) {\r\n        if (_terminationParty == TerminationParty.TERMINATION_EMPLOYER) {\r\n            return TerminationParty.TERMINATION_ASSIGNEE;\r\n        } else if (_terminationParty == TerminationParty.TERMINATION_ASSIGNEE) {\r\n            return TerminationParty.TERMINATION_EMPLOYER;\r\n        }\r\n\r\n        revert(\"PARSER_UNHANDLED_INITIATOR_PARTY\");\r\n    }\r\n}\r\n\r\n// File: contracts/labor-contract/LaborContractCore.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LaborContractCore is\r\n    InitializableStorageAdapter,\r\n    FeeConstants\r\n{\r\n    StorageInterface.Bytes32AddressMapping internal escrowStorage;\r\n    StorageInterface.Bytes32AddressMapping internal workflowStorage;\r\n\r\n    /// @dev keccak(contractId, signer address) => boolean\r\n    StorageInterface.Bytes32BoolMapping internal signsStorage;\r\n    /// @dev keccak(contractId, signer address) => salt (from #sign)\r\n    StorageInterface.Bytes32UIntMapping internal signsSaltStorage;\r\n    /// @dev keccak(contractId, signer address) => signature (from #sign)\r\n    StorageInterface.BytesSequenceMapping internal signsSignatureStorage;\r\n    /// @dev contractId => set of salts\r\n    StorageInterface.UIntSetMapping internal signsInvalidatedSaltsStorage;\r\n\r\n    // StorageInterface.Bytes32Bytes32Mapping internal baseContractStorage;\r\n    // StorageInterface.Bytes32SetMapping internal linkedContractsStorage;\r\n\r\n    StorageInterface.Bytes32UInt8Mapping internal contractStateStorage;\r\n    StorageInterface.Bytes32Bytes32Mapping internal contractDocumentHashStorage;\r\n    StorageInterface.BytesSequenceMapping internal contractInfoStorage;\r\n    StorageInterface.BytesSequenceMapping internal terminationsStorage;\r\n\r\n    StorageInterface.BytesSequenceMapping internal proposedTasksStorage;\r\n    StorageInterface.Bytes32Bytes32Mapping internal proposedDocumentHashStorage;\r\n\r\n    /// @dev proposition to store ID of termination with the highest termination budget\r\n    /// contractId => max locked termination value\r\n    StorageInterface.Bytes32UIntMapping internal terminationLockedBalanceStorage;\r\n\r\n    /// @dev contractId => upfront balance\r\n    StorageInterface.Bytes32UIntMapping internal budgetUpfrontPaymentAmountStorage;\r\n    // StorageInterface.Bytes32UIntMapping internal totalLockBudgetAmountStorage;\r\n    StorageInterface.Bytes32UIntMapping internal totalBudgetAmountStorage;\r\n    /// @dev contractId => sum of total completed (of future) payments\r\n    StorageInterface.Bytes32UIntMapping internal completedPaymentsBalanceStorage;\r\n    /// @dev contractId => sum of total completed and transferred payments\r\n    StorageInterface.Bytes32UIntMapping internal transferredPaymentsBalanceStorage;\r\n\r\n    StorageInterface.Bytes32UIntMapping internal terminationRequestIdStorage;\r\n    StorageInterface.StringMapping internal terminationReasonStorage;\r\n\r\n    StorageInterface.Address internal terminatableStorage;\r\n    StorageInterface.Address internal disputableStorage;\r\n    StorageInterface.Address internal signableStorage;\r\n    StorageInterface.Address internal completableStorage;\r\n    StorageInterface.Address internal tasksProposableStorage;\r\n\r\n\r\n    function _initCore() internal {\r\n        escrowStorage.init(\"escrow\");\r\n        workflowStorage.init(\"workflow\");\r\n        signsStorage.init(\"signs\");\r\n        signsSaltStorage.init(\"signsSalt\");\r\n        signsSignatureStorage.init(\"signsSignature\");\r\n        signsInvalidatedSaltsStorage.init(\"signsInvalidatedSalts\");\r\n        // baseContractStorage.init(\"baseContract\");\r\n        // linkedContractsStorage.init(\"linkedContracts\");\r\n        contractStateStorage.init(\"contractState\");\r\n        contractDocumentHashStorage.init(\"contractDocumentHash\");\r\n        contractInfoStorage.init(\"contractInfo\");\r\n        terminationsStorage.init(\"terminations\");\r\n        proposedTasksStorage.init(\"proposedTasks\");\r\n        proposedDocumentHashStorage.init(\"proposedDocumentHash\");\r\n        terminationLockedBalanceStorage.init(\"terminationLockedBalance\");\r\n        budgetUpfrontPaymentAmountStorage.init(\"budgetUpfrontPaymentAmount\");\r\n        // totalLockBudgetAmountStorage.init(\"totalLockBudgetAmount\");\r\n        totalBudgetAmountStorage.init(\"totalBudgetAmount\");\r\n        terminationRequestIdStorage.init(\"terminationRequestId\");\r\n        terminationReasonStorage.init(\"terminationReason\");\r\n        completedPaymentsBalanceStorage.init(\"completedPaymentsBalance\");\r\n        transferredPaymentsBalanceStorage.init(\"transferredPaymentsBalance\");\r\n        terminatableStorage.init(\"terminatable\");\r\n        disputableStorage.init(\"disputable\");\r\n        signableStorage.init(\"signable\");\r\n        completableStorage.init(\"completable\");\r\n        tasksProposableStorage.init(\"tasksProposable\");\r\n    }\r\n}\r\n\r\n\r\ncontract LaborContractEventEmitter {\r\n\r\n    event ContractCreated(bytes32 indexed contractId, bytes32 documentHash);\r\n    event ContractSigned(bytes32 indexed contractId, bytes32 documentHash, address signer, uint expireAtBlock, uint salt);\r\n    event ContractSignRevoked(bytes32 indexed contractId, address signer);\r\n    event ContractStarted(bytes32 indexed contractId, uint _depositValue);\r\n    event ContractTasksProposed(bytes32 indexed contractId, bytes32 documentHash);\r\n    event ContractTasksAccepted(bytes32 indexed contractId, bytes32 documentHash);\r\n    event ContractDisputeResolved(bytes32 indexed contractId);\r\n    event ContractTerminationRequested(bytes32 indexed contractId, uint terminationId, address initiator, string comment);\r\n    event ContractTerminationRequestCancelled(bytes32 indexed contractId, uint terminationId);\r\n    event ContractTerminated(bytes32 indexed contractId, uint terminationId);\r\n    event ContractStateTransitioned(bytes32 indexed contractId, uint8 indexed previousState, uint8 indexed currentState);\r\n    event ContractOperationLogged(bytes32 indexed contractId, string indexed operationAction);\r\n    event ContractWithdrawOperationLogged(bytes32 indexed contractId, string indexed operationAction, uint depositValue, uint paymentAmount);\r\n}\r\n\r\n\r\ncontract LaborContractAbstract is\r\n    LaborContractCore,\r\n    LaborContractEventEmitter\r\n{\r\n    using SafeMath for uint;\r\n\r\n    enum State { NOT_INITIALIZED, CREATED, SIGNED, STARTED, TERMINATION_REQUESTED, TERMINATED, UNDER_DISPUTE, COMPLETED }\r\n\r\n    uint constant internal OK = 1;\r\n    uint constant internal TERMINATION_PERCENT_PRECISION = 10000;\r\n\r\n    modifier onlyInState(bytes32 _contractId, State _state) {\r\n        require(_getContractState(_contractId) == _state, \"C_S\");\r\n        _;\r\n    }\r\n\r\n    function getEscrow(bytes32 _contractId) public view returns (EscrowBaseInterface) {\r\n        return EscrowBaseInterface(store.get(escrowStorage, _contractId));\r\n    }\r\n\r\n    function getWorkflow(bytes32 _contractId) public view returns (WorkflowBase) {\r\n        return WorkflowBase(store.get(workflowStorage, _contractId));\r\n    }\r\n\r\n    function getServiceSurchargePercent(bytes32 _contractId) public view returns (uint _percent, uint _precision) {\r\n        (, _percent, _precision) = getEscrow(_contractId).getServiceFeeInfo();\r\n    }\r\n\r\n    function version() public pure returns (string);\r\n\r\n    /** INTERNAL */\r\n\r\n    function _setContractStateTo(bytes32 _contractId, State _newState) internal {\r\n        require(_newState != State.NOT_INITIALIZED, \"C_NI\");\r\n\r\n        State _currentState = _getContractState(_contractId);\r\n        if (_currentState == _newState) {\r\n            return;\r\n        }\r\n\r\n        store.set(contractStateStorage, _contractId, uint8(_newState));\r\n\r\n        emit ContractStateTransitioned(_contractId, uint8(_currentState), uint8(_newState));\r\n    }\r\n\r\n    function _getContractState(bytes32 _contractId) internal view returns (State) {\r\n        return State(store.get(contractStateStorage, _contractId));\r\n    }\r\n\r\n    function _getContractDocumentHash(\r\n        bytes32 _contractId,\r\n        DataParser.ContractData memory _contractInfo\r\n    )\r\n    internal\r\n    view\r\n    returns (bytes32 _documentHash)\r\n    {\r\n        _documentHash = store.get(contractDocumentHashStorage, _contractId);\r\n        if (_documentHash == bytes32(0)) {\r\n            _documentHash = _contractInfo.documentHash;\r\n        }\r\n    }\r\n\r\n    function _getContractInfoBytes(bytes32 _contractId) internal view returns (bytes memory _data) {\r\n        return store.get(contractInfoStorage, _contractId);\r\n    }\r\n\r\n    function _getTerminationsInfoBytes(bytes32 _contractId) internal view returns (bytes memory _data) {\r\n        return store.get(terminationsStorage, _contractId);\r\n    }\r\n\r\n    function _getContractAccumulatedPaymentAmount(bytes32 _contractId) internal view returns (uint) {\r\n        return store.get(completedPaymentsBalanceStorage, _contractId);\r\n    }\r\n\r\n    function _getContractTransferredPaymentAmount(bytes32 _contractId) internal view returns (uint) {\r\n        return store.get(transferredPaymentsBalanceStorage, _contractId);\r\n    }\r\n\r\n    function _getContractTotalBudgetAmount(bytes32 _contractId) internal view returns (uint) {\r\n        return store.get(totalBudgetAmountStorage, _contractId);\r\n    }\r\n\r\n    function _getContractLockedTerminationAmount(bytes32 _contractId) internal view returns (uint) {\r\n        return store.get(terminationLockedBalanceStorage, _contractId);\r\n    }\r\n\r\n    function _getLeftToPayAmount(bytes32 _contractId) internal view returns (uint) {\r\n        return _getContractAccumulatedPaymentAmount(_contractId).sub(_getContractTransferredPaymentAmount(_contractId));\r\n    }\r\n\r\n    function _incrementTransferredBalance(bytes32 _contractId, uint _value) internal {\r\n        store.set(transferredPaymentsBalanceStorage, _contractId, _getContractTransferredPaymentAmount(_contractId).add(_value));\r\n    }\r\n\r\n    function _decrementTransferredBalance(bytes32 _contractId, uint _value) internal {\r\n        store.set(transferredPaymentsBalanceStorage, _contractId, _getContractTransferredPaymentAmount(_contractId).sub(_value));\r\n    }\r\n\r\n    function _incrementLockedTerminationAmount(bytes32 _contractId, uint _value) internal {\r\n        store.set(terminationLockedBalanceStorage, _contractId, _getContractLockedTerminationAmount(_contractId).add(_value));\r\n\r\n    }\r\n\r\n    function _incrementUpfrontPaymentAmount(bytes32 _contractId, uint _value) internal {\r\n        if (_value > 0) {\r\n            uint _currentUpfrontPaymentAmount = store.get(budgetUpfrontPaymentAmountStorage, _contractId);\r\n            store.set(budgetUpfrontPaymentAmountStorage, _contractId, _currentUpfrontPaymentAmount.add(_value));\r\n        }\r\n    }\r\n\r\n    function _decrementLockedTerminationAmount(bytes32 _contractId, uint _value) internal {\r\n        store.set(terminationLockedBalanceStorage, _contractId, _getContractLockedTerminationAmount(_contractId).sub(_value));\r\n    }\r\n\r\n    function _incrementCompletedPaymentValue(bytes32 _contractId, uint _value) internal {\r\n        uint _completedPaymentsBalance = _getContractAccumulatedPaymentAmount(_contractId);\r\n        store.set(completedPaymentsBalanceStorage, _contractId, _completedPaymentsBalance.add(_value));\r\n    }\r\n\r\n    function _decrementCompletedPaymentValue(bytes32 _contractId, uint _value) internal {\r\n        uint _completedPaymentsBalance = _getContractAccumulatedPaymentAmount(_contractId);\r\n        store.set(completedPaymentsBalanceStorage, _contractId, _completedPaymentsBalance.sub(_value));\r\n    }\r\n}\r\n\r\n// File: contracts/labor-contract/LaborContractBase.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\ninterface LaborContractBaseInitializable {\r\n\r\n    function initLaborContract(\r\n        address _owner,\r\n        address _storage,\r\n        bytes32 _crate\r\n        ) external;\r\n\r\n    function setExtensionContracts(\r\n        address _signable,\r\n        address _terminatable,\r\n        address _disputable,\r\n        address _completable,\r\n        address _tasksProposable\r\n    ) external;\r\n}\r\n\r\n\r\ninterface LaborContractBaseGeneralizable {\r\n    function getPaymentRequirements(bytes32 _contractId) external view returns (bool _lockFullBudget, uint8 _paymentTimeline);\r\n    function getContractParties(bytes32 _contractId) external view returns (address _employer, address _assignee);\r\n    function getContractState(bytes32 _contractId) external view returns (uint8 _state);\r\n}\r\n\r\n\r\ninterface LaborContractBase {\r\n\r\n    /// @notice Registers contract by an assignee that was negotiated by both parties and now is ready\r\n    ///\t\tfor the next step - financial relationships. Then signs registered contract.\r\n    /// If job contract is taking place then `_signature` should be based on arbiter setting\r\n    ///     (see EscrowBaseInterface#setArbiter).\r\n    /// If dispute contract is taking place then `_expireAtBlock`, `_salt`, `_signature` should skipped.\r\n    /// @param _workflow workflow smart contract address that could be used for time tracking; workflow specific\r\n    /// @param _escrow escrow smart contract for locking contract budget\r\n    /// @param _data initialization data for a contract\r\n    /// @param _expireAtBlock signature's expiration block\r\n    /// @param _salt signature's unique identifier\r\n    /// @param _signature signature of signed data\r\n    /// @return result code of an operation\r\n    function createContractAndSign(\r\n        bytes32 _contractId,\r\n        EscrowBaseInterface _escrow,\r\n        WorkflowBase _workflow,\r\n        bytes _data,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n        ) external returns (uint);\r\n}\r\n\r\n\r\ninterface LaborContractBaseOperationable {\r\n\r\n    /// @notice Callback function that is supposed to be called from associated workflow.\r\n    ///     Should be called on key operations that do not require any payment during execution.\r\n    /// @param _contractId contract identifier\r\n    /// @param _operationCode code of performed operation\r\n    function onOperation(bytes32 _contractId, string _operationCode) external;\r\n\r\n    /// @notice Callback function that is supposed to be called from associated workflow.\r\n    ///     Should be called on payable operations, for example, task completion confirmation.\r\n    /// @param _contractId contract identifier\r\n    /// @param _operationCode code of performed operation\r\n    /// @param _depositValue value to deposit (if needed, should include surchange percent)\r\n    /// @param _value value to be withdrawn from escrow\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid\r\n    /// @param _salt random bytes to identify signed data\r\n    /// @param _signature signature provided by employer\r\n    function onWithdrawOperation(\r\n        bytes32 _contractId,\r\n        string _operationCode,\r\n        uint _depositValue,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n        ) external payable;\r\n}\r\n\r\n\r\ninterface LaborContractBaseSignable {\r\n\r\n    /// @notice Calculates how much is needed to start a contract.\r\n    /// @param _contractId contract identifier\r\n    function getLockingDepositBalance(bytes32 _contractId) external view returns (uint);\r\n\r\n    /// @dev Calculates how much is needed to start a contract.\r\n    /// @return\r\n    /// @return _values[0] tasks budget\r\n    /// @return _values[1] deposit fee amount\r\n    /// @return _values[2] locked termination amount\r\n    /// @return _values[3] initial (upfront) payment amount\r\n    /// @return _values[4] upfront withdraw fee amount\r\n    function getLockingContractDetails(bytes32 _contractId) external view returns (uint[] _values);\r\n\r\n    /// @notice Signs registered contract by an assignee. This operation precedes any other\r\n    ///     sign methods of other parties.\r\n    /// If job contract is taking place then `_signature` should be based on arbiter setting\r\n    ///     (see EscrowBaseInterface#setArbiter).\r\n    /// If dispute contract is taking place then `_expireAtBlock`, `_salt`, `_signature` should skipped.\r\n    /// @param _contractId contract identifier\r\n    /// @param _documentHash hash of a document on which parties have an agreement\r\n    /// @param _expireAtBlock signature's expiration block\r\n    /// @param _salt signature's unique identifier\r\n    /// @param _signature signature of signed data\r\n    /// @return result code of an operation\r\n    function sign(\r\n        bytes32 _contractId,\r\n        bytes32 _documentHash,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n    ) external returns (uint);\r\n\r\n    /// @notice Allows an assignee to revoke her sign when the contract `_contractId` has not started yet.\r\n    /// @return result code of an operation\r\n    function revokeSign(bytes32 _contractId) external returns (uint);\r\n\r\n    /// @notice Signs contract and deposits to it, so it becomes ready for work.\r\n    ///     Should be done as the latest sign among all signs because it locks currency\r\n    /// If job contract is taking place then `_signature` should be based on artibter setting\r\n    ///     (see EscrowBaseInterface#setArbiter).\r\n    /// If dispute contract is taking place then `_signature` should be based on initiating escrow dispute\r\n    ///     (see EscrowBaseInterface#initiateDispute).\r\n    /// @param _contractId contract identifier\r\n    /// @param _documentHash hash of a document on which parties have an agreement\r\n    /// @param _value amount of deposited currency\r\n    /// @param _expireAtBlock signature's expiration block (the same as it was in assignee's sign)\r\n    /// @param _salt signature's unique identifier (the same as it was in assignee's sign)\r\n    /// @param _signature signature of signed data (signed data should be the same as it was in assignee's sign)\r\n    /// @return result code of an operation\r\n    function signAndDeposit(\r\n        bytes32 _contractId,\r\n        bytes32 _documentHash,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n        ) external payable returns (uint);\r\n}\r\n\r\n\r\ninterface LaborContractBaseCompletable {\r\n\r\n    /// @notice Calculates how much is needed to complete a contract\r\n    ///     (in cases when payment is performed after all tasks and no escrow locked balance exists).\r\n    /// @param _contractId contract identifier\r\n    /// @return _depositValue how much should be deposited by employer to resolve contract completion\r\n    /// @return _employerPaybackValue how much an employer gets back\r\n    /// @return _assigneeResolveValue how much an assignee will be paid\r\n    function getCompletionContractDepositBalance(\r\n        bytes32 _contractId\r\n    )\r\n    external\r\n    view\r\n    returns (\r\n        uint _depositValue,\r\n        uint _employerPaybackValue,\r\n        uint _assigneeResolveValue\r\n    );\r\n\r\n    /// @dev Calculates how much is needed to complete a contract.\r\n    /// @return\r\n    /// @return _values[0] already completed and paid amount\r\n    /// @return _values[1] completed but not paid (means it will be paid eventually)\r\n    /// @return _values[2] unpaid (left) tasks budget amount (not completed)\r\n    /// @return _values[3] escrow current balance\r\n    /// @return _values[4] need to deposit amount\r\n    /// @return _values[5] deposit fee value\r\n    /// @return _values[6] returned amount to employer\r\n    /// @return _values[7] paid amount to assignee\r\n    /// @return _values[8] locked termination amount\r\n    /// @return _values[9] withdraw fee amount\r\n    function getCompletionContractDetails(bytes32 _contractId) external view returns (uint[] _values);\r\n\r\n    /// @notice Completes the contract and resolves debts for both parties.\r\n    ///     No actions with contract will be available after that.\r\n    ///     Signature should present data for releasing termination escrow to the assignee and\r\n    ///     termination remainder + budget escrow to the employer. Escrow balance should be empty\r\n    ///     after execution - escrow will be flushed after that.\r\n    ///     See EscrowBaseInterface#releaseNegotiatedPayment for more details.\r\n    /// @param _contractId contract identifier\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid\r\n    /// @param _salt random bytes to identify signed data\r\n    /// @param _signatures concatenated signatures produced by employer and assignee\r\n    /// @return result code of an operation\r\n    function completeContract(\r\n        bytes32 _contractId,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signatures\r\n        ) external payable returns (uint);\r\n}\r\n\r\n\r\ninterface LaborContractBaseTerminatable {\r\n\r\n    /// @notice Gets details about depositing amount that is required to initiate termination process.\r\n    /// @param _contractId contract identifier\r\n    /// @param _terminationId termination identifier\r\n    /// @return amount that is required to deposit by termination initiator\r\n    function getTerminationInitiateDepositDetails(bytes32 _contractId, uint _terminationId) external view returns (uint);\r\n\r\n    /// @notice Gets details about depositing amount that is required to cancel termination process.\r\n    /// @param _contractId contract identifier\r\n    /// @param _terminationId termination identifier\r\n    /// @return amount that is required to deposit by termination confirmator\r\n    function getTerminationCancelDepositDetails(bytes32 _contractId, uint _terminationId) external view returns (uint);\r\n\r\n    /// @notice Gets details about depositing amount that is required to confirm termination process.\r\n    /// @param _contractId contract identifier\r\n    /// @param _terminationId termination identifier\r\n    /// @return amount that is required to deposit by termination confirmator\r\n    function getTerminationConfirmDepositDetails(bytes32 _contractId, uint _terminationId) external view returns (uint);\r\n\r\n    /// @notice Calculates requested termination conditions for the contract `_contractId`.\r\n    /// @param _contractId contract identifier\r\n    /// @param _terminationId termination condition identifier\r\n    /// @return _employerValue amount that will return back to the employer\r\n    /// @return _assigneeValue amount that will go to the assignee\r\n    function getTerminationPaymentAmounts(\r\n        bytes32 _contractId,\r\n        uint _terminationId\r\n    )\r\n    external\r\n    view\r\n    returns (uint _employerValue, uint _assigneeValue);\r\n\r\n    /// @dev Calculates requested termination conditions for the contract `_contractId`.\r\n    /// @param _contractId contract identifier\r\n    /// @param _terminationId termination condition identifier\r\n    /// @return _values[0] termination amount\r\n    /// @return _values[1] employer's amount\r\n    /// @return _values[2] assignee's amount\r\n    /// @return _values[3] initiator type\r\n    /// @return _values[4] receiver type\r\n    /// @return _values[5] unspent upfront amount that would be returned to an employer\r\n    /// @return _values[6] need to deposit amount on termination initiation\r\n    /// @return _values[7] need to deposit amount on termination confirmation\r\n    /// @return _values[8] need to pay for tasks in case if they are competed but not paid\r\n    /// @return _values[9] withdraw assignee fee amount\r\n    function getTerminationContractDetails(bytes32 _contractId, uint _terminationId) external view returns (uint[] _values);\r\n\r\n    /// @notice Starts termination negotiations by any party (employer or assignee)\r\n    ///     Is not applicable for disputes.\r\n    /// @param _contractId contract identifier\r\n    /// @param _terminationId termination identifier; type of termination condition should\r\n    ///     be assosiated with the initiator\r\n    /// @param _value value to deposit, duplicated as a parameter to secure from unintended deposits\r\n    /// @param _comment additional comments about termination reason or other notes\r\n    /// @return result code of an operation\r\n    function initiateTermination(\r\n        bytes32 _contractId,\r\n        uint32 _terminationId,\r\n        uint _value,\r\n        string _comment\r\n        ) external payable returns (uint);\r\n\r\n    /// @notice Cancels termination request that has not confirmed yet.\r\n    ///     Should be called by the termination initiator\r\n    ///     Is not applicable for disputes.\r\n    /// @param _contractId contract identifier\r\n    /// @return result code of an operation\r\n    function cancelTerminationRequest(bytes32 _contractId) external returns (uint);\r\n\r\n    /// @notice Cancels termination request that has not confirmed yet.\r\n    ///     Should be called by the termination initiator.\r\n    ///     Is not applicable for disputes.\r\n    ///\r\n    ///     If a deposit was made during termination initiation stage and\r\n    ///     'getTerminationCancelDepositDetails()' returns non-zero result then the opposite\r\n    ///     party should sign that amount for withdrawal and pass to termination's\r\n    ///     initiator.\r\n    ///     When initiator is an assignee then an employer should sign a message for\r\n    ///     EscrowBaseInterface#releaseBuyerPayment method.\r\n    ///     When initiator is an employer then an assignee should sign a message for\r\n    ///     EscrowBaseInterface#sendSellerPayback method.\r\n    ///     Otherwise expireAtBlock, salt and signature should be skipped.\r\n    /// @param _contractId contract identifier\r\n    /// @param _expireAtBlock contract identifier\r\n    /// @param _salt contract identifier\r\n    /// @param _signature contract identifier\r\n    /// @return result code of an operation\r\n    function cancelTerminationRequestWithApproval(\r\n        bytes32 _contractId,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n        ) external returns (uint);\r\n\r\n    /// @notice Performs confirmation of requested termination and terminates contract.\r\n    ///     Is not applicable for disputes.\r\n    ///     Should be signed by both parties that means they are both aware and agreed on conditions.\r\n    ///     Signature should present data for releasing termination escrow to the assignee and\r\n    ///     termination remainder + budget escrow to the employer. Escrow balance should be empty\r\n    ///     after execution - escrow will be flushed after that.\r\n    ///     See EscrowBaseInterface#releaseNegotiatedPayment for more details.\r\n    /// @param _contractId contract identifier\r\n    /// @param _value value to deposit, duplicated as a parameter to secure from unintended withdrawals\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid. Should be the same for\r\n    ///     tasks payment and for negotiated payment.\r\n    /// @param _tasksSalt tasks random bytes to identify signed data\r\n    ///     Skip when no payment is required.\r\n    /// @param _tasksSignature signature of EscrowBaseInterface#releaseBuyerPayment message\r\n    ///     Skip when no payment is required.\r\n    /// @param _salt random bytes to identify signed data\r\n    /// @param _signatures concatenated signatures produced by employer and assignee\r\n    /// @return result code of an operation\r\n    function confirmTermination(\r\n        bytes32 _contractId,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _tasksSalt,\r\n        bytes _tasksSignature,\r\n        uint _salt,\r\n        bytes _signatures\r\n        ) external payable returns (uint);\r\n}\r\n\r\n\r\ninterface LaborContractBaseDisputable {\r\n\r\n    /// @notice Gets details about contract resolvement by an arbiter.\r\n    /// @param _contractId contract identifier\r\n    /// @param _assigneeValue value that will go to an assignee\r\n    /// @return _values[0] employer's amount\r\n    /// @return _values[1] withdraw fee amount (for assignee)\r\n    function getResolvingContractDetails(bytes32 _contractId, uint _assigneeValue) external view returns (uint[] _values);\r\n\r\n    /// @notice Resolves the dispute in contract (if such exists).\r\n    ///     Sends provided percent `_assigneePercent` to the underlying\r\n    ///     contract assignee, the remainder - to contract employer.\r\n    ///     No actions with contract will be available after that.\r\n    ///     Signature should present data for releasing full escrow balance and split\r\n    ///     it amont parties in a dispute. Escrow balance should be empty\r\n    ///     after execution - escrow will be flushed after that.\r\n    ///     See EscrowBaseInterface#releaseDisputedPayment for more details.\r\n    /// @param _contractId contract identifier\r\n    /// @param _assigneeValue part of the escrow balance that will go to the assignee\r\n    ///     of disputed contract\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid\r\n    /// @param _signature signature provided by dispute assignee (base contract's arbiter)\r\n    /// @return result code of an operation\r\n    function resolveContract(\r\n        bytes32 _contractId,\r\n        uint _assigneeValue,\r\n        uint _expireAtBlock,\r\n        bytes _signature\r\n        ) external returns (uint);\r\n}\r\n\r\n\r\ninterface LaborContractBaseTasksProposable {\r\n\r\n    /// @notice Gets details about proposed tasks for contract `_contractId`.\r\n    /// @param _contractId contract identifier\r\n    /// @return _values[0] proposed tasks budget\r\n    /// @return _values[1] amount needed to be deposited\r\n    /// @return _values[2] employer's fee amount included into deposit\r\n    /// @return _values[3] termination amount needed to be locked additionally\r\n    /// @return _values[4] upfront amount\r\n    /// @return _values[5] assignee's fee amount that will be taken fron upfront amount\r\n    function getContractProposedTasksDetails(bytes32 _contractId) external view returns (uint[] _values);\r\n\r\n    /// @notice Puts new tasks of a contract `_contractId` to an approval state for an employer.\r\n    ///     Should be called by an assignee.\r\n    /// @param _contractId contract identifier\r\n    /// @param _updatedDocumentHash document hash of the updated contract\r\n    /// @param _data tasks and task penalty that are going to be added\r\n    /// @return result code of an operation\r\n    function proposeTasks(\r\n        bytes32 _contractId,\r\n        bytes32 _updatedDocumentHash,\r\n        bytes _data\r\n        ) external returns (uint);\r\n\r\n    /// @notice Accepts proposed tasks for a contract `_contractId`\r\n    ///     and adds tasks to a contract's workflow.\r\n    ///     Should be called by an employer.\r\n    /// @param _contractId contract identifier\r\n    /// @param _updatedDocumentHash document hash of the updated contract\r\n    /// @param _value value to be deposited for provided tasks\r\n    /// @return result code of an operation\r\n    function acceptProposedTasksAndDeposit(\r\n        bytes32 _contractId,\r\n        bytes32 _updatedDocumentHash,\r\n        uint _value\r\n        ) external payable returns (uint);\r\n}\r\n\r\n// File: contracts/labor-contract/LaborLib.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n\r\nlibrary LaborLib {\r\n\r\n\tusing SafeMath for uint;\r\n\r\n\tfunction _calculateContractTermination(\r\n        DataParser.ContractData memory /* _contractInfo */,\r\n        DataParser.TerminationData memory _terminationInfo,\r\n        uint _totalBudget,\r\n        uint _escrowBalance,\r\n        uint _leftToTransferAmount,\r\n\t\tuint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (\r\n        uint _employerValue,\r\n        uint _assigneeValue\r\n    ) {\r\n        uint _fullTerminationAmount = DataParser.getTerminationResultValue(\r\n            _terminationInfo,\r\n            _totalBudget,\r\n            _precision\r\n        );\r\n\r\n        if (_terminationInfo.payToType == uint8(DataParser.TerminationParty.TERMINATION_ASSIGNEE)) {\r\n            _assigneeValue = _assigneeValue.add(_fullTerminationAmount);\r\n        } else if (_terminationInfo.payToType == uint8(DataParser.TerminationParty.TERMINATION_EMPLOYER)) {\r\n            _employerValue = _employerValue.add(_fullTerminationAmount);\r\n        } else {\r\n            revert(\"C_TPT\"); // Invalid Termination payTo\r\n        }\r\n\r\n        _assigneeValue = _assigneeValue.add(_leftToTransferAmount);\r\n\r\n        uint _reminder = _escrowBalance.sub(_fullTerminationAmount).sub(_leftToTransferAmount);\r\n        _employerValue = _employerValue.add(_reminder);\r\n\r\n        require(_escrowBalance >= _fullTerminationAmount.add(_leftToTransferAmount), \"C_TA\"); // Invalid Termination amount\r\n    }\r\n\r\n\tfunction _calculateContractInitiateTerminationExcessFare(\r\n        DataParser.ContractData memory _contractInfo,\r\n        DataParser.TerminationData memory _terminationInfo,\r\n        DataParser.TerminationParty _forParty,\r\n        uint _accumulatedBalance,\r\n        uint _escrowBalance,\r\n        uint _totalBudget,\r\n        uint _upfrontRefund,\r\n\t\tuint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (\r\n        uint _fare,\r\n        uint _fareToEscrow,\r\n        uint _terminationAmount\r\n    ) {\r\n        if (\r\n            uint8(_forParty) == _terminationInfo.initiatorType &&\r\n            _terminationInfo.initiatorType == uint8(DataParser.TerminationParty.TERMINATION_ASSIGNEE)\r\n        ) {\r\n            _terminationAmount = _calculateContractTerminationAssigneeRepay(_terminationInfo, _totalBudget, _precision);\r\n            _fare = _fare\r\n                .add(_upfrontRefund)\r\n                .add(_terminationAmount);\r\n            _fareToEscrow = _fare;\r\n            return;\r\n        }\r\n\r\n        if (\r\n            uint8(_forParty) == _terminationInfo.initiatorType &&\r\n            _terminationInfo.initiatorType == uint8(DataParser.TerminationParty.TERMINATION_EMPLOYER) &&\r\n            _contractInfo.paymentTimeline == uint8(DataParser.PaymentTimeline.PAY_BY_PROJECT)\r\n        ) {\r\n            _fare = _calculateExcessFareForProjectTimeline(_escrowBalance, _accumulatedBalance);\r\n            _fareToEscrow = _fare;\r\n        }\r\n    }\r\n\r\n\tfunction _calculateContractCancelTerminationExcessFare(\r\n        DataParser.ContractData memory /* _contractInfo */,\r\n        DataParser.TerminationData memory _terminationInfo,\r\n        DataParser.TerminationParty _forParty,\r\n        uint /* _accumulatedBalance */,\r\n        uint /* _escrowBalance */,\r\n        uint _totalBudget,\r\n        uint _upfrontRefund,\r\n\t\tuint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (\r\n        uint _fare,\r\n        uint _fareToEscrow,\r\n        uint _terminationAmount\r\n    ) {\r\n        if (\r\n            uint8(_forParty) == _terminationInfo.initiatorType &&\r\n            _terminationInfo.initiatorType == uint8(DataParser.TerminationParty.TERMINATION_ASSIGNEE)\r\n        ) {\r\n            _terminationAmount = _calculateContractTerminationAssigneeRepay(_terminationInfo, _totalBudget, _precision);\r\n            _fare = _fare\r\n                .add(_upfrontRefund)\r\n                .add(_terminationAmount);\r\n            _fareToEscrow = _fare;\r\n        }\r\n    }\r\n\r\n    function _calculateContractConfirmTerminationExcessFare(\r\n        DataParser.ContractData memory _contractInfo,\r\n        DataParser.TerminationData memory _terminationInfo,\r\n        DataParser.TerminationParty _forParty,\r\n        uint _accumulatedBalance,\r\n        uint _escrowBalance,\r\n        uint _totalBudget,\r\n        uint _upfrontRefund,\r\n\t\tuint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (\r\n        uint _fare,\r\n        uint _fareToEscrow,\r\n        uint _terminationAmount\r\n    ) {\r\n        // NOTE: means that confirmation is performed by an employer\r\n        if (\r\n            uint8(_forParty) != _terminationInfo.initiatorType &&\r\n            _terminationInfo.initiatorType == uint8(DataParser.TerminationParty.TERMINATION_ASSIGNEE) &&\r\n            _contractInfo.paymentTimeline == uint8(DataParser.PaymentTimeline.PAY_BY_PROJECT)\r\n        ) {\r\n            _fare = _calculateExcessFareForProjectTimeline(_escrowBalance, _accumulatedBalance);\r\n            _fareToEscrow = _fare;\r\n            return;\r\n        }\r\n\r\n        // NOTE: means that confirmation is performed by an assignee\r\n        if (\r\n            uint8(_forParty) != _terminationInfo.initiatorType &&\r\n            _terminationInfo.initiatorType == uint8(DataParser.TerminationParty.TERMINATION_EMPLOYER)\r\n        ) {\r\n            _terminationAmount = _calculateContractTerminationAssigneeRepay(_terminationInfo, _totalBudget, _precision);\r\n            _fare = _fare\r\n                .add(_upfrontRefund)\r\n                .add(_terminationAmount);\r\n            _fareToEscrow = _fare;\r\n        }\r\n    }\r\n\r\n    function _calculateExcessFareForProjectTimeline(\r\n        uint _escrowBalance,\r\n        uint _accumulatedBalance\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint _depositValue)\r\n    {\r\n        if (_accumulatedBalance > _escrowBalance) {\r\n            _depositValue = _accumulatedBalance.sub(_escrowBalance);\r\n        }\r\n    }\r\n\r\n    function _calculateContractTerminationAssigneeRepay(\r\n        DataParser.TerminationData memory _terminationInfo,\r\n        uint _totalBudget,\r\n\t\tuint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint)\r\n    {\r\n        if (_terminationInfo.payToType == uint8(DataParser.TerminationParty.TERMINATION_EMPLOYER)) {\r\n            uint _terminationValue = DataParser.getTerminationResultValue(\r\n                _terminationInfo,\r\n                _totalBudget,\r\n                _precision\r\n            );\r\n            return _terminationValue;\r\n        }\r\n    }\r\n\r\n\r\n    function _calculateContractCompletion(\r\n        DataParser.ContractData memory _contractInfo,\r\n        uint _escrowBalance,\r\n        uint _accumulatedBalance\r\n    )\r\n    internal\r\n    pure\r\n    returns (\r\n        uint _depositValue,\r\n        uint _employerValue,\r\n        uint _assigneeValue\r\n    ) {\r\n        if (_contractInfo.paymentTimeline == uint8(DataParser.PaymentTimeline.PAY_BY_TASK)) {\r\n            _employerValue = _escrowBalance;\r\n\r\n            assert(_escrowBalance == _employerValue.add(_assigneeValue));\r\n            return;\r\n        } else if (_contractInfo.paymentTimeline == uint8(DataParser.PaymentTimeline.PAY_BY_PROJECT)) {\r\n            if (_accumulatedBalance > _escrowBalance) {\r\n                _depositValue = _accumulatedBalance.sub(_escrowBalance);\r\n            }\r\n\r\n            if (_escrowBalance > _accumulatedBalance) {\r\n                _employerValue = _escrowBalance.sub(_accumulatedBalance);\r\n            }\r\n\r\n            _assigneeValue = _accumulatedBalance;\r\n\r\n            assert(_escrowBalance.add(_depositValue) == _employerValue.add(_assigneeValue));\r\n            return;\r\n        }\r\n\r\n        revert(\"C_PI\");\r\n    }\r\n\r\n\r\n    function _calculateContractSignDepositAmount(\r\n        DataParser.ContractData memory _contractInfo,\r\n        uint _totalBudget,\r\n        uint _upfrontAmount,\r\n        uint _terminationLockedAmount,\r\n        uint16 _feeValue,\r\n        uint _feePrecision\r\n    )\r\n    internal\r\n    pure\r\n    returns (\r\n        uint _requiredDepositAmount,\r\n        uint _initialTransferAmount,\r\n        uint _serviceFee\r\n    ) {\r\n        uint _totalBudgetFee = PercentCalculator.getPercent(_totalBudget, _feeValue, _feePrecision);\r\n        _serviceFee = _serviceFee.add(_totalBudgetFee);\r\n\r\n        _initialTransferAmount = _initialTransferAmount.add(_upfrontAmount);\r\n        _requiredDepositAmount = _requiredDepositAmount.add(_terminationLockedAmount);\r\n\r\n        if (_contractInfo.lockFullBudget) {\r\n            _requiredDepositAmount = _requiredDepositAmount.add(_totalBudget);\r\n        }\r\n        else {\r\n            _requiredDepositAmount = _requiredDepositAmount.add(_initialTransferAmount);\r\n        }\r\n\r\n        _requiredDepositAmount = _requiredDepositAmount.add(_serviceFee);\r\n\r\n        assert(_requiredDepositAmount.sub(_serviceFee) >= _initialTransferAmount);\r\n    }\r\n\r\n    function _findMaxTerminationValue(\r\n        DataParser.TerminationData[] memory _terminations,\r\n        uint _totalBudget,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint _maxTerminationAmount)\r\n    {\r\n        for (uint _terminationIndex = 0; _terminationIndex < _terminations.length; ++_terminationIndex) {\r\n            DataParser.TerminationData memory _termination = _terminations[_terminationIndex];\r\n            if (_termination.payToType != uint8(DataParser.TerminationParty.TERMINATION_ASSIGNEE)) {\r\n                continue;\r\n            }\r\n\r\n            uint _fullTerminationAmount = DataParser.getTerminationResultValue(_termination, _totalBudget, _precision);\r\n\r\n            if (_maxTerminationAmount < _fullTerminationAmount) {\r\n                _maxTerminationAmount = _fullTerminationAmount;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/labor-contract/LaborContractTasksProposable.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LaborContractTasksProposable is\r\n    LaborContractBaseTasksProposable,\r\n    InitializableOwned,\r\n    LaborContractAbstract\r\n{\r\n\r\n    uint constant internal CONTRACT_PROPOSABLE_TASKS_DETAILS_AMOUNT = 0;\r\n    uint constant internal CONTRACT_PROPOSABLE_TASKS_DETAILS_DEPOSIT_AMOUNT = 1;\r\n    uint constant internal CONTRACT_PROPOSABLE_TASKS_DETAILS_DEPOSIT_FEE_AMOUNT = 2;\r\n    uint constant internal CONTRACT_PROPOSABLE_TASKS_DETAILS_TERMINATION_PART_AMOUNT = 3;\r\n    uint constant internal CONTRACT_PROPOSABLE_TASKS_DETAILS_UPFRONT_AMOUNT = 4;\r\n    uint constant internal CONTRACT_PROPOSABLE_TASKS_DETAILS_WITHDRAW_FEE_AMOUNT = 5;\r\n    uint constant internal CONTRACT_PROPOSABLE_TASKS_DETAILS_LENGTH = 6;\r\n\r\n    modifier onlyWithProposedTasks(bytes32 _contractId) {\r\n        require(store.get(proposedDocumentHashStorage, _contractId) != bytes32(0), \"C_TNP\"); // C_TNP == tasks are not proposed\r\n        _;\r\n    }\r\n\r\n    constructor() StorageAdapter(Storage(0x0), \"\") public {\r\n        // NOTE: don't need to initialize anything\r\n    }\r\n\r\n    function version() public pure returns (string) {\r\n        return \"0.1.0\";\r\n    }\r\n\r\n    function getContractProposedTasksDetails(bytes32 _contractId) external view returns (uint[] _values) {\r\n        _values = new uint[](CONTRACT_PROPOSABLE_TASKS_DETAILS_LENGTH);\r\n        DataParser.ContractData memory _contractInfo = DataParser.parseContractDataCleanInput(_getContractInfoBytes(_contractId));\r\n        (uint _proposedTasksBudget, uint _upfrontAmount, uint _totalBudget) = _getPrecalculatedTasksBudgetForProposedTasks(_contractId);\r\n        (\r\n            uint _depositAmount,\r\n            uint _initialTransferAmount,\r\n            uint _serviceFee,\r\n            uint _lockTerminationAmount\r\n        ) = _getProposedTasksAcceptanceAmount(\r\n            _contractId,\r\n            _contractInfo,\r\n            _totalBudget,\r\n            _proposedTasksBudget,\r\n            _upfrontAmount\r\n        );\r\n\r\n        _values[CONTRACT_PROPOSABLE_TASKS_DETAILS_AMOUNT] = _proposedTasksBudget;\r\n        _values[CONTRACT_PROPOSABLE_TASKS_DETAILS_DEPOSIT_AMOUNT] = _depositAmount;\r\n        _values[CONTRACT_PROPOSABLE_TASKS_DETAILS_DEPOSIT_FEE_AMOUNT] = _serviceFee;\r\n        _values[CONTRACT_PROPOSABLE_TASKS_DETAILS_TERMINATION_PART_AMOUNT] = _lockTerminationAmount;\r\n        _values[CONTRACT_PROPOSABLE_TASKS_DETAILS_UPFRONT_AMOUNT] = _initialTransferAmount;\r\n\r\n        EscrowBaseInterface _escrow = getEscrow(_contractId);\r\n        (, uint16 _feeValue, uint _feePrecision) = _escrow.getServiceFeeInfo();\r\n\r\n        _values[CONTRACT_PROPOSABLE_TASKS_DETAILS_WITHDRAW_FEE_AMOUNT] = PercentCalculator.getPercent(\r\n            _values[CONTRACT_PROPOSABLE_TASKS_DETAILS_UPFRONT_AMOUNT],\r\n            _feeValue,\r\n            _feePrecision\r\n        );\r\n    }\r\n\r\n    function _getPrecalculatedTasksBudgetForProposedTasks(bytes32 _contractId) private view returns (\r\n        uint _proposedTasksBudget,\r\n        uint _upfrontAmount,\r\n        uint _totalBudget\r\n    ) {\r\n        bytes memory _data = store.get(proposedTasksStorage, _contractId);\r\n        (_proposedTasksBudget, _upfrontAmount) = getWorkflow(_contractId).precalculateWorkflowData(_contractId, address(this), _data);\r\n        _totalBudget = _getContractTotalBudgetAmount(_contractId).add(_proposedTasksBudget);\r\n    }\r\n\r\n    function proposeTasks(\r\n        bytes32 _contractId,\r\n        bytes32 _updatedDocumentHash,\r\n        bytes _data\r\n        )\r\n    external\r\n    onlyInState(_contractId, State.STARTED)\r\n    returns (uint)\r\n    {\r\n        require(_updatedDocumentHash != bytes32(0), \"C_IV\"); // C_IV == invalid value\r\n\r\n        DataParser.ContractData memory _contractInfo = DataParser.parseContractDataCleanInput(_getContractInfoBytes(_contractId));\r\n        require(_contractInfo.allowDynamicTasks, \"C_ADT\"); // C_ADT == dynamic tasks should be allowed\r\n        require(msg.sender == _contractInfo.assignee, \"C_IC\"); // C_IC == invalid caller\r\n        require(_getContractDocumentHash(_contractId, _contractInfo) != _updatedDocumentHash, \"C_H\"); // C_H == invalid updated document hash\r\n        _validateContractProposedTasks(_contractId, _data);\r\n\r\n        store.set(proposedTasksStorage, _contractId, _data);\r\n        store.set(proposedDocumentHashStorage, _contractId, _updatedDocumentHash);\r\n\r\n        emit ContractTasksProposed(_contractId, _updatedDocumentHash);\r\n        return OK;\r\n    }\r\n\r\n    function acceptProposedTasksAndDeposit(\r\n        bytes32 _contractId,\r\n        bytes32 _updatedDocumentHash,\r\n        uint _value\r\n    )\r\n    external\r\n    payable\r\n    onlyInState(_contractId, State.STARTED)\r\n    onlyWithProposedTasks(_contractId)\r\n    returns (uint)\r\n    {\r\n        require(store.get(proposedDocumentHashStorage, _contractId) == _updatedDocumentHash, \"C_H\"); // C_H == invalid updated document hash\r\n\r\n        DataParser.ContractData memory _contractInfo = DataParser.parseContractDataCleanInput(_getContractInfoBytes(_contractId));\r\n        require(msg.sender == _contractInfo.employer, \"C_IC\"); // C_IC == invalid caller\r\n\r\n        bytes memory _data = store.get(proposedTasksStorage, _contractId);\r\n        (uint _tasksBudget, uint _upfrontAmount) = getWorkflow(_contractId).addWorkflowData(_contractId, address(this), _data);\r\n        require(_tasksBudget > 0, \"C_B\"); // C_B == invalid tasks budget\r\n\r\n        _incrementTotalContractBudget(_contractId, _tasksBudget);\r\n        _incrementUpfrontPaymentAmount(_contractId, _upfrontAmount);\r\n        _handleTasksPropositionToEscrow(_contractId, _contractInfo, _tasksBudget, _upfrontAmount, _value);\r\n\r\n        store.set(contractDocumentHashStorage, _contractId, _updatedDocumentHash);\r\n        store.set(proposedDocumentHashStorage, _contractId, bytes32(0));\r\n        store.set(proposedTasksStorage, _contractId, new bytes(0));\r\n\r\n        emit ContractTasksAccepted(_contractId, _updatedDocumentHash);\r\n        return OK;\r\n    }\r\n\r\n    /** PRIVATE */\r\n\r\n    function _incrementTotalContractBudget(bytes32 _contractId, uint _value) private {\r\n        uint _currentBudget = _getContractTotalBudgetAmount(_contractId);\r\n        store.set(totalBudgetAmountStorage, _contractId, _currentBudget.add(_value));\r\n    }\r\n\r\n    function _handleTasksPropositionToEscrow(\r\n        bytes32 _contractId,\r\n        DataParser.ContractData memory _contractInfo,\r\n        uint _proposedTasksBudget,\r\n        uint _upfrontAmount,\r\n        uint _inValue\r\n    )\r\n    private\r\n    {\r\n        (\r\n            uint _requiredDepositAmount,\r\n            uint _initialTransferAmount,\r\n            uint _serviceFee,\r\n            uint _lockTerminationAmount\r\n        ) = _getProposedTasksAcceptanceAmount(\r\n            _contractId,\r\n            _contractInfo,\r\n            _getContractTotalBudgetAmount(_contractId),\r\n            _proposedTasksBudget,\r\n            _upfrontAmount\r\n        );\r\n        require(_requiredDepositAmount == _inValue, \"C_A\"); // C_A == invalid amount provided\r\n\r\n        _proceedDepositToEscrow(\r\n            _contractId,\r\n            _contractInfo,\r\n            _requiredDepositAmount,\r\n            _initialTransferAmount,\r\n            _lockTerminationAmount,\r\n            _serviceFee\r\n        );\r\n    }\r\n\r\n    function _proceedDepositToEscrow(\r\n        bytes32 _contractId,\r\n        DataParser.ContractData memory _contractInfo,\r\n        uint _value,\r\n        uint _initialTransferAmount,\r\n        uint _additionalLockTerminationAmount,\r\n        uint _serviceFee\r\n    )\r\n    private\r\n    {\r\n        uint _depositAmount = _value.sub(_additionalLockTerminationAmount).sub(_serviceFee);\r\n        EscrowBaseInterface _escrow = getEscrow(_contractId);\r\n\r\n        /**\r\n            1. For contract budget we take fee only from upfront value\r\n            for a reason that fee is taken from full budget but a deposited value\r\n            could differ from that value.\r\n         */\r\n        require(\r\n            OK == _escrow.deposit.value(SafeMath.min(_depositAmount, msg.value))\r\n            (\r\n                _contractId,\r\n                _contractInfo.employer,\r\n                _contractInfo.assignee,\r\n                _depositAmount,\r\n                _initialTransferAmount,\r\n                _getBuyerFeeFlag()\r\n            ),\r\n            \"C_DE\" // C_DE == invalid escrow deposit operation\r\n        );\r\n\r\n        _incrementCompletedPaymentValue(_contractId, _initialTransferAmount);\r\n        _incrementTransferredBalance(_contractId, _initialTransferAmount);\r\n\r\n        /**\r\n            2. For termination budget we take no deposit fee according to specification\r\n         */\r\n        if (_additionalLockTerminationAmount > 0) {\r\n            require(\r\n                OK == _escrow.deposit.value(SafeMath.min(_additionalLockTerminationAmount, msg.value))\r\n                (\r\n                    _contractId,\r\n                    _contractInfo.employer,\r\n                    _contractInfo.assignee,\r\n                    _additionalLockTerminationAmount,\r\n                    0,\r\n                    _getNoFeeFlag()\r\n                ),\r\n                \"C_DE\" // C_DE == invalid escrow deposit operation\r\n            );\r\n            _incrementLockedTerminationAmount(_contractId, _additionalLockTerminationAmount);\r\n        }\r\n\r\n        /**\r\n            3. Transfer service fee directly to fee recepient\r\n         */\r\n        require(\r\n            OK == _escrow.retranslateToFeeRecipient.value(SafeMath.min(_serviceFee, msg.value))\r\n            (\r\n                _contractInfo.paymentCurrencySymbol,\r\n                _contractInfo.employer,\r\n                _serviceFee\r\n            ),\r\n            \"C_FE\" // C_FE == invalid fee escrow retranslation\r\n        );\r\n    }\r\n\r\n    function _validateContractProposedTasks(\r\n        bytes32 _contractId,\r\n        bytes _data\r\n    )\r\n    private\r\n    view\r\n    {\r\n         (uint _tasksBudget,) = getWorkflow(_contractId).precalculateWorkflowData(_contractId, address(this), _data);\r\n        require(_tasksBudget > 0, \"C_B\"); // C_B == invalid tasks budget\r\n    }\r\n\r\n\r\n    /** PRIVATE GETTERS */\r\n\r\n    function _getProposedTasksAcceptanceAmount(\r\n        bytes32 _contractId,\r\n        DataParser.ContractData memory _contractInfo,\r\n        uint _totalBudget,\r\n        uint _proposedTasksBudget,\r\n        uint _upfrontAmount\r\n    )\r\n    private\r\n    view\r\n    returns (\r\n        uint _requiredDepositAmount,\r\n        uint _initialTransferAmount,\r\n        uint _serviceFee,\r\n        uint _lockTerminationAmount\r\n    ) {\r\n        DataParser.TerminationData[] memory _terminations = DataParser.parseTerminationDataCleanInput(_getTerminationsInfoBytes(_contractId));\r\n        uint _lockedTerminationAmount = _getContractLockedTerminationAmount(_contractId);\r\n\r\n        return _calculateProposedTasksAcceptanceAmount(\r\n            _contractId,\r\n            _contractInfo,\r\n            _terminations,\r\n            _totalBudget,\r\n            _lockedTerminationAmount,\r\n            _proposedTasksBudget,\r\n            _upfrontAmount\r\n        );\r\n    }\r\n\r\n    function _calculateProposedTasksAcceptanceAmount(\r\n        bytes32 _contractId,\r\n        DataParser.ContractData memory _contractInfo,\r\n        DataParser.TerminationData[] memory _terminations,\r\n        uint _totalBudget,\r\n        uint _terminationLockedAmount,\r\n        uint _proposedTasksBudget,\r\n        uint _upfrontAmount\r\n    )\r\n    private\r\n    view\r\n    returns (\r\n        uint _requiredDepositAmount,\r\n        uint _initialTransferAmount,\r\n        uint _serviceFee,\r\n        uint _lockTerminationAmount\r\n\r\n    ) {\r\n        uint _updatedMaxTerminationAmount = LaborLib._findMaxTerminationValue(_terminations, _totalBudget, TERMINATION_PERCENT_PRECISION);\r\n        _lockTerminationAmount = _updatedMaxTerminationAmount.sub(_terminationLockedAmount);\r\n\r\n        EscrowBaseInterface _escrow = getEscrow(_contractId);\r\n        (, uint16 _feeValue, uint _feePrecision) = _escrow.getServiceFeeInfo();\r\n\r\n        (_requiredDepositAmount, _initialTransferAmount, _serviceFee) = LaborLib._calculateContractSignDepositAmount(\r\n            _contractInfo,\r\n            _proposedTasksBudget,\r\n            _upfrontAmount,\r\n            _lockTerminationAmount,\r\n            _feeValue,\r\n            _feePrecision\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"getContractProposedTasksDetails\",\"outputs\":[{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"getServiceSurchargePercent\",\"outputs\":[{\"name\":\"_percent\",\"type\":\"uint256\"},{\"name\":\"_precision\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_updatedDocumentHash\",\"type\":\"bytes32\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"proposeTasks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"getWorkflow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"getEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"name\":\"_updatedDocumentHash\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"acceptProposedTasksAndDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"ContractCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"documentHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"expireAtBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"ContractSigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"ContractSignRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_depositValue\",\"type\":\"uint256\"}],\"name\":\"ContractStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"ContractTasksProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"ContractTasksAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"}],\"name\":\"ContractDisputeResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"terminationId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"comment\",\"type\":\"string\"}],\"name\":\"ContractTerminationRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"terminationId\",\"type\":\"uint256\"}],\"name\":\"ContractTerminationRequestCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"terminationId\",\"type\":\"uint256\"}],\"name\":\"ContractTerminated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"previousState\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"currentState\",\"type\":\"uint8\"}],\"name\":\"ContractStateTransitioned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operationAction\",\"type\":\"string\"}],\"name\":\"ContractOperationLogged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operationAction\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"depositValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"paymentAmount\",\"type\":\"uint256\"}],\"name\":\"ContractWithdrawOperationLogged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"LaborContractTasksProposable","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://1a3f2b1859b6b18b0ed370e59c8a92a7bef27c95626ee00b233e5f6c9da26cb3"}]}