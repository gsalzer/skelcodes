{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.6.0;\r\n\r\ninterface IRelay {\r\n\r\n    /// @notice Transfer NMR on behalf of a Numerai user\r\n    ///         Can only be called by Manager or Owner\r\n    /// @dev Can only be used on the first 1 million ethereum addresses\r\n    /// @param _from The user address\r\n    /// @param _to The recipient address\r\n    /// @param _value The amount of NMR in wei\r\n    function withdraw(address _from, address _to, uint256 _value) external returns (bool ok);\r\n\r\n    /// @notice Burn the NMR sent to address 0 and burn address\r\n    function burnZeroAddress() external;\r\n\r\n    /// @notice Permanantly disable the relay contract\r\n    ///         Can only be called by Owner\r\n    function disable() external;\r\n\r\n    /// @notice Permanantly disable token upgradability\r\n    ///         Can only be called by Owner\r\n    function disableTokenUpgradability() external;\r\n\r\n    /// @notice Upgrade the token delegate logic.\r\n    ///         Can only be called by Owner\r\n    /// @param _newDelegate Address of the new delegate contract\r\n    function changeTokenDelegate(address _newDelegate) external;\r\n\r\n    /// @notice Upgrade the token delegate logic using the UpgradeDelegate\r\n    ///         Can only be called by Owner\r\n    /// @dev must be called after UpgradeDelegate is set as the token delegate\r\n    /// @param _multisig Address of the multisig wallet address to receive NMR and ETH\r\n    /// @param _delegateV3 Address of NumeraireDelegateV3\r\n    function executeUpgradeDelegate(address _multisig, address _delegateV3) external;\r\n\r\n    /// @notice Burn stakes during initialization phase\r\n    ///         Can only be called by Manager or Owner\r\n    /// @dev must be called after UpgradeDelegate is set as the token delegate\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @param staker The address of the user\r\n    /// @param tag The UTF8 character string used to identify the submission\r\n    function destroyStake(uint256 tournamentID, uint256 roundID, address staker, bytes32 tag) external;\r\n\r\n}\r\n\r\n\r\ninterface INMR {\r\n\r\n    /* ERC20 Interface */\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /* NMR Special Interface */\r\n\r\n    // used for user balance management\r\n    function withdraw(address _from, address _to, uint256 _value) external returns(bool ok);\r\n\r\n    // used for migrating active stakes\r\n    function destroyStake(address _staker, bytes32 _tag, uint256 _tournamentID, uint256 _roundID) external returns (bool ok);\r\n\r\n    // used for disabling token upgradability\r\n    function createRound(uint256, uint256, uint256, uint256) external returns (bool ok);\r\n\r\n    // used for upgrading the token delegate logic\r\n    function createTournament(uint256 _newDelegate) external returns (bool ok);\r\n\r\n    // used like burn(uint256)\r\n    function mint(uint256 _value) external returns (bool ok);\r\n\r\n    // used like burnFrom(address, uint256)\r\n    function numeraiTransfer(address _to, uint256 _value) external returns (bool ok);\r\n\r\n    // used to check if upgrade completed\r\n    function contractUpgradable() external view returns (bool);\r\n\r\n    function getTournament(uint256 _tournamentID) external view returns (uint256, uint256[] memory);\r\n\r\n    function getRound(uint256 _tournamentID, uint256 _roundID) external view returns (uint256, uint256, uint256);\r\n\r\n    function getStake(uint256 _tournamentID, uint256 _roundID, address _staker, bytes32 _tag) external view returns (uint256, uint256, bool, bool);\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool wasInitializing = initializing;\r\n    initializing = true;\r\n    initialized = true;\r\n\r\n    _;\r\n\r\n    initializing = wasInitializing;\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable is Initializable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function initialize(address sender) public initializer {\r\n        _owner = sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n\r\ncontract Manageable is Initializable, Ownable {\r\n    address private _manager;\r\n\r\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\r\n\r\n    /**\r\n     * @dev The Managable constructor sets the original `manager` of the contract to the sender\r\n     * account.\r\n     */\r\n    function initialize(address sender) initializer public {\r\n        Ownable.initialize(sender);\r\n        _manager = sender;\r\n        emit ManagementTransferred(address(0), _manager);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the manager.\r\n     */\r\n    function manager() public view returns (address) {\r\n        return _manager;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner or manager.\r\n     */\r\n    modifier onlyManagerOrOwner() {\r\n        require(isManagerOrOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner or manager of the contract.\r\n     */\r\n    function isManagerOrOwner() public view returns (bool) {\r\n        return (msg.sender == _manager || isOwner());\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newManager.\r\n     * @param newManager The address to transfer management to.\r\n     */\r\n    function transferManagement(address newManager) public onlyOwner {\r\n        require(newManager != address(0));\r\n        emit ManagementTransferred(_manager, newManager);\r\n        _manager = newManager;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n *      Modified from openzeppelin Pausable to simplify access control.\r\n */\r\ncontract Pausable is Initializable, Manageable {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /// @notice Initializer function called at time of deployment\r\n    /// @param sender The address of the wallet to handle permission control\r\n    function initialize(address sender) public initializer {\r\n        Manageable.initialize(sender);\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyManagerOrOwner whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyManagerOrOwner whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Numerai Tournament logic contract version 2\r\ncontract NumeraiTournamentV2 is Initializable, Pausable {\r\n\r\n    uint256 public totalStaked;\r\n\r\n    mapping (uint256 => Tournament) public tournaments;\r\n\r\n    struct Tournament {\r\n        uint256 creationTime;\r\n        uint256[] roundIDs;\r\n        mapping (uint256 => Round) rounds;\r\n    }\r\n\r\n    struct Round {\r\n        uint128 creationTime;\r\n        uint128 stakeDeadline;\r\n        mapping (address => mapping (bytes32 => Stake)) stakes;\r\n    }\r\n\r\n    struct Stake {\r\n        uint128 amount;\r\n        uint32 confidence;\r\n        uint128 burnAmount;\r\n        bool resolved;\r\n    }\r\n\r\n    /* /////////////////// */\r\n    /* Do not modify above */\r\n    /* /////////////////// */\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint128;\r\n\r\n    event Staked(\r\n        uint256 indexed tournamentID,\r\n        uint256 indexed roundID,\r\n        address indexed staker,\r\n        bytes32 tag,\r\n        uint256 stakeAmount,\r\n        uint256 confidence\r\n    );\r\n    event StakeResolved(\r\n        uint256 indexed tournamentID,\r\n        uint256 indexed roundID,\r\n        address indexed staker,\r\n        bytes32 tag,\r\n        uint256 originalStake,\r\n        uint256 burnAmount\r\n    );\r\n    event RoundCreated(\r\n        uint256 indexed tournamentID,\r\n        uint256 indexed roundID,\r\n        uint256 stakeDeadline\r\n    );\r\n    event TournamentCreated(\r\n        uint256 indexed tournamentID\r\n    );\r\n\r\n    // set the address of the NMR token as a constant (stored in runtime code)\r\n    address private constant _TOKEN = address(\r\n        0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671\r\n    );\r\n\r\n    // set the address of the relay as a constant (stored in runtime code)\r\n    address private constant _RELAY = address(\r\n        0xB17dF4a656505570aD994D023F632D48De04eDF2\r\n    );\r\n\r\n    /// @dev Throws if the roundID given is not greater than the latest one\r\n    modifier onlyNewRounds(uint256 tournamentID, uint256 roundID) {\r\n        uint256 length = tournaments[tournamentID].roundIDs.length;\r\n        if (length > 0) {\r\n            uint256 lastRoundID = tournaments[tournamentID].roundIDs[length - 1];\r\n            require(roundID > lastRoundID, \"roundID must be increasing\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev Throws if the uint256 input is bigger than the max uint128\r\n    modifier onlyUint128(uint256 a) {\r\n        require(\r\n            a < 0x100000000000000000000000000000000,\r\n            \"Input uint256 cannot be larger than uint128\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @notice constructor function, used to enforce implementation address\r\n    constructor() public {\r\n        require(\r\n            address(this) == address(0x4a0E8E6E323E45f8f63De2389407BF6670B8E716),\r\n            \"incorrect deployment address - check submitting account & nonce.\"\r\n        );\r\n    }\r\n\r\n    /////////////////////////////\r\n    // Fund Recovery Functions //\r\n    /////////////////////////////\r\n\r\n    /// @notice Recover the ETH sent to this contract address\r\n    ///         Can only be called by Numerai\r\n    /// @param recipient The address of the recipient\r\n    function recoverETH(address payable recipient) public onlyOwner {\r\n        recipient.transfer(address(this).balance);\r\n    }\r\n\r\n    /// @notice Recover the NMR sent to this address\r\n    ///         Can only be called by Numerai\r\n    /// @param recipient The address of the recipient\r\n    function recoverNMR(address payable recipient) public onlyOwner {\r\n        uint256 balance = INMR(_TOKEN).balanceOf(address(this));\r\n        uint256 amount = balance.sub(totalStaked);\r\n        require(INMR(_TOKEN).transfer(recipient, amount));\r\n    }\r\n\r\n    ///////////////////////\r\n    // Batched Functions //\r\n    ///////////////////////\r\n\r\n    /// @notice A batched version of stakeOnBehalf()\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @param staker The address of the user\r\n    /// @param tag The UTF8 character string used to identify the submission\r\n    /// @param stakeAmount The amount of NMR in wei to stake with this submission\r\n    /// @param confidence The confidence threshold to submit with this submission\r\n    function batchStakeOnBehalf(\r\n        uint256[] calldata tournamentID,\r\n        uint256[] calldata roundID,\r\n        address[] calldata staker,\r\n        bytes32[] calldata tag,\r\n        uint256[] calldata stakeAmount,\r\n        uint256[] calldata confidence\r\n    ) external {\r\n        uint256 len = tournamentID.length;\r\n        require(\r\n            roundID.length == len &&\r\n            staker.length == len &&\r\n            tag.length == len &&\r\n            stakeAmount.length == len &&\r\n            confidence.length == len,\r\n            \"Inputs must be same length\"\r\n        );\r\n        for (uint i = 0; i < len; i++) {\r\n            stakeOnBehalf(tournamentID[i], roundID[i], staker[i], tag[i], stakeAmount[i], confidence[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice A batched version of withdraw()\r\n    /// @param from The user address\r\n    /// @param to The recipient address\r\n    /// @param value The amount of NMR in wei\r\n    function batchWithdraw(\r\n        address[] calldata from,\r\n        address[] calldata to,\r\n        uint256[] calldata value\r\n    ) external {\r\n        uint256 len = from.length;\r\n        require(\r\n            to.length == len &&\r\n            value.length == len,\r\n            \"Inputs must be same length\"\r\n        );\r\n        for (uint i = 0; i < len; i++) {\r\n            withdraw(from[i], to[i], value[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice A batched version of resolveStake()\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @param staker The address of the user\r\n    /// @param tag The UTF8 character string used to identify the submission\r\n    /// @param burnAmount The amount of NMR in wei to burn from the stake\r\n    function batchResolveStake(\r\n        uint256[] calldata tournamentID,\r\n        uint256[] calldata roundID,\r\n        address[] calldata staker,\r\n        bytes32[] calldata tag,\r\n        uint256[] calldata burnAmount\r\n    ) external {\r\n        uint256 len = tournamentID.length;\r\n        require(\r\n            roundID.length == len &&\r\n            staker.length == len &&\r\n            tag.length == len &&\r\n            burnAmount.length == len,\r\n            \"Inputs must be same length\"\r\n        );\r\n        for (uint i = 0; i < len; i++) {\r\n            resolveStake(tournamentID[i], roundID[i], staker[i], tag[i], burnAmount[i]);\r\n        }\r\n    }\r\n\r\n    //////////////////////////////\r\n    // Special Access Functions //\r\n    //////////////////////////////\r\n\r\n    /// @notice Stake a round submission on behalf of a Numerai user\r\n    ///         Can only be called by Numerai\r\n    ///         Calling this function multiple times will increment the stake\r\n    /// @dev Calls withdraw() on the NMR token contract through the relay contract.\r\n    ///      Can only be used on the first 1 million ethereum addresses.\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @param staker The address of the user\r\n    /// @param tag The UTF8 character string used to identify the submission\r\n    /// @param stakeAmount The amount of NMR in wei to stake with this submission\r\n    /// @param confidence The confidence threshold to submit with this submission\r\n    function stakeOnBehalf(\r\n        uint256 tournamentID,\r\n        uint256 roundID,\r\n        address staker,\r\n        bytes32 tag,\r\n        uint256 stakeAmount,\r\n        uint256 confidence\r\n    ) public onlyManagerOrOwner whenNotPaused {\r\n        _stake(tournamentID, roundID, staker, tag, stakeAmount, confidence);\r\n        IRelay(_RELAY).withdraw(staker, address(this), stakeAmount);\r\n    }\r\n\r\n    /// @notice Transfer NMR on behalf of a Numerai user\r\n    ///         Can only be called by Numerai\r\n    /// @dev Calls the NMR token contract through the relay contract\r\n    ///      Can only be used on the first 1 million ethereum addresses.\r\n    /// @param from The user address\r\n    /// @param to The recipient address\r\n    /// @param value The amount of NMR in wei\r\n    function withdraw(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) public onlyManagerOrOwner whenNotPaused {\r\n        IRelay(_RELAY).withdraw(from, to, value);\r\n    }\r\n\r\n    ////////////////////\r\n    // User Functions //\r\n    ////////////////////\r\n\r\n    /// @notice Stake a round submission on your own behalf\r\n    ///         Can be called by anyone\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @param tag The UTF8 character string used to identify the submission\r\n    /// @param stakeAmount The amount of NMR in wei to stake with this submission\r\n    /// @param confidence The confidence threshold to submit with this submission\r\n    function stake(\r\n        uint256 tournamentID,\r\n        uint256 roundID,\r\n        bytes32 tag,\r\n        uint256 stakeAmount,\r\n        uint256 confidence\r\n    ) public whenNotPaused {\r\n        _stake(tournamentID, roundID, msg.sender, tag, stakeAmount, confidence);\r\n        require(INMR(_TOKEN).transferFrom(msg.sender, address(this), stakeAmount),\r\n            \"Stake was not successfully transfered\");\r\n    }\r\n\r\n    /////////////////////////////////////\r\n    // Tournament Management Functions //\r\n    /////////////////////////////////////\r\n\r\n    /// @notice Resolve a staked submission after the round is completed\r\n    ///         The portion of the stake which is not burned is returned to the user.\r\n    ///         Can only be called by Numerai\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @param staker The address of the user\r\n    /// @param tag The UTF8 character string used to identify the submission\r\n    /// @param burnAmount The amount of NMR in wei to burn from the stake\r\n    function resolveStake(\r\n        uint256 tournamentID,\r\n        uint256 roundID,\r\n        address staker,\r\n        bytes32 tag,\r\n        uint256 burnAmount\r\n    )\r\n    public\r\n    onlyManagerOrOwner\r\n    whenNotPaused\r\n    onlyUint128(burnAmount)\r\n    {\r\n        Stake storage stakeObj = tournaments[tournamentID].rounds[roundID].stakes[staker][tag];\r\n        uint128 originalStakeAmount = stakeObj.amount;\r\n        if (burnAmount >= 0x100000000000000000000000000000000)\r\n            burnAmount = originalStakeAmount;\r\n        uint128 releaseAmount = uint128(originalStakeAmount.sub(burnAmount));\r\n\r\n        assert(originalStakeAmount == releaseAmount + burnAmount);\r\n        require(originalStakeAmount > 0, \"The stake must exist\");\r\n        require(!stakeObj.resolved, \"The stake must not already be resolved\");\r\n        require(\r\n            uint256(\r\n                tournaments[tournamentID].rounds[roundID].stakeDeadline\r\n            ) < block.timestamp,\r\n            \"Cannot resolve before stake deadline\"\r\n        );\r\n\r\n        stakeObj.amount = 0;\r\n        stakeObj.burnAmount = uint128(burnAmount);\r\n        stakeObj.resolved = true;\r\n\r\n        require(\r\n            INMR(_TOKEN).transfer(staker, releaseAmount),\r\n            \"Stake was not succesfully released\"\r\n        );\r\n        _burn(burnAmount);\r\n\r\n        totalStaked = totalStaked.sub(originalStakeAmount);\r\n\r\n        emit StakeResolved(tournamentID, roundID, staker, tag, originalStakeAmount, burnAmount);\r\n    }\r\n\r\n    /// @notice Initialize a new tournament\r\n    ///         Can only be called by Numerai\r\n    /// @param tournamentID The index of the tournament\r\n    function createTournament(uint256 tournamentID) public onlyManagerOrOwner {\r\n\r\n        Tournament storage tournament = tournaments[tournamentID];\r\n\r\n        require(\r\n            tournament.creationTime == 0,\r\n            \"Tournament must not already be initialized\"\r\n        );\r\n\r\n        uint256 oldCreationTime;\r\n        (oldCreationTime,) = getTournamentV1(tournamentID);\r\n        require(\r\n            oldCreationTime == 0,\r\n            \"This tournament must not be initialized in V1\"\r\n        );\r\n\r\n        tournament.creationTime = block.timestamp;\r\n\r\n        emit TournamentCreated(tournamentID);\r\n    }\r\n\r\n    /// @notice Initialize a new round\r\n    ///         Can only be called by Numerai\r\n    /// @dev The new roundID must be > the last roundID used on the previous tournament version\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @param stakeDeadline The UNIX timestamp deadline for users to stake their submissions\r\n    function createRound(\r\n        uint256 tournamentID,\r\n        uint256 roundID,\r\n        uint256 stakeDeadline\r\n    )\r\n    public\r\n    onlyManagerOrOwner\r\n    onlyNewRounds(tournamentID, roundID)\r\n    onlyUint128(stakeDeadline)\r\n    {\r\n        Tournament storage tournament = tournaments[tournamentID];\r\n        Round storage round = tournament.rounds[roundID];\r\n\r\n        require(tournament.creationTime > 0, \"This tournament must be initialized\");\r\n        require(round.creationTime == 0, \"This round must not be initialized\");\r\n\r\n        tournament.roundIDs.push(roundID);\r\n        round.creationTime = uint128(block.timestamp);\r\n        round.stakeDeadline = uint128(stakeDeadline);\r\n\r\n        emit RoundCreated(tournamentID, roundID, stakeDeadline);\r\n    }\r\n\r\n    //////////////////////\r\n    // Getter Functions //\r\n    //////////////////////\r\n\r\n    /// @notice Get the state of a tournament in this version\r\n    /// @param tournamentID The index of the tournament\r\n    /// @return creationTime The UNIX timestamp of the tournament creation\r\n    /// @return roundIDs The array of index of the tournament rounds\r\n    function getTournamentV2(uint256 tournamentID) public view returns (\r\n        uint256 creationTime,\r\n        uint256[] memory roundIDs\r\n    ) {\r\n        Tournament storage tournament = tournaments[tournamentID];\r\n        return (tournament.creationTime, tournament.roundIDs);\r\n    }\r\n\r\n    /// @notice Get the state of a round in this version\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @return creationTime The UNIX timestamp of the round creation\r\n    /// @return stakeDeadline The UNIX timestamp of the round deadline for staked submissions\r\n    function getRoundV2(uint256 tournamentID, uint256 roundID) public view returns (\r\n        uint256 creationTime,\r\n        uint256 stakeDeadline\r\n    ) {\r\n        Round storage round = tournaments[tournamentID].rounds[roundID];\r\n        return (uint256(round.creationTime), uint256(round.stakeDeadline));\r\n    }\r\n\r\n    /// @notice Get the state of a staked submission in this version\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @param staker The address of the user\r\n    /// @param tag The UTF8 character string used to identify the submission\r\n    /// @return amount The amount of NMR in wei staked with this submission\r\n    /// @return confidence The confidence threshold attached to this submission\r\n    /// @return burnAmount The amount of NMR in wei burned by the resolution\r\n    /// @return resolved True if the staked submission has been resolved\r\n    function getStakeV2(uint256 tournamentID, uint256 roundID, address staker, bytes32 tag) public view returns (\r\n        uint256 amount,\r\n        uint256 confidence,\r\n        uint256 burnAmount,\r\n        bool resolved\r\n    ) {\r\n        Stake storage stakeObj = tournaments[tournamentID].rounds[roundID].stakes[staker][tag];\r\n        return (stakeObj.amount, stakeObj.confidence, stakeObj.burnAmount, stakeObj.resolved);\r\n    }\r\n\r\n    /// @notice Get the state of a tournament in this version\r\n    /// @param tournamentID The index of the tournament\r\n    /// @return creationTime The UNIX timestamp of the tournament creation\r\n    /// @return roundIDs The array of index of the tournament rounds\r\n    function getTournamentV1(uint256 tournamentID) public view returns (\r\n        uint256 creationTime,\r\n        uint256[] memory roundIDs\r\n    ) {\r\n        return INMR(_TOKEN).getTournament(tournamentID);\r\n    }\r\n\r\n    /// @notice Get the state of a round in this version\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @return creationTime The UNIX timestamp of the round creation\r\n    /// @return endTime The UNIX timestamp of the round deadline for staked submissions\r\n    /// @return resolutionTime The UNIX timestamp of the round start time for resolutions\r\n    function getRoundV1(uint256 tournamentID, uint256 roundID) public view returns (\r\n        uint256 creationTime,\r\n        uint256 endTime,\r\n        uint256 resolutionTime\r\n    ) {\r\n        return INMR(_TOKEN).getRound(tournamentID, roundID);\r\n    }\r\n\r\n    /// @notice Get the state of a staked submission in this version\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @param staker The address of the user\r\n    /// @param tag The UTF8 character string used to identify the submission\r\n    /// @return confidence The confidence threshold attached to this submission\r\n    /// @return amount The amount of NMR in wei staked with this submission\r\n    /// @return successful True if the staked submission beat the threshold\r\n    /// @return resolved True if the staked submission has been resolved\r\n    function getStakeV1(uint256 tournamentID, uint256 roundID, address staker, bytes32 tag) public view returns (\r\n        uint256 confidence,\r\n        uint256 amount,\r\n        bool successful,\r\n        bool resolved\r\n    ) {\r\n        return INMR(_TOKEN).getStake(tournamentID, roundID, staker, tag);\r\n    }\r\n\r\n    /// @notice Get the address of the relay contract\r\n    /// @return The address of the relay contract\r\n    function relay() external pure returns (address) {\r\n        return _RELAY;\r\n    }\r\n\r\n    /// @notice Get the address of the NMR token contract\r\n    /// @return The address of the NMR token contract\r\n    function token() external pure returns (address) {\r\n        return _TOKEN;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal Functions //\r\n    ////////////////////////\r\n\r\n    /// @dev Internal function to handle stake logic\r\n    ///      stakeAmount must fit in a uint128\r\n    ///      confidence must fit in a uint32\r\n    /// @param tournamentID The index of the tournament\r\n    /// @param roundID The index of the tournament round\r\n    /// @param tag The UTF8 character string used to identify the submission\r\n    /// @param stakeAmount The amount of NMR in wei to stake with this submission\r\n    /// @param confidence The confidence threshold to submit with this submission\r\n    function _stake(\r\n        uint256 tournamentID,\r\n        uint256 roundID,\r\n        address staker,\r\n        bytes32 tag,\r\n        uint256 stakeAmount,\r\n        uint256 confidence\r\n    ) internal onlyUint128(stakeAmount) {\r\n        Tournament storage tournament = tournaments[tournamentID];\r\n        Round storage round = tournament.rounds[roundID];\r\n        Stake storage stakeObj = round.stakes[staker][tag];\r\n\r\n        uint128 currentStake = stakeObj.amount;\r\n        uint32 currentConfidence = stakeObj.confidence;\r\n\r\n        require(tournament.creationTime > 0, \"This tournament must be initialized\");\r\n        require(round.creationTime > 0, \"This round must be initialized\");\r\n        require(\r\n            uint256(round.stakeDeadline) > block.timestamp,\r\n            \"Cannot stake after stake deadline\"\r\n        );\r\n        require(stakeAmount > 0 || currentStake > 0, \"Cannot stake zero NMR\");\r\n        require(confidence <= 1000000000, \"Confidence is capped at 9 decimal places\");\r\n        require(currentConfidence <= confidence, \"Confidence can only be increased\");\r\n\r\n        stakeObj.amount = uint128(currentStake.add(stakeAmount));\r\n        stakeObj.confidence = uint32(confidence);\r\n\r\n        totalStaked = totalStaked.add(stakeAmount);\r\n\r\n        emit Staked(tournamentID, roundID, staker, tag, stakeObj.amount, confidence);\r\n    }\r\n\r\n    /// @notice Internal helper function to burn NMR\r\n    /// @dev If before the token upgrade, sends the tokens to address 0\r\n    ///      If after the token upgrade, calls the repurposed mint function to burn\r\n    /// @param _value The amount of NMR in wei\r\n    function _burn(uint256 _value) internal {\r\n        if (INMR(_TOKEN).contractUpgradable()) {\r\n            require(INMR(_TOKEN).transfer(address(0), _value));\r\n        } else {\r\n            require(INMR(_TOKEN).mint(_value), \"burn not successful\");\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256[]\"},{\"name\":\"roundID\",\"type\":\"uint256[]\"},{\"name\":\"staker\",\"type\":\"address[]\"},{\"name\":\"tag\",\"type\":\"bytes32[]\"},{\"name\":\"stakeAmount\",\"type\":\"uint256[]\"},{\"name\":\"confidence\",\"type\":\"uint256[]\"}],\"name\":\"batchStakeOnBehalf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"recoverETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256[]\"},{\"name\":\"roundID\",\"type\":\"uint256[]\"},{\"name\":\"staker\",\"type\":\"address[]\"},{\"name\":\"tag\",\"type\":\"bytes32[]\"},{\"name\":\"burnAmount\",\"type\":\"uint256[]\"}],\"name\":\"batchResolveStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"name\":\"roundID\",\"type\":\"uint256\"},{\"name\":\"stakeDeadline\",\"type\":\"uint256\"}],\"name\":\"createRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"name\":\"roundID\",\"type\":\"uint256\"},{\"name\":\"tag\",\"type\":\"bytes32\"},{\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"name\":\"confidence\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"getRoundV1\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"resolutionTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"}],\"name\":\"getTournamentV1\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"roundIDs\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"name\":\"roundID\",\"type\":\"uint256\"},{\"name\":\"staker\",\"type\":\"address\"},{\"name\":\"tag\",\"type\":\"bytes32\"}],\"name\":\"getStakeV2\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"confidence\",\"type\":\"uint256\"},{\"name\":\"burnAmount\",\"type\":\"uint256\"},{\"name\":\"resolved\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address[]\"},{\"name\":\"to\",\"type\":\"address[]\"},{\"name\":\"value\",\"type\":\"uint256[]\"}],\"name\":\"batchWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"getRoundV2\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"stakeDeadline\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isManagerOrOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tournaments\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"name\":\"roundID\",\"type\":\"uint256\"},{\"name\":\"staker\",\"type\":\"address\"},{\"name\":\"tag\",\"type\":\"bytes32\"}],\"name\":\"getStakeV1\",\"outputs\":[{\"name\":\"confidence\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"successful\",\"type\":\"bool\"},{\"name\":\"resolved\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relay\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"}],\"name\":\"getTournamentV2\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"roundIDs\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"name\":\"roundID\",\"type\":\"uint256\"},{\"name\":\"staker\",\"type\":\"address\"},{\"name\":\"tag\",\"type\":\"bytes32\"},{\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"resolveStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"}],\"name\":\"createTournament\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"recoverNMR\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"transferManagement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"name\":\"roundID\",\"type\":\"uint256\"},{\"name\":\"staker\",\"type\":\"address\"},{\"name\":\"tag\",\"type\":\"bytes32\"},{\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"name\":\"confidence\",\"type\":\"uint256\"}],\"name\":\"stakeOnBehalf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tag\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"confidence\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tag\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"originalStake\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"name\":\"StakeResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tournamentID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakeDeadline\",\"type\":\"uint256\"}],\"name\":\"RoundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tournamentID\",\"type\":\"uint256\"}],\"name\":\"TournamentCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"NumeraiTournamentV2","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"65535","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://fdb15b6deb23c2ea7cb3dc28951f540a3c73b413863085a691763349bf14d42e"}]}