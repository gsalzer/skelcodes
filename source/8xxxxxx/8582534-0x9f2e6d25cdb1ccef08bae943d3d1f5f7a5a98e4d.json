{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/Groups.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\nlibrary Groups {\r\n    struct MemberMap {\r\n        mapping(address => bool) members;\r\n    }\r\n\r\n    struct GroupMap {\r\n        mapping(uint8 => MemberMap) groups;\r\n    }\r\n\r\n    /**\r\n     * @dev Add an account to a group\r\n     */\r\n    function add(GroupMap storage map, uint8 groupId, address account) internal {\r\n        MemberMap storage group = map.groups[groupId];\r\n        require(account != address(0));\r\n        require(!groupContains(group, account));\r\n\r\n        group.members[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account from a group\r\n     */\r\n    function remove(GroupMap storage map, uint8 groupId, address account) internal {\r\n        MemberMap storage group = map.groups[groupId];\r\n        require(account != address(0));\r\n        require(groupContains(group, account));\r\n\r\n        group.members[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the account is in the group\r\n     * @return bool\r\n     */\r\n    function contains(GroupMap storage map, uint8 groupId, address account) internal view returns (bool) {\r\n        MemberMap storage group = map.groups[groupId];\r\n        return groupContains(group, account);\r\n    }\r\n\r\n    function groupContains(MemberMap storage group, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return group.members[account];\r\n    }\r\n}\r\n\r\n// File: contracts/erc/ERC165.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n// File: contracts/erc/ERC165Map.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract ERC165Map is ERC165 {\r\n    bytes4 private constant INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n    constructor() public {\r\n        supportedInterfaces[INTERFACE_ID_ERC165] = true;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    function _addInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff);\r\n        supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: contracts/erc/ERC721.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface ERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n// File: contracts/erc/ERC721Metadata.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n// File: contracts/erc/ERC721TokenReceiver.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns (bytes4);\r\n}\r\n\r\n// File: contracts/erc/ERC721Enumerable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/Qri.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Qri is ERC165Map, ERC721, ERC721Metadata, ERC721Enumerable {\r\n    using Groups for Groups.GroupMap;\r\n    using SafeMath for uint256;\r\n\r\n    uint8 public constant ADMIN = 1;\r\n\r\n    bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n    bytes4 private constant INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n    bytes4 private constant INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\r\n\r\n    string private tokenName;\r\n    string private tokenSymbol;\r\n\r\n    bool public unrestrictedMinting;\r\n\r\n    Groups.GroupMap groups;\r\n\r\n    address public tokenOwner;\r\n\r\n    uint256[] private allTokens;\r\n    mapping(uint256 => uint256) private tokenIndex;\r\n    mapping(uint256 => address) private owners;\r\n    mapping(address => uint256[]) private ownedTokens;\r\n    mapping(uint256 => uint256) private ownedTokensIndex;\r\n    mapping(uint256 => address) private approval;\r\n    mapping(address => uint256) private tokenCount;\r\n    mapping(address => mapping(address => bool)) private operatorApproval;\r\n    mapping(uint256 => string) private uri;\r\n\r\n    event AddedToGroup(uint8 indexed groupId, address indexed account);\r\n    event RemovedFromGroup(uint8 indexed groupId, address indexed account);\r\n\r\n    constructor(string _name, string _symbol) public {\r\n        _addInterface(INTERFACE_ID_ERC721);\r\n        _addInterface(INTERFACE_ID_ERC721_METADATA);\r\n        _addInterface(INTERFACE_ID_ERC721_ENUMERABLE);\r\n\r\n        tokenName = _name;\r\n        tokenSymbol = _symbol;\r\n\r\n        _addAdmin(msg.sender);\r\n        tokenOwner = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(isAdmin(msg.sender), \"Must be an admin\");\r\n        _;\r\n    }\r\n\r\n    function unrestrictMinting() public onlyAdmin {\r\n        unrestrictedMinting = true;\r\n    }\r\n\r\n    function restrictMinting() public onlyAdmin {\r\n        unrestrictedMinting = false;\r\n    }\r\n\r\n    function name() external view returns (string) {\r\n        return tokenName;\r\n    }\r\n\r\n    function symbol() external view returns (string) {\r\n        return tokenSymbol;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return allTokens.length;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        require(account != address(0));\r\n        return tokenCount[account];\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = owners[tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\r\n        require(index < balanceOf(owner));\r\n        return ownedTokens[owner][index];\r\n    }\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index < totalSupply());\r\n        return allTokens[index];\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId));\r\n        return approval[tokenId];\r\n    }\r\n\r\n    function isApprovedForAll(address account, address operator) public view returns (bool) {\r\n        return operatorApproval[account][operator];\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string) {\r\n        require(_exists(tokenId));\r\n        return uri[tokenId];\r\n    }\r\n\r\n    function addAdmin(address account) public onlyAdmin {\r\n        _addAdmin(account);\r\n    }\r\n\r\n    function _addAdmin(address account) internal {\r\n        groups.add(ADMIN, account);\r\n        emit AddedToGroup(ADMIN, account);\r\n    }\r\n\r\n    function removeAdmin(address account) public onlyAdmin {\r\n        groups.remove(ADMIN, account);\r\n        emit RemovedFromGroup(ADMIN, account);\r\n    }\r\n\r\n    function isAdmin(address account) public view returns (bool) {\r\n        return groups.contains(ADMIN, account);\r\n    }\r\n\r\n    function approve(address account, uint256 tokenId) public {\r\n        address owner = ownerOf(tokenId);\r\n\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        approval[tokenId] = account;\r\n        emit Approval(owner, account, tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != msg.sender);\r\n        operatorApproval[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId));\r\n        require(to != address(0));\r\n\r\n        _clearApproval(from, tokenId);\r\n        _removeTokenFrom(from, tokenId);\r\n        _addTokenTo(to, tokenId);\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external payable {\r\n        transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, \"\"));\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) external payable {\r\n        transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, data));\r\n    }\r\n\r\n    function mint(address to, uint256 tokenId) public onlyAdmin returns (bool) {\r\n        _mint(to, tokenId);\r\n        return true;\r\n    }\r\n\r\n    function mintWithTokenURI(address to, uint256 tokenId, string URIForToken) public onlyAdmin returns (bool) {\r\n        _mint(to, tokenId);\r\n        _setTokenURI(tokenId, URIForToken);\r\n        return true;\r\n    }\r\n\r\n    function addQr(uint256 tokenId) public returns (bool) {\r\n        if (!unrestrictedMinting) {\r\n            require(isAdmin(msg.sender), \"Must be an admin\");\r\n        }\r\n        _mint(tokenOwner, tokenId);\r\n        _setTokenURI(tokenId, concat(\"https://qr.blockwell.ai/qri/\", uint2str(tokenId)));\r\n        return true;\r\n    }\r\n\r\n    function burn(uint256 tokenId) public {\r\n        require(msg.sender == ownerOf(tokenId));\r\n        _burn(msg.sender, tokenId);\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        return owners[tokenId] != address(0);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0));\r\n        _addTokenTo(to, tokenId);\r\n\r\n        tokenIndex[tokenId] = allTokens.length;\r\n        allTokens.push(tokenId);\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    function _burn(address account, uint256 tokenId) internal {\r\n        _clearApproval(account, tokenId);\r\n        _removeTokenFrom(account, tokenId);\r\n\r\n        if (bytes(uri[tokenId]).length != 0) {\r\n            delete uri[tokenId];\r\n        }\r\n\r\n        // Delete from array by moving the last element to the deleted position\r\n        uint256 index = tokenIndex[tokenId];\r\n        uint256 lastTokenIndex = allTokens.length.sub(1);\r\n        uint256 lastToken = allTokens[lastTokenIndex];\r\n\r\n        allTokens[index] = lastToken;\r\n        allTokens[lastTokenIndex] = 0;\r\n\r\n        allTokens.length--;\r\n        tokenIndex[tokenId] = 0;\r\n        tokenIndex[lastToken] = index;\r\n\r\n        emit Transfer(account, address(0), tokenId);\r\n    }\r\n\r\n    function _addTokenTo(address to, uint256 tokenId) internal {\r\n        require(owners[tokenId] == address(0));\r\n        owners[tokenId] = to;\r\n        tokenCount[to] = tokenCount[to].add(1);\r\n\r\n        ownedTokens[to].push(tokenId);\r\n        ownedTokensIndex[tokenId] = ownedTokens[to].length - 1;\r\n    }\r\n\r\n    function _removeTokenFrom(address from, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from);\r\n        tokenCount[from] = tokenCount[from].sub(1);\r\n        owners[tokenId] = address(0);\r\n\r\n        // Delete from array by moving the last element to the deleted position\r\n        uint256 index = ownedTokensIndex[tokenId];\r\n        uint256 lastTokenIndex = ownedTokens[from].length.sub(1);\r\n        uint256 lastToken = ownedTokens[from][lastTokenIndex];\r\n\r\n        ownedTokens[from][index] = lastToken;\r\n        ownedTokens[from].length--;\r\n\r\n        ownedTokensIndex[tokenId] = 0;\r\n        ownedTokensIndex[lastToken] = index;\r\n    }\r\n\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes data) internal returns (bool) {\r\n        if (!isContract(to)) {\r\n            return true;\r\n        }\r\n        ERC721TokenReceiver receiver = ERC721TokenReceiver(to);\r\n        bytes4 retval = receiver.onERC721Received(msg.sender, from, tokenId, data);\r\n        return (retval == receiver.onERC721Received.selector);\r\n    }\r\n\r\n    function _clearApproval(address account, uint256 tokenId) private {\r\n        require(ownerOf(tokenId) == account);\r\n        if (approval[tokenId] != address(0)) {\r\n            approval[tokenId] = address(0);\r\n        }\r\n    }\r\n\r\n    function _setTokenURI(uint256 tokenId, string newURI) internal {\r\n        require(_exists(tokenId));\r\n        uri[tokenId] = newURI;\r\n    }\r\n\r\n\r\n    function concat(string memory a, string memory b) internal pure returns (string memory) {\r\n        uint256 aLength = bytes(a).length;\r\n        uint256 bLength = bytes(b).length;\r\n        string memory value = new string(aLength + bLength);\r\n        uint valuePointer;\r\n        uint aPointer;\r\n        uint bPointer;\r\n        assembly {\r\n            valuePointer := add(value, 32)\r\n            aPointer := add(a, 32)\r\n            bPointer := add(b, 32)\r\n        }\r\n        copy(aPointer, valuePointer, aLength);\r\n        copy(bPointer, valuePointer + aLength, bLength);\r\n        return value;\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n        while (i != 0) {\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function copy(uint src, uint dest, uint len) internal pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unrestrictMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"URIForToken\",\"type\":\"string\"}],\"name\":\"mintWithTokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restrictMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unrestrictedMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"addQr\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"groupId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddedToGroup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"groupId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemovedFromGroup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"Qri","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000012426c6f636b77656c6c2d515220496e646578000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000035152490000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"None","SwarmSource":"bzzr://4d8f013d1a56f732223dee9e49521b6b110058fe12cbfe9ed5bfaa5f5b72b37a"}]}