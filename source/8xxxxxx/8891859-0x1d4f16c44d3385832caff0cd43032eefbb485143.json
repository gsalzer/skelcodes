{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\n\ncontract IPackFour {\n\n    struct Purchase {\n        uint16 current;\n        uint16 count;\n        address user;\n        uint randomness;\n        uint64 commit;\n    }\n\n    function purchases(uint p) public view returns (\n        uint16 current,\n        uint16 count,\n        address user,\n        uint256 randomness,\n        uint64 commit\n    );\n\n    function predictPacks(uint id) public view returns (uint16[] memory protos, uint16[] memory purities);\n\n    function getCardDetails(\n        uint16 packIndex,\n        uint8 cardIndex,\n        uint result\n    )\n        public\n        view\n        returns (uint16 proto, uint16 purity);\n\n}\n\ncontract BaseMigration {\n\n    function convertPurity(uint16 purity)\n        public\n        pure\n        returns (uint8)\n    {\n        return uint8(4 - (purity / 1000));\n    }\n\n    function convertProto(uint16 proto)\n        public\n        view\n        returns (uint16)\n    {\n        if (proto >= 1 && proto <= 377) {\n            return proto;\n        }\n        // first phoenix\n        if (proto == 380) {\n            return 400;\n        }\n        // light's bidding\n        if (proto == 381) {\n            return 401;\n        }\n        // chimera\n        if (proto == 394) {\n            return 402;\n        }\n        // etherbots\n        (bool found, uint index) = getEtherbotsIndex(proto);\n        if (found) {\n            return uint16(380 + index);\n        }\n        // hyperion\n        if (proto == 378) {\n            return 65000;\n        }\n        // prometheus\n        if (proto == 379) {\n            return 65001;\n        }\n        // atlas\n        if (proto == 383) {\n            return 65002;\n        }\n        // tethys\n        if (proto == 384) {\n            return 65003;\n        }\n        require(false, \"BM: unrecognised proto\");\n    }\n\n    uint16[] internal ebs = [\n        400,\n        413,\n        414,\n        421,\n        427,\n        428,\n        389,\n        415,\n        416,\n        422,\n        424,\n        425,\n        426,\n        382,\n        420,\n        417\n    ];\n\n    function getEtherbotsIndex(uint16 proto)\n        public\n        view\n        returns (bool, uint16)\n    {\n        for (uint16 i = 0; i < ebs.length; i++) {\n            if (ebs[i] == proto) {\n                return (true, i);\n            }\n        }\n        return (false, 0);\n    }\n\n}\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others (`ERC165Checker`).\n *\n * For an implementation, see `ERC165`.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * \n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either `approve` or `setApproveForAll`.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either `approve` or `setApproveForAll`.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\n\ncontract ICards is IERC721 {\n\n    struct Batch {\n        uint48 userID;\n        uint16 size;\n    }\n\n    function batches(uint index) public view returns (uint48 userID, uint16 size);\n\n    function userIDToAddress(uint48 id) public view returns (address);\n\n    function getDetails(\n        uint tokenId\n    )\n        public\n        view\n        returns (\n        uint16 proto,\n        uint8 quality\n    );\n\n    function setQuality(\n        uint tokenId,\n        uint8 quality\n    ) public;\n\n    function mintCards(\n        address to,\n        uint16[] memory _protos,\n        uint8[] memory _qualities\n    )\n        public\n        returns (uint);\n\n    function mintCard(\n        address to,\n        uint16 _proto,\n        uint8 _quality\n    )\n        public\n        returns (uint);\n\n    function burn(uint tokenId) public;\n\n    function batchSize()\n        public\n        view\n        returns (uint);\n}\n\n\n\ncontract SplitV1Migration is BaseMigration {\n\n    ICards cards;\n    uint public oldLimit;\n    uint16 public newLimit;\n    uint16 public constant size = 5;\n\n    constructor(\n        ICards _cards,\n        address[] memory _packs,\n        uint _oldLimit,\n        uint16 _newLimit\n    ) public {\n\n        for (uint i = 0; i < _packs.length; i++) {\n            canMigrate[_packs[i]] = true;\n        }\n\n        cards = _cards;\n        oldLimit = _oldLimit;\n        require(_newLimit % size == 0, \"limit must be divisible by size\");\n        newLimit = _newLimit;\n    }\n\n    mapping (address => bool) public canMigrate;\n\n    mapping (address => mapping (uint => uint16)) public v1Migrated;\n\n    event Migrated(\n        address indexed user,\n        address indexed pack,\n        uint indexed id,\n        uint start,\n        uint end,\n        uint startID\n    );\n\n    function migrateAll(\n        IPackFour pack,\n        uint[] memory ids\n    ) public {\n        for (uint i = 0; i < ids.length; i++) {\n            migrate(pack, ids[i]);\n        }\n    }\n\n    struct StackDepthLimit {\n        uint16 proto;\n        uint16 purity;\n        uint16[] protos;\n        uint8[] qualities;\n    }\n\n    function migrate(\n        IPackFour pack,\n        uint id\n    )\n        public\n    {\n\n        require(\n            canMigrate[address(pack)],\n            \"V1: must be migrating from an approved pack\"\n        );\n\n        (\n            uint16 current,\n            uint16 count,\n            address user,\n            uint256 randomness,\n        ) = pack.purchases(id);\n\n        // Check if randomness set\n        require(\n            randomness != 0,\n            \"V1: must have had randomness set\"\n        );\n\n        uint16 remaining = ((count - current) * size);\n\n        require(\n            remaining > oldLimit,\n            \"V1: must have not been able to activate in v1\"\n        );\n\n        remaining -= v1Migrated[address(pack)][id];\n\n        uint16 loopStart = (current * size) + v1Migrated[address(pack)][id];\n\n        uint16 len = remaining > newLimit ? newLimit : remaining;\n\n        StackDepthLimit memory sdl;\n\n        sdl.protos = new uint16[](len);\n        sdl.qualities = new uint8[](len);\n\n        uint16 packStart = loopStart / size;\n\n        for (uint16 i = 0; i < len / size; i++) {\n            for (uint8 j = 0; j < size; j++) {\n                uint index = (i * size) + j;\n                (sdl.proto, sdl.purity) = pack.getCardDetails(i + packStart, j, randomness);\n                sdl.protos[index] = convertProto(sdl.proto);\n                sdl.qualities[index] = convertPurity(sdl.purity);\n            }\n        }\n\n        // Batch Mint cards (details passed as function args)\n        uint startID = cards.mintCards(user, sdl.protos, sdl.qualities);\n\n        v1Migrated[address(pack)][id] += len;\n\n        uint loopEnd = loopStart + len;\n\n        emit Migrated(user, address(pack), id, loopStart, loopEnd, startID);\n    }\n\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"}],\"name\":\"getEtherbotsIndex\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newLimit\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IPackFour\",\"name\":\"pack\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"migrateAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"}],\"name\":\"convertProto\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"purity\",\"type\":\"uint16\"}],\"name\":\"convertPurity\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canMigrate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"size\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IPackFour\",\"name\":\"pack\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"v1Migrated\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICards\",\"name\":\"_cards\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_packs\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_oldLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_newLimit\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pack\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startID\",\"type\":\"uint256\"}],\"name\":\"Migrated\",\"type\":\"event\"}]","ContractName":"SplitV1Migration","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000097575aa6364bb5f452d5b297ce74922c84621848000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000fa000000000000000000000000000000000000000000000000000000000000012c0000000000000000000000000000000000000000000000000000000000000004000000000000000000000000482cf6a9d6b23452c81d4d0f0f139c1414963f89000000000000000000000000c47d7d42e44b2e04c83a45cf45898e597a0c23110000000000000000000000001e891c587b345ab02a31b57c1f926fb08913d10d0000000000000000000000000777f76d195795268388789343068e4fcd286919","Library":"","LicenseType":"","SwarmSource":"bzzr://591cf1232d53c6b08c6fc8528e1532ab17dbe9f222be3ade1df4b6f0e11d9599"}]}