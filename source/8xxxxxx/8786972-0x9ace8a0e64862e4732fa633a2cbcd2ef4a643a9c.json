{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0 <0.6.0;\n\ninterface IRelay {\n\n    /// @notice Transfer NMR on behalf of a Numerai user\n    ///         Can only be called by Manager or Owner\n    /// @dev Can only be used on the first 1 million ethereum addresses\n    /// @param _from The user address\n    /// @param _to The recipient address\n    /// @param _value The amount of NMR in wei\n    function withdraw(address _from, address _to, uint256 _value) external returns (bool ok);\n\n    /// @notice Burn the NMR sent to address 0 and burn address\n    function burnZeroAddress() external;\n\n    /// @notice Permanantly disable the relay contract\n    ///         Can only be called by Owner\n    function disable() external;\n\n    /// @notice Permanantly disable token upgradability\n    ///         Can only be called by Owner\n    function disableTokenUpgradability() external;\n\n    /// @notice Upgrade the token delegate logic.\n    ///         Can only be called by Owner\n    /// @param _newDelegate Address of the new delegate contract\n    function changeTokenDelegate(address _newDelegate) external;\n\n    /// @notice Upgrade the token delegate logic using the UpgradeDelegate\n    ///         Can only be called by Owner\n    /// @dev must be called after UpgradeDelegate is set as the token delegate\n    /// @param _multisig Address of the multisig wallet address to receive NMR and ETH\n    /// @param _delegateV3 Address of NumeraireDelegateV3\n    function executeUpgradeDelegate(address _multisig, address _delegateV3) external;\n\n    /// @notice Burn stakes during initialization phase\n    ///         Can only be called by Manager or Owner\n    /// @dev must be called after UpgradeDelegate is set as the token delegate\n    /// @param tournamentID The index of the tournament\n    /// @param roundID The index of the tournament round\n    /// @param staker The address of the user\n    /// @param tag The UTF8 character string used to identify the submission\n    function destroyStake(uint256 tournamentID, uint256 roundID, address staker, bytes32 tag) external;\n\n}\n\n\ninterface INMR {\n\n    /* ERC20 Interface */\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /* NMR Special Interface */\n\n    // used for user balance management\n    function withdraw(address _from, address _to, uint256 _value) external returns(bool ok);\n\n    // used for migrating active stakes\n    function destroyStake(address _staker, bytes32 _tag, uint256 _tournamentID, uint256 _roundID) external returns (bool ok);\n\n    // used for disabling token upgradability\n    function createRound(uint256, uint256, uint256, uint256) external returns (bool ok);\n\n    // used for upgrading the token delegate logic\n    function createTournament(uint256 _newDelegate) external returns (bool ok);\n\n    // used like burn(uint256)\n    function mint(uint256 _value) external returns (bool ok);\n\n    // used like burnFrom(address, uint256)\n    function numeraiTransfer(address _to, uint256 _value) external returns (bool ok);\n\n    // used to check if upgrade completed\n    function contractUpgradable() external view returns (bool);\n\n    function getTournament(uint256 _tournamentID) external view returns (uint256, uint256[] memory);\n\n    function getRound(uint256 _tournamentID, uint256 _roundID) external view returns (uint256, uint256, uint256);\n\n    function getStake(uint256 _tournamentID, uint256 _roundID, address _staker, bytes32 _tag) external view returns (uint256, uint256, bool, bool);\n\n    function changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) external returns (bool ok);\n}\n\n\ninterface IErasureStake {\n    function increaseStake(uint256 currentStake, uint256 amountToAdd) external;\n    function reward(uint256 currentStake, uint256 amountToAdd) external;\n    function punish(uint256 currentStake, uint256 punishment, bytes calldata message) external returns (uint256 cost);\n    function releaseStake(uint256 currentStake, uint256 amountToRelease) external;\n}\n\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool wasInitializing = initializing;\n    initializing = true;\n    initialized = true;\n\n    _;\n\n    initializing = wasInitializing;\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error.\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n/* TODO: Update eip165 interface\n *  bytes4(keccak256('create(bytes)')) == 0xcf5ba53f\n *  bytes4(keccak256('getInstanceType()')) == 0x18c2f4cf\n *  bytes4(keccak256('getInstanceRegistry()')) == 0xa5e13904\n *  bytes4(keccak256('getImplementation()')) == 0xaaf10f42\n *\n *  => 0xcf5ba53f ^ 0x18c2f4cf ^ 0xa5e13904 ^ 0xaaf10f42 == 0xd88967b6\n */\n interface iFactory {\n\n     event InstanceCreated(address indexed instance, address indexed creator, string initABI, bytes initData);\n\n     function create(bytes calldata initData) external returns (address instance);\n     function createSalty(bytes calldata initData, bytes32 salt) external returns (address instance);\n     function getInitSelector() external view returns (bytes4 initSelector);\n     function getInstanceRegistry() external view returns (address instanceRegistry);\n     function getTemplate() external view returns (address template);\n     function getSaltyInstance(bytes calldata, bytes32 salt) external view returns (address instance);\n     function getNextInstance(bytes calldata) external view returns (address instance);\n\n     function getInstanceCreator(address instance) external view returns (address creator);\n     function getInstanceType() external view returns (bytes4 instanceType);\n     function getInstanceCount() external view returns (uint256 count);\n     function getInstance(uint256 index) external view returns (address instance);\n     function getInstances() external view returns (address[] memory instances);\n     function getPaginatedInstances(uint256 startIndex, uint256 endIndex) external view returns (address[] memory instances);\n }\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable is Initializable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    function initialize(address sender) public initializer {\n        _owner = sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[50] private ______gap;\n}\n\n\n\ncontract Manageable is Initializable, Ownable {\n    address private _manager;\n\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\n\n    /**\n     * @dev The Managable constructor sets the original `manager` of the contract to the sender\n     * account.\n     */\n    function initialize(address sender) initializer public {\n        Ownable.initialize(sender);\n        _manager = sender;\n        emit ManagementTransferred(address(0), _manager);\n    }\n\n    /**\n     * @return the address of the manager.\n     */\n    function manager() public view returns (address) {\n        return _manager;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner or manager.\n     */\n    modifier onlyManagerOrOwner() {\n        require(isManagerOrOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner or manager of the contract.\n     */\n    function isManagerOrOwner() public view returns (bool) {\n        return (msg.sender == _manager || isOwner());\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newManager.\n     * @param newManager The address to transfer management to.\n     */\n    function transferManagement(address newManager) public onlyOwner {\n        require(newManager != address(0));\n        emit ManagementTransferred(_manager, newManager);\n        _manager = newManager;\n    }\n\n    uint256[50] private ______gap;\n}\n\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n *      Modified from openzeppelin Pausable to simplify access control.\n */\ncontract Pausable is Initializable, Manageable {\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /// @notice Initializer function called at time of deployment\n    /// @param sender The address of the wallet to handle permission control\n    function initialize(address sender) public initializer {\n        Manageable.initialize(sender);\n        _paused = false;\n    }\n\n    /**\n     * @return true if the contract is paused, false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"contract is paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"expected contract to be paused\");\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyManagerOrOwner whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    uint256[50] private ______gap;\n}\n\n\n\n\n\n\n\n\ncontract NumeraiErasureV1 is Initializable, Pausable {\n    using SafeMath for uint256;\n\n    event CreateStake(\n        address indexed agreement,\n        address indexed staker\n    );\n\n    event CreateAndIncreaseStake(\n        address indexed agreement,\n        address indexed staker,\n        uint256 amount\n    );\n\n    event IncreaseStake(\n        address indexed agreement,\n        address indexed staker,\n        uint256 oldStakeAmount,\n        uint256 amountAdded\n    );\n\n    event Reward(\n        address indexed agreement,\n        address indexed staker,\n        uint256 oldStakeAmount,\n        uint256 amountAdded\n    );\n\n    event Punish(\n        address indexed agreement,\n        address indexed staker,\n        uint256 oldStakeAmount,\n        uint256 amountPunished,\n        bytes message\n    );\n\n    event ReleaseStake(\n        address indexed agreement,\n        address indexed staker,\n        uint256 oldStakeAmount,\n        uint256 amountReleased\n    );\n\n    event ResolveAndReleaseStake(\n        address indexed agreement,\n        address indexed staker,\n        uint256 oldStakeAmount,\n        uint256 amountReleased,\n        uint256 amountStakeChanged,\n        bool isReward\n    );\n\n    // set the address of the NMR token as a constant (stored in runtime code)\n    address private constant _TOKEN = address(\n        0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671\n    );\n\n    // set the address of the relay as a constant (stored in runtime code)\n    address private constant _RELAY = address(\n        0xB17dF4a656505570aD994D023F632D48De04eDF2\n    );\n\n    /// @notice Initializer function called at time of deployment\n    /// @param _owner The address of the wallet to handle permission control\n    function initialize(\n        address _owner\n    ) public initializer {\n        // initialize the contract's ownership.\n        Pausable.initialize(_owner);\n    }\n\n    /////////////////////////////\n    // Fund Recovery Functions //\n    /////////////////////////////\n\n    /// @notice Recover the ETH sent to this contract address\n    ///         Can only be called by the owner\n    /// @param recipient The address of the recipient\n    function recoverETH(address payable recipient) public onlyOwner {\n        recipient.transfer(address(this).balance);\n    }\n\n    /// @notice Recover the NMR sent to this address\n    ///         Can only be called by the owner\n    /// @param recipient The address of the recipient\n    function recoverNMR(address payable recipient) public onlyOwner {\n        uint256 balance = INMR(_TOKEN).balanceOf(address(this));\n        require(INMR(_TOKEN).transfer(recipient, balance), \"transfer failed\");\n    }\n\n\n    ////////////////////////\n    // Internal Functions //\n    ////////////////////////\n\n    function _approveNMR(address agreement, uint256 amountToAdd) internal {\n        uint256 oldAllowance = INMR(_TOKEN).allowance(address(this), agreement);\n        uint256 newAllowance = oldAllowance.add(amountToAdd);\n        require(INMR(_TOKEN).changeApproval(agreement, oldAllowance, newAllowance), \"Failed to approve\");\n    }\n\n    ///////////////////\n    // NMR Functions //\n    ///////////////////\n\n    /// @notice Transfer NMR on behalf of a Numerai user\n    ///         Can only be called by Numerai\n    /// @dev Calls the NMR token contract through the relay contract\n    ///      Can only be used on the first 1 million ethereum addresses.\n    /// @param from The user address\n    /// @param to The recipient address\n    /// @param value The amount of NMR in wei\n    function withdraw(\n        address from,\n        address to,\n        uint256 value\n    ) public onlyManagerOrOwner whenNotPaused {\n        IRelay(_RELAY).withdraw(from, to, value);\n    }\n\n    ///////////////////////\n    // Erasure Functions //\n    ///////////////////////\n\n    /// @notice Owned function to stake on Erasure agreement\n    ///         Can only be called by Numerai\n    ///         This function is intended as a bridge to allow for our custodied user accounts\n    ///         (ie. the first million addresses), to stake in an Erasure agreement. Erasure\n    ///         agreements assume an ERC-20 token, and the way we did custody doesn't quite fit\n    ///         in the normal ERC-20 way of doing things. Ideally, we would be able to call\n    ///         `changeApproval` on behalf of our custodied accounts, but that is unfortunately\n    ///         not possible.\n    ///         Instead what we have to do is `withdraw` the NMR into this contract and then call\n    ///         `changeApproval` on this contract before calling `increaseStake` on the Erasure\n    ///         agreement. The NMR is then taken from this contract to increase the stake.\n    /// @param agreement The address of the agreement contract. Must conform to IErasureStake interface\n    /// @param staker The address of the staker\n    /// @param currentStake The amount of NMR in wei already staked on the agreement\n    /// @param stakeAmount The amount of NMR in wei to incease the stake with this agreement\n    function increaseStake(\n        address agreement, address staker, uint256 currentStake, uint256 stakeAmount\n    ) public onlyManagerOrOwner whenNotPaused {\n        require(stakeAmount > 0, \"Cannot stake zero NMR\");\n\n        uint256 oldBalance = INMR(_TOKEN).balanceOf(address(this));\n\n        require(IRelay(_RELAY).withdraw(staker, address(this), stakeAmount), \"Failed to withdraw\");\n\n        _approveNMR(agreement, stakeAmount);\n\n        IErasureStake(agreement).increaseStake(currentStake, stakeAmount);\n\n        uint256 newBalance = INMR(_TOKEN).balanceOf(address(this));\n        require(oldBalance == newBalance, \"Balance before/after did not match\");\n\n        emit IncreaseStake(agreement, staker, currentStake, stakeAmount);\n    }\n\n    /// @notice Owned function to create an Erasure agreement stake\n    /// @param factory The address of the agreement factory. Must conform to iFactory interface\n    /// @param agreement The address of the agreement contract that will be created. Get this value by running factory.getSaltyInstance(...)\n    /// @param staker The address of the staker\n    /// @param callData The callData used to create the agreement\n    /// @param salt The salt used to create the agreement\n    function createStake(\n        address factory, address agreement, address staker, bytes memory callData, bytes32 salt\n    ) public onlyManagerOrOwner whenNotPaused {\n        require(iFactory(factory).createSalty(callData, salt) == agreement, \"Unexpected agreement address\");\n\n        emit CreateStake(agreement, staker);\n    }\n\n    /// @notice Owned function to create an Erasure agreement stake\n    /// @param factory The address of the agreement factory. Must conform to iFactory interface\n    /// @param agreement The address of the agreement contract that will be created. Get this value by running factory.getSaltyInstance(...)\n    /// @param staker The address of the staker\n    /// @param stakeAmount The amount of NMR in wei to incease the stake with this agreement\n    /// @param callData The callData used to create the agreement\n    /// @param salt The salt used to create the agreement\n    function createAndIncreaseStake(\n        address factory, address agreement, address staker, uint256 stakeAmount, bytes memory callData, bytes32 salt\n    ) public onlyManagerOrOwner whenNotPaused {\n        createStake(factory, agreement, staker, callData, salt);\n\n        increaseStake(agreement, staker, 0, stakeAmount);\n\n        emit CreateAndIncreaseStake(agreement, staker, stakeAmount);\n    }\n\n    /// @notice Owned function to reward an Erasure agreement stake\n    /// NMR tokens must be stored in this contract before this call.\n    /// @param agreement The address of the agreement contract. Must conform to IErasureStake interface\n    /// @param staker The address of the staker\n    /// @param currentStake The amount of NMR in wei already staked on the agreement\n    /// @param amountToAdd The amount of NMR in wei to incease the stake with this agreement\n    function reward(\n        address agreement, address staker, uint256 currentStake, uint256 amountToAdd\n    ) public onlyManagerOrOwner whenNotPaused {\n        require(amountToAdd > 0, \"Cannot add zero NMR\");\n\n        uint256 oldBalance = INMR(_TOKEN).balanceOf(address(this));\n\n        _approveNMR(agreement, amountToAdd);\n\n        IErasureStake(agreement).reward(currentStake, amountToAdd);\n\n        uint256 newBalance = INMR(_TOKEN).balanceOf(address(this));\n        require(oldBalance.sub(amountToAdd) == newBalance, \"Balance before/after did not match\");\n\n        emit Reward(agreement, staker, currentStake, amountToAdd);\n    }\n\n    /// @notice Owned function to punish an Erasure agreement stake\n    /// @param agreement The address of the agreement contract. Must conform to IErasureStake interface\n    /// @param staker The address of the staker\n    /// @param currentStake The amount of NMR in wei already staked on the agreement\n    /// @param punishment The amount of NMR in wei to punish the stake with this agreement\n    function punish(\n        address agreement, address staker, uint256 currentStake, uint256 punishment, bytes memory message\n    ) public onlyManagerOrOwner whenNotPaused {\n        require(punishment > 0, \"Cannot punish zero NMR\");\n\n        uint256 oldBalance = INMR(_TOKEN).balanceOf(address(this));\n\n        IErasureStake(agreement).punish(currentStake, punishment, message);\n\n        uint256 newBalance = INMR(_TOKEN).balanceOf(address(this));\n        require(oldBalance == newBalance, \"Balance before/after did not match\");\n\n        emit Punish(agreement, staker, currentStake, punishment, message);\n    }\n\n    /// @notice Owned function to release an Erasure agreement stake\n    /// @param agreement The address of the agreement contract. Must conform to IErasureStake interface\n    /// @param staker The address of the staker\n    /// @param currentStake The amount of NMR in wei already staked on the agreement\n    /// @param amountToRelease The amount of NMR in wei to release back to the staker\n    function releaseStake(\n        address agreement, address staker, uint256 currentStake, uint256 amountToRelease\n    ) public onlyManagerOrOwner whenNotPaused {\n        require(amountToRelease > 0, \"Cannot release zero NMR\");\n\n        IErasureStake(agreement).releaseStake(currentStake, amountToRelease);\n\n        emit ReleaseStake(agreement, staker, currentStake, amountToRelease);\n    }\n\n    /// @notice Owned function to resolve and then release an Erasure agreement stake\n    /// @param agreement The address of the agreement contract. Must conform to IErasureStake interface\n    /// @param staker The address of the staker\n    /// @param currentStake The amount of NMR in wei already staked on the agreement\n    /// @param amountToRelease The amount of NMR in wei to release back to the staker\n    /// @param amountToChangeStake The amount of NMR to change the stake with\n    /// @param isReward Boolean, if true then reward, else punish\n    function resolveAndReleaseStake(\n        address agreement, address staker, uint256 currentStake, uint256 amountToRelease, uint256 amountToChangeStake, bool isReward\n    ) public onlyManagerOrOwner whenNotPaused {\n        require(amountToRelease != 0, \"Cannot release with zero NMR\");\n\n        uint256 newStake = currentStake;\n        if (amountToChangeStake != 0) {\n            if(isReward) {\n                reward(agreement, staker, currentStake, amountToChangeStake);\n                newStake = currentStake.add(amountToChangeStake);\n            } else {\n                punish(agreement, staker, currentStake, amountToChangeStake, \"punish before release\");\n                newStake = currentStake.sub(amountToChangeStake);\n            }\n        }\n\n        releaseStake(agreement, staker, newStake, amountToRelease);\n\n        emit ResolveAndReleaseStake(agreement, staker, currentStake, amountToRelease, amountToChangeStake, isReward);\n    }\n}\n","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"agreement\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CreateAndIncreaseStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"agreement\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"CreateStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"agreement\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAdded\",\"type\":\"uint256\"}],\"name\":\"IncreaseStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"agreement\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPunished\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"Punish\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"agreement\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountReleased\",\"type\":\"uint256\"}],\"name\":\"ReleaseStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"agreement\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountReleased\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountStakeChanged\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isReward\",\"type\":\"bool\"}],\"name\":\"ResolveAndReleaseStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"agreement\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAdded\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"agreement\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"createAndIncreaseStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"agreement\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"createStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"agreement\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"name\":\"increaseStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isManagerOrOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"agreement\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"punishment\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"punish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"recoverETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"recoverNMR\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"agreement\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToRelease\",\"type\":\"uint256\"}],\"name\":\"releaseStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"agreement\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToRelease\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToChangeStake\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReward\",\"type\":\"bool\"}],\"name\":\"resolveAndReleaseStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"agreement\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToAdd\",\"type\":\"uint256\"}],\"name\":\"reward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"transferManagement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NumeraiErasureV1","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://18f8f60c15a036703968c4d275e2b597570ed71114c2097c7d947cacb7659837"}]}