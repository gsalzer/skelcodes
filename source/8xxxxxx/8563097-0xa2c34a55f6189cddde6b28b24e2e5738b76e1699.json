{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: contracts/AbstractOrganizationFactory.sol\n\npragma solidity ^0.5.6;\n\n/**\n * Abstract Organization Factory. Usable in libraries.\n */\ncontract AbstractOrganizationFactory {\n\n    /**\n     * @dev Event triggered every time organization is created.\n     */\n    event OrganizationCreated(address indexed organization);\n\n    /**\n     * @dev Event triggered when owner of the factory is changed.\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address);\n\n    /**\n     * @dev Creates new 0xORG smart contract\n     * @param  orgJsonUri Organization's data pointer\n     * @param  orgJsonHash Organization's data hash\n     * @return {\" \": \"Address of the new organization.\"}\n     */\n    function create(string calldata orgJsonUri, bytes32 orgJsonHash) external returns (address);\n\n    /**\n     * @dev Creates new 0xORG smart contract and adds it to a segment directory\n     * in the same transaction\n     * @param  orgJsonUri Organization's data pointer\n     * @param  orgJsonHash Organization's data hash\n     * @param  directory Segment directory address\n     * @return {\" \": \"Address of the new organization.\"}\n     */\n    function createAndAddToDirectory(\n        string calldata orgJsonUri,\n        bytes32 orgJsonHash,\n        address directory\n    ) external returns (address);\n\n    /**\n     * @dev Returns number of created organizations.\n     */\n    function getCreatedOrganizationsLength() public view returns (uint);\n\n    /**\n     * @dev Returns a list of created organizations.\n     */\n    function getCreatedOrganizations() public view returns (address[] memory);\n\n    /**\n     * @dev Returns index of `organization`\n     */\n    function createdOrganizationsIndex(address organization) public view returns (uint);\n\n    /**\n     * @dev Returns organization address on `index` position.\n     */\n    function createdOrganizations(uint index) public view returns (address);\n}\n\n// File: contracts/AbstractSegmentDirectory.sol\n\npragma solidity ^0.5.6;\n\n/**\n * @title AbstractSegmentDirectory\n * \n * @dev Usable in libraries. Segment Directory is essentially a list\n * of 0xORG smart contracts that share a common segment - hotels, airlines, otas.\n */\ncontract AbstractSegmentDirectory {\n\n    /**\n     * @dev Event triggered every time organization is added.\n     */\n    event OrganizationAdded(address indexed organization, uint index);\n\n    /**\n     * @dev Event triggered every time organization is removed.\n     */\n    event OrganizationRemoved(address indexed organization);\n\n    /**\n     * @dev Event triggered when owner of the directory is changed.\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address);\n\n    /**\n     * @dev Returns the segment name\n     */\n    function getSegment() public view returns (string memory);\n\n    /**\n     * @dev Returns the address of the associated lif token\n     */\n    function getLifToken() public view returns (address);\n\n    /**\n     * @dev Adds an organization to the list\n     */\n    function add(address organization) external returns (address);\n\n    /**\n     * @dev Removes an organization from the list\n     */\n    function remove(address organization) external;\n\n    /**\n     * @dev Returns the number of added organizations. Might contain zero\n     * addresses (these remain after removing an organization).\n     */\n    function getOrganizationsLength() public view returns (uint);\n\n    /**\n     * @dev Returns a list of added organizations. Might contain zero addresses.\n     */\n    function getOrganizations() public view returns (address[] memory);\n\n    /**\n     * @dev Returns index of `organization`\n     */\n    function organizationsIndex(address organization) public view returns (uint);\n\n    /**\n     * @dev Returns organization address on `index` position.\n     */\n    function organizations(uint index) public view returns (address);\n}\n\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others (`ERC165Checker`).\n *\n * For an implementation, see `ERC165`.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Implementation of the `IERC165` interface.\n *\n * Contracts may inherit from this and call `_registerInterface` to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See `IERC165.supportsInterface`.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See `IERC165.supportsInterface`.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n// File: contracts/OrganizationInterface.sol\n\npragma solidity ^0.5.6;\n\n\n/**\n * @title Minimal 0xORG interface\n * \n * @dev If you are creating your own implementation of Winding\n * Tree Organization, this is the minimal interface that you must\n * fullfill. Without it, the Organization won't be added into the\n * SegmentDirectory. For checked interface ID, head over to the\n * implementation of `addOrganization` in `SegmentDirectory`.\n *\n * This is not meant to be used by libraries that try to operate\n * with the organization as any data manipulation methods are\n * intentionally omitted. It can be used only for reading data.\n */\ncontract OrganizationInterface is IERC165 {\n    /**\n     * @dev Returns the address of the current owner.\n     * @return {\" \": \"Current owner address.\"}\n     */\n    function owner() public view returns (address);\n\n    /**\n     * @dev Returns the URI of ORG.JSON file stored off-chain.\n     * @return {\" \": \"Current ORG.JSON URI.\"}\n     */\n    function getOrgJsonUri() external view returns (string memory);\n\n    /**\n     * @dev Returns keccak256 hash of raw ORG.JSON contents. This should\n     * be used to verify that the contents of ORG.JSON has not been tampered\n     * with. It is a responsibility of the Organization owner to keep this\n     * hash up to date.\n     * @return {\" \": \"Current ORG.JSON hash.\"}\n     */\n    function getOrgJsonHash() external view returns (bytes32);\n\n    /**\n     * @dev Returns if an `address` is associated with the Organization.\n     * Associated keys can be used on behalf of the organization,\n     * typically to sign messages.\n     *\n     * @param addr Associated Ethereum address\n     * @return {\" \": \"true if associated, false otherwise\"}\n     */\n    function hasAssociatedKey(address addr) external view returns (bool);\n\n    /**\n     * @dev Returns all associatedKeys belonging to this organization.\n     * @return {\" \": \"List of associatedKeys\"}\n     */\n    function getAssociatedKeys() external view returns (address[] memory);\n}\n\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: contracts/Organization.sol\n\npragma solidity ^0.5.6;\n\n\n\n\n/**\n * @title Organization\n * @dev A contract that represents an Organization in the Winding Tree platform,\n * commonly referred to as 0xORG. This is a reference implementation that is\n * created by the OrganizationFactory. You cn implement your own logic if it\n * adheres to the `OrganizationInterface`.\n */\ncontract Organization is OrganizationInterface, ERC165, Initializable {\n    // Address of the contract owner\n    address _owner;\n\n    // Arbitrary locator of the off-chain stored Organization data\n    // This might be an HTTPS resource, IPFS hash, Swarm address...\n    // This is intentionally generic.\n    string public orgJsonUri;\n\n    // Number of a block when the Organization was created\n    uint public created;\n\n    // Index of associated addresses. These can be used\n    // to operate on behalf of this organization, typically sign messages.\n    mapping(address => uint) public associatedKeysIndex;\n\n    // List of associatedKeys. These addresses (i. e. public key\n    // fingerprints) can be used to associate signed content with this\n    // organization.\n    address[] public associatedKeys;\n\n    // keccak256 hash of the ORG.JSON file contents. This should\n    // be used to verify that the contents of ORG.JSON has not been tampered\n    // with. It is a responsibility of the Organization owner to keep this\n    // hash up to date.\n    bytes32 public orgJsonHash;\n\n    /**\n     * @dev Event triggered when owner of the organization is changed.\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Event triggered when orgJsonUri of the organization is changed.\n     */\n    event OrgJsonUriChanged(string previousOrgJsonUri, string newOrgJsonUri);\n\n    /**\n     * @dev Event triggered when orgJsonHash of the organization is changed.\n     */\n    event OrgJsonHashChanged(bytes32 indexed previousOrgJsonHash, bytes32 indexed newOrgJsonHash);\n\n    /**\n     * @dev Event triggered when new associatedKey is added.\n     */\n    event AssociatedKeyAdded(address indexed associatedKey, uint index);\n\n    /**\n     * @dev Event triggered when a associatedKey is removed.\n     */    \n    event AssociatedKeyRemoved(address indexed associatedKey);\n\n    /**\n     * @dev Initializer for upgradeable contracts.\n     * @param __owner The address of the contract owner\n     * @param _orgJsonUri pointer to Organization data\n     * @param  _orgJsonHash keccak256 hash of the new ORG.JSON contents.\n     */\n    function initialize(address payable __owner, string memory _orgJsonUri, bytes32 _orgJsonHash) public initializer {\n        require(__owner != address(0), 'Organization: Cannot set owner to 0x0 address');\n        require(bytes(_orgJsonUri).length != 0, 'Organization: orgJsonUri cannot be an empty string');\n        require(_orgJsonHash != 0, 'Organization: orgJsonHash cannot be empty');\n        emit OwnershipTransferred(_owner, __owner);\n        _owner = __owner;        \n        orgJsonUri = _orgJsonUri;\n        orgJsonHash = _orgJsonHash;\n        created = block.number;\n        associatedKeys.length++;\n        OrganizationInterface i;\n        _registerInterface(0x01ffc9a7);//_INTERFACE_ID_ERC165\n        bytes4 associatedKeysInterface = i.hasAssociatedKey.selector ^ i.getAssociatedKeys.selector; // 0xfed71811\n        bytes4 orgJsonInterface = i.getOrgJsonUri.selector ^ i.getOrgJsonHash.selector; // 0x6f4826be\n        _registerInterface(orgJsonInterface);\n        _registerInterface(associatedKeysInterface);\n        _registerInterface(i.owner.selector); // 0x8da5cb5b\n        _registerInterface(\n            i.owner.selector ^\n            orgJsonInterface ^\n            associatedKeysInterface\n        ); // 0x1c3af5f4\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == _owner, 'Organization: Only owner can call this method');\n        _;\n    }\n\n    /**\n     * @dev `changeOrgJsonUri` Allows owner to change Organization's orgJsonUri.\n     * @param  _orgJsonUri New orgJsonUri pointer of this Organization\n     */\n    function changeOrgJsonUri(string memory _orgJsonUri) public onlyOwner {\n        require(bytes(_orgJsonUri).length != 0, 'Organization: orgJsonUri cannot be an empty string');\n        emit OrgJsonUriChanged(orgJsonUri, _orgJsonUri);\n        orgJsonUri = _orgJsonUri;\n    }\n\n    /**\n     * @dev Returns current orgJsonUri\n     * @return {\" \": \"Current orgJsonUri.\"}\n     */\n    function getOrgJsonUri() external view returns (string memory) {\n        return orgJsonUri;\n    }\n\n    /**\n     * @dev `changeOrgJsonHash` Allows owner to change Organization's orgJsonHash.\n     * @param  _orgJsonHash keccak256 hash of the new ORG.JSON contents.\n     */\n    function changeOrgJsonHash(bytes32 _orgJsonHash) public onlyOwner {\n        require(_orgJsonHash != 0, 'Organization: orgJsonHash cannot be empty');\n        emit OrgJsonHashChanged(orgJsonHash, _orgJsonHash);\n        orgJsonHash = _orgJsonHash;\n    }\n\n    /**\n     * @dev Returns keccak256 hash of raw ORG.JSON contents. This should\n     * be used to verify that the contents of ORG.JSON has not been tampered\n     * with. It is a responsibility of the Organization owner to keep this\n     * hash up to date.\n     * @return {\" \": \"Current ORG.JSON hash.\"}\n     */\n    function getOrgJsonHash() external view returns (bytes32) {\n        return orgJsonHash;\n    }\n\n    /**\n     * @dev Shorthand method to change ORG.JSON uri and hash at the same time\n     * @param  _orgJsonUri New orgJsonUri pointer of this Organization\n     * @param  _orgJsonHash keccak256 hash of the new ORG.JSON contents.\n     */\n    function changeOrgJsonUriAndHash(string memory _orgJsonUri, bytes32 _orgJsonHash) public onlyOwner {\n        changeOrgJsonUri(_orgJsonUri);\n        changeOrgJsonHash(_orgJsonHash);\n    }\n\n    /**\n     * @dev Adds another associated key. Only owner can call this.\n     * @param addr Associated Ethereum address\n     * @return {\" \": \"Address of the added associatedKey\"}\n     */\n    function addAssociatedKey(address addr) public onlyOwner returns(address) {\n        require(addr != address(0), 'Organization: Cannot add associatedKey with 0x0 address');\n        require(associatedKeysIndex[addr] == 0, 'Organization: Cannot add associatedKey twice');\n        associatedKeysIndex[addr] = associatedKeys.length;\n        associatedKeys.push(addr);\n        emit AssociatedKeyAdded(addr, associatedKeysIndex[addr]);\n        return addr;\n    }\n\n    /**\n     * @dev Removes an associated key. Only owner can call this.\n     * @param addr Associated Ethereum address\n     */\n    function removeAssociatedKey(address addr) public onlyOwner {\n        require(addr != address(0), 'Organization: Cannot remove associatedKey with 0x0 address');\n        require(associatedKeysIndex[addr] != uint(0), 'Organization: Cannot remove unknown organization');\n        delete associatedKeys[associatedKeysIndex[addr]];\n        delete associatedKeysIndex[addr];\n        emit AssociatedKeyRemoved(addr);\n    }\n\n    /**\n     * @dev Is an address considered as associated for this organization?\n     * @return {\" \": \"True if address is considered as associatedKey, false otherwise\"}\n     */\n    function hasAssociatedKey(address addr) external view returns(bool) {\n        return associatedKeys[associatedKeysIndex[addr]] != address(0);\n    }\n\n    /**\n     * @dev Returns all addresses associated with this organization.\n     * @return {\" \": \"List of associated keys\"}\n     */\n    function getAssociatedKeys() external view returns (address[] memory) {\n        return associatedKeys;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        require(newOwner != address(0), 'Organization: Cannot transfer to 0x0 address');\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n\n    /**\n     * @dev A synchronization method that should be kept up to date with \n     * the list of interfaces set during initialization. It should also be called\n     * everytime the implementation gets updated. If the interface list gets out of\n     * sync with the implementation at anytime, it is possible that some integrations\n     * will stop working. Since this method is not destructive, no access restriction\n     * is in place. It's supposed to be called by the proxy admin anyway.\n     */\n    function setInterfaces() public {\n        // OrganizationInterface i;\n        bytes4[5] memory interfaceIds = [\n            bytes4(0x01ffc9a7), // _INTERFACE_ID_ERC165\n            bytes4(0x8da5cb5b), // i.owner.selector\n            bytes4(0xfed71811), // i.hasAssociatedKey.selector ^ i.getAssociatedKeys.selector\n            bytes4(0x6f4826be), // i.getOrgJsonUri.selector ^ i.getOrgJsonHash.selector\n            bytes4(0x1c3af5f4)  // 0x8da5cb5b ^ 0xfed71811 ^ 0x6f4826be\n        ];\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!this.supportsInterface(interfaceIds[i])) {\n                _registerInterface(interfaceIds[i]);\n            }\n        }\n    }\n}\n\n// File: @openzeppelin/upgrades/contracts/application/ImplementationProvider.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title ImplementationProvider\n * @dev Abstract contract for providing implementation addresses for other contracts by name.\n */\ncontract ImplementationProvider {\n  /**\n   * @dev Abstract function to return the implementation address of a contract.\n   * @param contractName Name of the contract.\n   * @return Implementation address of the contract.\n   */\n  function getImplementation(string memory contractName) public view returns (address);\n}\n\n// File: @openzeppelin/upgrades/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n *\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\n */\ncontract OpenZeppelinUpgradesOwnable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: @openzeppelin/upgrades/contracts/application/Package.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title Package\n * @dev A package is composed by a set of versions, identified via semantic versioning,\n * where each version has a contract address that refers to a reusable implementation,\n * plus an optional content URI with metadata. Note that the semver identifier is restricted\n * to major, minor, and patch, as prerelease tags are not supported.\n */\ncontract Package is OpenZeppelinUpgradesOwnable {\n  /**\n   * @dev Emitted when a version is added to the package.\n   * @param semanticVersion Name of the added version.\n   * @param contractAddress Contract associated with the version.\n   * @param contentURI Optional content URI with metadata of the version.\n   */\n  event VersionAdded(uint64[3] semanticVersion, address contractAddress, bytes contentURI);\n\n  struct Version {\n    uint64[3] semanticVersion;\n    address contractAddress;\n    bytes contentURI; \n  }\n\n  mapping (bytes32 => Version) internal versions;\n  mapping (uint64 => bytes32) internal majorToLatestVersion;\n  uint64 internal latestMajor;\n\n  /**\n   * @dev Returns a version given its semver identifier.\n   * @param semanticVersion Semver identifier of the version.\n   * @return Contract address and content URI for the version, or zero if not exists.\n   */\n  function getVersion(uint64[3] memory semanticVersion) public view returns (address contractAddress, bytes memory contentURI) {\n    Version storage version = versions[semanticVersionHash(semanticVersion)];\n    return (version.contractAddress, version.contentURI); \n  }\n\n  /**\n   * @dev Returns a contract for a version given its semver identifier.\n   * This method is equivalent to `getVersion`, but returns only the contract address.\n   * @param semanticVersion Semver identifier of the version.\n   * @return Contract address for the version, or zero if not exists.\n   */\n  function getContract(uint64[3] memory semanticVersion) public view returns (address contractAddress) {\n    Version storage version = versions[semanticVersionHash(semanticVersion)];\n    return version.contractAddress;\n  }\n\n  /**\n   * @dev Adds a new version to the package. Only the Owner can add new versions.\n   * Reverts if the specified semver identifier already exists. \n   * Emits a `VersionAdded` event if successful.\n   * @param semanticVersion Semver identifier of the version.\n   * @param contractAddress Contract address for the version, must be non-zero.\n   * @param contentURI Optional content URI for the version.\n   */\n  function addVersion(uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI) public onlyOwner {\n    require(contractAddress != address(0), \"Contract address is required\");\n    require(!hasVersion(semanticVersion), \"Given version is already registered in package\");\n    require(!semanticVersionIsZero(semanticVersion), \"Version must be non zero\");\n\n    // Register version\n    bytes32 versionId = semanticVersionHash(semanticVersion);\n    versions[versionId] = Version(semanticVersion, contractAddress, contentURI);\n    \n    // Update latest major\n    uint64 major = semanticVersion[0];\n    if (major > latestMajor) {\n      latestMajor = semanticVersion[0];\n    }\n\n    // Update latest version for this major\n    uint64 minor = semanticVersion[1];\n    uint64 patch = semanticVersion[2];\n    uint64[3] storage latestVersionForMajor = versions[majorToLatestVersion[major]].semanticVersion;\n    if (semanticVersionIsZero(latestVersionForMajor) // No latest was set for this major\n       || (minor > latestVersionForMajor[1]) // Or current minor is greater \n       || (minor == latestVersionForMajor[1] && patch > latestVersionForMajor[2]) // Or current patch is greater\n       ) { \n      majorToLatestVersion[major] = versionId;\n    }\n\n    emit VersionAdded(semanticVersion, contractAddress, contentURI);\n  }\n\n  /**\n   * @dev Checks whether a version is present in the package.\n   * @param semanticVersion Semver identifier of the version.\n   * @return true if the version is registered in this package, false otherwise.\n   */\n  function hasVersion(uint64[3] memory semanticVersion) public view returns (bool) {\n    Version storage version = versions[semanticVersionHash(semanticVersion)];\n    return address(version.contractAddress) != address(0);\n  }\n\n  /**\n   * @dev Returns the version with the highest semver identifier registered in the package.\n   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will always return `2.0.0`, regardless \n   * of the order in which they were registered. Returns zero if no versions are registered.\n   * @return Semver identifier, contract address, and content URI for the version, or zero if not exists.\n   */\n  function getLatest() public view returns (uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI) {\n    return getLatestByMajor(latestMajor);\n  }\n\n  /**\n   * @dev Returns the version with the highest semver identifier for the given major.\n   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will return `1.3.0` for major `1`, \n   * regardless of the order in which they were registered. Returns zero if no versions are registered\n   * for the specified major.\n   * @param major Major identifier to query\n   * @return Semver identifier, contract address, and content URI for the version, or zero if not exists.\n   */\n  function getLatestByMajor(uint64 major) public view returns (uint64[3] memory semanticVersion, address contractAddress, bytes memory contentURI) {\n    Version storage version = versions[majorToLatestVersion[major]];\n    return (version.semanticVersion, version.contractAddress, version.contentURI); \n  }\n\n  function semanticVersionHash(uint64[3] memory version) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(version[0], version[1], version[2]));\n  }\n\n  function semanticVersionIsZero(uint64[3] memory version) internal pure returns (bool) {\n    return version[0] == 0 && version[1] == 0 && version[2] == 0;\n  }\n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/Proxy.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\ncontract Proxy {\n  /**\n   * @dev Fallback function.\n   * Implemented entirely in `_fallback`.\n   */\n  function () payable external {\n    _fallback();\n  }\n\n  /**\n   * @return The Address of the implementation.\n   */\n  function _implementation() internal view returns (address);\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function _delegate(address implementation) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize)\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize)\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize) }\n      default { return(0, returndatasize) }\n    }\n  }\n\n  /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n  function _willFallback() internal {\n  }\n\n  /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n\n// File: @openzeppelin/upgrades/contracts/utils/Address.sol\n\npragma solidity ^0.5.0;\n\n/**\n * Utility library of inline functions on addresses\n *\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\n */\nlibrary OpenZeppelinUpgradesAddress {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/BaseUpgradeabilityProxy.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Returns the current implementation.\n   * @return Address of the current implementation\n   */\n  function _implementation() internal view returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/UpgradeabilityProxy.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title UpgradeabilityProxy\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n * implementation and init data.\n */\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Contract constructor.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, bytes memory _data) public payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/BaseAdminUpgradeabilityProxy.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title BaseAdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @return The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address) {\n    return _admin();\n  }\n\n  /**\n   * @return The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    (bool success,) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @return The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal {\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n    super._willFallback();\n  }\n}\n\n// File: @openzeppelin/upgrades/contracts/upgradeability/AdminUpgradeabilityProxy.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \n * initializing the implementation, admin, and init data.\n */\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n  /**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param _admin Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }\n}\n\n// File: @openzeppelin/upgrades/contracts/application/App.sol\n\npragma solidity ^0.5.0;\n\n\n\n\n\n/**\n * @title App\n * @dev Contract for upgradeable applications.\n * It handles the creation of proxies.\n */\ncontract App is OpenZeppelinUpgradesOwnable {\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param proxy Address of the created proxy.\n   */\n  event ProxyCreated(address proxy);\n\n  /**\n   * @dev Emitted when a package dependency is changed in the application.\n   * @param providerName Name of the package that changed.\n   * @param package Address of the package associated to the name.\n   * @param version Version of the package in use.\n   */\n  event PackageChanged(string providerName, address package, uint64[3] version);\n\n  /**\n   * @dev Tracks a package in a particular version, used for retrieving implementations\n   */\n  struct ProviderInfo {\n    Package package;\n    uint64[3] version;\n  }\n\n  /**\n   * @dev Maps from dependency name to a tuple of package and version\n   */\n  mapping(string => ProviderInfo) internal providers;\n\n  /**\n   * @dev Constructor function.\n   */\n  constructor() public { }\n\n  /**\n   * @dev Returns the provider for a given package name, or zero if not set.\n   * @param packageName Name of the package to be retrieved.\n   * @return The provider.\n   */\n  function getProvider(string memory packageName) public view returns (ImplementationProvider provider) {\n    ProviderInfo storage info = providers[packageName];\n    if (address(info.package) == address(0)) return ImplementationProvider(0);\n    return ImplementationProvider(info.package.getContract(info.version));\n  }\n\n  /**\n   * @dev Returns information on a package given its name.\n   * @param packageName Name of the package to be queried.\n   * @return A tuple with the package address and pinned version given a package name, or zero if not set\n   */\n  function getPackage(string memory packageName) public view returns (Package, uint64[3] memory) {\n    ProviderInfo storage info = providers[packageName];\n    return (info.package, info.version);\n  }\n\n  /**\n   * @dev Sets a package in a specific version as a dependency for this application.\n   * Requires the version to be present in the package.\n   * @param packageName Name of the package to set or overwrite.\n   * @param package Address of the package to register.\n   * @param version Version of the package to use in this application.\n   */\n  function setPackage(string memory packageName, Package package, uint64[3] memory version) public onlyOwner {\n    require(package.hasVersion(version), \"The requested version must be registered in the given package\");\n    providers[packageName] = ProviderInfo(package, version);\n    emit PackageChanged(packageName, address(package), version);\n  }\n\n  /**\n   * @dev Unsets a package given its name.\n   * Reverts if the package is not set in the application.\n   * @param packageName Name of the package to remove.\n   */\n  function unsetPackage(string memory packageName) public onlyOwner {\n    require(address(providers[packageName].package) != address(0), \"Package to unset not found\");\n    delete providers[packageName];\n    emit PackageChanged(packageName, address(0), [uint64(0), uint64(0), uint64(0)]);\n  }\n\n  /**\n   * @dev Returns the implementation address for a given contract name, provided by the `ImplementationProvider`.\n   * @param packageName Name of the package where the contract is contained.\n   * @param contractName Name of the contract.\n   * @return Address where the contract is implemented.\n   */\n  function getImplementation(string memory packageName, string memory contractName) public view returns (address) {\n    ImplementationProvider provider = getProvider(packageName);\n    if (address(provider) == address(0)) return address(0);\n    return provider.getImplementation(contractName);\n  }\n\n  /**\n   * @dev Creates a new proxy for the given contract and forwards a function call to it.\n   * This is useful to initialize the proxied contract.\n   * @param packageName Name of the package where the contract is contained.\n   * @param contractName Name of the contract.\n   * @param admin Address of the proxy administrator.\n   * @param data Data to send as msg.data to the corresponding implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   * @return Address of the new proxy.\n   */\n   function create(string memory packageName, string memory contractName, address admin, bytes memory data) payable public returns (AdminUpgradeabilityProxy) {\n     address implementation = getImplementation(packageName, contractName);\n     AdminUpgradeabilityProxy proxy = (new AdminUpgradeabilityProxy).value(msg.value)(implementation, admin, data);\n     emit ProxyCreated(address(proxy));\n     return proxy;\n  }\n}\n\n// File: contracts/OrganizationFactory.sol\n\npragma solidity ^0.5.6;\n\n\n\n\n\n\n/**\n * @title OrganizationFactory\n *\n * @dev A factory contract that can create new instances of upgradeable\n * 0xORG smart contracts from the `Organization` blueprint published in\n * `wt-contracts` ZeppelinOS package.\n */\ncontract OrganizationFactory is Initializable, AbstractOrganizationFactory {\n    // ZeppelinOS App instance\n    App internal app;\n\n    // Address of the contract owner\n    address _owner;\n\n    // Array of addresses of created `Organization` contracts. We need to keep\n    // track of it because owner of this factory remains the Proxy Owner of\n    // the created smart contracts and is the only account that can change\n    // the implementation or transfer its ownership.\n    address[] _createdOrganizations;\n\n    // Mapping of organizations position in the general created organization index\n    mapping(address => uint) _createdOrganizationsIndex;\n\n    /**\n     * @dev `createOrganization` Create new organization upgradeable contract.\n     * The created proxy's owner is **this Factory owner**.\n     * The created Organizations's ownership is given to `msg.sender`.\n     * This ownership design allows the factory owner to keep the implementation\n     * safe whilst giving the data owner full control over their data.\n     *\n     * See the reasoning on https://github.com/windingtree/wt-contracts/pull/241#issuecomment-501726595\n     * \n     * Emits `OrganizationCreated` on success.\n     * @param  orgJsonUri Organization's data pointer\n     * @param  orgJsonHash Organization's data hash\n     * @return {\" \": \"Address of the new organization.\"}\n     */\n    function createOrganization(string memory orgJsonUri, bytes32 orgJsonHash) internal returns (address) {\n        address newOrganizationAddress = address(\n            app.create(\n                \"wt-contracts\", \n                \"Organization\", \n                _owner, \n                abi.encodeWithSignature(\"initialize(address,string,bytes32)\", msg.sender, orgJsonUri, orgJsonHash)\n            )\n        );\n        emit OrganizationCreated(newOrganizationAddress);\n        _createdOrganizationsIndex[newOrganizationAddress] = _createdOrganizations.length;\n        _createdOrganizations.push(newOrganizationAddress);\n        return newOrganizationAddress;\n    }\n\n    /**\n     * @dev `create` proxies and externalizes createOrganization\n     * @param  orgJsonUri Organization's data pointer\n     * @param  orgJsonHash Organization's data hash\n     * @return {\" \": \"Address of the new organization.\"}\n     */\n    function create(string calldata orgJsonUri, bytes32 orgJsonHash) external returns (address) {\n        return createOrganization(orgJsonUri, orgJsonHash);\n    }\n\n    /**\n     * @dev `createAndAddToDirectory` Creates the organization contract and tries to add it\n     * to a SegmentDirectory living on the passed `directory` address.\n     *\n     * We cannot reuse create call due to the Organization ownership restrictions.\n     * \n     * @param  orgJsonUri Organization's data pointer\n     * @param  orgJsonHash Organization's data hash\n     * @param  directory Segment directory's address\n     * @return {\" \": \"Address of the new organization.\"}\n     */\n    function createAndAddToDirectory(\n        string calldata orgJsonUri,\n        bytes32 orgJsonHash,\n        address directory\n    ) external returns (address) {\n        // TODO rewrite so that directory address gets known from entrypoint #248\n        require(directory != address(0), 'OrganizationFactory: Cannot use directory with 0x0 address');\n        address newOrganizationAddress = address(\n            app.create(\n                \"wt-contracts\", \n                \"Organization\", \n                _owner, \n                abi.encodeWithSignature(\"initialize(address,string,bytes32)\", address(this), orgJsonUri, orgJsonHash)\n            )\n        );\n        AbstractSegmentDirectory sd = AbstractSegmentDirectory(directory);\n        sd.add(newOrganizationAddress);\n        _createdOrganizationsIndex[newOrganizationAddress] = _createdOrganizations.length;\n        _createdOrganizations.push(newOrganizationAddress);\n        Organization o = Organization(newOrganizationAddress);\n        o.transferOwnership(msg.sender);\n        emit OrganizationCreated(newOrganizationAddress);\n        return newOrganizationAddress;\n    }\n\n    /**\n     * @dev Initializer for upgradeable contracts.\n     * @param __owner The address of the contract owner\n     * @param _app ZeppelinOS App address\n     */\n    function initialize(address payable __owner, App _app) public initializer {\n        require(__owner != address(0), 'OrganizationFactory: Cannot set owner to 0x0 address');\n        require(address(_app) != address(0), 'OrganizationFactory: Cannot set app to 0x0 address');\n        _owner = __owner;\n        app = _app;\n        _createdOrganizations.length++;\n    }\n\n    /**\n     * @dev `getCreatedOrganizationsLength` get the length of the `createdOrganizations` array\n     * @return {\" \": \"Length of the organizations array. Might contain zero addresses.\"}\n     */\n    function getCreatedOrganizationsLength() public view returns (uint) {\n        return _createdOrganizations.length;\n    }\n\n    /**\n     * @dev `getCreatedOrganizations` get `createdOrganizations` array\n     * @return {\" \": \"Array of organization addresses. Might contain zero addresses.\"}\n     */\n    function getCreatedOrganizations() public view returns (address[] memory) {\n        return _createdOrganizations;\n    }\n\n    /**\n     * @dev `createdOrganizationsIndex` get index of Organization\n     * @return {\" \": \"Organization index.\"}\n     */\n    function createdOrganizationsIndex(address organization) public view returns (uint) {\n        return _createdOrganizationsIndex[organization];\n    }\n\n    /**\n     * @dev `createdOrganizations` get Organization address on an index\n     * @return {\" \": \"Organization address.\"}\n     */\n    function createdOrganizations(uint index) public view returns (address) {\n        return _createdOrganizations[index];\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == _owner, 'OrganizationFactory: Only owner can call this method');\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address payable newOwner) internal {\n        require(newOwner != address(0), 'OrganizationFactory: Cannot transfer to 0x0 address');\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n}\n","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"organization\",\"type\":\"address\"}],\"name\":\"createdOrganizationsIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCreatedOrganizations\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCreatedOrganizationsLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orgJsonUri\",\"type\":\"string\"},{\"name\":\"orgJsonHash\",\"type\":\"bytes32\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"__owner\",\"type\":\"address\"},{\"name\":\"_app\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"createdOrganizations\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orgJsonUri\",\"type\":\"string\"},{\"name\":\"orgJsonHash\",\"type\":\"bytes32\"},{\"name\":\"directory\",\"type\":\"address\"}],\"name\":\"createAndAddToDirectory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"organization\",\"type\":\"address\"}],\"name\":\"OrganizationCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"OrganizationFactory","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://8c25182a6157dd5541a796e49baf32c9cfddca58a01dbe09eec6459dabfeaa90"}]}