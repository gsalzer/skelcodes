{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\n\n/**\n * @title Interface that every module contract should implement\n */\ninterface IModule {\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() external pure returns(bytes4 initFunction);\n\n    /**\n     * @notice Return the permission flags that are associated with a module\n     */\n    function getPermissions() external view returns(bytes32[] memory permissions);\n\n}\n\n/**\n * @title Utility contract to allow pausing and unpausing of certain functions\n */\ncontract Pausable {\n    event Pause(address account);\n    event Unpause(address account);\n\n    bool public paused = false;\n\n    /**\n    * @notice Modifier to make a function callable only when the contract is not paused.\n    */\n    modifier whenNotPaused() {\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n\n    /**\n    * @notice Modifier to make a function callable only when the contract is paused.\n    */\n    modifier whenPaused() {\n        require(paused, \"Contract is not paused\");\n        _;\n    }\n\n    /**\n    * @notice Called by the owner to pause, triggers stopped state\n    */\n    function _pause() internal whenNotPaused {\n        paused = true;\n        /*solium-disable-next-line security/no-block-members*/\n        emit Pause(msg.sender);\n    }\n\n    /**\n    * @notice Called by the owner to unpause, returns to normal state\n    */\n    function _unpause() internal whenPaused {\n        paused = false;\n        /*solium-disable-next-line security/no-block-members*/\n        emit Unpause(msg.sender);\n    }\n\n}\n\n/**\n * @title Interface that every module factory contract should implement\n */\ninterface IModuleFactory {\n    event ChangeSetupCost(uint256 _oldSetupCost, uint256 _newSetupCost);\n    event ChangeCostType(bool _isOldCostInPoly, bool _isNewCostInPoly);\n    event GenerateModuleFromFactory(\n        address _module,\n        bytes32 indexed _moduleName,\n        address indexed _moduleFactory,\n        address _creator,\n        uint256 _setupCost,\n        uint256 _setupCostInPoly\n    );\n    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);\n\n    //Should create an instance of the Module, or throw\n    function deploy(bytes calldata _data) external returns(address moduleAddress);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function version() external view returns(string memory moduleVersion);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function name() external view returns(bytes32 moduleName);\n\n    /**\n     * @notice Returns the title associated with the module\n     */\n    function title() external view returns(string memory moduleTitle);\n\n    /**\n     * @notice Returns the description associated with the module\n     */\n    function description() external view returns(string memory moduleDescription);\n\n    /**\n     * @notice Get the setup cost of the module in USD\n     */\n    function setupCost() external returns(uint256 usdSetupCost);\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external view returns(uint8[] memory moduleTypes);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external view returns(bytes32[] memory moduleTags);\n\n    /**\n     * @notice Used to change the setup fee\n     * @param _newSetupCost New setup fee\n     */\n    function changeSetupCost(uint256 _newSetupCost) external;\n\n    /**\n     * @notice Used to change the currency and amount setup cost\n     * @param _setupCost new setup cost\n     * @param _isCostInPoly new setup cost currency. USD or POLY\n     */\n    function changeCostAndType(uint256 _setupCost, bool _isCostInPoly) external;\n\n    /**\n     * @notice Function use to change the lower and upper bound of the compatible version st\n     * @param _boundType Type of bound\n     * @param _newVersion New version array\n     */\n    function changeSTVersionBounds(string calldata _boundType, uint8[] calldata _newVersion) external;\n\n    /**\n     * @notice Get the setup cost of the module\n     */\n    function setupCostInPoly() external returns (uint256 polySetupCost);\n\n    /**\n     * @notice Used to get the lower bound\n     * @return Lower bound\n     */\n    function getLowerSTVersionBounds() external view returns(uint8[] memory lowerBounds);\n\n    /**\n     * @notice Used to get the upper bound\n     * @return Upper bound\n     */\n    function getUpperSTVersionBounds() external view returns(uint8[] memory upperBounds);\n\n    /**\n     * @notice Updates the tags of the ModuleFactory\n     * @param _tagsData New list of tags\n     */\n    function changeTags(bytes32[] calldata _tagsData) external;\n\n    /**\n     * @notice Updates the name of the ModuleFactory\n     * @param _name New name that will replace the old one.\n     */\n    function changeName(bytes32 _name) external;\n\n    /**\n     * @notice Updates the description of the ModuleFactory\n     * @param _description New description that will replace the old one.\n     */\n    function changeDescription(string calldata _description) external;\n\n    /**\n     * @notice Updates the title of the ModuleFactory\n     * @param _title New Title that will replace the old one.\n     */\n    function changeTitle(string calldata _title) external;\n\n}\n\ninterface IDataStore {\n    /**\n     * @dev Changes security token atatched to this data store\n     * @param _securityToken address of the security token\n     */\n    function setSecurityToken(address _securityToken) external;\n\n    /**\n     * @dev Stores a uint256 data against a key\n     * @param _key Unique key to identify the data\n     * @param _data Data to be stored against the key\n     */\n    function setUint256(bytes32 _key, uint256 _data) external;\n\n    function setBytes32(bytes32 _key, bytes32 _data) external;\n\n    function setAddress(bytes32 _key, address _data) external;\n\n    function setString(bytes32 _key, string calldata _data) external;\n\n    function setBytes(bytes32 _key, bytes calldata _data) external;\n\n    function setBool(bytes32 _key, bool _data) external;\n\n    /**\n     * @dev Stores a uint256 array against a key\n     * @param _key Unique key to identify the array\n     * @param _data Array to be stored against the key\n     */\n    function setUint256Array(bytes32 _key, uint256[] calldata _data) external;\n\n    function setBytes32Array(bytes32 _key, bytes32[] calldata _data) external ;\n\n    function setAddressArray(bytes32 _key, address[] calldata _data) external;\n\n    function setBoolArray(bytes32 _key, bool[] calldata _data) external;\n\n    /**\n     * @dev Inserts a uint256 element to the array identified by the key\n     * @param _key Unique key to identify the array\n     * @param _data Element to push into the array\n     */\n    function insertUint256(bytes32 _key, uint256 _data) external;\n\n    function insertBytes32(bytes32 _key, bytes32 _data) external;\n\n    function insertAddress(bytes32 _key, address _data) external;\n\n    function insertBool(bytes32 _key, bool _data) external;\n\n    /**\n     * @dev Deletes an element from the array identified by the key.\n     * When an element is deleted from an Array, last element of that array is moved to the index of deleted element.\n     * @param _key Unique key to identify the array\n     * @param _index Index of the element to delete\n     */\n    function deleteUint256(bytes32 _key, uint256 _index) external;\n\n    function deleteBytes32(bytes32 _key, uint256 _index) external;\n\n    function deleteAddress(bytes32 _key, uint256 _index) external;\n\n    function deleteBool(bytes32 _key, uint256 _index) external;\n\n    /**\n     * @dev Stores multiple uint256 data against respective keys\n     * @param _keys Array of keys to identify the data\n     * @param _data Array of data to be stored against the respective keys\n     */\n    function setUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\n\n    function setBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\n\n    function setAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\n\n    function setBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\n\n    /**\n     * @dev Inserts multiple uint256 elements to the array identified by the respective keys\n     * @param _keys Array of keys to identify the data\n     * @param _data Array of data to be inserted in arrays of the respective keys\n     */\n    function insertUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\n\n    function insertBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\n\n    function insertAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\n\n    function insertBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\n\n    function getUint256(bytes32 _key) external view returns(uint256);\n\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    function getAddress(bytes32 _key) external view returns(address);\n\n    function getString(bytes32 _key) external view returns(string memory);\n\n    function getBytes(bytes32 _key) external view returns(bytes memory);\n\n    function getBool(bytes32 _key) external view returns(bool);\n\n    function getUint256Array(bytes32 _key) external view returns(uint256[] memory);\n\n    function getBytes32Array(bytes32 _key) external view returns(bytes32[] memory);\n\n    function getAddressArray(bytes32 _key) external view returns(address[] memory);\n\n    function getBoolArray(bytes32 _key) external view returns(bool[] memory);\n\n    function getUint256ArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getBytes32ArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getAddressArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getBoolArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getUint256ArrayElement(bytes32 _key, uint256 _index) external view returns(uint256);\n\n    function getBytes32ArrayElement(bytes32 _key, uint256 _index) external view returns(bytes32);\n\n    function getAddressArrayElement(bytes32 _key, uint256 _index) external view returns(address);\n\n    function getBoolArrayElement(bytes32 _key, uint256 _index) external view returns(bool);\n\n    function getUint256ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(uint256[] memory);\n\n    function getBytes32ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bytes32[] memory);\n\n    function getAddressArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(address[] memory);\n\n    function getBoolArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bool[] memory);\n}\n\n/**\n * @title Interface for all security tokens\n */\ninterface ISecurityToken {\n    // Standard ERC20 interface\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function decimals() external view returns(uint8);\n    function totalSupply() external view returns(uint256);\n    function balanceOf(address owner) external view returns(uint256);\n    function allowance(address owner, address spender) external view returns(uint256);\n    function transfer(address to, uint256 value) external returns(bool);\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\n    function approve(address spender, uint256 value) external returns(bool);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     * @return byte Ethereum status code (ESC)\n     * @return bytes32 Application specific reason code\n     */\n    function canTransfer(address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\n\n    // Emit at the time when module get added\n    event ModuleAdded(\n        uint8[] _types,\n        bytes32 indexed _name,\n        address indexed _moduleFactory,\n        address _module,\n        uint256 _moduleCost,\n        uint256 _budget,\n        bytes32 _label,\n        bool _archived\n    );\n\n    // Emit when the token details get updated\n    event UpdateTokenDetails(string _oldDetails, string _newDetails);\n    // Emit when the token name get updated\n    event UpdateTokenName(string _oldName, string _newName);\n    // Emit when the granularity get changed\n    event GranularityChanged(uint256 _oldGranularity, uint256 _newGranularity);\n    // Emit when is permanently frozen by the issuer\n    event FreezeIssuance();\n    // Emit when transfers are frozen or unfrozen\n    event FreezeTransfers(bool _status);\n    // Emit when new checkpoint created\n    event CheckpointCreated(uint256 indexed _checkpointId, uint256 _investorLength);\n    // Events to log controller actions\n    event SetController(address indexed _oldController, address indexed _newController);\n    //Event emit when the global treasury wallet address get changed\n    event TreasuryWalletChanged(address _oldTreasuryWallet, address _newTreasuryWallet);\n    event DisableController();\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event TokenUpgraded(uint8 _major, uint8 _minor, uint8 _patch);\n\n    // Emit when Module get archived from the securityToken\n    event ModuleArchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when Module get unarchived from the securityToken\n    event ModuleUnarchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when Module get removed from the securityToken\n    event ModuleRemoved(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when the budget allocated to a module is changed\n    event ModuleBudgetChanged(uint8[] _moduleTypes, address _module, uint256 _oldBudget, uint256 _budget); //Event emitted by the tokenLib.\n\n    // Transfer Events\n    event TransferByPartition(\n        bytes32 indexed _fromPartition,\n        address _operator,\n        address indexed _from,\n        address indexed _to,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    // Operator Events\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n\n    // Issuance / Redemption Events\n    event IssuedByPartition(bytes32 indexed partition, address indexed to, uint256 value, bytes data);\n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\n\n    // Document Events\n    event DocumentRemoved(bytes32 indexed _name, string _uri, bytes32 _documentHash);\n    event DocumentUpdated(bytes32 indexed _name, string _uri, bytes32 _documentHash);\n\n    // Controller Events\n    event ControllerTransfer(\n        address _controller,\n        address indexed _from,\n        address indexed _to,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    event ControllerRedemption(\n        address _controller,\n        address indexed _tokenHolder,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    // Issuance / Redemption Events\n    event Issued(address indexed _operator, address indexed _to, uint256 _value, bytes _data);\n    event Redeemed(address indexed _operator, address indexed _from, uint256 _value, bytes _data);\n\n    /**\n     * @notice Initialization function\n     * @dev Expected to be called atomically with the proxy being created, by the owner of the token\n     * @dev Can only be called once\n     */\n    function initialize(address _getterDelegate) external;\n\n    /**\n     * @notice The standard provides an on-chain function to determine whether a transfer will succeed,\n     * and return details indicating the reason if the transfer is not valid.\n     * @param _from The address from whom the tokens get transferred.\n     * @param _to The address to which to transfer tokens to.\n     * @param _partition The partition from which to transfer tokens\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @return ESC (Ethereum Status Code) following the EIP-1066 standard\n     * @return Application specific reason codes with additional details\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function canTransferByPartition(\n        address _from,\n        address _to,\n        bytes32 _partition,\n        uint256 _value,\n        bytes calldata _data\n    )\n        external\n        view\n        returns (byte statusCode, bytes32 reasonCode, bytes32 partition);\n\n    /**\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     * @return byte Ethereum status code (ESC)\n     * @return bytes32 Application specific reason code\n     */\n    function canTransferFrom(address _from, address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\n\n    /**\n     * @notice Used to attach a new document to the contract, or update the URI or hash of an existing attached document\n     * @dev Can only be executed by the owner of the contract.\n     * @param _name Name of the document. It should be unique always\n     * @param _uri Off-chain uri of the document from where it is accessible to investors/advisors to read.\n     * @param _documentHash hash (of the contents) of the document.\n     */\n    function setDocument(bytes32 _name, string calldata _uri, bytes32 _documentHash) external;\n\n    /**\n     * @notice Used to remove an existing document from the contract by giving the name of the document.\n     * @dev Can only be executed by the owner of the contract.\n     * @param _name Name of the document. It should be unique always\n     */\n    function removeDocument(bytes32 _name) external;\n\n    /**\n     * @notice Used to return the details of a document with a known name (`bytes32`).\n     * @param _name Name of the document\n     * @return string The URI associated with the document.\n     * @return bytes32 The hash (of the contents) of the document.\n     * @return uint256 the timestamp at which the document was last modified.\n     */\n    function getDocument(bytes32 _name) external view returns (string memory documentUri, bytes32 documentHash, uint256 documentTime);\n\n    /**\n     * @notice Used to retrieve a full list of documents attached to the smart contract.\n     * @return bytes32 List of all documents names present in the contract.\n     */\n    function getAllDocuments() external view returns (bytes32[] memory documentNames);\n\n    /**\n     * @notice In order to provide transparency over whether `controllerTransfer` / `controllerRedeem` are useable\n     * or not `isControllable` function will be used.\n     * @dev If `isControllable` returns `false` then it always return `false` and\n     * `controllerTransfer` / `controllerRedeem` will always revert.\n     * @return bool `true` when controller address is non-zero otherwise return `false`.\n     */\n    function isControllable() external view returns (bool controlled);\n\n    /**\n     * @notice Checks if an address is a module of certain type\n     * @param _module Address to check\n     * @param _type type to check against\n     */\n    function isModule(address _module, uint8 _type) external view returns(bool isValid);\n\n    /**\n     * @notice This function must be called to increase the total supply (Corresponds to mint function of ERC20).\n     * @dev It only be called by the token issuer or the operator defined by the issuer. ERC1594 doesn't have\n     * have the any logic related to operator but its superset ERC1400 have the operator logic and this function\n     * is allowed to call by the operator.\n     * @param _tokenHolder The account that will receive the created tokens (account should be whitelisted or KYCed).\n     * @param _value The amount of tokens need to be issued\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     */\n    function issue(address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice issue new tokens and assigns them to the target _tokenHolder.\n     * @dev Can only be called by the issuer or STO attached to the token.\n     * @param _tokenHolders A list of addresses to whom the minted tokens will be dilivered\n     * @param _values A list of number of tokens get minted and transfer to corresponding address of the investor from _tokenHolders[] list\n     * @return success\n     */\n    function issueMulti(address[] calldata _tokenHolders, uint256[] calldata _values) external;\n\n    /**\n     * @notice Increases totalSupply and the corresponding amount of the specified owners partition\n     * @param _partition The partition to allocate the increase in balance\n     * @param _tokenHolder The token holder whose balance should be increased\n     * @param _value The amount by which to increase the balance\n     * @param _data Additional data attached to the minting of tokens\n     */\n    function issueByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of msg.sender\n     * @param _partition The partition to allocate the decrease in balance\n     * @param _value The amount by which to decrease the balance\n     * @param _data Additional data attached to the burning of tokens\n     */\n    function redeemByPartition(bytes32 _partition, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\n     * are out of the scope of the ERC1594.\n     * @param _value The amount of tokens need to be redeemed\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\n     */\n    function redeem(uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\n     * are out of the scope of the ERC1594.\n     * @dev It is analogy to `transferFrom`\n     * @param _tokenHolder The account whose tokens gets redeemed.\n     * @param _value The amount of tokens need to be redeemed\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\n     */\n    function redeemFrom(address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of tokenHolder\n     * @dev This function can only be called by the authorised operator.\n     * @param _partition The partition to allocate the decrease in balance.\n     * @param _tokenHolder The token holder whose balance should be decreased\n     * @param _value The amount by which to decrease the balance\n     * @param _data Additional data attached to the burning of tokens\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\n     */\n    function operatorRedeemByPartition(\n        bytes32 _partition,\n        address _tokenHolder,\n        uint256 _value,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    ) external;\n\n    /**\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n     * @param _delegate address of delegate\n     * @param _module address of PermissionManager module\n     * @param _perm the permissions\n     * @return success\n     */\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPermission);\n\n    /**\n     * @notice Returns module list for a module type\n     * @param _module Address of the module\n     * @return bytes32 Name\n     * @return address Module address\n     * @return address Module factory address\n     * @return bool Module archived\n     * @return uint8 Array of module types\n     * @return bytes32 Module label\n     */\n    function getModule(address _module) external view returns (bytes32 moduleName, address moduleAddress, address factoryAddress, bool isArchived, uint8[] memory moduleTypes, bytes32 moduleLabel);\n\n    /**\n     * @notice Returns module list for a module name\n     * @param _name Name of the module\n     * @return address[] List of modules with this name\n     */\n    function getModulesByName(bytes32 _name) external view returns(address[] memory modules);\n\n    /**\n     * @notice Returns module list for a module type\n     * @param _type Type of the module\n     * @return address[] List of modules with this type\n     */\n    function getModulesByType(uint8 _type) external view returns(address[] memory modules);\n\n    /**\n     * @notice use to return the global treasury wallet\n     */\n    function getTreasuryWallet() external view returns(address treasuryWallet);\n\n    /**\n     * @notice Queries totalSupply at a specified checkpoint\n     * @param _checkpointId Checkpoint ID to query as of\n     */\n    function totalSupplyAt(uint256 _checkpointId) external view returns(uint256 supply);\n\n    /**\n     * @notice Queries balance at a specified checkpoint\n     * @param _investor Investor to query balance for\n     * @param _checkpointId Checkpoint ID to query as of\n     */\n    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns(uint256 balance);\n\n    /**\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\n     */\n    function createCheckpoint() external returns(uint256 checkpointId);\n\n    /**\n     * @notice Gets list of times that checkpoints were created\n     * @return List of checkpoint times\n     */\n    function getCheckpointTimes() external view returns(uint256[] memory checkpointTimes);\n\n    /**\n     * @notice returns an array of investors\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\n     * @return list of addresses\n     */\n    function getInvestors() external view returns(address[] memory investors);\n\n    /**\n     * @notice returns an array of investors at a given checkpoint\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\n     * @return list of investors\n     */\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[] memory investors);\n\n    /**\n     * @notice returns an array of investors with non zero balance at a given checkpoint\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\n     * @param _start Position of investor to start iteration from\n     * @param _end Position of investor to stop iteration at\n     * @return list of investors\n     */\n    function getInvestorsSubsetAt(uint256 _checkpointId, uint256 _start, uint256 _end) external view returns(address[] memory investors);\n\n    /**\n     * @notice generates subset of investors\n     * NB - can be used in batches if investor list is large\n     * @param _start Position of investor to start iteration from\n     * @param _end Position of investor to stop iteration at\n     * @return list of investors\n     */\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[] memory investors);\n\n    /**\n     * @notice Gets current checkpoint ID\n     * @return Id\n     */\n    function currentCheckpointId() external view returns(uint256 checkpointId);\n\n    /**\n     * @notice Determines whether `_operator` is an operator for all partitions of `_tokenHolder`\n     * @param _operator The operator to check\n     * @param _tokenHolder The token holder to check\n     * @return Whether the `_operator` is an operator for all partitions of `_tokenHolder`\n     */\n    function isOperator(address _operator, address _tokenHolder) external view returns (bool isValid);\n\n    /**\n     * @notice Determines whether `_operator` is an operator for a specified partition of `_tokenHolder`\n     * @param _partition The partition to check\n     * @param _operator The operator to check\n     * @param _tokenHolder The token holder to check\n     * @return Whether the `_operator` is an operator for a specified partition of `_tokenHolder`\n     */\n    function isOperatorForPartition(bytes32 _partition, address _operator, address _tokenHolder) external view returns (bool isValid);\n\n    /**\n     * @notice Return all partitions\n     * @param _tokenHolder Whom balance need to queried\n     * @return List of partitions\n     */\n    function partitionsOf(address _tokenHolder) external view returns (bytes32[] memory partitions);\n\n    /**\n     * @notice Gets data store address\n     * @return data store address\n     */\n    function dataStore() external view returns (address dataStoreAddress);\n\n    /**\n    * @notice Allows owner to change data store\n    * @param _dataStore Address of the token data store\n    */\n    function changeDataStore(address _dataStore) external;\n\n\n    /**\n     * @notice Allows to change the treasury wallet address\n     * @param _wallet Ethereum address of the treasury wallet\n     */\n    function changeTreasuryWallet(address _wallet) external;\n\n    /**\n     * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\n     * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\n     * @param _tokenContract Address of the ERC20Basic compliance token\n     * @param _value Amount of POLY to withdraw\n     */\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\n\n    /**\n    * @notice Allows owner to increase/decrease POLY approval of one of the modules\n    * @param _module Module address\n    * @param _change Change in allowance\n    * @param _increase True if budget has to be increased, false if decrease\n    */\n    function changeModuleBudget(address _module, uint256 _change, bool _increase) external;\n\n    /**\n     * @notice Changes the tokenDetails\n     * @param _newTokenDetails New token details\n     */\n    function updateTokenDetails(string calldata _newTokenDetails) external;\n\n    /**\n    * @notice Allows owner to change token name\n    * @param _name new name of the token\n    */\n    function changeName(string calldata _name) external;\n\n    /**\n    * @notice Allows the owner to change token granularity\n    * @param _granularity Granularity level of the token\n    */\n    function changeGranularity(uint256 _granularity) external;\n\n    /**\n     * @notice Freezes all the transfers\n     */\n    function freezeTransfers() external;\n\n    /**\n     * @notice Un-freezes all the transfers\n     */\n    function unfreezeTransfers() external;\n\n    /**\n     * @notice Permanently freeze issuance of this security token.\n     * @dev It MUST NOT be possible to increase `totalSuppy` after this function is called.\n     */\n    function freezeIssuance(bytes calldata _signature) external;\n\n    /**\n      * @notice Attachs a module to the SecurityToken\n      * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\n      * @dev to control restrictions on transfers.\n      * @param _moduleFactory is the address of the module factory to be added\n      * @param _data is data packed into bytes used to further configure the module (See STO usage)\n      * @param _maxCost max amount of POLY willing to pay to the module.\n      * @param _budget max amount of ongoing POLY willing to assign to the module.\n      * @param _label custom module label.\n      * @param _archived whether to add the module as an archived module\n      */\n    function addModuleWithLabel(\n        address _moduleFactory,\n        bytes calldata _data,\n        uint256 _maxCost,\n        uint256 _budget,\n        bytes32 _label,\n        bool _archived\n    ) external;\n\n    /**\n     * @notice Function used to attach a module to the security token\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\n     * @dev to control restrictions on transfers.\n     * @dev You are allowed to add a new moduleType if:\n     * @dev - there is no existing module of that type yet added\n     * @dev - the last member of the module list is replacable\n     * @param _moduleFactory is the address of the module factory to be added\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\n     * @param _budget max amount of ongoing POLY willing to assign to the module.\n     * @param _archived whether to add the module as an archived module\n     */\n    function addModule(address _moduleFactory, bytes calldata _data, uint256 _maxCost, uint256 _budget, bool _archived) external;\n\n    /**\n    * @notice Archives a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function archiveModule(address _module) external;\n\n    /**\n    * @notice Unarchives a module attached to the SecurityToken\n    * @param _module address of module to unarchive\n    */\n    function unarchiveModule(address _module) external;\n\n    /**\n    * @notice Removes a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function removeModule(address _module) external;\n\n    /**\n     * @notice Used by the issuer to set the controller addresses\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) external;\n\n    /**\n     * @notice This function allows an authorised address to transfer tokens between any two token holders.\n     * The transfer must still respect the balances of the token holders (so the transfer must be for at most\n     * `balanceOf(_from)` tokens) and potentially also need to respect other transfer restrictions.\n     * @dev This function can only be executed by the `controller` address.\n     * @param _from Address The address which you want to send tokens from\n     * @param _to Address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\n     * because use of `_data` parameter is implementation specific).\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\n     */\n    function controllerTransfer(address _from, address _to, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\n\n    /**\n     * @notice This function allows an authorised address to redeem tokens for any token holder.\n     * The redemption must still respect the balances of the token holder (so the redemption must be for at most\n     * `balanceOf(_tokenHolder)` tokens) and potentially also need to respect other transfer restrictions.\n     * @dev This function can only be executed by the `controller` address.\n     * @param _tokenHolder The account whose tokens will be redeemed.\n     * @param _value uint256 the amount of tokens need to be redeemed.\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\n     * because use of `_data` parameter is implementation specific).\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\n     */\n    function controllerRedeem(address _tokenHolder, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\n\n    /**\n     * @notice Used by the issuer to permanently disable controller functionality\n     * @dev enabled via feature switch \"disableControllerAllowed\"\n     */\n    function disableController(bytes calldata _signature) external;\n\n    /**\n     * @notice Used to get the version of the securityToken\n     */\n    function getVersion() external view returns(uint8[] memory version);\n\n    /**\n     * @notice Gets the investor count\n     */\n    function getInvestorCount() external view returns(uint256 investorCount);\n\n    /**\n     * @notice Gets the holder count (investors with non zero balance)\n     */\n    function holderCount() external view returns(uint256 count);\n\n    /**\n      * @notice Overloaded version of the transfer function\n      * @param _to receiver of transfer\n      * @param _value value of transfer\n      * @param _data data to indicate validation\n      * @return bool success\n      */\n    function transferWithData(address _to, uint256 _value, bytes calldata _data) external;\n\n    /**\n      * @notice Overloaded version of the transferFrom function\n      * @param _from sender of transfer\n      * @param _to receiver of transfer\n      * @param _value value of transfer\n      * @param _data data to indicate validation\n      * @return bool success\n      */\n    function transferFromWithData(address _from, address _to, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\n     * @param _partition The partition from which to transfer tokens\n     * @param _to The address to which to transfer tokens to\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function transferByPartition(bytes32 _partition, address _to, uint256 _value, bytes calldata _data) external returns (bytes32 partition);\n\n    /**\n     * @notice Get the balance according to the provided partitions\n     * @param _partition Partition which differentiate the tokens.\n     * @param _tokenHolder Whom balance need to queried\n     * @return Amount of tokens as per the given partitions\n     */\n    function balanceOfByPartition(bytes32 _partition, address _tokenHolder) external view returns(uint256 balance);\n\n    /**\n      * @notice Provides the granularity of the token\n      * @return uint256\n      */\n    function granularity() external view returns(uint256 granularityAmount);\n\n    /**\n      * @notice Provides the address of the polymathRegistry\n      * @return address\n      */\n    function polymathRegistry() external view returns(address registryAddress);\n\n    /**\n    * @notice Upgrades a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function upgradeModule(address _module) external;\n\n    /**\n    * @notice Upgrades security token\n    */\n    function upgradeToken() external;\n\n    /**\n     * @notice A security token issuer can specify that issuance has finished for the token\n     * (i.e. no new tokens can be minted or issued).\n     * @dev If a token returns FALSE for `isIssuable()` then it MUST always return FALSE in the future.\n     * If a token returns FALSE for `isIssuable()` then it MUST never allow additional tokens to be issued.\n     * @return bool `true` signifies the minting is allowed. While `false` denotes the end of minting\n     */\n    function isIssuable() external view returns (bool issuable);\n\n    /**\n     * @notice Authorises an operator for all partitions of `msg.sender`.\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\n     * @param _operator An address which is being authorised.\n     */\n    function authorizeOperator(address _operator) external;\n\n    /**\n     * @notice Revokes authorisation of an operator previously given for all partitions of `msg.sender`.\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\n     * @param _operator An address which is being de-authorised\n     */\n    function revokeOperator(address _operator) external;\n\n    /**\n     * @notice Authorises an operator for a given partition of `msg.sender`\n     * @param _partition The partition to which the operator is authorised\n     * @param _operator An address which is being authorised\n     */\n    function authorizeOperatorByPartition(bytes32 _partition, address _operator) external;\n\n    /**\n     * @notice Revokes authorisation of an operator previously given for a specified partition of `msg.sender`\n     * @param _partition The partition to which the operator is de-authorised\n     * @param _operator An address which is being de-authorised\n     */\n    function revokeOperatorByPartition(bytes32 _partition, address _operator) external;\n\n    /**\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\n     * @param _partition The partition from which to transfer tokens.\n     * @param _from The address from which to transfer tokens from\n     * @param _to The address to which to transfer tokens to\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function operatorTransferByPartition(\n        bytes32 _partition,\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    )\n        external\n        returns (bytes32 partition);\n\n    /*\n    * @notice Returns if transfers are currently frozen or not\n    */\n    function transfersFrozen() external view returns (bool isFrozen);\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) external;\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() external view returns (bool);\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() external view returns (address ownerAddress);\n\n    function controller() external view returns(address controllerAddress);\n\n    function moduleRegistry() external view returns(address moduleRegistryAddress);\n\n    function securityTokenRegistry() external view returns(address securityTokenRegistryAddress);\n\n    function polyToken() external view returns(address polyTokenAddress);\n\n    function tokenFactory() external view returns(address tokenFactoryAddress);\n\n    function getterDelegate() external view returns(address delegate);\n\n    function controllerDisabled() external view returns(bool isDisabled);\n\n    function initialized() external view returns(bool isInitialized);\n\n    function tokenDetails() external view returns(string memory details);\n\n    function updateFromRegistry() external;\n\n}\n\ninterface ICheckPermission {\n    /**\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n     * @param _delegate address of delegate\n     * @param _module address of PermissionManager module\n     * @param _perm the permissions\n     * @return success\n     */\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPerm);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Storage for Module contract\n * @notice Contract is abstract\n */\ncontract ModuleStorage {\n    address public factory;\n\n    ISecurityToken public securityToken;\n\n    // Permission flag\n    bytes32 public constant ADMIN = \"ADMIN\";\n    bytes32 public constant OPERATOR = \"OPERATOR\";\n\n    bytes32 internal constant TREASURY = 0xaae8817359f3dcb67d050f44f3e49f982e0359d90ca4b5f18569926304aaece6; // keccak256(abi.encodePacked(\"TREASURY_WALLET\"))\n\n    IERC20 public polyToken;\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor(address _securityToken, address _polyAddress) public {\n        securityToken = ISecurityToken(_securityToken);\n        factory = msg.sender;\n        polyToken = IERC20(_polyAddress);\n    }\n\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     * @notice Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @title Interface that any module contract should implement\n * @notice Contract is abstract\n */\ncontract Module is IModule, ModuleStorage, Pausable {\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     */\n    constructor (address _securityToken, address _polyAddress) public\n    ModuleStorage(_securityToken, _polyAddress)\n    {\n    }\n\n    //Allows owner, factory or permissioned delegate\n    modifier withPerm(bytes32 _perm) {\n        require(_checkPerm(_perm, msg.sender), \"Invalid permission\");\n        _;\n    }\n\n    function _checkPerm(bytes32 _perm, address _caller) internal view returns (bool) {\n        bool isOwner = _caller == Ownable(address(securityToken)).owner();\n        bool isFactory = _caller == factory;\n        return isOwner || isFactory || ICheckPermission(address(securityToken)).checkPermission(_caller, address(this), _perm);\n    }\n\n    function _onlySecurityTokenOwner() internal view {\n        require(msg.sender == Ownable(address(securityToken)).owner(), \"Sender is not owner\");\n    }\n\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Sender is not factory\");\n        _;\n    }\n\n    /**\n     * @notice Pause (overridden function)\n     */\n    function pause() public {\n        _onlySecurityTokenOwner();\n        super._pause();\n    }\n\n    /**\n     * @notice Unpause (overridden function)\n     */\n    function unpause() public {\n        _onlySecurityTokenOwner();\n        super._unpause();\n    }\n\n    /**\n     * @notice used to return the data store address of securityToken\n     */\n    function getDataStore() public view returns(IDataStore) {\n        return IDataStore(securityToken.dataStore());\n    }\n\n    /**\n    * @notice Reclaims ERC20Basic compatible tokens\n    * @dev We duplicate here due to the overriden owner & onlyOwner\n    * @param _tokenContract The address of the token contract\n    */\n    function reclaimERC20(address _tokenContract) external {\n        _onlySecurityTokenOwner();\n        require(_tokenContract != address(0), \"Invalid address\");\n        IERC20 token = IERC20(_tokenContract);\n        uint256 balance = token.balanceOf(address(this));\n        require(token.transfer(msg.sender, balance), \"Transfer failed\");\n    }\n\n   /**\n    * @notice Reclaims ETH\n    * @dev We duplicate here due to the overriden owner & onlyOwner\n    */\n    function reclaimETH() external {\n        _onlySecurityTokenOwner();\n        msg.sender.transfer(address(this).balance);\n    }\n}\n\n/**\n * @title Interface to be implemented by all Transfer Manager modules\n */\ninterface ITransferManager {\n    //  If verifyTransfer returns:\n    //  FORCE_VALID, the transaction will always be valid, regardless of other TM results\n    //  INVALID, then the transfer should not be allowed regardless of other TM results\n    //  VALID, then the transfer is valid for this TM\n    //  NA, then the result from this TM is ignored\n    enum Result {INVALID, NA, VALID, FORCE_VALID}\n\n    /**\n     * @notice Determines if the transfer between these two accounts can happen\n     */\n    function executeTransfer(address _from, address _to, uint256 _amount, bytes calldata _data) external returns(Result result);\n\n    function verifyTransfer(address _from, address _to, uint256 _amount, bytes calldata _data) external view returns(Result result, bytes32 partition);\n\n    /**\n     * @notice return the amount of tokens for a given user as per the partition\n     * @param _partition Identifier\n     * @param _tokenHolder Whom token amount need to query\n     * @param _additionalBalance It is the `_value` that transfer during transfer/transferFrom function call\n     */\n    function getTokensByPartition(bytes32 _partition, address _tokenHolder, uint256 _additionalBalance) external view returns(uint256 amount);\n\n}\n\n/**\n * @title Base abstract contract to be implemented by all Transfer Manager modules\n */\ncontract TransferManager is ITransferManager, Module {\n\n    bytes32 public constant LOCKED = \"LOCKED\";\n    bytes32 public constant UNLOCKED = \"UNLOCKED\";\n\n    modifier onlySecurityToken() {\n        require(msg.sender == address(securityToken), \"Sender is not owner\");\n        _;\n    }\n\n    // Provide default versions of ERC1410 functions that can be overriden\n\n    /**\n     * @notice return the amount of tokens for a given user as per the partition\n     * @dev returning the balance of token holder against the UNLOCKED partition. \n     * This condition is valid only when the base contract doesn't implement the\n     * `getTokensByPartition()` function.  \n     */\n    function getTokensByPartition(bytes32 _partition, address _tokenHolder, uint256 /*_additionalBalance*/) external view returns(uint256) {\n        if (_partition == UNLOCKED)\n            return securityToken.balanceOf(_tokenHolder);\n        return uint256(0);\n    }\n\n}\n\nlibrary Encoder {\n    function getKey(string memory _key) internal pure returns(bytes32) {\n        return bytes32(keccak256(abi.encodePacked(_key)));\n    }\n\n    function getKey(string memory _key1, address _key2) internal pure returns(bytes32) {\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\n    }\n\n    function getKey(string memory _key1, string memory _key2) internal pure returns(bytes32) {\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\n    }\n\n    function getKey(string memory _key1, uint256 _key2) internal pure returns(bytes32) {\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\n    }\n\n    function getKey(string memory _key1, bytes32 _key2) internal pure returns(bytes32) {\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\n    }\n\n    function getKey(string memory _key1, bool _key2) internal pure returns(bytes32) {\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\n    }\n\n}\n\n/**\n * @title Helper library use to compare or validate the semantic versions\n */\n\nlibrary VersionUtils {\n\n    function lessThanOrEqual(uint8[] memory _current, uint8[] memory _new) internal pure returns(bool) {\n        require(_current.length == 3);\n        require(_new.length == 3);\n        uint8 i = 0;\n        for (i = 0; i < _current.length; i++) {\n            if (_current[i] == _new[i]) continue;\n            if (_current[i] < _new[i]) return true;\n            if (_current[i] > _new[i]) return false;\n        }\n        return true;\n    }\n\n    function greaterThanOrEqual(uint8[] memory _current, uint8[] memory _new) internal pure returns(bool) {\n        require(_current.length == 3);\n        require(_new.length == 3);\n        uint8 i = 0;\n        for (i = 0; i < _current.length; i++) {\n            if (_current[i] == _new[i]) continue;\n            if (_current[i] > _new[i]) return true;\n            if (_current[i] < _new[i]) return false;\n        }\n        return true;\n    }\n\n    /**\n     * @notice Used to pack the uint8[] array data into uint24 value\n     * @param _major Major version\n     * @param _minor Minor version\n     * @param _patch Patch version\n     */\n    function pack(uint8 _major, uint8 _minor, uint8 _patch) internal pure returns(uint24) {\n        return (uint24(_major) << 16) | (uint24(_minor) << 8) | uint24(_patch);\n    }\n\n    /**\n     * @notice Used to convert packed data into uint8 array\n     * @param _packedVersion Packed data\n     */\n    function unpack(uint24 _packedVersion) internal pure returns(uint8[] memory) {\n        uint8[] memory _unpackVersion = new uint8[](3);\n        _unpackVersion[0] = uint8(_packedVersion >> 16);\n        _unpackVersion[1] = uint8(_packedVersion >> 8);\n        _unpackVersion[2] = uint8(_packedVersion);\n        return _unpackVersion;\n    }\n\n\n    /**\n     * @notice Used to packed the KYC data\n     */\n    function packKYC(uint64 _a, uint64 _b, uint64 _c, uint8 _d) internal pure returns(uint256) {\n        // this function packs 3 uint64 and a uint8 together in a uint256 to save storage cost\n        // a is rotated left by 136 bits, b is rotated left by 72 bits and c is rotated left by 8 bits.\n        // rotation pads empty bits with zeroes so now we can safely do a bitwise OR operation to pack\n        // all the variables together.\n        return (uint256(_a) << 136) | (uint256(_b) << 72) | (uint256(_c) << 8) | uint256(_d);\n    }\n\n    /**\n     * @notice Used to convert packed data into KYC data\n     * @param _packedVersion Packed data\n     */\n    function unpackKYC(uint256 _packedVersion) internal pure returns(uint64 canSendAfter, uint64 canReceiveAfter, uint64 expiryTime, uint8 added) {\n        canSendAfter = uint64(_packedVersion >> 136);\n        canReceiveAfter = uint64(_packedVersion >> 72);\n        expiryTime = uint64(_packedVersion >> 8);\n        added = uint8(_packedVersion);\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n/**\n * @title Elliptic curve signature operations\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\n * See https://github.com/ethereum/solidity/issues/864\n */\n\nlibrary ECDSA {\n    /**\n     * @dev Recover signer address from a message by using their signature\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * toEthSignedMessageHash\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\n     * and hash the result\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\n/**\n * @title Transfer Manager module for core transfer validation functionality\n */\ncontract GeneralTransferManagerStorage {\n\n    bytes32 public constant WHITELIST = \"WHITELIST\";\n    bytes32 public constant INVESTORSKEY = 0xdf3a8dd24acdd05addfc6aeffef7574d2de3f844535ec91e8e0f3e45dba96731; //keccak256(abi.encodePacked(\"INVESTORS\"))\n    bytes32 public constant INVESTORFLAGS = \"INVESTORFLAGS\";\n    uint256 internal constant ONE = uint256(1);\n\n    enum TransferType { GENERAL, ISSUANCE, REDEMPTION }\n\n    //Address from which issuances come\n    address public issuanceAddress;\n\n    // Allows all TimeRestrictions to be offset\n    struct Defaults {\n        uint64 canSendAfter;\n        uint64 canReceiveAfter;\n    }\n\n    // Offset to be applied to all timings (except KYC expiry)\n    Defaults public defaults;\n\n    // Map of used nonces by customer\n    mapping(address => mapping(uint256 => bool)) public nonceMap;\n\n    struct TransferRequirements {\n        bool fromValidKYC;\n        bool toValidKYC;\n        bool fromRestricted;\n        bool toRestricted;\n    }\n\n    mapping(uint8 => TransferRequirements) public transferRequirements;\n    // General = 0, Issuance = 1, Redemption = 2\n}\n\n/**\n * @title Transfer Manager module for core transfer validation functionality\n */\ncontract GeneralTransferManager is GeneralTransferManagerStorage, TransferManager {\n    using SafeMath for uint256;\n    using ECDSA for bytes32;\n\n    // Emit when Issuance address get changed\n    event ChangeIssuanceAddress(address _issuanceAddress);\n\n    // Emit when investor details get modified related to their whitelisting\n    event ChangeDefaults(uint64 _defaultCanSendAfter, uint64 _defaultCanReceiveAfter);\n\n    // _canSendAfter is the time from which the _investor can send tokens\n    // _canReceiveAfter is the time from which the _investor can receive tokens\n    // if allowAllWhitelistIssuances is TRUE, then _canReceiveAfter is ignored when receiving tokens from the issuance address\n    // if allowAllWhitelistTransfers is TRUE, then _canReceiveAfter and _canSendAfter is ignored when sending or receiving tokens\n    // in any case, any investor sending or receiving tokens, must have a _expiryTime in the future\n    event ModifyKYCData(\n        address indexed _investor,\n        address indexed _addedBy,\n        uint64 _canSendAfter,\n        uint64 _canReceiveAfter,\n        uint64 _expiryTime\n    );\n\n    event ModifyInvestorFlag(\n        address indexed _investor,\n        uint8 indexed _flag,\n        bool _value\n    );\n\n    event ModifyTransferRequirements(\n        TransferType indexed _transferType,\n        bool _fromValidKYC,\n        bool _toValidKYC,\n        bool _fromRestricted,\n        bool _toRestricted\n    );\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     */\n    constructor(address _securityToken, address _polyToken)\n    public\n    Module(_securityToken, _polyToken)\n    {\n\n    }\n\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() public pure returns(bytes4) {\n        return bytes4(0);\n    }\n\n    /**\n     * @notice Used to change the default times used when canSendAfter / canReceiveAfter are zero\n     * @param _defaultCanSendAfter default for zero canSendAfter\n     * @param _defaultCanReceiveAfter default for zero canReceiveAfter\n     */\n    function changeDefaults(uint64 _defaultCanSendAfter, uint64 _defaultCanReceiveAfter) public withPerm(ADMIN) {\n        /* 0 values are also allowed as they represent that the Issuer\n           does not want a default value for these variables.\n           0 is also the default value of these variables */\n        defaults.canSendAfter = _defaultCanSendAfter;\n        defaults.canReceiveAfter = _defaultCanReceiveAfter;\n        emit ChangeDefaults(_defaultCanSendAfter, _defaultCanReceiveAfter);\n    }\n\n    /**\n     * @notice Used to change the Issuance Address\n     * @param _issuanceAddress new address for the issuance\n     */\n    function changeIssuanceAddress(address _issuanceAddress) public withPerm(ADMIN) {\n        // address(0x0) is also a valid value and in most cases, the address that issues tokens is 0x0.\n        issuanceAddress = _issuanceAddress;\n        emit ChangeIssuanceAddress(_issuanceAddress);\n    }\n\n    /**\n     * @notice Default implementation of verifyTransfer used by SecurityToken\n     * If the transfer request comes from the STO, it only checks that the investor is in the whitelist\n     * If the transfer request comes from a token holder, it checks that:\n     * a) Both are on the whitelist\n     * b) Seller's sale lockup period is over\n     * c) Buyer's purchase lockup is over\n     * @param _from Address of the sender\n     * @param _to Address of the receiver\n    */\n    function executeTransfer(\n        address _from,\n        address _to,\n        uint256 /*_amount*/,\n        bytes calldata _data\n    ) external returns(Result) {\n        if (_data.length > 32) {\n            address target;\n            uint256 nonce;\n            uint256 validFrom;\n            uint256 validTo;\n            bytes memory data;\n            (target, nonce, validFrom, validTo, data) = abi.decode(_data, (address, uint256, uint256, uint256, bytes));\n            if (target == address(this))\n                _processTransferSignature(nonce, validFrom, validTo, data);\n        }\n        (Result success,) = _verifyTransfer(_from, _to);\n        return success;\n    }\n\n    function _processTransferSignature(uint256 _nonce, uint256 _validFrom, uint256 _validTo, bytes memory _data) internal {\n        address[] memory investor;\n        uint256[] memory canSendAfter;\n        uint256[] memory canReceiveAfter;\n        uint256[] memory expiryTime;\n        bytes memory signature;\n        (investor, canSendAfter, canReceiveAfter, expiryTime, signature) =\n            abi.decode(_data, (address[], uint256[], uint256[], uint256[], bytes));\n        _modifyKYCDataSignedMulti(investor, canSendAfter, canReceiveAfter, expiryTime, _validFrom, _validTo, _nonce, signature);\n    }\n\n    /**\n     * @notice Default implementation of verifyTransfer used by SecurityToken\n     * @param _from Address of the sender\n     * @param _to Address of the receiver\n    */\n    function verifyTransfer(\n        address _from,\n        address _to,\n        uint256 /*_amount*/,\n        bytes memory /* _data */\n    )\n        public\n        view\n        returns(Result, bytes32)\n    {\n        return _verifyTransfer(_from, _to);\n    }\n\n    function _verifyTransfer(\n        address _from,\n        address _to\n    )\n        internal\n        view\n        returns(Result, bytes32)\n    {\n        if (!paused) {\n            TransferRequirements memory txReq;\n            uint64 canSendAfter;\n            uint64 fromExpiry;\n            uint64 toExpiry;\n            uint64 canReceiveAfter;\n\n            if (_from == issuanceAddress) {\n                txReq = transferRequirements[uint8(TransferType.ISSUANCE)];\n            } else if (_to == address(0)) {\n                txReq = transferRequirements[uint8(TransferType.REDEMPTION)];\n            } else {\n                txReq = transferRequirements[uint8(TransferType.GENERAL)];\n            }\n\n            (canSendAfter, fromExpiry, canReceiveAfter, toExpiry) = _getValuesForTransfer(_from, _to);\n\n            if ((txReq.fromValidKYC && !_validExpiry(fromExpiry)) || (txReq.toValidKYC && !_validExpiry(toExpiry))) {\n                return (Result.NA, bytes32(0));\n            }\n\n            (canSendAfter, canReceiveAfter) = _adjustTimes(canSendAfter, canReceiveAfter);\n\n            if ((txReq.fromRestricted && !_validLockTime(canSendAfter)) || (txReq.toRestricted && !_validLockTime(canReceiveAfter))) {\n                return (Result.NA, bytes32(0));\n            }\n\n            return (Result.VALID, getAddressBytes32());\n        }\n        return (Result.NA, bytes32(0));\n    }\n\n    /**\n    * @notice Modifies the successful checks required for a transfer to be deemed valid.\n    * @param _transferType Type of transfer (0 = General, 1 = Issuance, 2 = Redemption)\n    * @param _fromValidKYC Defines if KYC is required for the sender\n    * @param _toValidKYC Defines if KYC is required for the receiver\n    * @param _fromRestricted Defines if transfer time restriction is checked for the sender\n    * @param _toRestricted Defines if transfer time restriction is checked for the receiver\n    */\n    function modifyTransferRequirements(\n        TransferType _transferType,\n        bool _fromValidKYC,\n        bool _toValidKYC,\n        bool _fromRestricted,\n        bool _toRestricted\n    ) public withPerm(ADMIN) {\n        _modifyTransferRequirements(\n            _transferType,\n            _fromValidKYC,\n            _toValidKYC,\n            _fromRestricted,\n            _toRestricted\n        );\n    }\n\n    /**\n    * @notice Modifies the successful checks required for transfers.\n    * @param _transferTypes Types of transfer (0 = General, 1 = Issuance, 2 = Redemption)\n    * @param _fromValidKYC Defines if KYC is required for the sender\n    * @param _toValidKYC Defines if KYC is required for the receiver\n    * @param _fromRestricted Defines if transfer time restriction is checked for the sender\n    * @param _toRestricted Defines if transfer time restriction is checked for the receiver\n    */\n    function modifyTransferRequirementsMulti(\n        TransferType[] memory _transferTypes,\n        bool[] memory _fromValidKYC,\n        bool[] memory _toValidKYC,\n        bool[] memory _fromRestricted,\n        bool[] memory _toRestricted\n    ) public withPerm(ADMIN) {\n        require(\n            _transferTypes.length == _fromValidKYC.length &&\n            _fromValidKYC.length == _toValidKYC.length &&\n            _toValidKYC.length == _fromRestricted.length &&\n            _fromRestricted.length == _toRestricted.length,\n            \"Mismatched input lengths\"\n        );\n\n        for (uint256 i = 0; i <  _transferTypes.length; i++) {\n            _modifyTransferRequirements(\n                _transferTypes[i],\n                _fromValidKYC[i],\n                _toValidKYC[i],\n                _fromRestricted[i],\n                _toRestricted[i]\n            );\n        }\n    }\n\n    function _modifyTransferRequirements(\n        TransferType _transferType,\n        bool _fromValidKYC,\n        bool _toValidKYC,\n        bool _fromRestricted,\n        bool _toRestricted\n    ) internal {\n        transferRequirements[uint8(_transferType)] =\n            TransferRequirements(\n                _fromValidKYC,\n                _toValidKYC,\n                _fromRestricted,\n                _toRestricted\n            );\n\n        emit ModifyTransferRequirements(\n            _transferType,\n            _fromValidKYC,\n            _toValidKYC,\n            _fromRestricted,\n            _toRestricted\n        );\n    }\n\n\n    /**\n    * @notice Add or remove KYC info of an investor.\n    * @param _investor is the address to whitelist\n    * @param _canSendAfter is the moment when the sale lockup period ends and the investor can freely sell or transfer their tokens\n    * @param _canReceiveAfter is the moment when the purchase lockup period ends and the investor can freely purchase or receive tokens from others\n    * @param _expiryTime is the moment till investors KYC will be validated. After that investor need to do re-KYC\n    */\n    function modifyKYCData(\n        address _investor,\n        uint64 _canSendAfter,\n        uint64 _canReceiveAfter,\n        uint64 _expiryTime\n    )\n        public\n        withPerm(ADMIN)\n    {\n        _modifyKYCData(_investor, _canSendAfter, _canReceiveAfter, _expiryTime);\n    }\n\n    function _modifyKYCData(address _investor, uint64 _canSendAfter, uint64 _canReceiveAfter, uint64 _expiryTime) internal {\n        require(_investor != address(0), \"Invalid investor\");\n        IDataStore dataStore = getDataStore();\n        if (!_isExistingInvestor(_investor, dataStore)) {\n           dataStore.insertAddress(INVESTORSKEY, _investor);\n        }\n        uint256 _data = VersionUtils.packKYC(_canSendAfter, _canReceiveAfter, _expiryTime, uint8(1));\n        dataStore.setUint256(_getKey(WHITELIST, _investor), _data);\n        emit ModifyKYCData(_investor, msg.sender, _canSendAfter, _canReceiveAfter, _expiryTime);\n    }\n\n    /**\n    * @notice Add or remove KYC info of an investor.\n    * @param _investors is the address to whitelist\n    * @param _canSendAfter is the moment when the sale lockup period ends and the investor can freely sell his tokens\n    * @param _canReceiveAfter is the moment when the purchase lockup period ends and the investor can freely purchase tokens from others\n    * @param _expiryTime is the moment till investors KYC will be validated. After that investor need to do re-KYC\n    */\n    function modifyKYCDataMulti(\n        address[] memory _investors,\n        uint64[] memory _canSendAfter,\n        uint64[] memory _canReceiveAfter,\n        uint64[] memory _expiryTime\n    )\n        public\n        withPerm(ADMIN)\n    {\n        require(\n            _investors.length == _canSendAfter.length &&\n            _canSendAfter.length == _canReceiveAfter.length &&\n            _canReceiveAfter.length == _expiryTime.length,\n            \"Mismatched input lengths\"\n        );\n        for (uint256 i = 0; i < _investors.length; i++) {\n            _modifyKYCData(_investors[i], _canSendAfter[i], _canReceiveAfter[i], _expiryTime[i]);\n        }\n    }\n\n    /**\n    * @notice Used to modify investor Flag.\n    * @dev Flags are properties about investors that can be true or false like isAccredited\n    * @param _investor is the address of the investor.\n    * @param _flag index of flag to change. flag is used to know specifics about investor like isAccredited.\n    * @param _value value of the flag. a flag can be true or false.\n    */\n    function modifyInvestorFlag(\n        address _investor,\n        uint8 _flag,\n        bool _value\n    )\n        public\n        withPerm(ADMIN)\n    {\n        _modifyInvestorFlag(_investor, _flag, _value);\n    }\n\n\n    function _modifyInvestorFlag(address _investor, uint8 _flag, bool _value) internal {\n        require(_investor != address(0), \"Invalid investor\");\n        IDataStore dataStore = getDataStore();\n        if (!_isExistingInvestor(_investor, dataStore)) {\n           dataStore.insertAddress(INVESTORSKEY, _investor);\n           //KYC data can not be present if _isExistingInvestor is false and hence we can set packed KYC as uint256(1) to set `added` as true\n           dataStore.setUint256(_getKey(WHITELIST, _investor), uint256(1));\n        }\n        //NB Flags are packed together in a uint256 to save gas. We can have a maximum of 256 flags.\n        uint256 flags = dataStore.getUint256(_getKey(INVESTORFLAGS, _investor));\n        if (_value)\n            flags = flags | (ONE << _flag);\n        else\n            flags = flags & ~(ONE << _flag);\n        dataStore.setUint256(_getKey(INVESTORFLAGS, _investor), flags);\n        emit ModifyInvestorFlag(_investor, _flag, _value);\n    }\n\n    /**\n    * @notice Used to modify investor data.\n    * @param _investors List of the addresses to modify data about.\n    * @param _flag index of flag to change. flag is used to know specifics about investor like isAccredited.\n    * @param _value value of the flag. a flag can be true or false.\n    */\n    function modifyInvestorFlagMulti(\n        address[] memory _investors,\n        uint8[] memory _flag,\n        bool[] memory _value\n    )\n        public\n        withPerm(ADMIN)\n    {\n        require(\n            _investors.length == _flag.length &&\n            _flag.length == _value.length,\n            \"Mismatched input lengths\"\n        );\n        for (uint256 i = 0; i < _investors.length; i++) {\n            _modifyInvestorFlag(_investors[i], _flag[i], _value[i]);\n        }\n    }\n\n    /**\n    * @notice Adds or removes addresses from the whitelist - can be called by anyone with a valid signature\n    * @param _investor is the address to whitelist\n    * @param _canSendAfter is the moment when the sale lockup period ends and the investor can freely sell his tokens\n    * @param _canReceiveAfter is the moment when the purchase lockup period ends and the investor can freely purchase tokens from others\n    * @param _expiryTime is the moment till investors KYC will be validated. After that investor need to do re-KYC\n    * @param _validFrom is the time that this signature is valid from\n    * @param _validTo is the time that this signature is valid until\n    * @param _nonce nonce of signature (avoid replay attack)\n    * @param _signature issuer signature\n    */\n    function modifyKYCDataSigned(\n        address _investor,\n        uint256 _canSendAfter,\n        uint256 _canReceiveAfter,\n        uint256 _expiryTime,\n        uint256 _validFrom,\n        uint256 _validTo,\n        uint256 _nonce,\n        bytes memory _signature\n    )\n        public\n    {\n        require(\n            _modifyKYCDataSigned(_investor, _canSendAfter, _canReceiveAfter, _expiryTime, _validFrom, _validTo, _nonce, _signature),\n            \"Invalid signature or data\"\n        );\n    }\n\n    function _modifyKYCDataSigned(\n        address _investor,\n        uint256 _canSendAfter,\n        uint256 _canReceiveAfter,\n        uint256 _expiryTime,\n        uint256 _validFrom,\n        uint256 _validTo,\n        uint256 _nonce,\n        bytes memory _signature\n    )\n        internal\n        returns(bool)\n    {\n        /*solium-disable-next-line security/no-block-members*/\n        if(_validFrom > now || _validTo < now || _investor == address(0))\n            return false;\n        bytes32 hash = keccak256(\n            abi.encodePacked(this, _investor, _canSendAfter, _canReceiveAfter, _expiryTime, _validFrom, _validTo, _nonce)\n        );\n        if (_checkSig(hash, _signature, _nonce)) {\n            require(\n                uint64(_canSendAfter) == _canSendAfter &&\n                uint64(_canReceiveAfter) == _canReceiveAfter &&\n                uint64(_expiryTime) == _expiryTime,\n                \"uint64 overflow\"\n            );\n            _modifyKYCData(_investor, uint64(_canSendAfter), uint64(_canReceiveAfter), uint64(_expiryTime));\n            return true;\n        }\n        return false;\n    }\n\n    /**\n    * @notice Adds or removes addresses from the whitelist - can be called by anyone with a valid signature\n    * @dev using uint256 for some uint256 variables as web3 wasn;t packing and hashing uint64 arrays properly\n    * @param _investor is the address to whitelist\n    * @param _canSendAfter is the moment when the sale lockup period ends and the investor can freely sell his tokens\n    * @param _canReceiveAfter is the moment when the purchase lockup period ends and the investor can freely purchase tokens from others\n    * @param _expiryTime is the moment till investors KYC will be validated. After that investor need to do re-KYC\n    * @param _validFrom is the time that this signature is valid from\n    * @param _validTo is the time that this signature is valid until\n    * @param _nonce nonce of signature (avoid replay attack)\n    * @param _signature issuer signature\n    */\n    function modifyKYCDataSignedMulti(\n        address[] memory _investor,\n        uint256[] memory _canSendAfter,\n        uint256[] memory _canReceiveAfter,\n        uint256[] memory _expiryTime,\n        uint256 _validFrom,\n        uint256 _validTo,\n        uint256 _nonce,\n        bytes memory _signature\n    )\n        public\n    {\n        require(\n            _modifyKYCDataSignedMulti(_investor, _canSendAfter, _canReceiveAfter, _expiryTime, _validFrom, _validTo, _nonce, _signature),\n            \"Invalid signature or data\"\n        );\n    }\n\n    function _modifyKYCDataSignedMulti(\n        address[] memory _investor,\n        uint256[] memory _canSendAfter,\n        uint256[] memory _canReceiveAfter,\n        uint256[] memory _expiryTime,\n        uint256 _validFrom,\n        uint256 _validTo,\n        uint256 _nonce,\n        bytes memory _signature\n    )\n        internal\n        returns(bool)\n    {\n        if (_investor.length != _canSendAfter.length ||\n            _canSendAfter.length != _canReceiveAfter.length ||\n            _canReceiveAfter.length != _expiryTime.length\n        ) {\n            return false;\n        }\n\n        if (_validFrom > now || _validTo < now) {\n            return false;\n        }\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(this, _investor, _canSendAfter, _canReceiveAfter, _expiryTime, _validFrom, _validTo, _nonce)\n        );\n\n        if (_checkSig(hash, _signature, _nonce)) {\n            for (uint256 i = 0; i < _investor.length; i++) {\n                if (uint64(_canSendAfter[i]) == _canSendAfter[i] &&\n                    uint64(_canReceiveAfter[i]) == _canReceiveAfter[i] &&\n                    uint64(_expiryTime[i]) == _expiryTime[i]\n                )\n                    _modifyKYCData(_investor[i], uint64(_canSendAfter[i]), uint64(_canReceiveAfter[i]), uint64(_expiryTime[i]));\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Used to verify the signature\n     */\n    function _checkSig(bytes32 _hash, bytes memory _signature, uint256 _nonce) internal returns(bool) {\n        //Check that the signature is valid\n        //sig should be signing - _investor, _canSendAfter, _canReceiveAfter & _expiryTime and be signed by the issuer address\n        address signer = _hash.toEthSignedMessageHash().recover(_signature);\n        if (nonceMap[signer][_nonce] || !_checkPerm(OPERATOR, signer)) {\n            return false;\n        }\n        nonceMap[signer][_nonce] = true;\n        return true;\n    }\n\n    /**\n     * @notice Internal function used to check whether the KYC of investor is valid\n     * @param _expiryTime Expiry time of the investor\n     */\n    function _validExpiry(uint64 _expiryTime) internal view returns(bool valid) {\n        if (_expiryTime >= uint64(now)) /*solium-disable-line security/no-block-members*/\n            valid = true;\n    }\n\n    /**\n     * @notice Internal function used to check whether the lock time of investor is valid\n     * @param _lockTime Lock time of the investor\n     */\n    function _validLockTime(uint64 _lockTime) internal view returns(bool valid) {\n        if (_lockTime <= uint64(now)) /*solium-disable-line security/no-block-members*/\n            valid = true;\n    }\n\n    /**\n     * @notice Internal function to adjust times using default values\n     */\n    function _adjustTimes(uint64 _canSendAfter, uint64 _canReceiveAfter) internal view returns(uint64, uint64) {\n        if (_canSendAfter == 0) {\n            _canSendAfter = defaults.canSendAfter;\n        }\n        if (_canReceiveAfter == 0) {\n            _canReceiveAfter = defaults.canReceiveAfter;\n        }\n        return (_canSendAfter, _canReceiveAfter);\n    }\n\n    function _getKey(bytes32 _key1, address _key2) internal pure returns(bytes32) {\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\n    }\n\n    function _getKYCValues(address _investor, IDataStore dataStore) internal view returns(\n        uint64 canSendAfter,\n        uint64 canReceiveAfter,\n        uint64 expiryTime,\n        uint8 added\n    )\n    {\n        uint256 data = dataStore.getUint256(_getKey(WHITELIST, _investor));\n        (canSendAfter, canReceiveAfter, expiryTime, added)  = VersionUtils.unpackKYC(data);\n    }\n\n    function _isExistingInvestor(address _investor, IDataStore dataStore) internal view returns(bool) {\n        uint256 data = dataStore.getUint256(_getKey(WHITELIST, _investor));\n        //extracts `added` from packed `_whitelistData`\n        return uint8(data) == 0 ? false : true;\n    }\n\n    function _getValuesForTransfer(address _from, address _to) internal view returns(uint64 canSendAfter, uint64 fromExpiry, uint64 canReceiveAfter, uint64 toExpiry) {\n        IDataStore dataStore = getDataStore();\n        (canSendAfter, , fromExpiry, ) = _getKYCValues(_from, dataStore);\n        (, canReceiveAfter, toExpiry, ) = _getKYCValues(_to, dataStore);\n    }\n\n    /**\n     * @dev Returns list of all investors\n     */\n    function getAllInvestors() public view returns(address[] memory investors) {\n        IDataStore dataStore = getDataStore();\n        investors = dataStore.getAddressArray(INVESTORSKEY);\n    }\n\n    /**\n     * @dev Returns list of investors in a range\n     */\n    function getInvestors(uint256 _fromIndex, uint256 _toIndex) public view returns(address[] memory investors) {\n        IDataStore dataStore = getDataStore();\n        investors = dataStore.getAddressArrayElements(INVESTORSKEY, _fromIndex, _toIndex);\n    }\n\n    function getAllInvestorFlags() public view returns(address[] memory investors, uint256[] memory flags) {\n        investors = getAllInvestors();\n        flags = new uint256[](investors.length);\n        for (uint256 i = 0; i < investors.length; i++) {\n            flags[i] = _getInvestorFlags(investors[i]);\n        }\n    }\n\n    function getInvestorFlag(address _investor, uint8 _flag) public view returns(bool value) {\n        uint256 flag = (_getInvestorFlags(_investor) >> _flag) & ONE;\n        value = flag > 0 ? true : false;\n    }\n\n    function getInvestorFlags(address _investor) public view returns(uint256 flags) {\n        flags = _getInvestorFlags(_investor);\n    }\n\n    function _getInvestorFlags(address _investor) internal view returns(uint256 flags) {\n        IDataStore dataStore = getDataStore();\n        flags = dataStore.getUint256(_getKey(INVESTORFLAGS, _investor));\n    }\n\n    /**\n     * @dev Returns list of all investors data\n     */\n    function getAllKYCData() external view returns(\n        address[] memory investors,\n        uint256[] memory canSendAfters,\n        uint256[] memory canReceiveAfters,\n        uint256[] memory expiryTimes\n    ) {\n        investors = getAllInvestors();\n        (canSendAfters, canReceiveAfters, expiryTimes) = _kycData(investors);\n        return (investors, canSendAfters, canReceiveAfters, expiryTimes);\n    }\n\n    /**\n     * @dev Returns list of specified investors data\n     */\n    function getKYCData(address[] calldata _investors) external view returns(\n        uint256[] memory,\n        uint256[] memory,\n        uint256[] memory\n    ) {\n        return _kycData(_investors);\n    }\n\n    function _kycData(address[] memory _investors) internal view returns(\n        uint256[] memory,\n        uint256[] memory,\n        uint256[] memory\n    ) {\n        uint256[] memory canSendAfters = new uint256[](_investors.length);\n        uint256[] memory canReceiveAfters = new uint256[](_investors.length);\n        uint256[] memory expiryTimes = new uint256[](_investors.length);\n        for (uint256 i = 0; i < _investors.length; i++) {\n            (canSendAfters[i], canReceiveAfters[i], expiryTimes[i], ) = _getKYCValues(_investors[i], getDataStore());\n        }\n        return (canSendAfters, canReceiveAfters, expiryTimes);\n    }\n\n    /**\n     * @notice Return the permissions flag that are associated with general trnasfer manager\n     */\n    function getPermissions() public view returns(bytes32[] memory) {\n        bytes32[] memory allPermissions = new bytes32[](1);\n        allPermissions[0] = ADMIN;\n        return allPermissions;\n    }\n\n    /**\n     * @notice return the amount of tokens for a given user as per the partition\n     * @param _partition Identifier\n     * @param _tokenHolder Whom token amount need to query\n     * @param _additionalBalance It is the `_value` that transfer during transfer/transferFrom function call\n     */\n    function getTokensByPartition(bytes32 _partition, address _tokenHolder, uint256 _additionalBalance) external view returns(uint256) {\n        uint256 currentBalance = (msg.sender == address(securityToken)) ? (securityToken.balanceOf(_tokenHolder)).add(_additionalBalance) : securityToken.balanceOf(_tokenHolder);\n        uint256 canSendAfter;\n        (canSendAfter,,,) = _getKYCValues(_tokenHolder, getDataStore());\n        canSendAfter = (canSendAfter == 0 ? defaults.canSendAfter:  canSendAfter);\n        bool unlockedCheck = paused ? _partition == UNLOCKED : (_partition == UNLOCKED && now >= canSendAfter);\n        if (((_partition == LOCKED && now < canSendAfter) && !paused) || unlockedCheck)\n            return currentBalance;\n        else\n            return 0;\n    }\n\n    function getAddressBytes32() public view returns(bytes32) {\n        return bytes32(uint256(address(this)) << 96);\n    }\n\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getAllKYCData\",\"outputs\":[{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"canSendAfters\",\"type\":\"uint256[]\"},{\"name\":\"canReceiveAfters\",\"type\":\"uint256[]\"},{\"name\":\"expiryTimes\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitFunction\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transferTypes\",\"type\":\"uint8[]\"},{\"name\":\"_fromValidKYC\",\"type\":\"bool[]\"},{\"name\":\"_toValidKYC\",\"type\":\"bool[]\"},{\"name\":\"_fromRestricted\",\"type\":\"bool[]\"},{\"name\":\"_toRestricted\",\"type\":\"bool[]\"}],\"name\":\"modifyTransferRequirementsMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WHITELIST\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_partition\",\"type\":\"bytes32\"},{\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"name\":\"_additionalBalance\",\"type\":\"uint256\"}],\"name\":\"getTokensByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_canSendAfter\",\"type\":\"uint256\"},{\"name\":\"_canReceiveAfter\",\"type\":\"uint256\"},{\"name\":\"_expiryTime\",\"type\":\"uint256\"},{\"name\":\"_validFrom\",\"type\":\"uint256\"},{\"name\":\"_validTo\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"modifyKYCDataSigned\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"executeTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INVESTORFLAGS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNLOCKED\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"polyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressBytes32\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_flag\",\"type\":\"uint8\"}],\"name\":\"getInvestorFlag\",\"outputs\":[{\"name\":\"value\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transferType\",\"type\":\"uint8\"},{\"name\":\"_fromValidKYC\",\"type\":\"bool\"},{\"name\":\"_toValidKYC\",\"type\":\"bool\"},{\"name\":\"_fromRestricted\",\"type\":\"bool\"},{\"name\":\"_toRestricted\",\"type\":\"bool\"}],\"name\":\"modifyTransferRequirements\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"reclaimERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fromIndex\",\"type\":\"uint256\"},{\"name\":\"_toIndex\",\"type\":\"uint256\"}],\"name\":\"getInvestors\",\"outputs\":[{\"name\":\"investors\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address[]\"},{\"name\":\"_canSendAfter\",\"type\":\"uint256[]\"},{\"name\":\"_canReceiveAfter\",\"type\":\"uint256[]\"},{\"name\":\"_expiryTime\",\"type\":\"uint256[]\"},{\"name\":\"_validFrom\",\"type\":\"uint256\"},{\"name\":\"_validTo\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"modifyKYCDataSignedMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OPERATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonceMap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOCKED\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuanceAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_flag\",\"type\":\"uint8\"},{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"modifyInvestorFlag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"securityToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getInvestorFlags\",\"outputs\":[{\"name\":\"flags\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INVESTORSKEY\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPermissions\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"transferRequirements\",\"outputs\":[{\"name\":\"fromValidKYC\",\"type\":\"bool\"},{\"name\":\"toValidKYC\",\"type\":\"bool\"},{\"name\":\"fromRestricted\",\"type\":\"bool\"},{\"name\":\"toRestricted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_canSendAfter\",\"type\":\"uint64\"},{\"name\":\"_canReceiveAfter\",\"type\":\"uint64\"},{\"name\":\"_expiryTime\",\"type\":\"uint64\"}],\"name\":\"modifyKYCData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllInvestors\",\"outputs\":[{\"name\":\"investors\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"},{\"name\":\"_canSendAfter\",\"type\":\"uint64[]\"},{\"name\":\"_canReceiveAfter\",\"type\":\"uint64[]\"},{\"name\":\"_expiryTime\",\"type\":\"uint64[]\"}],\"name\":\"modifyKYCDataMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_issuanceAddress\",\"type\":\"address\"}],\"name\":\"changeIssuanceAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"}],\"name\":\"getKYCData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaults\",\"outputs\":[{\"name\":\"canSendAfter\",\"type\":\"uint64\"},{\"name\":\"canReceiveAfter\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_defaultCanSendAfter\",\"type\":\"uint64\"},{\"name\":\"_defaultCanReceiveAfter\",\"type\":\"uint64\"}],\"name\":\"changeDefaults\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"verifyTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllInvestorFlags\",\"outputs\":[{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"flags\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"},{\"name\":\"_flag\",\"type\":\"uint8[]\"},{\"name\":\"_value\",\"type\":\"bool[]\"}],\"name\":\"modifyInvestorFlagMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDataStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_securityToken\",\"type\":\"address\"},{\"name\":\"_polyToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_issuanceAddress\",\"type\":\"address\"}],\"name\":\"ChangeIssuanceAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_defaultCanSendAfter\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"_defaultCanReceiveAfter\",\"type\":\"uint64\"}],\"name\":\"ChangeDefaults\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_addedBy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_canSendAfter\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"_canReceiveAfter\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"_expiryTime\",\"type\":\"uint64\"}],\"name\":\"ModifyKYCData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_flag\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"ModifyInvestorFlag\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_transferType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_fromValidKYC\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_toValidKYC\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_fromRestricted\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_toRestricted\",\"type\":\"bool\"}],\"name\":\"ModifyTransferRequirements\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"GeneralTransferManager","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://8d15bd61cf4541509e3a9a1499270b002a039598b259c6e25893e3b3d9be2ecb"}]}