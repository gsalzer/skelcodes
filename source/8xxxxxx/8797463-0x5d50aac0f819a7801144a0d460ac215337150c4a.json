{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/escrow/EscrowBaseInterface.sol\r\n\r\n/**\r\n * Copyright 2017â€“2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ninterface EscrowBaseInterface {\r\n\r\n\tfunction hasCurrencySupport(bytes32 _symbol) public view returns (bool);\r\n\r\n\tfunction getServiceFeeInfo() external view returns (address, uint16, uint);\r\n\tfunction setServiceFee(uint16 _feeValue) external returns (uint);\r\n\tfunction setServiceFeeAddress(address _feeReceiver) external returns (uint);\r\n\r\n\t/// @notice Gets balance locked on escrow.\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @return currency symbol\r\n    /// @return currence balance on escrow\r\n    function getBalanceOf(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer\r\n    ) external view returns (bytes32, uint);\r\n\r\n\t/// @notice Creates an escrow record for provided symbol \"`_symbol`\"\r\n\t/// @dev Escrow is reusable so the same tradeRecordId could be reused after an escrow\r\n\t///\t\twith the same identifier is resolved.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _symbol symbol of payment currency\r\n\t/// @param _value amount to initially deposit to escrow; could be 0\r\n\t/// @param _transferImmediatelyToBuyerAmount amount to transfer immediately to a buyer\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction createEscrow(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tbytes32 _symbol,\r\n\t\tuint _value,\r\n\t\tuint _transferImmediatelyToBuyerAmount,\r\n\t\tuint8 _feeStatus\r\n\t) external payable returns (uint);\r\n\r\n\t/// @notice Deposits to an escrow provided amount `_value`\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _value amount to deposit\r\n\t/// @param _transferImmediatelyToBuyerAmount amount to transfer immediately to a buyer\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction deposit(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _value,\r\n\t\tuint _transferImmediatelyToBuyerAmount, // transfers _transferImmediatelyToBuyerAmount directly to _buyer.\r\n\t\tuint8 _feeStatus\r\n\t) external payable returns (uint);\r\n\r\n\t/// @notice Transfers `_value` from escrow to buyer `_buyer`\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller shoud sign hash of (message, escrow address, msg.sig, _value, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _value amount to withdraw from escrow\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _sellerSignature signature produced by seller\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction releaseBuyerPayment(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _value,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _sellerSignature,\r\n\t\tuint8 _feeStatus\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Transfers `_value` from escrow to seller `_seller`\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Buyer shoud sign hash of (message, escrow address, msg.sig, _value, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _value amount to withdraw from escrow\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _buyerSignature signature produced by buyer\r\n\t/// @return result code of an operation\r\n\tfunction sendSellerPayback(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _value,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _buyerSignature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Transfers `_value` from escrow to seller `_seller` and buyer `_buyer`\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _sellerValue, _buyerValue, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _sellerValue amount to withdraw from escrow to the seller\r\n\t/// @param _buyerValue amount to withdraw from escrow to the buyer\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signatures concatenated signatures produced by seller and buyer\r\n\t/// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n\t/// @return result code of an operation\r\n\tfunction releaseNegotiatedPayment(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _sellerValue,\r\n\t\tuint _buyerValue,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _signatures,\r\n\t\tuint8 _feeStatus\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Starts a dispute process between seller `_seller` and buyer `_buyer`.\r\n\t/// \tCould start only if an arbiter was specified.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signature signature of an initiator\r\n\t/// @return result code of an operation\r\n\tfunction initiateDispute(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _signature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Cancels an initiated dispute process\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signature signature of an initiator\r\n\t/// @return result code of an operation\r\n\tfunction cancelDispute(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _signature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Transfers disputed value from escrow to the seller `_seller` and the buyer `_buyer` according\r\n\t/// \tto provided buyer value `_buyerValue`. The value of escrow - _buyerValue will be transferred to the seller.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Arbiter should sign hash of (message, escrow address, msg.sig, _buyerValue, _expireAtBlock) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _buyerValue value that will be transferred to the buyer\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _arbiterSignature signature of an arbiter\r\n\t/// @return result code of an operation\r\n\tfunction releaseDisputedPayment(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\tuint _buyerValue,\r\n\t\tuint _expireAtBlock,\r\n\t\tbytes _arbiterSignature\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Deletes escrow record when it is no more needed.\r\n    ///     Escrow should be empty to be deleted.\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    function deleteEscrow(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer\r\n    ) external returns (uint);\r\n\r\n\tfunction getArbiter(bytes32 _tradeRecordId, address _seller, address _buyer) external view returns (address);\r\n\r\n\t/// @notice Sets a new arbiter `_arbiter`. His address should be approved by both parties.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _arbiter, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _bothSignatures signatures of seller and buyer\r\n\tfunction setArbiter(\r\n\t\tbytes32 _tradeRecordId,\r\n\t\taddress _seller,\r\n\t\taddress _buyer,\r\n\t\taddress _arbiter,\r\n\t\tuint _expireAtBlock,\r\n\t\tuint _salt,\r\n\t\tbytes _bothSignatures\r\n\t) external returns (uint);\r\n\r\n\t/// @notice Performs transfer of a currency `_symbol`\r\n\t///\t\tfrom a `msg.sender` to service fee recepient\r\n\t/// @param _symbol target currency symbol\r\n\t/// @param _from holder address of the `_symbol`\r\n\t/// @param _amount amount to retransfer\r\n\t/// @return result code of an operation\r\n\tfunction retranslateToFeeRecipient(bytes32 _symbol, address _from, uint _amount) external payable returns (uint);\r\n}\r\n\r\n// File: contracts/common/Signatures.sol\r\n\r\n/**\r\n * Copyright 2017â€“2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\nlibrary Signatures {\r\n\r\n    bytes constant internal SIGNATURE_PREFIX = \"\\x19Ethereum Signed Message:\\n32\";\r\n    uint constant internal SIGNATURE_LENGTH = 65;\r\n\r\n    function getSignerFromSignature(bytes32 _message, bytes _signature)\r\n    public\r\n    pure\r\n    returns (address)\r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (_signature.length != SIGNATURE_LENGTH) {\r\n            return 0;\r\n        }\r\n\r\n        assembly {\r\n            r := mload(add(_signature, 32))\r\n            s := mload(add(_signature, 64))\r\n            v := and(mload(add(_signature, 65)), 255)\r\n        }\r\n\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        return ecrecover(\r\n            keccak256(abi.encodePacked(SIGNATURE_PREFIX, _message)),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n\r\n    /// @notice Get signers from signatures byte array.\r\n    /// @param _message message hash\r\n    /// @param _signatures signatures\r\n    /// @return addresses of signers\r\n    function getSignersFromSignatures(bytes32 _message, bytes _signatures)\r\n    public\r\n    pure\r\n    returns (address[] memory _addresses)\r\n    {\r\n        require(validSignaturesLength(_signatures), \"SIGNATURES_SHOULD_HAVE_CORRECT_LENGTH\");\r\n        _addresses = new address[](numSignatures(_signatures));\r\n        for (uint i = 0; i < _addresses.length; i++) {\r\n            _addresses[i] = getSignerFromSignature(_message, signatureAt(_signatures, i));\r\n        }\r\n    }\r\n\r\n    function numSignatures(bytes _signatures)\r\n    private\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return _signatures.length / SIGNATURE_LENGTH;\r\n    }\r\n\r\n    function validSignaturesLength(bytes _signatures)\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (_signatures.length % SIGNATURE_LENGTH) == 0;\r\n    }\r\n\r\n    function signatureAt(bytes _signatures, uint position)\r\n    private\r\n    pure\r\n    returns (bytes)\r\n    {\r\n        return slice(_signatures, position * SIGNATURE_LENGTH, SIGNATURE_LENGTH);\r\n    }\r\n\r\n    function bytesToBytes4(bytes memory source)\r\n    private\r\n    pure\r\n    returns (bytes4 output) {\r\n        if (source.length == 0) {\r\n            return 0x0;\r\n        }\r\n        assembly {\r\n            output := mload(add(source, 4))\r\n        }\r\n    }\r\n\r\n    function slice(bytes _bytes, uint _start, uint _length)\r\n    private\r\n    pure\r\n    returns (bytes)\r\n    {\r\n        require(_bytes.length >= (_start + _length), \"SIGNATURES_SLICE_SIZE_SHOULD_NOT_OVERTAKE_BYTES_LENGTH\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n}\r\n\r\n// File: @laborx/solidity-shared-contracts/contracts/ERC20Interface.sol\r\n\r\n/**\r\n* Copyright 2017â€“2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/// @title Defines an interface for EIP20 token smart contract\r\ncontract ERC20Interface {\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n\r\n    string public symbol;\r\n\r\n    function decimals() public view returns (uint8);\r\n    function totalSupply() public view returns (uint256 supply);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n}\r\n\r\n// File: @laborx/solidity-shared-contracts/contracts/Owned.sol\r\n\r\n/**\r\n* Copyright 2017â€“2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n/// @title Owned contract with safe ownership pass.\r\n///\r\n/// Note: all the non constant functions return false instead of throwing in case if state change\r\n/// didn't happen yet.\r\ncontract Owned {\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    address public contractOwner;\r\n    address public pendingContractOwner;\r\n\r\n    modifier onlyContractOwner {\r\n        if (msg.sender == contractOwner) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    constructor()\r\n    public\r\n    {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    /// @notice Prepares ownership pass.\r\n    /// Can only be called by current owner.\r\n    /// @param _to address of the next owner.\r\n    /// @return success.\r\n    function changeContractOwnership(address _to)\r\n    public\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        if (_to == 0x0) {\r\n            return false;\r\n        }\r\n        pendingContractOwner = _to;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Finalize ownership pass.\r\n    /// Can only be called by pending owner.\r\n    /// @return success.\r\n    function claimContractOwnership()\r\n    public\r\n    returns (bool)\r\n    {\r\n        if (msg.sender != pendingContractOwner) {\r\n            return false;\r\n        }\r\n\r\n        emit OwnershipTransferred(contractOwner, pendingContractOwner);\r\n        contractOwner = pendingContractOwner;\r\n        delete pendingContractOwner;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address newOwner)\r\n    public\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        if (newOwner == 0x0) {\r\n            return false;\r\n        }\r\n\r\n        emit OwnershipTransferred(contractOwner, newOwner);\r\n        contractOwner = newOwner;\r\n        delete pendingContractOwner;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @dev Backward compatibility only.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferContractOwnership(address newOwner)\r\n    public\r\n    returns (bool)\r\n    {\r\n        return transferOwnership(newOwner);\r\n    }\r\n\r\n    /// @notice Withdraw given tokens from contract to owner.\r\n    /// This method is only allowed for contact owner.\r\n    function withdrawTokens(address[] tokens)\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        address _contractOwner = contractOwner;\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            ERC20Interface token = ERC20Interface(tokens[i]);\r\n            uint balance = token.balanceOf(this);\r\n            if (balance > 0) {\r\n                token.transfer(_contractOwner, balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraw ether from contract to owner.\r\n    /// This method is only allowed for contact owner.\r\n    function withdrawEther()\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        uint balance = address(this).balance;\r\n        if (balance > 0)  {\r\n            contractOwner.transfer(balance);\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers ether to another address.\r\n    /// Allowed only for contract owners.\r\n    /// @param _to recepient address\r\n    /// @param _value wei to transfer; must be less or equal to total balance on the contract\r\n    function transferEther(address _to, uint256 _value)\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        require(_to != 0x0, \"INVALID_ETHER_RECEPIENT_ADDRESS\");\r\n        if (_value > address(this).balance) {\r\n            revert(\"INVALID_VALUE_TO_TRANSFER_ETHER\");\r\n        }\r\n\r\n        _to.transfer(_value);\r\n    }\r\n}\r\n\r\n// File: contracts/common/Object.sol\r\n\r\n/**\r\n * Copyright 2017â€“2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n/**\r\n * @title Generic owned destroyable contract\r\n */\r\ncontract Object is Owned {\r\n    /**\r\n    *  Common result code. Means everything is fine.\r\n    */\r\n    uint constant OK = 1;\r\n}\r\n\r\n// File: contracts/common/access/Context.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/common/access/Roles.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: contracts/common/access/roles/WhitelistAdminRole.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n/**\r\n * @title WhitelistAdminRole\r\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\r\n */\r\ncontract WhitelistAdminRole is Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n    constructor () internal {\r\n        _addWhitelistAdmin(_msgSender());\r\n    }\r\n\r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(_msgSender()), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account);\r\n    }\r\n\r\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(_msgSender());\r\n    }\r\n\r\n    function _addWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    }\r\n\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/common/access/roles/WhitelistedRole.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title WhitelistedRole\r\n * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\r\n * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\r\n * it), and not Whitelisteds themselves.\r\n */\r\ncontract WhitelistedRole is Context, WhitelistAdminRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistedAdded(address indexed account);\r\n    event WhitelistedRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelisteds;\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(_msgSender()), \"WhitelistedRole: caller does not have the Whitelisted role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return _whitelisteds.has(account);\r\n    }\r\n\r\n    function addWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    function removeWhitelisted(address account) public onlyWhitelistAdmin {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    function renounceWhitelisted() public {\r\n        _removeWhitelisted(_msgSender());\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        _whitelisteds.add(account);\r\n        emit WhitelistedAdded(account);\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        _whitelisteds.remove(account);\r\n        emit WhitelistedRemoved(account);\r\n    }\r\n}\r\n\r\n// File: contracts/common/Relayed.sol\r\n\r\n/**\r\n * Copyright 2017â€“2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\ncontract Relayed is Object, WhitelistedRole {\r\n\r\n    uint private whitelistedCount;\r\n\r\n    event RelayTransferred(address indexed previousRelay, address indexed newRelay);\r\n\r\n    /// @dev Throws if called by any account other than the relay.\r\n    modifier onlyRelay() {\r\n        require(!isActivatedRelay() || isWhitelisted(msg.sender), \"RELAY_ONLY\");\r\n        _;\r\n    }\r\n\r\n    function isActivatedRelay() public view returns (bool) {\r\n        return whitelistedCount != 0;\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        super._addWhitelisted(account);\r\n        whitelistedCount = whitelistedCount + 1;\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        super._removeWhitelisted(account);\r\n        whitelistedCount = whitelistedCount - 1;\r\n    }\r\n}\r\n\r\n// File: contracts/escrow/EscrowBase.sol\r\n\r\n/**\r\n * Copyright 2017â€“2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ncontract EscrowBase {\r\n\r\n    mapping(bytes32 => bool) internal _saltWithEscrow2flagMapping;\r\n\r\n    /// @notice Gets balance locked on escrow.\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @return currency symbol\r\n    /// @return currence balance on escrow\r\n    function getBalanceOf(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer\r\n    )\r\n    external\r\n    view\r\n    returns (bytes32, uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        return (_getEscrowSymbol(_escrowHash), _getEscrowValue(_escrowHash));\r\n    }\r\n\r\n    /// @notice  Hashes the values and returns the escrow hash.\r\n    /// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n    /// @return returns escrow hash\r\n    function _getEscrowHash(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer\r\n    )\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_tradeRecordId, _seller, _buyer));\r\n    }\r\n\r\n    function _getEncodedSaltWithEscrowHash(uint _salt, bytes32 _escrowHash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_salt, _escrowHash));\r\n    }\r\n\r\n    function _getEscrowExists(bytes32 _escrowHash) internal view returns (bool);\r\n\r\n    function _getEscrowDisputed(bytes32 _escrowHash) internal view returns (bool);\r\n\r\n    function _getEscrowSymbol(bytes32 _escrowHash) internal view returns (bytes32);\r\n\r\n    function _getEscrowValue(bytes32 _escrowHash) internal view returns (uint);\r\n\r\n    function _getEscrowArbiter(bytes32 _escrowHash) internal view returns (address);\r\n}\r\n\r\n// File: contracts/escrow/DisputedEmitter.sol\r\n\r\n/**\r\n * Copyright 2017â€“2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ncontract DisputedEmitter {\r\n    event DisputeRequested(bytes32 indexed tradeHash, address arbiter);\r\n    event DisputeCanceled(bytes32 indexed tradeHash);\r\n    event ArbiterTransferred(bytes32 indexed tradeHash, address arbiter);\r\n\r\n    function _emitDisputeRequested(bytes32 _tradeHash, address _arbiter) internal {\r\n        emit DisputeRequested(_tradeHash, _arbiter);\r\n    }\r\n\r\n    function _emitDisputeCanceled(bytes32 _tradeHash) internal {\r\n        emit DisputeCanceled(_tradeHash);\r\n    }\r\n\r\n    function _emitArbiterTransferred(bytes32 _tradeHash, address _arbiter) internal {\r\n        emit ArbiterTransferred(_tradeHash, _arbiter);\r\n    }\r\n}\r\n\r\n// File: contracts/escrow/Disputed.sol\r\n\r\n/**\r\n * Copyright 2017â€“2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n\r\ncontract Disputed is\r\n    Relayed,\r\n    EscrowBase,\r\n    DisputedEmitter\r\n{\r\n    mapping(bytes32 => address) internal _disputeInitiators;\r\n\r\n    /// @notice Starts a dispute process between seller `_seller` and buyer `_buyer`.\r\n\t/// \tCould start only if an arbiter was specified.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signature signature of an initiator\r\n\t/// @return result code of an operation\r\n    function initiateDispute(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n    external\r\n    onlyRelay\r\n    returns (uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        bytes32 _encodedSaltWithEscrow = _getEncodedSaltWithEscrowHash(_salt, _escrowHash);\r\n        require(_getEscrowExists(_escrowHash), \"DISPUTED_ESCROW_SHOULD_EXIST\");\r\n        require(!_getEscrowDisputed(_escrowHash), \"DISPUTED_ESCROW_SHOULD_NOT_BE_DISPUTED\");\r\n        address _arbiter = _getEscrowArbiter(_escrowHash);\r\n        require(_arbiter != address(0), \"DISPUTED_ARBITER_SHOULD_NOT_BE_EMPTY\");\r\n        require(!_saltWithEscrow2flagMapping[_encodedSaltWithEscrow], \"DISPUTED_SUCH_SALT_SHOULD_NOT_EXIST\");\r\n        bytes memory _message = abi.encodePacked(\r\n            _escrowHash,\r\n            address(this),\r\n            msg.sig,\r\n            _expireAtBlock,\r\n            _salt\r\n        );\r\n        address _signer = Signatures.getSignerFromSignature(keccak256(_message), _signature);\r\n        require(_signer == _seller || _signer == _buyer, \"DISPUTED_SIGNER_SHOULD_BE_BUYER_OR_SELLER\");\r\n        require(block.number < _expireAtBlock, \"DISPUTED_TX_SHOULD_NOT_BE_EXPIRED\");\r\n\r\n        _saltWithEscrow2flagMapping[_encodedSaltWithEscrow] = true;\r\n        _disputeInitiators[_escrowHash] = _signer;\r\n        _setEscrowDisputed(_escrowHash, true);\r\n        _emitDisputeRequested(_escrowHash, _arbiter);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Cancels an initiated dispute process\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _signature signature of an initiator\r\n\t/// @return result code of an operation\r\n    function cancelDispute(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signature\r\n    )\r\n    external\r\n    onlyRelay\r\n    returns (uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        bytes32 _encodedSaltWithEscrow = _getEncodedSaltWithEscrowHash(_salt, _escrowHash);\r\n        require(_getEscrowExists(_escrowHash), \"DISPUTED_ESCROW_SHOULD_EXIST\");\r\n        require(_getEscrowDisputed(_escrowHash), \"DISPUTED_ESCROW_SHOULD_BE_DISPUTED\");\r\n        require(!_saltWithEscrow2flagMapping[_encodedSaltWithEscrow], \"DISPUTED_SUCH_SALT_SHOULD_NOT_EXIST\");\r\n        bytes memory _message = abi.encodePacked(\r\n            _escrowHash,\r\n            address(this),\r\n            msg.sig,\r\n            _expireAtBlock,\r\n            _salt\r\n        );\r\n        address _signer = Signatures.getSignerFromSignature(keccak256(_message), _signature);\r\n        require(_signer == _disputeInitiators[_escrowHash], \"DISPUTED_SIGNER_SHOULD_BE_DISPUTE_INITIATOR\");\r\n        require(block.number < _expireAtBlock, \"DISPUTED_TX_SHOULD_NOT_BE_EXPIRED\");\r\n\r\n        _saltWithEscrow2flagMapping[_encodedSaltWithEscrow] = true;\r\n        _setEscrowDisputed(_escrowHash, false);\r\n        delete _disputeInitiators[_escrowHash];\r\n        _emitDisputeCanceled(_escrowHash);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Transfers disputed value from escrow to the seller `_seller` and the buyer `_buyer` according\r\n\t/// \tto provided buyer value `_buyerValue`. The value of escrow - _buyerValue will be transferred to the seller.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Arbiter should sign hash of (message, escrow address, msg.sig, _buyerValue, _expireAtBlock) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _buyerValue value that will be transferred to the buyer\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _arbiterSignature signature of an arbiter\r\n\t/// @return result code of an operation\r\n    function releaseDisputedPayment(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _buyerValue,\r\n        uint _expireAtBlock,\r\n        bytes _arbiterSignature\r\n        ) external returns (uint);\r\n\r\n    function getArbiter(bytes32 _tradeRecordId, address _seller, address _buyer) external view returns (address) {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        return _getEscrowArbiter(_escrowHash);\r\n    }\r\n\r\n    /// @notice Sets a new arbiter `_arbiter`. His address should be approved by both parties.\r\n\t/// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n\t/// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _arbiter, _expireAtBlock, _salt) data\r\n\t/// @param _tradeRecordId identifier of escrow record\r\n\t/// @param _seller who will mainly deposit to escrow\r\n\t/// @param _buyer who will eventually is going to receive payment\r\n\t/// @param _expireAtBlock expiry block after which transaction will be invalid\r\n\t/// @param _salt random bytes to identify signed data\r\n\t/// @param _bothSignatures signatures of seller and buyer\r\n    function setArbiter(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        address _arbiter,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _bothSignatures\r\n    )\r\n    external\r\n    onlyRelay\r\n    returns (uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        bytes32 _encodedSaltWithEscrow = _getEncodedSaltWithEscrowHash(_salt, _escrowHash);\r\n        require(_getEscrowExists(_escrowHash), \"DISPUTED_ESCROW_SHOULD_EXIST\");\r\n        require(!_saltWithEscrow2flagMapping[_encodedSaltWithEscrow], \"DISPUTED_SUCH_SALT_SHOULD_NOT_EXIST\");\r\n        bytes memory _message = abi.encodePacked(\r\n            _escrowHash,\r\n            address(this),\r\n            msg.sig,\r\n            _arbiter,\r\n            _expireAtBlock,\r\n            _salt\r\n        );\r\n        address[] memory _signers = Signatures.getSignersFromSignatures(keccak256(_message), _bothSignatures);\r\n        require(\r\n            _signers.length == 2 &&\r\n            (\r\n                (_signers[0] == _seller && _signers[1] == _buyer) ||\r\n                (_signers[0] == _buyer && _signers[1] == _seller)\r\n            ),\r\n            \"DISPUTED_SIGNERS_SHOULD_BE_BUYER_AND_SELLER\");\r\n        require(block.number < _expireAtBlock, \"DISPUTED_TX_SHOULD_NOT_BE_EXPIRED\");\r\n\r\n        _saltWithEscrow2flagMapping[_encodedSaltWithEscrow] = true;\r\n        _setEscrowArbiter(_escrowHash, _arbiter);\r\n        _emitArbiterTransferred(_escrowHash, _arbiter);\r\n\r\n        return OK;\r\n    }\r\n\r\n    function _setEscrowDisputed(bytes32 _escrowHash, bool _disputeStatus) internal;\r\n\r\n    function _setEscrowArbiter(bytes32 _escrowHash, address _arbiter) internal;\r\n}\r\n\r\n// File: contracts/escrow/FeeApplicable.sol\r\n\r\n/**\r\n * Copyright 2017â€“2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ncontract FeeApplicable is Object {\r\n\r\n    uint constant MAX_FEE = 100; // 100 = 1%\r\n    uint constant FEE_PRECISION = 10000; // Fee calculation: value * (fee / FEE_PRECISION)\r\n\r\n    address private _serviceFeeAddress;\r\n    uint16 private _serviceFee;\r\n\r\n    modifier onlyFeeAdmin {\r\n        require(_isFeeAdmin(msg.sender), \"AF_IC\"); // AF_IC == applicable fee invalid caller\r\n        _;\r\n    }\r\n\r\n    function getServiceFeeInfo() public view returns (address, uint16, uint) {\r\n        return (_serviceFeeAddress, _serviceFee, FEE_PRECISION);\r\n    }\r\n\r\n    function setServiceFee(uint16 _feeValue) external onlyFeeAdmin returns (uint) {\r\n        require(_feeValue <= MAX_FEE, \"AF_IV\"); // AF_IV == applicable fee invalid fee value\r\n        _serviceFee = _feeValue;\r\n    }\r\n\r\n    function setServiceFeeAddress(address _feeReceiver) external onlyFeeAdmin returns (uint) {\r\n        _serviceFeeAddress = _feeReceiver;\r\n    }\r\n\r\n    function _isFeeAdmin(address _account) internal view returns (bool);\r\n}\r\n\r\n// File: contracts/escrow/EscrowEmitter.sol\r\n\r\n/**\r\n * Copyright 2017â€“2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\ncontract EscrowEmitter {\r\n    event Created(bytes32 indexed tradeHash, bytes32 symbol, uint value);\r\n    event Deposited(bytes32 indexed tradeHash, bytes32 symbol, uint value);\r\n    event ReleasedPayment(bytes32 indexed tradeHash, bytes32 symbol, uint value);\r\n    event Payback(bytes32 indexed tradeHash, bytes32 symbol, uint value);\r\n\r\n    function _emitCreated(bytes32 _tradeHash, bytes32 _symbol, uint _value) internal {\r\n        emit Created(_tradeHash, _symbol, _value);\r\n    }\r\n\r\n    function _emitDeposited(bytes32 _tradeHash, bytes32 _symbol, uint _value) internal {\r\n        emit Deposited(_tradeHash, _symbol, _value);\r\n    }\r\n\r\n    function _emitReleasedPayment(bytes32 _tradeHash, bytes32 _symbol, uint _value) internal {\r\n        emit ReleasedPayment(_tradeHash, _symbol, _value);\r\n    }\r\n\r\n    function _emitPayback(bytes32 _tradeHash, bytes32 _symbol, uint _value) internal {\r\n        emit Payback(_tradeHash, _symbol, _value);\r\n    }\r\n}\r\n\r\n// File: contracts/libs/Bits.sol\r\n\r\n/**\r\n * Copyright 2017â€“2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\nlibrary Bits {\r\n\r\n    uint constant internal ONE = uint(1);\r\n    uint constant internal ONES = uint(~0);\r\n\r\n    // Sets the bit at the given 'index' in 'self' to '1'.\r\n    // Returns the modified value.\r\n    function setBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self | ONE << index;\r\n    }\r\n\r\n    // Sets the bit at the given 'index' in 'self' to '0'.\r\n    // Returns the modified value.\r\n    function clearBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self & ~(ONE << index);\r\n    }\r\n\r\n    // Sets the bit at the given 'index' in 'self' to:\r\n    //  '1' - if the bit is '0'\r\n    //  '0' - if the bit is '1'\r\n    // Returns the modified value.\r\n    function toggleBit(uint self, uint8 index) internal pure returns (uint) {\r\n        return self ^ ONE << index;\r\n    }\r\n\r\n    // Get the value of the bit at the given 'index' in 'self'.\r\n    function bit(uint self, uint8 index) internal pure returns (uint8) {\r\n        return uint8(self >> index & 1);\r\n    }\r\n\r\n    // Check if the bit at the given 'index' in 'self' is set.\r\n    // Returns:\r\n    //  'true' - if the value of the bit is '1'\r\n    //  'false' - if the value of the bit is '0'\r\n    function bitSet(uint self, uint8 index) internal pure returns (bool) {\r\n        return self >> index & 1 == 1;\r\n    }\r\n\r\n    // Checks if the bit at the given 'index' in 'self' is equal to the corresponding\r\n    // bit in 'other'.\r\n    // Returns:\r\n    //  'true' - if both bits are '0' or both bits are '1'\r\n    //  'false' - otherwise\r\n    function bitEqual(uint self, uint other, uint8 index) internal pure returns (bool) {\r\n        return (self ^ other) >> index & 1 == 0;\r\n    }\r\n\r\n    // Get the bitwise NOT of the bit at the given 'index' in 'self'.\r\n    function bitNot(uint self, uint8 index) internal pure returns (uint8) {\r\n        return uint8(1 - (self >> index & 1));\r\n    }\r\n\r\n    // Computes the bitwise AND of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitAnd(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self & other) >> index & 1);\r\n    }\r\n\r\n    // Computes the bitwise OR of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitOr(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self | other) >> index & 1);\r\n    }\r\n\r\n    // Computes the bitwise XOR of the bit at the given 'index' in 'self', and the\r\n    // corresponding bit in 'other', and returns the value.\r\n    function bitXor(uint self, uint other, uint8 index) internal pure returns (uint8) {\r\n        return uint8((self ^ other) >> index & 1);\r\n    }\r\n\r\n    // Gets 'numBits' consecutive bits from 'self', starting from the bit at 'startIndex'.\r\n    // Returns the bits as a 'uint'.\r\n    // Requires that:\r\n    //  - '0 < numBits <= 256'\r\n    //  - 'startIndex < 256'\r\n    //  - 'numBits + startIndex <= 256'\r\n    function bits(uint self, uint8 startIndex, uint16 numBits) internal pure returns (uint) {\r\n        require(0 < numBits && startIndex < 256 && startIndex + numBits <= 256);\r\n        return self >> startIndex & ONES >> 256 - numBits;\r\n    }\r\n\r\n    // Computes the index of the highest bit set in 'self'.\r\n    // Returns the highest bit set as an 'uint8'.\r\n    // Requires that 'self != 0'.\r\n    function highestBitSet(uint self) internal pure returns (uint8 highest) {\r\n        require(self != 0);\r\n        uint val = self;\r\n        for (uint8 i = 128; i >= 1; i >>= 1) {\r\n            if (val & (ONE << i) - 1 << i != 0) {\r\n                highest += i;\r\n                val >>= i;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Computes the index of the lowest bit set in 'self'.\r\n    // Returns the lowest bit set as an 'uint8'.\r\n    // Requires that 'self != 0'.\r\n    function lowestBitSet(uint self) internal pure returns (uint8 lowest) {\r\n        require(self != 0);\r\n        uint val = self;\r\n        for (uint8 i = 128; i >= 1; i >>= 1) {\r\n            if (val & (ONE << i) - 1 == 0) {\r\n                lowest += i;\r\n                val >>= i;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/common/FeeConstants.sol\r\n\r\n/**\r\n * Copyright 2017â€“2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\ncontract FeeConstants {\r\n\r\n    using Bits for uint8;\r\n\r\n    uint8 constant SELLER_FLAG_BIT_IDX = 0;\r\n    uint8 constant BUYER_FLAG_BIT_IDX = 1;\r\n\r\n    function _getSellerFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return uint8(_feeStatus.setBit(SELLER_FLAG_BIT_IDX));\r\n    }\r\n\r\n    function _getBuyerFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return uint8(_feeStatus.setBit(BUYER_FLAG_BIT_IDX));\r\n    }\r\n\r\n    function _getAllFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return uint8(uint8(_feeStatus\r\n            .setBit(SELLER_FLAG_BIT_IDX))\r\n            .setBit(BUYER_FLAG_BIT_IDX));\r\n    }\r\n\r\n    function _getNoFeeFlag() internal pure returns (uint8 _feeStatus) {\r\n        return 0;\r\n    }\r\n\r\n    function _isFeeFlagAppliedFor(uint8 _feeStatus, uint8 _userBit) internal pure returns (bool) {\r\n        return _feeStatus.bitSet(_userBit);\r\n    }\r\n}\r\n\r\n// File: contracts/libs/SafeMath.sol\r\n\r\n/**\r\n* Copyright 2017â€“2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b, \"SAFE_MATH_MUL\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SAFE_MATH_SUB\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SAFE_MATH_ADD\");\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n}\r\n\r\n// File: contracts/libs/PercentCalculator.sol\r\n\r\n/**\r\n * Copyright 2017â€“2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\nlibrary PercentCalculator {\r\n\r\n    using SafeMath for uint;\r\n\r\n    function getPercent(\r\n        uint _value,\r\n        uint _percent,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint)\r\n    {\r\n        return _value.mul(_percent).div(_precision);\r\n    }\r\n\r\n    function getValueWithPercent(\r\n        uint _value,\r\n        uint _percent,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint)\r\n    {\r\n        return _value.add(getPercent(_value, _percent, _precision));\r\n    }\r\n\r\n    function getFullValueFromPercentedValue(\r\n        uint _value,\r\n        uint _percent,\r\n        uint _precision\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint)\r\n    {\r\n        return _value.mul(_precision).div(_percent);\r\n    }\r\n}\r\n\r\n// File: contracts/escrow/EscrowETH.sol\r\n\r\n/**\r\n * Copyright 2017â€“2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract EscrowETH is\r\n    EscrowBaseInterface,\r\n    Disputed,\r\n    FeeApplicable,\r\n    EscrowEmitter,\r\n    FeeConstants\r\n{\r\n\r\n    using SafeMath for uint;\r\n\r\n    bytes32 constant ETH_SYMBOL = \"ETH\";\r\n\r\n    uint private accumulatedFee;\r\n\r\n    mapping(bytes32 => Escrow) private escrows;\r\n\r\n    struct Escrow {\r\n        bool exists;\r\n        bool disputed;\r\n        uint value;\r\n        address arbiter;\r\n    }\r\n\r\n    function() external payable {\r\n        revert(\"ESCROW_ETH_DOES_NOT_SUPPORT_ETH\");\r\n    }\r\n\r\n    function getFeeBalance() public view returns (uint) {\r\n        return accumulatedFee;\r\n    }\r\n\r\n    /// @notice Creates an escrow record for provided symbol \"`_symbol`\"\r\n    /// @dev Escrow is reusable so the same tradeRecordId could be reused after an escrow\r\n    ///\t\twith the same identifier is resolved.\r\n    /// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @param _symbol symbol of payment currency\r\n    /// @param _value amount to initially deposit to escrow; could be 0\r\n    /// @param _transferImmediatelyToBuyerAmount amount to transfer immediately to a buyer\r\n    /// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n    /// @return result code of an operation\r\n    function createEscrow(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        bytes32 _symbol,\r\n        uint _value,\r\n        uint _transferImmediatelyToBuyerAmount,\r\n        uint8 _feeStatus\r\n    )\r\n    external\r\n    payable\r\n    onlyRelay\r\n    returns (uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        require(!_escrow.exists, \"ESCROW_ETH_ESCROW_SHOULD_NOT_EXIST\");\r\n        require(hasCurrencySupport(_symbol), \"ESCROW_ETH_CURRENCY_SHOULD_BE_SUPPORTED\");\r\n\r\n        uint _valueWithoutFee = _value;\r\n        if (_value > 0) {\r\n            require(_value == msg.value && _value >= _transferImmediatelyToBuyerAmount, \"ESCROW_ETH_VALUE_SHOULD_BE_CORRECT\");\r\n            _valueWithoutFee = _takeDepositFee(_value, _feeStatus);\r\n            if (_transferImmediatelyToBuyerAmount > 0) {\r\n                //send upfront to buyer\r\n                _valueWithoutFee = _valueWithoutFee.sub(_transferImmediatelyToBuyerAmount);\r\n                uint _transferImmediatelyToBuyerAmountWithoutFee = _takeWithdrawalFee(_transferImmediatelyToBuyerAmount, _feeStatus);\r\n                _buyer.transfer(_transferImmediatelyToBuyerAmountWithoutFee);\r\n            }\r\n        }\r\n        escrows[_escrowHash] = Escrow(true, false, _valueWithoutFee, address(0));\r\n        _emitCreated(_escrowHash, ETH_SYMBOL, _valueWithoutFee);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Deposits to an escrow provided amount `_value`\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @param _value amount to deposit\r\n    /// @param _transferImmediatelyToBuyerAmount amount to transfer immediately to a buyer\r\n    /// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n    /// @return result code of an operation\r\n    function deposit(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _value,\r\n        uint _transferImmediatelyToBuyerAmount, // transfers _transferImmediatelyToBuyerAmount directly to _buyer.\r\n        uint8 _feeStatus\r\n    )\r\n    external\r\n    payable\r\n    onlyRelay\r\n    returns (uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        require(_escrow.exists, \"ESCROW_ETH_ESCROW_SHOULD_EXIST\");\r\n        require(!_escrow.disputed, \"ESCROW_ETH_ESCROW_SHOULD_NOT_BE_DISPUTED\");\r\n        require(msg.value == _value && msg.value > 0 && _value >= _transferImmediatelyToBuyerAmount, \"ESCROW_ETH_VALUE_SHOULD_BE_CORRECT\");\r\n\r\n        uint _valueWithoutFee = _takeDepositFee(_value, _feeStatus);\r\n        if (_transferImmediatelyToBuyerAmount > 0) {\r\n            //send upfront to buyer\r\n            _valueWithoutFee = _valueWithoutFee.sub(_transferImmediatelyToBuyerAmount);\r\n            uint _transferImmediatelyToBuyerAmountWithoutFee = _takeWithdrawalFee(_transferImmediatelyToBuyerAmount, _feeStatus);\r\n            _buyer.transfer(_transferImmediatelyToBuyerAmountWithoutFee);\r\n        }\r\n        _escrow.value = _escrow.value.add(_valueWithoutFee);\r\n        _emitDeposited(_escrowHash, ETH_SYMBOL, _valueWithoutFee);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Transfers `_value` from escrow to buyer `_buyer`\r\n    /// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n    /// @dev Seller shoud sign hash of (message, escrow address, msg.sig, _value, _expireAtBlock, _salt) data\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @param _value amount to withdraw from escrow\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid\r\n    /// @param _salt random bytes to identify signed data\r\n    /// @param _sellerSignature signature produced by seller\r\n    /// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n    /// @return result code of an operation\r\n    function releaseBuyerPayment(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _sellerSignature,\r\n        uint8 _feeStatus\r\n    )\r\n    external\r\n    onlyRelay\r\n    returns (uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        bytes32 _encodedSaltWithEscrow = _getEncodedSaltWithEscrowHash(_salt, _escrowHash);\r\n        require(_escrow.exists, \"ESCROW_ETH_ESCROW_SHOULD_EXIST\");\r\n        require(!_escrow.disputed, \"ESCROW_ETH_ESCROW_SHOULD_NOT_BE_DISPUTED\");\r\n        require(!_saltWithEscrow2flagMapping[_encodedSaltWithEscrow], \"ESCROW_ETH_SUCH_SALT_SHOULD_NOT_EXIST\");\r\n        _assertSeller(_escrowHash, _seller, _value, _expireAtBlock, _salt, _sellerSignature);\r\n        require(block.number < _expireAtBlock, \"ESCROW_ETH_TX_SHOULD_NOT_BE_EXPIRED\");\r\n        require(_escrow.value >= _value && _value > 0, \"ESCROW_ETH_VALUE_SHOULD_BE_CORRECT\");\r\n\r\n        _saltWithEscrow2flagMapping[_encodedSaltWithEscrow] = true;\r\n        _escrow.value = _escrow.value.sub(_value);\r\n        uint _valueWithoutFee = _takeWithdrawalFee(_value, _feeStatus);\r\n        _buyer.transfer(_valueWithoutFee);\r\n        _emitReleasedPayment(_escrowHash, ETH_SYMBOL, _valueWithoutFee);\r\n\r\n        return OK;\r\n    }\r\n\r\n    function _assertSeller(\r\n        bytes32 _escrowHash,\r\n        address _seller,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _sellerSignature\r\n    )\r\n    private\r\n    view\r\n    {\r\n        bytes memory _message = abi.encodePacked(\r\n            _escrowHash,\r\n            address(this),\r\n            msg.sig,\r\n            _value,\r\n            _expireAtBlock,\r\n            _salt\r\n        );\r\n        address _signer = Signatures.getSignerFromSignature(keccak256(_message), _sellerSignature);\r\n        require(_signer == _seller, \"ESCROW_ETH_SIGNER_SHOULD_BE_SELLER\");\r\n    }\r\n\r\n\r\n    /// @notice Transfers `_value` from escrow to seller `_seller`\r\n    /// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n    /// @dev Buyer shoud sign hash of (message, escrow address, msg.sig, _value, _expireAtBlock, _salt) data\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @param _value amount to withdraw from escrow\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid\r\n    /// @param _salt random bytes to identify signed data\r\n    /// @param _buyerSignature signature produced by buyer\r\n    /// @return result code of an operation\r\n    function sendSellerPayback(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _value,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _buyerSignature\r\n    )\r\n    external\r\n    onlyRelay\r\n    returns (uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        bytes32 _encodedSaltWithEscrow = _getEncodedSaltWithEscrowHash(_salt, _escrowHash);\r\n        require(_escrow.exists, \"ESCROW_ETH_ESCROW_SHOULD_EXIST\");\r\n        require(!_escrow.disputed, \"ESCROW_ETH_ESCROW_SHOULD_NOT_BE_DISPUTED\");\r\n        require(!_saltWithEscrow2flagMapping[_encodedSaltWithEscrow], \"ESCROW_ETH_SUCH_SALT_SHOULD_NOT_EXIST\");\r\n        bytes memory _message = abi.encodePacked(\r\n            _escrowHash,\r\n            address(this),\r\n            msg.sig,\r\n            _value,\r\n            _expireAtBlock,\r\n            _salt\r\n        );\r\n        address _signer = Signatures.getSignerFromSignature(keccak256(_message), _buyerSignature);\r\n        require(_signer == _buyer, \"ESCROW_ETH_SIGNER_SHOULD_BE_BUYER\");\r\n        require(block.number < _expireAtBlock, \"ESCROW_ETH_TX_SHOULD_NOT_BE_EXPIRED\");\r\n        require(_escrow.value >= _value && _value > 0, \"ESCROW_ETH_VALUE_SHOULD_BE_CORRECT\");\r\n\r\n        _saltWithEscrow2flagMapping[_encodedSaltWithEscrow] = true;\r\n        _escrow.value = _escrow.value.sub(_value);\r\n        _seller.transfer(_value);\r\n        _emitPayback(_escrowHash, ETH_SYMBOL, _value);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Transfers `_value` from escrow to seller `_seller` and buyer `_buyer`\r\n    /// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n    /// @dev Seller and buyer shoud sign hash of (message, escrow address, msg.sig, _sellerValue, _buyerValue, _expireAtBlock, _salt) data\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @param _sellerValue amount to withdraw from escrow to the seller\r\n    /// @param _buyerValue amount to withdraw from escrow to the buyer\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid\r\n    /// @param _salt random bytes to identify signed data\r\n    /// @param _signatures concatenated signatures produced by seller and buyer\r\n    /// @param _feeStatus fee condition (1st bit - seller, 2nd - buyer)\r\n    /// @return result code of an operation\r\n    function releaseNegotiatedPayment(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _sellerValue,\r\n        uint _buyerValue,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signatures,\r\n        uint8 _feeStatus\r\n    )\r\n    external\r\n    onlyRelay\r\n    returns (uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        require(_escrow.exists, \"ESCROW_ETH_ESCROW_SHOULD_EXIST\");\r\n        require(!_escrow.disputed, \"ESCROW_ETH_ESCROW_SHOULD_NOT_BE_DISPUTED\");\r\n        require(!_saltWithEscrow2flagMapping[_getEncodedSaltWithEscrowHash(_salt, _escrowHash)], \"ESCROW_ETH_SUCH_SALT_SHOULD_NOT_EXIST\");\r\n        _assertSellerAndBuyer(_escrowHash, _seller, _buyer, _sellerValue, _buyerValue, _expireAtBlock, _salt, _signatures);\r\n        require(block.number < _expireAtBlock, \"ESCROW_ETH_TX_SHOULD_NOT_BE_EXPIRED\");\r\n        require(_escrow.value >= _sellerValue.add(_buyerValue) && _sellerValue.add(_buyerValue) > 0, \"ESCROW_ETH_VALUE_SHOULD_BE_CORRECT\");\r\n\r\n        _saltWithEscrow2flagMapping[_getEncodedSaltWithEscrowHash(_salt, _escrowHash)] = true;\r\n        _escrow.value = _escrow.value.sub(_sellerValue.add(_buyerValue));\r\n        _seller.transfer(_sellerValue);\r\n        uint _buyerValueWithoutFee = _takeWithdrawalFee(_buyerValue, _feeStatus);\r\n        _buyer.transfer(_buyerValueWithoutFee);\r\n        _emitPayback(_escrowHash, ETH_SYMBOL, _sellerValue);\r\n        _emitReleasedPayment(_escrowHash, ETH_SYMBOL, _buyerValueWithoutFee);\r\n\r\n        return OK;\r\n    }\r\n\r\n    function _assertSellerAndBuyer(\r\n        bytes32 _escrowHash,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _sellerValue,\r\n        uint _buyerValue,\r\n        uint _expireAtBlock,\r\n        uint _salt,\r\n        bytes _signatures\r\n    )\r\n    private\r\n    view\r\n    {\r\n        bytes memory _message = abi.encodePacked(\r\n            _escrowHash,\r\n            address(this),\r\n            msg.sig,\r\n            _sellerValue,\r\n            _buyerValue,\r\n            _expireAtBlock,\r\n            _salt\r\n        );\r\n        address[] memory _signers = Signatures.getSignersFromSignatures(keccak256(_message), _signatures);\r\n        require(_signers.length == 2 && ((_signers[0] == _seller && _signers[1] == _buyer) ||\r\n            (_signers[0] == _buyer && _signers[1] == _seller)), \"ESCROW_ETH_SIGNERS_SHOULD_BE_BUYER_AND_SELLER\");\r\n    }\r\n\r\n    /// @notice Transfers disputed value from escrow to the seller `_seller` and the buyer `_buyer` according\r\n    /// \tto provided buyer value `_buyerValue`. The value of escrow - _buyerValue will be transferred to the seller.\r\n    /// @dev Escrow is identified by a message = keccak256(_tradeRecordId, _seller, _buyer)\r\n    /// @dev Arbiter should sign hash of (message, escrow address, msg.sig, _buyerValue, _expireAtBlock) data\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    /// @param _buyerValue value that will be transferred to the buyer\r\n    /// @param _expireAtBlock expiry block after which transaction will be invalid\r\n    /// @param _arbiterSignature signature of an arbiter\r\n    /// @return result code of an operation\r\n    function releaseDisputedPayment(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer,\r\n        uint _buyerValue,\r\n        uint _expireAtBlock,\r\n        bytes _arbiterSignature\r\n    )\r\n    external\r\n    onlyRelay\r\n    returns (uint)\r\n    {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        require(_escrow.exists, \"ESCROW_ETH_ESCROW_SHOULD_EXIST\");\r\n        require(_escrow.disputed, \"ESCROW_ETH_ESCROW_SHOULD_BE_DISPUTED\");\r\n        bytes memory _message = abi.encodePacked(\r\n            _escrowHash,\r\n            address(this),\r\n            msg.sig,\r\n            _buyerValue,\r\n            _expireAtBlock\r\n        );\r\n        address _signer = Signatures.getSignerFromSignature(keccak256(_message), _arbiterSignature);\r\n        require(_signer == _escrow.arbiter, \"ESCROW_ETH_SIGNER_SHOULD_BE_ARBITER\");\r\n        require(block.number < _expireAtBlock, \"ESCROW_ETH_TX_SHOULD_NOT_BE_EXPIRED\");\r\n        require(_buyerValue <= _escrow.value, \"ESCROW_ETH_VALUE_SHOULD_BE_CORRECT\");\r\n\r\n        if (_buyerValue < _escrow.value) {\r\n            uint _sellerValue = _escrow.value.sub(_buyerValue);\r\n            _seller.transfer(_sellerValue);\r\n            _emitPayback(_escrowHash, ETH_SYMBOL, _sellerValue);\r\n        }\r\n        uint _buyerValueWithoutFee = _takeWithdrawalFee(_buyerValue);\r\n        _buyer.transfer(_buyerValueWithoutFee);\r\n\r\n        _deleteEscrow(_escrowHash);\r\n        delete _disputeInitiators[_escrowHash];\r\n        _emitReleasedPayment(_escrowHash, ETH_SYMBOL, _buyerValueWithoutFee);\r\n        _emitDisputeCanceled(_escrowHash);\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Deletes escrow record when it is no more needed.\r\n    ///     Escrow should be empty to be deleted.\r\n    /// @param _tradeRecordId identifier of escrow record\r\n    /// @param _seller who will mainly deposit to escrow\r\n    /// @param _buyer who will eventually is going to receive payment\r\n    function deleteEscrow(\r\n        bytes32 _tradeRecordId,\r\n        address _seller,\r\n        address _buyer\r\n    ) external returns (uint) {\r\n        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        if (_escrow.exists && _escrow.value == 0) {\r\n            _deleteEscrow(_escrowHash);\r\n        }\r\n\r\n        return OK;\r\n    }\r\n\r\n    function _deleteEscrow(bytes32 _escrowHash) private {\r\n        delete escrows[_escrowHash];\r\n    }\r\n\r\n    /// @notice Charges a service fee for deposits to escrow contract.\r\n    /// @param _value value from which the commission is taken\r\n    /// @param _feeStatus activate state fee: 1 - active, 0 - not active. 1st bit - seller, 2nd bit - buyer\r\n    /// @return result value without service fee\r\n    function _takeDepositFee(uint _value, uint8 _feeStatus) private returns (uint _valueToDeposit) {\r\n        _valueToDeposit = _value;\r\n        bool _isActivatedRelay = isActivatedRelay();\r\n        (, uint16 _serviceFeeValue, uint _feePrecision) = getServiceFeeInfo();\r\n        if (_serviceFeeValue > 0 && (!_isActivatedRelay || (_isActivatedRelay && _isFeeFlagAppliedFor(_feeStatus, SELLER_FLAG_BIT_IDX)))) {\r\n            _valueToDeposit = PercentCalculator.getFullValueFromPercentedValue(_value, _feePrecision.add(_serviceFeeValue), _feePrecision);\r\n            uint _feeValue = _value.sub(_valueToDeposit);\r\n            accumulatedFee = accumulatedFee.add(_feeValue);\r\n        }\r\n    }\r\n\r\n    /// @notice Charges a service fee for withdrawal payments from escrow contract.\r\n    /// @param _value value from which the commission is taken\r\n    /// @param _feeStatus activate state fee: 1 - active, 0 - not active. 1st bit - seller, 2nd bit - buyer\r\n    /// @return result value without service fee\r\n    function _takeWithdrawalFee(uint _value, uint8 _feeStatus) private returns (uint) {\r\n        bool _isActivatedRelay = isActivatedRelay();\r\n        if (!_isActivatedRelay || (_isActivatedRelay && _isFeeFlagAppliedFor(_feeStatus, BUYER_FLAG_BIT_IDX))) {\r\n            return _takeWithdrawalFee(_value);\r\n        }\r\n        return _value;\r\n    }\r\n\r\n    function _takeWithdrawalFee(uint _value) private returns (uint) {\r\n        (, uint16 _serviceFeeValue, uint _feePrecision) = getServiceFeeInfo();\r\n        if (_serviceFeeValue > 0) {\r\n            uint _feeValue = PercentCalculator.getPercent(_value, _serviceFeeValue, _feePrecision);\r\n            _value = _value.sub(_feeValue);\r\n            accumulatedFee = accumulatedFee.add(_feeValue);\r\n        }\r\n        return _value;\r\n    }\r\n\r\n    /// @notice Transfer accumulated service fee to the serviceFeeAddress\r\n    function withdrawFee() external onlyContractOwner {\r\n        (address _feeDestinationAddress,,) = getServiceFeeInfo();\r\n        require(_feeDestinationAddress != 0x0, \"ESCROW_ETH_INVALID_SERVICE_FEE_ADDRESS\");\r\n\r\n        if (accumulatedFee > 0) {\r\n            uint _accumulatedFee = accumulatedFee;\r\n            accumulatedFee = 0;\r\n            _feeDestinationAddress.transfer(_accumulatedFee);\r\n        }\r\n    }\r\n\r\n\tfunction retranslateToFeeRecipient(bytes32 _symbol, address /* _from */, uint _amount) external payable returns (uint) {\r\n        require(hasCurrencySupport(_symbol), \"ESCROW_ETH_CURRENCY_SHOULD_BE_SUPPORTED\");\r\n        require(msg.value == _amount, \"ESCROW_ETH_VALUE_SHOULD_BE_CORRECT\");\r\n\r\n        accumulatedFee = accumulatedFee.add(_amount);\r\n\r\n        return OK;\r\n    }\r\n\r\n    function hasCurrencySupport(bytes32 _symbol) public view returns (bool) {\r\n        return _symbol == ETH_SYMBOL;\r\n    }\r\n\r\n    function _isFeeAdmin(address _account) internal view returns (bool) {\r\n        return contractOwner == _account;\r\n    }\r\n\r\n    function _getEscrowExists(bytes32 _escrowHash) internal view returns(bool) {\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        return _escrow.exists;\r\n    }\r\n\r\n    function _getEscrowDisputed(bytes32 _escrowHash) internal view returns(bool) {\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        return _escrow.disputed;\r\n    }\r\n\r\n    function _getEscrowSymbol(bytes32 /* _escrowHash */) internal view returns(bytes32) {\r\n        return ETH_SYMBOL;\r\n    }\r\n\r\n    function _getEscrowValue(bytes32 _escrowHash) internal view returns(uint) {\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        return _escrow.value;\r\n    }\r\n\r\n    function _getEscrowArbiter(bytes32 _escrowHash) internal view returns(address) {\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        return _escrow.arbiter;\r\n    }\r\n\r\n    function _setEscrowDisputed(bytes32 _escrowHash, bool _disputeStatus) internal {\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        _escrow.disputed = _disputeStatus;\r\n    }\r\n\r\n    function _setEscrowArbiter(bytes32 _escrowHash, address _arbiter) internal {\r\n        Escrow storage _escrow = escrows[_escrowHash];\r\n        _escrow.arbiter = _arbiter;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_transferImmediatelyToBuyerAmount\",\"type\":\"uint256\"},{\"name\":\"_feeStatus\",\"type\":\"uint8\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_sellerValue\",\"type\":\"uint256\"},{\"name\":\"_buyerValue\",\"type\":\"uint256\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_signatures\",\"type\":\"bytes\"},{\"name\":\"_feeStatus\",\"type\":\"uint8\"}],\"name\":\"releaseNegotiatedPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"setServiceFeeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_sellerSignature\",\"type\":\"bytes\"},{\"name\":\"_feeStatus\",\"type\":\"uint8\"}],\"name\":\"releaseBuyerPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"initiateDispute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_buyerSignature\",\"type\":\"bytes\"}],\"name\":\"sendSellerPayback\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"retranslateToFeeRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"bytes32\"}],\"name\":\"hasCurrencySupport\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_buyerValue\",\"type\":\"uint256\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_arbiterSignature\",\"type\":\"bytes\"}],\"name\":\"releaseDisputedPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"getBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_symbol\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_transferImmediatelyToBuyerAmount\",\"type\":\"uint256\"},{\"name\":\"_feeStatus\",\"type\":\"uint8\"}],\"name\":\"createEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeValue\",\"type\":\"uint16\"}],\"name\":\"setServiceFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"deleteEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getServiceFeeInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeeBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"cancelDispute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"getArbiter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeRecordId\",\"type\":\"bytes32\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_arbiter\",\"type\":\"address\"},{\"name\":\"_expireAtBlock\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_bothSignatures\",\"type\":\"bytes\"}],\"name\":\"setArbiter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActivatedRelay\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReleasedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Payback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"arbiter\",\"type\":\"address\"}],\"name\":\"DisputeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeHash\",\"type\":\"bytes32\"}],\"name\":\"DisputeCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"arbiter\",\"type\":\"address\"}],\"name\":\"ArbiterTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousRelay\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newRelay\",\"type\":\"address\"}],\"name\":\"RelayTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistedRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EscrowETH","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"Signatures:65b81c19ab7b084f31adf0915b6baaa6130c6d26","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://e8151e8bc6a35039c53ff64cef0c30d48d046d5ad3108817784766fb8d560aaf"}]}