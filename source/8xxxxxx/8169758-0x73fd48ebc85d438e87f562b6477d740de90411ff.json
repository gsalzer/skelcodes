{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n/**\n * @title Interface that every module contract should implement\n */\ninterface IModule {\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() external pure returns(bytes4 initFunction);\n\n    /**\n     * @notice Return the permission flags that are associated with a module\n     */\n    function getPermissions() external view returns(bytes32[] memory permissions);\n\n}\n\n/**\n * @title Utility contract to allow pausing and unpausing of certain functions\n */\ncontract Pausable {\n    event Pause(address account);\n    event Unpause(address account);\n\n    bool public paused = false;\n\n    /**\n    * @notice Modifier to make a function callable only when the contract is not paused.\n    */\n    modifier whenNotPaused() {\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n\n    /**\n    * @notice Modifier to make a function callable only when the contract is paused.\n    */\n    modifier whenPaused() {\n        require(paused, \"Contract is not paused\");\n        _;\n    }\n\n    /**\n    * @notice Called by the owner to pause, triggers stopped state\n    */\n    function _pause() internal whenNotPaused {\n        paused = true;\n        /*solium-disable-next-line security/no-block-members*/\n        emit Pause(msg.sender);\n    }\n\n    /**\n    * @notice Called by the owner to unpause, returns to normal state\n    */\n    function _unpause() internal whenPaused {\n        paused = false;\n        /*solium-disable-next-line security/no-block-members*/\n        emit Unpause(msg.sender);\n    }\n\n}\n\n/**\n * @title Interface that every module factory contract should implement\n */\ninterface IModuleFactory {\n    event ChangeSetupCost(uint256 _oldSetupCost, uint256 _newSetupCost);\n    event ChangeCostType(bool _isOldCostInPoly, bool _isNewCostInPoly);\n    event GenerateModuleFromFactory(\n        address _module,\n        bytes32 indexed _moduleName,\n        address indexed _moduleFactory,\n        address _creator,\n        uint256 _setupCost,\n        uint256 _setupCostInPoly\n    );\n    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);\n\n    //Should create an instance of the Module, or throw\n    function deploy(bytes calldata _data) external returns(address moduleAddress);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function version() external view returns(string memory moduleVersion);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function name() external view returns(bytes32 moduleName);\n\n    /**\n     * @notice Returns the title associated with the module\n     */\n    function title() external view returns(string memory moduleTitle);\n\n    /**\n     * @notice Returns the description associated with the module\n     */\n    function description() external view returns(string memory moduleDescription);\n\n    /**\n     * @notice Get the setup cost of the module in USD\n     */\n    function setupCost() external returns(uint256 usdSetupCost);\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external view returns(uint8[] memory moduleTypes);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external view returns(bytes32[] memory moduleTags);\n\n    /**\n     * @notice Used to change the setup fee\n     * @param _newSetupCost New setup fee\n     */\n    function changeSetupCost(uint256 _newSetupCost) external;\n\n    /**\n     * @notice Used to change the currency and amount setup cost\n     * @param _setupCost new setup cost\n     * @param _isCostInPoly new setup cost currency. USD or POLY\n     */\n    function changeCostAndType(uint256 _setupCost, bool _isCostInPoly) external;\n\n    /**\n     * @notice Function use to change the lower and upper bound of the compatible version st\n     * @param _boundType Type of bound\n     * @param _newVersion New version array\n     */\n    function changeSTVersionBounds(string calldata _boundType, uint8[] calldata _newVersion) external;\n\n    /**\n     * @notice Get the setup cost of the module\n     */\n    function setupCostInPoly() external returns (uint256 polySetupCost);\n\n    /**\n     * @notice Used to get the lower bound\n     * @return Lower bound\n     */\n    function getLowerSTVersionBounds() external view returns(uint8[] memory lowerBounds);\n\n    /**\n     * @notice Used to get the upper bound\n     * @return Upper bound\n     */\n    function getUpperSTVersionBounds() external view returns(uint8[] memory upperBounds);\n\n    /**\n     * @notice Updates the tags of the ModuleFactory\n     * @param _tagsData New list of tags\n     */\n    function changeTags(bytes32[] calldata _tagsData) external;\n\n    /**\n     * @notice Updates the name of the ModuleFactory\n     * @param _name New name that will replace the old one.\n     */\n    function changeName(bytes32 _name) external;\n\n    /**\n     * @notice Updates the description of the ModuleFactory\n     * @param _description New description that will replace the old one.\n     */\n    function changeDescription(string calldata _description) external;\n\n    /**\n     * @notice Updates the title of the ModuleFactory\n     * @param _title New Title that will replace the old one.\n     */\n    function changeTitle(string calldata _title) external;\n\n}\n\ninterface IDataStore {\n    /**\n     * @dev Changes security token atatched to this data store\n     * @param _securityToken address of the security token\n     */\n    function setSecurityToken(address _securityToken) external;\n\n    /**\n     * @dev Stores a uint256 data against a key\n     * @param _key Unique key to identify the data\n     * @param _data Data to be stored against the key\n     */\n    function setUint256(bytes32 _key, uint256 _data) external;\n\n    function setBytes32(bytes32 _key, bytes32 _data) external;\n\n    function setAddress(bytes32 _key, address _data) external;\n\n    function setString(bytes32 _key, string calldata _data) external;\n\n    function setBytes(bytes32 _key, bytes calldata _data) external;\n\n    function setBool(bytes32 _key, bool _data) external;\n\n    /**\n     * @dev Stores a uint256 array against a key\n     * @param _key Unique key to identify the array\n     * @param _data Array to be stored against the key\n     */\n    function setUint256Array(bytes32 _key, uint256[] calldata _data) external;\n\n    function setBytes32Array(bytes32 _key, bytes32[] calldata _data) external ;\n\n    function setAddressArray(bytes32 _key, address[] calldata _data) external;\n\n    function setBoolArray(bytes32 _key, bool[] calldata _data) external;\n\n    /**\n     * @dev Inserts a uint256 element to the array identified by the key\n     * @param _key Unique key to identify the array\n     * @param _data Element to push into the array\n     */\n    function insertUint256(bytes32 _key, uint256 _data) external;\n\n    function insertBytes32(bytes32 _key, bytes32 _data) external;\n\n    function insertAddress(bytes32 _key, address _data) external;\n\n    function insertBool(bytes32 _key, bool _data) external;\n\n    /**\n     * @dev Deletes an element from the array identified by the key.\n     * When an element is deleted from an Array, last element of that array is moved to the index of deleted element.\n     * @param _key Unique key to identify the array\n     * @param _index Index of the element to delete\n     */\n    function deleteUint256(bytes32 _key, uint256 _index) external;\n\n    function deleteBytes32(bytes32 _key, uint256 _index) external;\n\n    function deleteAddress(bytes32 _key, uint256 _index) external;\n\n    function deleteBool(bytes32 _key, uint256 _index) external;\n\n    /**\n     * @dev Stores multiple uint256 data against respective keys\n     * @param _keys Array of keys to identify the data\n     * @param _data Array of data to be stored against the respective keys\n     */\n    function setUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\n\n    function setBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\n\n    function setAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\n\n    function setBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\n\n    /**\n     * @dev Inserts multiple uint256 elements to the array identified by the respective keys\n     * @param _keys Array of keys to identify the data\n     * @param _data Array of data to be inserted in arrays of the respective keys\n     */\n    function insertUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\n\n    function insertBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\n\n    function insertAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\n\n    function insertBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\n\n    function getUint256(bytes32 _key) external view returns(uint256);\n\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    function getAddress(bytes32 _key) external view returns(address);\n\n    function getString(bytes32 _key) external view returns(string memory);\n\n    function getBytes(bytes32 _key) external view returns(bytes memory);\n\n    function getBool(bytes32 _key) external view returns(bool);\n\n    function getUint256Array(bytes32 _key) external view returns(uint256[] memory);\n\n    function getBytes32Array(bytes32 _key) external view returns(bytes32[] memory);\n\n    function getAddressArray(bytes32 _key) external view returns(address[] memory);\n\n    function getBoolArray(bytes32 _key) external view returns(bool[] memory);\n\n    function getUint256ArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getBytes32ArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getAddressArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getBoolArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getUint256ArrayElement(bytes32 _key, uint256 _index) external view returns(uint256);\n\n    function getBytes32ArrayElement(bytes32 _key, uint256 _index) external view returns(bytes32);\n\n    function getAddressArrayElement(bytes32 _key, uint256 _index) external view returns(address);\n\n    function getBoolArrayElement(bytes32 _key, uint256 _index) external view returns(bool);\n\n    function getUint256ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(uint256[] memory);\n\n    function getBytes32ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bytes32[] memory);\n\n    function getAddressArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(address[] memory);\n\n    function getBoolArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bool[] memory);\n}\n\n/**\n * @title Interface for all security tokens\n */\ninterface ISecurityToken {\n    // Standard ERC20 interface\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function decimals() external view returns(uint8);\n    function totalSupply() external view returns(uint256);\n    function balanceOf(address owner) external view returns(uint256);\n    function allowance(address owner, address spender) external view returns(uint256);\n    function transfer(address to, uint256 value) external returns(bool);\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\n    function approve(address spender, uint256 value) external returns(bool);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     * @return byte Ethereum status code (ESC)\n     * @return bytes32 Application specific reason code\n     */\n    function canTransfer(address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\n\n    // Emit at the time when module get added\n    event ModuleAdded(\n        uint8[] _types,\n        bytes32 indexed _name,\n        address indexed _moduleFactory,\n        address _module,\n        uint256 _moduleCost,\n        uint256 _budget,\n        bytes32 _label,\n        bool _archived\n    );\n\n    // Emit when the token details get updated\n    event UpdateTokenDetails(string _oldDetails, string _newDetails);\n    // Emit when the token name get updated\n    event UpdateTokenName(string _oldName, string _newName);\n    // Emit when the granularity get changed\n    event GranularityChanged(uint256 _oldGranularity, uint256 _newGranularity);\n    // Emit when is permanently frozen by the issuer\n    event FreezeIssuance();\n    // Emit when transfers are frozen or unfrozen\n    event FreezeTransfers(bool _status);\n    // Emit when new checkpoint created\n    event CheckpointCreated(uint256 indexed _checkpointId, uint256 _investorLength);\n    // Events to log controller actions\n    event SetController(address indexed _oldController, address indexed _newController);\n    //Event emit when the global treasury wallet address get changed\n    event TreasuryWalletChanged(address _oldTreasuryWallet, address _newTreasuryWallet);\n    event DisableController();\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event TokenUpgraded(uint8 _major, uint8 _minor, uint8 _patch);\n\n    // Emit when Module get archived from the securityToken\n    event ModuleArchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when Module get unarchived from the securityToken\n    event ModuleUnarchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when Module get removed from the securityToken\n    event ModuleRemoved(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when the budget allocated to a module is changed\n    event ModuleBudgetChanged(uint8[] _moduleTypes, address _module, uint256 _oldBudget, uint256 _budget); //Event emitted by the tokenLib.\n\n    // Transfer Events\n    event TransferByPartition(\n        bytes32 indexed _fromPartition,\n        address _operator,\n        address indexed _from,\n        address indexed _to,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    // Operator Events\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n\n    // Issuance / Redemption Events\n    event IssuedByPartition(bytes32 indexed partition, address indexed to, uint256 value, bytes data);\n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\n\n    // Document Events\n    event DocumentRemoved(bytes32 indexed _name, string _uri, bytes32 _documentHash);\n    event DocumentUpdated(bytes32 indexed _name, string _uri, bytes32 _documentHash);\n\n    // Controller Events\n    event ControllerTransfer(\n        address _controller,\n        address indexed _from,\n        address indexed _to,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    event ControllerRedemption(\n        address _controller,\n        address indexed _tokenHolder,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    // Issuance / Redemption Events\n    event Issued(address indexed _operator, address indexed _to, uint256 _value, bytes _data);\n    event Redeemed(address indexed _operator, address indexed _from, uint256 _value, bytes _data);\n\n    /**\n     * @notice Initialization function\n     * @dev Expected to be called atomically with the proxy being created, by the owner of the token\n     * @dev Can only be called once\n     */\n    function initialize(address _getterDelegate) external;\n\n    /**\n     * @notice The standard provides an on-chain function to determine whether a transfer will succeed,\n     * and return details indicating the reason if the transfer is not valid.\n     * @param _from The address from whom the tokens get transferred.\n     * @param _to The address to which to transfer tokens to.\n     * @param _partition The partition from which to transfer tokens\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @return ESC (Ethereum Status Code) following the EIP-1066 standard\n     * @return Application specific reason codes with additional details\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function canTransferByPartition(\n        address _from,\n        address _to,\n        bytes32 _partition,\n        uint256 _value,\n        bytes calldata _data\n    )\n        external\n        view\n        returns (byte statusCode, bytes32 reasonCode, bytes32 partition);\n\n    /**\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     * @return byte Ethereum status code (ESC)\n     * @return bytes32 Application specific reason code\n     */\n    function canTransferFrom(address _from, address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\n\n    /**\n     * @notice Used to attach a new document to the contract, or update the URI or hash of an existing attached document\n     * @dev Can only be executed by the owner of the contract.\n     * @param _name Name of the document. It should be unique always\n     * @param _uri Off-chain uri of the document from where it is accessible to investors/advisors to read.\n     * @param _documentHash hash (of the contents) of the document.\n     */\n    function setDocument(bytes32 _name, string calldata _uri, bytes32 _documentHash) external;\n\n    /**\n     * @notice Used to remove an existing document from the contract by giving the name of the document.\n     * @dev Can only be executed by the owner of the contract.\n     * @param _name Name of the document. It should be unique always\n     */\n    function removeDocument(bytes32 _name) external;\n\n    /**\n     * @notice Used to return the details of a document with a known name (`bytes32`).\n     * @param _name Name of the document\n     * @return string The URI associated with the document.\n     * @return bytes32 The hash (of the contents) of the document.\n     * @return uint256 the timestamp at which the document was last modified.\n     */\n    function getDocument(bytes32 _name) external view returns (string memory documentUri, bytes32 documentHash, uint256 documentTime);\n\n    /**\n     * @notice Used to retrieve a full list of documents attached to the smart contract.\n     * @return bytes32 List of all documents names present in the contract.\n     */\n    function getAllDocuments() external view returns (bytes32[] memory documentNames);\n\n    /**\n     * @notice In order to provide transparency over whether `controllerTransfer` / `controllerRedeem` are useable\n     * or not `isControllable` function will be used.\n     * @dev If `isControllable` returns `false` then it always return `false` and\n     * `controllerTransfer` / `controllerRedeem` will always revert.\n     * @return bool `true` when controller address is non-zero otherwise return `false`.\n     */\n    function isControllable() external view returns (bool controlled);\n\n    /**\n     * @notice Checks if an address is a module of certain type\n     * @param _module Address to check\n     * @param _type type to check against\n     */\n    function isModule(address _module, uint8 _type) external view returns(bool isValid);\n\n    /**\n     * @notice This function must be called to increase the total supply (Corresponds to mint function of ERC20).\n     * @dev It only be called by the token issuer or the operator defined by the issuer. ERC1594 doesn't have\n     * have the any logic related to operator but its superset ERC1400 have the operator logic and this function\n     * is allowed to call by the operator.\n     * @param _tokenHolder The account that will receive the created tokens (account should be whitelisted or KYCed).\n     * @param _value The amount of tokens need to be issued\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     */\n    function issue(address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice issue new tokens and assigns them to the target _tokenHolder.\n     * @dev Can only be called by the issuer or STO attached to the token.\n     * @param _tokenHolders A list of addresses to whom the minted tokens will be dilivered\n     * @param _values A list of number of tokens get minted and transfer to corresponding address of the investor from _tokenHolders[] list\n     * @return success\n     */\n    function issueMulti(address[] calldata _tokenHolders, uint256[] calldata _values) external;\n\n    /**\n     * @notice Increases totalSupply and the corresponding amount of the specified owners partition\n     * @param _partition The partition to allocate the increase in balance\n     * @param _tokenHolder The token holder whose balance should be increased\n     * @param _value The amount by which to increase the balance\n     * @param _data Additional data attached to the minting of tokens\n     */\n    function issueByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of msg.sender\n     * @param _partition The partition to allocate the decrease in balance\n     * @param _value The amount by which to decrease the balance\n     * @param _data Additional data attached to the burning of tokens\n     */\n    function redeemByPartition(bytes32 _partition, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\n     * are out of the scope of the ERC1594.\n     * @param _value The amount of tokens need to be redeemed\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\n     */\n    function redeem(uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\n     * are out of the scope of the ERC1594.\n     * @dev It is analogy to `transferFrom`\n     * @param _tokenHolder The account whose tokens gets redeemed.\n     * @param _value The amount of tokens need to be redeemed\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\n     */\n    function redeemFrom(address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of tokenHolder\n     * @dev This function can only be called by the authorised operator.\n     * @param _partition The partition to allocate the decrease in balance.\n     * @param _tokenHolder The token holder whose balance should be decreased\n     * @param _value The amount by which to decrease the balance\n     * @param _data Additional data attached to the burning of tokens\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\n     */\n    function operatorRedeemByPartition(\n        bytes32 _partition,\n        address _tokenHolder,\n        uint256 _value,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    ) external;\n\n    /**\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n     * @param _delegate address of delegate\n     * @param _module address of PermissionManager module\n     * @param _perm the permissions\n     * @return success\n     */\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPermission);\n\n    /**\n     * @notice Returns module list for a module type\n     * @param _module Address of the module\n     * @return bytes32 Name\n     * @return address Module address\n     * @return address Module factory address\n     * @return bool Module archived\n     * @return uint8 Array of module types\n     * @return bytes32 Module label\n     */\n    function getModule(address _module) external view returns (bytes32 moduleName, address moduleAddress, address factoryAddress, bool isArchived, uint8[] memory moduleTypes, bytes32 moduleLabel);\n\n    /**\n     * @notice Returns module list for a module name\n     * @param _name Name of the module\n     * @return address[] List of modules with this name\n     */\n    function getModulesByName(bytes32 _name) external view returns(address[] memory modules);\n\n    /**\n     * @notice Returns module list for a module type\n     * @param _type Type of the module\n     * @return address[] List of modules with this type\n     */\n    function getModulesByType(uint8 _type) external view returns(address[] memory modules);\n\n    /**\n     * @notice use to return the global treasury wallet\n     */\n    function getTreasuryWallet() external view returns(address treasuryWallet);\n\n    /**\n     * @notice Queries totalSupply at a specified checkpoint\n     * @param _checkpointId Checkpoint ID to query as of\n     */\n    function totalSupplyAt(uint256 _checkpointId) external view returns(uint256 supply);\n\n    /**\n     * @notice Queries balance at a specified checkpoint\n     * @param _investor Investor to query balance for\n     * @param _checkpointId Checkpoint ID to query as of\n     */\n    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns(uint256 balance);\n\n    /**\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\n     */\n    function createCheckpoint() external returns(uint256 checkpointId);\n\n    /**\n     * @notice Gets list of times that checkpoints were created\n     * @return List of checkpoint times\n     */\n    function getCheckpointTimes() external view returns(uint256[] memory checkpointTimes);\n\n    /**\n     * @notice returns an array of investors\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\n     * @return list of addresses\n     */\n    function getInvestors() external view returns(address[] memory investors);\n\n    /**\n     * @notice returns an array of investors at a given checkpoint\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\n     * @return list of investors\n     */\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[] memory investors);\n\n    /**\n     * @notice returns an array of investors with non zero balance at a given checkpoint\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\n     * @param _start Position of investor to start iteration from\n     * @param _end Position of investor to stop iteration at\n     * @return list of investors\n     */\n    function getInvestorsSubsetAt(uint256 _checkpointId, uint256 _start, uint256 _end) external view returns(address[] memory investors);\n\n    /**\n     * @notice generates subset of investors\n     * NB - can be used in batches if investor list is large\n     * @param _start Position of investor to start iteration from\n     * @param _end Position of investor to stop iteration at\n     * @return list of investors\n     */\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[] memory investors);\n\n    /**\n     * @notice Gets current checkpoint ID\n     * @return Id\n     */\n    function currentCheckpointId() external view returns(uint256 checkpointId);\n\n    /**\n     * @notice Determines whether `_operator` is an operator for all partitions of `_tokenHolder`\n     * @param _operator The operator to check\n     * @param _tokenHolder The token holder to check\n     * @return Whether the `_operator` is an operator for all partitions of `_tokenHolder`\n     */\n    function isOperator(address _operator, address _tokenHolder) external view returns (bool isValid);\n\n    /**\n     * @notice Determines whether `_operator` is an operator for a specified partition of `_tokenHolder`\n     * @param _partition The partition to check\n     * @param _operator The operator to check\n     * @param _tokenHolder The token holder to check\n     * @return Whether the `_operator` is an operator for a specified partition of `_tokenHolder`\n     */\n    function isOperatorForPartition(bytes32 _partition, address _operator, address _tokenHolder) external view returns (bool isValid);\n\n    /**\n     * @notice Return all partitions\n     * @param _tokenHolder Whom balance need to queried\n     * @return List of partitions\n     */\n    function partitionsOf(address _tokenHolder) external view returns (bytes32[] memory partitions);\n\n    /**\n     * @notice Gets data store address\n     * @return data store address\n     */\n    function dataStore() external view returns (address dataStoreAddress);\n\n    /**\n    * @notice Allows owner to change data store\n    * @param _dataStore Address of the token data store\n    */\n    function changeDataStore(address _dataStore) external;\n\n\n    /**\n     * @notice Allows to change the treasury wallet address\n     * @param _wallet Ethereum address of the treasury wallet\n     */\n    function changeTreasuryWallet(address _wallet) external;\n\n    /**\n     * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\n     * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\n     * @param _tokenContract Address of the ERC20Basic compliance token\n     * @param _value Amount of POLY to withdraw\n     */\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\n\n    /**\n    * @notice Allows owner to increase/decrease POLY approval of one of the modules\n    * @param _module Module address\n    * @param _change Change in allowance\n    * @param _increase True if budget has to be increased, false if decrease\n    */\n    function changeModuleBudget(address _module, uint256 _change, bool _increase) external;\n\n    /**\n     * @notice Changes the tokenDetails\n     * @param _newTokenDetails New token details\n     */\n    function updateTokenDetails(string calldata _newTokenDetails) external;\n\n    /**\n    * @notice Allows owner to change token name\n    * @param _name new name of the token\n    */\n    function changeName(string calldata _name) external;\n\n    /**\n    * @notice Allows the owner to change token granularity\n    * @param _granularity Granularity level of the token\n    */\n    function changeGranularity(uint256 _granularity) external;\n\n    /**\n     * @notice Freezes all the transfers\n     */\n    function freezeTransfers() external;\n\n    /**\n     * @notice Un-freezes all the transfers\n     */\n    function unfreezeTransfers() external;\n\n    /**\n     * @notice Permanently freeze issuance of this security token.\n     * @dev It MUST NOT be possible to increase `totalSuppy` after this function is called.\n     */\n    function freezeIssuance(bytes calldata _signature) external;\n\n    /**\n      * @notice Attachs a module to the SecurityToken\n      * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\n      * @dev to control restrictions on transfers.\n      * @param _moduleFactory is the address of the module factory to be added\n      * @param _data is data packed into bytes used to further configure the module (See STO usage)\n      * @param _maxCost max amount of POLY willing to pay to the module.\n      * @param _budget max amount of ongoing POLY willing to assign to the module.\n      * @param _label custom module label.\n      * @param _archived whether to add the module as an archived module\n      */\n    function addModuleWithLabel(\n        address _moduleFactory,\n        bytes calldata _data,\n        uint256 _maxCost,\n        uint256 _budget,\n        bytes32 _label,\n        bool _archived\n    ) external;\n\n    /**\n     * @notice Function used to attach a module to the security token\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\n     * @dev to control restrictions on transfers.\n     * @dev You are allowed to add a new moduleType if:\n     * @dev - there is no existing module of that type yet added\n     * @dev - the last member of the module list is replacable\n     * @param _moduleFactory is the address of the module factory to be added\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\n     * @param _budget max amount of ongoing POLY willing to assign to the module.\n     * @param _archived whether to add the module as an archived module\n     */\n    function addModule(address _moduleFactory, bytes calldata _data, uint256 _maxCost, uint256 _budget, bool _archived) external;\n\n    /**\n    * @notice Archives a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function archiveModule(address _module) external;\n\n    /**\n    * @notice Unarchives a module attached to the SecurityToken\n    * @param _module address of module to unarchive\n    */\n    function unarchiveModule(address _module) external;\n\n    /**\n    * @notice Removes a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function removeModule(address _module) external;\n\n    /**\n     * @notice Used by the issuer to set the controller addresses\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) external;\n\n    /**\n     * @notice This function allows an authorised address to transfer tokens between any two token holders.\n     * The transfer must still respect the balances of the token holders (so the transfer must be for at most\n     * `balanceOf(_from)` tokens) and potentially also need to respect other transfer restrictions.\n     * @dev This function can only be executed by the `controller` address.\n     * @param _from Address The address which you want to send tokens from\n     * @param _to Address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\n     * because use of `_data` parameter is implementation specific).\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\n     */\n    function controllerTransfer(address _from, address _to, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\n\n    /**\n     * @notice This function allows an authorised address to redeem tokens for any token holder.\n     * The redemption must still respect the balances of the token holder (so the redemption must be for at most\n     * `balanceOf(_tokenHolder)` tokens) and potentially also need to respect other transfer restrictions.\n     * @dev This function can only be executed by the `controller` address.\n     * @param _tokenHolder The account whose tokens will be redeemed.\n     * @param _value uint256 the amount of tokens need to be redeemed.\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\n     * because use of `_data` parameter is implementation specific).\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\n     */\n    function controllerRedeem(address _tokenHolder, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\n\n    /**\n     * @notice Used by the issuer to permanently disable controller functionality\n     * @dev enabled via feature switch \"disableControllerAllowed\"\n     */\n    function disableController(bytes calldata _signature) external;\n\n    /**\n     * @notice Used to get the version of the securityToken\n     */\n    function getVersion() external view returns(uint8[] memory version);\n\n    /**\n     * @notice Gets the investor count\n     */\n    function getInvestorCount() external view returns(uint256 investorCount);\n\n    /**\n     * @notice Gets the holder count (investors with non zero balance)\n     */\n    function holderCount() external view returns(uint256 count);\n\n    /**\n      * @notice Overloaded version of the transfer function\n      * @param _to receiver of transfer\n      * @param _value value of transfer\n      * @param _data data to indicate validation\n      * @return bool success\n      */\n    function transferWithData(address _to, uint256 _value, bytes calldata _data) external;\n\n    /**\n      * @notice Overloaded version of the transferFrom function\n      * @param _from sender of transfer\n      * @param _to receiver of transfer\n      * @param _value value of transfer\n      * @param _data data to indicate validation\n      * @return bool success\n      */\n    function transferFromWithData(address _from, address _to, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\n     * @param _partition The partition from which to transfer tokens\n     * @param _to The address to which to transfer tokens to\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function transferByPartition(bytes32 _partition, address _to, uint256 _value, bytes calldata _data) external returns (bytes32 partition);\n\n    /**\n     * @notice Get the balance according to the provided partitions\n     * @param _partition Partition which differentiate the tokens.\n     * @param _tokenHolder Whom balance need to queried\n     * @return Amount of tokens as per the given partitions\n     */\n    function balanceOfByPartition(bytes32 _partition, address _tokenHolder) external view returns(uint256 balance);\n\n    /**\n      * @notice Provides the granularity of the token\n      * @return uint256\n      */\n    function granularity() external view returns(uint256 granularityAmount);\n\n    /**\n      * @notice Provides the address of the polymathRegistry\n      * @return address\n      */\n    function polymathRegistry() external view returns(address registryAddress);\n\n    /**\n    * @notice Upgrades a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function upgradeModule(address _module) external;\n\n    /**\n    * @notice Upgrades security token\n    */\n    function upgradeToken() external;\n\n    /**\n     * @notice A security token issuer can specify that issuance has finished for the token\n     * (i.e. no new tokens can be minted or issued).\n     * @dev If a token returns FALSE for `isIssuable()` then it MUST always return FALSE in the future.\n     * If a token returns FALSE for `isIssuable()` then it MUST never allow additional tokens to be issued.\n     * @return bool `true` signifies the minting is allowed. While `false` denotes the end of minting\n     */\n    function isIssuable() external view returns (bool issuable);\n\n    /**\n     * @notice Authorises an operator for all partitions of `msg.sender`.\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\n     * @param _operator An address which is being authorised.\n     */\n    function authorizeOperator(address _operator) external;\n\n    /**\n     * @notice Revokes authorisation of an operator previously given for all partitions of `msg.sender`.\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\n     * @param _operator An address which is being de-authorised\n     */\n    function revokeOperator(address _operator) external;\n\n    /**\n     * @notice Authorises an operator for a given partition of `msg.sender`\n     * @param _partition The partition to which the operator is authorised\n     * @param _operator An address which is being authorised\n     */\n    function authorizeOperatorByPartition(bytes32 _partition, address _operator) external;\n\n    /**\n     * @notice Revokes authorisation of an operator previously given for a specified partition of `msg.sender`\n     * @param _partition The partition to which the operator is de-authorised\n     * @param _operator An address which is being de-authorised\n     */\n    function revokeOperatorByPartition(bytes32 _partition, address _operator) external;\n\n    /**\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\n     * @param _partition The partition from which to transfer tokens.\n     * @param _from The address from which to transfer tokens from\n     * @param _to The address to which to transfer tokens to\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function operatorTransferByPartition(\n        bytes32 _partition,\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    )\n        external\n        returns (bytes32 partition);\n\n    /*\n    * @notice Returns if transfers are currently frozen or not\n    */\n    function transfersFrozen() external view returns (bool isFrozen);\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) external;\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() external view returns (bool);\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() external view returns (address ownerAddress);\n\n    function controller() external view returns(address controllerAddress);\n\n    function moduleRegistry() external view returns(address moduleRegistryAddress);\n\n    function securityTokenRegistry() external view returns(address securityTokenRegistryAddress);\n\n    function polyToken() external view returns(address polyTokenAddress);\n\n    function tokenFactory() external view returns(address tokenFactoryAddress);\n\n    function getterDelegate() external view returns(address delegate);\n\n    function controllerDisabled() external view returns(bool isDisabled);\n\n    function initialized() external view returns(bool isInitialized);\n\n    function tokenDetails() external view returns(string memory details);\n\n    function updateFromRegistry() external;\n\n}\n\ninterface ICheckPermission {\n    /**\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n     * @param _delegate address of delegate\n     * @param _module address of PermissionManager module\n     * @param _perm the permissions\n     * @return success\n     */\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPerm);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Storage for Module contract\n * @notice Contract is abstract\n */\ncontract ModuleStorage {\n    address public factory;\n\n    ISecurityToken public securityToken;\n\n    // Permission flag\n    bytes32 public constant ADMIN = \"ADMIN\";\n    bytes32 public constant OPERATOR = \"OPERATOR\";\n\n    bytes32 internal constant TREASURY = 0xaae8817359f3dcb67d050f44f3e49f982e0359d90ca4b5f18569926304aaece6; // keccak256(abi.encodePacked(\"TREASURY_WALLET\"))\n\n    IERC20 public polyToken;\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor(address _securityToken, address _polyAddress) public {\n        securityToken = ISecurityToken(_securityToken);\n        factory = msg.sender;\n        polyToken = IERC20(_polyAddress);\n    }\n\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     * @notice Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @title Interface that any module contract should implement\n * @notice Contract is abstract\n */\ncontract Module is IModule, ModuleStorage, Pausable {\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     */\n    constructor (address _securityToken, address _polyAddress) public\n    ModuleStorage(_securityToken, _polyAddress)\n    {\n    }\n\n    //Allows owner, factory or permissioned delegate\n    modifier withPerm(bytes32 _perm) {\n        require(_checkPerm(_perm, msg.sender), \"Invalid permission\");\n        _;\n    }\n\n    function _checkPerm(bytes32 _perm, address _caller) internal view returns (bool) {\n        bool isOwner = _caller == Ownable(address(securityToken)).owner();\n        bool isFactory = _caller == factory;\n        return isOwner || isFactory || ICheckPermission(address(securityToken)).checkPermission(_caller, address(this), _perm);\n    }\n\n    function _onlySecurityTokenOwner() internal view {\n        require(msg.sender == Ownable(address(securityToken)).owner(), \"Sender is not owner\");\n    }\n\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Sender is not factory\");\n        _;\n    }\n\n    /**\n     * @notice Pause (overridden function)\n     */\n    function pause() public {\n        _onlySecurityTokenOwner();\n        super._pause();\n    }\n\n    /**\n     * @notice Unpause (overridden function)\n     */\n    function unpause() public {\n        _onlySecurityTokenOwner();\n        super._unpause();\n    }\n\n    /**\n     * @notice used to return the data store address of securityToken\n     */\n    function getDataStore() public view returns(IDataStore) {\n        return IDataStore(securityToken.dataStore());\n    }\n\n    /**\n    * @notice Reclaims ERC20Basic compatible tokens\n    * @dev We duplicate here due to the overriden owner & onlyOwner\n    * @param _tokenContract The address of the token contract\n    */\n    function reclaimERC20(address _tokenContract) external {\n        _onlySecurityTokenOwner();\n        require(_tokenContract != address(0), \"Invalid address\");\n        IERC20 token = IERC20(_tokenContract);\n        uint256 balance = token.balanceOf(address(this));\n        require(token.transfer(msg.sender, balance), \"Transfer failed\");\n    }\n\n   /**\n    * @notice Reclaims ETH\n    * @dev We duplicate here due to the overriden owner & onlyOwner\n    */\n    function reclaimETH() external {\n        _onlySecurityTokenOwner();\n        msg.sender.transfer(address(this).balance);\n    }\n}\n\n/**\n * @title Interface to be implemented by all Wallet modules\n * @dev abstract contract\n */\ncontract Wallet is Module {\n\n}\n\n/**\n * @title Wallet for core vesting escrow functionality\n */\ncontract VestingEscrowWalletStorage {\n\n    struct Schedule {\n        // Name of the template\n        bytes32 templateName;\n        // Tokens that were already claimed\n        uint256 claimedTokens;\n        // Start time of the schedule\n        uint256 startTime;\n    }\n\n    struct Template {\n        // Total amount of tokens\n        uint256 numberOfTokens;\n        // Schedule duration (How long the schedule will last)\n        uint256 duration;\n        // Schedule frequency (It is a cliff time period)\n        uint256 frequency;\n        // Index of the template in an array template names\n        uint256 index;\n    }\n\n    // Number of tokens that are hold by the `this` contract but are unassigned to any schedule\n    uint256 public unassignedTokens;\n    // Address of the Treasury wallet. All of the unassigned token will transfer to that address.\n    address public treasuryWallet;\n    // List of all beneficiaries who have the schedules running/completed/created\n    address[] public beneficiaries;\n    // Flag whether beneficiary has been already added or not\n    mapping(address => bool) internal beneficiaryAdded;\n\n    // Holds schedules array corresponds to the affiliate/employee address\n    mapping(address => Schedule[]) public schedules;\n    // Holds template names array corresponds to the affiliate/employee address\n    mapping(address => bytes32[]) internal userToTemplates;\n    // Mapping use to store the indexes for different template names for a user.\n    // affiliate/employee address => template name => index\n    mapping(address => mapping(bytes32 => uint256)) internal userToTemplateIndex;\n    // Holds affiliate/employee addresses coressponds to the template name\n    mapping(bytes32 => address[]) internal templateToUsers;\n    // Mapping use to store the indexes for different users for a template.\n    // template name => affiliate/employee address => index\n    mapping(bytes32 => mapping(address => uint256)) internal templateToUserIndex;\n    // Store the template details corresponds to the template name\n    mapping(bytes32 => Template) templates;\n\n    // List of all template names\n    bytes32[] public templateNames;\n}\n\n/**\n * @title Wallet for core vesting escrow functionality\n */\ncontract VestingEscrowWallet is VestingEscrowWalletStorage, Wallet {\n    using SafeMath for uint256;\n\n    // States used to represent the status of the schedule\n    enum State {CREATED, STARTED, COMPLETED}\n\n    // Emit when new schedule is added\n    event AddSchedule(\n        address indexed _beneficiary,\n        bytes32 _templateName,\n        uint256 _startTime\n    );\n    // Emit when schedule is modified\n    event ModifySchedule(\n        address indexed _beneficiary,\n        bytes32 _templateName,\n        uint256 _startTime\n    );\n    // Emit when all schedules are revoked for user\n    event RevokeAllSchedules(address indexed _beneficiary);\n    // Emit when schedule is revoked\n    event RevokeSchedule(address indexed _beneficiary, bytes32 _templateName);\n    // Emit when tokes are deposited to wallet\n    event DepositTokens(uint256 _numberOfTokens, address _sender);\n    // Emit when all unassigned tokens are sent to treasury\n    event SendToTreasury(uint256 _numberOfTokens, address _sender);\n    // Emit when is sent tokes to user\n    event SendTokens(address indexed _beneficiary, uint256 _numberOfTokens);\n    // Emit when template is added\n    event AddTemplate(bytes32 _name, uint256 _numberOfTokens, uint256 _duration, uint256 _frequency);\n    // Emit when template is removed\n    event RemoveTemplate(bytes32 _name);\n    // Emit when the treasury wallet gets changed\n    event TreasuryWalletChanged(address _newWallet, address _oldWallet);\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor (address _securityToken, address _polyAddress)\n    public\n    Module(_securityToken, _polyAddress)\n    {\n    }\n\n    /**\n     * @notice This function returns the signature of the configure function\n     */\n    function getInitFunction() public pure returns (bytes4) {\n        return this.configure.selector;\n    }\n\n    /**\n     * @notice Used to initialize the treasury wallet address\n     * @param _treasuryWallet Address of the treasury wallet\n     */\n    function configure(address _treasuryWallet) public onlyFactory {\n        _setWallet(_treasuryWallet);\n    }\n\n    /**\n     * @notice Used to change the treasury wallet address\n     * @param _newTreasuryWallet Address of the treasury wallet\n     */\n    function changeTreasuryWallet(address _newTreasuryWallet) public {\n        _onlySecurityTokenOwner();\n        _setWallet(_newTreasuryWallet);\n    }\n\n    function _setWallet(address _newTreasuryWallet) internal {\n        emit TreasuryWalletChanged(_newTreasuryWallet, treasuryWallet);\n        treasuryWallet = _newTreasuryWallet;\n    }\n\n    /**\n     * @notice Used to deposit tokens from treasury wallet to the vesting escrow wallet\n     * @param _numberOfTokens Number of tokens that should be deposited\n     */\n    function depositTokens(uint256 _numberOfTokens) external withPerm(ADMIN) {\n        _depositTokens(_numberOfTokens);\n    }\n\n    function _depositTokens(uint256 _numberOfTokens) internal {\n        require(_numberOfTokens > 0, \"Should be > 0\");\n        require(\n            securityToken.transferFrom(msg.sender, address(this), _numberOfTokens),\n            \"Failed transferFrom\"\n        );\n        unassignedTokens = unassignedTokens.add(_numberOfTokens);\n        emit DepositTokens(_numberOfTokens, msg.sender);\n    }\n\n    /**\n     * @notice Sends unassigned tokens to the treasury wallet\n     * @param _amount Amount of tokens that should be send to the treasury wallet\n     */\n    function sendToTreasury(uint256 _amount) public withPerm(OPERATOR) {\n        require(_amount > 0, \"Amount cannot be zero\");\n        require(_amount <= unassignedTokens, \"Amount is greater than unassigned tokens\");\n        unassignedTokens = unassignedTokens - _amount;\n        require(securityToken.transfer(getTreasuryWallet(), _amount), \"Transfer failed\");\n        emit SendToTreasury(_amount, msg.sender);\n    }\n\n    /**\n     * @notice Returns the treasury wallet address\n     */\n    function getTreasuryWallet() public view returns(address) {\n        if (treasuryWallet == address(0)) {\n            address wallet = IDataStore(getDataStore()).getAddress(TREASURY);\n            require(wallet != address(0), \"Invalid address\");\n            return wallet;\n        } else\n            return treasuryWallet;\n    }\n\n    /**\n     * @notice Pushes available tokens to the beneficiary's address\n     * @param _beneficiary Address of the beneficiary who will receive tokens\n     */\n    function pushAvailableTokens(address _beneficiary) public withPerm(OPERATOR) {\n        _sendTokens(_beneficiary);\n    }\n\n    /**\n     * @notice Used to withdraw available tokens by beneficiary\n     */\n    function pullAvailableTokens() external whenNotPaused {\n        _sendTokens(msg.sender);\n    }\n\n    /**\n     * @notice Adds template that can be used for creating schedule\n     * @param _name Name of the template will be created\n     * @param _numberOfTokens Number of tokens that should be assigned to schedule\n     * @param _duration Duration of the vesting schedule\n     * @param _frequency Frequency of the vesting schedule\n     */\n    function addTemplate(bytes32 _name, uint256 _numberOfTokens, uint256 _duration, uint256 _frequency) external withPerm(ADMIN) {\n        _addTemplate(_name, _numberOfTokens, _duration, _frequency);\n    }\n\n    function _addTemplate(bytes32 _name, uint256 _numberOfTokens, uint256 _duration, uint256 _frequency) internal {\n        require(_name != bytes32(0), \"Invalid name\");\n        require(!_isTemplateExists(_name), \"Already exists\");\n        _validateTemplate(_numberOfTokens, _duration, _frequency);\n        templateNames.push(_name);\n        templates[_name] = Template(_numberOfTokens, _duration, _frequency, templateNames.length - 1);\n        emit AddTemplate(_name, _numberOfTokens, _duration, _frequency);\n    }\n\n    /**\n     * @notice Removes template with a given name\n     * @param _name Name of the template that will be removed\n     */\n    function removeTemplate(bytes32 _name) external withPerm(ADMIN) {\n        require(_isTemplateExists(_name), \"Template not found\");\n        require(templateToUsers[_name].length == 0, \"Template is used\");\n        uint256 index = templates[_name].index;\n        if (index != templateNames.length - 1) {\n            templateNames[index] = templateNames[templateNames.length - 1];\n            templates[templateNames[index]].index = index;\n        }\n        templateNames.length--;\n        // delete template data\n        delete templates[_name];\n        emit RemoveTemplate(_name);\n    }\n\n    /**\n     * @notice Returns count of the templates those can be used for creating schedule\n     * @return Count of the templates\n     */\n    function getTemplateCount() external view returns(uint256) {\n        return templateNames.length;\n    }\n\n    /**\n     * @notice Gets the list of the template names those can be used for creating schedule\n     * @return bytes32 Array of all template names were created\n     */\n    function getAllTemplateNames() external view returns(bytes32[] memory) {\n        return templateNames;\n    }\n\n    /**\n     * @notice Adds vesting schedules for each of the beneficiary's address\n     * @param _beneficiary Address of the beneficiary for whom it is scheduled\n     * @param _templateName Name of the template that will be created\n     * @param _numberOfTokens Total number of tokens for created schedule\n     * @param _duration Duration of the created vesting schedule\n     * @param _frequency Frequency of the created vesting schedule\n     * @param _startTime Start time of the created vesting schedule\n     */\n    function addSchedule(\n        address _beneficiary,\n        bytes32 _templateName,\n        uint256 _numberOfTokens,\n        uint256 _duration,\n        uint256 _frequency,\n        uint256 _startTime\n    )\n        external\n        withPerm(ADMIN)\n    {\n        _addSchedule(_beneficiary, _templateName, _numberOfTokens, _duration, _frequency, _startTime);\n    }\n\n    function _addSchedule(\n        address _beneficiary,\n        bytes32 _templateName,\n        uint256 _numberOfTokens,\n        uint256 _duration,\n        uint256 _frequency,\n        uint256 _startTime\n    )\n        internal\n    {\n        _addTemplate(_templateName, _numberOfTokens, _duration, _frequency);\n        _addScheduleFromTemplate(_beneficiary, _templateName, _startTime);\n    }\n\n    /**\n     * @notice Adds vesting schedules from template for the beneficiary\n     * @param _beneficiary Address of the beneficiary for whom it is scheduled\n     * @param _templateName Name of the exists template\n     * @param _startTime Start time of the created vesting schedule\n     */\n    function addScheduleFromTemplate(address _beneficiary, bytes32 _templateName, uint256 _startTime) external withPerm(ADMIN) {\n        _addScheduleFromTemplate(_beneficiary, _templateName, _startTime);\n    }\n\n    function _addScheduleFromTemplate(address _beneficiary, bytes32 _templateName, uint256 _startTime) internal {\n        require(_beneficiary != address(0), \"Invalid address\");\n        require(_isTemplateExists(_templateName), \"Template not found\");\n        uint256 index = userToTemplateIndex[_beneficiary][_templateName];\n        require(\n            schedules[_beneficiary].length == 0 ||\n            schedules[_beneficiary][index].templateName != _templateName,\n            \"Already added\"\n        );\n        require(_startTime >= now, \"Date in the past\");\n        uint256 numberOfTokens = templates[_templateName].numberOfTokens;\n        if (numberOfTokens > unassignedTokens) {\n            _depositTokens(numberOfTokens.sub(unassignedTokens));\n        }\n        unassignedTokens = unassignedTokens.sub(numberOfTokens);\n        if (!beneficiaryAdded[_beneficiary]) {\n            beneficiaries.push(_beneficiary);\n            beneficiaryAdded[_beneficiary] = true;\n        }\n        schedules[_beneficiary].push(Schedule(_templateName, 0, _startTime));\n        userToTemplates[_beneficiary].push(_templateName);\n        userToTemplateIndex[_beneficiary][_templateName] = schedules[_beneficiary].length - 1;\n        templateToUsers[_templateName].push(_beneficiary);\n        templateToUserIndex[_templateName][_beneficiary] = templateToUsers[_templateName].length - 1;\n        emit AddSchedule(_beneficiary, _templateName, _startTime);\n    }\n\n    /**\n     * @notice Modifies vesting schedules for each of the beneficiary\n     * @param _beneficiary Address of the beneficiary for whom it is modified\n     * @param _templateName Name of the template was used for schedule creation\n     * @param _startTime Start time of the created vesting schedule\n     */\n    function modifySchedule(address _beneficiary, bytes32 _templateName, uint256 _startTime) external withPerm(ADMIN) {\n        _modifySchedule(_beneficiary, _templateName, _startTime);\n    }\n\n    function _modifySchedule(address _beneficiary, bytes32 _templateName, uint256 _startTime) internal {\n        _checkSchedule(_beneficiary, _templateName);\n        require(_startTime > now, \"Date in the past\");\n        uint256 index = userToTemplateIndex[_beneficiary][_templateName];\n        Schedule storage schedule = schedules[_beneficiary][index];\n        /*solium-disable-next-line security/no-block-members*/\n        require(now < schedule.startTime, \"Schedule started\");\n        schedule.startTime = _startTime;\n        emit ModifySchedule(_beneficiary, _templateName, _startTime);\n    }\n\n    /**\n     * @notice Revokes vesting schedule with given template name for given beneficiary\n     * @param _beneficiary Address of the beneficiary for whom it is revoked\n     * @param _templateName Name of the template was used for schedule creation\n     */\n    function revokeSchedule(address _beneficiary, bytes32 _templateName) external withPerm(ADMIN) {\n        _checkSchedule(_beneficiary, _templateName);\n        uint256 index = userToTemplateIndex[_beneficiary][_templateName];\n        _sendTokensPerSchedule(_beneficiary, index);\n        uint256 releasedTokens = _getReleasedTokens(_beneficiary, index);\n        unassignedTokens = unassignedTokens.add(templates[_templateName].numberOfTokens.sub(releasedTokens));\n        _deleteUserToTemplates(_beneficiary, _templateName);\n        _deleteTemplateToUsers(_beneficiary, _templateName);\n        emit RevokeSchedule(_beneficiary, _templateName);\n    }\n\n    function _deleteUserToTemplates(address _beneficiary, bytes32 _templateName) internal {\n        uint256 index = userToTemplateIndex[_beneficiary][_templateName];\n        Schedule[] storage userSchedules = schedules[_beneficiary];\n        if (index != userSchedules.length - 1) {\n            userSchedules[index] = userSchedules[userSchedules.length - 1];\n            userToTemplates[_beneficiary][index] = userToTemplates[_beneficiary][userToTemplates[_beneficiary].length - 1];\n            userToTemplateIndex[_beneficiary][userSchedules[index].templateName] = index;\n        }\n        userSchedules.length--;\n        userToTemplates[_beneficiary].length--;\n        delete userToTemplateIndex[_beneficiary][_templateName];\n    }\n\n    function _deleteTemplateToUsers(address _beneficiary, bytes32 _templateName) internal {\n        uint256 templateIndex = templateToUserIndex[_templateName][_beneficiary];\n        if (templateIndex != templateToUsers[_templateName].length - 1) {\n            templateToUsers[_templateName][templateIndex] = templateToUsers[_templateName][templateToUsers[_templateName].length - 1];\n            templateToUserIndex[_templateName][templateToUsers[_templateName][templateIndex]] = templateIndex;\n        }\n        templateToUsers[_templateName].length--;\n        delete templateToUserIndex[_templateName][_beneficiary];\n    }\n\n    /**\n     * @notice Revokes all vesting schedules for given beneficiary's address\n     * @param _beneficiary Address of the beneficiary for whom all schedules will be revoked\n     */\n    function revokeAllSchedules(address _beneficiary) public withPerm(ADMIN) {\n        _revokeAllSchedules(_beneficiary);\n    }\n\n    function _revokeAllSchedules(address _beneficiary) internal {\n        require(_beneficiary != address(0), \"Invalid address\");\n        _sendTokens(_beneficiary);\n        Schedule[] storage userSchedules = schedules[_beneficiary];\n        for (uint256 i = 0; i < userSchedules.length; i++) {\n            uint256 releasedTokens = _getReleasedTokens(_beneficiary, i);\n            Template memory template = templates[userSchedules[i].templateName];\n            unassignedTokens = unassignedTokens.add(template.numberOfTokens.sub(releasedTokens));\n            delete userToTemplateIndex[_beneficiary][userSchedules[i].templateName];\n            _deleteTemplateToUsers(_beneficiary, userSchedules[i].templateName);\n        }\n        delete schedules[_beneficiary];\n        delete userToTemplates[_beneficiary];\n        emit RevokeAllSchedules(_beneficiary);\n    }\n\n    /**\n     * @notice Returns beneficiary's schedule created using template name\n     * @param _beneficiary Address of the beneficiary who will receive tokens\n     * @param _templateName Name of the template was used for schedule creation\n     * @return beneficiary's schedule data (numberOfTokens, duration, frequency, startTime, claimedTokens, State)\n     */\n    function getSchedule(address _beneficiary, bytes32 _templateName) external view returns(uint256, uint256, uint256, uint256, uint256, State) {\n        _checkSchedule(_beneficiary, _templateName);\n        uint256 index = userToTemplateIndex[_beneficiary][_templateName];\n        Schedule memory schedule = schedules[_beneficiary][index];\n        return (\n            templates[schedule.templateName].numberOfTokens,\n            templates[schedule.templateName].duration,\n            templates[schedule.templateName].frequency,\n            schedule.startTime,\n            schedule.claimedTokens,\n            _getScheduleState(_beneficiary, _templateName)\n        );\n    }\n\n    function _getScheduleState(address _beneficiary, bytes32 _templateName) internal view returns(State) {\n        _checkSchedule(_beneficiary, _templateName);\n        uint256 index = userToTemplateIndex[_beneficiary][_templateName];\n        Schedule memory schedule = schedules[_beneficiary][index];\n        if (now < schedule.startTime) {\n            return State.CREATED;\n        } else if (now > schedule.startTime && now < schedule.startTime.add(templates[_templateName].duration)) {\n            return State.STARTED;\n        } else {\n            return State.COMPLETED;\n        }\n    }\n\n    /**\n     * @notice Returns list of the template names for given beneficiary's address\n     * @param _beneficiary Address of the beneficiary\n     * @return List of the template names that were used for schedule creation\n     */\n    function getTemplateNames(address _beneficiary) external view returns(bytes32[] memory) {\n        require(_beneficiary != address(0), \"Invalid address\");\n        return userToTemplates[_beneficiary];\n    }\n\n    /**\n     * @notice Returns count of the schedules were created for given beneficiary\n     * @param _beneficiary Address of the beneficiary\n     * @return Count of beneficiary's schedules\n     */\n    function getScheduleCount(address _beneficiary) external view returns(uint256) {\n        require(_beneficiary != address(0), \"Invalid address\");\n        return schedules[_beneficiary].length;\n    }\n\n    function _getAvailableTokens(address _beneficiary, uint256 _index) internal view returns(uint256) {\n        Schedule memory schedule = schedules[_beneficiary][_index];\n        uint256 releasedTokens = _getReleasedTokens(_beneficiary, _index);\n        return releasedTokens.sub(schedule.claimedTokens);\n    }\n\n    function _getReleasedTokens(address _beneficiary, uint256 _index) internal view returns(uint256) {\n        Schedule memory schedule = schedules[_beneficiary][_index];\n        Template memory template = templates[schedule.templateName];\n        /*solium-disable-next-line security/no-block-members*/\n        if (now > schedule.startTime) {\n            uint256 periodCount = template.duration.div(template.frequency);\n            /*solium-disable-next-line security/no-block-members*/\n            uint256 periodNumber = (now.sub(schedule.startTime)).div(template.frequency);\n            if (periodNumber > periodCount) {\n                periodNumber = periodCount;\n            }\n            return template.numberOfTokens.mul(periodNumber).div(periodCount);\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Used to bulk send available tokens for each of the beneficiaries\n     * @param _fromIndex Start index of array of beneficiary's addresses\n     * @param _toIndex End index of array of beneficiary's addresses\n     */\n    function pushAvailableTokensMulti(uint256 _fromIndex, uint256 _toIndex) public withPerm(OPERATOR) {\n        require(_toIndex < beneficiaries.length, \"Array out of bound\");\n        for (uint256 i = _fromIndex; i <= _toIndex; i++) {\n            if (schedules[beneficiaries[i]].length !=0)\n                pushAvailableTokens(beneficiaries[i]);\n        }\n    }\n\n    /**\n     * @notice Used to bulk add vesting schedules for each of beneficiary\n     * @param _beneficiaries Array of the beneficiary's addresses\n     * @param _templateNames Array of the template names\n     * @param _numberOfTokens Array of number of tokens should be assigned to schedules\n     * @param _durations Array of the vesting duration\n     * @param _frequencies Array of the vesting frequency\n     * @param _startTimes Array of the vesting start time\n     */\n    function addScheduleMulti(\n        address[] memory _beneficiaries,\n        bytes32[] memory _templateNames,\n        uint256[] memory _numberOfTokens,\n        uint256[] memory _durations,\n        uint256[] memory _frequencies,\n        uint256[] memory _startTimes\n    )\n        public\n        withPerm(ADMIN)\n    {\n        require(\n            _beneficiaries.length == _templateNames.length && /*solium-disable-line operator-whitespace*/\n            _beneficiaries.length == _numberOfTokens.length && /*solium-disable-line operator-whitespace*/\n            _beneficiaries.length == _durations.length && /*solium-disable-line operator-whitespace*/\n            _beneficiaries.length == _frequencies.length && /*solium-disable-line operator-whitespace*/\n            _beneficiaries.length == _startTimes.length,\n            \"Arrays sizes mismatch\"\n        );\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\n            _addSchedule(_beneficiaries[i], _templateNames[i], _numberOfTokens[i], _durations[i], _frequencies[i], _startTimes[i]);\n        }\n    }\n\n    /**\n     * @notice Used to bulk add vesting schedules from template for each of the beneficiary\n     * @param _beneficiaries Array of beneficiary's addresses\n     * @param _templateNames Array of the template names were used for schedule creation\n     * @param _startTimes Array of the vesting start time\n     */\n    function addScheduleFromTemplateMulti(\n        address[] memory _beneficiaries,\n        bytes32[] memory _templateNames,\n        uint256[] memory _startTimes\n    )\n        public\n        withPerm(ADMIN)\n    {\n        require(_beneficiaries.length == _templateNames.length && _beneficiaries.length == _startTimes.length, \"Arrays sizes mismatch\");\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\n            _addScheduleFromTemplate(_beneficiaries[i], _templateNames[i], _startTimes[i]);\n        }\n    }\n\n    /**\n     * @notice Used to bulk revoke vesting schedules for each of the beneficiaries\n     * @param _beneficiaries Array of the beneficiary's addresses\n     */\n    function revokeSchedulesMulti(address[] memory _beneficiaries) public withPerm(ADMIN) {\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\n            _revokeAllSchedules(_beneficiaries[i]);\n        }\n    }\n\n    /**\n     * @notice Used to bulk modify vesting schedules for each of the beneficiaries\n     * @param _beneficiaries Array of the beneficiary's addresses\n     * @param _templateNames Array of the template names\n     * @param _startTimes Array of the vesting start time\n     */\n    function modifyScheduleMulti(\n        address[] memory _beneficiaries,\n        bytes32[] memory _templateNames,\n        uint256[] memory _startTimes\n    )\n        public\n        withPerm(ADMIN)\n    {\n        require(\n            _beneficiaries.length == _templateNames.length && /*solium-disable-line operator-whitespace*/\n            _beneficiaries.length == _startTimes.length,\n            \"Arrays sizes mismatch\"\n        );\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\n            _modifySchedule(_beneficiaries[i], _templateNames[i], _startTimes[i]);\n        }\n    }\n\n    function _checkSchedule(address _beneficiary, bytes32 _templateName) internal view {\n        require(_beneficiary != address(0), \"Invalid address\");\n        uint256 index = userToTemplateIndex[_beneficiary][_templateName];\n        require(\n            index < schedules[_beneficiary].length &&\n            schedules[_beneficiary][index].templateName == _templateName,\n            \"Schedule not found\"\n        );\n    }\n\n    function _isTemplateExists(bytes32 _name) internal view returns(bool) {\n        return templates[_name].numberOfTokens > 0;\n    }\n\n    function _validateTemplate(uint256 _numberOfTokens, uint256 _duration, uint256 _frequency) internal view {\n        require(_numberOfTokens > 0, \"Zero amount\");\n        require(_duration % _frequency == 0, \"Invalid frequency\");\n        uint256 periodCount = _duration.div(_frequency);\n        require(_numberOfTokens % periodCount == 0);\n        uint256 amountPerPeriod = _numberOfTokens.div(periodCount);\n        require(amountPerPeriod % securityToken.granularity() == 0, \"Invalid granularity\");\n    }\n\n    function _sendTokens(address _beneficiary) internal {\n        for (uint256 i = 0; i < schedules[_beneficiary].length; i++) {\n            _sendTokensPerSchedule(_beneficiary, i);\n        }\n    }\n\n    function _sendTokensPerSchedule(address _beneficiary, uint256 _index) internal {\n        uint256 amount = _getAvailableTokens(_beneficiary, _index);\n        if (amount > 0) {\n            schedules[_beneficiary][_index].claimedTokens = schedules[_beneficiary][_index].claimedTokens.add(amount);\n            require(securityToken.transfer(_beneficiary, amount), \"Transfer failed\");\n            emit SendTokens(_beneficiary, amount);\n        }\n    }\n\n    /**\n     * @notice Return the permissions flag that are associated with VestingEscrowWallet\n     */\n    function getPermissions() public view returns(bytes32[] memory) {\n        bytes32[] memory allPermissions = new bytes32[](2);\n        allPermissions[0] = ADMIN;\n        allPermissions[1] = OPERATOR;\n        return allPermissions;\n    }\n\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"reclaimETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitFunction\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getScheduleCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_templateName\",\"type\":\"bytes32\"},{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"addScheduleFromTemplate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTreasuryWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_templateName\",\"type\":\"bytes32\"},{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"modifySchedule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllTemplateNames\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"},{\"name\":\"_templateNames\",\"type\":\"bytes32[]\"},{\"name\":\"_numberOfTokens\",\"type\":\"uint256[]\"},{\"name\":\"_durations\",\"type\":\"uint256[]\"},{\"name\":\"_frequencies\",\"type\":\"uint256[]\"},{\"name\":\"_startTimes\",\"type\":\"uint256[]\"}],\"name\":\"addScheduleMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasuryWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"removeTemplate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unassignedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTemplateCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTreasuryWallet\",\"type\":\"address\"}],\"name\":\"changeTreasuryWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_templateName\",\"type\":\"bytes32\"}],\"name\":\"revokeSchedule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"polyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_treasuryWallet\",\"type\":\"address\"}],\"name\":\"configure\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getTemplateNames\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"schedules\",\"outputs\":[{\"name\":\"templateName\",\"type\":\"bytes32\"},{\"name\":\"claimedTokens\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"reclaimERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_templateName\",\"type\":\"bytes32\"}],\"name\":\"getSchedule\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OPERATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_templateName\",\"type\":\"bytes32\"},{\"name\":\"_numberOfTokens\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_frequency\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"addSchedule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"},{\"name\":\"_templateNames\",\"type\":\"bytes32[]\"},{\"name\":\"_startTimes\",\"type\":\"uint256[]\"}],\"name\":\"modifyScheduleMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromIndex\",\"type\":\"uint256\"},{\"name\":\"_toIndex\",\"type\":\"uint256\"}],\"name\":\"pushAvailableTokensMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"securityToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pullAvailableTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPermissions\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"},{\"name\":\"_templateNames\",\"type\":\"bytes32[]\"},{\"name\":\"_startTimes\",\"type\":\"uint256[]\"}],\"name\":\"addScheduleFromTemplateMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_numberOfTokens\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_frequency\",\"type\":\"uint256\"}],\"name\":\"addTemplate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"revokeAllSchedules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendToTreasury\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"pushAvailableTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"templateNames\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"beneficiaries\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"name\":\"revokeSchedulesMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDataStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_securityToken\",\"type\":\"address\"},{\"name\":\"_polyAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_templateName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"AddSchedule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_templateName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"ModifySchedule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"RevokeAllSchedules\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_templateName\",\"type\":\"bytes32\"}],\"name\":\"RevokeSchedule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_numberOfTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"DepositTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_numberOfTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"SendToTreasury\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"SendTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_numberOfTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_duration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_frequency\",\"type\":\"uint256\"}],\"name\":\"AddTemplate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"RemoveTemplate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_oldWallet\",\"type\":\"address\"}],\"name\":\"TreasuryWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"VestingEscrowWallet","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://031d4ca6f92c61717f95f7a04b4af8e29c3ab5e92320c7bebf83786863c1e782"}]}