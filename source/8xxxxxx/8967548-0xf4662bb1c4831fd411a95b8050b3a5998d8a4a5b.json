{"status":"1","message":"OK","result":[{"SourceCode":"/**\nAuthor: Loopring Foundation (Loopring Project Ltd)\n*/\n\npragma solidity ^0.5.11;\n\n\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    \n    \n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    \n    modifier onlyOwner()\n    {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        onlyOwner\n    {\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function renounceOwnership()\n        public\n        onlyOwner\n    {\n        emit OwnershipTransferred(owner, address(0));\n        owner = address(0);\n    }\n}\n\ncontract Claimable is Ownable\n{\n    address public pendingOwner;\n\n    \n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        onlyOwner\n    {\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\n        pendingOwner = newOwner;\n    }\n\n    \n    function claimOwnership()\n        public\n        onlyPendingOwner\n    {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\ncontract ERC20 {\n    function totalSupply()\n        public\n        view\n        returns (uint);\n\n    function balanceOf(\n        address who\n        )\n        public\n        view\n        returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n        )\n        public\n        view\n        returns (uint);\n\n    function transfer(\n        address to,\n        uint value\n        )\n        public\n        returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint    value\n        )\n        public\n        returns (bool);\n\n    function approve(\n        address spender,\n        uint    value\n        )\n        public\n        returns (bool);\n}\n\nlibrary ERC20SafeTransfer {\n    function safeTransferAndVerify(\n        address token,\n        address to,\n        uint    value\n        )\n        internal\n    {\n        safeTransferWithGasLimitAndVerify(\n            token,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint    value\n        )\n        internal\n        returns (bool)\n    {\n        return safeTransferWithGasLimit(\n            token,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferWithGasLimitAndVerify(\n        address token,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n    {\n        require(\n            safeTransferWithGasLimit(token, to, value, gasLimit),\n            \"TRANSFER_FAILURE\"\n        );\n    }\n\n    function safeTransferWithGasLimit(\n        address token,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n        returns (bool)\n    {\n        \n        \n        \n\n        \n        bytes memory callData = abi.encodeWithSelector(\n            bytes4(0xa9059cbb),\n            to,\n            value\n        );\n        (bool success, ) = token.call.gas(gasLimit)(callData);\n        return checkReturnValue(success);\n    }\n\n    function safeTransferFromAndVerify(\n        address token,\n        address from,\n        address to,\n        uint    value\n        )\n        internal\n    {\n        safeTransferFromWithGasLimitAndVerify(\n            token,\n            from,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint    value\n        )\n        internal\n        returns (bool)\n    {\n        return safeTransferFromWithGasLimit(\n            token,\n            from,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferFromWithGasLimitAndVerify(\n        address token,\n        address from,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n    {\n        bool result = safeTransferFromWithGasLimit(\n            token,\n            from,\n            to,\n            value,\n            gasLimit\n        );\n        require(result, \"TRANSFER_FAILURE\");\n    }\n\n    function safeTransferFromWithGasLimit(\n        address token,\n        address from,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n        returns (bool)\n    {\n        \n        \n        \n\n        \n        bytes memory callData = abi.encodeWithSelector(\n            bytes4(0x23b872dd),\n            from,\n            to,\n            value\n        );\n        (bool success, ) = token.call.gas(gasLimit)(callData);\n        return checkReturnValue(success);\n    }\n\n    function checkReturnValue(\n        bool success\n        )\n        internal\n        pure\n        returns (bool)\n    {\n        \n        \n        \n        if (success) {\n            assembly {\n                switch returndatasize()\n                \n                case 0 {\n                    success := 1\n                }\n                \n                case 32 {\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)\n                }\n                \n                default {\n                    success := 0\n                }\n            }\n        }\n        return success;\n    }\n}\n\nlibrary MathUint {\n    function mul(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint c)\n    {\n        c = a * b;\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\n    }\n\n    function sub(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint)\n    {\n        require(b <= a, \"SUB_UNDERFLOW\");\n        return a - b;\n    }\n\n    function add(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint c)\n    {\n        c = a + b;\n        require(c >= a, \"ADD_OVERFLOW\");\n    }\n\n    function decodeFloat(\n        uint f\n        )\n        internal\n        pure\n        returns (uint value)\n    {\n        uint numBitsMantissa = 23;\n        uint exponent = f >> numBitsMantissa;\n        uint mantissa = f & ((1 << numBitsMantissa) - 1);\n        value = mantissa * (10 ** exponent);\n    }\n}\n\ncontract ReentrancyGuard {\n    \n    uint private _guardValue;\n\n    \n    modifier nonReentrant()\n    {\n        \n        require(_guardValue == 0, \"REENTRANCY\");\n\n        \n        _guardValue = 1;\n\n        \n        _;\n\n        \n        _guardValue = 0;\n    }\n}\n\ncontract IProtocolFeeVault {\n    uint public constant REWARD_PERCENTAGE      = 70;\n    uint public constant DAO_PERDENTAGE         = 20;\n\n    address public userStakingPoolAddress;\n    address public lrcAddress;\n    address public tokenSellerAddress;\n    address public daoAddress;\n\n    uint claimedReward;\n    uint claimedDAOFund;\n    uint claimedBurn;\n\n    event LRCClaimed(uint amount);\n    event DAOFunded(uint amountDAO, uint amountBurn);\n    event TokenSold(address token, uint amount);\n    event SettingsUpdated(uint time);\n\n    \n    \n    \n    \n    function updateSettings(\n        address _userStakingPoolAddress,\n        address _tokenSellerAddress,\n        address _daoAddress\n        )\n        external;\n\n    \n    \n    \n    \n    \n    function claimStakingReward(uint amount) external;\n\n    \n    \n    function fundDAO() external;\n\n    \n    \n    \n    \n    function sellTokenForLRC(\n        address token,\n        uint    amount\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function getProtocolFeeStats()\n        public\n        view\n        returns (\n            uint accumulatedFees,\n            uint accumulatedBurn,\n            uint accumulatedDAOFund,\n            uint accumulatedReward,\n            uint remainingFees,\n            uint remainingBurn,\n            uint remainingDAOFund,\n            uint remainingReward\n        );\n}\n\ncontract IUserStakingPool {\n    uint public constant MIN_CLAIM_DELAY        = 90 days;\n    uint public constant MIN_WITHDRAW_DELAY     = 90 days;\n\n    address public lrcAddress;\n    address public protocolFeeVaultAddress;\n\n    uint    public numAddresses;\n\n    event ProtocolFeeVaultChanged (address feeVaultAddress);\n\n    event LRCStaked       (address indexed user,  uint amount);\n    event LRCWithdrawn    (address indexed user,  uint amount);\n    event LRCRewarded     (address indexed user,  uint amount);\n\n    \n    \n    function setProtocolFeeVault(address _protocolFeeVaultAddress)\n        external;\n\n    \n    function getTotalStaking()\n        public\n        view\n        returns (uint);\n\n    \n    \n    \n    \n    \n    \n    function getUserStaking(address user)\n        public\n        view\n        returns (\n            uint withdrawalWaitTime,\n            uint rewardWaitTime,\n            uint balance,\n            uint pendingReward\n        );\n\n    \n    \n    \n    function stake(uint amount)\n        external;\n\n    \n    \n    function withdraw(uint amount)\n        external;\n\n    \n    \n    \n    function claim()\n        external\n        returns (uint claimedAmount);\n}\n\ncontract UserStakingPool is Claimable, ReentrancyGuard, IUserStakingPool\n{\n    using ERC20SafeTransfer for address;\n    using MathUint          for uint;\n\n    struct Staking {\n        uint   balance;        \n        uint64 depositedAt;\n        uint64 claimedAt;      \n    }\n\n    Staking public total;\n    mapping (address => Staking) public stakings;\n\n    constructor(address _lrcAddress)\n        Claimable()\n        public\n    {\n        require(_lrcAddress != address(0), \"ZERO_ADDRESS\");\n        lrcAddress = _lrcAddress;\n    }\n\n    function setProtocolFeeVault(address _protocolFeeVaultAddress)\n        external\n        nonReentrant\n        onlyOwner\n    {\n        \n        protocolFeeVaultAddress = _protocolFeeVaultAddress;\n        emit ProtocolFeeVaultChanged(protocolFeeVaultAddress);\n    }\n\n    function getTotalStaking()\n        public\n        view\n        returns (uint)\n    {\n        return total.balance;\n    }\n\n    function getUserStaking(address user)\n        public\n        view\n        returns (\n            uint withdrawalWaitTime,\n            uint rewardWaitTime,\n            uint balance,\n            uint pendingReward\n        )\n    {\n        withdrawalWaitTime = getUserWithdrawalWaitTime(user);\n        rewardWaitTime = getUserClaimWaitTime(user);\n        balance = stakings[user].balance;\n        (, , pendingReward) = getUserPendingReward(user);\n    }\n\n    function stake(uint amount)\n        external\n        nonReentrant\n    {\n        require(amount > 0, \"ZERO_VALUE\");\n\n        \n        lrcAddress.safeTransferFromAndVerify(msg.sender, address(this), amount);\n\n        Staking storage user = stakings[msg.sender];\n\n        if (user.balance == 0) {\n            numAddresses += 1;\n        }\n\n        \n        uint balance = user.balance.add(amount);\n\n        user.depositedAt = uint64(\n            user.balance\n                .mul(user.depositedAt)\n                .add(amount.mul(now)) / balance\n        );\n\n        user.claimedAt = uint64(\n            user.balance\n                .mul(user.claimedAt)\n                .add(amount.mul(now)) / balance\n        );\n\n        user.balance = balance;\n\n        \n        balance = total.balance.add(amount);\n\n        total.claimedAt = uint64(\n            total.balance\n                .mul(total.claimedAt)\n                .add(amount.mul(now)) / balance\n        );\n\n        total.balance = balance;\n\n        emit LRCStaked(msg.sender, amount);\n    }\n\n    function withdraw(uint amount)\n        external\n        nonReentrant\n    {\n        require(getUserWithdrawalWaitTime(msg.sender) == 0, \"NEED_TO_WAIT\");\n\n        \n        if (protocolFeeVaultAddress != address(0) &&\n            getUserClaimWaitTime(msg.sender) == 0) {\n            claimReward();\n        }\n\n        Staking storage user = stakings[msg.sender];\n\n        uint _amount = (amount == 0 || amount > user.balance) ? user.balance : amount;\n        require(_amount > 0, \"ZERO_BALANCE\");\n\n        total.balance = total.balance.sub(_amount);\n        user.balance = user.balance.sub(_amount);\n\n        if (user.balance == 0) {\n            numAddresses -= 1;\n            delete stakings[msg.sender];\n        }\n\n        \n        lrcAddress.safeTransferAndVerify(msg.sender, _amount);\n\n        emit LRCWithdrawn(msg.sender, _amount);\n    }\n\n    function claim()\n        external\n        nonReentrant\n        returns (uint claimedAmount)\n    {\n        return claimReward();\n    }\n\n    \n\n    function claimReward()\n        private\n        returns (uint claimedAmount)\n    {\n        require(protocolFeeVaultAddress != address(0), \"ZERO_ADDRESS\");\n        require(getUserClaimWaitTime(msg.sender) == 0, \"NEED_TO_WAIT\");\n\n        uint totalPoints;\n        uint userPoints;\n\n        (totalPoints, userPoints, claimedAmount) = getUserPendingReward(msg.sender);\n\n        if (claimedAmount > 0) {\n            IProtocolFeeVault(protocolFeeVaultAddress).claimStakingReward(claimedAmount);\n\n            total.balance = total.balance.add(claimedAmount);\n\n            total.claimedAt = uint64(\n                now.sub(totalPoints.sub(userPoints) / total.balance)\n            );\n\n            Staking storage user = stakings[msg.sender];\n            user.balance = user.balance.add(claimedAmount);\n            user.claimedAt = uint64(now);\n        }\n        emit LRCRewarded(msg.sender, claimedAmount);\n    }\n\n    function getUserWithdrawalWaitTime(address user)\n        private\n        view\n        returns (uint)\n    {\n        uint depositedAt = stakings[user].depositedAt;\n        if (depositedAt == 0) {\n            return MIN_WITHDRAW_DELAY;\n        } else {\n            uint time = depositedAt + MIN_WITHDRAW_DELAY;\n            return (time <= now) ? 0 : time.sub(now);\n        }\n    }\n\n    function getUserClaimWaitTime(address user)\n        private\n        view\n        returns (uint)\n    {\n        uint claimedAt = stakings[user].claimedAt;\n        if (claimedAt == 0) {\n            return MIN_CLAIM_DELAY;\n        } else {\n            uint time = stakings[user].claimedAt + MIN_CLAIM_DELAY;\n            return (time <= now) ? 0 : time.sub(now);\n        }\n    }\n\n    function getUserPendingReward(address user)\n        private\n        view\n        returns (\n            uint totalPoints,\n            uint userPoints,\n            uint pendingReward\n        )\n    {\n        Staking storage staking = stakings[user];\n\n        \n        totalPoints = total.balance.mul(now.sub(total.claimedAt).add(1));\n        userPoints = staking.balance.mul(now.sub(staking.claimedAt));\n\n        \n        if (totalPoints < userPoints) {\n            userPoints = totalPoints;\n        }\n\n        if (protocolFeeVaultAddress != address(0) &&\n            totalPoints != 0 &&\n            userPoints != 0) {\n            (, , , , , , , pendingReward) = IProtocolFeeVault(\n                protocolFeeVaultAddress\n            ).getProtocolFeeStats();\n            pendingReward = pendingReward.mul(userPoints) / totalPoints;\n        }\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawalWaitTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardWaitTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"depositedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"claimedAt\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numAddresses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lrcAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_CLAIM_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocolFeeVaultAddress\",\"type\":\"address\"}],\"name\":\"setProtocolFeeVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_WITHDRAW_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"protocolFeeVaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"depositedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"claimedAt\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lrcAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeVaultAddress\",\"type\":\"address\"}],\"name\":\"ProtocolFeeVaultChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LRCStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LRCWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LRCRewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"UserStakingPool","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bbbbca6a901c926f240b89eacb641d8aec7aeafd","Library":"","LicenseType":"","SwarmSource":"bzzr://3a8d4f4a474e4e4cf5f39ea7846c3a11c33125afc08eae8ed969ba8bfb4f4f7b"}]}