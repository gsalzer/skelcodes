{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\ncontract simple_contract {\r\n    mapping (bytes32 => uint8[]) public vMap;\r\n    mapping (bytes32 => bytes32[]) public rMap;\r\n    mapping (bytes32 => bytes32[]) public sMap;\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    /*\r\n    ecrecover : check signer\r\n    */\r\n    function addSign(bytes32 hash, uint8[] vArray, bytes32[] rArray, bytes32[] sArray, address[] addrArray) public {\r\n        require(vMap[hash].length == 0 && rMap[hash].length == 0 && sMap[hash].length == 0, \"no map\");\r\n        require(vArray.length == rArray.length && rArray.length == sArray.length, \"invalid map\");\r\n        require(addrArray.length > 0 && addrArray.length < 1000, \"invalid address array length\");\r\n        require(_checkDistinctParties(addrArray), \"invalid address array\");\r\n        vMap[hash] = new uint8[](vArray.length);\r\n        rMap[hash] = new bytes32[](vArray.length);\r\n        sMap[hash] = new bytes32[](vArray.length);\r\n        for (uint256 i = 0; i < vArray.length; i++) {\r\n            vMap[hash][i] = vArray[i];\r\n            rMap[hash][i] = rArray[i];\r\n            sMap[hash][i] = sArray[i];\r\n\r\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n            bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\r\n            require(ecrecover(prefixedHash, vArray[i], rArray[i], sArray[i]) == addrArray[i], \"ecrecover fail\");\r\n        }\r\n    }\r\n\r\n    function getAddresses(bytes32 hash) public view returns (address[]) {\r\n        uint8[] storage vArray = vMap[hash];\r\n        bytes32[] storage rArray = rMap[hash];\r\n        bytes32[] storage sArray = sMap[hash];\r\n        address[] memory addrArray = new address[](vArray.length);\r\n        require(vArray.length > 0 && rArray.length > 0 && sArray.length > 0);\r\n        for (uint256 i = 0; i < vArray.length; i++) {\r\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n            bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\r\n            addrArray[i] = ecrecover(prefixedHash, vArray[i], rArray[i], sArray[i]);\r\n        }\r\n        return addrArray;\r\n    }\r\n\r\n    function getEcrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    function _checkDistinctParties(address[] _parties) private pure returns (bool) {\r\n        for (uint256 i = 0; i < _parties.length; i++) {\r\n            for (uint256 j = i + 1; j < _parties.length; j++) {\r\n                if (_parties[i] == _parties[j]) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sMap\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"getAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"getEcrecover\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rMap\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"vArray\",\"type\":\"uint8[]\"},{\"name\":\"rArray\",\"type\":\"bytes32[]\"},{\"name\":\"sArray\",\"type\":\"bytes32[]\"},{\"name\":\"addrArray\",\"type\":\"address[]\"}],\"name\":\"addSign\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"simple_contract","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://b3adf41b13926028acbfad8a5e4c9c45c2527c6aed9acbc66920131fba68990c"}]}