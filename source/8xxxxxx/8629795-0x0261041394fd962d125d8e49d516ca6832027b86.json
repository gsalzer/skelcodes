{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-09-27\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2019-09-24\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2019-09-24\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2019-09-20\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2019-09-20\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2019-09-11\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2019-09-11\r\n*/\r\n\r\npragma solidity ^0.5.11;\r\n\r\ncontract Token {\r\n  function transfer(address to, uint256 value) public returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool success);\r\n     function balanceOf(address account) external view returns(uint256);\r\n     function allowance(address _owner, address _spender)external view returns(uint256);\r\n}\r\n\r\nlibrary SafeMath{\r\n      function mul(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        if (a == 0) {\r\n        return 0;}\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract StableDEX {\r\n    using SafeMath for uint256;\r\n    \r\n    event DepositandWithdraw(address from,address tokenAddress,uint256 amount,uint256 type_); //Type = 0-deposit 1- withdraw , Token address = address(0) - eth , address - token address;\r\n    \r\n    address payable admin;\r\n    \r\n    address public feeAddress;\r\n    \r\n    bool private dexStatus;   \r\n      \r\n    uint256 public tokenId=0;\r\n      \r\n    struct orders{\r\n        address userAddress;\r\n        address tokenAddress;\r\n        uint256 type_;\r\n        uint256 price;\r\n        uint256 total;\r\n        uint256 _decimal;\r\n        uint256 tradeTotal;\r\n        uint256 amount;\r\n        uint256 tradeAmount;\r\n        uint256 pairOrderID;\r\n        uint256 status; \r\n    }\r\n    \r\n    struct tokens{\r\n        address tokenAddress;\r\n        string tokenSymbol;\r\n        uint256 decimals;\r\n        bool status;\r\n    }\r\n    \r\n    \r\n    constructor(address payable _admin,address feeAddress_) public{\r\n        admin = _admin;\r\n        feeAddress = feeAddress_;\r\n        dexStatus = true;\r\n    }\r\n\r\n    \r\n    mapping(uint256=>orders) public Order; //place order by passing userID and orderID as argument;\r\n    \r\n    mapping(address=>mapping(address=>uint256))public userDetails;  // trader token balance;\r\n    \r\n    mapping(address=>mapping(address=>uint256))public feeAmount;\r\n    \r\n     mapping(address=>uint256) public withdrawfee;\r\n     \r\n     mapping(uint256=>mapping(uint256=>bool)) public orderPairStatus;\r\n     \r\n     mapping(address=>tokens) public tokendetails;\r\n    \r\n    modifier dexstatuscheck(){\r\n       require(dexStatus==true);\r\n       _;\r\n    }\r\n    \r\n    function setDexStatus(bool status_) public returns(bool){\r\n        require(msg.sender == admin);\r\n        dexStatus = status_;\r\n        return true;\r\n    }   \r\n    \r\n    function addToken(address tokenAddress,string memory tokenSymbol,uint256 decimal_) public returns(bool){\r\n        require(msg.sender == feeAddress && tokendetails[tokenAddress].status==false);\r\n        tokendetails[tokenAddress].tokenSymbol=tokenSymbol;\r\n        tokendetails[tokenAddress].decimals=decimal_;\r\n        tokendetails[tokenAddress].status=true;\r\n        return true;\r\n    }\r\n    \r\n    function deposit() dexstatuscheck public payable returns(bool) {\r\n        require(msg.value > 0);\r\n        userDetails[msg.sender][address(0)]=userDetails[msg.sender][address(0)].add(msg.value);\r\n        emit DepositandWithdraw( msg.sender, address(0),msg.value,0);\r\n        return true;\r\n    }\r\n    \r\n    function tokenDeposit(address tokenaddr,uint256 tokenAmount) dexstatuscheck public returns(bool)\r\n    {\r\n        require(tokenAmount > 0 && tokendetails[tokenaddr].status==true);\r\n        require(tokenallowance(tokenaddr,msg.sender) > 0);\r\n        userDetails[msg.sender][tokenaddr] = userDetails[msg.sender][tokenaddr].add(tokenAmount);\r\n        Token(tokenaddr).transferFrom(msg.sender,address(this), tokenAmount);\r\n        emit DepositandWithdraw( msg.sender,tokenaddr,tokenAmount,0);\r\n        return true;\r\n        \r\n    }\r\n  \r\n    function withdraw(uint8 type_,address tokenaddr,uint256 amount) dexstatuscheck public returns(bool) {\r\n        require(type_ ==0 || type_ == 1);\r\n         if(type_==0){ // withdraw ether\r\n         require(tokenaddr == address(0));\r\n         require(amount>0 && amount <= userDetails[msg.sender][address(0)] && withdrawfee[address(0)]<amount);\r\n         require(amount<=address(this).balance);\r\n                msg.sender.transfer(amount.sub(withdrawfee[address(0)]));    \r\n                userDetails[msg.sender][address(0)] = userDetails[msg.sender][address(0)].sub(amount);\r\n                feeAmount[admin][address(0)] = feeAmount[admin][address(0)].add(withdrawfee[address(0)]);\r\n                \r\n        }\r\n        else{ //withdraw token\r\n        require(tokenaddr != address(0) && tokendetails[tokenaddr].status==true);\r\n        require(amount>0 && amount <= userDetails[msg.sender][tokenaddr] && withdrawfee[tokenaddr]<amount);\r\n              Token(tokenaddr).transfer(msg.sender, (amount.sub(withdrawfee[tokenaddr])));\r\n              userDetails[msg.sender][tokenaddr] = userDetails[msg.sender][tokenaddr].sub(amount);\r\n              feeAmount[admin][tokenaddr] = feeAmount[admin][tokenaddr].add(withdrawfee[tokenaddr]);\r\n        }\r\n        emit DepositandWithdraw( msg.sender,tokenaddr,amount,1);\r\n        return true;\r\n    }\r\n\r\n     function adminProfitWithdraw(uint8 type_,address tokenAddr)public returns(bool){ //  tokenAddr = type 0 - address(0),  type 1 - token address;\r\n       require(msg.sender == admin);\r\n       require(type_ ==0 || type_ == 1);\r\n         if(type_==0){ // withdraw ether\r\n            admin.transfer(feeAmount[admin][address(0)]);\r\n            feeAmount[admin][address(0)]=0;\r\n                \r\n        }\r\n        else{ //withdraw token\r\n            require(tokenAddr != address(0)) ;\r\n            Token(tokenAddr).transfer(admin, feeAmount[admin][tokenAddr]);\r\n            feeAmount[admin][tokenAddr]=0;\r\n        }\r\n           \r\n          \r\n            return true;\r\n        }\r\n        \r\n        \r\n    function setwithdrawfee(address[] memory addr,uint256[] memory feeamount)public returns(bool)\r\n        {\r\n          require(msg.sender==admin);\r\n          //array length should be within 10.\r\n          require(addr.length <10 && feeamount.length < 10 && addr.length==feeamount.length);\r\n          for(uint8 i=0;i<addr.length;i++){\r\n            withdrawfee[addr[i]]=feeamount[i];    \r\n          }\r\n           return true;\r\n        }\r\n    \r\n\r\n    \r\n    function verify(string memory  message, uint8 v, bytes32 r, bytes32 s) private pure returns (address signer) {\r\n        string memory header = \"\\x19Ethereum Signed Message:\\n000000\";\r\n        uint256 lengthOffset;\r\n        uint256 length;\r\n        assembly {\r\n            length := mload(message)\r\n            lengthOffset := add(header, 57)\r\n        }\r\n        require(length <= 999999);\r\n        uint256 lengthLength = 0;\r\n        uint256 divisor = 100000; \r\n        while (divisor != 0) {\r\n            uint256 digit = length.div(divisor);\r\n            if (digit == 0) {\r\n             \r\n                if (lengthLength == 0) {\r\n                      divisor = divisor.div(10);\r\n                      continue;\r\n                    }\r\n            }\r\n            lengthLength++;\r\n            length = length.sub(digit.mul(divisor));\r\n            divisor = divisor.div(10);\r\n            digit = digit.add(0x30);\r\n            lengthOffset++;\r\n            assembly {\r\n                mstore8(lengthOffset, digit)\r\n            }\r\n        }  \r\n        if (lengthLength == 0) {\r\n            lengthLength = 1 + 0x19 + 1;\r\n        } else {\r\n            lengthLength = lengthLength.add(1 + 0x19);\r\n        }\r\n        assembly {\r\n            mstore(header, lengthLength)\r\n        }\r\n        bytes32 check = keccak256(abi.encodePacked(header, message));\r\n        return ecrecover(check, v, r, s);\r\n    }\r\n            \r\n            \r\n \r\n    \r\n    \r\n     function makeOrder(uint256[9] memory tradeDetails,address[2] memory traderAddresses,string memory message,uint8  v,bytes32 r,bytes32 s) dexstatuscheck public returns(bool){\r\n      require(msg.sender == feeAddress);\r\n       require(verify((message),v,r,s)==traderAddresses[1]);\r\n        \r\n      \r\n    // First array (tradeDetails)\r\n      // 0- orderid\r\n      // 1- amount\r\n      // 2- price\r\n      // 3- total\r\n      // 4- buyerFee\r\n      // 5 - sellerFee\r\n      // 6 - type\r\n      // 7- decimal\r\n      // 8 - pairOrderID\r\n\r\n \r\n    // Second  array (traderAddresses)\r\n      // 0- tokenAddress\r\n      // 1- userAddress\r\n    \r\n    \r\n      uint256 amount__;\r\n       \r\n        uint256 orderiD = tradeDetails[0];\r\n        if(Order[orderiD].status==0){   // if status code = 0 - new order, will store order details.\r\n        \r\n            if(tradeDetails[6] == 0){\r\n                amount__ = tradeDetails[3];\r\n            }\r\n            else if(tradeDetails[6] ==1){\r\n                amount__ = tradeDetails[1];\r\n            }\r\n            require(amount__ > 0 && amount__ <= userDetails[traderAddresses[1]][traderAddresses[0]]);\r\n                // stores placed order details\r\n                Order[orderiD].userAddress = traderAddresses[1];\r\n                Order[orderiD].type_ = tradeDetails[6];\r\n                Order[orderiD].price = tradeDetails[2];\r\n                Order[orderiD].amount  = tradeDetails[1];\r\n                Order[orderiD].total  = tradeDetails[3];\r\n                Order[orderiD].tradeTotal  = tradeDetails[3];\r\n                Order[orderiD]._decimal  = tradeDetails[7];\r\n                Order[orderiD].tokenAddress = traderAddresses[0];       \r\n                // freeze trade amount;\r\n                userDetails[traderAddresses[1]][traderAddresses[0]]=userDetails[traderAddresses[1]][traderAddresses[0]].sub(amount__);\r\n                // store total trade count\r\n                Order[orderiD].tradeAmount=tradeDetails[1];\r\n                Order[orderiD].status=1;\r\n            \r\n        }\r\n        else if(Order[orderiD].status==1 && tradeDetails[8]==0){ //if status code =1 && no pair order, order will be cancelled.\r\n            cancelOrder(orderiD);\r\n        }\r\n        if(Order[orderiD].status==1 && tradeDetails[1] > 0 && tradeDetails[8]>0 && Order[tradeDetails[8]].status==1 && tradeDetails[3]>0){ //order mapping\r\n                \r\n                Order[orderiD].tradeAmount =Order[orderiD].tradeAmount.sub(tradeDetails[1]);\r\n                Order[tradeDetails[8]].tradeAmount =Order[tradeDetails[8]].tradeAmount.sub(tradeDetails[1]);\r\n                if(tradeDetails[2]>0){\r\n                    userDetails[Order[orderiD].userAddress][Order[orderiD].tokenAddress]=userDetails[Order[orderiD].userAddress][Order[orderiD].tokenAddress].add(tradeDetails[2]);\r\n                }\r\n                Order[orderiD].tradeTotal =Order[orderiD].tradeTotal.sub(((tradeDetails[1].mul(Order[orderiD].price)).div(Order[orderiD]._decimal)));\r\n                Order[tradeDetails[8]].tradeTotal =Order[tradeDetails[8]].tradeTotal.sub(((tradeDetails[1].mul(Order[tradeDetails[8]].price)).div(Order[tradeDetails[8]]._decimal)));\r\n                \r\n               \r\n                    if(tradeDetails[6] == 1 || tradeDetails[6]==3)\r\n                    {\r\n                        userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress]=userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress].add(tradeDetails[1]);\r\n                        userDetails[Order[orderiD].userAddress][traderAddresses[0]]= userDetails[Order[orderiD].userAddress][traderAddresses[0]].sub(tradeDetails[4]);    \r\n                        feeAmount[admin][traderAddresses[0]]= feeAmount[admin][traderAddresses[0]].add(tradeDetails[4]);\r\n                    }\r\n                    else\r\n                    {\r\n                         userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress]=userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress].add(tradeDetails[1].sub(tradeDetails[4]));\r\n                            feeAmount[admin][Order[tradeDetails[8]].tokenAddress]= feeAmount[admin][Order[tradeDetails[8]].tokenAddress].add(tradeDetails[4]);\r\n                    }\r\n                    if(tradeDetails[6] == 2 || tradeDetails[6]==3)\r\n                    {\r\n                        userDetails[Order[tradeDetails[8]].userAddress][Order[orderiD].tokenAddress]=userDetails[Order[tradeDetails[8]].userAddress][Order[orderiD].tokenAddress].add(tradeDetails[3]);\r\n                        userDetails[Order[tradeDetails[8]].userAddress][traderAddresses[0]]= userDetails[Order[tradeDetails[8]].userAddress][traderAddresses[0]].sub(tradeDetails[5]);\r\n                        feeAmount[admin][traderAddresses[0]]= feeAmount[admin][traderAddresses[0]].add(tradeDetails[5]);\r\n                    }\r\n                    else\r\n                    {\r\n                         userDetails[Order[tradeDetails[8]].userAddress][Order[orderiD].tokenAddress]=userDetails[Order[tradeDetails[8]].userAddress][Order[orderiD].tokenAddress].add(tradeDetails[1].sub(tradeDetails[5]));\r\n                         feeAmount[admin][Order[orderiD].tokenAddress]= feeAmount[admin][Order[orderiD].tokenAddress].add(tradeDetails[5]);\r\n                    }\r\n              \r\n                \r\n                if(Order[tradeDetails[8]].tradeAmount==0){\r\n                    Order[tradeDetails[8]].status=2;    \r\n                }\r\n                if(Order[orderiD].tradeAmount==0){\r\n                    Order[orderiD].status=2;    \r\n                }\r\n                orderPairStatus[orderiD][tradeDetails[8]] = true;\r\n            }\r\n\r\n        return true; \r\n    }\r\n\r\n    function cancelOrder(uint256 orderid)internal returns(bool){\r\n        if(Order[orderid].status==1){\r\n            if(Order[orderid].type_ == 0){\r\n            userDetails[ Order[orderid].userAddress][Order[orderid].tokenAddress]=userDetails[ Order[orderid].userAddress][Order[orderid].tokenAddress].add(Order[orderid].tradeTotal);        \r\n            }\r\n            else{\r\n                userDetails[ Order[orderid].userAddress][Order[orderid].tokenAddress]=userDetails[ Order[orderid].userAddress][Order[orderid].tokenAddress].add(Order[orderid].tradeAmount);\r\n            }\r\n            Order[orderid].status=3;    // cancelled\r\n        }\r\n        return true;\r\n}\r\n    \r\n    \r\n     function viewTokenBalance(address tokenAddr,address baladdr)public view returns(uint256){\r\n        return Token(tokenAddr).balanceOf(baladdr);\r\n    }\r\n    \r\n    function tokenallowance(address tokenAddr,address owner) public view returns(uint256){\r\n        return Token(tokenAddr).allowance(owner,address(this));\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"tokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokendetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenaddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"tokenDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"type_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"adminProfitWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[9]\",\"name\":\"tradeDetails\",\"type\":\"uint256[9]\"},{\"internalType\":\"address[2]\",\"name\":\"traderAddresses\",\"type\":\"address[2]\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"makeOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"type_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"tokenaddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status_\",\"type\":\"bool\"}],\"name\":\"setDexStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderPairStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Order\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"type_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decimal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradeTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pairOrderID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"feeamount\",\"type\":\"uint256[]\"}],\"name\":\"setwithdrawfee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baladdr\",\"type\":\"address\"}],\"name\":\"viewTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimal_\",\"type\":\"uint256\"}],\"name\":\"addToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokenallowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeAddress_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"type_\",\"type\":\"uint256\"}],\"name\":\"DepositandWithdraw\",\"type\":\"event\"}]","ContractName":"StableDEX","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002442835142090e3718dd47b5ba5d85958f783fc300000000000000000000000052d382564471a36da526b5a22d1de1e0a6eea05a","Library":"","LicenseType":"None","SwarmSource":"bzzr://60c953e3d1f1cd93bb52d5a278fc0cdd184eda70007a59ad52433c7a7dea1ecc"}]}