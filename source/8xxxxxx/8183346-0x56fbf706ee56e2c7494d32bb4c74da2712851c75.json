{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/passThrough/PassThroughStorage.sol\r\n\r\ncontract PassThroughStorage {\r\n    bytes4 public constant ERC721_Received = 0x150b7a02;\r\n    uint256 public constant MAX_EXPIRATION_TIME = (365 * 2 days) - 170;\r\n    mapping(bytes4 => uint256) public disableMethods;\r\n\r\n    address public estateRegistry;\r\n    address public operator;\r\n    address public target;\r\n\r\n    event MethodAllowed(\r\n      address indexed _caller,\r\n      bytes4 indexed _signatureBytes4,\r\n      string _signature\r\n    );\r\n\r\n    event MethodDisabled(\r\n      address indexed _caller,\r\n      bytes4 indexed _signatureBytes4,\r\n      string _signature\r\n    );\r\n\r\n    event TargetChanged(\r\n      address indexed _caller,\r\n      address indexed _oldTarget,\r\n      address indexed _newTarget\r\n    );\r\n}\r\n\r\n// File: contracts/passThrough/PassThrough.sol\r\n\r\ncontract PassThrough is Ownable, PassThroughStorage {\r\n    using Address for address;\r\n\r\n    /**\r\n    * @dev Constructor of the contract.\r\n    */\r\n    constructor(address _estateRegistry, address _operator) Ownable() public {\r\n        estateRegistry = _estateRegistry;\r\n        operator = _operator;\r\n\r\n        // Set target\r\n        setTarget(estateRegistry);\r\n\r\n        // ERC721 methods\r\n        disableMethod(\"approve(address,uint256)\", MAX_EXPIRATION_TIME);\r\n        disableMethod(\"setApprovalForAll(address,bool)\", MAX_EXPIRATION_TIME);\r\n        disableMethod(\"transferFrom(address,address,uint256)\", MAX_EXPIRATION_TIME);\r\n        disableMethod(\"safeTransferFrom(address,address,uint256)\", MAX_EXPIRATION_TIME);\r\n        disableMethod(\"safeTransferFrom(address,address,uint256,bytes)\", MAX_EXPIRATION_TIME);\r\n\r\n        // EstateRegistry methods\r\n        disableMethod(\"transferLand(uint256,uint256,address)\", MAX_EXPIRATION_TIME);\r\n        disableMethod(\"transferManyLands(uint256,uint256[],address)\", MAX_EXPIRATION_TIME);\r\n        disableMethod(\"safeTransferManyFrom(address,address,uint256[])\", MAX_EXPIRATION_TIME);\r\n        disableMethod(\"safeTransferManyFrom(address,address,uint256[],bytes)\", MAX_EXPIRATION_TIME);\r\n        disableMethod(\"transferLandToEstate(int256,int256,uint256)\", MAX_EXPIRATION_TIME);\r\n        disableMethod(\"transferManyLandToEstate(int256[],int256[],uint256)\", MAX_EXPIRATION_TIME);\r\n    }\r\n\r\n    /**\r\n    * @dev Fallback function could be called by the operator, if the method is allowed, or\r\n    * by the owner. If the call was unsuccessful will revert.\r\n    */\r\n    function() external payable {\r\n        require(\r\n            isOperator() && isMethodAllowed(msg.sig) || isOwner(),\r\n            \"Permission denied\"\r\n        );\r\n\r\n        bytes memory _calldata = msg.data;\r\n        uint256 _calldataSize = msg.data.length;\r\n        address _dst = target;\r\n        uint256 _msgValue = msg.value;\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let result := call(sub(gas, 10000), _dst, _msgValue, add(_calldata, 0x20), _calldataSize, 0, 0)\r\n            let size := returndatasize\r\n\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n            // if the call returned error data, forward it\r\n            if iszero(result) { revert(ptr, size) }\r\n            return(ptr, size)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Check if sender is the operator\r\n    * @return bool whether is sender is the caller or not\r\n    */\r\n    function isOperator() internal view returns (bool) {\r\n        return msg.sender == operator;\r\n    }\r\n\r\n    /**\r\n    * @dev Check if a method is allowed\r\n    * @param _signature string - method signature\r\n    * @return bool - whether method is allowed or not\r\n    */\r\n    function isMethodAllowed(bytes4 _signature) internal view returns (bool) {\r\n        return disableMethods[_signature] < block.timestamp;\r\n    }\r\n\r\n    function setTarget(address _target) public {\r\n        require(\r\n            _target.isContract() && _target != address(this), \r\n            \"The target should be a contract and different of the pass-throug contract\"\r\n        );\r\n\r\n        require(\r\n            isOperator() || isOwner(),\r\n            \"Permission denied\"\r\n        );\r\n\r\n        emit TargetChanged(msg.sender, target, _target);\r\n        target = _target;\r\n    }\r\n\r\n    /**\r\n    * @dev Disable a method for two years\r\n    * Note that the input expected is the method signature as 'transfer(address,uint256)'\r\n    * @param _signature string - method signature\r\n    */\r\n    function disableMethod(string memory _signature, uint256 _time) public onlyOwner {\r\n        require(_time > 0, \"Time should be greater than 0\");\r\n        require(_time <= MAX_EXPIRATION_TIME, \"Time should be lower than 2 years\");\r\n\r\n        bytes4 signatureBytes4 = convertToBytes4(abi.encodeWithSignature(_signature));\r\n        disableMethods[signatureBytes4] = block.timestamp + _time;\r\n\r\n        emit MethodDisabled(msg.sender, signatureBytes4, _signature);\r\n    }\r\n\r\n    /**\r\n    * @dev Allow a method previously disabled\r\n    * Note that the input expected is the method signature as 'transfer(address,uint256)'\r\n    * @param _signature string - method signature\r\n    */\r\n    function allowMethod(string memory _signature) public onlyOwner {\r\n        bytes4 signatureBytes4 = convertToBytes4(abi.encodeWithSignature(_signature));\r\n        require(!isMethodAllowed(signatureBytes4), \"Method is already allowed\");\r\n\r\n        disableMethods[signatureBytes4] = 0;\r\n\r\n        emit MethodAllowed(msg.sender, signatureBytes4, _signature);\r\n    }\r\n\r\n    /**\r\n    * @dev Convert bytes to bytes4\r\n    * @param _signature bytes - method signature\r\n    * @return bytes4 - method signature in bytes4\r\n    */\r\n    function convertToBytes4(bytes memory _signature) internal pure returns (bytes4) {\r\n        require(_signature.length == 4, \"Invalid method signature\");\r\n        bytes4 signatureBytes4;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            signatureBytes4 := mload(add(_signature, 32))\r\n        }\r\n        return signatureBytes4;\r\n    }\r\n\r\n    /**\r\n    * @notice Handle the receipt of an NFT\r\n    * @dev The ERC721 smart contract calls this function on the recipient\r\n    * after a `safetransfer`. This function MAY throw to revert and reject the\r\n    * transfer. Return of other than the magic value MUST result in the\r\n    * transaction being reverted.\r\n    * Note: the contract address is always the message sender.\r\n    * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    */\r\n    function onERC721Received(\r\n        address /*_from*/,\r\n        address /*_to*/,\r\n        uint256 /*_tokenId*/,\r\n        bytes memory /*_data*/\r\n    )\r\n        public\r\n        view\r\n        returns (bytes4)\r\n    {\r\n        require(msg.sender == estateRegistry, \"Token not accepted\");\r\n        return ERC721_Received;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_EXPIRATION_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"disableMethods\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERC721_Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"string\"}],\"name\":\"allowMethod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"setTarget\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"string\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"disableMethod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"estateRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_estateRegistry\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_signatureBytes4\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"_signature\",\"type\":\"string\"}],\"name\":\"MethodAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_signatureBytes4\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"_signature\",\"type\":\"string\"}],\"name\":\"MethodDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_oldTarget\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newTarget\",\"type\":\"address\"}],\"name\":\"TargetChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PassThrough","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000959e104e1a4db6317fa58f8295f586e1a978c29700000000000000000000000074a766c77766e7a577d9025eb9357549adb3dd16","Library":"","SwarmSource":"bzzr://2bea60088ac9a7a0921cbbb66856dd6e550a6a112e9af17bdbc4fb2d173959a3"}]}