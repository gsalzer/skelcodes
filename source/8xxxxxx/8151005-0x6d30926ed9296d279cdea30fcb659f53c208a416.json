{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract IZrxExchange {\r\n\r\n    struct Order {\r\n        address makerAddress;           // Address that created the order.\r\n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\r\n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\r\n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\r\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\r\n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\r\n        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\r\n        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\r\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\r\n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.\r\n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\r\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\r\n    }\r\n\r\n    struct OrderInfo {\r\n        uint8 orderStatus;                    // Status that describes order's validity and fillability.\r\n        bytes32 orderHash;                    // EIP712 hash of the order (see IZrxExchange.getOrderHash).\r\n        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\r\n    }\r\n\r\n    struct FillResults {\r\n        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\r\n        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\r\n        uint256 makerFeePaid;            // Total amount of ZRX paid by maker(s) to feeRecipient(s).\r\n        uint256 takerFeePaid;            // Total amount of ZRX paid by taker to feeRecipients(s).\r\n    }\r\n\r\n    function getOrderInfo(Order memory order)\r\n        public\r\n        view\r\n        returns (OrderInfo memory orderInfo);\r\n\r\n    function getOrdersInfo(Order[] memory orders)\r\n        public\r\n        view\r\n        returns (OrderInfo[] memory ordersInfo);\r\n\r\n    function fillOrder(\r\n        Order memory order,\r\n        uint256 takerAssetFillAmount,\r\n        bytes memory signature\r\n    )\r\n        public\r\n        returns (FillResults memory fillResults);\r\n}\r\n\r\ncontract IERC20NonView {\r\n    // Methods are not view to avoid throw on proxy tokens with delegatecall inside\r\n    function balanceOf(address user) public returns(uint256);\r\n    function allowance(address from, address to) public returns(uint256);\r\n}\r\n\r\ncontract ZrxMarketOrder {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    function marketSellOrders(\r\n        address makerAsset,\r\n        address zrxExchange,\r\n        address zrxTokenProxy,\r\n        uint256 takerAssetFillAmount,\r\n        IZrxExchange.Order[] calldata orders,\r\n        bytes[] calldata signatures\r\n    )\r\n        external\r\n        returns (IZrxExchange.FillResults memory totalFillResults)\r\n    {\r\n        for (uint i = 0; i < orders.length; i++) {\r\n\r\n            // Stop execution if the entire amount of takerAsset has been sold\r\n            if (totalFillResults.takerAssetFilledAmount >= takerAssetFillAmount) {\r\n                break;\r\n            }\r\n\r\n            // Calculate the remaining amount of takerAsset to sell\r\n            uint256 remainingTakerAmount = takerAssetFillAmount.sub(totalFillResults.takerAssetFilledAmount);\r\n\r\n            IZrxExchange.OrderInfo memory orderInfo = IZrxExchange(zrxExchange).getOrderInfo(orders[i]);\r\n            uint256 orderRemainingTakerAmount = orders[i].takerAssetAmount.sub(orderInfo.orderTakerAssetFilledAmount);\r\n\r\n            // Check available balance and allowance and update orderRemainingTakerAmount\r\n            {\r\n                uint256 balance = IERC20NonView(makerAsset).balanceOf(orders[i].makerAddress);\r\n                uint256 allowance = IERC20NonView(makerAsset).allowance(orders[i].makerAddress, zrxTokenProxy);\r\n                uint256 availableMakerAmount = (allowance < balance) ? allowance : balance;\r\n                uint256 availableTakerAmount = availableMakerAmount.mul(orders[i].takerAssetAmount).div(orders[i].makerAssetAmount);\r\n\r\n                if (availableTakerAmount < orderRemainingTakerAmount) {\r\n                    orderRemainingTakerAmount = availableTakerAmount;\r\n                }\r\n            }\r\n\r\n            uint256 takerAmount = (orderRemainingTakerAmount < remainingTakerAmount) ? orderRemainingTakerAmount : remainingTakerAmount;\r\n\r\n            IZrxExchange.FillResults memory fillResults = IZrxExchange(zrxExchange).fillOrder(\r\n                orders[i],\r\n                takerAmount,\r\n                signatures[i]\r\n            );\r\n\r\n            remainingTakerAmount = remainingTakerAmount.sub(fillResults.takerAssetFilledAmount);\r\n        }\r\n\r\n        return totalFillResults;\r\n    }\r\n\r\n    function addFillResults(\r\n        IZrxExchange.FillResults memory totalFillResults,\r\n        IZrxExchange.FillResults memory singleFillResults\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        totalFillResults.makerAssetFilledAmount = totalFillResults.makerAssetFilledAmount.add(singleFillResults.makerAssetFilledAmount);\r\n        totalFillResults.takerAssetFilledAmount = totalFillResults.takerAssetFilledAmount.add(singleFillResults.takerAssetFilledAmount);\r\n        totalFillResults.makerFeePaid = totalFillResults.makerFeePaid.add(singleFillResults.makerFeePaid);\r\n        totalFillResults.takerFeePaid = totalFillResults.takerFeePaid.add(singleFillResults.takerFeePaid);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"makerAsset\",\"type\":\"address\"},{\"name\":\"zrxExchange\",\"type\":\"address\"},{\"name\":\"zrxTokenProxy\",\"type\":\"address\"},{\"name\":\"takerAssetFillAmount\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"makerAddress\",\"type\":\"address\"},{\"name\":\"takerAddress\",\"type\":\"address\"},{\"name\":\"feeRecipientAddress\",\"type\":\"address\"},{\"name\":\"senderAddress\",\"type\":\"address\"},{\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"name\":\"makerFee\",\"type\":\"uint256\"},{\"name\":\"takerFee\",\"type\":\"uint256\"},{\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"name\":\"takerAssetData\",\"type\":\"bytes\"}],\"name\":\"orders\",\"type\":\"tuple[]\"},{\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"marketSellOrders\",\"outputs\":[{\"components\":[{\"name\":\"makerAssetFilledAmount\",\"type\":\"uint256\"},{\"name\":\"takerAssetFilledAmount\",\"type\":\"uint256\"},{\"name\":\"makerFeePaid\",\"type\":\"uint256\"},{\"name\":\"takerFeePaid\",\"type\":\"uint256\"}],\"name\":\"totalFillResults\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ZrxMarketOrder","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://027d4082e66ed479043e06de6bf81e09330843fd5c7d95de31f595e3db7d4a29"}]}