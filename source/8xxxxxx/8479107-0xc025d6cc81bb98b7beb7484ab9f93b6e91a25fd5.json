{"status":"1","message":"OK","result":[{"SourceCode":"{\"CashBack.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Modifiers.sol\\\";\\n\\ncontract CashBack is Modifiers {\\n    using SafeMath for uint;\\n\\n    function cashBackAmount(address _painter) public view returns (uint cashBackInWei) {\\n        // last cashBack Calculation Round for Painter\\n        uint round = cashBackCalculationRound[_painter];\\n\\n        uint calcCashBack = cashBackCalculated[_painter];\\n        uint curCashBackPerPaint = maxCashBackPerPaintForRound[round].sub(cashBackPerPaintForRound[round][_painter]);\\n        uint curCashBack = curCashBackPerPaint.mul(userPaintsForRound[round][_painter]);\\n\\n        cashBackInWei = calcCashBack.add(curCashBack);\\n    }\\n\\n    function withdrawCashBack() external isLiveGame() {\\n        address withdrawer = msg.sender;\\n        uint curCashBack = cashBackAmount(withdrawer);\\n        require(curCashBack \\u003e 0, \\\"Cashback can not be 0\\\");\\n\\n        // last cashBack Calculation Round for Withdrawer\\n        uint round = cashBackCalculationRound[withdrawer];\\n\\n        // update states\\n        cashBackCalculated[withdrawer] = 0;\\n        cashBackPerPaintForRound[round][withdrawer] = maxCashBackPerPaintForRound[round];\\n\\n        // transfer cashback\\n        withdrawer.transfer(curCashBack);\\n        emit CashBackWithdrawn(currentRound, withdrawer, curCashBack);\\n    }\\n\\n    function _distributeCashBack(uint _value) internal {\\n        uint curRound = currentRound;  // gas consumption optimization\\n        address painter = msg.sender;\\n\\n        uint totalPaints = totalPaintsForRound[curRound];\\n        uint curCashBackPerPaint = _value.div(totalPaints);\\n        uint updCashBackPerPaint = maxCashBackPerPaintForRound[curRound].add(curCashBackPerPaint);\\n\\n        // update maxCashBackPerPaintForRound state\\n        maxCashBackPerPaintForRound[curRound] = updCashBackPerPaint;\\n\\n        // update already earned cashback in this or prev rounds\\n        cashBackCalculated[painter] = cashBackAmount(painter);\\n\\n        // update cashBackCalculationRound state\\n        if (cashBackCalculationRound[painter] \\u003c curRound) {\\n            cashBackCalculationRound[painter] = curRound;\\n            // add current round cashback\\n            cashBackCalculated[painter] = cashBackAmount(painter);\\n        }\\n\\n        // update cashBackPerPaintForRound state\\n        cashBackPerPaintForRound[curRound][painter] = updCashBackPerPaint;\\n\\n        // update totalCashBackForRound state\\n        totalCashBackForRound[curRound] = totalCashBackForRound[curRound].add(_value);\\n    }\\n}\"},\"DividendsDistributor.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./Modifiers.sol\\\";\\n\\ncontract DividendsDistributor is Modifiers {\\n\\n    function withdrawFoundersComission() external onlyAdmin() returns (bool) {\\n        _withdrawDividensHelper(founders);\\n        return true;\\n    }\\n\\n    function withdrawDividends() external returns (bool) {\\n        _withdrawDividensHelper(msg.sender);\\n        return true;\\n    }\\n\\n    function _withdrawDividensHelper(address _beneficiary) private {\\n        uint balance = pendingWithdrawals[_beneficiary];\\n        require(balance \\u003e 0, \\\"Dividends withdrawal balance is zero.\\\");\\n\\n        // set state\\n        pendingWithdrawals[_beneficiary] = 0;\\n\\n        // withdrawal dividends\\n        _beneficiary.transfer(balance);\\n        emit DividendsWithdrawn(_beneficiary, balance);\\n    }\\n}\"},\"ERC1538Delegate.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./IERC1538.sol\\\";\\nimport \\\"./ERC1538QueryDelegates.sol\\\";\\n\\n/******************************************************************************\\\\\\n* Implementation of ERC1538.\\n* Function signatures are stored in an array so functions can be queried.\\n/******************************************************************************/\\n\\ncontract ERC1538Delegate is IERC1538, ERC1538QueryDelegates {\\n\\n    function updateContract(address _delegate, string _functionSignatures, string commitMessage) external onlyOwner {\\n        // pos is first used to check the size of the delegate contract.\\n        // After that pos is the current memory location of _functionSignatures.\\n        // It is used to move through the characters of _functionSignatures\\n        uint256 pos;\\n        if(_delegate != address(0)) {\\n            assembly {\\n                pos := extcodesize(_delegate)\\n            }\\n            require(pos \\u003e 0, \\\"_delegate address is not a contract and is not address(0)\\\");\\n        }\\n        // creates a bytes vesion of _functionSignatures\\n        bytes memory signatures = bytes(_functionSignatures);\\n        // stores the position in memory where _functionSignatures ends.\\n        uint256 signaturesEnd;\\n        // stores the starting position of a function signature in _functionSignatures\\n        uint256 start;\\n        assembly {\\n            pos := add(signatures,32)\\n            start := pos\\n            signaturesEnd := add(pos,mload(signatures))\\n        }\\n        // the function id of the current function signature\\n        bytes4 funcId;\\n        // the delegate address that is being replaced or address(0) if removing functions\\n        address oldDelegate;\\n        // the length of the current function signature in _functionSignatures\\n        uint256 num;\\n        // the current character in _functionSignatures\\n        uint256 char;\\n        // the position of the current function signature in the funcSignatures array\\n        uint256 index;\\n        // the last position in the funcSignatures array\\n        uint256 lastIndex;\\n        // parse the _functionSignatures string and handle each function\\n        for (; pos \\u003c signaturesEnd; pos++) {\\n            assembly {char := byte(0,mload(pos))}\\n            // 0x29 == )\\n            if (char == 0x29) {\\n                pos++;\\n                num = (pos - start);\\n                start = pos;\\n                assembly {\\n                    mstore(signatures,num)\\n                }\\n                funcId = bytes4(keccak256(signatures));\\n                oldDelegate = delegates[funcId];\\n                if(_delegate == address(0)) {\\n                    index = funcSignatureToIndex[signatures];\\n                    require(index != 0, \\\"Function does not exist.\\\");\\n                    index--;\\n                    lastIndex = funcSignatures.length - 1;\\n                    if (index != lastIndex) {\\n                        funcSignatures[index] = funcSignatures[lastIndex];\\n                        funcSignatureToIndex[funcSignatures[lastIndex]] = index + 1;\\n                    }\\n                    funcSignatures.length--;\\n                    delete funcSignatureToIndex[signatures];\\n                    delete delegates[funcId];\\n                    emit FunctionUpdate(funcId, oldDelegate, address(0), string(signatures));\\n                }\\n                else if (funcSignatureToIndex[signatures] == 0) {\\n                    require(oldDelegate == address(0), \\\"Funcion id clash.\\\");\\n                    delegates[funcId] = _delegate;\\n                    funcSignatures.push(signatures);\\n                    funcSignatureToIndex[signatures] = funcSignatures.length;\\n                    emit FunctionUpdate(funcId, address(0), _delegate, string(signatures));\\n                }\\n                else if (delegates[funcId] != _delegate) {\\n                    delegates[funcId] = _delegate;\\n                    emit FunctionUpdate(funcId, oldDelegate, _delegate, string(signatures));\\n\\n                }\\n                assembly {signatures := add(signatures,num)}\\n            }\\n        }\\n        emit CommitMessage(commitMessage);\\n    }\\n}\"},\"ERC1538QueryDelegates.sol\":{\"content\":\"pragma solidity 0.4.24;\\n/******************************************************************************\\\\\\n* \\n* Contains functions for retrieving function signatures and delegate contract\\n* addresses.\\n/******************************************************************************/\\n\\nimport \\\"./StorageV0.sol\\\";\\nimport \\\"./IERC1538Query.sol\\\";\\n\\ncontract ERC1538QueryDelegates is IERC1538Query, StorageV0 {\\n\\n    function totalFunctions() external view returns(uint256) {\\n        return funcSignatures.length;\\n    }\\n\\n    function functionByIndex(uint256 _index) external view returns(string memory functionSignature, bytes4 functionId, address delegate) {\\n        require(_index \\u003c funcSignatures.length, \\\"functionSignatures index does not exist.\\\");\\n        bytes memory signature = funcSignatures[_index];\\n        functionId = bytes4(keccak256(signature));\\n        delegate = delegates[functionId];\\n        return (string(signature), functionId, delegate);\\n    }\\n\\n    function functionExists(string _functionSignature) external view returns(bool) {\\n        return funcSignatureToIndex[bytes(_functionSignature)] != 0;\\n    }\\n\\n    function functionSignatures() external view returns(string) {\\n        uint256 signaturesLength;\\n        bytes memory signatures;\\n        bytes memory signature;\\n        uint256 functionIndex;\\n        uint256 charPos;\\n        uint256 funcSignaturesNum = funcSignatures.length;\\n        bytes[] memory memoryFuncSignatures = new bytes[](funcSignaturesNum);\\n        for(; functionIndex \\u003c funcSignaturesNum; functionIndex++) {\\n            signature = funcSignatures[functionIndex];\\n            signaturesLength += signature.length;\\n            memoryFuncSignatures[functionIndex] = signature;\\n        }\\n        signatures = new bytes(signaturesLength);\\n        functionIndex = 0;\\n        for(; functionIndex \\u003c funcSignaturesNum; functionIndex++) {\\n            signature = memoryFuncSignatures[functionIndex];\\n            for(uint256 i = 0; i \\u003c signature.length; i++) {\\n                signatures[charPos] = signature[i];\\n                charPos++;\\n            }\\n        }\\n        return string(signatures);\\n    }\\n\\n    function delegateFunctionSignatures(address _delegate) external view returns(string) {\\n        uint256 funcSignaturesNum = funcSignatures.length;\\n        bytes[] memory delegateSignatures = new bytes[](funcSignaturesNum);\\n        uint256 delegateSignaturesPos;\\n        uint256 signaturesLength;\\n        bytes memory signatures;\\n        bytes memory signature;\\n        uint256 functionIndex;\\n        uint256 charPos;\\n        for(; functionIndex \\u003c funcSignaturesNum; functionIndex++) {\\n            signature = funcSignatures[functionIndex];\\n            if(_delegate == delegates[bytes4(keccak256(signature))]) {\\n                signaturesLength += signature.length;\\n                delegateSignatures[delegateSignaturesPos] = signature;\\n                delegateSignaturesPos++;\\n            }\\n\\n        }\\n        signatures = new bytes(signaturesLength);\\n        functionIndex = 0;\\n        for(; functionIndex \\u003c delegateSignatures.length; functionIndex++) {\\n            signature = delegateSignatures[functionIndex];\\n            if(signature.length == 0) {\\n                break;\\n            }\\n            for(uint256 i = 0; i \\u003c signature.length; i++) {\\n                signatures[charPos] = signature[i];\\n                charPos++;\\n            }\\n        }\\n        return string(signatures);\\n    }\\n\\n    function delegateAddress(string _functionSignature) external view returns(address) {\\n        require(funcSignatureToIndex[bytes(_functionSignature)] != 0, \\\"Function signature not found.\\\");\\n        return delegates[bytes4(keccak256(bytes(_functionSignature)))];\\n    }\\n\\n    function functionById(bytes4 _functionId) external view returns(string signature, address delegate) {\\n        for(uint256 i = 0; i \\u003c funcSignatures.length; i++) {\\n            if(_functionId == bytes4(keccak256(funcSignatures[i]))) {\\n                return (string(funcSignatures[i]), delegates[_functionId]);\\n            }\\n        }\\n        revert(\\\"functionId not found\\\");\\n    }\\n\\n    function delegateAddresses() external view returns(address[]) {\\n        uint256 funcSignaturesNum = funcSignatures.length;\\n        address[] memory delegatesBucket = new address[](funcSignaturesNum);\\n        uint256 numDelegates;\\n        uint256 functionIndex;\\n        bool foundDelegate;\\n        address delegate;\\n        for(; functionIndex \\u003c funcSignaturesNum; functionIndex++) {\\n            delegate = delegates[bytes4(keccak256(funcSignatures[functionIndex]))];\\n            for(uint256 i = 0; i \\u003c numDelegates; i++) {\\n                if(delegate == delegatesBucket[i]) {\\n                    foundDelegate = true;\\n                    break;\\n                }\\n            }\\n            if(foundDelegate == false) {\\n                delegatesBucket[numDelegates] = delegate;\\n                numDelegates++;\\n            }\\n            else {\\n                foundDelegate = false;\\n            }\\n        }\\n        address[] memory delegates_ = new address[](numDelegates);\\n        functionIndex = 0;\\n        for(; functionIndex \\u003c numDelegates; functionIndex++) {\\n            delegates_[functionIndex] = delegatesBucket[functionIndex];\\n        }\\n        return delegates_;\\n    }\\n}\"},\"Game.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./PaintsPool.sol\\\";\\nimport \\\"./PaintDiscount.sol\\\";\\nimport \\\"./CashBack.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\ncontract Game is PaintDiscount, PaintsPool, CashBack {\\n    using SafeMath for uint;\\n\\n    // set new value of priceLimitPaints\\n    function setPriceLimitPaints(uint _paintsNumber) external onlyAdmin() {\\n        priceLimitPaints = _paintsNumber;\\n    }\\n\\n    // function estimating call price for given color\\n    function estimateCallPrice(uint[] _pixels, uint _color) public view returns (uint totalCallPrice) {\\n        uint moneySpent = moneySpentByUser[msg.sender];\\n        bool hasDiscount = hasPaintDiscount[msg.sender];\\n        uint discount = usersPaintDiscount[msg.sender];\\n\\n        // next paint number\\n        uint curPaintNum = totalPaintsForRound[currentRound] + 1;\\n\\n        // external call – add extra paints\\n        if (!isPaintCall) {\\n            curPaintNum += priceLimitPaints;\\n        }\\n\\n        uint curPrice = _getPaintPrice(curPaintNum);  // price for next painting without discount\\n        uint price = curPrice;  // price for next painting\\n\\n        for (uint i = 0; i \\u003c _pixels.length; i++) {\\n            if (hasDiscount) {\\n                price = curPrice.mul(100 - discount).div(100); // discount call price\\n            }\\n\\n            totalCallPrice += price;\\n            moneySpent += price;\\n\\n            if (moneySpent \\u003e= 1 ether) {\\n                hasDiscount = true;\\n                discount = moneySpent / 1 ether;\\n\\n                if (moneySpent \\u003e= 10 ether) {\\n                    discount = 10;\\n                }\\n            }\\n        }\\n\\n    }\\n\\n    function drawTimeBank() public {\\n        uint curRound = currentRound;\\n        uint lastPaintTime = lastPaintTimeForRound[curRound];\\n        require ((now - lastPaintTime) \\u003e 20 minutes \\u0026\\u0026 lastPaintTime \\u003e 0, \\\"20 minutes have not passed yet.\\\");\\n\\n        address winner = lastPainterForRound[curRound];\\n        uint curTbIter = tbIteration;\\n        uint prize = timeBankForRound[curRound].mul(90).div(100);  // 90% of time bank goes to winner;\\n\\n        winnerOfRound[curRound] = winner;  // set winner of round\\n        winnerBankForRound[curRound] = 1;  // timebank(1) was drawn for this round\\n        timeBankForRound[curRound + 1] = timeBankForRound[curRound].div(10);  // 10% of time bank goes to next round\\n        timeBankForRound[curRound] = prize;\\n\\n        colorBankForRound[curRound + 1] = colorBankForRound[curRound];  // color bank goes to next round\\n        colorBankForRound[curRound] = 0;\\n\\n        // change global state - new game\\n        currentRound = curRound.add(1);\\n        tbIteration = curTbIter.add(1);\\n        _resetPaintsPool();\\n\\n        // transfer time bank to winner\\n        winner.transfer(prize);\\n        emit TimeBankWithdrawn(curRound, curTbIter, winner, prize);\\n    }\\n\\n    function paint(uint[] _pixels, uint _color, string _refLink) external payable isRegistered(_refLink) isLiveGame() {\\n        require (_pixels.length \\u003e= 1 \\u0026\\u0026 _pixels.length \\u003c= 15, \\\"The number of pixels should be from 1 to 15 pixels\\\");\\n        require(_color \\u003e 0 \\u0026\\u0026 _color \\u003c= totalColorsNumber, \\\"The color with such id does not exist.\\\");\\n\\n        // drawTimeBank call and exit if 20 minutes passed since last paint\\n        if ((now - lastPaintTimeForRound[currentRound]) \\u003e 20 minutes \\u0026\\u0026\\n            lastPaintTimeForRound[currentRound] \\u003e 0) {\\n\\n            drawTimeBank();\\n            msg.sender.transfer(msg.value);\\n            return;\\n        }\\n\\n        // call estimateCallPrice from paint function\\n        isPaintCall = true;\\n        uint callPrice = estimateCallPrice(_pixels, _color);\\n        isPaintCall = false;\\n\\n        require(msg.value \\u003e= callPrice, \\\"Wrong call price – insufficient funds\\\");\\n\\n        // Add remaining money\\n        if (msg.value - callPrice \\u003e 0) {\\n            uint remainingMoney = msg.value - callPrice;\\n            // Update cashback amount for msg.sender\\n            cashBackCalculated[msg.sender] = cashBackCalculated[msg.sender].add(remainingMoney);\\n        }\\n\\n        // distribute money to banks, cashBack and dividends\\n        if (totalPaintsForRound[currentRound] == 0) {\\n            // need for first cashback distribution to first painter\\n            totalPaintsForRound[currentRound] = _pixels.length;\\n            userPaintsForRound[currentRound][msg.sender] = _pixels.length;\\n            _setBanks(_color, _refLink, callPrice);\\n        } else {\\n            // for other cases – distribute cashback to prev painters\\n            _setBanks(_color, _refLink, callPrice);\\n            totalPaintsForRound[currentRound] = totalPaintsForRound[currentRound].add(_pixels.length);\\n            userPaintsForRound[currentRound][msg.sender] = userPaintsForRound[currentRound][msg.sender].add(_pixels.length);\\n        }\\n\\n        colorToTotalPaintsForCBIteration[cbIteration][_color] = colorToTotalPaintsForCBIteration[cbIteration][_color].add(_pixels.length);\\n\\n        //paint pixels\\n        for (uint i = 0; i \\u003c _pixels.length; i++) {\\n            _paint(_pixels[i], _color);\\n        }\\n\\n        // save user spended money for this color\\n        _setMoneySpentByUserForColor(_color);\\n\\n        _setUsersPaintDiscountForColor(_color);\\n\\n        if (paintsCounterForColor[_color] == 0) {\\n            paintGenToEndTimeForColor[_color][currentPaintGenForColor[_color] - 1] = now;\\n        }\\n\\n        paintsCounter++; //counter for all users paints\\n        paintsCounterForColor[_color]++; //counter for given color\\n        counterToPainter[paintsCounter] = msg.sender; //counter for given user\\n        counterToPainterForColor[_color][paintsCounterForColor[_color]] = msg.sender;\\n\\n        if (isUserCountedForRound[currentRound][msg.sender] == false) {\\n            usersCounterForRound[currentRound] = usersCounterForRound[currentRound].add(1);\\n            isUserCountedForRound[currentRound][msg.sender] = true;\\n        }\\n\\n        // check the winning in color bank\\n        if (winnerBankForRound[currentRound] == 2) {\\n            _drawColorBank();\\n        }\\n    }\\n\\n    function _paint(uint _pixel, uint _color) internal {\\n        //set paints amount in a pool and price for paint\\n        _fillPaintsPool(_color);\\n\\n        require(msg.sender == tx.origin, \\\"Can not be a contract\\\");\\n        require(_pixel \\u003e 0 \\u0026\\u0026 _pixel \\u003c= totalPixelsNumber, \\\"The pixel with such id does not exist.\\\");\\n\\n        uint oldColor = pixelToColorForRound[currentRound][_pixel];\\n\\n        pixelToColorForRound[currentRound][_pixel] = _color; // save old color for pixel\\n        pixelToOldColorForRound[currentRound][_pixel] = oldColor; // set new color for pixel\\n\\n        lastPaintTimeForRound[currentRound] = now;\\n        lastPainterForRound[currentRound] = msg.sender;\\n\\n        // decrease number of old color pixels\\n        if (colorToPaintedPixelsAmountForRound[currentRound][oldColor] \\u003e 0) {\\n            colorToPaintedPixelsAmountForRound[currentRound][oldColor] = colorToPaintedPixelsAmountForRound[currentRound][oldColor].sub(1);\\n        }\\n\\n        // increase number of new color pixels\\n        colorToPaintedPixelsAmountForRound[currentRound][_color] = colorToPaintedPixelsAmountForRound[currentRound][_color].add(1);\\n\\n        pixelToPaintTimeForRound[currentRound][_pixel] = now;\\n\\n        lastPaintTimeOfUser[msg.sender] = now;\\n        lastPaintTimeOfUserForColor[_color][msg.sender] = now;\\n\\n        // decrease paints pool by 1\\n        paintGenToAmountForColor[_color][currentPaintGenForColor[_color]] = paintGenToAmountForColor[_color][currentPaintGenForColor[_color]].sub(1);\\n\\n        lastPaintedPixelForRound[currentRound] = _pixel;\\n        lastPlayedRound[msg.sender] = currentRound;\\n\\n        emit Paint(_pixel, _color, msg.sender, currentRound, now);\\n\\n        // check wherether all pixels are the same color\\n        if (colorToPaintedPixelsAmountForRound[currentRound][_color] == totalPixelsNumber) {\\n            winnerColorForRound[currentRound] = _color;\\n            winnerOfRound[currentRound] = lastPainterForRound[currentRound];\\n\\n            // color bank is 2\\n            winnerBankForRound[currentRound] = 2;\\n\\n            // 10% of colorbank goes to next round\\n            colorBankForRound[currentRound + 1] = colorBankForRound[currentRound].div(10);\\n\\n            // 90% of colorbank for winner\\n            colorBankForRound[currentRound] = colorBankForRound[currentRound].mul(90).div(100);\\n\\n            //timebank goes to next round\\n            timeBankForRound[currentRound + 1] = timeBankForRound[currentRound];\\n            timeBankForRound[currentRound] = 0;\\n        }\\n    }\\n\\n    function _setBanks(uint _color, string _refLink, uint _callPrice) private {\\n        bytes32 refLink32 = Utils.toBytes16(_refLink);\\n\\n        uint valueToTimeBank = _callPrice.mul(40).div(100);  // 40% to TimeBank\\n        uint valueToColorBank = _callPrice.div(10);  // 10% to ColorBank\\n        uint valueToLuckyPot = _callPrice.div(20);  // 5% to LuckyPot\\n        uint valueGameFee = _callPrice.div(20);  // 5% Game Fee to Founders\\n        uint valueRef = _callPrice.div(20);  // 5% to Referrer\\n        uint valueCashBack = _callPrice.mul(35).div(100);  // 35% CashBack (+ valueRef without Referrer)\\n\\n        // reflink provided\\n        if (refLinkExists[refLink32]) {\\n            pendingWithdrawals[refLinkToUser[refLink32]] = pendingWithdrawals[refLinkToUser[refLink32]].add(valueRef);\\n            _distributeCashBack(valueCashBack);  // CashBack with Refferer\\n        } else {\\n            _distributeCashBack(valueCashBack + valueRef);  // CashBack without Refferer\\n        }\\n\\n        // set bank states\\n        timeBankForRound[currentRound] = timeBankForRound[currentRound].add(valueToTimeBank);\\n        colorBankForRound[currentRound] = colorBankForRound[currentRound].add(valueToColorBank);\\n        colorBankToColorForRound[currentRound][_color] = colorBankToColorForRound[currentRound][_color].add(valueToColorBank);\\n        luckyPotBank = luckyPotBank.add(valueToLuckyPot);\\n        pendingWithdrawals[founders] = pendingWithdrawals[founders].add(valueGameFee);\\n    }\\n\\n    function _drawColorBank() private {\\n        uint curRound = currentRound;\\n        uint curCbIter = cbIteration;\\n        address winner = winnerOfRound[curRound];\\n        uint prize = colorBankForRound[curRound];\\n\\n        // change global state - new game\\n        currentRound = curRound.add(1);\\n        cbIteration = curCbIter.add(1);\\n        _resetPaintsPool();\\n\\n        // transfer color bank to winner\\n        winner.transfer(prize);\\n        emit ColorBankWithdrawn(curRound, curCbIter, winner, prize);\\n    }\\n\\n    function _resetPaintsPool() private {\\n        uint firstPaintGenForColor = 1;\\n\\n        for (uint i = 1; i \\u003c= totalColorsNumber; i++){\\n            callPriceForColor[i] = 0.005 ether;\\n            nextCallPriceForColor[i] = callPriceForColor[i];\\n            currentPaintGenForColor[i] = firstPaintGenForColor;\\n\\n            paintGenToAmountForColor[i][firstPaintGenForColor] = maxPaintsInPool;\\n            paintGenStartedForColor[i][firstPaintGenForColor] = true;\\n            paintGenToStartTimeForColor[i][firstPaintGenForColor] = now;\\n        }\\n    }\\n\\n    modifier isRegistered(string _refLink) {\\n\\n        if (isRegisteredUser[msg.sender] != true) {\\n            bytes32 refLink32 = Utils.toBytes16(_refLink);\\n\\n            if (refLinkExists[refLink32]) {\\n                address referrer = refLinkToUser[refLink32];\\n                referrerToReferrals[referrer].push(msg.sender);\\n                referralToReferrer[msg.sender] = referrer;\\n                hasReferrer[msg.sender] = true;\\n            }\\n            uniqueUsersCount = uniqueUsersCount.add(1);\\n            newUserToCounter[msg.sender] = uniqueUsersCount;\\n            registrationTimeForUser[msg.sender] = now;\\n            isRegisteredUser[msg.sender] = true;\\n        }\\n        _;\\n    }\\n\\n    function _getPaintPrice(uint _number) private pure returns (uint) {\\n        uint paintPrice = uint((int(_sqrt(_number * 22222222 + 308641358025)) - 7777777)*1e18 / 12345678 + 0.589996*1e18);\\n        uint temp = 1e13;  // for round - 10^-5\\n        return ((paintPrice + temp - 1) / temp) * temp;\\n    }\\n\\n    // gives square root of given x.\\n    function _sqrt(uint x) private pure returns (uint y) {\\n        uint z = (x + 1) / 2;\\n        y = x;\\n        while (z \\u003c y) {\\n            y = z;\\n            z = (x / z + z) / 2;\\n        }\\n    }\\n}\"},\"GameStateController.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./Roles.sol\\\";\\nimport \\\"./Modifiers.sol\\\";\\n\\ncontract GameStateController is Modifiers {\\n\\n    function pauseGame() external onlyAdmin() {\\n        require (isGamePaused == false, \\\"Game is already paused\\\");\\n        isGamePaused = true;\\n    }\\n\\n    function resumeGame() external onlyAdmin() {\\n        require (isGamePaused == true, \\\"Game is already live\\\");\\n        isGamePaused = false;\\n    }\\n\\n    function withdrawEther() external onlyAdmin() returns (bool) {\\n        require (isGamePaused == true, \\\"Can withdraw when game is live\\\");\\n        uint balance = address(this).balance;\\n        uint colorBank = colorBankForRound[currentRound];\\n        uint timeBank = timeBankForRound[currentRound];\\n        owner().transfer(balance);\\n        colorBankForRound[currentRound]= 0;\\n        timeBankForRound[currentRound]= 0;\\n        emit EtherWithdrawn(balance, colorBank, timeBank, now);\\n        return true;\\n    }\\n    \\n}\\n\"},\"Helpers.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./Modifiers.sol\\\";\\n\\ncontract Helpers is Modifiers {\\n\\n    function getUsername(address _painter) external view returns(string username) {\\n        username = addressToUsername[_painter];\\n    }\\n\\n    function isUsernameExists(string _username) external view returns(bool) {\\n        return usernameExists[_username];\\n    }\\n\\n    // username lenght 1-16 symbols\\n    function createUsername(string _username) external isValidUsername(_username) {\\n        require(!usernameExists[_username], \\\"This username already exists, try different one.\\\");\\n        require(bytes(addressToUsername[msg.sender]).length == 0, \\\"You have already created your username.\\\");\\n\\n        addressToUsername[msg.sender] = _username;\\n        usernameExists[_username] = true;\\n\\n        emit UsernameCreated(msg.sender, _username);\\n    }\\n\\n    function getPixelColor(uint _pixel) external view returns (uint) {\\n        return pixelToColorForRound[currentRound][_pixel];\\n    }\\n\\n    //function adding new color to the game after minting\\n    function addNewColor() external onlyAdmin() {\\n        totalColorsNumber++; \\n        currentPaintGenForColor[totalColorsNumber] = 1;\\n        callPriceForColor[totalColorsNumber] = 0.01 ether;\\n        nextCallPriceForColor[totalColorsNumber] = callPriceForColor[totalColorsNumber];\\n        paintGenToAmountForColor[totalColorsNumber][currentPaintGenForColor[totalColorsNumber]] = maxPaintsInPool;\\n        paintGenStartedForColor[totalColorsNumber][currentPaintGenForColor[totalColorsNumber]] = true;\\n        paintGenToEndTimeForColor[totalColorsNumber][currentPaintGenForColor[totalColorsNumber] - 1] = now;\\n        paintGenToStartTimeForColor[totalColorsNumber][currentPaintGenForColor[totalColorsNumber]] = now;\\n    }\\n\\n}\"},\"IColor.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\ninterface Color {\\n    function totalSupply() external view returns (uint);\\n    function ownerOf(uint _tokenId) external view returns (address);\\n}\\n\\n\"},\"IERC1538.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\ninterface IERC1538 {\\n    event CommitMessage(string message);\\n    event FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\\n    function updateContract(address _delegate, string _functionSignatures, string commitMessage) external;\\n}\"},\"IERC1538Query.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\ninterface IERC1538Query {\\n    function totalFunctions() external view returns(uint256);\\n    function functionByIndex(uint256 _index) external view returns(string memory functionSignature, bytes4 functionId, address delegate);\\n    function functionExists(string _functionSignature) external view returns(bool);\\n    function functionSignatures() external view returns(string);\\n    function delegateFunctionSignatures(address _delegate) external view returns(string);\\n    function delegateAddress(string _functionSignature) external view returns(address);\\n    function functionById(bytes4 _functionId) external view returns(string signature, address delegate);\\n    function delegateAddresses() external view returns(address[]);\\n}\"},\"Initializer.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./StorageV1.sol\\\";\\n\\ncontract Initializer is StorageV1 {\\n\\n    //constructor\\n    function _initializer() internal {\\n        totalColorsNumber = 8;\\n        totalPixelsNumber = 49;\\n\\n        isAdmin[msg.sender] = true;\\n        maxPaintsInPool = totalPixelsNumber;\\n        currentRound = 1;\\n        cbIteration = 1;\\n        tbIteration = 1;\\n\\n        priceLimitPaints = 100;\\n\\n        for (uint i = 1; i \\u003c= totalColorsNumber; i++) {\\n            currentPaintGenForColor[i] = 1;\\n            callPriceForColor[i] = 0.005 ether;\\n            nextCallPriceForColor[i] = callPriceForColor[i];\\n            paintGenToAmountForColor[i][currentPaintGenForColor[i]] = maxPaintsInPool;\\n            paintGenStartedForColor[i][currentPaintGenForColor[i]] = true;\\n            \\n            paintGenToStartTimeForColor[i][currentPaintGenForColor[i]] = now;\\n        }\\n        \\n    }\\n}\\n\"},\"IPixel.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\ninterface Pixel {\\n    function totalSupply() external view returns (uint);\\n    function ownerOf(uint _tokenId) external view returns (address);\\n}\\n\\n\"},\"LuckyPot.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Modifiers.sol\\\";\\n\\ncontract LuckyPot is Modifiers {\\n    using SafeMath for uint;\\n\\n    function increaseLuckyPot() external payable {\\n        require(msg.value != 0, \\\"msg.value is 0\\\");\\n        luckyPotBank = luckyPotBank.add(msg.value);\\n    }\\n\\n    function drawLuckyPot(address _user, uint _bankPercent, uint _pixelId) external onlyAdmin() {\\n        require(luckyPotBank \\u003e 0, \\\"luckyPotBank is empty\\\");\\n        require(_bankPercent \\u003e 0 \\u0026\\u0026 _bankPercent \\u003c= 100, \\\"Invalid percent\\\");\\n        require(_pixelId \\u003e 0 \\u0026\\u0026 _pixelId \\u003c= totalPixelsNumber, \\\"The pixel with such id does not exist.\\\");\\n\\n        uint luckyPotBankAmountForWinner = luckyPotBank.mul(_bankPercent).div(100);\\n\\n        // change luckyPotBank state\\n        luckyPotBank = luckyPotBank.sub(luckyPotBankAmountForWinner);\\n        luckyPotBankWinner[_user] = true;\\n\\n        // transfer luckypot\\n        _user.transfer(luckyPotBankAmountForWinner);\\n        emit LuckyPotDrawn(_pixelId, _user, luckyPotBankAmountForWinner);\\n    }\\n}\"},\"Migrations.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\ncontract Migrations {\\n  address public owner;\\n  uint public last_completed_migration;\\n\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  modifier restricted() {\\n    if (msg.sender == owner) _;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n\\n  function upgrade(address new_address) public restricted {\\n    Migrations upgraded = Migrations(new_address);\\n    upgraded.setCompleted(last_completed_migration);\\n  }\\n}\\n\"},\"Modifiers.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./StorageV1.sol\\\";\\n\\ncontract Modifiers is StorageV1 {\\n    using SafeMath for uint;\\n\\n    modifier onlyAdmin() {\\n        require(isAdmin[msg.sender] == true, \\\"You don\\u0027t have admin rights.\\\");\\n        _;\\n    }\\n\\n    modifier isLiveGame() {\\n        require(isGamePaused == false, \\\"Game is paused.\\\");\\n        _;\\n    }\\n\\n    // should be 4-8 symbols\\n    modifier isValidRefLink(string _str) {\\n        require(bytes(_str).length \\u003e= 4, \\\"Ref link should be of length [4,8]\\\");\\n        require(bytes(_str).length \\u003c= 8, \\\"Ref link should be of length [4,8]\\\");\\n        _;\\n    }\\n\\n    // should be 1-16 symbols\\n    modifier isValidUsername(string _str) {\\n        require(bytes(_str).length \\u003e= 1, \\\"Name should be of length [1,16]\\\");\\n        require(bytes(_str).length \\u003c= 16, \\\"Name should be of length [1,16]\\\");\\n        _;\\n    }\\n\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address private _owner;\\n\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() internal {\\n    _owner = msg.sender;\\n    emit OwnershipTransferred(address(0), _owner);\\n  }\\n\\n  /**\\n   * @return the address of the owner.\\n   */\\n  function owner() public view returns(address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(isOwner());\\n    _;\\n  }\\n\\n  /**\\n   * @return true if `msg.sender` is the owner of the contract.\\n   */\\n  function isOwner() public view returns(bool) {\\n    return msg.sender == _owner;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to relinquish control of the contract.\\n   * @notice Renouncing to ownership will leave the contract without an owner.\\n   * It will not be possible to call the functions with the `onlyOwner`\\n   * modifier anymore.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipTransferred(_owner, address(0));\\n    _owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function _transferOwnership(address newOwner) internal {\\n    require(newOwner != address(0));\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n}\\n\"},\"PaintDiscount.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./StorageV1.sol\\\";\\n\\ncontract PaintDiscount is StorageV1 {\\n    using SafeMath for uint;\\n\\n    // saving discount for user\\n    function _setUsersPaintDiscountForColor(uint _color) internal {\\n\\n        //each 1 eth = 1% discount\\n        usersPaintDiscount[msg.sender] = moneySpentByUser[msg.sender] / 1 ether; // for all colors\\n        usersPaintDiscountForColor[_color][msg.sender] = moneySpentByUserForColor[_color][msg.sender] / 1 ether; // for current color\\n\\n        //max discount 10% for all colors\\n        if (moneySpentByUser[msg.sender] \\u003e= 10 ether) {\\n            usersPaintDiscount[msg.sender] = 10;\\n        }\\n\\n        //max discount 10% for current color\\n        if (moneySpentByUserForColor[_color][msg.sender] \\u003e= 10 ether) {\\n            usersPaintDiscountForColor[_color][msg.sender] = 10;\\n        }\\n    }\\n\\n    //  Money spent by user buying this color\\n    function _setMoneySpentByUserForColor(uint _color) internal {\\n\\n        moneySpentByUser[msg.sender] += msg.value; // for all colors\\n        moneySpentByUserForColor[_color][msg.sender] += msg.value; // for current color\\n\\n        // for all colors\\n        if (moneySpentByUser[msg.sender] \\u003e= 1 ether) {\\n            hasPaintDiscount[msg.sender] = true;\\n        }\\n\\n        // for current color\\n        if (moneySpentByUserForColor[_color][msg.sender] \\u003e= 1 ether) {\\n            hasPaintDiscountForColor[_color][msg.sender] = true;\\n        }\\n    }\\n}\"},\"PaintsPool.sol\":{\"content\":\"pragma solidity ^0.4.24;\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./StorageV1.sol\\\";\\n\\ncontract PaintsPool is StorageV1 {\\n    using SafeMath for uint;\\n\\n    //update paint price\\n    function _updateCallPrice(uint _color) private {\\n        \\n        //increase call price for 5%(for frontend)\\n        nextCallPriceForColor[_color] = callPriceForColor[_color].mul(105).div(100);\\n        \\n        \\n        emit CallPriceUpdated(callPriceForColor[_color]);\\n    }\\n     \\n    \\n    \\n    function _fillPaintsPool(uint _color) internal {\\n\\n        \\n        uint nextPaintGen = currentPaintGenForColor[_color].add(1);\\n        //each 5 min we produce new paint generation\\n        if (now - paintGenToEndTimeForColor[_color][currentPaintGenForColor[_color] - 1] \\u003e= 5 minutes) { \\n            \\n            \\n            uint paintsRemain = paintGenToAmountForColor[_color][currentPaintGenForColor[_color]]; \\n            \\n            //if 5 min passed and new gen not yet started     \\n            if (paintGenStartedForColor[_color][nextPaintGen] == false) {\\n                \\n                //we create new gen with amount of paints remaining \\n                paintGenToAmountForColor[_color][nextPaintGen] = maxPaintsInPool.sub(paintsRemain); \\n                \\n                \\n                paintGenToStartTimeForColor[_color][nextPaintGen] = now; \\n\\n                paintGenStartedForColor[_color][nextPaintGen] = true;\\n            }\\n            \\n            if (paintGenToAmountForColor[_color][currentPaintGenForColor[_color]] == 1) {\\n                \\n                \\n                _updateCallPrice(_color);\\n                \\n                //current gen paiints ends now \\n                paintGenToEndTimeForColor[_color][currentPaintGenForColor[_color]] = now;\\n            }\\n               \\n            \\n            if (paintGenToAmountForColor[_color][currentPaintGenForColor[_color]] == 0) {\\n                \\n               \\n                callPriceForColor[_color] = nextCallPriceForColor[_color];\\n\\n                if (paintGenToAmountForColor[_color][nextPaintGen] == 0) {\\n                    paintGenToAmountForColor[_color][nextPaintGen] = maxPaintsInPool;\\n                }\\n                //now we use next gen paints\\n                currentPaintGenForColor[_color] = nextPaintGen;\\n            }\\n        }\\n        ///if 5 min not yet passed\\n        else {\\n\\n            if (paintGenToAmountForColor[_color][currentPaintGenForColor[_color]] == 0) {\\n               \\n                paintGenToAmountForColor[_color][nextPaintGen] = maxPaintsInPool;\\n                //we use next paint gen\\n                currentPaintGenForColor[_color] = nextPaintGen;\\n            }\\n\\n        }\\n    }\\n}\"},\"Referral.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Modifiers.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\ncontract Referral is Modifiers {\\n    using SafeMath for uint;\\n\\n    // ref link lenght 4-8 symbols\\n    function createRefLink(string _refLink) external isValidRefLink(_refLink) {\\n        require(!hasRefLink[msg.sender], \\\"You have already generated your ref link.\\\");\\n        bytes32 refLink32 = Utils.toBytes16(_refLink);\\n        require(!refLinkExists[refLink32], \\\"This referral link already exists, try different one.\\\");\\n        hasRefLink[msg.sender] = true;\\n        userToRefLink[msg.sender] = _refLink;\\n        refLinkExists[refLink32] = true;\\n        refLinkToUser[refLink32] = msg.sender;\\n    }\\n\\n    function getReferralsForUser(address _user) external view returns (address[]) {\\n        return referrerToReferrals[_user];\\n    }\\n\\n    function getReferralData(address _user) external view returns (uint registrationTime, uint moneySpent) {\\n        registrationTime = registrationTimeForUser[_user];\\n        moneySpent = moneySpentByUser[_user];\\n    }\\n}\"},\"Roles.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./Modifiers.sol\\\";\\n\\ncontract Roles is Modifiers {\\n    \\n    function addAdmin(address _new) external onlyOwner() {\\n        isAdmin[_new] = true;\\n    }\\n    \\n    function removeAdmin(address _admin) external onlyOwner() {\\n        isAdmin[_admin] = false;\\n    }\\n\\n    function renounceAdmin() external onlyAdmin() {\\n        isAdmin[msg.sender] = false;\\n    }\\n\\n}\"},\"Router.sol\":{\"content\":\"pragma solidity 0.4.24;\\npragma experimental \\\"v0.5.0\\\";\\nimport \\\"./Initializer.sol\\\";\\n\\ncontract Router is Initializer {\\n    \\n    event CommitMessage(string message);\\n    event FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\\n\\n    constructor(address _erc1538Delegate) public  {\\n\\n        //Adding ERC1538 updateContract function\\n        bytes memory signature = \\\"updateContract(address,string,string)\\\";\\n        bytes4 funcId = bytes4(keccak256(signature));\\n        delegates[funcId] = _erc1538Delegate;\\n        funcSignatures.push(signature);\\n        funcSignatureToIndex[signature] = funcSignatures.length;\\n        emit FunctionUpdate(funcId, address(0), _erc1538Delegate, string(signature));\\n        emit CommitMessage(\\\"Added ERC1538 updateContract function at contract creation\\\");\\n    \\n        _initializer();\\n    }\\n\\n    function() external payable {\\n        address delegate = delegates[msg.sig];\\n        require(delegate != address(0), \\\"Function does not exist.\\\");\\n        assembly {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, 0, calldatasize)\\n            let result := delegatecall(gas, delegate, ptr, calldatasize, 0, 0)\\n            let size := returndatasize\\n            returndatacopy(ptr, 0, size)\\n            switch result\\n            case 0 {revert(ptr, size)}\\n            default {return (ptr, size)}\\n        }\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two numbers, reverts on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0); // Solidity only automatically asserts when dividing by 0\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, reverts on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\"},\"StorageV0.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract StorageV0 is Ownable {\\n\\n    // maps functions to the delegate contracts that execute the functions\\n    // funcId =\\u003e delegate contract\\n    mapping(bytes4 =\\u003e address) internal delegates;\\n\\n    // array of function signatures supported by the contract\\n    bytes[] internal funcSignatures;\\n\\n    // maps each function signature to its position in the funcSignatures array.\\n    // signature =\\u003e index+1\\n    mapping(bytes =\\u003e uint256) internal funcSignatureToIndex;\\n\\n}\"},\"StorageV1.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./StorageV0.sol\\\";\\nimport \\\"./IColor.sol\\\";\\nimport \\\"./IPixel.sol\\\";\\n\\ncontract StorageV1 is StorageV0 {\\n\\n    //pixel color(round=\\u003e pixel=\\u003e color)\\n    mapping (uint =\\u003e mapping (uint =\\u003e uint)) public pixelToColorForRound;\\n\\n    //old pixel color(round=\\u003e pixel=\\u003e color)\\n    mapping (uint =\\u003e mapping (uint =\\u003e uint)) public pixelToOldColorForRound;\\n\\n    // (round =\\u003e color =\\u003e pixel amount)\\n    mapping (uint =\\u003e mapping (uint =\\u003e uint)) public colorToPaintedPixelsAmountForRound;\\n\\n    //color bank for round (round =\\u003e color bank)\\n    mapping (uint =\\u003e uint) public colorBankForRound;\\n\\n    //color bank for  color for round (round =\\u003e color =\\u003e color bank)\\n    mapping (uint =\\u003e mapping (uint =\\u003e uint)) public colorBankToColorForRound;\\n\\n    //time bank for round (round =\\u003e time bank)\\n    mapping (uint =\\u003e uint) public timeBankForRound;\\n\\n    // (round =\\u003e timestamp)\\n    mapping (uint =\\u003e uint) public lastPaintTimeForRound;\\n\\n    // (round =\\u003e adress)\\n    mapping (uint =\\u003e address) public lastPainterForRound;\\n\\n    // (round =\\u003e pixel)\\n    mapping (uint =\\u003e uint) public lastPaintedPixelForRound;\\n\\n    // (round =\\u003e color)\\n    mapping (uint =\\u003e uint) public winnerColorForRound;\\n\\n    // (round =\\u003e color =\\u003e paints amount)\\n    mapping (uint =\\u003e mapping (uint =\\u003e uint)) public colorToTotalPaintsForCBIteration;\\n\\n    // (round =\\u003e adress)\\n    mapping (uint =\\u003e address) public winnerOfRound;\\n\\n    //bank drawn in round (round =\\u003e drawn bank) (1 = time bank, 2 = color bank)\\n    mapping (uint =\\u003e uint) public winnerBankForRound;\\n\\n    // (round =\\u003e pixel =\\u003e timestamp)\\n    mapping (uint =\\u003e mapping (uint =\\u003e uint)) public pixelToPaintTimeForRound;\\n\\n\\n    // number of paints for paint price limit\\n    uint public priceLimitPaints;\\n\\n    // is paint function call – for paint price limit logic\\n    bool public isPaintCall;\\n\\n\\n    // (round =\\u003e paints number)\\n    mapping (uint =\\u003e uint) public totalPaintsForRound;\\n\\n    // (round =\\u003e address =\\u003e paints number)\\n    mapping (uint =\\u003e mapping (address =\\u003e uint)) public userPaintsForRound;\\n\\n\\n    // total cashback for round (round =\\u003e total cashback)\\n    mapping (uint =\\u003e uint) public totalCashBackForRound;\\n\\n    // max cashback since the beginning of the round (round =\\u003e cashback per paint)\\n    mapping (uint =\\u003e uint) public maxCashBackPerPaintForRound;\\n\\n    // cashback per painter for round in time of painter\\u0027s last paint (round =\\u003e painter\\u0027s address =\\u003e cashback per paint)\\n    mapping (uint =\\u003e mapping (address =\\u003e uint)) public cashBackPerPaintForRound;\\n\\n    // unwithdrawn cashback + remaining money from paints (address =\\u003e cashback per painter)\\n    mapping (address =\\u003e uint) public cashBackCalculated;\\n\\n    // last cashback calculation round in cashBackCalculated (address =\\u003e round)\\n    mapping (address =\\u003e uint) public cashBackCalculationRound;\\n\\n\\n    mapping (uint =\\u003e mapping (uint =\\u003e uint)) public paintGenToAmountForColor;\\n    mapping (uint =\\u003e mapping (uint =\\u003e uint)) public paintGenToStartTimeForColor;\\n    mapping (uint =\\u003e mapping (uint =\\u003e uint)) public paintGenToEndTimeForColor;\\n    mapping (uint =\\u003e mapping (uint =\\u003e bool)) public paintGenStartedForColor;\\n    mapping (uint =\\u003e uint) public currentPaintGenForColor;\\n    mapping (uint =\\u003e uint) public callPriceForColor;\\n    mapping (uint =\\u003e uint) public nextCallPriceForColor;\\n\\n\\n    mapping (uint =\\u003e mapping (address =\\u003e uint)) public moneySpentByUserForColor;\\n    mapping (address =\\u003e uint) public moneySpentByUser;\\n\\n\\n    mapping (uint =\\u003e mapping (address =\\u003e bool)) public hasPaintDiscountForColor;\\n    mapping (address =\\u003e bool) public hasPaintDiscount;\\n    mapping (uint =\\u003e mapping (address =\\u003e uint)) public usersPaintDiscountForColor;  //in percent\\n    mapping (address =\\u003e uint) public usersPaintDiscount;  //in percent\\n\\n\\n\\n    mapping (address =\\u003e uint) public registrationTimeForUser;\\n    mapping (address =\\u003e bool) public isRegisteredUser;\\n\\n\\n    mapping (address =\\u003e bool) public hasRefLink;\\n    mapping (address =\\u003e address) public referralToReferrer;\\n    mapping (address =\\u003e address[]) public referrerToReferrals;\\n    mapping (address =\\u003e bool) public hasReferrer;\\n    mapping (address =\\u003e string) public userToRefLink;\\n    mapping (bytes32 =\\u003e address) public refLinkToUser;\\n    mapping (bytes32 =\\u003e bool) public refLinkExists;\\n    mapping (address =\\u003e uint) public newUserToCounter;\\n\\n\\n    mapping (address =\\u003e string) public addressToUsername;\\n    mapping (string =\\u003e bool) internal usernameExists;  // not public – string accessor\\n\\n\\n    mapping(address =\\u003e bool)  public luckyPotBankWinner;\\n    uint public luckyPotBank;\\n\\n\\n    uint public uniqueUsersCount;\\n\\n    uint public maxPaintsInPool;\\n\\n    uint public currentRound;\\n\\n    //time bank iteration\\n    uint public tbIteration;\\n\\n   //color bank iteration\\n    uint public cbIteration;\\n\\n\\n    uint public paintsCounter;\\n    mapping (uint =\\u003e uint) public paintsCounterForColor;\\n\\n\\n    // (counter =\\u003e user)\\n    mapping (uint =\\u003e address) public counterToPainter;\\n\\n    // (color =\\u003e counter =\\u003e user)\\n    mapping (uint =\\u003e mapping (uint =\\u003e address)) public counterToPainterForColor;\\n\\n    mapping (address =\\u003e uint) public lastPlayedRound;\\n\\n\\n    // For dividends distribution\\n    mapping (address =\\u003e uint) public pendingWithdrawals;\\n\\n    // (adress =\\u003e time)\\n    mapping (address =\\u003e uint) public addressToLastWithdrawalTime;\\n\\n\\n    address public founders = 0xe04f921cf3d6c882C0FAa79d0810a50B1101e2D4;\\n\\n\\n    bool public isGamePaused;\\n\\n    mapping(address =\\u003e bool) public isAdmin;\\n\\n    Color public colorInstance;\\n    Pixel public pixelInstance;\\n\\n    uint public totalColorsNumber; // 8\\n    uint public totalPixelsNumber; //225 in V1\\n\\n\\n    mapping (address =\\u003e uint) public lastPaintTimeOfUser;\\n    mapping (uint =\\u003e mapping (address =\\u003e uint)) public lastPaintTimeOfUserForColor;\\n\\n\\n    mapping (uint =\\u003e uint) public usersCounterForRound;\\n    mapping (uint =\\u003e mapping (address =\\u003e bool)) public isUserCountedForRound;\\n\\n\\n    // ***** Events *****\\n\\n    event ColorBankWithdrawn(uint indexed round, uint indexed cbIteration, address indexed winnerOfRound, uint prize);\\n    event TimeBankWithdrawn(uint indexed round, uint indexed tbIteration, address indexed winnerOfRound, uint prize);\\n    event Paint(uint indexed pixelId, uint colorId, address indexed painter, uint indexed round, uint timestamp);\\n    event CallPriceUpdated(uint indexed newCallPrice);\\n    event EtherWithdrawn(uint balance, uint colorBank, uint timeBank, uint timestamp);\\n    event LuckyPotDrawn(uint pixelId, address indexed winnerOfLuckyPot, uint prize);\\n    event CashBackWithdrawn(uint indexed round, address indexed withdrawer, uint cashback);\\n    event DividendsWithdrawn(address indexed withdrawer, uint withdrawalAmount);\\n    event UsernameCreated(address indexed user, string username);\\n}\"},\"Utils.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nlibrary Utils {\\n    \\n    // convert a string less than 32 characters long to bytes32\\n    function toBytes16(string _string) pure internal returns (bytes16) {\\n        // make sure that the string isn\\u0027t too long for this function\\n        // will work but will cut off the any characters past the 32nd character\\n        bytes16 _stringBytes;\\n        string memory str = _string;\\n    \\n        // simplest way to convert 32 character long string\\n        assembly {\\n          // load the memory pointer of string with an offset of 32\\n          // 32 passes over non-core data parts of string such as length of text\\n          _stringBytes := mload(add(str, 32))\\n        }\\n        return _stringBytes;\\n    }\\n\\n    \\n    \\n}\"},\"Wrapper.sol\":{\"content\":\"pragma solidity 0.4.24;\\nimport \\\"./Modifiers.sol\\\";\\n\\n/**\\n** Wrapper for Router Contract to interact with all the functions\\u0027 signatures\\n**/\\n\\ncontract Wrapper is Modifiers {\\n\\n    //DividendsDistributor.sol\\n    function withdrawDividends() external returns (bool) {}\\n    function withdrawFoundersComission() external returns (bool) {}\\n\\n    //LuckyPot\\n    function increaseLuckyPot() external payable {}\\n    function drawLuckyPot(address _user, uint _bankPercent, uint _pixelId) external {}\\n\\n    //GameStateController.sol\\n    function pauseGame() external {}\\n    function resumeGame() external {}\\n    function withdrawEther() external returns (bool) {}\\n\\n    //Referral.sol\\n    function createRefLink(string _refLink) external {}\\n    function getReferralsForUser(address _user) external view returns (address[]) {}\\n    function getReferralData(address _user) external view returns (uint registrationTime, uint moneySpent) {}\\n\\n    //Roles.sol\\n    function addAdmin(address _new) external {}\\n    function removeAdmin(address _admin) external {}\\n    function renounceAdmin() external {}\\n\\n    //Game.sol\\n    function setPriceLimitPaints(uint _paintsNumber) external {}\\n    function estimateCallPrice(uint[] _pixels, uint _color) public view returns (uint totalCallPrice) {}\\n    function paint(uint[] _pixels, uint _color, string _refLink) external payable {}\\n    function drawTimeBank() public {}\\n    function cashBackAmount(address _painter) public view returns(uint cashBackInWei) {}\\n    function withdrawCashBack() external {}\\n\\n    //ERC1538.sol\\n    function updateContract(address _delegate, string _functionSignatures, string commitMessage) external {}\\n\\n    //GameMock.sol\\n    function mock() external {}\\n    function mock2() external {}\\n    function mock3(uint _winnerColor) external {}\\n    function mockMaxPaintsInPool() external {}\\n\\n    //Helpers.sol\\n    function getUsername(address _painter) external view returns(string username) {}\\n    function isUsernameExists(string _username) external view returns(bool) {}\\n    function createUsername(string _username) external {}\\n    function getPixelColor(uint _pixel) external view returns (uint) {}\\n    function addNewColor() external {}\\n\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isGamePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"refLinkToUser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userPaintsForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"colorToPaintedPixelsAmountForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tbIteration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winnerOfRound\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasReferrer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"colorToTotalPaintsForCBIteration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalColorsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRegisteredUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasPaintDiscountForColor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentPaintGenForColor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastPlayedRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"moneySpentByUserForColor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paintGenToStartTimeForColor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"callPriceForColor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winnerBankForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paintsCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"usersPaintDiscount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"founders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"newUserToCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"counterToPainterForColor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"moneySpentByUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pixelToOldColorForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timeBankForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToRefLink\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paintGenStartedForColor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceLimitPaints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usersCounterForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastPaintedPixelForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextCallPriceForColor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastPaintTimeForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastPainterForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"cashBackPerPaintForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasRefLink\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasPaintDiscount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isUserCountedForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"registrationTimeForUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastPaintTimeOfUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referrerToReferrals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paintsCounterForColor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pixelToPaintTimeForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"colorBankToColorForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"luckyPotBankWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaintCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"counterToPainter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastPaintTimeOfUserForColor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pixelToColorForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalCashBackForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalPaintsForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"colorBankForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paintGenToEndTimeForColor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniqueUsersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"refLinkExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paintGenToAmountForColor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"cashBackCalculated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralToReferrer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToLastWithdrawalTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToUsername\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxCashBackPerPaintForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"usersPaintDiscountForColor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPaintsInPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"cashBackCalculationRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPixelsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pixelInstance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingWithdrawals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winnerColorForRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"colorInstance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"luckyPotBank\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cbIteration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_erc1538Delegate\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"CommitMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"functionId\",\"type\":\"bytes4\"},{\"indexed\":true,\"name\":\"oldDelegate\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newDelegate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"functionSignature\",\"type\":\"string\"}],\"name\":\"FunctionUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"cbIteration\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winnerOfRound\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"ColorBankWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tbIteration\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winnerOfRound\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"TimeBankWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"pixelId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"colorId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"painter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Paint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newCallPrice\",\"type\":\"uint256\"}],\"name\":\"CallPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"colorBank\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeBank\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"EtherWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pixelId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winnerOfLuckyPot\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"LuckyPotDrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cashback\",\"type\":\"uint256\"}],\"name\":\"CashBackWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawalAmount\",\"type\":\"uint256\"}],\"name\":\"DividendsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"username\",\"type\":\"string\"}],\"name\":\"UsernameCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Router","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000fd006782540399a92628a472df6733e3c95b26a6","Library":"","LicenseType":"None","SwarmSource":"bzzr://9b93e29ed743d1cd483d3a0f1e4c2f87fc28a2d14840d27fbab69f80baf44309"}]}