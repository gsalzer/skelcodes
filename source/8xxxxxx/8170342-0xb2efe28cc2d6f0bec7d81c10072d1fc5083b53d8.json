{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/gnosis-safe/base/BaseSafe.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\nimport \\\"./Module.sol\\\";\\nimport \\\"./ModuleManager.sol\\\";\\nimport \\\"./OwnerManager.sol\\\";\\n\\n\\n/// @title Base Safe - A multisignature wallet with support for modules and owners. This contract needs to be extented to add functionality to execute transactions.\\n/// @author Stefan George - <stefan@gnosis.pm>\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract BaseSafe is ModuleManager, OwnerManager {\\n\\n    /// @dev Setup function sets initial storage of contract.\\n    /// @param _owners List of Safe owners.\\n    /// @param _threshold Number of required confirmations for a Safe transaction.\\n    /// @param to Contract address for optional delegate call.\\n    /// @param data Data payload for optional delegate call.\\n    function setupSafe(address[] memory _owners, uint256 _threshold, address to, bytes memory data)\\n        internal\\n    {\\n        setupOwners(_owners, _threshold);\\n        // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\\n        setupModules(to, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/base/Module.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\nimport \\\"../common/MasterCopy.sol\\\";\\nimport \\\"./ModuleManager.sol\\\";\\n\\n\\n/// @title Module - Base class for modules.\\n/// @author Stefan George - <stefan@gnosis.pm>\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract Module is MasterCopy {\\n\\n    ModuleManager public manager;\\n\\n    modifier authorized() {\\n        require(msg.sender == address(manager), \\\"Method can only be called from manager\\\");\\n        _;\\n    }\\n\\n    function setManager()\\n        internal\\n    {\\n        // manager can only be 0 at initalization of contract.\\n        // Check ensures that setup function can only be called once.\\n        require(address(manager) == address(0), \\\"Manager has already been set\\\");\\n        manager = ModuleManager(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/common/MasterCopy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\nimport \\\"./SelfAuthorized.sol\\\";\\n\\n\\n/// @title MasterCopy - Base for master copy contracts (should always be first super contract)\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract MasterCopy is SelfAuthorized {\\n  // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\\n  // It should also always be ensured that the address is stored alone (uses a full word)\\n    address masterCopy;\\n\\n  /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\\n  /// @param _masterCopy New contract address.\\n    function changeMasterCopy(address _masterCopy)\\n        public\\n        authorized\\n    {\\n        // Master copy address cannot be null.\\n        require(_masterCopy != address(0), \\\"Invalid master copy address provided\\\");\\n        masterCopy = _masterCopy;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/common/SelfAuthorized.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/// @title SelfAuthorized - authorizes current contract to perform actions\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract SelfAuthorized {\\n    modifier authorized() {\\n        require(msg.sender == address(this), \\\"Method can only be called from this contract\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/base/ModuleManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\nimport \\\"../common/Enum.sol\\\";\\nimport \\\"../common/SelfAuthorized.sol\\\";\\nimport \\\"./Executor.sol\\\";\\nimport \\\"./Module.sol\\\";\\n\\n\\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\\n/// @author Stefan George - <stefan@gnosis.pm>\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract ModuleManager is SelfAuthorized, Executor {\\n\\n    event EnabledModule(Module module);\\n    event DisabledModule(Module module);\\n\\n    address public constant SENTINEL_MODULES = address(0x1);\\n\\n    mapping (address => address) internal modules;\\n    \\n    function setupModules(address to, bytes memory data)\\n        internal\\n    {\\n        require(modules[SENTINEL_MODULES] == address(0), \\\"Modules have already been initialized\\\");\\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\\n        if (to != address(0))\\n            // Setup has to complete successfully or transaction fails.\\n            require(executeDelegateCall(to, data, gasleft()), \\\"Could not finish initialization\\\");\\n    }\\n\\n    /// @dev Allows to add a module to the whitelist.\\n    ///      This can only be done via a Safe transaction.\\n    /// @param module Module to be whitelisted.\\n    function enableModule(Module module)\\n        public\\n        authorized\\n    {\\n        // Module address cannot be null or sentinel.\\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \\\"Invalid module address provided\\\");\\n        // Module cannot be added twice.\\n        require(modules[address(module)] == address(0), \\\"Module has already been added\\\");\\n        modules[address(module)] = modules[SENTINEL_MODULES];\\n        modules[SENTINEL_MODULES] = address(module);\\n        emit EnabledModule(module);\\n    }\\n\\n    /// @dev Allows to remove a module from the whitelist.\\n    ///      This can only be done via a Safe transaction.\\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\\n    /// @param module Module to be removed.\\n    function disableModule(Module prevModule, Module module)\\n        public\\n        authorized\\n    {\\n        // Validate module address and check that it corresponds to module index.\\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \\\"Invalid module address provided\\\");\\n        require(modules[address(prevModule)] == address(module), \\\"Invalid prevModule, module pair provided\\\");\\n        modules[address(prevModule)] = modules[address(module)];\\n        modules[address(module)] = address(0);\\n        emit DisabledModule(module);\\n    }\\n\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\\n        public\\n        returns (bool success)\\n    {\\n        // Only whitelisted modules are allowed.\\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \\\"Method can only be called from an enabled module\\\");\\n        // Execute transaction without further confirmations.\\n        success = execute(to, value, data, operation, gasleft());\\n    }\\n\\n    /// @dev Returns array of modules.\\n    /// @return Array of modules.\\n    function getModules()\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        // Calculate module count\\n        uint256 moduleCount = 0;\\n        address currentModule = modules[SENTINEL_MODULES];\\n        while(currentModule != SENTINEL_MODULES) {\\n            currentModule = modules[currentModule];\\n            moduleCount ++;\\n        }\\n        address[] memory array = new address[](moduleCount);\\n\\n        // populate return array\\n        moduleCount = 0;\\n        currentModule = modules[SENTINEL_MODULES];\\n        while(currentModule != SENTINEL_MODULES) {\\n            array[moduleCount] = currentModule;\\n            currentModule = modules[currentModule];\\n            moduleCount ++;\\n        }\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/common/Enum.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/// @title Enum - Collection of enums\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract Enum {\\n    enum Operation {\\n        Call,\\n        DelegateCall,\\n        Create\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/base/Executor.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\nimport \\\"../common/Enum.sol\\\";\\nimport \\\"../common/EtherPaymentFallback.sol\\\";\\n\\n\\n/// @title Executor - A contract that can execute transactions\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract Executor is EtherPaymentFallback {\\n\\n    event ContractCreation(address newContract);\\n\\n    function execute(address to, uint256 value, bytes memory data, Enum.Operation operation, uint256 txGas)\\n        internal\\n        returns (bool success)\\n    {\\n        if (operation == Enum.Operation.Call)\\n            success = executeCall(to, value, data, txGas);\\n        else if (operation == Enum.Operation.DelegateCall)\\n            success = executeDelegateCall(to, data, txGas);\\n        else {\\n            address newContract = executeCreate(data);\\n            success = newContract != address(0);\\n            emit ContractCreation(newContract);\\n        }\\n    }\\n\\n    function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\\n        internal\\n        returns (bool success)\\n    {\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\\n        }\\n    }\\n\\n    function executeDelegateCall(address to, bytes memory data, uint256 txGas)\\n        internal\\n        returns (bool success)\\n    {\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\\n        }\\n    }\\n\\n    function executeCreate(bytes memory data)\\n        internal\\n        returns (address newContract)\\n    {\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            newContract := create(0, add(data, 0x20), mload(data))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/common/EtherPaymentFallback.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract EtherPaymentFallback {\\n\\n    /// @dev Fallback function accepts Ether transactions.\\n    function ()\\n        external\\n        payable\\n    {\\n\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/base/OwnerManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\nimport \\\"../common/SelfAuthorized.sol\\\";\\n\\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\\n/// @author Stefan George - <stefan@gnosis.pm>\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract OwnerManager is SelfAuthorized {\\n\\n    event AddedOwner(address owner);\\n    event RemovedOwner(address owner);\\n    event ChangedThreshold(uint256 threshold);\\n\\n    address public constant SENTINEL_OWNERS = address(0x1);\\n\\n    mapping(address => address) internal owners;\\n    uint256 ownerCount;\\n    uint256 internal threshold;\\n\\n    /// @dev Setup function sets initial storage of contract.\\n    /// @param _owners List of Safe owners.\\n    /// @param _threshold Number of required confirmations for a Safe transaction.\\n    function setupOwners(address[] memory _owners, uint256 _threshold)\\n        internal\\n    {\\n        // Threshold can only be 0 at initialization.\\n        // Check ensures that setup function can only be called once.\\n        require(threshold == 0, \\\"Owners have already been setup\\\");\\n        // Validate that threshold is smaller than number of added owners.\\n        require(_threshold <= _owners.length, \\\"Threshold cannot exceed owner count\\\");\\n        // There has to be at least one Safe owner.\\n        require(_threshold >= 1, \\\"Threshold needs to be greater than 0\\\");\\n        // Initializing Safe owners.\\n        address currentOwner = SENTINEL_OWNERS;\\n        for (uint256 i = 0; i < _owners.length; i++) {\\n            // Owner address cannot be null.\\n            address owner = _owners[i];\\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \\\"Invalid owner address provided\\\");\\n            // No duplicate owners allowed.\\n            require(owners[owner] == address(0), \\\"Duplicate owner address provided\\\");\\n            owners[currentOwner] = owner;\\n            currentOwner = owner;\\n        }\\n        owners[currentOwner] = SENTINEL_OWNERS;\\n        ownerCount = _owners.length;\\n        threshold = _threshold;\\n    }\\n\\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\\n    ///      This can only be done via a Safe transaction.\\n    /// @param owner New owner address.\\n    /// @param _threshold New threshold.\\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\\n        public\\n        authorized\\n    {\\n        // Owner address cannot be null.\\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \\\"Invalid owner address provided\\\");\\n        // No duplicate owners allowed.\\n        require(owners[owner] == address(0), \\\"Address is already an owner\\\");\\n        owners[owner] = owners[SENTINEL_OWNERS];\\n        owners[SENTINEL_OWNERS] = owner;\\n        ownerCount++;\\n        emit AddedOwner(owner);\\n        // Change threshold if threshold was changed.\\n        if (threshold != _threshold)\\n            changeThreshold(_threshold);\\n    }\\n\\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\\n    ///      This can only be done via a Safe transaction.\\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\\n    /// @param owner Owner address to be removed.\\n    /// @param _threshold New threshold.\\n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\\n        public\\n        authorized\\n    {\\n        // Only allow to remove an owner, if threshold can still be reached.\\n        require(ownerCount - 1 >= _threshold, \\\"New owner count needs to be larger than new threshold\\\");\\n        // Validate owner address and check that it corresponds to owner index.\\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \\\"Invalid owner address provided\\\");\\n        require(owners[prevOwner] == owner, \\\"Invalid prevOwner, owner pair provided\\\");\\n        owners[prevOwner] = owners[owner];\\n        owners[owner] = address(0);\\n        ownerCount--;\\n        emit RemovedOwner(owner);\\n        // Change threshold if threshold was changed.\\n        if (threshold != _threshold)\\n            changeThreshold(_threshold);\\n    }\\n\\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\\n    ///      This can only be done via a Safe transaction.\\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\\n    /// @param oldOwner Owner address to be replaced.\\n    /// @param newOwner New owner address.\\n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\\n        public\\n        authorized\\n    {\\n        // Owner address cannot be null.\\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \\\"Invalid owner address provided\\\");\\n        // No duplicate owners allowed.\\n        require(owners[newOwner] == address(0), \\\"Address is already an owner\\\");\\n        // Validate oldOwner address and check that it corresponds to owner index.\\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \\\"Invalid owner address provided\\\");\\n        require(owners[prevOwner] == oldOwner, \\\"Invalid prevOwner, owner pair provided\\\");\\n        owners[newOwner] = owners[oldOwner];\\n        owners[prevOwner] = newOwner;\\n        owners[oldOwner] = address(0);\\n        emit RemovedOwner(oldOwner);\\n        emit AddedOwner(newOwner);\\n    }\\n\\n    /// @dev Allows to update the number of required confirmations by Safe owners.\\n    ///      This can only be done via a Safe transaction.\\n    /// @param _threshold New threshold.\\n    function changeThreshold(uint256 _threshold)\\n        public\\n        authorized\\n    {\\n        // Validate that threshold is smaller than number of owners.\\n        require(_threshold <= ownerCount, \\\"Threshold cannot exceed owner count\\\");\\n        // There has to be at least one Safe owner.\\n        require(_threshold >= 1, \\\"Threshold needs to be greater than 0\\\");\\n        threshold = _threshold;\\n        emit ChangedThreshold(threshold);\\n    }\\n\\n    function getThreshold()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return threshold;\\n    }\\n\\n    function isOwner(address owner)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\\n    }\\n\\n    /// @dev Returns array of owners.\\n    /// @return Array of Safe owners.\\n    function getOwners()\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        address[] memory array = new address[](ownerCount);\\n\\n        // populate return array\\n        uint256 index = 0;\\n        address currentOwner = owners[SENTINEL_OWNERS];\\n        while(currentOwner != SENTINEL_OWNERS) {\\n            array[index] = currentOwner;\\n            currentOwner = owners[currentOwner];\\n            index ++;\\n        }\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/common/SecuredTokenTransfer.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/// @title SecuredTokenTransfer - Secure token transfer\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract SecuredTokenTransfer {\\n\\n    /// @dev Transfers a token and returns if it was a success\\n    /// @param token Token that should be transferred\\n    /// @param receiver Receiver to whom the token should be transferred\\n    /// @param amount The amount of tokens that should be transferred\\n    function transferToken (\\n        address token, \\n        address receiver,\\n        uint256 amount\\n    )\\n        internal\\n        returns (bool transferred)\\n    {\\n        bytes memory data = abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", receiver, amount);\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, returndatasize)\\n            switch returndatasize \\n            case 0 { transferred := success }\\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\\n            default { transferred := 0 }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/common/SignatureDecoder.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\\n/// @author Ricardo Guilherme Schmidt (Status Research & Development GmbH) \\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract SignatureDecoder {\\n    \\n    /// @dev Recovers address who signed the message \\n    /// @param messageHash operation ethereum signed message hash\\n    /// @param messageSignature message `txHash` signature\\n    /// @param pos which signature to read\\n    function recoverKey (\\n        bytes32 messageHash, \\n        bytes memory messageSignature,\\n        uint256 pos\\n    )\\n        internal\\n        pure\\n        returns (address) \\n    {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        (v, r, s) = signatureSplit(messageSignature, pos);\\n        return ecrecover(messageHash, v, r, s);\\n    }\\n\\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`. \\n    /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures\\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\\n    /// @param signatures concatenated rsv signatures\\n    function signatureSplit(bytes memory signatures, uint256 pos)\\n        internal\\n        pure\\n        returns (uint8 v, bytes32 r, bytes32 s)\\n    {\\n        // The signature format is a compact form of:\\n        //   {bytes32 r}{bytes32 s}{uint8 v}\\n        // Compact means, uint8 is not padded to 32 bytes.\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            let signaturePos := mul(0x41, pos)\\n            r := mload(add(signatures, add(signaturePos, 0x20)))\\n            s := mload(add(signatures, add(signaturePos, 0x40)))\\n            // Here we are loading the last 32 bytes, including 31 bytes\\n            // of 's'. There is no 'mload8' to do this.\\n            //\\n            // 'byte' is not working due to the Solidity parser, so lets\\n            // use the second best option, 'and'\\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/external/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n * TODO: remove once open zeppelin update to solc 0.5.0\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\"\r\n    },\r\n    \"contracts/gnosis-safe/GnosisSafe.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\nimport \\\"./base/BaseSafe.sol\\\";\\nimport \\\"./common/MasterCopy.sol\\\";\\nimport \\\"./common/SignatureDecoder.sol\\\";\\nimport \\\"./common/SecuredTokenTransfer.sol\\\";\\nimport \\\"./interfaces/ISignatureValidator.sol\\\";\\nimport \\\"./external/SafeMath.sol\\\";\\n\\n/// @title Gnosis Safe - A multisignature wallet with support for confirmations using signed messages based on ERC191.\\n/// @author Stefan George - <stefan@gnosis.pm>\\n/// @author Richard Meissner - <richard@gnosis.pm>\\n/// @author Ricardo Guilherme Schmidt - (Status Research & Development GmbH) - Gas Token Payment\\ncontract GnosisSafe is MasterCopy, BaseSafe, SignatureDecoder, SecuredTokenTransfer, ISignatureValidator {\\n\\n    using SafeMath for uint256;\\n\\n    string public constant NAME = \\\"Gnosis Safe\\\";\\n    string public constant VERSION = \\\"1.0.0\\\";\\n\\n    //keccak256(\\n    //    \\\"EIP712Domain(address verifyingContract)\\\"\\n    //);\\n    bytes32 public constant DOMAIN_SEPARATOR_TYPEHASH = 0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;\\n\\n    //keccak256(\\n    //    \\\"SafeTx(address to,uint256 value,bytes data,uint8 operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\\\"\\n    //);\\n    bytes32 public constant SAFE_TX_TYPEHASH = 0xbb8310d486368db6bd6f849402fdd73ad53d316b5a4b2644ad6efe0f941286d8;\\n\\n    //keccak256(\\n    //    \\\"SafeMessage(bytes message)\\\"\\n    //);\\n    bytes32 public constant SAFE_MSG_TYPEHASH = 0x60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca;\\n\\n    event ExecutionFailed(bytes32 txHash);\\n\\n    uint256 public nonce;\\n    bytes32 public domainSeparator;\\n    // Mapping to keep track of all message hashes that have been approve by ALL REQUIRED owners\\n    mapping(bytes32 => uint256) public signedMessages;\\n    // Mapping to keep track of all hashes (message or transaction) that have been approve by ANY owners\\n    mapping(address => mapping(bytes32 => uint256)) public approvedHashes;\\n\\n    /// @dev Setup function sets initial storage of contract.\\n    /// @param _owners List of Safe owners.\\n    /// @param _threshold Number of required confirmations for a Safe transaction.\\n    /// @param to Contract address for optional delegate call.\\n    /// @param data Data payload for optional delegate call.\\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\\n    /// @param payment Value that should be paid\\n    /// @param paymentReceiver Adddress that should receive the payment (or 0 if tx.origin)\\n    function setup(address[] calldata _owners, uint256 _threshold, address to, bytes calldata data, address paymentToken, uint256 payment, address payable paymentReceiver)\\n        external\\n    {\\n        require(domainSeparator == 0, \\\"Domain Separator already set!\\\");\\n        domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this));\\n        setupSafe(_owners, _threshold, to, data);\\n        \\n        if (payment > 0) {\\n            // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\\n            // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\\n            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\\n        } \\n    }\\n\\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\\n    ///      Note: The fees are always transfered, even if the user transaction fails.\\n    /// @param to Destination address of Safe transaction.\\n    /// @param value Ether value of Safe transaction.\\n    /// @param data Data payload of Safe transaction.\\n    /// @param operation Operation type of Safe transaction.\\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\\n    /// @param baseGas Gas costs for that are indipendent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\\n    /// @param gasPrice Gas price that should be used for the payment calculation.\\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\\n    function execTransaction(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address payable refundReceiver,\\n        bytes calldata signatures\\n    )\\n        external\\n        returns (bool success)\\n    {\\n        bytes memory txHashData = encodeTransactionData(\\n            to, value, data, operation, // Transaction info\\n            safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, // Payment info\\n            nonce\\n        );\\n        // Increase nonce and execute transaction.\\n        nonce++;\\n        checkSignatures(keccak256(txHashData), txHashData, signatures, true);\\n        require(gasleft() >= safeTxGas, \\\"Not enough gas to execute safe transaction\\\");\\n        uint256 gasUsed = gasleft();\\n        // If no safeTxGas has been set and the gasPrice is 0 we assume that all available gas can be used\\n        success = execute(to, value, data, operation, safeTxGas == 0 && gasPrice == 0 ? gasleft() : safeTxGas);\\n        gasUsed = gasUsed.sub(gasleft());\\n        if (!success) {\\n            emit ExecutionFailed(keccak256(txHashData));\\n        }\\n\\n        // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\\n        if (gasPrice > 0) {\\n            handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\\n        }\\n    }\\n\\n    function handlePayment(\\n        uint256 gasUsed,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address payable refundReceiver\\n    )\\n        private\\n    {\\n        uint256 amount = gasUsed.add(baseGas).mul(gasPrice);\\n        // solium-disable-next-line security/no-tx-origin\\n        address payable receiver = refundReceiver == address(0) ? tx.origin : refundReceiver;\\n        if (gasToken == address(0)) {\\n            // solium-disable-next-line security/no-send\\n            require(receiver.send(amount), \\\"Could not pay gas costs with ether\\\");\\n        } else {\\n            require(transferToken(gasToken, receiver, amount), \\\"Could not pay gas costs with token\\\");\\n        }\\n    }\\n\\n    /**\\n    * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\\n    * @param dataHash Hash of the data (could be either a message hash or transaction hash)\\n    * @param data That should be signed (this is passed to an external validator contract)\\n    * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\\n    * @param consumeHash Indicates that in case of an approved hash the storage can be freed to save gas\\n    */\\n    function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures, bool consumeHash)\\n        internal\\n    {\\n        // Check that the provided signature data is not too short\\n        require(signatures.length >= threshold.mul(65), \\\"Signatures data too short\\\");\\n        // There cannot be an owner with address 0.\\n        address lastOwner = address(0);\\n        address currentOwner;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        uint256 i;\\n        for (i = 0; i < threshold; i++) {\\n            (v, r, s) = signatureSplit(signatures, i);\\n            // If v is 0 then it is a contract signature\\n            if (v == 0) {\\n                // When handling contract signatures the address of the contract is encoded into r\\n                currentOwner = address(uint256(r));\\n\\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\\n                // Here we only check that the pointer is not pointing inside the part that is being processed\\n                require(uint256(s) >= threshold.mul(65), \\\"Invalid contract signature location: inside static part\\\");\\n\\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\\n                require(uint256(s).add(32) <= signatures.length, \\\"Invalid contract signature location: length not present\\\");\\n\\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\\n                uint256 contractSignatureLen;\\n                // solium-disable-next-line security/no-inline-assembly\\n                assembly {\\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\\n                }\\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \\\"Invalid contract signature location: data not complete\\\");\\n\\n                // Check signature\\n                bytes memory contractSignature;\\n                // solium-disable-next-line security/no-inline-assembly\\n                assembly {\\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\\n                    contractSignature := add(add(signatures, s), 0x20)\\n                }\\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \\\"Invalid contract signature provided\\\");\\n            // If v is 1 then it is an approved hash\\n            } else if (v == 1) {\\n                // When handling approved hashes the address of the approver is encoded into r\\n                currentOwner = address(uint256(r));\\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \\\"Hash has not been approved\\\");\\n                // Hash has been marked for consumption. If this hash was pre-approved free storage\\n                if (consumeHash && msg.sender != currentOwner) {\\n                    approvedHashes[currentOwner][dataHash] = 0;\\n                }\\n            } else {\\n                // Use ecrecover with the messageHash for EOA signatures\\n                currentOwner = ecrecover(dataHash, v, r, s);\\n            }\\n            require (currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, \\\"Invalid owner provided\\\");\\n            lastOwner = currentOwner;\\n        }\\n    }\\n\\n    /// @dev Allows to estimate a Safe transaction.\\n    ///      This method is only meant for estimation purpose, therfore two different protection mechanism against execution in a transaction have been made:\\n    ///      1.) The method can only be called from the safe itself\\n    ///      2.) The response is returned with a revert\\n    ///      When estimating set `from` to the address of the safe.\\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\\n    /// @param to Destination address of Safe transaction.\\n    /// @param value Ether value of Safe transaction.\\n    /// @param data Data payload of Safe transaction.\\n    /// @param operation Operation type of Safe transaction.\\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\\n    function requiredTxGas(address to, uint256 value, bytes calldata data, Enum.Operation operation)\\n        external\\n        authorized\\n        returns (uint256)\\n    {\\n        uint256 startGas = gasleft();\\n        // We don't provide an error message here, as we use it to return the estimate\\n        // solium-disable-next-line error-reason\\n        require(execute(to, value, data, operation, gasleft()));\\n        uint256 requiredGas = startGas - gasleft();\\n        // Convert response to string and return via error message\\n        revert(string(abi.encodePacked(requiredGas)));\\n    }\\n\\n    /**\\n    * @dev Marks a hash as approved. This can be used to validate a hash that is used by a signature.\\n    * @param hashToApprove The hash that should be marked as approved for signatures that are verified by this contract.\\n    */\\n    function approveHash(bytes32 hashToApprove)\\n        external\\n    {\\n        require(owners[msg.sender] != address(0), \\\"Only owners can approve a hash\\\");\\n        approvedHashes[msg.sender][hashToApprove] = 1;\\n    }\\n\\n    /**\\n    * @dev Marks a message as signed\\n    * @param _data Arbitrary length data that should be marked as signed on the behalf of address(this)\\n    */ \\n    function signMessage(bytes calldata _data) \\n        external\\n        authorized\\n    {\\n        signedMessages[getMessageHash(_data)] = 1;\\n    }\\n\\n    /**\\n    * @dev Should return whether the signature provided is valid for the provided data\\n    * @param _data Arbitrary length data signed on the behalf of address(this)\\n    * @param _signature Signature byte array associated with _data\\n    * @return a bool upon valid or invalid signature with corresponding _data\\n    */ \\n    function isValidSignature(bytes calldata _data, bytes calldata _signature)\\n        external\\n        returns (bytes4)\\n    {\\n        bytes32 messageHash = getMessageHash(_data);\\n        if (_signature.length == 0) {\\n            require(signedMessages[messageHash] != 0, \\\"Hash not approved\\\");\\n        } else {\\n            // consumeHash needs to be false, as the state should not be changed\\n            checkSignatures(messageHash, _data, _signature, false);\\n        }\\n        return EIP1271_MAGIC_VALUE;\\n    }\\n\\n    /// @dev Returns hash of a message that can be signed by owners.\\n    /// @param message Message that should be hashed\\n    /// @return Message hash.\\n    function getMessageHash(\\n        bytes memory message\\n    )\\n        public\\n        view\\n        returns (bytes32)\\n    {\\n        bytes32 safeMessageHash = keccak256(\\n            abi.encode(SAFE_MSG_TYPEHASH, keccak256(message))\\n        );\\n        return keccak256(\\n            abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeMessageHash)\\n        );\\n    }\\n\\n    /// @dev Returns the bytes that are hashed to be signed by owners.\\n    /// @param to Destination address.\\n    /// @param value Ether value.\\n    /// @param data Data payload.\\n    /// @param operation Operation type.\\n    /// @param safeTxGas Fas that should be used for the safe transaction.\\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\\n    /// @param _nonce Transaction nonce.\\n    /// @return Transaction hash bytes.\\n    function encodeTransactionData(\\n        address to, \\n        uint256 value, \\n        bytes memory data, \\n        Enum.Operation operation, \\n        uint256 safeTxGas, \\n        uint256 baseGas, \\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver,\\n        uint256 _nonce\\n    )\\n        public\\n        view\\n        returns (bytes memory)\\n    {\\n        bytes32 safeTxHash = keccak256(\\n            abi.encode(SAFE_TX_TYPEHASH, to, value, keccak256(data), operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce)\\n        );\\n        return abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, safeTxHash);\\n    }\\n\\n    /// @dev Returns hash to be signed by owners.\\n    /// @param to Destination address.\\n    /// @param value Ether value.\\n    /// @param data Data payload.\\n    /// @param operation Operation type.\\n    /// @param safeTxGas Fas that should be used for the safe transaction.\\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\\n    /// @param _nonce Transaction nonce.\\n    /// @return Transaction hash.\\n    function getTransactionHash(\\n        address to, \\n        uint256 value, \\n        bytes memory data, \\n        Enum.Operation operation, \\n        uint256 safeTxGas, \\n        uint256 baseGas, \\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver,\\n        uint256 _nonce\\n    )\\n        public\\n        view\\n        returns (bytes32)\\n    {\\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/interfaces/ISignatureValidator.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\ncontract ISignatureValidator {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\")\\n    bytes4 constant internal EIP1271_MAGIC_VALUE = 0x20c13b0b;\\n\\n    /**\\n    * @dev Should return whether the signature provided is valid for the provided data\\n    * @param _data Arbitrary length data signed on the behalf of address(this)\\n    * @param _signature Signature byte array associated with _data\\n    *\\n    * MUST return the bytes4 magic value 0x20c13b0b when function passes.\\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\n    * MUST allow external calls\\n    */ \\n    function isValidSignature(\\n        bytes calldata _data, \\n        bytes calldata _signature)\\n        external \\n        returns (bytes4);\\n}\"\r\n    },\r\n    \"contracts/gnosis-safe/libraries/CreateAndAddModules.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\nimport \\\"../base/Module.sol\\\";\\n\\n\\n/// @title Create and Add Modules - Allows to create and add multiple module in one transaction.\\n/// @author Stefan George - <stefan@gnosis.pm>\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract CreateAndAddModules {\\n\\n    /// @dev Function required to compile contract. Gnosis Safe function is called instead.\\n    /// @param module Not used.\\n    function enableModule(Module module)\\n        public\\n    {\\n        revert();\\n    }\\n\\n    /// @dev Allows to create and add multiple module in one transaction.\\n    /// @param proxyFactory Module proxy factory contract.\\n    /// @param data Modules constructor payload. This is the data for each proxy factory call concatinated. (e.g. <byte_array_len_1><byte_array_data_1><byte_array_len_2><byte_array_data_2>)\\n    function createAndAddModules(address proxyFactory, bytes memory data)\\n        public\\n    {\\n        uint256 length = data.length;\\n        Module module;\\n        uint256 i = 0;\\n        while (i < length) {\\n            // solium-disable-next-line security/no-inline-assembly\\n            assembly {\\n                let createBytesLength := mload(add(0x20, add(data, i)))\\n                let createBytes := add(0x40, add(data, i))\\n\\n                let output := mload(0x40)\\n                if eq(delegatecall(gas, proxyFactory, createBytes, createBytesLength, output, 0x20), 0) { revert(0, 0) }\\n                module := and(mload(output), 0xffffffffffffffffffffffffffffffffffffffff)\\n\\n                // Data is always padded to 32 bytes\\n                i := add(i, add(0x20, mul(div(add(createBytesLength, 0x1f), 0x20), 0x20)))\\n            }\\n            this.enableModule(module);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/libraries/MultiSend.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/// @title Multi Send - Allows to batch multiple transactions into one.\\n/// @author Nick Dodson - <nick.dodson@consensys.net>\\n/// @author Gonçalo Sá - <goncalo.sa@consensys.net>\\n/// @author Stefan George - <stefan@gnosis.pm>\\ncontract MultiSend {\\n\\n    /// @dev Sends multiple transactions and reverts all if one fails.\\n    /// @param transactions Encoded transactions. Each transaction is encoded as a \\n    ///                     tuple(operation,address,uint256,bytes), where operation \\n    ///                     can be 0 for a call or 1 for a delegatecall. The bytes \\n    ///                     of all encoded transactions are concatenated to form the input.\\n    function multiSend(bytes memory transactions)\\n        public\\n    {\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            let length := mload(transactions)\\n            let i := 0x20\\n            for { } lt(i, length) { } {\\n                let operation := mload(add(transactions, i))\\n                let to := mload(add(transactions, add(i, 0x20)))\\n                let value := mload(add(transactions, add(i, 0x40)))\\n                let dataLength := mload(add(transactions, add(i, 0x80)))\\n                let data := add(transactions, add(i, 0xa0))\\n                let success := 0\\n                switch operation \\n                case 0 { success := call(gas, to, value, data, dataLength, 0, 0) }\\n                case 1 { success := delegatecall(gas, to, data, dataLength, 0, 0) }\\n                if eq(success, 0) { revert(0, 0) }\\n                i := add(i, add(0xa0, mul(div(add(dataLength, 0x1f), 0x20), 0x20)))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/modules/DailyLimitModule.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\nimport \\\"../base/Module.sol\\\";\\nimport \\\"../base/ModuleManager.sol\\\";\\nimport \\\"../base/OwnerManager.sol\\\";\\nimport \\\"../common/Enum.sol\\\";\\n\\n\\n/// @title Daily Limit Module - Allows to transfer limited amounts of ERC20 tokens and Ether without confirmations.\\n/// @author Stefan George - <stefan@gnosis.pm>\\ncontract DailyLimitModule is Module {\\n\\n    string public constant NAME = \\\"Daily Limit Module\\\";\\n    string public constant VERSION = \\\"0.1.0\\\";\\n\\n    // dailyLimits mapping maps token address to daily limit settings.\\n    mapping (address => DailyLimit) public dailyLimits;\\n\\n    struct DailyLimit {\\n        uint256 dailyLimit;\\n        uint256 spentToday;\\n        uint256 lastDay;\\n    }\\n\\n    /// @dev Setup function sets initial storage of contract.\\n    /// @param tokens List of token addresses. Ether is represented with address 0x0.\\n    /// @param _dailyLimits List of daily limits in smalles units (e.g. Wei for Ether).\\n    function setup(address[] memory tokens, uint256[] memory _dailyLimits)\\n        public\\n    {\\n        setManager();\\n        for (uint256 i = 0; i < tokens.length; i++)\\n            dailyLimits[tokens[i]].dailyLimit = _dailyLimits[i];\\n    }\\n\\n    /// @dev Allows to update the daily limit for a specified token. This can only be done via a Safe transaction.\\n    /// @param token Token contract address.\\n    /// @param dailyLimit Daily limit in smallest token unit.\\n    function changeDailyLimit(address token, uint256 dailyLimit)\\n        public\\n        authorized\\n    {\\n        dailyLimits[token].dailyLimit = dailyLimit;\\n    }\\n\\n    /// @dev Returns if Safe transaction is a valid daily limit transaction.\\n    /// @param token Address of the token that should be transfered (0 for Ether)\\n    /// @param to Address to which the tokens should be transfered\\n    /// @param amount Amount of tokens (or Ether) that should be transfered\\n    /// @return Returns if transaction can be executed.\\n    function executeDailyLimit(address token, address to, uint256 amount)\\n        public\\n    {\\n        // Only Safe owners are allowed to execute daily limit transactions.\\n        require(OwnerManager(address(manager)).isOwner(msg.sender), \\\"Method can only be called by an owner\\\");\\n        require(to != address(0), \\\"Invalid to address provided\\\");\\n        require(amount > 0, \\\"Invalid amount provided\\\");\\n        // Validate that transfer is not exceeding daily limit.\\n        require(isUnderLimit(token, amount), \\\"Daily limit has been reached\\\");\\n        dailyLimits[token].spentToday += amount;\\n        if (token == address(0)) {\\n            require(manager.execTransactionFromModule(to, amount, \\\"\\\", Enum.Operation.Call), \\\"Could not execute ether transfer\\\");\\n        } else {\\n            bytes memory data = abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", to, amount);\\n            require(manager.execTransactionFromModule(token, 0, data, Enum.Operation.Call), \\\"Could not execute token transfer\\\");\\n        }\\n    }\\n\\n    function isUnderLimit(address token, uint256 amount)\\n        internal\\n        returns (bool)\\n    {\\n        DailyLimit storage dailyLimit = dailyLimits[token];\\n        if (today() > dailyLimit.lastDay) {\\n            dailyLimit.lastDay = today();\\n            dailyLimit.spentToday = 0;\\n        }\\n        if (dailyLimit.spentToday + amount <= dailyLimit.dailyLimit && \\n            dailyLimit.spentToday + amount > dailyLimit.spentToday)\\n            return true;\\n        return false;\\n    }\\n\\n    /// @dev Returns last midnight as Unix timestamp.\\n    /// @return Unix timestamp.\\n    function today()\\n        public\\n        view\\n        returns (uint)\\n    {\\n        return now - (now % 1 days);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/modules/SocialRecoveryModule.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\nimport \\\"../base/Module.sol\\\";\\nimport \\\"../base/ModuleManager.sol\\\";\\nimport \\\"../base/OwnerManager.sol\\\";\\nimport \\\"../common/Enum.sol\\\";\\n\\n\\n/// @title Social Recovery Module - Allows to replace an owner without Safe confirmations if friends approve the replacement.\\n/// @author Stefan George - <stefan@gnosis.pm>\\ncontract SocialRecoveryModule is Module {\\n\\n    string public constant NAME = \\\"Social Recovery Module\\\";\\n    string public constant VERSION = \\\"0.1.0\\\";\\n\\n    uint256 public threshold;\\n    address[] public friends;\\n\\n    // isFriend mapping maps friend's address to friend status.\\n    mapping (address => bool) public isFriend;\\n    // isExecuted mapping maps data hash to execution status.\\n    mapping (bytes32 => bool) public isExecuted;\\n    // isConfirmed mapping maps data hash to friend's address to confirmation status.\\n    mapping (bytes32 => mapping (address => bool)) public isConfirmed;\\n\\n    modifier onlyFriend() {\\n        require(isFriend[msg.sender], \\\"Method can only be called by a friend\\\");\\n        _;\\n    }\\n\\n    /// @dev Setup function sets initial storage of contract.\\n    /// @param _friends List of friends' addresses.\\n    /// @param _threshold Required number of friends to confirm replacement.\\n    function setup(address[] memory _friends, uint256 _threshold)\\n        public\\n    {\\n        require(_threshold <= _friends.length, \\\"Threshold cannot exceed friends count\\\");\\n        require(_threshold >= 2, \\\"At least 2 friends required\\\");\\n        setManager();\\n        // Set allowed friends.\\n        for (uint256 i = 0; i < _friends.length; i++) {\\n            address friend = _friends[i];\\n            require(friend != address(0), \\\"Invalid friend address provided\\\");\\n            require(!isFriend[friend], \\\"Duplicate friend address provided\\\");\\n            isFriend[friend] = true;\\n        }\\n        friends = _friends;\\n        threshold = _threshold;\\n    }\\n\\n    /// @dev Allows a friend to confirm a Safe transaction.\\n    /// @param dataHash Safe transaction hash.\\n    function confirmTransaction(bytes32 dataHash)\\n        public\\n        onlyFriend\\n    {\\n        require(!isExecuted[dataHash], \\\"Recovery already executed\\\");\\n        isConfirmed[dataHash][msg.sender] = true;\\n    }\\n\\n    /// @dev Returns if Safe transaction is a valid owner replacement transaction.\\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\\n    /// @param oldOwner Owner address to be replaced.\\n    /// @param newOwner New owner address.\\n    /// @return Returns if transaction can be executed.\\n    function recoverAccess(address prevOwner, address oldOwner, address newOwner)\\n        public\\n        onlyFriend\\n    {\\n        bytes memory data = abi.encodeWithSignature(\\\"swapOwner(address,address,address)\\\", prevOwner, oldOwner, newOwner);\\n        bytes32 dataHash = getDataHash(data);\\n        require(!isExecuted[dataHash], \\\"Recovery already executed\\\");\\n        require(isConfirmedByRequiredFriends(dataHash), \\\"Recovery has not enough confirmations\\\");\\n        isExecuted[dataHash] = true;\\n        require(manager.execTransactionFromModule(address(manager), 0, data, Enum.Operation.Call), \\\"Could not execute recovery\\\");\\n    }\\n\\n    /// @dev Returns if Safe transaction is a valid owner replacement transaction.\\n    /// @param dataHash Data hash.\\n    /// @return Confirmation status.\\n    function isConfirmedByRequiredFriends(bytes32 dataHash)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        uint256 confirmationCount;\\n        for (uint256 i = 0; i < friends.length; i++) {\\n            if (isConfirmed[dataHash][friends[i]])\\n                confirmationCount++;\\n            if (confirmationCount == threshold)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    /// @dev Returns hash of data encoding owner replacement.\\n    /// @param data Data payload.\\n    /// @return Data hash.\\n    function getDataHash(bytes memory data)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/modules/StateChannelModule.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\nimport \\\"../base/Module.sol\\\";\\nimport \\\"../base/OwnerManager.sol\\\";\\nimport \\\"../common/SignatureDecoder.sol\\\";\\n\\n\\n/// @title Gnosis Safe State Module - A module that allows interaction with statechannels.\\n/// @author Stefan George - <stefan@gnosis.pm>\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract StateChannelModule is Module, SignatureDecoder {\\n\\n    string public constant NAME = \\\"State Channel Module\\\";\\n    string public constant VERSION = \\\"0.1.0\\\";\\n\\n    // isExecuted mapping allows to check if a transaction (by hash) was already executed.\\n    mapping (bytes32 => uint256) public isExecuted;\\n\\n    /// @dev Setup function sets manager\\n    function setup()\\n        public\\n    {\\n        setManager();\\n    }\\n\\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners.\\n    /// @param to Destination address of Safe transaction.\\n    /// @param value Ether value of Safe transaction.\\n    /// @param data Data payload of Safe transaction.\\n    /// @param operation Operation type of Safe transaction.\\n    /// @param nonce Nonce used for this Safe transaction.\\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\\n    function execTransaction(\\n        address to, \\n        uint256 value, \\n        bytes memory data, \\n        Enum.Operation operation, \\n        uint256 nonce,\\n        bytes memory signatures\\n    )\\n        public\\n    {\\n        bytes32 transactionHash = getTransactionHash(to, value, data, operation, nonce);\\n        require(isExecuted[transactionHash] == 0, \\\"Transaction already executed\\\");\\n        checkHash(transactionHash, signatures);\\n        // Mark as executed and execute transaction.\\n        isExecuted[transactionHash] = 1;\\n        require(manager.execTransactionFromModule(to, value, data, operation), \\\"Could not execute transaction\\\");\\n    }\\n\\n    function checkHash(bytes32 transactionHash, bytes memory signatures)\\n        internal\\n        view\\n    {\\n        // There cannot be an owner with address 0.\\n        address lastOwner = address(0);\\n        address currentOwner;\\n        uint256 i;\\n        uint256 threshold = OwnerManager(address(manager)).getThreshold();\\n        // Validate threshold is reached.\\n        for (i = 0; i < threshold; i++) {\\n            currentOwner = recoverKey(transactionHash, signatures, i);\\n            require(OwnerManager(address(manager)).isOwner(currentOwner), \\\"Signature not provided by owner\\\");\\n            require(currentOwner > lastOwner, \\\"Signatures are not ordered by owner address\\\");\\n            lastOwner = currentOwner;\\n        }\\n    }\\n\\n    /// @dev Returns hash to be signed by owners.\\n    /// @param to Destination address.\\n    /// @param value Ether value.\\n    /// @param data Data payload.\\n    /// @param operation Operation type.\\n    /// @param nonce Transaction nonce.\\n    /// @return Transaction hash.\\n    function getTransactionHash(\\n        address to, \\n        uint256 value, \\n        bytes memory data, \\n        Enum.Operation operation, \\n        uint256 nonce\\n    )\\n        public\\n        view\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(byte(0x19), byte(0), this, to, value, data, operation, nonce));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/modules/WhitelistModule.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\nimport \\\"../base/Module.sol\\\";\\nimport \\\"../base/ModuleManager.sol\\\";\\nimport \\\"../base/OwnerManager.sol\\\";\\nimport \\\"../common/Enum.sol\\\";\\n\\n\\n/// @title Whitelist Module - Allows to execute transactions to whitelisted addresses without confirmations.\\n/// @author Stefan George - <stefan@gnosis.pm>\\ncontract WhitelistModule is Module {\\n\\n    string public constant NAME = \\\"Whitelist Module\\\";\\n    string public constant VERSION = \\\"0.1.0\\\";\\n\\n    // isWhitelisted mapping maps destination address to boolean.\\n    mapping (address => bool) public isWhitelisted;\\n\\n    /// @dev Setup function sets initial storage of contract.\\n    /// @param accounts List of whitelisted accounts.\\n    function setup(address[] memory accounts)\\n        public\\n    {\\n        setManager();\\n        for (uint256 i = 0; i < accounts.length; i++) {\\n            address account = accounts[i];\\n            require(account != address(0), \\\"Invalid account provided\\\");\\n            isWhitelisted[account] = true;\\n        }\\n    }\\n\\n    /// @dev Allows to add destination to whitelist. This can only be done via a Safe transaction.\\n    /// @param account Destination address.\\n    function addToWhitelist(address account)\\n        public\\n        authorized\\n    {\\n        require(account != address(0), \\\"Invalid account provided\\\");\\n        require(!isWhitelisted[account], \\\"Account is already whitelisted\\\");\\n        isWhitelisted[account] = true;\\n    }\\n\\n    /// @dev Allows to remove destination from whitelist. This can only be done via a Safe transaction.\\n    /// @param account Destination address.\\n    function removeFromWhitelist(address account)\\n        public\\n        authorized\\n    {\\n        require(isWhitelisted[account], \\\"Account is not whitelisted\\\");\\n        isWhitelisted[account] = false;\\n    }\\n\\n    /// @dev Returns if Safe transaction is to a whitelisted destination.\\n    /// @param to Whitelisted destination address.\\n    /// @param value Not checked.\\n    /// @param data Not checked.\\n    /// @return Returns if transaction can be executed.\\n    function executeWhitelisted(address to, uint256 value, bytes memory data)\\n        public\\n        returns (bool)\\n    {\\n        // Only Safe owners are allowed to execute transactions to whitelisted accounts.\\n        require(OwnerManager(address(manager)).isOwner(msg.sender), \\\"Method can only be called by an owner\\\");\\n        require(isWhitelisted[to], \\\"Target account is not whitelisted\\\");\\n        require(manager.execTransactionFromModule(to, value, data, Enum.Operation.Call), \\\"Could not execute transaction\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/proxies/DelegateConstructorProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\nimport \\\"./Proxy.sol\\\";\\n\\n\\n/// @title Delegate Constructor Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract. It is possible to send along initialization data with the constructor.\\n/// @author Stefan George - <stefan@gnosis.pm>\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract DelegateConstructorProxy is Proxy {\\n\\n    /// @dev Constructor function sets address of master copy contract.\\n    /// @param _masterCopy Master copy address.\\n    /// @param initializer Data used for a delegate call to initialize the contract.\\n    constructor(address _masterCopy, bytes memory initializer) Proxy(_masterCopy)\\n        public\\n    {\\n        if (initializer.length > 0) {\\n            // solium-disable-next-line security/no-inline-assembly\\n            assembly {\\n                let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\\n                let success := delegatecall(sub(gas, 10000), masterCopy, add(initializer, 0x20), mload(initializer), 0, 0)\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize)\\n                if eq(success, 0) { revert(ptr, returndatasize) }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/proxies/Proxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\\n/// @author Stefan George - <stefan@gnosis.pm>\\ncontract Proxy {\\n\\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\\n    address internal masterCopy;\\n\\n    /// @dev Constructor function sets address of master copy contract.\\n    /// @param _masterCopy Master copy address.\\n    constructor(address _masterCopy)\\n        public\\n    {\\n        require(_masterCopy != address(0), \\\"Invalid master copy address provided\\\");\\n        masterCopy = _masterCopy;\\n    }\\n\\n    /// @dev Fallback function forwards all transactions and returns all received return data.\\n    function ()\\n        external\\n        payable\\n    {\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            let masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\\n            calldatacopy(0, 0, calldatasize())\\n            let success := delegatecall(gas, masterCopy, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            if eq(success, 0) { revert(0, returndatasize()) }\\n            return(0, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/proxies/PayingProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\nimport \\\"../common/SecuredTokenTransfer.sol\\\";\\nimport \\\"./DelegateConstructorProxy.sol\\\";\\n\\n/// @title Paying Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract. It is possible to send along initialization data with the constructor. And sends funds after creation to a specified account.\\n/// @author Stefan George - <stefan@gnosis.pm>\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract PayingProxy is DelegateConstructorProxy, SecuredTokenTransfer {\\n\\n    /// @dev Constructor function sets address of master copy contract.\\n    /// @param _masterCopy Master copy address.\\n    /// @param initializer Data used for a delegate call to initialize the contract.\\n    /// @param funder Address that should be paid for the execution of this call\\n    /// @param paymentToken Token that should be used for the payment (0 is ETH)\\n    /// @param payment Value that should be paid\\n    constructor(address _masterCopy, bytes memory initializer, address payable funder, address paymentToken, uint256 payment) \\n        DelegateConstructorProxy(_masterCopy, initializer)\\n        public\\n    {\\n        if (payment > 0) {\\n            if (paymentToken == address(0)) {\\n                 // solium-disable-next-line security/no-send\\n                require(funder.send(payment), \\\"Could not pay safe creation with ether\\\");\\n            } else {\\n                require(transferToken(paymentToken, funder, payment), \\\"Could not pay safe creation with token\\\");\\n            }\\n        } \\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gnosis-safe/proxies/ProxyFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.3;\\nimport \\\"./Proxy.sol\\\";\\n\\n\\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\\n/// @author Stefan George - <stefan@gnosis.pm>\\ncontract ProxyFactory {\\n\\n    event ProxyCreation(Proxy proxy);\\n\\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\\n    /// @param masterCopy Address of master copy.\\n    /// @param data Payload for message call sent to new proxy contract.\\n    function createProxy(address masterCopy, bytes memory data)\\n        public\\n        returns (Proxy proxy)\\n    {\\n        proxy = new Proxy(masterCopy);\\n        if (data.length > 0)\\n            // solium-disable-next-line security/no-inline-assembly\\n            assembly {\\n                if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\\n            }\\n        emit ProxyCreation(proxy);\\n    }\\n\\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\\n    function proxyRuntimeCode() public pure returns (bytes memory) {\\n        return type(Proxy).runtimeCode;\\n    }\\n\\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\\n    function proxyCreationCode() public pure returns (bytes memory) {\\n        return type(Proxy).creationCode;\\n    }\\n\\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\\n    /// @param _mastercopy Address of master copy.\\n    /// @param initializer Payload for message call sent to new proxy contract.\\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\\n    function createProxyWithNonce(address _mastercopy, bytes memory initializer, uint256 saltNonce)\\n        public\\n        returns (Proxy proxy)\\n    {\\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\\n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint256(_mastercopy));\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\\n        }\\n        if (initializer.length > 0)\\n            // solium-disable-next-line security/no-inline-assembly\\n            assembly {\\n                if eq(call(gas, proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) { revert(0,0) }\\n            }\\n        emit ProxyCreation(proxy);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GuildBank.sol\": {\r\n      \"content\": \"pragma solidity 0.5.3;\\n\\nimport \\\"./oz/Ownable.sol\\\";\\nimport \\\"./oz/IERC20.sol\\\";\\nimport \\\"./oz/SafeMath.sol\\\";\\n\\ncontract GuildBank is Ownable {\\n    using SafeMath for uint256;\\n\\n    IERC20 public approvedToken; // approved token contract reference\\n\\n    event Withdrawal(address indexed receiver, uint256 amount);\\n\\n    constructor(address approvedTokenAddress) public {\\n        approvedToken = IERC20(approvedTokenAddress);\\n    }\\n\\n    function withdraw(address receiver, uint256 shares, uint256 totalShares) public onlyOwner returns (bool) {\\n        uint256 amount = approvedToken.balanceOf(address(this)).mul(shares).div(totalShares);\\n        emit Withdrawal(receiver, amount);\\n        return approvedToken.transfer(receiver, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oz/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"\r\n    },\r\n    \"contracts/oz/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/oz/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two unsigned integers, reverts on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n     * reverts when dividing by zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/Moloch.sol\": {\r\n      \"content\": \"// Goals\\n// - Defensibility -> Kick out malicious members via forceRagequit\\n// - Separation of Wealth and Power -> voting / loot tokens - grant pool can't be claimed (controlled by separate contract?)\\n// - batch proposals -> 1 month between proposal batches, 2 week voting period, 2 week grace period\\n// - better spam protection -> exponential increase in deposit for same member / option to claim deposit\\n// - replacing members?\\n//   - hasn't been discussed\\n// - accountability to stakeholders\\n//   - some kind of siganlling\\n\\n\\npragma solidity 0.5.3;\\n\\nimport \\\"./oz/SafeMath.sol\\\";\\nimport \\\"./oz/IERC20.sol\\\";\\nimport \\\"./GuildBank.sol\\\";\\n\\ncontract Moloch {\\n    using SafeMath for uint256;\\n\\n    /***************\\n    GLOBAL CONSTANTS\\n    ***************/\\n  uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\\n    uint256 public votingPeriodLength; // default = 35 periods (7 days)\\n    uint256 public gracePeriodLength; // default = 35 periods (7 days)\\n    uint256 public abortWindow; // default = 5 periods (1 day)\\n    uint256 public proposalDeposit; // default = 10 ETH (~$1,000 worth of ETH at contract deployment)\\n    uint256 public dilutionBound; // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit\\n    uint256 public processingReward; // default = 0.1 - amount of ETH to give to whoever processes a proposal\\n    uint256 public summoningTime; // needed to determine the current period\\n\\n    IERC20 public approvedToken; // approved token contract reference; default = wETH\\n    GuildBank public guildBank; // guild bank contract reference\\n\\n    // HARD-CODED LIMITS\\n    // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations\\n    // with periods or shares, yet big enough to not limit reasonable use cases.\\n    uint256 constant MAX_VOTING_PERIOD_LENGTH = 10**18; // maximum length of voting period\\n    uint256 constant MAX_GRACE_PERIOD_LENGTH = 10**18; // maximum length of grace period\\n    uint256 constant MAX_DILUTION_BOUND = 10**18; // maximum dilution bound\\n    uint256 constant MAX_NUMBER_OF_SHARES = 10**18; // maximum number of shares that can be minted\\n\\n    /***************\\n    EVENTS\\n    ***************/\\n    event SubmitProposal(uint256 proposalIndex, address indexed delegateKey, address indexed memberAddress, address indexed applicant, uint256 tokenTribute, uint256 sharesRequested);\\n    event SubmitVote(uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\\n    event ProcessProposal(uint256 indexed proposalIndex, address indexed applicant, address indexed memberAddress, uint256 tokenTribute, uint256 sharesRequested, bool didPass);\\n    event Ragequit(address indexed memberAddress, uint256 sharesToBurn);\\n    event Abort(uint256 indexed proposalIndex, address applicantAddress);\\n    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\\n    event SummonComplete(address indexed summoner, uint256 shares);\\n\\n    /******************\\n    INTERNAL ACCOUNTING\\n    ******************/\\n    uint256 public totalShares = 0; // total shares across all members\\n    uint256 public totalSharesRequested = 0; // total shares that have been requested in unprocessed proposals\\n\\n    enum Vote {\\n        Null, // default value, counted as abstention\\n        Yes,\\n        No\\n    }\\n\\n    struct Member {\\n        address delegateKey; // the key responsible for submitting proposals and voting - defaults to member address unless updated\\n        uint256 shares; // the # of shares assigned to this member\\n        bool exists; // always true once a member has been created\\n        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\\n    }\\n\\n    struct Proposal {\\n        address proposer; // the member who submitted the proposal\\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals\\n        uint256 sharesRequested; // the # of shares the applicant is requesting\\n        uint256 startingPeriod; // the period in which voting can start for this proposal\\n        uint256 yesVotes; // the total number of YES votes for this proposal\\n        uint256 noVotes; // the total number of NO votes for this proposal\\n        bool processed; // true only if the proposal has been processed\\n        bool didPass; // true only if the proposal passed\\n        bool aborted; // true only if applicant calls \\\"abort\\\" fn before end of voting period\\n        uint256 tokenTribute; // amount of tokens offered as tribute\\n        string details; // proposal details - could be IPFS hash, plaintext, or JSON\\n        uint256 maxTotalSharesAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\\n        mapping (address => Vote) votesByMember; // the votes on this proposal by each member\\n    }\\n\\n    mapping (address => Member) public members;\\n    mapping (address => address) public memberAddressByDelegateKey;\\n    Proposal[] public proposalQueue;\\n\\n    /********\\n    MODIFIERS\\n    ********/\\n    modifier onlyMember {\\n        require(members[msg.sender].shares > 0, \\\"Moloch::onlyMember - not a member\\\");\\n        _;\\n    }\\n\\n    modifier onlyDelegate {\\n        require(members[memberAddressByDelegateKey[msg.sender]].shares > 0, \\\"Moloch::onlyDelegate - not a delegate\\\");\\n        _;\\n    }\\n\\n    /********\\n    FUNCTIONS\\n    ********/\\n    constructor(\\n        address summoner,\\n        address _approvedToken,\\n        uint256 _periodDuration,\\n        uint256 _votingPeriodLength,\\n        uint256 _gracePeriodLength,\\n        uint256 _abortWindow,\\n        uint256 _proposalDeposit,\\n        uint256 _dilutionBound,\\n        uint256 _processingReward\\n    ) public {\\n        require(summoner != address(0), \\\"Moloch::constructor - summoner cannot be 0\\\");\\n        require(_approvedToken != address(0), \\\"Moloch::constructor - _approvedToken cannot be 0\\\");\\n        require(_periodDuration > 0, \\\"Moloch::constructor - _periodDuration cannot be 0\\\");\\n        require(_votingPeriodLength > 0, \\\"Moloch::constructor - _votingPeriodLength cannot be 0\\\");\\n        require(_votingPeriodLength <= MAX_VOTING_PERIOD_LENGTH, \\\"Moloch::constructor - _votingPeriodLength exceeds limit\\\");\\n        require(_gracePeriodLength <= MAX_GRACE_PERIOD_LENGTH, \\\"Moloch::constructor - _gracePeriodLength exceeds limit\\\");\\n        require(_abortWindow > 0, \\\"Moloch::constructor - _abortWindow cannot be 0\\\");\\n        require(_abortWindow <= _votingPeriodLength, \\\"Moloch::constructor - _abortWindow must be smaller than or equal to _votingPeriodLength\\\");\\n        require(_dilutionBound > 0, \\\"Moloch::constructor - _dilutionBound cannot be 0\\\");\\n        require(_dilutionBound <= MAX_DILUTION_BOUND, \\\"Moloch::constructor - _dilutionBound exceeds limit\\\");\\n        require(_proposalDeposit >= _processingReward, \\\"Moloch::constructor - _proposalDeposit cannot be smaller than _processingReward\\\");\\n\\n        approvedToken = IERC20(_approvedToken);\\n\\n        guildBank = new GuildBank(_approvedToken);\\n\\n        periodDuration = _periodDuration;\\n        votingPeriodLength = _votingPeriodLength;\\n        gracePeriodLength = _gracePeriodLength;\\n        abortWindow = _abortWindow;\\n        proposalDeposit = _proposalDeposit;\\n        dilutionBound = _dilutionBound;\\n        processingReward = _processingReward;\\n\\n        summoningTime = now;\\n\\n        members[summoner] = Member(summoner, 1, true, 0);\\n        memberAddressByDelegateKey[summoner] = summoner;\\n        totalShares = 1;\\n\\n        emit SummonComplete(summoner, 1);\\n    }\\n\\n    /*****************\\n    PROPOSAL FUNCTIONS\\n    *****************/\\n\\n    function submitProposal(\\n        address applicant,\\n        uint256 tokenTribute,\\n        uint256 sharesRequested,\\n        string memory details\\n    )\\n        public\\n        onlyDelegate\\n    {\\n        require(applicant != address(0), \\\"Moloch::submitProposal - applicant cannot be 0\\\");\\n\\n        // Make sure we won't run into overflows when doing calculations with shares.\\n        // Note that totalShares + totalSharesRequested + sharesRequested is an upper bound\\n        // on the number of shares that can exist until this proposal has been processed.\\n        require(totalShares.add(totalSharesRequested).add(sharesRequested) <= MAX_NUMBER_OF_SHARES, \\\"Moloch::submitProposal - too many shares requested\\\");\\n\\n        totalSharesRequested = totalSharesRequested.add(sharesRequested);\\n\\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\\n\\n        // collect proposal deposit from proposer and store it in the Moloch until the proposal is processed\\n        require(approvedToken.transferFrom(msg.sender, address(this), proposalDeposit), \\\"Moloch::submitProposal - proposal deposit token transfer failed\\\");\\n\\n        // collect tribute from applicant and store it in the Moloch until the proposal is processed\\n        require(approvedToken.transferFrom(applicant, address(this), tokenTribute), \\\"Moloch::submitProposal - tribute token transfer failed\\\");\\n\\n        // compute startingPeriod for proposal\\n        uint256 startingPeriod = max(\\n            getCurrentPeriod(),\\n            proposalQueue.length == 0 ? 0 : proposalQueue[proposalQueue.length.sub(1)].startingPeriod\\n        ).add(1);\\n\\n        // create proposal ...\\n        Proposal memory proposal = Proposal({\\n            proposer: memberAddress,\\n            applicant: applicant,\\n            sharesRequested: sharesRequested,\\n            startingPeriod: startingPeriod,\\n            yesVotes: 0,\\n            noVotes: 0,\\n            processed: false,\\n            didPass: false,\\n            aborted: false,\\n            tokenTribute: tokenTribute,\\n            details: details,\\n            maxTotalSharesAtYesVote: 0\\n        });\\n\\n        // ... and append it to the queue\\n        proposalQueue.push(proposal);\\n\\n        uint256 proposalIndex = proposalQueue.length.sub(1);\\n        emit SubmitProposal(proposalIndex, msg.sender, memberAddress, applicant, tokenTribute, sharesRequested);\\n    }\\n\\n    function submitVote(uint256 proposalIndex, uint8 uintVote) public onlyDelegate {\\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\\n        Member storage member = members[memberAddress];\\n\\n        require(proposalIndex < proposalQueue.length, \\\"Moloch::submitVote - proposal does not exist\\\");\\n        Proposal storage proposal = proposalQueue[proposalIndex];\\n\\n        require(uintVote < 3, \\\"Moloch::submitVote - uintVote must be less than 3\\\");\\n        Vote vote = Vote(uintVote);\\n\\n        require(getCurrentPeriod() >= proposal.startingPeriod, \\\"Moloch::submitVote - voting period has not started\\\");\\n        require(!hasVotingPeriodExpired(proposal.startingPeriod), \\\"Moloch::submitVote - proposal voting period has expired\\\");\\n        require(proposal.votesByMember[memberAddress] == Vote.Null, \\\"Moloch::submitVote - member has already voted on this proposal\\\");\\n        require(vote == Vote.Yes || vote == Vote.No, \\\"Moloch::submitVote - vote must be either Yes or No\\\");\\n        require(!proposal.aborted, \\\"Moloch::submitVote - proposal has been aborted\\\");\\n\\n        // store vote\\n        proposal.votesByMember[memberAddress] = vote;\\n\\n        // count vote\\n        if (vote == Vote.Yes) {\\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\\n\\n            // set highest index (latest) yes vote - must be processed for member to ragequit\\n            if (proposalIndex > member.highestIndexYesVote) {\\n                member.highestIndexYesVote = proposalIndex;\\n            }\\n\\n            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\\n            if (totalShares > proposal.maxTotalSharesAtYesVote) {\\n                proposal.maxTotalSharesAtYesVote = totalShares;\\n            }\\n\\n        } else if (vote == Vote.No) {\\n            proposal.noVotes = proposal.noVotes.add(member.shares);\\n        }\\n\\n        emit SubmitVote(proposalIndex, msg.sender, memberAddress, uintVote);\\n    }\\n\\n    function processProposal(uint256 proposalIndex) public {\\n        require(proposalIndex < proposalQueue.length, \\\"Moloch::processProposal - proposal does not exist\\\");\\n        Proposal storage proposal = proposalQueue[proposalIndex];\\n\\n        require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \\\"Moloch::processProposal - proposal is not ready to be processed\\\");\\n        require(proposal.processed == false, \\\"Moloch::processProposal - proposal has already been processed\\\");\\n        require(proposalIndex == 0 || proposalQueue[proposalIndex.sub(1)].processed, \\\"Moloch::processProposal - previous proposal must be processed\\\");\\n\\n        proposal.processed = true;\\n        totalSharesRequested = totalSharesRequested.sub(proposal.sharesRequested);\\n\\n        bool didPass = proposal.yesVotes > proposal.noVotes;\\n\\n        // Make the proposal fail if the dilutionBound is exceeded\\n        if (totalShares.mul(dilutionBound) < proposal.maxTotalSharesAtYesVote) {\\n            didPass = false;\\n        }\\n\\n        // PROPOSAL PASSED\\n        if (didPass && !proposal.aborted) {\\n\\n            proposal.didPass = true;\\n\\n            // if the applicant is already a member, add to their existing shares\\n            if (members[proposal.applicant].exists) {\\n                members[proposal.applicant].shares = members[proposal.applicant].shares.add(proposal.sharesRequested);\\n\\n            // the applicant is a new member, create a new record for them\\n            } else {\\n                // if the applicant address is already taken by a member's delegateKey, reset it to their member address\\n                if (members[memberAddressByDelegateKey[proposal.applicant]].exists) {\\n                    address memberToOverride = memberAddressByDelegateKey[proposal.applicant];\\n                    memberAddressByDelegateKey[memberToOverride] = memberToOverride;\\n                    members[memberToOverride].delegateKey = memberToOverride;\\n                }\\n\\n                // use applicant address as delegateKey by default\\n                members[proposal.applicant] = Member(proposal.applicant, proposal.sharesRequested, true, 0);\\n                memberAddressByDelegateKey[proposal.applicant] = proposal.applicant;\\n            }\\n\\n            // mint new shares\\n            totalShares = totalShares.add(proposal.sharesRequested);\\n\\n            // transfer tokens to guild bank\\n            require(\\n                approvedToken.transfer(address(guildBank), proposal.tokenTribute),\\n                \\\"Moloch::processProposal - token transfer to guild bank failed\\\"\\n            );\\n\\n        // PROPOSAL FAILED OR ABORTED\\n        } else {\\n            // return all tokens to the applicant\\n            require(\\n                approvedToken.transfer(proposal.applicant, proposal.tokenTribute),\\n                \\\"Moloch::processProposal - failing vote token transfer failed\\\"\\n            );\\n        }\\n\\n        // send msg.sender the processingReward\\n        require(\\n            approvedToken.transfer(msg.sender, processingReward),\\n            \\\"Moloch::processProposal - failed to send processing reward to msg.sender\\\"\\n        );\\n\\n        // return deposit to proposer (subtract processing reward)\\n        require(\\n            approvedToken.transfer(proposal.proposer, proposalDeposit.sub(processingReward)),\\n            \\\"Moloch::processProposal - failed to return proposal deposit to proposer\\\"\\n        );\\n\\n        emit ProcessProposal(\\n            proposalIndex,\\n            proposal.applicant,\\n            proposal.proposer,\\n            proposal.tokenTribute,\\n            proposal.sharesRequested,\\n            didPass\\n        );\\n    }\\n\\n    function ragequit(uint256 sharesToBurn) public onlyMember {\\n        uint256 initialTotalShares = totalShares;\\n\\n        Member storage member = members[msg.sender];\\n\\n        require(member.shares >= sharesToBurn, \\\"Moloch::ragequit - insufficient shares\\\");\\n\\n        require(canRagequit(member.highestIndexYesVote), \\\"Moloch::ragequit - cant ragequit until highest index proposal member voted YES on is processed\\\");\\n\\n        // burn shares\\n        member.shares = member.shares.sub(sharesToBurn);\\n        totalShares = totalShares.sub(sharesToBurn);\\n\\n        // instruct guildBank to transfer fair share of tokens to the ragequitter\\n        require(\\n            guildBank.withdraw(msg.sender, sharesToBurn, initialTotalShares),\\n            \\\"Moloch::ragequit - withdrawal of tokens from guildBank failed\\\"\\n        );\\n\\n        emit Ragequit(msg.sender, sharesToBurn);\\n    }\\n\\n    function abort(uint256 proposalIndex) public {\\n        require(proposalIndex < proposalQueue.length, \\\"Moloch::abort - proposal does not exist\\\");\\n        Proposal storage proposal = proposalQueue[proposalIndex];\\n\\n        require(msg.sender == proposal.applicant, \\\"Moloch::abort - msg.sender must be applicant\\\");\\n        require(getCurrentPeriod() < proposal.startingPeriod.add(abortWindow), \\\"Moloch::abort - abort window must not have passed\\\");\\n        require(!proposal.aborted, \\\"Moloch::abort - proposal must not have already been aborted\\\");\\n\\n        uint256 tokensToAbort = proposal.tokenTribute;\\n        proposal.tokenTribute = 0;\\n        proposal.aborted = true;\\n\\n        // return all tokens to the applicant\\n        require(\\n            approvedToken.transfer(proposal.applicant, tokensToAbort),\\n            \\\"Moloch::processProposal - failed to return tribute to applicant\\\"\\n        );\\n\\n        emit Abort(proposalIndex, msg.sender);\\n    }\\n\\n    function updateDelegateKey(address newDelegateKey) public onlyMember {\\n        require(newDelegateKey != address(0), \\\"Moloch::updateDelegateKey - newDelegateKey cannot be 0\\\");\\n\\n        // skip checks if member is setting the delegate key to their member address\\n        if (newDelegateKey != msg.sender) {\\n            require(!members[newDelegateKey].exists, \\\"Moloch::updateDelegateKey - cant overwrite existing members\\\");\\n            require(!members[memberAddressByDelegateKey[newDelegateKey]].exists, \\\"Moloch::updateDelegateKey - cant overwrite existing delegate keys\\\");\\n        }\\n\\n        Member storage member = members[msg.sender];\\n        memberAddressByDelegateKey[member.delegateKey] = address(0);\\n        memberAddressByDelegateKey[newDelegateKey] = msg.sender;\\n        member.delegateKey = newDelegateKey;\\n\\n        emit UpdateDelegateKey(msg.sender, newDelegateKey);\\n    }\\n\\n    /***************\\n    GETTER FUNCTIONS\\n    ***************/\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x >= y ? x : y;\\n    }\\n\\n    function getCurrentPeriod() public view returns (uint256) {\\n        return now.sub(summoningTime).div(periodDuration);\\n    }\\n\\n    function getProposalQueueLength() public view returns (uint256) {\\n        return proposalQueue.length;\\n    }\\n\\n    // can only ragequit if the latest proposal you voted YES on has been processed\\n    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) {\\n        require(highestIndexYesVote < proposalQueue.length, \\\"Moloch::canRagequit - proposal does not exist\\\");\\n        return proposalQueue[highestIndexYesVote].processed;\\n    }\\n\\n    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) {\\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\\n    }\\n\\n    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) public view returns (Vote) {\\n        require(members[memberAddress].exists, \\\"Moloch::getMemberProposalVote - member doesn't exist\\\");\\n        require(proposalIndex < proposalQueue.length, \\\"Moloch::getMemberProposalVote - proposal doesn't exist\\\");\\n        return proposalQueue[proposalIndex].votesByMember[memberAddress];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oz/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\n * Originally based on code by FirstBlood:\\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n *\\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\\n * compliant implementations may not do it.\\n */\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev Total number of tokens in existence\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param owner The address to query the balance of.\\n     * @return An uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOf(address owner) public view returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param owner address The address which owns the funds.\\n     * @param spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Transfer token for a specified address\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one address to another.\\n     * Note that while this function emits an Approval event, this is not required as per the specification,\\n     * and other compliant implementations may not emit the event.\\n     * @param from address The address which you want to send tokens from\\n     * @param to address The address which you want to transfer to\\n     * @param value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        _transfer(from, to, value);\\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed_[_spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when allowed_[_spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer token for a specified addresses\\n     * @param from The address to transfer from.\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0));\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that mints an amount of the token and assigns it to\\n     * an account. This encapsulates the modification of balances such that the\\n     * proper events are emitted.\\n     * @param account The account that will receive the created tokens.\\n     * @param value The amount that will be created.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.add(value);\\n        _balances[account] = _balances[account].add(value);\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account.\\n     * @param account The account whose tokens will be burnt.\\n     * @param value The amount that will be burnt.\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Approve an address to spend another addresses' tokens.\\n     * @param owner The address that owns the tokens.\\n     * @param spender The address that will spend the tokens.\\n     * @param value The number of tokens that can be spent.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(spender != address(0));\\n        require(owner != address(0));\\n\\n        _allowed[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account, deducting from the sender's allowance for said account. Uses the\\n     * internal burn function.\\n     * Emits an Approval event (reflecting the reduced allowance).\\n     * @param account The account whose tokens will be burnt.\\n     * @param value The amount that will be burnt.\\n     */\\n    function _burnFrom(address account, uint256 value) internal {\\n        _burn(account, value);\\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Pool.sol\": {\r\n      \"content\": \"// Pool.sol\\n// - mints a pool share when someone donates tokens\\n// - syncs with Moloch proposal queue to mint shares for grantees\\n// - allows donors to withdraw tokens at any time\\n\\npragma solidity 0.5.3;\\n\\nimport \\\"./Moloch.sol\\\";\\nimport \\\"./oz/SafeMath.sol\\\";\\nimport \\\"./oz/IERC20.sol\\\";\\n\\ncontract MolochPool {\\n    using SafeMath for uint256;\\n\\n    event Sync (\\n        uint256 currentProposalIndex\\n    );\\n\\n    event Deposit (\\n        uint256 tokenAmount,\\n        address donor\\n    );\\n\\n    event Withdraw (\\n        uint256 sharesToBurn,\\n        address donor\\n    );\\n\\n    event KeeperWithdraw (\\n        uint256 sharesToBurn,\\n        address donor,\\n        address keeper\\n    );\\n\\n    event AddKeepers (\\n        address[] addedKeepers\\n    );\\n\\n    event RemoveKeepers (\\n        address[] removedKeepers\\n    );\\n\\n    event SharesMinted (\\n        uint256 sharesToMint,\\n        address recipient,\\n        uint256 totalPoolShares\\n    );\\n\\n    event SharesBurned (\\n        uint256 sharesToBurn,\\n        address recipient,\\n        uint256 totalPoolShares\\n    );\\n\\n    uint256 public totalPoolShares = 0; // the total shares outstanding of the pool\\n    uint256 public currentProposalIndex = 0; // the moloch proposal index that this pool has been synced to\\n\\n    Moloch public moloch; // moloch contract reference\\n    IERC20 public approvedToken; // approved token contract reference (copied from moloch contract)\\n\\n    bool locked; // prevent re-entrancy\\n\\n    uint256 constant MAX_NUMBER_OF_SHARES = 10**30; // maximum number of shares that can be minted\\n\\n    struct Donor {\\n        uint256 shares;\\n        mapping (address => bool) keepers;\\n    }\\n\\n    // the amount of shares each pool shareholder has\\n    mapping (address => Donor) public donors;\\n\\n    modifier active {\\n        require(totalPoolShares > 0, \\\"MolochPool: Not active\\\");\\n        _;\\n    }\\n\\n    modifier noReentrancy() {\\n        require(!locked, \\\"MolochPool: Reentrant call\\\");\\n        locked = true;\\n        _;\\n        locked = false;\\n    }\\n\\n    constructor(address _moloch) public {\\n        moloch = Moloch(_moloch);\\n        approvedToken = IERC20(moloch.approvedToken());\\n    }\\n\\n    function activate(uint256 initialTokens, uint256 initialPoolShares) public noReentrancy {\\n        require(totalPoolShares == 0, \\\"MolochPool: Already active\\\");\\n\\n        require(\\n            approvedToken.transferFrom(msg.sender, address(this), initialTokens),\\n            \\\"MolochPool: Initial tokens transfer failed\\\"\\n        );\\n        _mintSharesForAddress(initialPoolShares, msg.sender);\\n    }\\n\\n    // updates Pool state based on Moloch proposal queue\\n    // - we only want to mint shares for grants, which are 0 tribute\\n    // - mints pool shares to applicants based on sharesRequested / maxTotalSharesAtYesVote\\n    // - use maxTotalSharesAtYesVote because:\\n    //   - cant read shares at the time of proposal processing (womp womp)\\n    //   - should be close enough if grant shares are small relative to total shares, which they should be\\n    //   - protects pool contributors if many Moloch members ragequit before the proposal is processed by reducing follow on funding\\n    //   - e.g. if 50% of Moloch shares ragequit after someone voted yes, the grant proposal would get 50% less follow-on from the pool\\n    function sync(uint256 toIndex) public active noReentrancy {\\n        require(\\n            toIndex <= moloch.getProposalQueueLength(),\\n            \\\"MolochPool: Proposal index too high\\\"\\n        );\\n\\n        // declare proposal params\\n        address applicant;\\n        uint256 sharesRequested;\\n        bool processed;\\n        bool didPass;\\n        bool aborted;\\n        uint256 tokenTribute;\\n        uint256 maxTotalSharesAtYesVote;\\n\\n        uint256 i = currentProposalIndex;\\n\\n        while (i < toIndex) {\\n\\n            (, applicant, sharesRequested, , , , processed, didPass, aborted, tokenTribute, , maxTotalSharesAtYesVote) = moloch.proposalQueue(i);\\n\\n            if (!processed) { break; }\\n\\n            // passing grant proposal, mint pool shares proportionally on behalf of the applicant\\n            if (!aborted && didPass && tokenTribute == 0 && sharesRequested > 0) {\\n                // This can't revert:\\n                //   1. maxTotalSharesAtYesVote > 0, otherwise nobody could have voted.\\n                //   2. sharesRequested is <= 10**18 (see Moloch.sol:172), and\\n                //      totalPoolShares <= 10**30, so multiplying them is <= 10**48 and < 2**160\\n                uint256 sharesToMint = totalPoolShares.mul(sharesRequested).div(maxTotalSharesAtYesVote); // for a passing proposal, maxTotalSharesAtYesVote is > 0\\n                _mintSharesForAddress(sharesToMint, applicant);\\n            }\\n\\n            i++;\\n        }\\n\\n        currentProposalIndex = i;\\n\\n        emit Sync(currentProposalIndex);\\n    }\\n\\n    // add tokens to the pool, mint new shares proportionally\\n    function deposit(uint256 tokenAmount) public active noReentrancy {\\n\\n        uint256 sharesToMint = totalPoolShares.mul(tokenAmount).div(approvedToken.balanceOf(address(this)));\\n\\n        require(\\n            approvedToken.transferFrom(msg.sender, address(this), tokenAmount),\\n            \\\"MolochPool: Deposit transfer failed\\\"\\n        );\\n\\n        _mintSharesForAddress(sharesToMint, msg.sender);\\n\\n        emit Deposit(\\n            tokenAmount,\\n            msg.sender\\n        );\\n    }\\n\\n    // burn shares to proportionally withdraw tokens in pool\\n    function withdraw(uint256 sharesToBurn) public active noReentrancy {\\n        _withdraw(msg.sender, sharesToBurn);\\n\\n        emit Withdraw(\\n            sharesToBurn,\\n            msg.sender\\n        );\\n    }\\n\\n    // keeper burns shares to withdraw on behalf of the donor\\n    function keeperWithdraw(uint256 sharesToBurn, address recipient) public active noReentrancy {\\n        require(\\n            donors[recipient].keepers[msg.sender],\\n            \\\"MolochPool: Sender is not a keeper\\\"\\n        );\\n\\n        _withdraw(recipient, sharesToBurn);\\n\\n        emit KeeperWithdraw(\\n            sharesToBurn,\\n            recipient,\\n            msg.sender\\n        );\\n    }\\n\\n    function addKeepers(address[] calldata newKeepers) external active noReentrancy {\\n        Donor storage donor = donors[msg.sender];\\n\\n        for (uint256 i = 0; i < newKeepers.length; i++) {\\n            donor.keepers[newKeepers[i]] = true;\\n        }\\n\\n        emit AddKeepers(newKeepers);\\n    }\\n\\n    function removeKeepers(address[] calldata keepersToRemove) external active noReentrancy {\\n        Donor storage donor = donors[msg.sender];\\n\\n        for (uint256 i = 0; i < keepersToRemove.length; i++) {\\n            donor.keepers[keepersToRemove[i]] = false;\\n        }\\n\\n        emit RemoveKeepers(keepersToRemove);\\n    }\\n\\n    function _mintSharesForAddress(uint256 sharesToMint, address recipient) internal {\\n        totalPoolShares = totalPoolShares.add(sharesToMint);\\n        donors[recipient].shares = donors[recipient].shares.add(sharesToMint);\\n\\n        require(\\n            totalPoolShares <= MAX_NUMBER_OF_SHARES,\\n            \\\"MolochPool: Max number of shares exceeded\\\"\\n        );\\n\\n        emit SharesMinted(\\n            sharesToMint,\\n            recipient,\\n            totalPoolShares\\n        );\\n    }\\n\\n    function _withdraw(address recipient, uint256 sharesToBurn) internal {\\n        Donor storage donor = donors[recipient];\\n\\n        require(\\n            donor.shares >= sharesToBurn,\\n            \\\"MolochPool: Not enough shares to burn\\\"\\n        );\\n\\n        uint256 tokensToWithdraw = approvedToken.balanceOf(address(this)).mul(sharesToBurn).div(totalPoolShares);\\n\\n        totalPoolShares = totalPoolShares.sub(sharesToBurn);\\n        donor.shares = donor.shares.sub(sharesToBurn);\\n\\n        require(\\n            approvedToken.transfer(recipient, tokensToWithdraw),\\n            \\\"MolochPool: Withdrawal transfer failed\\\"\\n        );\\n\\n        emit SharesBurned(\\n            sharesToBurn,\\n            recipient,\\n            totalPoolShares\\n        );\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Token.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"./oz/ERC20.sol\\\";\\n\\ncontract Token is ERC20 {\\n  constructor(uint256 supply) public {\\n    _mint(msg.sender, supply);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"byzantium\",\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"sharesToBurn\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newKeepers\",\"type\":\"address[]\"}],\"name\":\"addKeepers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentProposalIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"moloch\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPoolShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"initialTokens\",\"type\":\"uint256\"},{\"name\":\"initialPoolShares\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"keeperWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toIndex\",\"type\":\"uint256\"}],\"name\":\"sync\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approvedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"donors\",\"outputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"keepersToRemove\",\"type\":\"address[]\"}],\"name\":\"removeKeepers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_moloch\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"currentProposalIndex\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"donor\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"donor\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"donor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"keeper\",\"type\":\"address\"}],\"name\":\"KeeperWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addedKeepers\",\"type\":\"address[]\"}],\"name\":\"AddKeepers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"removedKeepers\",\"type\":\"address[]\"}],\"name\":\"RemoveKeepers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sharesToMint\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalPoolShares\",\"type\":\"uint256\"}],\"name\":\"SharesMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalPoolShares\",\"type\":\"uint256\"}],\"name\":\"SharesBurned\",\"type\":\"event\"}]","ContractName":"MolochPool","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000001fd169a4f5c59acf79d0fd5d91d1201ef1bce9f1","Library":"","SwarmSource":"bzzr://e5189c953a0b87d6e0f0c12f5b07b96bc3bb37dcceba084b7a6038304619a22b"}]}