{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\nlibrary SafeERC20Detailed {\n\n    function safeDecimals(address token) internal returns (uint256 decimals) {\n\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSignature(\"decimals()\"));\n\n        if (!success) {\n            (success, data) = address(token).call(abi.encodeWithSignature(\"Decimals()\"));\n        }\n\n        if (!success) {\n            (success, data) = address(token).call(abi.encodeWithSignature(\"DECIMALS()\"));\n        }\n\n        if (!success) {\n            return 18;\n        }\n\n        assembly {\n            decimals := mload(add(data, 32))\n        }\n    }\n\n    function safeSymbol(address token) internal returns(bytes32 symbol) {\n\n        (bool success, bytes memory data) = token.call(abi.encodeWithSignature(\"symbol()\"));\n\n        if (!success) {\n            (success, data) = token.call(abi.encodeWithSignature(\"Symbol()\"));\n        }\n\n        if (!success) {\n            (success, data) = token.call(abi.encodeWithSignature(\"SYMBOL()\"));\n        }\n\n        if (!success) {\n            return 0;\n        }\n\n        uint256 dataLength = data.length;\n        assembly {\n            symbol := mload(add(data, dataLength))\n        }\n    }\n}\n\n\n\ncontract Approved {\n\n    using SafeERC20Detailed for address;\n\n    function allowances(\n        address source,\n        address[] calldata tokens,\n        address[] calldata spenders\n    )\n        external\n        returns(\n            uint256[] memory results,\n            uint256[] memory decimals,\n            bytes32[] memory symbols\n        )\n    {\n        require(tokens.length == spenders.length, \"Invalid argument array lengths\");\n\n        results = new uint256[](tokens.length);\n        decimals = new uint256[](tokens.length);\n        symbols = new bytes32[](tokens.length);\n\n        for (uint i = 0; i < tokens.length; i++) {\n\n            results[i] = IERC20(tokens[i]).allowance(source, spenders[i]);\n            decimals[i] = tokens[i].safeDecimals();\n            symbols[i] = tokens[i].safeSymbol();\n        }\n    }\n}\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"source\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"spenders\",\"type\":\"address[]\"}],\"name\":\"allowances\",\"outputs\":[{\"name\":\"results\",\"type\":\"uint256[]\"},{\"name\":\"decimals\",\"type\":\"uint256[]\"},{\"name\":\"symbols\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Approved","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://150e3ff16d4b35b9f5174291e93fae3511ee9ef6ba9f48ed796b3a7c88fa94ed"}]}