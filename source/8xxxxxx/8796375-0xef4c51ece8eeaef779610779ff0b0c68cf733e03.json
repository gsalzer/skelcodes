{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n  address public manager;\r\n  address public ownerWallet;\r\n\r\n  constructor() public {\r\n    owner = 0x371A6671c799a6F25c17368eB81A32fA98C967E2;\r\n    manager = 0x371A6671c799a6F25c17368eB81A32fA98C967E2;\r\n    ownerWallet = 0x371A6671c799a6F25c17368eB81A32fA98C967E2;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"only for owner\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwnerOrManager() {\r\n     require((msg.sender == owner)||(msg.sender == manager), \"only for owner or manager\");\r\n      _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    owner = newOwner;\r\n  }\r\n\r\n  function setManager(address _manager) public onlyOwnerOrManager {\r\n      manager = _manager;\r\n  }\r\n}\r\n\r\ncontract CryptoLights is Ownable {\r\n\r\n    event rLE(address indexed _u, address indexed _r, uint _t);\r\n    event bLE(address indexed _u, uint _l, uint _t);\r\n    event gME(address indexed _u, address indexed _r, uint _l, uint _t);\r\n    event lME(address indexed _u, address indexed _r, uint _l, uint _t);\r\n    event bRE(address indexed _u, uint _l, uint _t);\r\n    event lRE(address indexed _u, uint _l,uint _t);\r\n    event dE(address indexed _u,uint _v,uint _t);\r\n    event wE(address indexed _u,uint _v,uint _t);\r\n    mapping (uint => uint) public LP;\r\n    mapping (uint => uint) public TRS;\r\n    uint RLM = 3;\r\n    uint L = 180 days;\r\n    uint public T_1 = 10;\r\n    uint public T_2 = 30;\r\n    uint public T_3 = 70;\r\n    uint public T_4 = 150;\r\n    uint public T_5 = 500;\r\n    struct US {\r\n        bool x;\r\n        uint a;\r\n        uint b;\r\n        address[] c;\r\n        mapping (uint => uint) d;\r\n        mapping (address => uint) e;\r\n        mapping (uint => bool) f;\r\n    }\r\n    mapping (address => US) public us;\r\n    mapping (uint => address) public uL;\r\n    uint public g = 0;\r\n    constructor() public {\r\n        LP[1] = 0.1 ether;\r\n        LP[2] = 0.2 ether;\r\n        LP[3] = 0.6 ether;\r\n        LP[4] = 1.8 ether;\r\n        LP[5] = 5.4 ether;\r\n        TRS[1] = 0.1 ether;\r\n        TRS[2] = 0.25 ether;\r\n        TRS[3] = 0.55 ether;\r\n        TRS[4] = 1.5 ether;\r\n        TRS[5] = 5 ether;\r\n        US memory uS;\r\n        g++;\r\n        uS = US({\r\n            x : true,\r\n            a : g,\r\n            b : 0,\r\n            c : new address[](0)\r\n        });\r\n        us[ownerWallet] = uS;\r\n        uL[g] = ownerWallet;\r\n        us[ownerWallet].d[1] = 77777777777;\r\n        us[ownerWallet].d[2] = 77777777777;\r\n        us[ownerWallet].d[3] = 77777777777;\r\n        us[ownerWallet].d[4] = 77777777777;\r\n        us[ownerWallet].d[5] = 77777777777;\r\n    }\r\n\r\n    function () external payable {\r\n        uint level;\r\n        if(msg.value == LP[1]){\r\n            level = 1;\r\n        }else if(msg.value == LP[2]){\r\n            level = 2;\r\n        }else if(msg.value == LP[3]){\r\n            level = 3;\r\n        }else if(msg.value == LP[4]){\r\n            level = 4;\r\n        }else if(msg.value == LP[5]){\r\n            level = 5;\r\n        }else {\r\n            revert('Incorrect Value send');\r\n        }\r\n        if(us[msg.sender].x){\r\n            funcG(level);\r\n        } else if(level == 1) {\r\n            uint refId = 0;\r\n            address referrer = bTA(msg.data);\r\n\r\n            if (us[referrer].x){\r\n                refId = us[referrer].a;\r\n            } else {\r\n                revert('Incorrect referrer');\r\n            }\r\n            funcA(refId);\r\n        } else {\r\n            revert(\"Please buy first level\");\r\n        }\r\n    }\r\n    function funcA(uint _l) public payable {\r\n        uint _b = _l;\r\n        require(!us[msg.sender].x, 'User exist');\r\n        require(_b > 0 && _b <= g, 'Incorrect referrer Id');\r\n        require(msg.value==LP[1], 'Incorrect Value');\r\n        if(us[uL[_b]].c.length >= RLM)\r\n        {\r\n            // address[] memory _n = new address[](1);\r\n            // _n[0] = uL[_b];\r\n            _b = us[funcIV4(uL[_b])].a;\r\n        }\r\n        US memory uS;\r\n        g++;\r\n        uS = US({\r\n            x : true,\r\n            a : g,\r\n            b : _b,\r\n            c : new address[](0)\r\n        });\r\n        us[msg.sender] = uS;\r\n        uL[g] = msg.sender;\r\n        us[msg.sender].d[1] = now + L;\r\n        us[msg.sender].d[2] = 0;\r\n        us[msg.sender].d[3] = 0;\r\n        us[msg.sender].d[4] = 0;\r\n        us[msg.sender].d[5] = 0;\r\n        us[uL[_b]].c.push(msg.sender);\r\n        funcH(1, msg.sender);\r\n        emit rLE(msg.sender, uL[_b], now);\r\n        funcB(uL[_b],msg.sender);\r\n    }\r\n    function funcB(address _r,address _u) private {\r\n        if (us[_r].x){\r\n            us[_r].e[_u] += 1;\r\n            funcC(_r);\r\n            funcB(uL[us[_r].b],_r);\r\n        }\r\n    } \r\n    function funcC(address _u) private {\r\n        if (us[_u].c.length == 3){\r\n            uint _t1C = us[_u].e[us[_u].c[0]];\r\n            uint _t2C = us[_u].e[us[_u].c[1]];\r\n            uint _t3C = us[_u].e[us[_u].c[2]];\r\n            if (_t1C >= T_1 && _t2C >= T_1 && _t3C >= T_1 && !us[_u].f[0]){\r\n                bool _rs;\r\n                _rs = address(uint160(_u)).send(TRS[1]);\r\n                if (_rs){\r\n                    emit bRE(_u,1,now);\r\n                    us[_u].f[0] = true;\r\n                } else {\r\n                    emit lRE(_u,1,now);\r\n                }\r\n            }\r\n            if (_t1C >= T_2 && _t2C >= T_2 && _t3C >= T_2 && !us[_u].f[1]){\r\n                bool _rs;\r\n                _rs = address(uint160(_u)).send(TRS[2]);\r\n                if (_rs){\r\n                    emit bRE(_u,2,now);\r\n                    us[_u].f[1] = true;\r\n                } else {\r\n                    emit lRE(_u,2,now);\r\n                }\r\n            }\r\n            if (_t1C >= T_3 && _t2C >= T_3 && _t3C >= T_3 && !us[_u].f[2]){\r\n                bool _rs;\r\n                _rs = address(uint160(_u)).send(TRS[3]);\r\n                if (_rs){\r\n                    emit bRE(_u,3,now);\r\n                    us[_u].f[2] = true;\r\n                } else {\r\n                    emit lRE(_u,3,now);\r\n                }\r\n            }\r\n            if (_t1C >= T_4 && _t2C >= T_4 && _t3C >= T_4 && !us[_u].f[3]){\r\n                bool _rs;\r\n                _rs = address(uint160(_u)).send(TRS[4]);\r\n                if (_rs){\r\n                    emit bRE(_u,4,now);\r\n                    us[_u].f[3] = true;\r\n                } else {\r\n                    emit lRE(_u,4,now);\r\n                }\r\n            }\r\n            if (_t1C >= T_5 && _t2C >= T_5 && _t3C >= T_5 && !us[_u].f[4]){\r\n                bool _rs;\r\n                _rs = address(uint160(_u)).send(TRS[5]);\r\n                if (_rs){\r\n                    emit bRE(_u,5,now);\r\n                    us[_u].f[4] = true;\r\n                } else {\r\n                    emit lRE(_u,5,now);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function funcD() public payable {\r\n        emit dE(msg.sender,msg.value,now);\r\n    }\r\n    function funcE(uint _v) public onlyOwner {\r\n        msg.sender.transfer(_v);\r\n        emit wE(msg.sender,_v,now);\r\n    }\r\n    function funcF(address _u,uint _l) public onlyOwner {\r\n        require(us[_u].x,'User not exist');\r\n        require(_l>1 && _l<=5,'Incorrect level');\r\n        for (uint l = 2; l <= _l;l++){\r\n            us[_u].d[l] = now + L;\r\n        }\r\n    }\r\n    function funcG(uint _l) public payable {\r\n        require(us[msg.sender].x, 'User not exist');\r\n\r\n        require(_l>0 && _l<=5,'Incorrect level');\r\n\r\n        if(_l == 1){\r\n            require(msg.value==LP[1], 'Incorrect Value');\r\n            us[msg.sender].d[1] += L;\r\n        } else {\r\n            require(msg.value==LP[_l], 'Incorrect Value');\r\n\r\n            for(uint l =_l-1; l>0; l-- ){\r\n                require(us[msg.sender].d[l] >= now, 'Buy the previous level');\r\n            }\r\n\r\n            if(us[msg.sender].d[_l] == 0){\r\n                us[msg.sender].d[_l] = now + L;\r\n            } else {\r\n                us[msg.sender].d[_l] += L;\r\n            }\r\n        }\r\n        funcH(_l, msg.sender);\r\n        emit bLE(msg.sender, _l, now);\r\n    }\r\n    function funcH(uint _l, address _u) internal {\r\n        address _r;\r\n        address _r1;\r\n        address _r2;\r\n        address _r3;\r\n        address _r4;\r\n        if(_l == 1){\r\n            _r = uL[us[_u].b];\r\n        } else if(_l == 2){\r\n            _r1 = uL[us[_u].b];\r\n            _r = uL[us[_r1].b];\r\n        } else if(_l == 3){\r\n            _r1 = uL[us[_u].b];\r\n            _r2 = uL[us[_r1].b];\r\n            _r = uL[us[_r2].b];\r\n        } else if(_l == 4){\r\n            _r1 = uL[us[_u].b];\r\n            _r2 = uL[us[_r1].b];\r\n            _r3 = uL[us[_r2].b];\r\n            _r = uL[us[_r3].b];\r\n        } else if(_l == 5){\r\n            _r1 = uL[us[_u].b];\r\n            _r2 = uL[us[_r1].b];\r\n            _r3 = uL[us[_r2].b];            \r\n            _r4 = uL[us[_r3].b];\r\n            _r = uL[us[_r4].b];\r\n        }\r\n        if(!us[_r].x){\r\n            _r = uL[1];\r\n        }\r\n        if(us[_r].d[_l] >= now ){\r\n            bool _rs;\r\n            _rs = address(uint160(_r)).send(LP[_l]);\r\n            emit gME(_r, msg.sender, _l, now);\r\n        } else {\r\n            emit lME(_r, msg.sender, _l, now);\r\n            funcH(_l,_r);\r\n        }\r\n    }\r\n    function funcI(address[] memory _arr,uint _count) public view returns (address){\r\n        require(_count <= 6,'No Free Referrer');\r\n        address[] memory _n = new address[](729);\r\n        uint id = 0;\r\n        for (uint i = 0; i < 4;i++){\r\n            for (uint j = 0; j < _arr.length; j++){\r\n                if (i == 3){\r\n                    for (uint l = 0; l < us[_arr[j]].c.length;l++){\r\n                        _n[id] = us[_arr[j]].c[l];\r\n                        id++;\r\n                    }\r\n                } else {\r\n                    if (us[_arr[j]].c.length == i){\r\n                        return _arr[j];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        address[] memory n = new address[](id);\r\n        for (uint q = 0;q < id;q++){\r\n            n[q] = _n[q];\r\n        }\r\n        return funcI(n,_count+1);\r\n    }\r\n    function funcIV2(address[] memory _arr,uint _count) public view returns (address){\r\n        require(_count <= 6,'No Free Referrer');\r\n        address[] memory _n = new address[](3**(_count+1));\r\n        for (uint i = 0; i < 4;i++){\r\n            for (uint j = 0; j < _arr.length; j++){\r\n                if (i == 3){\r\n                    for (uint l = 0; l < us[_arr[j]].c.length;l++){\r\n                        _n[j+(3**_count)*l] = us[_arr[j]].c[l];\r\n                    }\r\n                } else {\r\n                    if (us[_arr[j]].c.length == i){\r\n                        return _arr[j];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return funcIV2(_n,_count+1);\r\n    }\r\n    function funcIV3(address[] memory _arr,uint _count) public view returns (address){\r\n        require(_count <= 6,'No Free Referrer');\r\n        address[] memory _n = new address[](3**(_count+1));\r\n        uint id = 0;\r\n        for (uint i = 0; i < 4;i++){\r\n            if (i == 3){\r\n                for (uint j = 0;j < _arr.length;j++){\r\n                    for (uint k = 0; k < us[_arr[j]].c.length;k++){\r\n                        _n[id] = us[_arr[j]].c[k];\r\n                        id++;\r\n                    }\r\n                }\r\n            } else {\r\n                uint j = 0;\r\n                while(j < 3**(_count-1)){\r\n                    uint k = j;\r\n                    while(k <= _arr.length){\r\n                        if (us[_arr[k]].c.length == i){\r\n                            return _arr[k];\r\n                        }\r\n                        k += 3**_count;\r\n                    }\r\n                    j++;\r\n                }\r\n            }\r\n        }\r\n        return funcIV3(_n,_count+1);\r\n    }\r\n    function funcIV4(address _u) public view returns(address) {\r\n        require(us[_u].x,'User not exist');\r\n        uint[] memory _n = new uint[](3);\r\n        _n[0] = 0;\r\n        _n[1] = 1;\r\n        _n[2] = 2;\r\n        if (us[_u].c.length < 3){\r\n            return _u;\r\n        }\r\n        return funcFR(us[_u].c,_n);\r\n    }\r\n    function funcFR(address[] memory _a,uint[] memory _n) private view returns (address){\r\n        require(_n.length <= 729,'F6');\r\n        address[] memory _na = new address[](3*_a.length);\r\n        uint[] memory _nn = new uint[](3*_n.length);\r\n        for (uint i = 0;i < 3;i++){\r\n            for (uint j = 0;j < _a.length;j++){\r\n                if (us[_a[_n[j]]].c.length == i){\r\n                    return _a[_n[j]];\r\n                }\r\n            }\r\n        }\r\n        for (uint i = 0; i < _a.length;i++){\r\n            for (uint j = 0; j < us[_a[i]].c.length;j++){\r\n                _na[3*i+j] = us[_a[i]].c[j];\r\n            }\r\n        }\r\n        for (uint i = 0;i < 3;i++){\r\n            for (uint j = 0; j < _n.length;j++){\r\n                _nn[_n.length*i+j] = 3*_n[j] + i;\r\n            }\r\n        }\r\n        return funcFR(_na,_nn);\r\n    }\r\n    function vUR(address _u) public view returns(address[] memory) {\r\n        return us[_u].c;\r\n    }\r\n    function vUT(address _u, address _aT) public view returns(uint){\r\n        return us[_u].e[_aT];\r\n    }\r\n\r\n    function vULE(address _u, uint _l) public view returns(uint) {\r\n        return us[_u].d[_l];\r\n    }\r\n    function vURS(address _u,uint _r) public view returns(bool){\r\n        return us[_u].f[_r];\r\n    }\r\n    function bTA(bytes memory bys) private pure returns (address  addr ) {\r\n        assembly { \r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"us\",\"outputs\":[{\"name\":\"x\",\"type\":\"bool\"},{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_u\",\"type\":\"address\"},{\"name\":\"_aT\",\"type\":\"address\"}],\"name\":\"vUT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_u\",\"type\":\"address\"},{\"name\":\"_r\",\"type\":\"uint256\"}],\"name\":\"vURS\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_l\",\"type\":\"uint256\"}],\"name\":\"funcG\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"T_1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_u\",\"type\":\"address\"}],\"name\":\"vUR\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TRS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"T_3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_arr\",\"type\":\"address[]\"},{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"funcIV3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_u\",\"type\":\"address\"},{\"name\":\"_l\",\"type\":\"uint256\"}],\"name\":\"funcF\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_arr\",\"type\":\"address[]\"},{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"funcIV2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_v\",\"type\":\"uint256\"}],\"name\":\"funcE\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_u\",\"type\":\"address\"},{\"name\":\"_l\",\"type\":\"uint256\"}],\"name\":\"vULE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"T_4\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_u\",\"type\":\"address\"}],\"name\":\"funcIV4\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"T_5\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_l\",\"type\":\"uint256\"}],\"name\":\"funcA\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uL\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"T_2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"funcD\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"g\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_arr\",\"type\":\"address[]\"},{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"funcI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_u\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_r\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_t\",\"type\":\"uint256\"}],\"name\":\"rLE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_u\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_l\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_t\",\"type\":\"uint256\"}],\"name\":\"bLE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_u\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_r\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_l\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_t\",\"type\":\"uint256\"}],\"name\":\"gME\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_u\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_r\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_l\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_t\",\"type\":\"uint256\"}],\"name\":\"lME\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_u\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_l\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_t\",\"type\":\"uint256\"}],\"name\":\"bRE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_u\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_l\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_t\",\"type\":\"uint256\"}],\"name\":\"lRE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_u\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_v\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_t\",\"type\":\"uint256\"}],\"name\":\"dE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_u\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_v\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_t\",\"type\":\"uint256\"}],\"name\":\"wE\",\"type\":\"event\"}]","ContractName":"CryptoLights","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://f0328c426d8ff71a74a142c7674d10ec46d4f292d4e9cba197ba3a91ed0abf31"}]}