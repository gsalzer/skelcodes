{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    assert(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    assert(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    assert(c >= _a);\n    return c;\n  }\n}\n\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address _who) public view returns (uint256);\n  function transfer(address _to, uint256 _value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address _owner, address _spender)\n    public view returns (uint256);\n\n  function transferFrom(address _from, address _to, uint256 _value)\n    public returns (bool);\n\n  function approve(address _spender, uint256 _value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n\n\ncontract Vesting {\n\n    using SafeMath for uint256;\n\n    ERC20 public mycroToken;\n\n    event LogFreezedTokensToInvestor(address _investorAddress, uint256 _tokenAmount, uint256 _daysToFreeze);\n    event LogUpdatedTokensToInvestor(address _investorAddress, uint256 _tokenAmount);\n    event LogWithdraw(address _investorAddress, uint256 _tokenAmount);\n\n    constructor(address _token) public {\n        mycroToken = ERC20(_token);\n    }\n\n    mapping (address => Investor) public investors;\n\n    struct Investor {\n        uint256 tokenAmount;\n        uint256 frozenPeriod;\n        bool isInvestor;\n    }\n\n\n    /**\n        @param _investorAddress the address of the investor\n        @param _tokenAmount the amount of tokens an investor will receive\n        @param _daysToFreeze the number of the days token would be freezed to withrow, e.c. 3 => 3 days\n     */\n    function freezeTokensToInvestor(address _investorAddress, uint256 _tokenAmount, uint256 _daysToFreeze) public returns (bool) {\n        require(_investorAddress != address(0));\n        require(_tokenAmount != 0);\n        require(!investors[_investorAddress].isInvestor);\n\n        _daysToFreeze = _daysToFreeze.mul(1 days); // converts days into seconds\n        \n        investors[_investorAddress] = Investor({tokenAmount: _tokenAmount, frozenPeriod: now.add(_daysToFreeze), isInvestor: true});\n        \n        require(mycroToken.transferFrom(msg.sender, address(this), _tokenAmount));\n        emit LogFreezedTokensToInvestor(_investorAddress, _tokenAmount, _daysToFreeze);\n\n        return true;\n    }\n\n     function updateTokensToInvestor(address _investorAddress, uint256 _tokenAmount) public returns(bool) {\n        require(investors[_investorAddress].isInvestor);\n        Investor storage currentInvestor = investors[_investorAddress];\n        currentInvestor.tokenAmount = currentInvestor.tokenAmount.add(_tokenAmount);\n\n        require(mycroToken.transferFrom(msg.sender, address(this), _tokenAmount));\n        emit LogUpdatedTokensToInvestor(_investorAddress, _tokenAmount);\n\n        return true;\n    }\n\n    function withdraw(uint256 _tokenAmount) public {\n        address investorAddress = msg.sender;\n        Investor storage currentInvestor = investors[investorAddress];\n        \n        require(currentInvestor.isInvestor);\n        require(now >= currentInvestor.frozenPeriod);\n        require(_tokenAmount <= currentInvestor.tokenAmount);\n\n        currentInvestor.tokenAmount = currentInvestor.tokenAmount.sub(_tokenAmount);\n        require(mycroToken.transfer(investorAddress, _tokenAmount));\n        emit LogWithdraw(investorAddress, _tokenAmount);\n    }\n\n\n\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"frozenPeriod\",\"type\":\"uint256\"},{\"name\":\"isInvestor\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mycroToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investorAddress\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"updateTokensToInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investorAddress\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_daysToFreeze\",\"type\":\"uint256\"}],\"name\":\"freezeTokensToInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_investorAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_daysToFreeze\",\"type\":\"uint256\"}],\"name\":\"LogFreezedTokensToInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_investorAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"LogUpdatedTokensToInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_investorAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"}]","ContractName":"Vesting","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000050987e6be405ebac691f8988304562e5efc3b2ea","Library":"","SwarmSource":"bzzr://668df567ff0fc38ba4e4531304ee52cc0708540fb9b992fb1c21d58f6dbb874f"}]}