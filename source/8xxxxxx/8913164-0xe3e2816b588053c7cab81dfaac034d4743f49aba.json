{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity =0.5.12;\r\n\r\n// * Gods Unchained Cards Exchange\r\n//\r\n// * Version 1.0\r\n//\r\n// * A dedicated, specialized contract enabling exchange of Gods Unchained cards.\r\n//   Considers Gods Unchained specific characteristics like quality and proto\r\n//   and allows multicard offchain listing and dynamic package purchases.\r\n//\r\n// * https://gu.cards\r\n// * Copyright gu.cards\r\n\r\ninterface ICards {\r\n    function cardProtos(uint tokenId) external view returns (uint16 proto);\r\n    function cardQualities(uint tokenId) external view returns (uint8 quality);\r\n}\r\n\r\ninterface IERC721 {\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n}\r\n\r\ncontract GodsUnchainedCards is IERC721, ICards {}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract CardExchange {\r\n    using SafeMath for uint256;\r\n\r\n    ////////////////////////////////////////////////\r\n    //////// V A R I A B L E S\r\n    //\r\n    // Current address of the Gods Unchained cards (CARD) token contract.\r\n    //\r\n    GodsUnchainedCards constant public godsUnchainedCards = GodsUnchainedCards(0x629cDEc6aCc980ebeeBeA9E5003bcD44DB9fc5cE);\r\n    //\r\n    // Mapping of all buy orders.\r\n    //\r\n    mapping (address => mapping(uint256 => BuyOrder)) public buyOrdersById;\r\n    //\r\n    // Mapping of all sell orders.\r\n    //\r\n    mapping (address => mapping(uint256 => SellOrder)) public sellOrdersById;\r\n    //\r\n    // EIP712 sellOrder implementation, to safely create sell orders without chain interaction.\r\n    //\r\n    string private constant domain = \"EIP712Domain(string name)\";\r\n    bytes32 public constant domainTypeHash = keccak256(abi.encodePacked(domain));\r\n    bytes32 private domainSeparator = keccak256(abi.encode(domainTypeHash, keccak256(\"Sell Gods Unchained cards on gu.cards\")));\r\n    string private constant sellOrdersForTokenIdsType = \"SellOrders(uint256[] ids,uint256[] tokenIds,uint256[] prices)\";\r\n    bytes32 public constant sellOrdersForTokenIdsTypeHash = keccak256(abi.encodePacked(sellOrdersForTokenIdsType));\r\n    string private constant sellOrdersForProtosAndQualitiesType = \"SellOrders(uint256[] ids,uint256[] protos,uint256[] qualities,uint256[] prices)\";\r\n    bytes32 public constant sellOrdersForProtosAndQualitiesTypeHash = keccak256(abi.encodePacked(sellOrdersForProtosAndQualitiesType));\r\n    //\r\n    // Accumulated locked funds from binding buy orders are save from contract killing or withdraw\r\n    // until the orders are executed or canceled.\r\n    //\r\n    uint256 public lockedInFunds;\r\n    //\r\n    // In case the exchange needs to be paused.\r\n    //\r\n    bool public paused;\r\n    //\r\n    // Exchange fee. \r\n    // Devided by 1000 than applied to the price.\r\n    // e.g. 25 = 2.5%\r\n    //\r\n    uint256 public exchangeFee;\r\n    //\r\n    // Standard contract ownership.\r\n    //\r\n    address payable public owner;\r\n    address payable private nextOwner;\r\n    \r\n    ////////////////////////////////////////////////\r\n    //////// E V E N T S\r\n    //\r\n    event BuyOrderCreated(uint256 id);\r\n    event SellOrderCreated(uint256 id);\r\n    event BuyOrderCanceled(uint256 id);\r\n    event SellOrderCanceled(uint256 id);\r\n    event Settled(uint256 buyOrderId, uint256 sellOrderId);\r\n\r\n    ////////////////////////////////////////////////\r\n    //////// S T R U C T S\r\n    //\r\n    //  An instruction from an orderer to buy a card.\r\n    //\r\n    struct BuyOrder {\r\n        //\r\n        // The id of the buy order.\r\n        //\r\n        uint256 id;\r\n        //\r\n        // Price in wei.\r\n        //\r\n        uint256 price;\r\n        //\r\n        // Exchange fee set the moment buy order is created.\r\n        //\r\n        uint256 fee;\r\n        //\r\n        // Which concrete card.\r\n        //\r\n        uint16 proto;\r\n        //\r\n        // The quality of the card.\r\n        //\r\n        uint8 quality;\r\n        //\r\n        // Where to send the card or refund to.\r\n        //\r\n        address payable buyer;\r\n        //\r\n        // Has the order been settled yet?\r\n        //\r\n        bool settled;\r\n        //\r\n        // Has the order been canceled yet?\r\n        //\r\n        bool canceled;\r\n    }\r\n    //\r\n    //  An instruction from a seller to sell a concrete card (token) for a certain amount of ETH.\r\n    //\r\n    struct SellOrder {\r\n        //\r\n        // The id of the sell order.\r\n        //\r\n        uint256 id;\r\n        //\r\n        // The concrete token id of the card.\r\n        //\r\n        uint256 tokenId;\r\n        //\r\n        // Which concrete card.\r\n        //\r\n        uint16 proto;\r\n        //\r\n        // The quality of the card.\r\n        //\r\n        uint8 quality;\r\n        //\r\n        // Price in wei.\r\n        //\r\n        uint256 price;\r\n        //\r\n        // Where to send the ETH to?\r\n        //\r\n        address payable seller;\r\n        //\r\n        // Has the order been settled yet?\r\n        //\r\n        bool settled;\r\n        //\r\n        // Has the order been canceled yet?\r\n        //\r\n        bool canceled;\r\n        //\r\n        // Has the orders tokenId been set?\r\n        // tokenId 0 is actually an existing token.\r\n        //\r\n        bool tokenIsSet;\r\n    }\r\n\r\n    ////////////////////////////////////////////////\r\n    //////// M O D I F I E R S\r\n    //\r\n    // Invokable only by contract owner.\r\n    //\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Function called by non-owner.\");\r\n        _;\r\n    }\r\n    //\r\n    // Invokable only if exchange is not paused.\r\n    //\r\n    modifier onlyUnpaused {\r\n        require(paused == false, \"Exchange is paused.\");\r\n        _;\r\n    }\r\n\r\n    ////////////////////////////////////////////////\r\n    //////// C O N S T R U C T O R\r\n    //\r\n    // Sets the contract owner\r\n    // and initalizes the EIP712 domain separator.\r\n    //\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    ////////////////////////////////////////////////\r\n    //////// F U N C T I O N S\r\n    //\r\n    // Public method to create one or multiple buy orders.\r\n    //\r\n    function createBuyOrders(uint256[] calldata ids, uint256[] calldata protos, uint256[] calldata prices, uint256[] calldata qualities) onlyUnpaused external payable {\r\n        _createBuyOrders(ids, protos, prices, qualities);\r\n    }\r\n    //\r\n    // Public Method to create one or multiple buy orders and settles them right after.\r\n    //\r\n    function createBuyOrdersAndSettle(uint256[] calldata orderData, uint256[] calldata sellOrderIds, uint256[] calldata tokenIds, address[] calldata sellOrderAddresses) onlyUnpaused external payable {\r\n        uint256[] memory buyOrderIds = _unpackOrderData(orderData, 0);\r\n        _createBuyOrders(\r\n            buyOrderIds,\r\n            _unpackOrderData(orderData, 1),\r\n            _unpackOrderData(orderData, 3),\r\n            _unpackOrderData(orderData, 2)\r\n        );\r\n        uint256 length = tokenIds.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            _updateSellOrderTokenId(sellOrdersById[sellOrderAddresses[i]][sellOrderIds[i]], tokenIds[i]);\r\n            _settle(\r\n                buyOrdersById[msg.sender][buyOrderIds[i]],\r\n                sellOrdersById[sellOrderAddresses[i]][sellOrderIds[i]]\r\n            );\r\n        }\r\n    }\r\n    //\r\n    // Public method to create a single buy order and settle with offchain/onchain sell order for token ids.\r\n    // Dedicated for offchain listings, use createBuyOrdersAndSettle otherwise.\r\n    //\r\n    // orderData[0] == buyOrderId\r\n    // orderData[1] == buyOrderProto\r\n    // orderData[2] == buyOrderPrice\r\n    // orderData[3] == buyOrderQuality\r\n    // orderData[4] == sellOrderId\r\n    //\r\n    function createBuyOrderAndSettleWithOffChainSellOrderForTokenIds(uint256[] calldata orderData, address sellOrderAddress, uint256[] calldata sellOrderIds, uint256[] calldata sellOrderTokenIds, uint256[] calldata sellOrderPrices, uint8 v, bytes32 r, bytes32 s) onlyUnpaused external payable {\r\n        _ensureBuyOrderPrice(orderData[2]);\r\n        _createBuyOrder(orderData[0], uint16(orderData[1]), orderData[2], uint8(orderData[3]));\r\n        _createOffChainSignedSellOrdersForTokenIds(sellOrderIds, sellOrderTokenIds, sellOrderPrices, v, r, s);\r\n        _settle(buyOrdersById[msg.sender][orderData[0]], sellOrdersById[sellOrderAddress][orderData[4]]);\r\n    }\r\n    //\r\n    // Public method to create a single buy order and settle with offchain/onchain sell order for proto and qualities.\r\n    // Dedicated for offchain listings, use createBuyOrdersAndSettle otherwise.\r\n    //\r\n    function createBuyOrderAndSettleWithOffChainSellOrderForProtosAndQualities(uint256 buyOrderId, uint16 buyOrderProto, uint256 buyOrderPrice, uint8 buyOrderQuality, uint256 sellOrderId, address sellOrderAddress, uint256 tokenId, uint256[] calldata sellOrderData, uint8 v, bytes32 r, bytes32 s) onlyUnpaused external payable {\r\n        _ensureBuyOrderPrice(buyOrderPrice);\r\n        _createBuyOrder(buyOrderId, buyOrderProto, buyOrderPrice, buyOrderQuality);\r\n        _createOffChainSignedSellOrdersForProtosAndQualities(\r\n            _unpackOrderData(sellOrderData, 0),\r\n            _unpackOrderData(sellOrderData, 1),\r\n            _unpackOrderData(sellOrderData, 2),\r\n            _unpackOrderData(sellOrderData, 3),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n        _updateSellOrderTokenId(sellOrdersById[sellOrderAddress][sellOrderId], tokenId);\r\n        _settle(buyOrdersById[msg.sender][buyOrderId], sellOrdersById[sellOrderAddress][sellOrderId]);\r\n    }\r\n    //\r\n    // Ensures buy order pice is bigger than zero \r\n    // and send ether is more then buy order price + fee.\r\n    //\r\n    function _ensureBuyOrderPrice(uint256 price) private view {\r\n        require(\r\n            msg.value >= (price.add(price.mul(exchangeFee).div(1000))) &&\r\n            price > 0,\r\n            \"Amount sent to the contract needs to cover at least this buy order's price and fee (and needs to be bigger than 0).\"\r\n        );\r\n    }\r\n    //\r\n    // Internal, private method to unpack order data\r\n    // Parts:\r\n    // 0    ids\r\n    // 1    protos\r\n    // 2    qualities\r\n    // 3    prices\r\n    //\r\n    function _unpackOrderData(uint256[] memory orderData, uint256 part) private pure returns (uint256[] memory data) {\r\n        uint256 length = orderData.length/4;\r\n        uint256[] memory returnData = new uint256[](length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            returnData[i] = orderData[i*4+part];\r\n        }\r\n        return returnData;\r\n    }\r\n    //\r\n    // Internal, private method to create buy orders.\r\n    //\r\n    function _createBuyOrders(uint256[] memory ids, uint256[] memory protos, uint256[] memory prices, uint256[] memory qualities) private {\r\n        uint256 totalAmountToPay = 0;\r\n        uint256 length = ids.length;\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            _createBuyOrder(ids[i], uint16(protos[i]), prices[i], uint8(qualities[i]));\r\n            totalAmountToPay = totalAmountToPay.add(\r\n                prices[i].add(prices[i].mul(exchangeFee).div(1000))\r\n            );\r\n        }\r\n        \r\n        require(msg.value >= totalAmountToPay && msg.value > 0, \"ETH sent to the contract is insufficient (prices + exchange fees)!\");\r\n    }\r\n    //\r\n    // Internal, private method to create a single buy order.\r\n    //\r\n    function _createBuyOrder(uint256 id, uint16 proto, uint256 price, uint8 quality) private {\r\n        BuyOrder storage buyOrder = buyOrdersById[msg.sender][id];\r\n        require(buyOrder.id == 0, \"Buy order with this ID does already exist!\");\r\n        buyOrder.id = id;\r\n        buyOrder.proto = proto;\r\n        buyOrder.price = price;\r\n        buyOrder.fee = price.mul(exchangeFee).div(1000);\r\n        buyOrder.quality = quality;\r\n        buyOrder.buyer = msg.sender;\r\n        \r\n        lockedInFunds = lockedInFunds.add(buyOrder.price.add(buyOrder.fee));\r\n\r\n        emit BuyOrderCreated(buyOrder.id);\r\n    }\r\n    //\r\n    // Public method to cancel buy orders.\r\n    //\r\n    function cancelBuyOrders(uint256[] calldata ids) external {\r\n        uint256 length = ids.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            BuyOrder storage buyOrder = buyOrdersById[msg.sender][ids[i]];\r\n            require(buyOrder.settled == false, \"Order has already been settled!\");\r\n            require(buyOrder.canceled == false, \"Order has already been canceled!\");\r\n            buyOrder.canceled = true; // prevent reentrancy, before transfer\r\n            lockedInFunds = lockedInFunds.sub(buyOrder.price.add(buyOrder.fee));\r\n            buyOrder.buyer.transfer(buyOrder.price.add(buyOrder.fee)); // refund\r\n            emit BuyOrderCanceled(buyOrder.id);\r\n        }\r\n    }\r\n    //\r\n    // Public method to creates sell orders for token ids.\r\n    //\r\n    function createSellOrdersForTokenIds(uint256[] calldata ids, uint256[] calldata prices, uint256[] calldata tokenIds) onlyUnpaused external {\r\n        _createSellOrdersForTokenIds(ids, prices, tokenIds, msg.sender);\r\n    }\r\n    //\r\n    // Internal, private method to create sell orders.\r\n    //\r\n    function _createSellOrdersForTokenIds(uint256[] memory ids, uint256[] memory prices, uint256[] memory tokenIds, address payable seller) private {\r\n        uint256 length = ids.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            _createSellOrderForTokenId(ids[i], prices[i], tokenIds[i], seller);\r\n        }\r\n    }\r\n    //\r\n    // Internal, private method to create sell orders for token ids.\r\n    //\r\n    function _createSellOrderForTokenId(uint256 id, uint256 price, uint256 tokenId, address seller) private {\r\n        _createSellOrder(\r\n            id,\r\n            price,\r\n            tokenId,\r\n            godsUnchainedCards.cardProtos(tokenId),\r\n            godsUnchainedCards.cardQualities(tokenId),\r\n            seller,\r\n            true\r\n        );\r\n    }\r\n     //\r\n    // Public method to creates sell orders for protos and qualities.\r\n    //\r\n    function createSellOrdersForProtosAndQualities(uint256[] calldata ids, uint256[] calldata prices, uint256[] calldata protos, uint256[] calldata qualities) onlyUnpaused external {\r\n        _createSellOrdersForProtosAndQualities(ids, prices, protos, qualities, msg.sender);\r\n    }\r\n    //\r\n    // Internal, private method to create sell orders.\r\n    //\r\n    function _createSellOrdersForProtosAndQualities(uint256[] memory ids, uint256[] memory prices, uint256[] memory protos, uint256[] memory qualities, address payable seller) private {\r\n        uint256 length = ids.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            _createSellOrderForProtoAndQuality(ids[i], prices[i], protos[i], qualities[i], seller);\r\n        }\r\n    }\r\n    //\r\n    // Internal, private method to create sell orders for token ids.\r\n    //\r\n    function _createSellOrderForProtoAndQuality(uint256 id, uint256 price, uint256 proto, uint256 quality, address seller) private {\r\n        _createSellOrder(\r\n            id,\r\n            price,\r\n            0,\r\n            proto,\r\n            quality,\r\n            seller,\r\n            false\r\n        );\r\n    }\r\n    //\r\n    // Internal, private method to create sell orders.\r\n    //\r\n    function _createSellOrder(uint256 id, uint256 price, uint256 tokenId, uint256 proto, uint256 quality, address seller, bool tokenIsSet) private {\r\n        address payable payableSeller = address(uint160(seller));\r\n        require(price > 0, \"Sell order price needs to be bigger than 0.\");\r\n\r\n        SellOrder storage sellOrder = sellOrdersById[seller][id];\r\n        require(sellOrder.id == 0, \"Sell order with this ID does already exist!\");\r\n        require(godsUnchainedCards.isApprovedForAll(payableSeller, address(this)), \"Operator approval missing!\");\r\n        sellOrder.id = id;\r\n        sellOrder.price = price;\r\n        sellOrder.proto = uint16(proto);\r\n        sellOrder.quality = uint8(quality);\r\n        sellOrder.seller = payableSeller;\r\n        \r\n        if(tokenIsSet) { _updateSellOrderTokenId(sellOrder, tokenId); }\r\n        \r\n        emit SellOrderCreated(sellOrder.id);\r\n    }\r\n    //\r\n    // Internal, private method to update sell order tokenId.\r\n    //\r\n    function _updateSellOrderTokenId(SellOrder storage sellOrder, uint256 tokenId) private {\r\n        if(\r\n            sellOrder.tokenIsSet ||\r\n            sellOrder.canceled ||\r\n            sellOrder.settled\r\n        ) { return; }\r\n        require(godsUnchainedCards.ownerOf(tokenId) == sellOrder.seller, \"Seller is not owner of this token!\");\r\n        require(\r\n            sellOrder.proto == godsUnchainedCards.cardProtos(tokenId) &&\r\n            sellOrder.quality == godsUnchainedCards.cardQualities(tokenId)\r\n            , \"Token does not correspond to sell order proto/quality!\"\r\n        );\r\n        sellOrder.tokenIsSet = true;\r\n        sellOrder.tokenId = tokenId;\r\n    }\r\n    //\r\n    // Public method to create sell orders for token ids and settle (e.g. into existing buy orders).\r\n    //\r\n    function createSellOrdersForTokenIdsAndSettle(uint256[] calldata sellOrderIds, address[] calldata sellOrderAddresses, uint256[] calldata sellOrderPrices, uint256[] calldata sellOrderTokenIds, uint256[] calldata buyOrderIds, address[] calldata buyOrderAddresses) onlyUnpaused external {\r\n        _createSellOrdersForTokenIds(sellOrderIds, sellOrderPrices, sellOrderTokenIds, msg.sender);\r\n        _settle(buyOrderIds, buyOrderAddresses, sellOrderIds, sellOrderAddresses);\r\n    }\r\n    //\r\n    // Turns sell orders created off chain into onchain sell orders for token ids.\r\n    //\r\n    function createOffChainSignedSellOrdersForTokenIds(uint256[] calldata sellOrderIds, uint256[] calldata sellOrderTokenIds, uint256[] calldata sellOrderPrices, uint8 v, bytes32 r, bytes32 s) onlyUnpaused external {\r\n        _createOffChainSignedSellOrdersForTokenIds(sellOrderIds, sellOrderTokenIds, sellOrderPrices, v, r, s);\r\n    }\r\n    //\r\n    // Internal private method to turn off chain sell orders into on chain sell orders for token ids.\r\n    //\r\n    function _createOffChainSignedSellOrdersForTokenIds(uint256[] memory sellOrderIds, uint256[] memory sellOrderTokenIds, uint256[] memory sellOrderPrices, uint8 v, bytes32 r, bytes32 s) private {\r\n        uint256 length = sellOrderIds.length;\r\n        address seller = _recoverForTokenIds(sellOrderIds, sellOrderTokenIds, sellOrderPrices, v, r, s);\r\n        for (\r\n            uint256 i = 0;\r\n            i < length;\r\n            i++\r\n        ) {\r\n            if(sellOrdersById[seller][sellOrderIds[i]].id == 0) {\r\n                // onchain sell order does not exist yet, create it\r\n                _createSellOrderForTokenId(\r\n                    sellOrderIds[i],\r\n                    sellOrderPrices[i],\r\n                    sellOrderTokenIds[i],\r\n                    seller\r\n                );\r\n            }\r\n        }\r\n    }\r\n    //\r\n    // Public method to create sell orders for protos and qualities and settle (e.g. into existing buy orders).\r\n    //\r\n    function createSellOrdersForProtosAndQualitiesAndSettle(uint256[] calldata sellOrderData, uint256[] calldata tokenIds, uint256[] calldata buyOrderIds, address[] calldata buyOrderAddresses) onlyUnpaused external {\r\n        uint256[] memory sellOrderIds = _unpackOrderData(sellOrderData, 0);\r\n        _createSellOrdersForProtosAndQualities(\r\n            sellOrderIds,\r\n            _unpackOrderData(sellOrderData, 3),\r\n            _unpackOrderData(sellOrderData, 1),\r\n            _unpackOrderData(sellOrderData, 2),\r\n            msg.sender\r\n        );\r\n        uint256 length = buyOrderIds.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n          _updateSellOrderTokenId(sellOrdersById[msg.sender][sellOrderIds[i]], tokenIds[i]);\r\n          _settle(buyOrdersById[buyOrderAddresses[i]][buyOrderIds[i]], sellOrdersById[msg.sender][sellOrderIds[i]]);\r\n        }\r\n    }\r\n    //\r\n    // Turns sell orders created off chain into onchain sell orders for protos and qualities.\r\n    //\r\n    function createOffChainSignedSellOrdersForProtosAndQualities(uint256[] calldata sellOrderIds, uint256[] calldata sellOrderProtos, uint256[] calldata sellOrderQualities, uint256[] calldata sellOrderPrices, uint8 v, bytes32 r, bytes32 s) onlyUnpaused external {\r\n        _createOffChainSignedSellOrdersForProtosAndQualities(sellOrderIds, sellOrderProtos, sellOrderQualities, sellOrderPrices, v, r, s);\r\n    }\r\n    //\r\n    // Internal private method to turn off chain sell orders into on chain sell orders for protos and qualities.\r\n    //\r\n    function _createOffChainSignedSellOrdersForProtosAndQualities(uint256[] memory sellOrderIds, uint256[] memory sellOrderProtos, uint256[] memory sellOrderQualities, uint256[] memory sellOrderPrices, uint8 v, bytes32 r, bytes32 s) private {\r\n        uint256 length = sellOrderIds.length;\r\n        address seller = _recoverForProtosAndQualities(sellOrderIds, sellOrderProtos, sellOrderQualities, sellOrderPrices, v, r, s);\r\n        for (\r\n            uint256 i = 0;\r\n            i < length;\r\n            i++\r\n        ) {\r\n            if(sellOrdersById[seller][sellOrderIds[i]].id == 0) {\r\n                // onchain sell order does not exist yet, create it\r\n                _createSellOrderForProtoAndQuality(\r\n                    sellOrderIds[i],\r\n                    sellOrderPrices[i],\r\n                    sellOrderProtos[i],\r\n                    sellOrderQualities[i],\r\n                    seller\r\n                );\r\n            }\r\n        }\r\n    }\r\n    //\r\n    // Public method that allows to recover an off chain sell order for token ids\r\n    //\r\n    function recoverSellOrderForTokenIds(uint256[] calldata ids, uint256[] calldata tokenIds, uint256[] calldata prices,  uint8 v, bytes32 r, bytes32 s) external view returns (address) {\r\n        return _recoverForTokenIds(ids, tokenIds, prices, v, r, s);\r\n    }\r\n    //\r\n    // Internal, private method to recover off chain sell order\r\n    //\r\n    function _recoverForTokenIds(uint256[] memory ids, uint256[] memory tokenIds, uint256[] memory prices, uint8 v, bytes32 r, bytes32 s) private view returns (address) {\r\n        return ecrecover(hashSellOrdersForTokenIds(ids, tokenIds, prices), v, r, s);\r\n    }\r\n    //\r\n    // Internal, private method to hash a sell orders for token ids\r\n    //\r\n    function hashSellOrdersForTokenIds(uint256[] memory ids, uint256[] memory tokenIds, uint256[] memory prices) private view returns (bytes32){\r\n        return keccak256(abi.encodePacked(\r\n           \"\\x19\\x01\",\r\n           domainSeparator,\r\n           keccak256(abi.encode(\r\n                sellOrdersForTokenIdsTypeHash,\r\n                keccak256(abi.encodePacked(ids)),\r\n                keccak256(abi.encodePacked(tokenIds)),\r\n                keccak256(abi.encodePacked(prices))\r\n            ))\r\n        ));\r\n    }\r\n    //\r\n    // Public method that allows to recover an off chain sell order for token ids\r\n    //\r\n    function recoverSellOrderForProtosAndQualities(uint256[] calldata ids, uint256[] calldata protos, uint256[] calldata qualities, uint256[] calldata prices,  uint8 v, bytes32 r, bytes32 s) external view returns (address) {\r\n        return _recoverForProtosAndQualities(ids, protos, qualities, prices, v, r, s);\r\n    }\r\n    //\r\n    // Internal, private method to recover off chain sell orders for protos and qualities\r\n    //\r\n    function _recoverForProtosAndQualities(uint256[] memory ids, uint256[] memory protos, uint256[] memory qualities, uint256[] memory prices, uint8 v, bytes32 r, bytes32 s) private view returns (address) {\r\n        return ecrecover(hashSellOrdersForProtosAndQualitiesIds(ids, protos, qualities, prices), v, r, s);\r\n    }\r\n     //\r\n    // Internal, private method to hash a sell order for protos & qualities\r\n    //\r\n    function hashSellOrdersForProtosAndQualitiesIds(uint256[] memory ids, uint256[] memory protos, uint256[] memory qualities, uint256[] memory prices) private view returns (bytes32){\r\n        return keccak256(abi.encodePacked(\r\n           \"\\x19\\x01\",\r\n           domainSeparator,\r\n           keccak256(abi.encode(\r\n                sellOrdersForProtosAndQualitiesTypeHash,\r\n                keccak256(abi.encodePacked(ids)),\r\n                keccak256(abi.encodePacked(protos)),\r\n                keccak256(abi.encodePacked(qualities)),\r\n                keccak256(abi.encodePacked(prices))\r\n            ))\r\n        ));\r\n    }\r\n    //\r\n    // Cancels sell orders.\r\n    //\r\n    function cancelSellOrders(uint256[] calldata ids) onlyUnpaused external {\r\n        uint256 length = ids.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            SellOrder storage sellOrder = sellOrdersById[msg.sender][ids[i]];\r\n            if(sellOrder.id == 0) { // off-chain sell order\r\n                sellOrder.id = ids[i];\r\n            }\r\n            require(sellOrder.canceled == false, \"Order has already been canceled!\");\r\n            require(sellOrder.settled == false, \"Order has already been settled!\");\r\n            sellOrder.canceled = true;\r\n            emit SellOrderCanceled(sellOrder.id);\r\n        }\r\n    }\r\n    //\r\n    // Public method to settle buy and sell orders (transfers cards for ETH).\r\n    //\r\n    function settle(uint256[] calldata buyOrderIds, address[] calldata buyOrderAddresses, uint256[] calldata sellOrderIds, address[] calldata sellOrderAddresses) onlyUnpaused external {\r\n        _settle(buyOrderIds, buyOrderAddresses, sellOrderIds, sellOrderAddresses);\r\n    }\r\n    //\r\n    // Public method to settle .\r\n    //\r\n    function settleWithToken(uint256[] calldata buyOrderIds, address[] calldata buyOrderAddresses, uint256[] calldata sellOrderIds, address[] calldata sellOrderAddresses, uint256[] calldata tokenIds) onlyUnpaused external {\r\n        uint256 length = tokenIds.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n          _updateSellOrderTokenId(\r\n              sellOrdersById[sellOrderAddresses[i]][sellOrderIds[i]],\r\n              tokenIds[i]\r\n          );\r\n          _settle(buyOrdersById[buyOrderAddresses[i]][buyOrderIds[i]], sellOrdersById[sellOrderAddresses[i]][sellOrderIds[i]]);\r\n        }\r\n    }\r\n    //\r\n    // Internal, private method to settle buy orders with sell order.\r\n    //\r\n    function _settle(uint256[] memory buyOrderIds, address[] memory buyOrderAddresses, uint256[] memory sellOrderIds, address[] memory sellOrderAddresses) private {\r\n        uint256 length = buyOrderIds.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            _settle(\r\n                buyOrdersById[buyOrderAddresses[i]][buyOrderIds[i]],\r\n                sellOrdersById[sellOrderAddresses[i]][sellOrderIds[i]]\r\n            );\r\n        }\r\n    }\r\n    //\r\n    // Internal, private method to settle a buy order with a sell order.\r\n    function _settle(BuyOrder storage buyOrder, SellOrder storage sellOrder) private {\r\n        if(\r\n            sellOrder.settled || sellOrder.canceled ||\r\n            buyOrder.settled || buyOrder.canceled\r\n        ) { return; }\r\n\r\n        uint256 proto = godsUnchainedCards.cardProtos(sellOrder.tokenId);\r\n        uint256 quality = godsUnchainedCards.cardQualities(sellOrder.tokenId);\r\n        require(buyOrder.price >= sellOrder.price, \"Sell order exceeds what the buyer is willing to pay!\");\r\n        require(buyOrder.proto == proto && sellOrder.proto == proto, \"Order protos are not matching!\");\r\n        require(buyOrder.quality == quality && sellOrder.quality == quality, \"Order qualities are not matching!\");\r\n        \r\n        sellOrder.settled = buyOrder.settled = true; // prevent reentrancy, before transfer or unlocking funds\r\n        lockedInFunds = lockedInFunds.sub(buyOrder.price.add(buyOrder.fee));\r\n        godsUnchainedCards.transferFrom(sellOrder.seller, buyOrder.buyer, sellOrder.tokenId);\r\n        sellOrder.seller.transfer(sellOrder.price);\r\n\r\n        emit Settled(buyOrder.id, sellOrder.id);\r\n    }\r\n    //\r\n    // Public method to pause or unpause the exchange.\r\n    //\r\n    function setPausedTo(bool value) external onlyOwner {\r\n        paused = value;\r\n    }\r\n    //\r\n    // Set exchange fee.\r\n    //\r\n    function setExchangeFee(uint256 value) external onlyOwner {\r\n        exchangeFee = value;\r\n    }\r\n    //\r\n    // Funds withdrawal, considers unresolved orders and keeps user funds save.\r\n    //\r\n    function withdraw(address payable beneficiary, uint256 amount) external onlyOwner {\r\n        require(lockedInFunds.add(amount) <= address(this).balance, \"Not enough funds. Funds are partially locked from unsettled buy orders.\");\r\n        beneficiary.transfer(amount);\r\n    }\r\n    //\r\n    // Standard contract ownership transfer.\r\n    //\r\n    function approveNextOwner(address payable _nextOwner) external onlyOwner {\r\n        require(_nextOwner != owner, \"Cannot approve current owner.\");\r\n        nextOwner = _nextOwner;\r\n    }\r\n    //\r\n    // Accept the next owner.\r\n    //\r\n    function acceptNextOwner() external {\r\n        require(msg.sender == nextOwner, \"The new owner has to accept the previously set new owner.\");\r\n        owner = nextOwner;\r\n    }\r\n    //\r\n    // Contract may be destroyed only when there are no ongoing orders and no locked in funds.\r\n    // So it would be required to either refund everybody or resolve all the orders,\r\n    // before the contract can be killed\r\n    //\r\n    function kill() external onlyOwner {\r\n        require(lockedInFunds == 0, \"All orders need to be settled or refundeded before self-destruct.\");\r\n        selfdestruct(owner);\r\n    }\r\n    //\r\n    // Fallback function deliberately left empty. It's primary use case\r\n    // is to top up the exchange.\r\n    //\r\n    function () external payable {}\r\n    \r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"BuyOrderCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"BuyOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"SellOrderCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"SellOrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyOrderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellOrderId\",\"type\":\"uint256\"}],\"name\":\"Settled\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"approveNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"buyOrdersById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"quality\",\"type\":\"uint8\"},{\"internalType\":\"address payable\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"settled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"cancelBuyOrders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"cancelSellOrders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buyOrderId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"buyOrderProto\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"buyOrderPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"buyOrderQuality\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"sellOrderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sellOrderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"sellOrderData\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"createBuyOrderAndSettleWithOffChainSellOrderForProtosAndQualities\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"orderData\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"sellOrderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"sellOrderIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellOrderTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellOrderPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"createBuyOrderAndSettleWithOffChainSellOrderForTokenIds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"protos\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"qualities\",\"type\":\"uint256[]\"}],\"name\":\"createBuyOrders\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"orderData\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellOrderIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"sellOrderAddresses\",\"type\":\"address[]\"}],\"name\":\"createBuyOrdersAndSettle\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"sellOrderIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellOrderProtos\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellOrderQualities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellOrderPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"createOffChainSignedSellOrdersForProtosAndQualities\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"sellOrderIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellOrderTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellOrderPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"createOffChainSignedSellOrdersForTokenIds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"protos\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"qualities\",\"type\":\"uint256[]\"}],\"name\":\"createSellOrdersForProtosAndQualities\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"sellOrderData\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"buyOrderIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"buyOrderAddresses\",\"type\":\"address[]\"}],\"name\":\"createSellOrdersForProtosAndQualitiesAndSettle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"createSellOrdersForTokenIds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"sellOrderIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"sellOrderAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellOrderPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellOrderTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"buyOrderIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"buyOrderAddresses\",\"type\":\"address[]\"}],\"name\":\"createSellOrdersForTokenIdsAndSettle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"domainTypeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"godsUnchainedCards\",\"outputs\":[{\"internalType\":\"contract GodsUnchainedCards\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"protos\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"qualities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"recoverSellOrderForProtosAndQualities\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"recoverSellOrderForTokenIds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sellOrdersById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"quality\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"settled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"tokenIsSet\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellOrdersForProtosAndQualitiesTypeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellOrdersForTokenIdsTypeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setExchangeFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setPausedTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"buyOrderIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"buyOrderAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellOrderIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"sellOrderAddresses\",\"type\":\"address[]\"}],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"buyOrderIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"buyOrderAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"sellOrderIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"sellOrderAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"settleWithToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CardExchange","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://6d388c89f1847797adede0baf1ab7d6bbe532aff2a1ac53fd41c8f725e40c4cf"}]}