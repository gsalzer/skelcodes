{"status":"1","message":"OK","result":[{"SourceCode":"#------------------------------------------------------------------------------\r\n#\r\n#   Copyright 2019 Fetch.AI Limited\r\n#\r\n#   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n#   you may not use this file except in compliance with the License.\r\n#   You may obtain a copy of the License at\r\n#\r\n#       http://www.apache.org/licenses/LICENSE-2.0\r\n#\r\n#   Unless required by applicable law or agreed to in writing, software\r\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n#   See the License for the specific language governing permissions and\r\n#   limitations under the License.\r\n#\r\n#------------------------------------------------------------------------------\r\nfrom vyper.interfaces import ERC20\r\n\r\nunits: {\r\n    tok: \"smallest ERC20 token unit\",\r\n}\r\n\r\n# maximum possible number of stakers a new auction can specify\r\nMAX_SLOTS: constant(uint256) = 200\r\n# number of blocks during which the auction remains open at reserve price\r\nRESERVE_PRICE_DURATION: constant(uint256) = 25  # number of blocks\r\n# number of seconds before deletion of the contract becomes possible after last lockupEnd() call\r\nDELETE_PERIOD: constant(timedelta) = 60 * (3600 * 24)\r\n# defining the decimals supported in pool rewards per token\r\nREWARD_PER_TOK_DENOMINATOR: constant(uint256(tok)) = 100000\r\n\r\n# Structs\r\nstruct Auction:\r\n    finalPrice: uint256(tok)\r\n    lockupEnd: uint256\r\n    slotsSold: uint256\r\n    start: uint256\r\n    end: uint256\r\n    startStake: uint256(tok)\r\n    reserveStake: uint256(tok)\r\n    declinePerBlock: uint256(tok)\r\n    slotsOnSale: uint256\r\n    rewardPerSlot: uint256(tok)\r\n    uniqueStakers: uint256\r\n\r\nstruct Pledge:\r\n    amount: uint256(tok)\r\n    AID: uint256\r\n    pool: address\r\n\r\nstruct Pool:\r\n    remainingReward: uint256(tok)\r\n    rewardPerTok: uint256(tok)\r\n    AID: uint256\r\n\r\nstruct VirtTokenHolder:\r\n    isHolder: bool\r\n    limit: uint256(tok)\r\n    rewards: uint256(tok)\r\n\r\n# Events\r\nBid: event({AID: uint256, _from: indexed(address), currentPrice: uint256(tok), amount: uint256(tok)})\r\nNewAuction: event({AID: uint256, start: uint256, end: uint256,\r\n    lockupEnd: uint256, startStake: uint256(tok), reserveStake: uint256(tok),\r\n    declinePerBlock: uint256(tok), slotsOnSale: uint256,\r\n    rewardPerSlot: uint256(tok)})\r\nPoolRegistration: event({AID: uint256, _address: address,\r\n    maxStake: uint256(tok), rewardPerTok: uint256(tok)})\r\nNewPledge: event({AID: uint256, _from: indexed(address), operator: address, amount: uint256(tok)})\r\nIncreasedPledge: event({AID: uint256, _from: indexed(address), operator: address, topup: uint256(tok)})\r\nAuctionFinalised: event({AID: uint256, finalPrice: uint256(tok), slotsSold: uint256(tok)})\r\nLockupEnded: event({AID: uint256})\r\nAuctionAborted: event({AID: uint256, rewardsPaid: bool})\r\nSelfStakeWithdrawal: event({_from: indexed(address), amount: uint256(tok)})\r\nPledgeWithdrawal: event({_from: indexed(address), amount: uint256(tok)})\r\n\r\n# Contract state\r\ntoken: ERC20\r\nowner: public(address)\r\nearliestDelete: public(timestamp)\r\n# address -> uint256 Slots a staker has won in the current auction (cleared at endLockup())\r\nstakerSlots: map(address, uint256)\r\n# auction winners\r\nstakers: address[MAX_SLOTS]\r\n\r\n# pledged stake + committed pool reward, excl. selfStakerDeposit; pool -> deposits\r\npoolDeposits: public(map(address, uint256(tok)))\r\n# staker (through pool) -> Pledge{pool, amount}\r\npledges: public(map(address, Pledge))\r\n# staker (directly) -> amount\r\nselfStakerDeposits: public(map(address, uint256(tok)))\r\n# staker (directly) -> price at which the bid was made\r\npriceAtBid: public(map(address, uint256(tok)))\r\n# pool address -> Pool\r\nregisteredPools: public(map(address, Pool))\r\n\r\n# Auction details\r\ncurrentAID: public(uint256)\r\nauction: public(Auction)\r\ntotalAuctionRewards: public(uint256(tok))\r\n\r\n# Virtual token management\r\nvirtTokenHolders: public(map(address, VirtTokenHolder))\r\n\r\n################################################################################\r\n# Constant functions\r\n################################################################################\r\n# @notice True from auction initialisation until either we hit the lower bound on being clear or\r\n#   the auction finalised through finaliseAuction()\r\n@private\r\n@constant\r\ndef _isBiddingPhase() -> bool:\r\n    return ((self.auction.lockupEnd > 0)\r\n            and (block.number < self.auction.end)\r\n            and (self.auction.slotsSold < self.auction.slotsOnSale)\r\n            and (self.auction.finalPrice == 0))\r\n\r\n# @notice Returns true if either the auction has been finalised or the lockup has ended\r\n# @dev self.auction will be cleared in endLockup() call\r\n# @dev reserveStake > 0 condition in initialiseAuction() guarantees that finalPrice = 0 can never be\r\n#   a valid final price\r\n@private\r\n@constant\r\ndef _isFinalised() -> bool:\r\n    return (self.auction.finalPrice > 0) or (self.auction.lockupEnd == 0)\r\n\r\n# @notice Calculate the scheduled, linearly declining price of the dutch auction\r\n@private\r\n@constant\r\ndef _getScheduledPrice() -> uint256(tok):\r\n    startStake_: uint256(tok) = self.auction.startStake\r\n    start: uint256 = self.auction.start\r\n    if (block.number <= start):\r\n        return startStake_\r\n    else:\r\n        # do not calculate max(startStake - decline, reserveStake) as that could throw on negative startStake - decline\r\n        decline: uint256(tok) = min(self.auction.declinePerBlock * (block.number - start),\r\n                                    startStake_ - self.auction.reserveStake)\r\n        return startStake_ - decline\r\n\r\n# @notice Returns the scheduled price of the auction until the auction is finalised. Then returns\r\n#   the final price.\r\n# @dev Auction price declines linearly from auction.start over _duration, then\r\n# stays at _reserveStake for RESERVE_PRICE_DURATION\r\n# @dev Returns zero If no auction is in bidding or lock-up phase\r\n@private\r\n@constant\r\ndef _getCurrentPrice() -> (uint256(tok)):\r\n    if self._isFinalised():\r\n        return self.auction.finalPrice\r\n    else:\r\n        scheduledPrice: uint256(tok) = self._getScheduledPrice()\r\n        return scheduledPrice\r\n\r\n# @notice Returns the lockup needed by an address that stakes directly\r\n# @dev Will throw if _address is a bidder in current auction & auciton not yet finalised, as the\r\n#   slot number & price are not final yet\r\n# @dev Calling endLockup() will clear all stakerSlots flags and thereby set the required\r\n#   lockups to 0 for all participants\r\n@private\r\n@constant\r\ndef _calculateSelfStakeNeeded(_address: address) -> uint256(tok):\r\n    selfStakeNeeded: uint256(tok) = 0\r\n    # these slots can be outdated if auction is not yet finalised / lockup hasn't ended yet\r\n    slotsWon: uint256 = self.stakerSlots[_address]\r\n\r\n    if slotsWon > 0:\r\n        assert self._isFinalised(), \"Is bidder and auction not finalised yet\"\r\n        poolDeposit: uint256(tok) = self.poolDeposits[_address]\r\n        currentPrice: uint256(tok) = self._getCurrentPrice()\r\n\r\n        if (slotsWon * currentPrice) > poolDeposit:\r\n            selfStakeNeeded += (slotsWon * currentPrice) - poolDeposit\r\n    return selfStakeNeeded\r\n\r\n################################################################################\r\n# Main functions\r\n################################################################################\r\n@public\r\ndef __init__(_ERC20Address: address):\r\n    self.owner = msg.sender\r\n    self.token = ERC20(_ERC20Address)\r\n\r\n# @notice Owner can initialise new auctions\r\n# @dev First auction starts with AID 1\r\n# @dev Requires the transfer of _reward to the contract to be approved with the\r\n#   underlying ERC20 token\r\n# @param _start: start of the price decay\r\n# @param _startStake: initial auction price\r\n# @param _reserveStake: lowest possible auction price >= 1\r\n# @param _duration: duration over which the auction price declines. Total bidding\r\n#   duration is _duration + RESERVE_PRICE_DURATION\r\n# @param _lockup_duration: number of blocks the lockup phase will last\r\n# @param _slotsOnSale: size of the assembly in this cycle\r\n# @param _reward: added to any remaining reward of past auctions\r\n@public\r\ndef initialiseAuction(_start: uint256,\r\n                      _startStake: uint256(tok),\r\n                      _reserveStake: uint256(tok),\r\n                      _duration: uint256,\r\n                      _lockup_duration: uint256,\r\n                      _slotsOnSale: uint256,\r\n                      _reward: uint256(tok)):\r\n    assert msg.sender == self.owner, \"Owner only\"\r\n    assert _startStake > _reserveStake, \"Invalid startStake\"\r\n    assert (_slotsOnSale > 0) and (_slotsOnSale <= MAX_SLOTS), \"Invald slot number\"\r\n    assert _start >= block.number, \"Start before current block\"\r\n    # NOTE: _isFinalised() relies on this requirement\r\n    assert _reserveStake > 0, \"Reserve stake has to be at least 1\"\r\n    assert self.auction.lockupEnd == 0, \"End current auction\"\r\n\r\n    self.currentAID += 1\r\n\r\n    # Use integer-ceil() of the fraction with (+ _duration - 1)\r\n    declinePerBlock: uint256(tok) = (_startStake - _reserveStake + _duration - 1) / _duration\r\n    end: uint256 = _start + _duration + RESERVE_PRICE_DURATION\r\n    self.auction.start = _start\r\n    self.auction.end = end\r\n    self.auction.lockupEnd = end + _lockup_duration\r\n    self.auction.startStake = _startStake\r\n    self.auction.reserveStake = _reserveStake\r\n    self.auction.declinePerBlock = declinePerBlock\r\n    self.auction.slotsOnSale = _slotsOnSale\r\n    # Also acts as the last checked price in _updatePrice()\r\n    self.auction.finalPrice = 0\r\n\r\n    # add auction rewards\r\n    self.totalAuctionRewards += _reward\r\n    self.auction.rewardPerSlot = self.totalAuctionRewards / self.auction.slotsOnSale\r\n    success: bool = self.token.transferFrom(msg.sender, self, as_unitless_number(_reward))\r\n    assert success, \"Transfer failed\"\r\n\r\n    log.NewAuction(self.currentAID, _start, end, end + _lockup_duration, _startStake,\r\n                   _reserveStake, declinePerBlock, _slotsOnSale, self.auction.rewardPerSlot)\r\n\r\n# @notice Move unclaimed auction rewards back to the contract owner\r\n# @dev Requires that no auction is in bidding or lockup phase\r\n@public\r\ndef retrieveUndistributedAuctionRewards():\r\n    assert msg.sender == self.owner, \"Owner only\"\r\n    assert self.auction.lockupEnd == 0, \"Auction ongoing\"\r\n    undistributed: uint256(tok) = self.totalAuctionRewards\r\n    clear(self.totalAuctionRewards)\r\n\r\n    success: bool = self.token.transfer(self.owner, as_unitless_number(undistributed))\r\n    assert success, \"Transfer failed\"\r\n\r\n# @notice Enter a bid into the auction. Requires the sender's deposits + _topup >= currentPrice or\r\n#   specify _topup = 0 to automatically calculate and transfer the topup needed to make a bid at the\r\n#   current price. Beforehand the sender must have approved the ERC20 contract to allow the transfer\r\n#   of at least the topup to the auction contract via ERC20.approve(auctionContract.address, amount)\r\n# @param _topup: Set to 0 to bid current price (automatically calculating and transfering required topup),\r\n#   o/w it will be interpreted as a topup to the existing deposits\r\n# @dev Only one bid per address and auction allowed, as time of bidding also specifies the priority\r\n#   in slot allocation\r\n# @dev No bids below current auction price allowed\r\n@public\r\ndef bid(_topup: uint256(tok)):\r\n    assert self._isBiddingPhase(), \"Not in bidding phase\"\r\n    assert self.stakerSlots[msg.sender] == 0, \"Sender already bid\"\r\n\r\n    _currentAID: uint256 = self.currentAID\r\n    currentPrice: uint256(tok) = self._getCurrentPrice()\r\n    _isVirtTokenHolder: bool = self.virtTokenHolders[msg.sender].isHolder\r\n\r\n    assert (_isVirtTokenHolder == False) or (_topup <= self.virtTokenHolders[msg.sender].limit), \"Virtual tokens above limit\"\r\n\r\n    # If pool: move unclaimed rewards and clear\r\n    if self.registeredPools[msg.sender].AID == _currentAID:\r\n        unclaimed: uint256(tok) = self.registeredPools[msg.sender].remainingReward\r\n        clear(self.registeredPools[msg.sender])\r\n        self.poolDeposits[msg.sender] -= unclaimed\r\n        self.selfStakerDeposits[msg.sender] += unclaimed\r\n    # if address was a pool in a previous auction and not the current one: reset poolDeposits\r\n    # do not rely on self.registeredPools[msg.sender].AID as this gets cleared at certain points\r\n    elif self.poolDeposits[msg.sender] > 0:\r\n        clear(self.poolDeposits[msg.sender])\r\n\r\n    totDeposit: uint256(tok) = self.poolDeposits[msg.sender] + self.selfStakerDeposits[msg.sender]\r\n\r\n    # cannot modify input argument\r\n    topup: uint256(tok) = _topup\r\n    if (currentPrice > totDeposit) and(_topup == 0):\r\n        topup = currentPrice - totDeposit\r\n    else:\r\n        assert totDeposit + topup >= currentPrice, \"Bid below current price\"\r\n\r\n    # Update deposits & stakers\r\n    self.priceAtBid[msg.sender] = currentPrice\r\n    self.selfStakerDeposits[msg.sender] += topup\r\n    slots: uint256 = min((totDeposit + topup) / currentPrice, self.auction.slotsOnSale - self.auction.slotsSold)\r\n    self.stakerSlots[msg.sender] = slots\r\n    self.auction.slotsSold += slots\r\n    self.stakers[self.auction.uniqueStakers] = msg.sender\r\n    self.auction.uniqueStakers += 1\r\n\r\n    # Transfer topup if necessary\r\n    if (topup > 0) and (_isVirtTokenHolder == False):\r\n        success: bool = self.token.transferFrom(msg.sender, self, as_unitless_number(topup))\r\n        assert success, \"Transfer failed\"\r\n    log.Bid(_currentAID, msg.sender, currentPrice, totDeposit + topup)\r\n\r\n# @Notice Anyone can supply the correct final price to finalise the auction and calculate the number of slots each\r\n#   staker has won. Required before lock-up can be ended or withdrawals can be made\r\n# @param finalPrice: proposed solution for the final price. Throws if not the correct solution\r\n# @dev Allows to move the calculation of the price that clear the auction off-chain\r\n@public\r\ndef finaliseAuction(finalPrice: uint256(tok)):\r\n    currentPrice: uint256(tok) = self._getCurrentPrice()\r\n    assert finalPrice >= currentPrice, \"Suggested solution below current price\"\r\n    assert self.auction.finalPrice == 0, \"Auction already finalised\"\r\n    assert self.auction.lockupEnd >= 0, \"Lockup has already ended\"\r\n\r\n    slotsOnSale: uint256 = self.auction.slotsOnSale\r\n    slotsRemaining: uint256 = slotsOnSale\r\n    slotsRemainingP1: uint256 = slotsOnSale\r\n    finalPriceP1: uint256(tok) = finalPrice + 1\r\n\r\n    uniqueStakers_int128: int128 = convert(self.auction.uniqueStakers, int128)\r\n    staker: address = ZERO_ADDRESS\r\n    totDeposit: uint256(tok) = 0\r\n    slots: uint256 = 0\r\n    currentSlots: uint256 = 0\r\n    _priceAtBid: uint256(tok)= 0\r\n\r\n    for i in range(MAX_SLOTS):\r\n        if i >= uniqueStakers_int128:\r\n            break\r\n\r\n        staker = self.stakers[i]\r\n        _priceAtBid = self.priceAtBid[staker]\r\n        slots = 0\r\n\r\n        if finalPrice <= _priceAtBid:\r\n            totDeposit = self.selfStakerDeposits[staker] + self.poolDeposits[staker]\r\n\r\n            if slotsRemaining > 0:\r\n                # finalPrice will always be > 0 as reserveStake required to be > 0\r\n                slots = min(totDeposit / finalPrice, slotsRemaining)\r\n                currentSlots = self.stakerSlots[staker]\r\n                if slots != currentSlots:\r\n                    self.stakerSlots[staker] = slots\r\n                slotsRemaining -= slots\r\n\r\n            if finalPriceP1 <= _priceAtBid:\r\n                slotsRemainingP1 -= min(totDeposit / finalPriceP1, slotsRemainingP1)\r\n\r\n        # later bidders dropping out of slot-allocation as earlier bidders already claim all slots at the final price\r\n        if slots == 0:\r\n            clear(self.stakerSlots[staker])\r\n            clear(self.stakers[i])\r\n\r\n    if (finalPrice == self.auction.reserveStake) and (self._isBiddingPhase() == False):\r\n        # a) reserveStake clears the auction and reserveStake + 1 does not\r\n        doesClear: bool = (slotsRemaining == 0) and (slotsRemainingP1 > 0)\r\n        # b) reserveStake does not clear the auction, accordingly neither will any other higher price\r\n        assert (doesClear or (slotsRemaining > 0)), \"reserveStake is not the best solution\"\r\n    else:\r\n        assert slotsRemaining == 0, \"finalPrice does not clear auction\"\r\n        assert slotsRemainingP1 > 0, \"Not largest price clearing the auction\"\r\n\r\n    self.auction.finalPrice = finalPrice\r\n    self.auction.slotsSold = slotsOnSale - slotsRemaining\r\n    log.AuctionFinalised(self.currentAID, finalPrice, slotsOnSale - slotsRemaining)\r\n\r\n# @notice Anyone can end the lock-up of an auction, thereby allowing everyone to\r\n#   withdraw their stakes and rewards. Auction must first be finalised through finaliseAuction().\r\n@private\r\ndef _endLockup(payoutRewards: bool):\r\n    assert self.auction.lockupEnd > 0, \"No lockup to end\"\r\n\r\n    slotsSold: uint256 = self.auction.slotsSold\r\n    rewardPerSlot_: uint256(tok) = 0\r\n    self.earliestDelete = block.timestamp + DELETE_PERIOD\r\n\r\n    if payoutRewards:\r\n        assert self._isFinalised(), \"Not finalised\"\r\n        rewardPerSlot_ = self.auction.rewardPerSlot\r\n        self.totalAuctionRewards -= slotsSold * rewardPerSlot_\r\n\r\n    # distribute rewards & cleanup\r\n    staker: address = ZERO_ADDRESS\r\n\r\n    for i in range(MAX_SLOTS):\r\n        staker = self.stakers[i]\r\n        if staker == ZERO_ADDRESS:\r\n            break\r\n\r\n        if payoutRewards:\r\n            if self.virtTokenHolders[staker].isHolder:\r\n                self.virtTokenHolders[staker].rewards += self.stakerSlots[staker] * rewardPerSlot_\r\n            else:\r\n                self.selfStakerDeposits[staker] += self.stakerSlots[staker] * rewardPerSlot_\r\n\r\n        clear(self.stakerSlots[staker])\r\n        if self.virtTokenHolders[staker].isHolder:\r\n            clear(self.selfStakerDeposits[staker])\r\n\r\n    clear(self.stakers)\r\n    clear(self.auction)\r\n\r\n@public\r\ndef endLockup():\r\n    # Prevents repeated calls of this function as self.auction will get reset here\r\n    assert self.auction.finalPrice > 0, \"Auction not finalised yet or no auction to end\"\r\n    assert block.number >= self.auction.lockupEnd, \"Lockup not over\"\r\n    self._endLockup(True)\r\n    log.LockupEnded(self.currentAID)\r\n\r\n# @notice The owner can clear the auction and all recorded slots in the case of an emergency and\r\n# thereby immediately lift any lockups and allow the immediate withdrawal of any made deposits.\r\n# @param payoutRewards: whether rewards get distributed to bidders\r\n@public\r\ndef abortAuction(payoutRewards: bool):\r\n    assert msg.sender == self.owner, \"Owner only\"\r\n\r\n    self._endLockup(payoutRewards)\r\n    log.AuctionAborted(self.currentAID, payoutRewards)\r\n\r\n# @param AID: auction ID, has to match self.currentAID\r\n# @param _totalReward: total reward committed to stakers, has to be paid upon\r\n#   calling this and be approved with the ERC20 token\r\n# @param _rewardPerTok: _rewardPerTok / REWARD_PER_TOK_DENOMINATOR will be paid\r\n#   for each stake pledged to the pool. Meaning _rewardPerTok should equal\r\n#   reward per token * REWARD_PER_TOK_DENOMINATOR (see getDenominator())\r\n@public\r\ndef registerPool(AID: uint256,\r\n                 _totalReward: uint256(tok),\r\n                 _rewardPerTok: uint256(tok)):\r\n    assert AID == self.currentAID, \"Not current auction\"\r\n    assert self._isBiddingPhase(), \"Not in bidding phase\"\r\n    assert self.registeredPools[msg.sender].AID < AID, \"Pool already exists\"\r\n    assert self.registeredPools[msg.sender].remainingReward == 0, \"Unclaimed rewards\"\r\n    assert self.virtTokenHolders[msg.sender].isHolder == False, \"Not allowed for virtTokenHolders\"\r\n\r\n    self.registeredPools[msg.sender] = Pool({remainingReward: _totalReward,\r\n                                             rewardPerTok: _rewardPerTok,\r\n                                             AID: AID})\r\n    # overwrite any poolDeposits that existed for the last auction\r\n    self.poolDeposits[msg.sender] = _totalReward\r\n\r\n    success: bool = self.token.transferFrom(msg.sender, self, as_unitless_number(_totalReward))\r\n    assert success, \"Transfer failed\"\r\n\r\n    maxStake: uint256(tok) = (_totalReward * REWARD_PER_TOK_DENOMINATOR) / _rewardPerTok\r\n    log.PoolRegistration(AID, msg.sender, maxStake, _rewardPerTok)\r\n\r\n# @notice Move pool rewards that were not claimed by anyone into\r\n#   selfStakerDeposits. Automatically done if pool enters a bid.\r\n# @dev Requires that the auction has passed the bidding phase\r\n@public\r\ndef retrieveUnclaimedPoolRewards():\r\n    assert ((self._isBiddingPhase() == False)\r\n             or (self.registeredPools[msg.sender].AID < self.currentAID)), \"Bidding phase of AID not over\"\r\n\r\n    unclaimed: uint256(tok) = self.registeredPools[msg.sender].remainingReward\r\n    clear(self.registeredPools[msg.sender])\r\n\r\n    self.poolDeposits[msg.sender] -= unclaimed\r\n    self.selfStakerDeposits[msg.sender] += unclaimed\r\n\r\n@private\r\ndef _updatePoolRewards(pool: address, newAmount: uint256(tok)) -> uint256(tok):\r\n    newReward: uint256(tok) = ((self.registeredPools[pool].rewardPerTok * newAmount)\r\n                                / REWARD_PER_TOK_DENOMINATOR)\r\n    assert self.registeredPools[pool].remainingReward >= newReward, \"Rewards depleted\"\r\n    self.registeredPools[pool].remainingReward -= newReward\r\n    return newReward\r\n\r\n# @notice Pledge stake to a staking pool. Possible from auction intialisation\r\n#   until the end of the bidding phase or until the pool has made a bid.\r\n#   Stake from the last auction can be taken over to the next auction. If amount\r\n#   exceeds the previous stake, this contract must be approved with the ERC20 token\r\n#   to transfer the difference to this contract.\r\n# @dev Only one pledge per address and auction allowed\r\n# @dev If decreasing the pledge, the difference is immediately paid out\r\n# @dev If the pool operator has already bid, this will throw with \"Rewards depleted\"\r\n# @param AID: The auction ID\r\n# @param pool: The address of the pool\r\n# @param amount: The new total amount, not the difference to existing pledges. If increasing the\r\n#   pledge, this has to include the pool rewards of the initial pledge\r\n@public\r\ndef pledgeStake(AID: uint256, pool: address, amount: uint256(tok)):\r\n    assert AID == self.currentAID, \"Not current AID\"\r\n    assert self._isBiddingPhase(), \"Not in bidding phase\"\r\n    assert self.registeredPools[pool].AID == AID, \"Not a registered pool\"\r\n    assert self.virtTokenHolders[msg.sender].isHolder == False, \"Not allowed for virtTokenHolders\"\r\n\r\n    existingPledgeAmount: uint256(tok) = self.pledges[msg.sender].amount\r\n    assert self.pledges[msg.sender].AID < AID, \"Already pledged\"\r\n\r\n    newReward: uint256(tok) = self._updatePoolRewards(pool, amount)\r\n\r\n    # overwriting any existing amount\r\n    self.pledges[msg.sender] = Pledge({amount: amount + newReward,\r\n                                                  AID: AID,\r\n                                                  pool: pool})\r\n    # pool reward is already added to poolDeposits during registerPool() call\r\n    self.poolDeposits[pool] += amount\r\n\r\n    if amount > existingPledgeAmount:\r\n        success: bool = self.token.transferFrom(msg.sender, self, as_unitless_number(amount - existingPledgeAmount))\r\n        assert success, \"Transfer failed\"\r\n    elif amount < existingPledgeAmount:\r\n        success: bool = self.token.transfer(msg.sender, as_unitless_number(existingPledgeAmount - amount))\r\n        assert success, \"Transfer failed\"\r\n\r\n    log.NewPledge(AID, msg.sender, pool, amount)\r\n\r\n# @notice Increase an existing pledge in the current auction\r\n# @dev Requires the auction to be in bidding phase and the pool to have enough rewards remaining\r\n# @param pool: The address of the pool. Has to match the pool of the initial pledge\r\n# @param topup: Value by which to increase the pledge\r\n@public\r\ndef increasePledge(pool: address, topup: uint256(tok)):\r\n    AID: uint256 = self.currentAID\r\n    assert self._isBiddingPhase(), \"Not in bidding phase\"\r\n    assert self.pledges[msg.sender].AID == AID, \"No pledge made in this auction yet\"\r\n    assert self.pledges[msg.sender].pool == pool, \"Cannot change pool\"\r\n\r\n    newReward: uint256(tok) = self._updatePoolRewards(pool, topup)\r\n    self.pledges[msg.sender].amount += topup + newReward\r\n    self.poolDeposits[pool] += topup\r\n\r\n    success: bool = self.token.transferFrom(msg.sender, self, as_unitless_number(topup))\r\n    assert success, \"Transfer failed\"\r\n\r\n    log.IncreasedPledge(AID, msg.sender, pool, topup)\r\n\r\n# @notice Withdraw any self-stake exceeding the required lockup. In case sender is a bidder in the\r\n#   current auction, this requires the auction to be finalised through finaliseAuction(),\r\n#   o/w _calculateSelfStakeNeeded() will throw\r\n@public\r\ndef withdrawSelfStake() -> uint256(tok):\r\n    # not guaranteed to be initialised to 0 without setting it explicitly\r\n    withdrawal: uint256(tok) = 0\r\n\r\n    if self.virtTokenHolders[msg.sender].isHolder:\r\n        withdrawal = self.virtTokenHolders[msg.sender].rewards\r\n        clear(self.virtTokenHolders[msg.sender].rewards)\r\n    else:\r\n        selfStake: uint256(tok) = self.selfStakerDeposits[msg.sender]\r\n        selfStakeNeeded: uint256(tok) = self._calculateSelfStakeNeeded(msg.sender)\r\n\r\n        if selfStake > selfStakeNeeded:\r\n            withdrawal = selfStake - selfStakeNeeded\r\n            self.selfStakerDeposits[msg.sender] -= withdrawal\r\n        elif selfStake < selfStakeNeeded:\r\n            assert False, \"Critical failure\"\r\n\r\n    success: bool = self.token.transfer(msg.sender, as_unitless_number(withdrawal))\r\n    assert success, \"Transfer failed\"\r\n\r\n    log.SelfStakeWithdrawal(msg.sender, withdrawal)\r\n\r\n    return withdrawal\r\n\r\n# @notice Withdraw pledged stake after the lock-up has ended\r\n@public\r\ndef withdrawPledgedStake() -> uint256(tok):\r\n    withdrawal: uint256(tok) = 0\r\n    if ((self.pledges[msg.sender].AID < self.currentAID)\r\n        or (self.auction.lockupEnd == 0)):\r\n        withdrawal += self.pledges[msg.sender].amount\r\n        clear(self.pledges[msg.sender])\r\n\r\n    success: bool = self.token.transfer(msg.sender, as_unitless_number(withdrawal))\r\n    assert success, \"Transfer failed\"\r\n\r\n    log.PledgeWithdrawal(msg.sender, withdrawal)\r\n\r\n    return withdrawal\r\n\r\n# @notice Allow the owner to remove the contract, given that no auction is\r\n#   active and at least DELETE_PERIOD blocks have past since the last lock-up end.\r\n@public\r\ndef deleteContract():\r\n    assert msg.sender == self.owner, \"Owner only\"\r\n    assert self.auction.lockupEnd == 0, \"In lockup phase\"\r\n    assert block.timestamp >= self.earliestDelete, \"earliestDelete not reached\"\r\n\r\n    contractBalance: uint256 = self.token.balanceOf(self)\r\n    success: bool = self.token.transfer(self.owner, contractBalance)\r\n    assert success, \"Transfer failed\"\r\n\r\n    selfdestruct(self.owner)\r\n\r\n# @notice Allow the owner to set virtTokenHolder status for addresses, allowing them to participate\r\n#   with virtual tokens\r\n# @dev Throws if the address has existing selfStakerDeposits, active slots, a registered pool for\r\n#   this auction, unretrieved pool rewards or existing pledges\r\n# @param _address: address for which to set the value\r\n# @param _isVirtTokenHolder: new value indicating whether isVirtTokenHolder or not\r\n# @param preserveRewards: if setting isVirtTokenHolder to false and that address still has remaining rewards:\r\n#   whether to move those rewards into selfStakerDeposits or to add them back to the control of the owner\r\n#   by adding them to totalAuctionRewards\r\n@public\r\ndef setVirtTokenHolder(_address: address, _isVirtTokenHolder: bool, limit: uint256(tok), preserveRewards: bool):\r\n    assert msg.sender == self.owner, \"Owner only\"\r\n    assert self.stakerSlots[_address] == 0, \"Address has active slots\"\r\n    assert self.selfStakerDeposits[_address] == 0, \"Address has positive selfStakerDeposits\"\r\n    assert self.registeredPools[_address].remainingReward == 0, \"Address has remainingReward\"\r\n    assert self.pledges[_address].amount == 0, \"Address has positive pledges\"\r\n    assert (self.registeredPools[_address].AID < self.currentAID) or (self.auction.finalPrice == 0), \"Address has a pool in ongoing auction\"\r\n\r\n    existingRewards: uint256(tok) = self.virtTokenHolders[_address].rewards\r\n\r\n    if (_isVirtTokenHolder == False) and (existingRewards > 0):\r\n        if preserveRewards:\r\n            self.selfStakerDeposits[_address] += existingRewards\r\n        else:\r\n            self.totalAuctionRewards += existingRewards\r\n        clear(self.virtTokenHolders[_address].rewards)\r\n\r\n    self.virtTokenHolders[_address].isHolder = _isVirtTokenHolder\r\n    self.virtTokenHolders[_address].limit = limit\r\n\r\n@public\r\ndef setVirtTokenLimit(_address: address, _virtTokenLimit: uint256(tok)):\r\n    assert msg.sender == self.owner, \"Owner only\"\r\n    assert self.virtTokenHolders[_address].isHolder, \"Not a virtTokenHolder\"\r\n    self.virtTokenHolders[_address].limit = _virtTokenLimit\r\n\r\n################################################################################\r\n# Getters\r\n################################################################################\r\n@public\r\n@constant\r\ndef getERC20Address() -> address:\r\n    return self.token\r\n\r\n@public\r\n@constant\r\ndef getDenominator() -> uint256(tok):\r\n    return REWARD_PER_TOK_DENOMINATOR\r\n\r\n@public\r\n@constant\r\ndef getFinalStakerSlots(staker: address) -> uint256:\r\n    assert self._isFinalised(), \"Slots not yet final\"\r\n    return self.stakerSlots[staker]\r\n\r\n# @dev Always returns an array of MAX_SLOTS with elements > unique bidders = zero\r\n@public\r\n@constant\r\ndef getFinalStakers() -> address[MAX_SLOTS]:\r\n    assert self._isFinalised(), \"Stakers not yet final\"\r\n    return self.stakers\r\n\r\n@public\r\n@constant\r\ndef getFinalSlotsSold() -> uint256:\r\n    assert self._isFinalised(), \"Slots not yet final\"\r\n    return self.auction.slotsSold\r\n\r\n@public\r\n@constant\r\ndef isBiddingPhase() -> bool:\r\n    return self._isBiddingPhase()\r\n\r\n@public\r\n@constant\r\ndef isFinalised() -> bool:\r\n    return self._isFinalised()\r\n\r\n@public\r\n@constant\r\ndef getCurrentPrice() -> uint256(tok):\r\n    return self._getCurrentPrice()\r\n\r\n@public\r\n@constant\r\ndef calculateSelfStakeNeeded(_address: address) -> uint256(tok):\r\n    return self._calculateSelfStakeNeeded(_address)","ABI":"[{\"name\":\"Bid\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"AID\",\"indexed\":false},{\"type\":\"address\",\"name\":\"_from\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"currentPrice\",\"indexed\":false,\"unit\":\"smallest ERC20 token unit\"},{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":false,\"unit\":\"smallest ERC20 token unit\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewAuction\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"AID\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"start\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"end\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"lockupEnd\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"startStake\",\"indexed\":false,\"unit\":\"smallest ERC20 token unit\"},{\"type\":\"uint256\",\"name\":\"reserveStake\",\"indexed\":false,\"unit\":\"smallest ERC20 token unit\"},{\"type\":\"uint256\",\"name\":\"declinePerBlock\",\"indexed\":false,\"unit\":\"smallest ERC20 token unit\"},{\"type\":\"uint256\",\"name\":\"slotsOnSale\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"rewardPerSlot\",\"indexed\":false,\"unit\":\"smallest ERC20 token unit\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PoolRegistration\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"AID\",\"indexed\":false},{\"type\":\"address\",\"name\":\"_address\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"maxStake\",\"indexed\":false,\"unit\":\"smallest ERC20 token unit\"},{\"type\":\"uint256\",\"name\":\"rewardPerTok\",\"indexed\":false,\"unit\":\"smallest ERC20 token unit\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewPledge\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"AID\",\"indexed\":false},{\"type\":\"address\",\"name\":\"_from\",\"indexed\":true},{\"type\":\"address\",\"name\":\"operator\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":false,\"unit\":\"smallest ERC20 token unit\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"IncreasedPledge\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"AID\",\"indexed\":false},{\"type\":\"address\",\"name\":\"_from\",\"indexed\":true},{\"type\":\"address\",\"name\":\"operator\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"topup\",\"indexed\":false,\"unit\":\"smallest ERC20 token unit\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AuctionFinalised\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"AID\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"finalPrice\",\"indexed\":false,\"unit\":\"smallest ERC20 token unit\"},{\"type\":\"uint256\",\"name\":\"slotsSold\",\"indexed\":false,\"unit\":\"smallest ERC20 token unit\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"LockupEnded\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"AID\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AuctionAborted\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"AID\",\"indexed\":false},{\"type\":\"bool\",\"name\":\"rewardsPaid\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SelfStakeWithdrawal\",\"inputs\":[{\"type\":\"address\",\"name\":\"_from\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":false,\"unit\":\"smallest ERC20 token unit\"}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PledgeWithdrawal\",\"inputs\":[{\"type\":\"address\",\"name\":\"_from\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"amount\",\"indexed\":false,\"unit\":\"smallest ERC20 token unit\"}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_ERC20Address\"}],\"constant\":false,\"payable\":false,\"type\":\"constructor\"},{\"name\":\"initialiseAuction\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_start\"},{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"_startStake\"},{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"_reserveStake\"},{\"type\":\"uint256\",\"name\":\"_duration\"},{\"type\":\"uint256\",\"name\":\"_lockup_duration\"},{\"type\":\"uint256\",\"name\":\"_slotsOnSale\"},{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"_reward\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":386617},{\"name\":\"retrieveUndistributedAuctionRewards\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":24221},{\"name\":\"bid\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"_topup\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":369528},{\"name\":\"finaliseAuction\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"finalPrice\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":15978961},{\"name\":\"endLockup\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":20437323},{\"name\":\"abortAuction\",\"outputs\":[],\"inputs\":[{\"type\":\"bool\",\"name\":\"payoutRewards\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":20437346},{\"name\":\"registerPool\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"AID\"},{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"_totalReward\"},{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"_rewardPerTok\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":151050},{\"name\":\"retrieveUnclaimedPoolRewards\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":135436},{\"name\":\"pledgeStake\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"AID\"},{\"type\":\"address\",\"name\":\"pool\"},{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"amount\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":191684},{\"name\":\"increasePledge\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"pool\"},{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"topup\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":121144},{\"name\":\"withdrawSelfStake\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":67110},{\"name\":\"withdrawPledgedStake\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":67296},{\"name\":\"deleteContract\",\"outputs\":[],\"inputs\":[],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":31694},{\"name\":\"setVirtTokenHolder\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"},{\"type\":\"bool\",\"name\":\"_isVirtTokenHolder\"},{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"limit\"},{\"type\":\"bool\",\"name\":\"preserveRewards\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":131408},{\"name\":\"setVirtTokenLimit\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"},{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"_virtTokenLimit\"}],\"constant\":false,\"payable\":false,\"type\":\"function\",\"gas\":37031},{\"name\":\"getERC20Address\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1173},{\"name\":\"getDenominator\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1003},{\"name\":\"getFinalStakerSlots\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"staker\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2477},{\"name\":\"getFinalStakers\",\"outputs\":[{\"type\":\"address[200]\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":61486},{\"name\":\"getFinalSlotsSold\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2461},{\"name\":\"isBiddingPhase\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2920},{\"name\":\"isFinalised\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2093},{\"name\":\"getCurrentPrice\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":11191},{\"name\":\"calculateSelfStakeNeeded\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":26540},{\"name\":\"owner\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1443},{\"name\":\"earliestDelete\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"sec\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1473},{\"name\":\"poolDeposits\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1657},{\"name\":\"pledges__amount\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1759},{\"name\":\"pledges__AID\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1795},{\"name\":\"pledges__pool\",\"outputs\":[{\"type\":\"address\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1825},{\"name\":\"selfStakerDeposits\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1777},{\"name\":\"priceAtBid\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1807},{\"name\":\"registeredPools__remainingReward\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1909},{\"name\":\"registeredPools__rewardPerTok\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1945},{\"name\":\"registeredPools__AID\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1975},{\"name\":\"currentAID\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1773},{\"name\":\"auction__finalPrice\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1875},{\"name\":\"auction__lockupEnd\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1911},{\"name\":\"auction__slotsSold\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1941},{\"name\":\"auction__start\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":1971},{\"name\":\"auction__end\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2001},{\"name\":\"auction__startStake\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2031},{\"name\":\"auction__reserveStake\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2061},{\"name\":\"auction__declinePerBlock\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2091},{\"name\":\"auction__slotsOnSale\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2121},{\"name\":\"auction__rewardPerSlot\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2151},{\"name\":\"auction__uniqueStakers\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2181},{\"name\":\"totalAuctionRewards\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2133},{\"name\":\"virtTokenHolders__isHolder\",\"outputs\":[{\"type\":\"bool\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2389},{\"name\":\"virtTokenHolders__limit\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2425},{\"name\":\"virtTokenHolders__rewards\",\"outputs\":[{\"type\":\"uint256\",\"unit\":\"smallest ERC20 token unit\",\"name\":\"out\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"constant\":true,\"payable\":false,\"type\":\"function\",\"gas\":2455}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.1.0b12","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000001d287cc25dad7ccaf76a26bc660c5f7c8e2a05bd","Library":"","LicenseType":"Apache-2.0","SwarmSource":""}]}