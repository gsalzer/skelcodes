{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/**\r\n * @title A contract with an owner.\r\n * @notice Contract ownership can be transferred by first nominating the new owner,\r\n * who must then accept the ownership, which prevents accidental incorrect ownership transfers.\r\n */\r\ncontract Owned {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    /**\r\n     * @dev Owned Constructor\r\n     */\r\n    constructor(address _owner)\r\n        public\r\n    {\r\n        require(_owner != address(0), \"Owner address cannot be 0\");\r\n        owner = _owner;\r\n        emit OwnerChanged(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Nominate a new owner of this contract.\r\n     * @dev Only the current owner may nominate a new owner.\r\n     */\r\n    function nominateNewOwner(address _owner)\r\n        external\r\n        onlyOwner\r\n    {\r\n        nominatedOwner = _owner;\r\n        emit OwnerNominated(_owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Accept the nomination to be owner.\r\n     */\r\n    function acceptOwnership()\r\n        external\r\n    {\r\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\r\n        emit OwnerChanged(owner, nominatedOwner);\r\n        owner = nominatedOwner;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner\r\n    {\r\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\r\n        _;\r\n    }\r\n\r\n    event OwnerNominated(address newOwner);\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n}\r\n\r\n\r\ncontract ISynthetixState {\r\n    // A struct for handing values associated with an individual user's debt position\r\n    struct IssuanceData {\r\n        // Percentage of the total debt owned at the time\r\n        // of issuance. This number is modified by the global debt\r\n        // delta array. You can figure out a user's exit price and\r\n        // collateralisation ratio using a combination of their initial\r\n        // debt and the slice of global debt delta which applies to them.\r\n        uint initialDebtOwnership;\r\n        // This lets us know when (in relative terms) the user entered\r\n        // the debt pool so we can calculate their exit price and\r\n        // collateralistion ratio\r\n        uint debtEntryIndex;\r\n    }\r\n\r\n    uint[] public debtLedger;\r\n    uint public issuanceRatio;\r\n    mapping(address => IssuanceData) public issuanceData;\r\n\r\n    function debtLedgerLength() external view returns (uint);\r\n    function hasIssued(address account) external view returns (bool);\r\n    function incrementTotalIssuerCount() external;\r\n    function decrementTotalIssuerCount() external;\r\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership) external;\r\n    function lastDebtLedgerEntry() external view returns (uint);\r\n    function appendDebtLedgerValue(uint value) external;\r\n    function clearIssuanceData(address account) external;\r\n}\r\n\r\n\r\ninterface ISynth {\r\n  function burn(address account, uint amount) external;\r\n  function issue(address account, uint amount) external;\r\n  function transfer(address to, uint value) public returns (bool);\r\n  function triggerTokenFallbackIfNeeded(address sender, address recipient, uint amount) external;\r\n  function transferFrom(address from, address to, uint value) public returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title SynthetixEscrow interface\r\n */\r\ninterface ISynthetixEscrow {\r\n    function balanceOf(address account) public view returns (uint);\r\n    function appendVestingEntry(address account, uint quantity) public;\r\n}\r\n\r\n\r\ncontract IFeePool {\r\n    address public FEE_ADDRESS;\r\n    uint public exchangeFeeRate;\r\n    function amountReceivedFromExchange(uint value) external view returns (uint);\r\n    function amountReceivedFromTransfer(uint value) external view returns (uint);\r\n    function feePaid(bytes4 currencyKey, uint amount) external;\r\n    function appendAccountIssuanceRecord(address account, uint lockedAmount, uint debtEntryIndex) external;\r\n    function rewardsMinted(uint amount) external;\r\n    function transferFeeIncurred(uint value) public view returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * @title ExchangeRates interface\r\n */\r\ninterface IExchangeRates {\r\n    function effectiveValue(bytes4 sourceCurrencyKey, uint sourceAmount, bytes4 destinationCurrencyKey) public view returns (uint);\r\n\r\n    function rateForCurrency(bytes4 currencyKey) public view returns (uint);\r\n\r\n    function anyRateIsStale(bytes4[] currencyKeys) external view returns (bool);\r\n\r\n    function rateIsStale(bytes4 currencyKey) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title Synthetix interface contract\r\n * @dev pseudo interface, actually declared as contract to hold the public getters \r\n */\r\n\r\n\r\ncontract ISynthetix {\r\n\r\n    // ========== PUBLIC STATE VARIABLES ==========\r\n\r\n    IFeePool public feePool;\r\n    ISynthetixEscrow public escrow;\r\n    ISynthetixEscrow public rewardEscrow;\r\n    ISynthetixState public synthetixState;\r\n    IExchangeRates public exchangeRates;\r\n\r\n    // ========== PUBLIC FUNCTIONS ==========\r\n\r\n    function balanceOf(address account) public view returns (uint);\r\n    function transfer(address to, uint value) public returns (bool);\r\n    function effectiveValue(bytes4 sourceCurrencyKey, uint sourceAmount, bytes4 destinationCurrencyKey) public view returns (uint);\r\n\r\n    function synthInitiatedFeePayment(address from, bytes4 sourceCurrencyKey, uint sourceAmount) external returns (bool);\r\n    function synthInitiatedExchange(\r\n        address from,\r\n        bytes4 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes4 destinationCurrencyKey,\r\n        address destinationAddress) external returns (bool);\r\n    function exchange(\r\n        bytes4 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes4 destinationCurrencyKey,\r\n        address destinationAddress) external returns (bool);\r\n    function collateralisationRatio(address issuer) public view returns (uint);\r\n    function totalIssuedSynths(bytes4 currencyKey)\r\n        public\r\n        view\r\n        returns (uint);\r\n    function getSynth(bytes4 currencyKey) public view returns (ISynth);\r\n    function debtBalanceOf(address issuer, bytes4 currencyKey) public view returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract IERC20 {\r\n    function totalSupply() public view returns (uint);\r\n\r\n    function balanceOf(address owner) public view returns (uint);\r\n\r\n    function allowance(address owner, address spender) public view returns (uint);\r\n\r\n    function transfer(address to, uint value) public returns (bool);\r\n\r\n    function approve(address spender, uint value) public returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) public returns (bool);\r\n\r\n    // ERC20 Optional\r\n    function name() public view returns (string);\r\n    function symbol() public view returns (string);\r\n    function decimals() public view returns (uint8);\r\n\r\n    event Transfer(\r\n      address indexed from,\r\n      address indexed to,\r\n      uint value\r\n    );\r\n\r\n    event Approval(\r\n      address indexed owner,\r\n      address indexed spender,\r\n      uint value\r\n    );\r\n}\r\n\r\n\r\n/* TokenExchanger.sol: Used for testing contract to contract calls on chain \r\n * with Synthetix for testing ERC20 compatability\r\n */\r\n\r\n\r\ncontract TokenExchanger is Owned {\r\n\r\n    address public integrationProxy;\r\n    address public synthetix;\r\n\r\n    constructor(address _owner, address _integrationProxy)\r\n        Owned(_owner)\r\n        public\r\n    {\r\n        integrationProxy = _integrationProxy;\r\n    }\r\n\r\n    function setSynthetixProxy(address _integrationProxy)\r\n        external\r\n        onlyOwner\r\n    {\r\n        integrationProxy = _integrationProxy;\r\n    }\r\n\r\n    function setSynthetix(address _synthetix)\r\n        external\r\n        onlyOwner\r\n    {\r\n        synthetix = _synthetix;\r\n    }\r\n\r\n    function checkBalance(address account)\r\n        public\r\n        view\r\n        synthetixProxyIsSet\r\n        returns (uint)\r\n    {\r\n        return IERC20(integrationProxy).balanceOf(account);\r\n    }\r\n\r\n    function checkAllowance(address tokenOwner, address spender)\r\n        public\r\n        view\r\n        synthetixProxyIsSet\r\n        returns (uint)\r\n    {\r\n        return IERC20(integrationProxy).allowance(tokenOwner, spender);\r\n    }\r\n\r\n    function checkBalanceSNXDirect(address account)\r\n        public\r\n        view\r\n        synthetixProxyIsSet\r\n        returns (uint)\r\n    {\r\n        return IERC20(synthetix).balanceOf(account);\r\n    }\r\n\r\n    function getDecimals(address tokenAddress)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return IERC20(tokenAddress).decimals();\r\n    }\r\n\r\n    function doTokenSpend(address fromAccount, address toAccount, uint amount)\r\n        public\r\n        synthetixProxyIsSet\r\n        returns (bool)\r\n    {\r\n        // Call Immutable static call #1\r\n        require(checkBalance(fromAccount) > amount, \"fromAccount does not have the required balance to spend\");\r\n\r\n        // Call Immutable static call #2\r\n        require(checkAllowance(fromAccount, address(this)) > amount, \"I TokenExchanger, do not have approval to spend this guys tokens\");\r\n\r\n        // Call Mutable call\r\n        return IERC20(integrationProxy).transferFrom(fromAccount, toAccount, amount);\r\n    }\r\n\r\n    modifier synthetixProxyIsSet {\r\n        require(integrationProxy != address(0), \"Synthetix Integration proxy address not set\");\r\n        _;\r\n    }\r\n\r\n    event LogString(string name, string value);\r\n    event LogInt(string name, uint value);\r\n    event LogAddress(string name, address value);\r\n    event LogBytes(string name, bytes4 value);\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromAccount\",\"type\":\"address\"},{\"name\":\"toAccount\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"doTokenSpend\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"checkBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthetix\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"checkAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_integrationProxy\",\"type\":\"address\"}],\"name\":\"setSynthetixProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"integrationProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"checkBalanceSNXDirect\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_synthetix\",\"type\":\"address\"}],\"name\":\"setSynthetix\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_integrationProxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"string\"}],\"name\":\"LogString\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogInt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"address\"}],\"name\":\"LogAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"bytes4\"}],\"name\":\"LogBytes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"}]","ContractName":"TokenExchanger","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b64ff7a4a33acdf48d97dab0d764afd0f6176882000000000000000000000000c011a72400e58ecd99ee497cf89e3775d4bd732f","Library":"","SwarmSource":"bzzr://618bd60c84b1b22d992f4067daa3817547d6488cd4a93639544a385bd8a43253"}]}