{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.8;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\n/**\\n * @title ERC20Basic\\n * @dev Simpler version of ERC20 interface\\n */\\ncontract ERC20Basic {\\n  uint256 public totalSupply;\\n  uint256 public currentSupply;\\n  address public master;\\n  function balanceOf(address who) external view returns (uint256);\\n  function transfer(address to, uint256 value) external;\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\n/**\\n * @title Basic token\\n * @dev Basic version of StandardToken, with no allowances.\\n */\\ncontract BasicToken is ERC20Basic {\\n  using SafeMath for uint256;\\n  mapping(address =\\u003e uint256) balances;\\n\\n  /**\\n   * @dev Fix for the ERC20 short address attack.\\n   */\\n  modifier onlyPayloadSize(uint256 size) {\\n     if(msg.data.length \\u003c size + 4) {\\n       revert();\\n     }\\n     _;\\n  }\\n\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return An uint256 representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) external view returns (uint256 balance) {\\n    return balances[_owner];\\n  }\\n}\\n\\n/**\\n * @title ERC20 interface\\n */\\ncontract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function transferFrom(address from, address to, uint256 value) external;\\n  function approve(address spender, uint256 value) external;\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implemantation of the basic standart token.\\n */\\ncontract StandardToken is BasicToken, ERC20 {\\n\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint256 the amout of tokens to be transfered\\n   */\\n  function transferFrom(address _from, address _to, uint256 _value) external onlyPayloadSize(3 * 32) {\\n    uint256 _allowance = allowed[_from][msg.sender];\\n\\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\\n    // if (_value \\u003e _allowance) throw;\\n\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n  }\\n\\n  /**\\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint256 _value) external {\\n\\n    // To change the approve amount you first have to reduce the addresses`\\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\\n    //  already 0 to mitigate the race condition described here:\\n    if ((_value != 0) \\u0026\\u0026 (allowed[msg.sender][_spender] != 0)) revert();\\n\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n  }\\n\\n  /**\\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\\n   */\\n  function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n}\\n\"},\"Invitation.sol\":{\"content\":\"pragma solidity ^0.5.8;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\ncontract InvitationBasic {\\n    function signUp(address referrer, address addr, uint256 phase, uint256 ePhase) external;\\n    function getParent(address addr) external view returns(address);\\n    function getAncestors(address addr) external view returns(address[] memory);\\n    function isRoot(address addr) external view returns (bool);\\n    function isSignedUp(address addr) public view returns (bool);\\n    function newRoot(address addr, uint256 phase) external;\\n    function newSignupCount(uint256 phase) external view returns (uint);\\n    function getPoints(uint256 phase, address addr) external view returns (uint256);\\n    function getTop(uint256 phase) external view returns(address[] memory);\\n    function distributeBonus(uint256 len) external pure returns(uint256[] memory);\\n}\\n\\ncontract Invitation is InvitationBasic {\\n    using SafeMath for uint256;\\n\\n    /*\\n     * STATES\\n     */\\n    address public master;\\n    address public caller;\\n\\n    bool public paused;\\n\\n    mapping (address =\\u003e bool) public rootList;\\n    mapping (address =\\u003e address) public referenceParentList;\\n    mapping (address =\\u003e address[]) public referenceChildList;\\n    mapping (uint256 =\\u003e mapping (address =\\u003e uint256)) public addressPoints;\\n    mapping (uint256 =\\u003e address[]) public newSignupList;\\n    mapping (uint256 =\\u003e address[]) public inviterList;\\n    mapping (uint256 =\\u003e address[]) public top;\\n\\n    uint maxChildrenCount = 0;\\n    uint256 basePoints = 100000;\\n    uint256 pointRate = 0;\\n    uint256 maxPointLevel = 10;\\n    uint256 winnerCount = 10;\\n\\n    /*\\n     * MODIFIERS\\n     */\\n    /// only master can call the function\\n    modifier onlyOwner {\\n        require(master == msg.sender, \\\"only owner can call\\\");\\n        _;\\n    }\\n\\n    /// only master can call the function\\n    modifier onlyCaller {\\n        require(caller == msg.sender, \\\"only caller can call\\\");\\n        _;\\n    }\\n\\n    /// function not paused\\n    modifier notPaused {\\n        require(paused == false, \\\"function is paused\\\");\\n        _;\\n    }\\n\\n    function setPause(bool value) external onlyOwner {\\n        paused = value;\\n    }\\n\\n    function setWinnerCount(uint256 _count) external onlyOwner {\\n        winnerCount = _count;\\n    }\\n\\n    function isSignedUp(address addr) public view returns (bool) {\\n        return rootList[addr] == true || referenceParentList[addr] != address(0);\\n    }\\n\\n    function signUp(address referrer, address addr, uint256 phase, uint256 ePhase) external onlyCaller notPaused {\\n        require(isSignedUp(referrer), \\\"invalid referrer\\\");\\n        require(!isSignedUp(addr), \\\"address has signed up\\\");\\n\\n        setUpParent(referrer, addr);\\n        updatePoints(referrer, addr, ePhase);\\n        newSignupList[phase].push(addr);\\n    }\\n\\n    function isRoot(address addr) external view returns (bool) {\\n        return rootList[addr] == true;\\n    }\\n\\n    function newRoot(address addr, uint256 phase) external onlyCaller notPaused {\\n        require(!isSignedUp(addr), \\\"address has signed up\\\");\\n        rootList[addr] = true;\\n        newSignupList[phase].push(addr);\\n    }\\n\\n    function getTop(uint256 phase) external view returns(address[] memory) {\\n      return top[phase];\\n    }\\n\\n    /*\\n    function getTopInviter(uint256 phase, uint256 topN) external onlyCaller returns(address[] memory) {\\n        if (inviterList[phase].length == 0 || top[phase].length \\u003e 0){\\n            return top[phase];\\n        }\\n        uint256 k = topN;\\n        randomizedSelect(inviterList[phase], 0, inviterList[phase].length - 1, k, phase);\\n\\n        for (uint256 i = 0; i\\u003c k \\u0026\\u0026 i \\u003c inviterList[phase].length; i++){\\n            top[phase].push(inviterList[phase][i]);\\n        }\\n        return top[phase];\\n    }\\n    */\\n\\n    function getChild(address addr) external view returns(address[] memory) {\\n        return referenceChildList[addr];\\n    }\\n\\n    function getPoints(uint256 phase, address addr) external view returns (uint256) {\\n        return addressPoints[phase][addr];\\n    }\\n\\n    function getParent(address addr) external view returns(address) {\\n        return referenceParentList[addr];\\n    }\\n\\n    function getNewSignup(uint256 phase) external view returns(address[] memory) {\\n        return newSignupList[phase];\\n    }\\n\\n    function newSignupCount(uint256 phase) external view returns (uint) {\\n        return newSignupList[phase].length;\\n    }\\n\\n    function setCaller(address who) external onlyOwner {\\n        caller = who;\\n    }\\n\\n    function setOwner(address who) external onlyOwner {\\n        master = who;\\n    }\\n\\n    constructor(uint _maxChildrenCount, uint _pointRate, uint256 _winnerCount) public {\\n        master = msg.sender; // master account\\n        maxChildrenCount = _maxChildrenCount;  // child node max number\\n        pointRate = _pointRate;  // e.g. 618\\n        winnerCount = _winnerCount;\\n    }\\n\\n    function setUpParent(address pAddress, address addr) internal {\\n        pAddress = findParent(pAddress);\\n        referenceParentList[addr] = pAddress;\\n        referenceChildList[pAddress].push(addr);\\n    }\\n\\n    function updateTop(address addr, uint256 phase) internal {\\n        for (uint256 k = 0; k \\u003c top[phase].length; k++){\\n            if (top[phase][k] == addr) {\\n                for (uint256 i = k; i \\u003e 0; i--){\\n                    if (addressPoints[phase][top[phase][i]] \\u003e addressPoints[phase][top[phase][i-1]]) {\\n                        (top[phase][i], top[phase][i-1]) = (top[phase][i-1], top[phase][i]);\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                return;\\n            }\\n        }\\n\\n        if (top[phase].length \\u003c winnerCount){\\n            top[phase].push(addr);\\n        } else if (addressPoints[phase][addr] \\u003e addressPoints[phase][top[phase][top[phase].length - 1]]){\\n            top[phase][top[phase].length - 1] = addr;\\n        }\\n\\n        for (uint256 i = top[phase].length - 1; i \\u003e 0; i--){\\n            if (addressPoints[phase][top[phase][i]] \\u003e addressPoints[phase][top[phase][i-1]]) {\\n                (top[phase][i], top[phase][i-1]) = (top[phase][i-1], top[phase][i]);\\n            } else {\\n              break;\\n            }\\n        }\\n    }\\n\\n    function updatePoints(address referrer, address addr, uint256 phase) internal {\\n        uint256 points = basePoints;\\n        if (addressPoints[phase][referrer] == 0) {\\n            inviterList[phase].push(referrer);\\n        }\\n        addressPoints[phase][referrer] = addressPoints[phase][referrer].add(points);\\n        points = points.mul(pointRate).div(1000);\\n        updateTop(referrer, phase);\\n\\n        address parent = referenceParentList[addr];\\n        uint256 level = 0;\\n        while (parent != address(0) \\u0026\\u0026 level \\u003c maxPointLevel){\\n            level = level.add(1);\\n            if (parent == referrer) {\\n                parent = referenceParentList[parent];\\n                continue;\\n            }\\n            if (addressPoints[phase][parent] == 0) {\\n                inviterList[phase].push(parent);\\n            }\\n            addressPoints[phase][parent] = addressPoints[phase][parent].add(points);\\n            points = points.mul(pointRate).div(1000);\\n            updateTop(parent, phase);\\n            parent = referenceParentList[parent];\\n        }\\n    }\\n\\n    function findParent(address root) internal view returns (address) {\\n        uint len = 10000;\\n        address[] memory temp = new address[](len);\\n        uint startIndex = 0;\\n        uint currentIndex = 0;\\n        temp[startIndex] = root;\\n        while (true){\\n            address currentAddress = temp[startIndex];\\n            startIndex++;\\n            if (startIndex == len){\\n                startIndex = 0;\\n            }\\n            if (referenceChildList[currentAddress].length \\u003c maxChildrenCount){\\n                return currentAddress;\\n            }else {\\n                for(uint i = 0; i\\u003c referenceChildList[currentAddress].length; i++){\\n                    currentIndex++;\\n                    if (currentIndex == len){\\n                        currentIndex = 0;\\n                    }\\n                    temp[currentIndex] = referenceChildList[currentAddress][i];\\n                }\\n            }\\n        }\\n    }\\n\\n    /*\\n    function randomizedSelect(address[] storage addressList, uint left, uint right, uint256 k, uint256 phase) internal{\\n        if (left == right) {\\n            return;\\n        }\\n\\n        if (left \\u003c right) {\\n            uint mid = partition(addressList, left, right, phase);\\n            uint i = mid - left + 1;\\n            if (i == k){\\n                return;\\n            }\\n\\n            if (k \\u003c i) {\\n                return randomizedSelect(addressList, left, mid - 1, k, phase);\\n            } else {\\n                return randomizedSelect(addressList, mid + 1, right, k - i, phase);\\n            }\\n        }\\n    }\\n\\n    function partition(address[] storage addressList, uint left, uint right, uint256 phase) internal returns(uint) {\\n        address tmp = addressList[left];\\n\\n        while (left \\u003c right) {\\n            while (left \\u003c right \\u0026\\u0026 addressPoints[phase][addressList[right]] \\u003c addressPoints[phase][tmp]) {\\n                right--;\\n            }\\n            addressList[left] = addressList[right];\\n            while (left \\u003c right \\u0026\\u0026 addressPoints[phase][addressList[left]] \\u003e= addressPoints[phase][tmp]) {\\n                left++;\\n            }\\n            addressList[right] = addressList[left];\\n        }\\n        addressList[left] = tmp;\\n        return left;\\n    }\\n    */\\n\\n    function distributeBonus(uint256 len) external pure returns(uint256[] memory) {\\n        uint256[] memory factors = new uint256[](len);\\n        for (uint256 i = 0; i \\u003c len; i++) {\\n            if (i \\u003c len.div(2)) {\\n              factors[i] = len.add(len.div(2).sub(i));\\n            } else {\\n              if (len % 2 == 0 ) {\\n                factors[i] = len.add(len.div(2)).sub(1).sub(i);\\n              } else {\\n                factors[i] = len.add(len.div(2)).sub(i);\\n              }\\n            }\\n        }\\n        return factors;\\n    }\\n\\n    function getAncestors(address addr) external view returns(address[] memory) {\\n        address[] memory ancestors = new address[](maxPointLevel);\\n        address parent = referenceParentList[addr];\\n\\n        for (uint256 i = 0; parent != address(0) \\u0026\\u0026 i \\u003c maxPointLevel; i++) {\\n            ancestors[i] = parent;\\n            parent = referenceParentList[parent];\\n        }\\n        return ancestors;\\n    }\\n}\\n\"},\"LuckyDraw.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\ncontract LuckyDrawBasic {\\n    function buyTicket(address addr, uint256 phase) external;\\n    function aggregateIcexWinners(uint256 phase) external;\\n    function getWinners(uint256 phase) external view returns(address[] memory);\\n}\\n\\ncontract LuckyDraw is LuckyDrawBasic {\\n    /*\\n     * STATES\\n     */\\n    address public master;\\n    address public caller;\\n\\n    bool public paused;\\n\\n    uint winnerCount = 10;\\n    mapping (uint256 =\\u003e address[]) winnerList;\\n    mapping (uint256 =\\u003e mapping(address =\\u003e bool)) playerList;\\n    mapping (uint256 =\\u003e uint256) playerNumbers;\\n    uint nonce = 0;\\n\\n    /*\\n     * MODIFIERS\\n     */\\n    /// only master can call the function\\n    modifier onlyOwner {\\n        require(master == msg.sender, \\\"only owner can call\\\");\\n        _;\\n    }\\n\\n    /// only master can call the function\\n    modifier onlyCaller {\\n        require(caller == msg.sender, \\\"only caller can call\\\");\\n        _;\\n    }\\n\\n    /// function not paused\\n    modifier notPaused {\\n        require(paused == false, \\\"function is paused\\\");\\n        _;\\n    }\\n\\n    constructor() public {\\n        master = msg.sender;\\n    }\\n\\n    function setCaller(address who) external onlyOwner {\\n        caller = who;\\n    }\\n\\n    function setOwner(address who) external onlyOwner {\\n        master = who;\\n    }\\n\\n    function setPause(bool value) external onlyOwner {\\n        paused = value;\\n    }\\n\\n    function buyTicket(address addr, uint256 phase) external onlyCaller notPaused {\\n        if (!playerList[phase][addr]){\\n            playerNumbers[phase]++;\\n            if (winnerList[phase].length \\u003c winnerCount){\\n                winnerList[phase].push(addr);\\n            }else {\\n                uint index = randomIndex(addr, playerNumbers[phase]);\\n                if (index \\u003c winnerCount){\\n                    winnerList[phase][index] = addr;\\n                }\\n            }\\n            playerList[phase][addr] = true;\\n        }\\n    }\\n\\n    // costs a bit, but will only invoke once, and paid by operator\\n    function aggregateIcexWinners(uint256 phase) external onlyCaller notPaused {\\n        for(uint i = 0 ; i \\u003c phase; ++i) {\\n            address[] memory candidates = winnerList[i];\\n            for(uint j = 0; j \\u003c candidates.length; ++j) {\\n                if (!playerList[phase][candidates[j]]) {\\n                    if (winnerList[phase].length \\u003c winnerCount) {\\n                        winnerList[phase].push(candidates[j]);\\n                    } else {\\n                        uint index = randomIndex(candidates[j], winnerCount * (phase + 1));\\n                        if (index \\u003c winnerCount){\\n                            winnerList[phase][index] = candidates[j];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function getWinners(uint256 phase) external view returns(address[] memory) {\\n        return winnerList[phase];\\n    }\\n\\n    function randomIndex(address addr, uint number) internal returns (uint) {\\n        uint randomnumber = uint(keccak256(abi.encodePacked(now, addr, nonce))) % number;\\n        nonce++;\\n        return randomnumber;\\n    }\\n}\\n\"},\"Migrations.sol\":{\"content\":\"pragma solidity \\u003e=0.4.25 \\u003c0.6.0;\\n\\ncontract Migrations {\\n  address public owner;\\n  uint public last_completed_migration;\\n\\n  modifier restricted() {\\n    if (msg.sender == owner) _;\\n  }\\n\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n\\n  function upgrade(address new_address) public restricted {\\n    Migrations upgraded = Migrations(new_address);\\n    upgraded.setCompleted(last_completed_migration);\\n  }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\"},\"VDPool.sol\":{\"content\":\"pragma solidity ^0.5.8;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\ncontract VDPoolBasic {\\n    function price() external view returns(uint256);\\n    function currentLevel() external view returns(uint256);\\n    function currentLevelRemaining() external view returns(uint256);\\n}\\n\\ncontract VDPoolThrottler {\\n    function getCooldownBlocks() external view returns(uint256);\\n}\\n\\ncontract VDPool is VDPoolBasic {\\n    using SafeMath for uint256;\\n    /*\\n     * STATES\\n     */\\n    address public master;\\n    address public caller;\\n\\n    uint256 public ethCapacity = 0;\\n    uint256 public basicExchangeRate = 0;\\n    uint256 public currentLevel = 0;\\n    uint256 public currentLevelStartBlock = 0;\\n    uint256 public cooldownBlocks = 0; // by default wait 1 block before enterring next level\\n    VDPoolThrottler throttlerContract;\\n    uint256 public currentPrice = 0;\\n    uint256 public currentLevelRemaining = 0;\\n\\n    bool public paused;\\n\\n    /*\\n     * EVENTS\\n     */\\n    event LevelDescend(uint256 level, uint256 price, uint256 startBlock, uint256 cooldownBlocks, uint256 currentBlock);\\n\\n    /*\\n     * MODIFIERS\\n     */\\n    /// only master can call the function\\n    modifier onlyOwner {\\n        require(master == msg.sender, \\\"only owner can call\\\");\\n        _;\\n    }\\n\\n    /// only master can call the function\\n    modifier onlyCaller {\\n        require(caller == msg.sender, \\\"only caller can call\\\");\\n        _;\\n    }\\n\\n    /// function not paused\\n    modifier notPaused {\\n        require(paused == false, \\\"function is paused\\\");\\n        _;\\n    }\\n\\n    constructor(uint256 _ethCapacity, uint256 _currentLevel, uint256 _basicExchangeRate) public {\\n        master = msg.sender;\\n        ethCapacity = _ethCapacity;\\n        currentLevel = _currentLevel;\\n        currentPrice = (currentLevel.sub(1)).mul(10).add(_basicExchangeRate);\\n        currentLevelRemaining = _ethCapacity;\\n        basicExchangeRate = _basicExchangeRate;\\n    }\\n\\n    function setPause(bool value) external onlyOwner {\\n        paused = value;\\n    }\\n\\n    function setCaller(address who) external onlyOwner {\\n        caller = who;\\n    }\\n\\n    function setOwner(address who) external onlyOwner {\\n        master = who;\\n    }\\n\\n    function setCooldownBlocks(uint256 bn) external onlyOwner {\\n        cooldownBlocks = bn;\\n    }\\n\\n    function setThrottlerContract(address contractAddress) external onlyOwner {\\n        throttlerContract = VDPoolThrottler(contractAddress);\\n    }\\n\\n    function price() external view returns (uint256) {\\n        uint256 tokens = computeTokenAmount(1 ether);\\n        return tokens;\\n    }\\n\\n    function computeTokenAmount(uint256 ethAmount) public view returns (uint256) {\\n        uint256 tokens = ethAmount.mul(currentPrice);\\n        return tokens;\\n    }\\n\\n    function buyToken(uint256 ethAmount) external onlyCaller notPaused returns (uint256) {\\n        require(currentLevelStartBlock \\u003c= block.number, \\\"cooling down\\\");\\n        uint256 eth = ethAmount;\\n        uint256 tokens = 0;\\n        while (eth \\u003e 0) {\\n            if (eth \\u003c= currentLevelRemaining) {\\n                tokens = tokens + computeTokenAmount(eth);\\n                currentLevelRemaining = currentLevelRemaining.sub(eth);\\n                eth = 0;\\n            }else {\\n                tokens = tokens + computeTokenAmount(currentLevelRemaining);\\n                eth = eth.sub(currentLevelRemaining);\\n                currentLevelRemaining = 0;\\n            }\\n\\n            if (currentLevelRemaining == 0){\\n                currentLevel = currentLevel.sub(1);\\n                require (currentLevel \\u003e 0, \\\"end of levels\\\");\\n                currentPrice = (currentLevel.sub(1)).mul(10).add(basicExchangeRate);\\n                currentLevelRemaining = ethCapacity;\\n                if (address(throttlerContract) != address(0)) {\\n                    cooldownBlocks = throttlerContract.getCooldownBlocks();\\n                }\\n                if (currentLevelStartBlock \\u003e block.number ) {\\n                    // handling the case of desending multiple level in one tx\\n                    currentLevelStartBlock = currentLevelStartBlock + cooldownBlocks;\\n                } else {\\n                    currentLevelStartBlock = block.number + cooldownBlocks;\\n                }\\n                emit LevelDescend(currentLevel, currentPrice, currentLevelStartBlock, cooldownBlocks, block.number);\\n            }\\n        }\\n\\n        return tokens;\\n    }\\n}\\n\"},\"VDPoolThrottler.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\n\\ncontract VDPoolThrottler {\\n    function getCooldownBlocks() external view returns(uint256);\\n}\\n\\ncontract DummyThrottler is VDPoolThrottler {\\n    function getCooldownBlocks() external view returns(uint256) {\\n      return 1;\\n  }\\n}\\n\"},\"XDS.sol\":{\"content\":\"pragma solidity ^0.5.8;\\nimport \\u0027./ERC20.sol\\u0027;\\n\\nlibrary address_make_payable {\\n   function make_payable(address x) internal pure returns (address payable) {\\n      return address(uint160(x));\\n   }\\n}\\n\\ncontract VDPoolBasic {\\n    function price() external view returns (uint256);\\n    function buyToken(uint256 ethAmount) external returns (uint256);\\n    function currentLevel() external view returns(uint256);\\n    function currentLevelRemaining() external view returns(uint256);\\n}\\n\\ncontract InvitationBasic {\\n    function signUp(address referrer, address addr, uint256 phase, uint256 ePhase) external;\\n    function isRoot(address addr) external view returns (bool);\\n    function newRoot(address addr, uint256 phase) external;\\n    function getParent(address addr) external view returns(address);\\n    function getAncestors(address addr) external view returns(address[] memory);\\n    function isSignedUp(address addr) public view returns (bool);\\n    function getPoints(uint256 phase, address addr) external view returns (uint256);\\n    function newSignupCount(uint256 phase) external view returns (uint256);\\n    function getTop(uint256 phase) external view returns(address[] memory);\\n    function distributeBonus(uint256 len) external pure returns(uint256[] memory);\\n}\\n\\ncontract LuckyDrawBasic {\\n    function buyTicket(address addr, uint256 phase) external;\\n    function aggregateIcexWinners(uint256 phase) external;\\n    function getWinners(uint256 phase) external view returns(address[] memory);\\n}\\n\\ncontract XDS is StandardToken {\\n    using address_make_payable for address;\\n\\n    /*\\n     * CONSTANTS\\n     */\\n\\n    uint16[] public bonusRate = [200, 150, 100, 50];\\n\\n    /*\\n     * STATES\\n     */\\n    address public settler;\\n    string public name;\\n    string public symbol;\\n    uint8 public constant decimals = 18;\\n\\n    address public reservedAccount;\\n    uint256 public reservedAmount;\\n    address public foundationAddr;\\n\\n    uint256 public firstBlock = 0;\\n    uint256 public blockPerPhase = 0;\\n\\n    mapping (uint256 =\\u003e uint256) public ethBalance;\\n    mapping (uint256 =\\u003e mapping (address =\\u003e uint256)) public addressInvestment;\\n    mapping (address =\\u003e uint256) public totalInvestment;\\n    mapping (address =\\u003e uint256) public crBonus; // controlled release bonus\\n    address[] icexInvestors;\\n    mapping (uint256 =\\u003e address[]) public topInvestor;\\n    mapping (uint256 =\\u003e bool) public settled;\\n\\n    InvitationBasic invitationContract;\\n    LuckyDrawBasic luckydrawContract;\\n    VDPoolBasic vdPoolContract;\\n\\n    uint256 public signUpFee = 0;\\n    uint256 public rootFee = 0;\\n    uint256 referrerBonus = 0;\\n    uint256 ancestorBonus = 0;\\n    uint16 topInvestorCounter = 0;\\n    uint16 icexCRBonusRatio = 75;\\n    uint256 crBonusReleasePhases = 10;\\n    uint256 ethBonusReleasePhases = 20;\\n\\n    uint256 luckyDrawRate = 10;\\n    uint256 invitationRate = 70;\\n    uint256 topInvestorRate = 20;\\n\\n    uint256 foundationRate = 50;\\n\\n    uint256 icexRewardETHPool = 0;\\n\\n    /*\\n     * EVENTS\\n     */\\n    /// Emitted only once after token sale starts.\\n    event SaleStarted();\\n\\n    event Settled(uint256 phase, uint256 ethDistributed, uint256 ethToPool);\\n\\n    event LuckydrawSettle(uint256 phase, address indexed who, uint256 ethAmount);\\n    event InvitationSettle(uint256 phase, address indexed who, uint256 ethAmount);\\n    event InvestorSettle(uint256 phase, address indexed who, uint256 ethAmount);\\n\\n    /*\\n     * MODIFIERS\\n     */\\n    /// only master can call the function\\n    modifier onlyOwner {\\n        require(master == msg.sender, \\\"only master can call\\\");\\n        _;\\n    }\\n\\n    constructor(string memory _name, string memory _symbol, uint256 _blockPerPhase, uint256 _totalSupply, uint256 _reservedAmount, address _reservedAccount, address _foundationAddr) public {\\n        master = msg.sender;  // master account\\n        settler = master;\\n\\n        name = _name;\\n        symbol = _symbol;\\n        totalSupply = _totalSupply;\\n        currentSupply = _reservedAmount;\\n\\n        reservedAmount = _reservedAmount;\\n        reservedAccount = _reservedAccount;\\n        balances[reservedAccount] = reservedAmount;\\n        emit Transfer(address(this), reservedAccount, reservedAmount);\\n\\n        foundationAddr = _foundationAddr; // foundation account\\n\\n        blockPerPhase = _blockPerPhase; // block number per phase\\n    }\\n\\n    /*\\n     * EXTERNAL FUNCTIONS\\n     */\\n\\n    function setOwner(address newOwner) external onlyOwner {\\n        master = newOwner;\\n    }\\n\\n    function setSettler(address newSettler) external onlyOwner {\\n        settler = newSettler;\\n    }\\n\\n    function transfer(address _to, uint256 _value) external onlyPayloadSize(2 * 32) {\\n        if ( _to == address(this)) {\\n            require(_value == rootFee, \\\"only valid value is root fee for this recipient\\\");\\n            balances[msg.sender] = balances[msg.sender].sub(_value);\\n            balances[_to] = balances[_to].add(_value);\\n            emit Transfer(msg.sender, _to, _value);\\n            require(!isSignedUp(), \\\"not qulifiled as new root\\\");\\n            invitationContract.newRoot(msg.sender, currentPhase());\\n        } else if ( _value == signUpFee \\u0026\\u0026 invitationContract.isSignedUp(_to) \\u0026\\u0026 !isSignedUp()) {\\n            uint256 fee = _value;\\n            balances[msg.sender] = balances[msg.sender].sub(fee);\\n\\n            uint256 phase = currentPhase();\\n            uint256 ePhase = phase;\\n            if (phase \\u003c bonusRate.length) {\\n                ePhase = bonusRate.length - 1;\\n            }\\n\\n            invitationContract.signUp(_to, msg.sender, phase, ePhase);\\n            //direct referrer\\n            balances[_to] = balances[_to].add(referrerBonus);\\n            emit Transfer(msg.sender, _to, referrerBonus);\\n            fee = fee.sub(referrerBonus);\\n\\n            // go up referrer tree\\n            address[] memory ancestors = invitationContract.getAncestors(msg.sender);\\n            for ( uint256 i = 0; i \\u003c ancestors.length \\u0026\\u0026 fee \\u003e= ancestorBonus; i++) {\\n                if (ancestors[i] == address(0)) {\\n                    break;\\n                }\\n                balances[ancestors[i]] = balances[ancestors[i]].add(ancestorBonus);\\n                emit Transfer(msg.sender, ancestors[i], ancestorBonus);\\n                fee = fee.sub(ancestorBonus);\\n            }\\n\\n            balances[foundationAddr] = balances[foundationAddr].add(fee);\\n            emit Transfer(msg.sender, foundationAddr, fee);\\n        } else {\\n            balances[msg.sender] = balances[msg.sender].sub(_value);\\n            balances[_to] = balances[_to].add(_value);\\n            emit Transfer(msg.sender, _to, _value);\\n        }\\n    }\\n\\n    function setInvitationContract(address addr, uint256 _rootFee, uint256 _signUpFee, uint256 _ancestorBonus, uint256 _referrerBonus, uint256 _invitationRate) external onlyOwner {\\n        invitationContract = InvitationBasic(addr);\\n\\n        rootFee = _rootFee; // price to be root\\n        signUpFee = _signUpFee; // sign up ticker price\\n        ancestorBonus = _ancestorBonus;  // ancestor node bonus\\n        referrerBonus = _referrerBonus;  // referrer node bonus\\n        invitationRate = _invitationRate;\\n    }\\n\\n    function setVdPoolContract(address addr, uint16 _topInvestorCounter, uint256 _topInvestorRate, uint256 _foundationRate) external onlyOwner {\\n        vdPoolContract = VDPoolBasic(addr);\\n\\n        topInvestorCounter = _topInvestorCounter;  // number of top investor used during settlment\\n        topInvestorRate = _topInvestorRate;  // top investor settle rate\\n\\n        foundationRate = _foundationRate; // foudation share\\n    }\\n\\n    function setLuckyDrawContract(address addr, uint256 _luckyDrawRate) external onlyOwner {\\n        luckydrawContract = LuckyDrawBasic(addr);\\n        luckyDrawRate = _luckyDrawRate;\\n    }\\n\\n    function settle(uint256 phase) external {\\n        require(settler == address(0) || settler == msg.sender, \\\"only settler can call\\\");\\n        require(phase \\u003e= 0, \\\"invalid phase\\\");\\n        require(phase \\u003c currentPhase(), \\\"phase not matured yet\\\");\\n        require (!settled[phase], \\\"phase already settled\\\");\\n\\n        uint256 pool = 0;\\n        uint256 toPool = 0;\\n        if (phase \\u003c bonusRate.length) {\\n            if(ethBalance[phase] \\u003e 0) {\\n                toPool = ethBalance[phase].mul(bonusRate.length).div(bonusRate.length + ethBonusReleasePhases);\\n                icexRewardETHPool = icexRewardETHPool.add(toPool);\\n                transferToFoundation(ethBalance[phase].sub(toPool));\\n            }\\n            // settling last phase of ICEX, combine pools\\n            if (phase == bonusRate.length - 1) {\\n                pool = icexRewardETHPool;\\n            }\\n        } else {\\n            pool = ethBalance[phase];\\n            distributeCRBonus(phase);\\n        }\\n\\n        if (pool \\u003e 0 ) {\\n            settleLuckydraw(phase, pool, phase \\u003c bonusRate.length);\\n            settleTopInvestor(phase, pool);\\n            settleInvitation(phase, pool);\\n        }\\n\\n        settled[phase] = true;\\n        emit Settled(phase, pool, toPool);\\n    }\\n\\n    function start(uint256 _firstBlock) external onlyOwner {\\n        require(!saleStarted(), \\\"Sale has not started yet\\\");\\n        require(firstBlock == 0 , \\\"Resonance already started\\\");\\n        firstBlock = _firstBlock;\\n        emit SaleStarted();\\n    }\\n\\n    /// @dev This default function allows token to be purchased by directly\\n    /// sending ether to this smart contract.\\n    function () external payable {\\n        issueToken(msg.sender);\\n    }\\n\\n    function price() external view returns(uint256) {\\n        return vdPoolContract.price();\\n    }\\n\\n    function currentLevel() external view returns(uint256) {\\n        return vdPoolContract.currentLevel();\\n    }\\n\\n    function currentRemainingEth() external view returns(uint256) {\\n        return vdPoolContract.currentLevelRemaining();\\n    }\\n\\n    function currentBonusRate() external view returns(uint16) {\\n        uint256 phase = currentPhase();\\n        if (phase \\u003c bonusRate.length){\\n            return bonusRate[phase];\\n        }\\n        return 0;\\n    }\\n\\n    function isSignedUp() public view returns (bool) {\\n        return invitationContract.isSignedUp(msg.sender);\\n    }\\n\\n    function topInvestors(uint256 phase) external view returns (address[] memory) {\\n        return topInvestor[phase];\\n    }\\n\\n    function luckyWinners(uint256 phase) external view returns (address[] memory) {\\n        return luckydrawContract.getWinners(phase);\\n    }\\n\\n    function invitationWinners(uint256 phase) external view returns(address[] memory) {\\n        return invitationContract.getTop(phase);\\n    }\\n\\n    function drain(uint256 amount) external onlyOwner {\\n        transferToFoundation(amount);\\n    }\\n\\n    /*\\n     * PUBLIC FUNCTIONS\\n     */\\n    function saleStarted() public view returns (bool) {\\n        return (firstBlock \\u003e 0 \\u0026\\u0026 block.number \\u003e= firstBlock);\\n    }\\n\\n    function currentPhase() public view returns(uint256) {\\n        return (block.number - firstBlock).div(blockPerPhase);\\n    }\\n\\n    function issueToken(address recipient) public payable {\\n        require(saleStarted(), \\\"Sale is not in progress\\\");\\n        require(msg.value \\u003e= 0.1 ether, \\\"minimal of 0.1 eth required\\\");\\n        uint256 phase = currentPhase();\\n        uint256 totalEth = msg.value;\\n\\n        updateTopInvestor(recipient, msg.value, phase);\\n        // ICEX\\n        if (phase \\u003c bonusRate.length){\\n            uint256 bonus = totalEth.mul(bonusRate[phase]).div(100);\\n            totalEth = totalEth.add(bonus);\\n            if (crBonus[recipient] == 0 ) {\\n                icexInvestors.push(recipient);\\n            }\\n        }\\n\\n        uint256 tokens = vdPoolContract.buyToken(totalEth);\\n\\n        totalInvestment[recipient] = totalInvestment[recipient].add(msg.value);\\n        currentSupply = currentSupply.add(tokens);\\n\\n        require(currentSupply \\u003c= totalSupply, \\\"exceed token supply cap\\\");\\n\\n        if (phase \\u003c bonusRate.length){\\n            uint256 crTokens = tokens.mul(bonusRate[phase]).div(100 + bonusRate[phase]).mul(icexCRBonusRatio).div(100);\\n            require(crTokens \\u003e= 0 \\u0026\\u0026 tokens \\u003e crTokens, \\u0027invalid cr bonus value\\u0027);\\n            crBonus[recipient] = crBonus[recipient].add(crTokens.div(crBonusReleasePhases));\\n            balances[recipient] = balances[recipient].add(tokens).sub(crTokens);\\n            emit Transfer(address(this), recipient, tokens.sub(crTokens));\\n        } else {\\n            balances[recipient] = balances[recipient].add(tokens);\\n            emit Transfer(address(this), recipient, tokens);\\n        }\\n\\n        uint256 foundation = msg.value.mul(foundationRate).div(100);\\n        transferToFoundation(foundation);\\n        ethBalance[phase] = ethBalance[phase].add(msg.value).sub(foundation);\\n        luckydrawContract.buyTicket(recipient, phase);\\n    }\\n\\n    /*\\n     * INTERNAL FUNCTIONS\\n     */\\n\\n    function updateTopInvestor(address addr, uint256 ethAmount, uint256 phase) internal {\\n        uint256 ePhase = phase;\\n        if (phase \\u003c bonusRate.length) {\\n            ePhase = bonusRate.length - 1; // save it for the last phase of ICEX\\n        }\\n        addressInvestment[ePhase][addr] = addressInvestment[ePhase][addr].add(ethAmount);\\n\\n        for (uint256 k = 0; k \\u003c topInvestor[ePhase].length; k++){\\n            if (topInvestor[ePhase][k] == addr) {\\n                for (uint256 i = k; i \\u003e 0; i--){\\n                    if (addressInvestment[ePhase][topInvestor[ePhase][i]] \\u003e addressInvestment[ePhase][topInvestor[ePhase][i-1]]) {\\n                        (topInvestor[ePhase][i], topInvestor[ePhase][i-1]) = (topInvestor[ePhase][i-1], topInvestor[ePhase][i]);\\n                    } else {\\n                      break;\\n                    }\\n                }\\n                return;\\n            }\\n        }\\n\\n        if (topInvestor[ePhase].length \\u003c topInvestorCounter){\\n            topInvestor[ePhase].push(addr);\\n        } else if (addressInvestment[ePhase][addr] \\u003e addressInvestment[ePhase][topInvestor[ePhase][topInvestor[ePhase].length - 1]]){\\n            topInvestor[ePhase][topInvestor[ePhase].length - 1] = addr;\\n        }\\n\\n        for (uint256 i = topInvestor[ePhase].length - 1; i \\u003e 0; i--){\\n            if (addressInvestment[ePhase][topInvestor[ePhase][i]] \\u003e addressInvestment[ePhase][topInvestor[ePhase][i-1]]) {\\n                (topInvestor[ePhase][i], topInvestor[ePhase][i-1]) = (topInvestor[ePhase][i-1], topInvestor[ePhase][i]);\\n            } else {\\n              break;\\n            }\\n        }\\n    }\\n\\n    function transferToFoundation(uint256 ethAmount) internal {\\n        address payable addr = foundationAddr.make_payable();\\n        addr.transfer(ethAmount);\\n    }\\n\\n    function settleLuckydraw(uint256 phase, uint256 ethAmount, bool isIcex) internal {\\n        if (isIcex) {\\n            luckydrawContract.aggregateIcexWinners(phase);\\n        }\\n        address[] memory winners = luckydrawContract.getWinners(phase);\\n\\n        uint256 bonus = ethAmount.mul(luckyDrawRate).div(100).div(winners.length);\\n        if (winners.length == 0 \\u0026\\u0026 bonus \\u003e 0){\\n            transferToFoundation(bonus);\\n            return;\\n        }\\n\\n        for (uint256 i = 0; i \\u003c winners.length; i++) {\\n            address payable addr = winners[i].make_payable();\\n            addr.transfer(bonus);\\n            emit LuckydrawSettle(phase, winners[i], bonus);\\n        }\\n    }\\n\\n    function settleTopInvestor (uint256 phase, uint256 ethAmount) internal {\\n        uint256 bonus = ethAmount.mul(topInvestorRate).div(100);\\n        if (topInvestor[phase].length == 0 \\u0026\\u0026 bonus \\u003e 0){\\n            transferToFoundation(bonus);\\n            return;\\n        }\\n\\n        uint256 len = topInvestor[phase].length;\\n        uint256[] memory factors = invitationContract.distributeBonus(len);\\n        for (uint256 i = 0; i \\u003c topInvestor[phase].length; i++) {\\n            address payable addr = topInvestor[phase][i].make_payable();\\n            uint256 iBonus = bonus.mul(factors[i]).div(len).div(len);\\n            addr.transfer(iBonus);\\n            emit InvestorSettle(phase, addr, iBonus);\\n        }\\n    }\\n\\n    function settleInvitation (uint256 phase, uint256 ethAmount) internal {\\n        uint256 totalBonus = ethAmount.mul(invitationRate).div(100);\\n        address[] memory winners = invitationContract.getTop(phase);\\n        if (winners.length == 0 \\u0026\\u0026 totalBonus \\u003e 0){\\n            transferToFoundation(totalBonus);\\n            return;\\n        }\\n\\n        uint256 len = winners.length;\\n        uint256[] memory factors = invitationContract.distributeBonus(len);\\n        for (uint256 i = 0; i \\u003c factors.length; i++) {\\n            uint256 bonus = totalBonus.mul(factors[i]).div(len).div(len);\\n            address payable addr = winners[i].make_payable();\\n            addr.transfer(bonus);\\n            emit InvitationSettle(phase, winners[i], bonus);\\n        }\\n    }\\n\\n    function distributeCRBonus(uint256 phase) internal {\\n        if (phase \\u003c bonusRate.length || phase \\u003e= bonusRate.length + crBonusReleasePhases) {\\n          return;\\n        }\\n\\n        for (uint256 i = 0; i \\u003c icexInvestors.length; i++) {\\n            address addr = icexInvestors[i];\\n            balances[addr] = balances[addr].add(crBonus[addr]);\\n            emit Transfer(address(this), addr, crBonus[addr]);\\n        }\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"currentPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSettler\",\"type\":\"address\"}],\"name\":\"setSettler\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSignedUp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservedAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBonusRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"settled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"phase\",\"type\":\"uint256\"}],\"name\":\"invitationWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_rootFee\",\"type\":\"uint256\"},{\"name\":\"_signUpFee\",\"type\":\"uint256\"},{\"name\":\"_ancestorBonus\",\"type\":\"uint256\"},{\"name\":\"_referrerBonus\",\"type\":\"uint256\"},{\"name\":\"_invitationRate\",\"type\":\"uint256\"}],\"name\":\"setInvitationContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRemainingEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"topInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rootFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_luckyDrawRate\",\"type\":\"uint256\"}],\"name\":\"setLuckyDrawContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"issueToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockPerPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"phase\",\"type\":\"uint256\"}],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signUpFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_firstBlock\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_topInvestorCounter\",\"type\":\"uint16\"},{\"name\":\"_topInvestorRate\",\"type\":\"uint256\"},{\"name\":\"_foundationRate\",\"type\":\"uint256\"}],\"name\":\"setVdPoolContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settler\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"phase\",\"type\":\"uint256\"}],\"name\":\"topInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"crBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ethBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"phase\",\"type\":\"uint256\"}],\"name\":\"luckyWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundationAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_blockPerPhase\",\"type\":\"uint256\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_reservedAmount\",\"type\":\"uint256\"},{\"name\":\"_reservedAccount\",\"type\":\"address\"},{\"name\":\"_foundationAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"phase\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethDistributed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethToPool\",\"type\":\"uint256\"}],\"name\":\"Settled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"phase\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"LuckydrawSettle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"phase\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"InvitationSettle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"phase\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"InvestorSettle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"XDS","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000b3b000000000000000000000000000000000000000001027e72f1f12813088000000000000000000000000000000000000000000000005a790ea17ace06a960000000000000000000000000000000aa3e3ad42952958f2d81357bf8cd5dcb77ed93000000000000000000000000079756ba86affc6cdda424aa7a061fec56077f6130000000000000000000000000000000000000000000000000000000000000011562d44696d656e73696f6e20436c6f756400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000035644430000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://e5035ff13373008b1863bfb433199e29c407914cd84c4b0fbdaa3b093ece0796"}]}