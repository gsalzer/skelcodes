{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n\r\nDeployed by Ren Project, https://renproject.io\r\n\r\nCommit hash: 272d917\r\nRepository: https://github.com/renproject/darknode-sol\r\nIssues: https://github.com/renproject/darknode-sol/issues\r\n\r\nLicenses\r\nopenzeppelin-solidity: (MIT) https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/LICENSE\r\ndarknode-sol: (GNU GPL V3) https://github.com/renproject/darknode-sol/blob/master/LICENSE\r\n\r\n*/\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable {\r\n    address private _pendingOwner;\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Claimable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier throws if called by any account other than the pendingOwner.\r\n    */\r\n    modifier onlyPendingOwner() {\r\n      require(msg.sender == _pendingOwner, \"Claimable: caller is not the pending owner\");\r\n      _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to set the pendingOwner address.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n      _pendingOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the pendingOwner address to finalize the transfer.\r\n    */\r\n    function claimOwnership() public onlyPendingOwner {\r\n      emit OwnershipTransferred(_owner, _pendingOwner);\r\n      _owner = _pendingOwner;\r\n      _pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * NOTE: This call _does not revert_ if the signature is invalid, or\r\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\r\n     * the zero address is returned.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            revert(\"signature's length is invalid\");\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            revert(\"signature's s is in the wrong range\");\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            revert(\"signature's v is in the wrong range\");\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\r\n     * JSON-RPC method.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\nlibrary String {\r\n\r\n    /// @notice Convert a uint value to its decimal string representation\r\n    // solium-disable-next-line security/no-assign-params\r\n    function fromUint(uint _i) internal pure returns (string memory) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    /// @notice Convert a bytes32 value to its hex string representation\r\n    function fromBytes32(bytes32 _value) internal pure returns(string memory) {\r\n        bytes32 value = bytes32(uint256(_value));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(32 * 2 + 2);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 32; i++) {\r\n            str[2+i*2] = alphabet[uint(uint8(value[i] >> 4))];\r\n            str[3+i*2] = alphabet[uint(uint8(value[i] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    /// @notice Convert an address to its hex string representation\r\n    function fromAddress(address _addr) internal pure returns(string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(20 * 2 + 2);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\r\n            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    /// @notice Append four strings\r\n    function add4(string memory a, string memory b, string memory c, string memory d) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(a, b, c, d));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n/// @notice ERC20Shifted represents a digital asset that has been bridged on to\r\n/// the Ethereum ledger. It exposes mint and burn functions that can only be\r\n/// called by it's associated Shifter.\r\ncontract ERC20Shifted is ERC20, ERC20Detailed, Claimable {\r\n\r\n    /* solium-disable-next-line no-empty-blocks */\r\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) public ERC20Detailed(_name, _symbol, _decimals) {}\r\n\r\n    /// @notice Allow the owner of the contract to recover funds accidentally\r\n    /// sent to the contract. To withdraw ETH, the token should be set to `0x0`.\r\n    function recoverTokens(address _token) external onlyOwner {\r\n        if (_token == address(0x0)) {\r\n            msg.sender.transfer(address(this).balance);\r\n        } else {\r\n            ERC20(_token).transfer(msg.sender, ERC20(_token).balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    function burn(address _from, uint256 _amount) public onlyOwner {\r\n        _burn(_from, _amount);\r\n    }\r\n\r\n    function mint(address _to, uint256 _amount) public onlyOwner {\r\n        _mint(_to, _amount);\r\n    }\r\n}\r\n\r\n/// @dev The following are not necessary for deploying zBTC or zZEC contracts,\r\n/// but are used to track deployments.\r\n\r\n/* solium-disable-next-line no-empty-blocks */\r\ncontract zBTC is ERC20Shifted(\"Shifted BTC\", \"zBTC\", 8) {}\r\n\r\n/* solium-disable-next-line no-empty-blocks */\r\ncontract zZEC is ERC20Shifted(\"Shifted ZEC\", \"zZEC\", 8) {}\r\n\r\n/* solium-disable-next-line no-empty-blocks */\r\ncontract zBCH is ERC20Shifted(\"Shifted BCH\", \"zBCH\", 8) {}\r\n\r\n/// @notice Shifter handles verifying mint and burn requests. A mintAuthority\r\n/// approves new assets to be minted by providing a digital signature. An owner\r\n/// of an asset can request for it to be burnt.\r\ncontract Shifter is Claimable {\r\n    using SafeMath for uint256;\r\n\r\n    uint8 public version = 2;\r\n\r\n    uint256 constant BIPS_DENOMINATOR = 10000;\r\n    uint256 public minShiftAmount;\r\n\r\n    /// @notice Each Shifter token is tied to a specific shifted token.\r\n    ERC20Shifted public token;\r\n\r\n    /// @notice The mintAuthority is an address that can sign mint requests.\r\n    address public mintAuthority;\r\n\r\n    /// @dev feeRecipient is assumed to be an address (or a contract) that can\r\n    /// accept erc20 payments it cannot be 0x0.\r\n    /// @notice When tokens are mint or burnt, a portion of the tokens are\r\n    /// forwarded to a fee recipient.\r\n    address public feeRecipient;\r\n\r\n    /// @notice The shiftIn fee in bips.\r\n    uint16 public shiftInFee;\r\n\r\n    /// @notice The shiftOut fee in bips.\r\n    uint16 public shiftOutFee;\r\n\r\n    /// @notice Each nHash can only be seen once.\r\n    mapping (bytes32=>bool) public status;\r\n\r\n    // LogShiftIn and LogShiftOut contain a unique `shiftID` that identifies\r\n    // the mint or burn event.\r\n    uint256 public nextShiftID = 0;\r\n\r\n    event LogShiftIn(\r\n        address indexed _to,\r\n        uint256 _amount,\r\n        uint256 indexed _shiftID,\r\n        bytes32 indexed _signedMessageHash\r\n    );\r\n    event LogShiftOut(\r\n        bytes _to,\r\n        uint256 _amount,\r\n        uint256 indexed _shiftID,\r\n        bytes indexed _indexedTo\r\n    );\r\n\r\n    /// @param _token The ERC20Shifted this Shifter is responsible for.\r\n    /// @param _feeRecipient The recipient of burning and minting fees.\r\n    /// @param _mintAuthority The address of the key that can sign mint\r\n    ///        requests.\r\n    /// @param _shiftInFee The amount subtracted each shiftIn request and\r\n    ///        forwarded to the feeRecipient. In BIPS.\r\n    /// @param _shiftOutFee The amount subtracted each shiftOut request and\r\n    ///        forwarded to the feeRecipient. In BIPS.\r\n    constructor(ERC20Shifted _token, address _feeRecipient, address _mintAuthority, uint16 _shiftInFee, uint16 _shiftOutFee, uint256 _minShiftOutAmount) public {\r\n        minShiftAmount = _minShiftOutAmount;\r\n        token = _token;\r\n        mintAuthority = _mintAuthority;\r\n        shiftInFee = _shiftInFee;\r\n        shiftOutFee = _shiftOutFee;\r\n        updateFeeRecipient(_feeRecipient);\r\n    }\r\n\r\n    /// @notice Allow the owner of the contract to recover funds accidentally\r\n    /// sent to the contract. To withdraw ETH, the token should be set to `0x0`.\r\n    function recoverTokens(address _token) external onlyOwner {\r\n        if (_token == address(0x0)) {\r\n            msg.sender.transfer(address(this).balance);\r\n        } else {\r\n            ERC20(_token).transfer(msg.sender, ERC20(_token).balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    // Public functions ////////////////////////////////////////////////////////\r\n\r\n    /// @notice Claims ownership of the token passed in to the constructor.\r\n    /// `transferStoreOwnership` must have previously been called.\r\n    /// Anyone can call this function.\r\n    function claimTokenOwnership() public {\r\n        token.claimOwnership();\r\n    }\r\n\r\n    /// @notice Allow the owner to update the owner of the ERC20Shifted token.\r\n    function transferTokenOwnership(Shifter _nextTokenOwner) public onlyOwner {\r\n        token.transferOwnership(address(_nextTokenOwner));\r\n        _nextTokenOwner.claimTokenOwnership();\r\n    }\r\n\r\n    /// @notice Allow the owner to update the fee recipient.\r\n    ///\r\n    /// @param _nextMintAuthority The address to start paying fees to.\r\n    function updateMintAuthority(address _nextMintAuthority) public onlyOwner {\r\n        mintAuthority = _nextMintAuthority;\r\n    }\r\n\r\n    /// @notice Allow the owner to update the minimum shiftOut amount.\r\n    ///\r\n    /// @param _minShiftOutAmount The new min shiftOut amount.\r\n    function updateMinimumShiftOutAmount(uint256 _minShiftOutAmount) public onlyOwner {\r\n        minShiftAmount = _minShiftOutAmount;\r\n    }\r\n\r\n    /// @notice Allow the owner to update the fee recipient.\r\n    ///\r\n    /// @param _nextFeeRecipient The address to start paying fees to.\r\n    function updateFeeRecipient(address _nextFeeRecipient) public onlyOwner {\r\n        // ShiftIn and ShiftOut will fail if the feeRecipient is 0x0\r\n        require(_nextFeeRecipient != address(0x0), \"Shifter: fee recipient cannot be 0x0\");\r\n\r\n        feeRecipient = _nextFeeRecipient;\r\n    }\r\n\r\n    /// @notice Allow the owner to update the shiftIn fee.\r\n    ///\r\n    /// @param _nextFee The new fee for minting and burning.\r\n    function updateShiftInFee(uint16 _nextFee) public onlyOwner {\r\n        shiftInFee = _nextFee;\r\n    }\r\n\r\n    /// @notice Allow the owner to update the shiftOut fee.\r\n    ///\r\n    /// @param _nextFee The new fee for minting and burning.\r\n    function updateShiftOutFee(uint16 _nextFee) public onlyOwner {\r\n        shiftOutFee = _nextFee;\r\n    }\r\n\r\n    /// @notice shiftIn mints tokens after taking a fee for the `_feeRecipient`.\r\n    ///\r\n    /// @param _pHash (payload hash) The hash of the payload associated with the\r\n    ///        shift.\r\n    /// @param _amount The amount of the token being shifted int, in its\r\n    ///        smallest value. (e.g. satoshis for BTC)\r\n    /// @param _nHash (nonce hash) The hash of the nonce, amount and pHash.\r\n    /// @param _sig The signature of the hash of the following values:\r\n    ///        (pHash, amount, msg.sender, nHash), signed by the mintAuthority.\r\n    function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes memory _sig) public returns (uint256) {\r\n        // Verify signature\r\n        bytes32 signedMessageHash = hashForSignature(_pHash, _amount, msg.sender, _nHash);\r\n        require(status[signedMessageHash] == false, \"Shifter: nonce hash already spent\");\r\n        if (!verifySignature(signedMessageHash, _sig)) {\r\n            // Return a detailed string containing the hash and recovered\r\n            // signer. This is a costly operation but is only run in the revert\r\n            // branch.\r\n            revert(\r\n                String.add4(\r\n                    \"Shifter: invalid signature - hash: \",\r\n                    String.fromBytes32(signedMessageHash),\r\n                    \", signer: \",\r\n                    String.fromAddress(ECDSA.recover(signedMessageHash, _sig))\r\n                )\r\n            );\r\n        }\r\n        status[signedMessageHash] = true;\r\n\r\n        // Mint `amount - fee` for the recipient and mint `fee` for the minter\r\n        uint256 absoluteFee = (_amount.mul(shiftInFee)).div(BIPS_DENOMINATOR);\r\n        uint256 receivedAmount = _amount.sub(absoluteFee);\r\n        token.mint(msg.sender, receivedAmount);\r\n        token.mint(feeRecipient, absoluteFee);\r\n\r\n        // Emit a log with a unique shift ID\r\n        emit LogShiftIn(msg.sender, receivedAmount, nextShiftID, signedMessageHash);\r\n        nextShiftID += 1;\r\n\r\n        return receivedAmount;\r\n    }\r\n\r\n    /// @notice shiftOut burns tokens after taking a fee for the `_feeRecipient`.\r\n    ///\r\n    /// @param _to The address to receive the unshifted digital asset. The\r\n    ///        format of this address should be of the destination chain.\r\n    ///        For example, when shifting out to Bitcoin, _to should be a\r\n    ///        Bitcoin address.\r\n    /// @param _amount The amount of the token being shifted out, in its\r\n    ///        smallest value. (e.g. satoshis for BTC)\r\n    function shiftOut(bytes memory _to, uint256 _amount) public returns (uint256) {\r\n        // The recipient must not be empty. Better validation is possible,\r\n        // but would need to be customized for each destination ledger.\r\n        require(_to.length != 0, \"Shifter: to address is empty\");\r\n        require(_amount >= minShiftAmount, \"Shifter: amount is less than the minimum shiftOut amount\");\r\n\r\n        // Burn full amount and mint fee\r\n        uint256 absoluteFee = (_amount.mul(shiftOutFee)).div(BIPS_DENOMINATOR);\r\n        token.burn(msg.sender, _amount);\r\n        token.mint(feeRecipient, absoluteFee);\r\n\r\n        // Emit a log with a unique shift ID\r\n        uint256 receivedValue = _amount.sub(absoluteFee);\r\n        emit LogShiftOut(_to, receivedValue, nextShiftID, _to);\r\n        nextShiftID += 1;\r\n\r\n        return receivedValue;\r\n    }\r\n\r\n    /// @notice verifySignature checks the the provided signature matches the provided\r\n    /// parameters.\r\n    function verifySignature(bytes32 _signedMessageHash, bytes memory _sig) public view returns (bool) {\r\n        return mintAuthority == ECDSA.recover(_signedMessageHash, _sig);\r\n    }\r\n\r\n    /// @notice hashForSignature hashes the parameters so that they can be signed.\r\n    function hashForSignature(bytes32 _pHash, uint256 _amount, address _to, bytes32 _nHash) public view returns (bytes32) {\r\n        return keccak256(abi.encode(_pHash, _amount, address(token), _to, _nHash));\r\n    }\r\n}\r\n\r\n/// @dev The following are not necessary for deploying BTCShifter or ZECShifter\r\n/// contracts, but are used to track deployments.\r\ncontract BTCShifter is Shifter {\r\n    constructor(ERC20Shifted _token, address _feeRecipient, address _mintAuthority, uint16 _shiftInFee, uint16 _shiftOutFee, uint256 _minShiftOutAmount)\r\n        Shifter(_token, _feeRecipient, _mintAuthority, _shiftInFee, _shiftOutFee, _minShiftOutAmount) public {\r\n        }\r\n}\r\n\r\ncontract ZECShifter is Shifter {\r\n    constructor(ERC20Shifted _token, address _feeRecipient, address _mintAuthority, uint16 _shiftInFee, uint16 _shiftOutFee, uint256 _minShiftOutAmount)\r\n        Shifter(_token, _feeRecipient, _mintAuthority, _shiftInFee, _shiftOutFee, _minShiftOutAmount) public {\r\n        }\r\n}\r\n\r\ncontract BCHShifter is Shifter {\r\n    constructor(ERC20Shifted _token, address _feeRecipient, address _mintAuthority, uint16 _shiftInFee, uint16 _shiftOutFee, uint256 _minShiftOutAmount)\r\n        Shifter(_token, _feeRecipient, _mintAuthority, _shiftInFee, _shiftOutFee, _minShiftOutAmount) public {\r\n        }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n/// @title DEXReserve\r\n/// @notice The DEX Reserve holds the liquidity for a single token pair for the\r\n/// DEX. Anyone can add liquidity, receiving in return a token representing\r\n/// a share in the funds held by the reserve.\r\ncontract DEXReserve is ERC20, ERC20Detailed, Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n\r\n    uint256 public feeInBIPS;\r\n    uint256 public pendingFeeInBIPS;\r\n    uint256 public feeChangeBlock;\r\n\r\n    ERC20 public baseToken;\r\n    ERC20 public token;\r\n    event LogAddLiquidity(address _liquidityProvider, uint256 _tokenAmount, uint256 _baseTokenAmount);\r\n    event LogDebug(uint256 _rcvAmount);\r\n    event LogFeesChanged(uint256 _previousFeeInBIPS, uint256 _newFeeInBIPS);\r\n\r\n    constructor (string memory _name, string memory _symbol, uint8 _decimals, ERC20 _baseToken, ERC20 _token, uint256 _feeInBIPS) public ERC20Detailed(_name, _symbol, _decimals) {\r\n        baseToken = _baseToken;\r\n        token = _token;\r\n        feeInBIPS = _feeInBIPS;\r\n        pendingFeeInBIPS = _feeInBIPS;\r\n    }\r\n\r\n    /// @notice Allow anyone to recover funds accidentally sent to the contract.\r\n    function recoverTokens(address _token) external onlyOwner {\r\n        require(ERC20(_token) != baseToken && ERC20(_token) != token, \"not allowed to recover reserve tokens\");\r\n        ERC20(_token).transfer(msg.sender, ERC20(_token).balanceOf(address(this)));\r\n    }\r\n\r\n    /// @notice Allow the reserve manager too update the contract fees.\r\n    /// There is a 10 block delay to reduce the chance of front-running trades.\r\n    function updateFee(uint256 _pendingFeeInBIPS) external onlyOwner {\r\n        if (_pendingFeeInBIPS == pendingFeeInBIPS) {\r\n            require(block.number >= feeChangeBlock, \"must wait 100 blocks before updating the fee\");\r\n            emit LogFeesChanged(feeInBIPS, pendingFeeInBIPS);\r\n            feeInBIPS = pendingFeeInBIPS;\r\n        } else {\r\n            // @dev 500 was chosen as an arbitrary limit - the fee should be\r\n            // well below that.\r\n            require(_pendingFeeInBIPS < 500, \"fee must not exceed hard-coded limit\");\r\n            feeChangeBlock = block.number + 100;\r\n            pendingFeeInBIPS = _pendingFeeInBIPS;\r\n        }\r\n    }\r\n\r\n    function buy(address _to, address _from, uint256 _baseTokenAmount) external returns (uint256)  {\r\n        require(totalSupply() != 0, \"reserve has no funds\");\r\n        uint256 rcvAmount = calculateBuyRcvAmt(_baseTokenAmount);\r\n        baseToken.safeTransferFrom(_from, address(this), _baseTokenAmount);\r\n        token.safeTransfer(_to, rcvAmount);\r\n        return rcvAmount;\r\n    }\r\n\r\n    function sell(address _to, address _from, uint256 _tokenAmount) external returns (uint256) {\r\n        require(totalSupply() != 0, \"reserve has no funds\");\r\n        uint256 rcvAmount = calculateSellRcvAmt(_tokenAmount);\r\n        token.safeTransferFrom(_from, address(this), _tokenAmount);\r\n        baseToken.safeTransfer(_to, rcvAmount);\r\n        return rcvAmount;\r\n    }\r\n\r\n    function calculateBuyRcvAmt(uint256 _sendAmt) public view returns (uint256) {\r\n        uint256 baseReserve = baseToken.balanceOf(address(this));\r\n        uint256 tokenReserve = token.balanceOf(address(this));\r\n        uint256 finalQuoteTokenAmount = (baseReserve.mul(tokenReserve)).div(baseReserve.add(_sendAmt));\r\n        uint256 rcvAmt = tokenReserve.sub(finalQuoteTokenAmount);\r\n        return _removeFees(rcvAmt);\r\n    }\r\n\r\n    function calculateSellRcvAmt(uint256 _sendAmt) public view returns (uint256) {\r\n        uint256 baseReserve = baseToken.balanceOf(address(this));\r\n        uint256 tokenReserve = token.balanceOf(address(this));\r\n        uint256 finalBaseTokenAmount = (baseReserve.mul(tokenReserve)).div(tokenReserve.add(_sendAmt));\r\n        uint256 rcvAmt = baseReserve.sub(finalBaseTokenAmount);\r\n        return _removeFees(rcvAmt);\r\n    }\r\n\r\n    function removeLiquidity(uint256 _liquidity) external returns (uint256, uint256) {\r\n        require(balanceOf(msg.sender) >= _liquidity, \"insufficient balance\");\r\n        uint256 baseTokenAmount = calculateBaseTokenValue(_liquidity);\r\n        uint256 quoteTokenAmount = calculateQuoteTokenValue(_liquidity);\r\n        _burn(msg.sender, _liquidity);\r\n        baseToken.safeTransfer(msg.sender, baseTokenAmount);\r\n        token.safeTransfer(msg.sender, quoteTokenAmount);\r\n        return (baseTokenAmount, quoteTokenAmount);\r\n    }\r\n\r\n    function addLiquidity(\r\n        address _liquidityProvider, uint256 _maxBaseToken, uint256 _tokenAmount, uint256 _deadline\r\n        ) external returns (uint256) {\r\n        require(block.number <= _deadline, \"addLiquidity request expired\");\r\n        uint256 liquidity = calculateExpectedLiquidity(_tokenAmount); \r\n        if (totalSupply() > 0) {\r\n            require(_tokenAmount > 0, \"token amount is less than allowed min amount\");\r\n            uint256 baseAmount = expectedBaseTokenAmount(_tokenAmount);\r\n            require(baseAmount <= _maxBaseToken, \"calculated base amount exceeds the maximum amount set\");\r\n            baseToken.safeTransferFrom(_liquidityProvider, address(this), baseAmount);\r\n            emit LogAddLiquidity(_liquidityProvider, _tokenAmount, baseAmount);\r\n        } else {\r\n            baseToken.safeTransferFrom(_liquidityProvider, address(this), _maxBaseToken);\r\n            emit LogAddLiquidity(_liquidityProvider, _tokenAmount, _maxBaseToken);\r\n        }\r\n        token.safeTransferFrom(msg.sender, address(this), _tokenAmount);\r\n        _mint(_liquidityProvider, liquidity);\r\n        return liquidity;\r\n    }\r\n\r\n    function calculateBaseTokenValue(uint256 _liquidity) public view returns (uint256) {\r\n        require(totalSupply() != 0, \"division by zero\");\r\n        uint256 baseReserve = baseToken.balanceOf(address(this));\r\n        return (_liquidity * baseReserve)/totalSupply();\r\n    }\r\n\r\n    function calculateQuoteTokenValue(uint256 _liquidity) public view returns (uint256) {\r\n        require(totalSupply() != 0,  \"division by zero\");\r\n        uint256 tokenReserve = token.balanceOf(address(this));\r\n        return (_liquidity * tokenReserve)/totalSupply();\r\n    }\r\n\r\n    function expectedBaseTokenAmount(uint256 _quoteTokenAmount) public view returns (uint256) {\r\n        uint256 baseReserve = baseToken.balanceOf(address(this));\r\n        uint256 tokenReserve = token.balanceOf(address(this));\r\n        return (_quoteTokenAmount * baseReserve)/tokenReserve;\r\n    }\r\n\r\n    function calculateExpectedLiquidity(uint256 _tokenAmount) public view returns (uint256) {\r\n        if (totalSupply() == 0) {\r\n            return _tokenAmount*2;\r\n        }\r\n        return ((totalSupply()*_tokenAmount)/token.balanceOf(address(this)));\r\n    }\r\n\r\n    function _removeFees(uint256 _amount) internal view returns (uint256) {\r\n        return (_amount * (10000 - feeInBIPS))/10000;\r\n    }\r\n}\r\n\r\n/* solhint-disable-next-line */ /* solium-disable-next-line */\r\ncontract BTC_DAI_Reserve is DEXReserve {\r\n    constructor (ERC20 _baseToken, ERC20 _token, uint256 _feeInBIPS) public DEXReserve(\"Bitcoin Liquidity Token\", \"BTCLT\", 8, _baseToken, _token, _feeInBIPS) {\r\n    }\r\n}\r\n\r\n/* solhint-disable-next-line */ /* solium-disable-next-line */\r\ncontract ZEC_DAI_Reserve is DEXReserve {\r\n    constructor (ERC20 _baseToken, ERC20 _token, uint256 _feeInBIPS) public DEXReserve(\"ZCash Liquidity Token\", \"ZECLT\", 8, _baseToken, _token, _feeInBIPS) {\r\n    }\r\n}\r\n\r\n/* solhint-disable-next-line */ /* solium-disable-next-line */\r\ncontract BCH_DAI_Reserve is DEXReserve {\r\n    constructor (ERC20 _baseToken, ERC20 _token, uint256 _feeInBIPS) public DEXReserve(\"BitcoinCash Liquidity Token\", \"BCHLT\", 8, _baseToken, _token, _feeInBIPS) {\r\n    }\r\n}\r\n\r\n/// @title DEX\r\n/// @notice The DEX contract stores the reserves for each token pair and\r\n/// provides functions for interacting with them:\r\n///   1) the view-function `calculateReceiveAmount` for calculating how much\r\n///      the user will receive in exchange for their tokens\r\n///   2) the function `trade` for executing a swap. If one of the tokens is the\r\n///      base token, this will only talk to one reserve. If neither of the\r\n///      tokens are, then the trade will settle across two reserves.\r\n///\r\n/// The DEX is ownable, allowing a DEX operator to register new reserves.\r\n/// Once a reserve has been registered, it can't be updated.\r\ncontract DEX is Claimable {\r\n    mapping (address=>DEXReserve) public reserves;\r\n    address public baseToken;\r\n\r\n    event LogTrade(address _src, address _dst, uint256 _sendAmount, uint256 _recvAmount);\r\n\r\n    /// @param _baseToken The reserves must all have a common base token.\r\n    constructor(address _baseToken) public {\r\n        baseToken = _baseToken;\r\n    }\r\n\r\n    /// @notice Allow the owner to recover funds accidentally sent to the\r\n    /// contract. To withdraw ETH, the token should be set to `0x0`.\r\n    function recoverTokens(address _token) external onlyOwner {\r\n        if (_token == address(0x0)) {\r\n            msg.sender.transfer(address(this).balance);\r\n        } else {\r\n            ERC20(_token).transfer(msg.sender, ERC20(_token).balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    /// @notice The DEX operator is able to register new reserves.\r\n    /// @param _erc20 The token that can be traded against the base token.\r\n    /// @param _reserve The address of the reserve contract. It must follow the\r\n    ///        DEXReserve interface.\r\n    function registerReserve(address _erc20, DEXReserve _reserve) external onlyOwner {\r\n        require(reserves[_erc20] == DEXReserve(0x0), \"token reserve already registered\");\r\n        reserves[_erc20] = _reserve;\r\n    }\r\n\r\n    /// @notice The main trade function to execute swaps.\r\n    /// @param _to The address at which the DST tokens should be sent to.\r\n    /// @param _src The address of the token being spent.\r\n    /// @param _dst The address of the token being received.\r\n    /// @param _sendAmount The amount of the source token being traded.\r\n    function trade(address _to, address _src, address _dst, uint256 _sendAmount) public returns (uint256) {\r\n        uint256 recvAmount;\r\n        if (_src == baseToken) {\r\n            require(reserves[_dst] != DEXReserve(0x0), \"unsupported token\");\r\n            recvAmount = reserves[_dst].buy(_to, msg.sender, _sendAmount);\r\n        } else if (_dst == baseToken) {\r\n            require(reserves[_src] != DEXReserve(0x0), \"unsupported token\");\r\n            recvAmount = reserves[_src].sell(_to, msg.sender, _sendAmount);\r\n        } else {\r\n            require(reserves[_src] != DEXReserve(0x0) && reserves[_dst] != DEXReserve(0x0), \"unsupported token\");\r\n            uint256 intermediteAmount = reserves[_src].sell(address(this), msg.sender, _sendAmount);\r\n            ERC20(baseToken).approve(address(reserves[_dst]), intermediteAmount);\r\n            recvAmount = reserves[_dst].buy(_to, address(this), intermediteAmount);\r\n        }\r\n        emit LogTrade(_src, _dst, _sendAmount, recvAmount);\r\n        return recvAmount;\r\n    }\r\n\r\n    /// @notice A read-only function to estimate the amount of DST tokens the\r\n    /// trader would receive for the send amount.\r\n    /// @param _src The address of the token being spent.\r\n    /// @param _dst The address of the token being received.\r\n    /// @param _sendAmount The amount of the source token being traded.\r\n    function calculateReceiveAmount(address _src, address _dst, uint256 _sendAmount) public view returns (uint256) {\r\n        if (_src == baseToken) {\r\n            return reserves[_dst].calculateBuyRcvAmt(_sendAmount);\r\n        }\r\n        if (_dst == baseToken) {\r\n            return reserves[_src].calculateSellRcvAmt(_sendAmount);\r\n        }\r\n        return reserves[_dst].calculateBuyRcvAmt(reserves[_src].calculateSellRcvAmt(_sendAmount));\r\n    }\r\n}\r\n\r\n/**\r\n * @notice LinkedList is a library for a circular double linked list.\r\n */\r\nlibrary LinkedList {\r\n\r\n    /*\r\n    * @notice A permanent NULL node (0x0) in the circular double linked list.\r\n    * NULL.next is the head, and NULL.previous is the tail.\r\n    */\r\n    address public constant NULL = address(0);\r\n\r\n    /**\r\n    * @notice A node points to the node before it, and the node after it. If\r\n    * node.previous = NULL, then the node is the head of the list. If\r\n    * node.next = NULL, then the node is the tail of the list.\r\n    */\r\n    struct Node {\r\n        bool inList;\r\n        address previous;\r\n        address next;\r\n    }\r\n\r\n    /**\r\n    * @notice LinkedList uses a mapping from address to nodes. Each address\r\n    * uniquely identifies a node, and in this way they are used like pointers.\r\n    */\r\n    struct List {\r\n        mapping (address => Node) list;\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a new node before an existing node.\r\n    *\r\n    * @param self The list being used.\r\n    * @param target The existing node in the list.\r\n    * @param newNode The next node to insert before the target.\r\n    */\r\n    function insertBefore(List storage self, address target, address newNode) internal {\r\n        require(!isInList(self, newNode), \"LinkedList: already in list\");\r\n        require(isInList(self, target) || target == NULL, \"LinkedList: not in list\");\r\n\r\n        // It is expected that this value is sometimes NULL.\r\n        address prev = self.list[target].previous;\r\n\r\n        self.list[newNode].next = target;\r\n        self.list[newNode].previous = prev;\r\n        self.list[target].previous = newNode;\r\n        self.list[prev].next = newNode;\r\n\r\n        self.list[newNode].inList = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a new node after an existing node.\r\n    *\r\n    * @param self The list being used.\r\n    * @param target The existing node in the list.\r\n    * @param newNode The next node to insert after the target.\r\n    */\r\n    function insertAfter(List storage self, address target, address newNode) internal {\r\n        require(!isInList(self, newNode), \"LinkedList: already in list\");\r\n        require(isInList(self, target) || target == NULL, \"LinkedList: not in list\");\r\n\r\n        // It is expected that this value is sometimes NULL.\r\n        address n = self.list[target].next;\r\n\r\n        self.list[newNode].previous = target;\r\n        self.list[newNode].next = n;\r\n        self.list[target].next = newNode;\r\n        self.list[n].previous = newNode;\r\n\r\n        self.list[newNode].inList = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Remove a node from the list, and fix the previous and next\r\n    * pointers that are pointing to the removed node. Removing anode that is not\r\n    * in the list will do nothing.\r\n    *\r\n    * @param self The list being using.\r\n    * @param node The node in the list to be removed.\r\n    */\r\n    function remove(List storage self, address node) internal {\r\n        require(isInList(self, node), \"LinkedList: not in list\");\r\n        if (node == NULL) {\r\n            return;\r\n        }\r\n        address p = self.list[node].previous;\r\n        address n = self.list[node].next;\r\n\r\n        self.list[p].next = n;\r\n        self.list[n].previous = p;\r\n\r\n        // Deleting the node should set this value to false, but we set it here for\r\n        // explicitness.\r\n        self.list[node].inList = false;\r\n        delete self.list[node];\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a node at the beginning of the list.\r\n    *\r\n    * @param self The list being used.\r\n    * @param node The node to insert at the beginning of the list.\r\n    */\r\n    function prepend(List storage self, address node) internal {\r\n        // isInList(node) is checked in insertBefore\r\n\r\n        insertBefore(self, begin(self), node);\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a node at the end of the list.\r\n    *\r\n    * @param self The list being used.\r\n    * @param node The node to insert at the end of the list.\r\n    */\r\n    function append(List storage self, address node) internal {\r\n        // isInList(node) is checked in insertBefore\r\n\r\n        insertAfter(self, end(self), node);\r\n    }\r\n\r\n    function swap(List storage self, address left, address right) internal {\r\n        // isInList(left) and isInList(right) are checked in remove\r\n\r\n        address previousRight = self.list[right].previous;\r\n        remove(self, right);\r\n        insertAfter(self, left, right);\r\n        remove(self, left);\r\n        insertAfter(self, previousRight, left);\r\n    }\r\n\r\n    function isInList(List storage self, address node) internal view returns (bool) {\r\n        return self.list[node].inList;\r\n    }\r\n\r\n    /**\r\n    * @notice Get the node at the beginning of a double linked list.\r\n    *\r\n    * @param self The list being used.\r\n    *\r\n    * @return A address identifying the node at the beginning of the double\r\n    * linked list.\r\n    */\r\n    function begin(List storage self) internal view returns (address) {\r\n        return self.list[NULL].next;\r\n    }\r\n\r\n    /**\r\n    * @notice Get the node at the end of a double linked list.\r\n    *\r\n    * @param self The list being used.\r\n    *\r\n    * @return A address identifying the node at the end of the double linked\r\n    * list.\r\n    */\r\n    function end(List storage self) internal view returns (address) {\r\n        return self.list[NULL].previous;\r\n    }\r\n\r\n    function next(List storage self, address node) internal view returns (address) {\r\n        require(isInList(self, node), \"LinkedList: not in list\");\r\n        return self.list[node].next;\r\n    }\r\n\r\n    function previous(List storage self, address node) internal view returns (address) {\r\n        require(isInList(self, node), \"LinkedList: not in list\");\r\n        return self.list[node].previous;\r\n    }\r\n\r\n}\r\n\r\ninterface IShifter {\r\n    function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes calldata _sig) external returns (uint256);\r\n    function shiftOut(bytes calldata _to, uint256 _amount) external returns (uint256);\r\n    function shiftInFee() external view returns (uint256);\r\n    function shiftOutFee() external view returns (uint256);\r\n}\r\n\r\n/// @notice ShifterRegistry is a mapping from assets to their associated\r\n/// ERC20Shifted and Shifter contracts.\r\ncontract ShifterRegistry is Claimable {\r\n\r\n    /// @dev The symbol is included twice because strings have to be hashed\r\n    /// first in order to be used as a log index/topic.\r\n    event LogShifterRegistered(string _symbol, string indexed _indexedSymbol, address indexed _tokenAddress, address indexed _shifterAddress);\r\n    event LogShifterDeregistered(string _symbol, string indexed _indexedSymbol, address indexed _tokenAddress, address indexed _shifterAddress);\r\n    event LogShifterUpdated(address indexed _tokenAddress, address indexed _currentShifterAddress, address indexed _newShifterAddress);\r\n\r\n    /// @notice The number of shifters registered\r\n    uint256 numShifters = 0;\r\n\r\n    /// @notice A list of shifter contracts\r\n    LinkedList.List private shifterList;\r\n\r\n    /// @notice A list of shifted token contracts\r\n    LinkedList.List private shiftedTokenList;\r\n\r\n    /// @notice A map of token addresses to canonical shifter addresses\r\n    mapping (address=>address) private shifterByToken;\r\n\r\n    /// @notice A map of token symbols to canonical shifter addresses\r\n    mapping (string=>address) private tokenBySymbol;\r\n\r\n    /// @notice Allow the owner of the contract to recover funds accidentally\r\n    /// sent to the contract. To withdraw ETH, the token should be set to `0x0`.\r\n    function recoverTokens(address _token) external onlyOwner {\r\n        if (_token == address(0x0)) {\r\n            msg.sender.transfer(address(this).balance);\r\n        } else {\r\n            ERC20(_token).transfer(msg.sender, ERC20(_token).balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    /// @notice Allow the owner to set the shifter address for a given\r\n    ///         ERC20Shifted token contract.\r\n    ///\r\n    /// @param _tokenAddress The address of the ERC20Shifted token contract.\r\n    /// @param _shifterAddress The address of the Shifter contract.\r\n    function setShifter(address _tokenAddress, address _shifterAddress) external onlyOwner {\r\n        // Check that token, shifter and symbol haven't already been registered\r\n        require(!LinkedList.isInList(shifterList, _shifterAddress), \"ShifterRegistry: shifter already registered\");\r\n        require(shifterByToken[_tokenAddress] == address(0x0), \"ShifterRegistry: token already registered\");\r\n        string memory symbol = ERC20Shifted(_tokenAddress).symbol();\r\n        require(tokenBySymbol[symbol] == address(0x0), \"ShifterRegistry: symbol already registered\");\r\n\r\n        // Add to list of shifters\r\n        LinkedList.append(shifterList, _shifterAddress);\r\n\r\n        // Add to list of shifted tokens\r\n        LinkedList.append(shiftedTokenList, _tokenAddress);\r\n\r\n        tokenBySymbol[symbol] = _tokenAddress;\r\n        shifterByToken[_tokenAddress] = _shifterAddress;\r\n        numShifters += 1;\r\n\r\n        emit LogShifterRegistered(symbol, symbol, _tokenAddress, _shifterAddress);\r\n    }\r\n\r\n    /// @notice Allow the owner to update the shifter address for a given\r\n    ///         ERC20Shifted token contract.\r\n    ///\r\n    /// @param _tokenAddress The address of the ERC20Shifted token contract.\r\n    /// @param _newShifterAddress The updated address of the Shifter contract.\r\n    function updateShifter(address _tokenAddress, address _newShifterAddress) external onlyOwner {\r\n        // Check that token, shifter are registered\r\n        address currentShifter = shifterByToken[_tokenAddress];\r\n        require(shifterByToken[_tokenAddress] != address(0x0), \"ShifterRegistry: token not registered\");\r\n\r\n        // Remove to list of shifters\r\n        LinkedList.remove(shifterList, currentShifter);\r\n\r\n        // Add to list of shifted tokens\r\n        LinkedList.append(shifterList, _newShifterAddress);\r\n\r\n        shifterByToken[_tokenAddress] = _newShifterAddress;\r\n\r\n        emit LogShifterUpdated(_tokenAddress, currentShifter, _newShifterAddress);\r\n    }\r\n\r\n    /// @notice Allows the owner to remove the shifter address for a given\r\n    ///         ERC20shifter token contract.\r\n    ///\r\n    /// @param _symbol The symbol of the token to deregister.\r\n    function removeShifter(string calldata _symbol) external onlyOwner {\r\n        // Look up token address\r\n        address tokenAddress = tokenBySymbol[_symbol];\r\n        require(tokenAddress != address(0x0), \"ShifterRegistry: symbol not registered\");\r\n\r\n        // Look up shifter address\r\n        address shifterAddress = shifterByToken[tokenAddress];\r\n\r\n        // Remove token and shifter\r\n        shifterByToken[tokenAddress] = address(0x0);\r\n        tokenBySymbol[_symbol] = address(0x0);\r\n        LinkedList.remove(shifterList, shifterAddress);\r\n        LinkedList.remove(shiftedTokenList, tokenAddress);\r\n        numShifters -= 1;\r\n\r\n        emit LogShifterDeregistered(_symbol, _symbol, tokenAddress, shifterAddress);\r\n    }\r\n\r\n    /// @dev To get all the registered shifters use count = 0.\r\n    function getShifters(address _start, uint256 _count) external view returns (address[] memory) {\r\n        uint256 count;\r\n        if (_count == 0) {\r\n            count = numShifters;\r\n        } else {\r\n            count = _count;\r\n        }\r\n\r\n        address[] memory shifters = new address[](count);\r\n\r\n        // Begin with the first node in the list\r\n        uint256 n = 0;\r\n        address next = _start;\r\n        if (next == address(0)) {\r\n            next = LinkedList.begin(shifterList);\r\n        }\r\n\r\n        while (n < count) {\r\n            if (next == address(0)) {\r\n                break;\r\n            }\r\n            shifters[n] = next;\r\n            next = LinkedList.next(shifterList, next);\r\n            n += 1;\r\n        }\r\n        return shifters;\r\n    }\r\n\r\n    /// @dev To get all the registered shifted tokens use count = 0.\r\n    function getShiftedTokens(address _start, uint256 _count) external view returns (address[] memory) {\r\n        uint256 count;\r\n        if (_count == 0) {\r\n            count = numShifters;\r\n        } else {\r\n            count = _count;\r\n        }\r\n\r\n        address[] memory shiftedTokens = new address[](count);\r\n\r\n        // Begin with the first node in the list\r\n        uint256 n = 0;\r\n        address next = _start;\r\n        if (next == address(0)) {\r\n            next = LinkedList.begin(shiftedTokenList);\r\n        }\r\n\r\n        while (n < count) {\r\n            if (next == address(0)) {\r\n                break;\r\n            }\r\n            shiftedTokens[n] = next;\r\n            next = LinkedList.next(shiftedTokenList, next);\r\n            n += 1;\r\n        }\r\n        return shiftedTokens;\r\n    }\r\n\r\n    /// @notice Returns the Shifter address for the given ERC20Shifted token\r\n    ///         contract address.\r\n    ///\r\n    /// @param _tokenAddress The address of the ERC20Shifted token contract.\r\n    function getShifterByToken(address _tokenAddress) external view returns (IShifter) {\r\n        return IShifter(shifterByToken[_tokenAddress]);\r\n    }\r\n\r\n    /// @notice Returns the Shifter address for the given ERC20Shifted token\r\n    ///         symbol.\r\n    ///\r\n    /// @param _tokenSymbol The symbol of the ERC20Shifted token contract.\r\n    function getShifterBySymbol(string calldata _tokenSymbol) external view returns (IShifter) {\r\n        return IShifter(shifterByToken[tokenBySymbol[_tokenSymbol]]);\r\n    }\r\n\r\n    /// @notice Returns the ERC20Shifted address for the given token symbol.\r\n    ///\r\n    /// @param _tokenSymbol The symbol of the ERC20Shifted token contract to\r\n    ///        lookup.\r\n    function getTokenBySymbol(string calldata _tokenSymbol) external view returns (address) {\r\n        return tokenBySymbol[_tokenSymbol];\r\n    }\r\n}\r\n\r\ncontract DEXAdapter {\r\n    using SafeERC20 for ERC20;\r\n\r\n    DEX public dex;\r\n    ShifterRegistry public shifterRegistry;\r\n\r\n    event LogTransferIn(address src, uint256 amount);\r\n    event LogTransferOut(address dst, uint256 amount);\r\n\r\n    constructor(DEX _dex, ShifterRegistry _shifterRegistry) public {\r\n        shifterRegistry = _shifterRegistry;\r\n        dex = _dex;\r\n    }\r\n\r\n    /// @notice Allow anyone to recover funds accidentally sent to the contract.\r\n    /// To withdraw ETH, the token should be set to `0x0`.\r\n    function recoverTokens(address _token) external {\r\n        if (_token == address(0x0)) {\r\n            msg.sender.transfer(address(this).balance);\r\n        } else {\r\n            ERC20(_token).transfer(msg.sender, ERC20(_token).balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    // TODO: Fix \"Stack too deep\" error!\r\n    uint256 transferredAmt;\r\n\r\n    function trade(\r\n        // Payload\r\n        /*uint256 _relayerFee,*/ address _src, address _dst, uint256 _minDstAmt, bytes calldata _to,\r\n        uint256 _refundBN, bytes calldata _refundAddress,\r\n        // Required\r\n        uint256 _amount, bytes32 _nHash, bytes calldata _sig\r\n    ) external {\r\n        transferredAmt;\r\n        bytes32 pHash = hashTradePayload(_src, _dst, _minDstAmt, _to, _refundBN, _refundAddress);\r\n        // Handle refunds if the refund block number has passed\r\n        if (block.number >= _refundBN) {\r\n            IShifter shifter = shifterRegistry.getShifterByToken(address(_src));\r\n            if (shifter != IShifter(0x0)) {\r\n                transferredAmt = shifter.shiftIn(pHash, _amount, _nHash, _sig);\r\n                shifter.shiftOut(_refundAddress, transferredAmt);\r\n            }\r\n            return;\r\n        }\r\n\r\n        transferredAmt = _transferIn(_src, _amount, _nHash, pHash, _sig);\r\n        emit LogTransferIn(_src, transferredAmt);\r\n        _doTrade(_src, _dst, _minDstAmt, _to, transferredAmt);\r\n    }\r\n\r\n    function hashTradePayload(\r\n        /*uint256 _relayerFee,*/ address _src, address _dst, uint256 _minDstAmt, bytes memory _to,\r\n        uint256 _refundBN, bytes memory _refundAddress\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(abi.encode(_src, _dst, _minDstAmt, _to, _refundBN, _refundAddress));\r\n    }\r\n\r\n    function hashLiquidityPayload(\r\n        address _liquidityProvider,  uint256 _maxBaseToken, address _token,\r\n        uint256 _refundBN, bytes memory _refundAddress\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(abi.encode(_liquidityProvider, _maxBaseToken, _token, _refundBN, _refundAddress));\r\n    }\r\n\r\n    function addLiquidity(\r\n        address _liquidityProvider,  uint256 _maxBaseToken, address _token, uint256 _deadline, bytes calldata _refundAddress,\r\n        uint256 _amount, bytes32 _nHash, bytes calldata _sig\r\n        ) external returns (uint256) {\r\n            DEXReserve reserve = dex.reserves(_token);\r\n            require(reserve != DEXReserve(0x0), \"unsupported token\");\r\n            bytes32 lpHash = hashLiquidityPayload(_liquidityProvider, _maxBaseToken, _token, _deadline, _refundAddress);\r\n            if (block.number > _deadline) {\r\n                uint256 shiftedAmount = shifterRegistry.getShifterByToken(_token).shiftIn(lpHash, _amount, _nHash, _sig);\r\n                shifterRegistry.getShifterByToken(_token).shiftOut(_refundAddress, shiftedAmount);\r\n                return 0;\r\n            }\r\n            require(ERC20(dex.baseToken()).allowance(_liquidityProvider, address(reserve)) >= _maxBaseToken,\r\n                \"insufficient base token allowance\");\r\n            uint256 transferredAmount = _transferIn(_token, _amount, _nHash, lpHash, _sig);\r\n            ERC20(_token).approve(address(reserve), transferredAmount);\r\n            return reserve.addLiquidity(_liquidityProvider, _maxBaseToken, transferredAmount, _deadline);\r\n    }\r\n\r\n    function removeLiquidity(address _token, uint256 _liquidity, bytes calldata _tokenAddress) external {\r\n        DEXReserve reserve = dex.reserves(_token);\r\n        require(reserve != DEXReserve(0x0), \"unsupported token\");\r\n        ERC20(reserve).safeTransferFrom(msg.sender, address(this), _liquidity);\r\n        (uint256 baseTokenAmount, uint256 quoteTokenAmount) = reserve.removeLiquidity(_liquidity);\r\n        reserve.baseToken().safeTransfer(msg.sender, baseTokenAmount);\r\n        shifterRegistry.getShifterByToken(address(reserve.token())).shiftOut(_tokenAddress, quoteTokenAmount);\r\n    }\r\n\r\n    function _doTrade(\r\n        address _src, address _dst, uint256 _minDstAmt, bytes memory _to, uint256 _amount\r\n    ) internal {\r\n        uint256 recvAmt;\r\n        address to;\r\n        IShifter shifter = shifterRegistry.getShifterByToken(address(_dst));\r\n\r\n        if (shifter != IShifter(0x0)) {\r\n            to = address(this);\r\n        } else {\r\n            to = _bytesToAddress(_to);\r\n        }\r\n\r\n        if (_src == dex.baseToken()) {\r\n            ERC20(_src).approve(address(dex.reserves(_dst)), _amount);\r\n        } else {\r\n            ERC20(_src).approve(address(dex.reserves(_src)), _amount);\r\n        }\r\n        recvAmt = dex.trade(to, _src, _dst, _amount);\r\n\r\n        require(recvAmt > 0 && recvAmt >= _minDstAmt, \"invalid receive amount\");\r\n        if (shifter != IShifter(0x0)) {\r\n            shifter.shiftOut(_to, recvAmt);\r\n        }\r\n        emit LogTransferOut(_dst, recvAmt);\r\n    }\r\n\r\n    function _transferIn(\r\n        /*uint256 _relayerFee,*/ address _src, uint256 _amount,\r\n        bytes32 _nHash, bytes32 _pHash, bytes memory _sig\r\n    ) internal returns (uint256) {\r\n        IShifter shifter = shifterRegistry.getShifterByToken(address(_src));\r\n        if (shifter != IShifter(0x0)) {\r\n            return shifter.shiftIn(_pHash, _amount, _nHash, _sig);\r\n        } else {\r\n            ERC20(_src).safeTransferFrom(msg.sender, address(this), _amount);\r\n            return _amount;\r\n        }\r\n    }\r\n\r\n    function _bytesToAddress(bytes memory _addr) internal pure returns (address) {\r\n        address addr;\r\n        /* solhint-disable-next-line */ /* solium-disable-next-line */\r\n        assembly {\r\n            addr := mload(add(_addr, 20))\r\n        }\r\n        return addr;\r\n    }\r\n\r\n    function calculateReceiveAmount(address _src, address _dst, uint256 _sendAmount) public view returns (uint256) {\r\n        uint256 sendAmount = _sendAmount;\r\n\r\n        // Remove shift-in fees\r\n        IShifter srcShifter = shifterRegistry.getShifterByToken(_dst);\r\n        if (srcShifter != IShifter(0x0)) {\r\n            sendAmount = removeFee(_sendAmount, srcShifter.shiftInFee());\r\n        }\r\n\r\n        uint256 receiveAmount = dex.calculateReceiveAmount(_src, _dst, sendAmount);\r\n\r\n        // Remove shift-out fees\r\n        IShifter dstShifter = shifterRegistry.getShifterByToken(_dst);\r\n        if (dstShifter != IShifter(0x0)) {\r\n            receiveAmount = removeFee(receiveAmount, dstShifter.shiftOutFee());\r\n        }\r\n\r\n        return receiveAmount;\r\n    }\r\n\r\n    function removeFee(uint256 _amount, uint256 _feeInBips) private view returns (uint256) {\r\n        return _amount - (_amount * _feeInBips)/10000;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract DEX\",\"name\":\"_dex\",\"type\":\"address\"},{\"internalType\":\"contract ShifterRegistry\",\"name\":\"_shifterRegistry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogTransferIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogTransferOut\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxBaseToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_refundAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sendAmount\",\"type\":\"uint256\"}],\"name\":\"calculateReceiveAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dex\",\"outputs\":[{\"internalType\":\"contract DEX\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxBaseToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_refundBN\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_refundAddress\",\"type\":\"bytes\"}],\"name\":\"hashLiquidityPayload\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minDstAmt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_to\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_refundBN\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_refundAddress\",\"type\":\"bytes\"}],\"name\":\"hashTradePayload\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_tokenAddress\",\"type\":\"bytes\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shifterRegistry\",\"outputs\":[{\"internalType\":\"contract ShifterRegistry\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minDstAmt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_to\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_refundBN\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_refundAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DEXAdapter","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f65d91333b1d4d3887016b17741ad602d77685940000000000000000000000005d9bf2bad3dd710e4d533681ed16ed1cfeac9e6f","Library":"","LicenseType":"None","SwarmSource":"bzzr://3129de11953014b9d1ea7c745e60d4f6de0bc1558b484a846a8c938a5a7cddb5"}]}