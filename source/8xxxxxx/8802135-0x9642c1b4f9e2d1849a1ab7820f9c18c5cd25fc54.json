{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * (.note) This call _does not revert_ if the signature is invalid, or\r\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\r\n     * the zero address is returned.\r\n     *\r\n     * (.warning) `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise)\r\n     * be too long), and then calling `toEthSignedMessageHash` on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * [`eth_sign`](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign)\r\n     * JSON-RPC method.\r\n     *\r\n     * See `recover`.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n// File: contracts/token/SRC20Detailed.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SRC20Detailed token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract SRC20Detailed {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    constructor (string memory _name, string memory _symbol, uint8 _decimals) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/ISRC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SRC20 public interface\r\n */\r\ninterface ISRC20 {\r\n\r\n    event RestrictionsAndRulesUpdated(address restrictions, address rules);\r\n\r\n    function transferToken(address to, uint256 value, uint256 nonce, uint256 expirationTime,\r\n        bytes32 msgHash, bytes calldata signature) external returns (bool);\r\n    function transferTokenFrom(address from, address to, uint256 value, uint256 nonce,\r\n        uint256 expirationTime, bytes32 hash, bytes calldata signature) external returns (bool);\r\n    function getTransferNonce() external view returns (uint256);\r\n    function getTransferNonce(address account) external view returns (uint256);\r\n    function executeTransfer(address from, address to, uint256 value) external returns (bool);\r\n    function updateRestrictionsAndRules(address restrictions, address rules) external returns (bool);\r\n\r\n    // ERC20 part-like interface\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function increaseAllowance(address spender, uint256 value) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 value) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/ISRC20Managed.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n    @title SRC20 interface for managers\r\n */\r\ninterface ISRC20Managed {\r\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\r\n\r\n    function burn(address account, uint256 value) external returns (bool);\r\n    function mint(address account, uint256 value) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/ITransferRules.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ITransferRules interface\r\n * @dev Represents interface for any on-chain SRC20 transfer rules\r\n * implementation. Transfer Rules are expected to follow\r\n * same interface, managing multiply transfer rule implementations with\r\n * capabilities of managing what happens with tokens.\r\n *\r\n * This interface is working with ERC20 transfer() function\r\n */\r\ninterface ITransferRules {\r\n    function setSRC(address src20) external returns (bool);\r\n    function doTransfer(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IFreezable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available events\r\n * `AccountFrozen` and `AccountUnfroze` and it will make sure that any child\r\n * that implements all necessary functionality.\r\n */\r\ncontract IFreezable {\r\n    event AccountFrozen(address indexed account);\r\n    event AccountUnfrozen(address indexed account);\r\n\r\n    function _freezeAccount(address account) internal;\r\n    function _unfreezeAccount(address account) internal;\r\n    function _isAccountFrozen(address account) internal view returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IPausable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the functions are implemented.\r\n */\r\ncontract IPausable{\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    function paused() public view returns (bool);\r\n\r\n    function _pause() internal;\r\n    function _unpause() internal;\r\n}\r\n\r\n// File: contracts/interfaces/IFeatured.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Support for \"SRC20 feature\" modifier.\r\n */\r\ncontract IFeatured is IPausable, IFreezable {\r\n    \r\n    event AccountFrozen(address indexed account);\r\n    event AccountUnfrozen(address indexed account);\r\n    event TokenFrozen();\r\n    event TokenUnfrozen();\r\n    \r\n    uint8 public constant ForceTransfer = 0x01;\r\n    uint8 public constant Pausable = 0x02;\r\n    uint8 public constant AccountBurning = 0x04;\r\n    uint8 public constant AccountFreezing = 0x08;\r\n\r\n    function _enable(uint8 features) internal;\r\n    function isEnabled(uint8 feature) public view returns (bool);\r\n\r\n    function checkTransfer(address from, address to) external view returns (bool);\r\n    function isAccountFrozen(address account) external view returns (bool);\r\n    function freezeAccount(address account) external;\r\n    function unfreezeAccount(address account) external;\r\n    function isTokenPaused() external view returns (bool);\r\n    function pauseToken() external;\r\n    function unPauseToken() external;\r\n}\r\n\r\n// File: contracts/interfaces/ISRC20Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which allows children to implement access managements\r\n * with multiple roles.\r\n *\r\n * `Authority` the one how is authorized by token owner/issuer to authorize transfers\r\n * either on-chain or off-chain.\r\n *\r\n * `Delegate` the person who person responsible for updating KYA document\r\n *\r\n * `Manager` the person who is responsible for minting and burning the tokens. It should be\r\n * be registry contract where staking->minting is executed.\r\n */\r\ncontract ISRC20Roles {\r\n    function isAuthority(address account) external view returns (bool);\r\n    function removeAuthority(address account) external returns (bool);\r\n    function addAuthority(address account) external returns (bool);\r\n\r\n    function isDelegate(address account) external view returns (bool);\r\n    function addDelegate(address account) external returns (bool);\r\n    function removeDelegate(address account) external returns (bool);\r\n\r\n    function manager() external view returns (address);\r\n    function isManager(address account) external view returns (bool);\r\n    function transferManagement(address newManager) external returns (bool);\r\n    function renounceManagement() external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/ITransferRestrictions.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ITransferRestrictions interface\r\n * @dev Represents interface for any on-chain SRC20 transfer restriction\r\n * implementation. Transfer Restriction registries are expected to follow\r\n * same interface, managing multiply transfer restriction implementations.\r\n *\r\n * It is intended to implementation of this interface be used for transferToken()\r\n */\r\ninterface ITransferRestrictions {\r\n    function authorize(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IAssetRegistry.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * AssetRegistry holds the real-world/offchain properties of the various Assets being tokenized.\r\n * It provides functions for getting/setting these properties.\r\n */\r\ninterface IAssetRegistry {\r\n\r\n    event AssetAdded(address indexed src20, bytes32 kyaHash, string kyaUrl, uint256 AssetValueUSD);\r\n    event AssetNVAUSDUpdated(address indexed src20, uint256 AssetValueUSD);\r\n    event AssetKYAUpdated(address indexed src20, bytes32 kyaHash, string kyaUrl);\r\n\r\n    function addAsset(address src20, bytes32 kyaHash, string calldata kyaUrl, uint256 netAssetValueUSD) external returns (bool);\r\n\r\n    function getNetAssetValueUSD(address src20) external view returns (uint256);\r\n    function updateNetAssetValueUSD(address src20, uint256 netAssetValueUSD) external returns (bool);\r\n\r\n    function getKYA(address src20) external view returns (bytes32 kyaHash, string memory kyaUrl);\r\n    function updateKYA(address src20, bytes32 kyaHash, string calldata kyaUrl) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/token/SRC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SRC20 contract\r\n * @dev Base SRC20 contract.\r\n */\r\ncontract SRC20 is ISRC20, ISRC20Managed, SRC20Detailed, Ownable {\r\n    using SafeMath for uint256;\r\n    using ECDSA for bytes32;\r\n\r\n    mapping(address => uint256) public _balances;\r\n    mapping(address => mapping(address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n    uint256 public _maxTotalSupply;\r\n\r\n    mapping(address => uint256) private _nonce;\r\n\r\n    ISRC20Roles public _roles;\r\n    IFeatured public _features;\r\n\r\n    IAssetRegistry public _assetRegistry;\r\n\r\n    /**\r\n     * @description Configured contract implementing token restriction(s).\r\n     * If set, transferToken will consult this contract should transfer\r\n     * be allowed after successful authorization signature check.\r\n     */\r\n    ITransferRestrictions public _restrictions;\r\n\r\n    /**\r\n     * @description Configured contract implementing token rule(s).\r\n     * If set, transfer will consult this contract should transfer\r\n     * be allowed after successful authorization signature check.\r\n     * And call doTransfer() in order for rules to decide where fund\r\n     * should end up.\r\n     */\r\n    ITransferRules public _rules;\r\n\r\n    modifier onlyAuthority() {\r\n        require(_roles.isAuthority(msg.sender), \"Caller not authority\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDelegate() {\r\n        require(_roles.isDelegate(msg.sender), \"Caller not delegate\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyManager() {\r\n        require(_roles.isManager(msg.sender), \"Caller not manager\");\r\n        _;\r\n    }\r\n\r\n    modifier enabled(uint8 feature) {\r\n        require(_features.isEnabled(feature), \"Token feature is not enabled\");\r\n        _;\r\n    }\r\n\r\n    // Constructors\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint8 decimals,\r\n        uint256 maxTotalSupply,\r\n        address[] memory addressList\r\n                    //  addressList[0] tokenOwner,\r\n                    //  addressList[1] restrictions,\r\n                    //  addressList[2] rules,\r\n                    //  addressList[3] roles,\r\n                    //  addressList[4] featured,\r\n                    //  addressList[5] assetRegistry\r\n    )\r\n    SRC20Detailed(name, symbol, decimals)\r\n    public\r\n    {\r\n        _assetRegistry = IAssetRegistry(addressList[5]);\r\n        _transferOwnership(addressList[0]);\r\n\r\n        _maxTotalSupply = maxTotalSupply;\r\n        _updateRestrictionsAndRules(addressList[1], addressList[2]);\r\n\r\n        _roles = ISRC20Roles(addressList[3]);\r\n        _features = IFeatured(addressList[4]);\r\n    }\r\n\r\n    /**\r\n     * @dev This method is intended to be executed by TransferRules contract when doTransfer is called in transfer\r\n     * and transferFrom methods to check where funds should go.\r\n     *\r\n     * @param from The address to transfer from.\r\n     * @param to The address to send tokens to.\r\n     * @param value The amount of tokens to send.\r\n     */\r\n    function executeTransfer(address from, address to, uint256 value) external onlyAuthority returns (bool) {\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Update the rules and restrictions settings for transfers.\r\n     * Only a Delegate can call this role\r\n     * \r\n     * @param restrictions address implementing on-chain restriction checks\r\n     * or address(0) if no rules should be checked on chain.\r\n     * @param rules address implementing on-chain restriction checks\r\n     * @return True on success.\r\n     */\r\n    function updateRestrictionsAndRules(address restrictions, address rules) external onlyDelegate returns (bool) {\r\n        return _updateRestrictionsAndRules(restrictions, rules);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to update the restrictions and rules contracts.\r\n     * Emits RestrictionsAndRulesUpdated event.\r\n     *\r\n     * @param restrictions address implementing on-chain restriction checks\r\n     *                     or address(0) if no rules should be checked on chain.\r\n     * @param rules address implementing on-chain restriction checks\r\n     * @return True on success.\r\n     */\r\n    function _updateRestrictionsAndRules(address restrictions, address rules) internal returns (bool) {\r\n\r\n        _restrictions = ITransferRestrictions(restrictions);\r\n        _rules = ITransferRules(rules);\r\n\r\n        if (rules != address(0)) {\r\n            require(_rules.setSRC(address(this)), \"SRC20 contract already set in transfer rules\");\r\n        }\r\n\r\n        emit RestrictionsAndRulesUpdated(restrictions, rules);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to specified address. Caller needs to provide authorization\r\n     * signature obtained from MAP API, signed by authority accepted by token issuer.\r\n     * Emits Transfer event.\r\n     *\r\n     * @param to The address to send tokens to.\r\n     * @param value The amount of tokens to send.\r\n     * @param nonce Token transfer nonce, can not repeat nonce for subsequent\r\n     * token transfers.\r\n     * @param expirationTime Timestamp until transfer request is valid.\r\n     * @param hash Hash of transfer params (kyaHash, from, to, value, nonce, expirationTime).\r\n     * @param signature Ethereum ECDSA signature of msgHash signed by one of authorities.\r\n     * @return True on success.\r\n     */\r\n    function transferToken(\r\n        address to,\r\n        uint256 value,\r\n        uint256 nonce,\r\n        uint256 expirationTime,\r\n        bytes32 hash,\r\n        bytes calldata signature\r\n    )\r\n        external returns (bool)\r\n    {\r\n        return _transferToken(msg.sender, to, value, nonce, expirationTime, hash, signature);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to specified address. Caller needs to provide authorization\r\n     * signature obtained from MAP API, signed by authority accepted by token issuer.\r\n     * Whole allowance needs to be transferred.\r\n     * Emits Transfer event.\r\n     * Emits Approval event.\r\n     *\r\n     * @param from The address to transfer from.\r\n     * @param to The address to send tokens to.\r\n     * @param value The amount of tokens to send.\r\n     * @param nonce Token transfer nonce, can not repeat nance for subsequent\r\n     * token transfers.\r\n     * @param expirationTime Timestamp until transfer request is valid.\r\n     * @param hash Hash of transfer params (kyaHash, from, to, value, nonce, expirationTime).\r\n     * @param signature Ethereum ECDSA signature of msgHash signed by one of authorities.\r\n     * @return True on success.\r\n     */\r\n    function transferTokenFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        uint256 nonce,\r\n        uint256 expirationTime,\r\n        bytes32 hash,\r\n        bytes calldata signature\r\n    )\r\n        external returns (bool)\r\n    {\r\n        _transferToken(from, to, value, nonce, expirationTime, hash, signature);\r\n        _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another, used by token issuer. This\r\n    * call requires only that from address has enough tokens, all other checks are\r\n    * skipped.\r\n    * Emits Transfer event.\r\n    * Allowed only to token owners. Require 'ForceTransfer' feature enabled.\r\n    *\r\n    * @param from The address which you want to send tokens from.\r\n    * @param to The address to send tokens to.\r\n    * @param value The amount of tokens to send.\r\n    * @return True on success.\r\n    */\r\n    function transferTokenForced(address from, address to, uint256 value)\r\n        external\r\n        enabled(_features.ForceTransfer())\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    // Nonce management\r\n    /**\r\n     * @dev Returns next nonce expected by transfer functions that require it.\r\n     * After any successful transfer, nonce will be incremented.\r\n     *\r\n     * @return Nonce for next transfer function.\r\n     */\r\n    function getTransferNonce() external view returns (uint256) {\r\n        return _nonce[msg.sender];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns nonce for account.\r\n     *\r\n     * @return Nonce for next transfer function.\r\n     */\r\n    function getTransferNonce(address account) external view returns (uint256) {\r\n        return _nonce[account];\r\n    }\r\n\r\n    // Account token burning management\r\n    /**\r\n     * @dev Function that burns an amount of the token of a given\r\n     * account.\r\n     * Emits Transfer event, with to address set to zero.\r\n     *\r\n     * @return True on success.\r\n     */\r\n    function burnAccount(address account, uint256 value)\r\n        external\r\n        enabled(_features.AccountBurning())\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        _burn(account, value);\r\n        return true;\r\n    }\r\n\r\n    // Token managed burning/minting\r\n    /**\r\n     * @dev Function that burns an amount of the token of a given\r\n     * account.\r\n     * Emits Transfer event, with to address set to zero.\r\n     * Allowed only to manager.\r\n     *\r\n     * @return True on success.\r\n     */\r\n    function burn(address account, uint256 value) external onlyManager returns (bool) {\r\n        _burn(account, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function that mints an amount of the token to a given\r\n     * account.\r\n     * Emits Transfer event, with from address set to zero.\r\n     * Allowed only to manager.\r\n     *\r\n     * @return True on success.\r\n     */\r\n    function mint(address account, uint256 value) external onlyManager returns (bool) {\r\n        _mint(account, value);\r\n        return true;\r\n    }\r\n\r\n    // ERC20 part-like interface methods\r\n    /**\r\n     * @dev Total number of tokens in existence.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the balance of.\r\n     * @return A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * NOTE: Clients SHOULD make sure to create user interfaces in such a way that\r\n     * they set the allowance first to 0 before setting it to another value for\r\n     * the same spender. THOUGH The contract itself shouldn’t enforce it, to allow\r\n     * backwards compatibility with contracts deployed before\r\n     * Emit Approval event.\r\n     *\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 value) external returns (bool) {\r\n        require(_features.checkTransfer(msg.sender, to), \"Feature transfer check\");\r\n\r\n        if (_rules != ITransferRules(0)) {\r\n            require(_rules.doTransfer(msg.sender, to, value), \"Transfer failed\");\r\n        } else {\r\n            _transfer(msg.sender, to, value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        require(_features.checkTransfer(from, to), \"Feature transfer check\");\r\n\r\n        if (_rules != ITransferRules(0)) {\r\n            _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\r\n            require(_rules.doTransfer(from, to, value), \"Transfer failed\");\r\n        } else {\r\n            _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\r\n            _transfer(from, to, value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increase approved tokens to the spender on behalf of msg.sender.\r\n     *\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens that allowance will be increase for.\r\n     */\r\n    function increaseAllowance(address spender, uint256 value) external returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decrease approved tokens to the spender on behalf of msg.sender.\r\n     *\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens that allowance will be reduced for.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 value) external returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(value));\r\n        return true;\r\n    }\r\n\r\n    // Privates\r\n    /**\r\n     * @dev Internal transfer token to specified address. Caller needs to provide authorization\r\n     * signature obtained from MAP API, signed by authority accepted by token issuer.\r\n     * Emits Transfer event.\r\n     *\r\n     * @param from The address to transfer from.\r\n     * @param to The address to send tokens to.\r\n     * @param value The amount of tokens to send.\r\n     * @param nonce Token transfer nonce, can not repeat nance for subsequent\r\n     * token transfers.\r\n     * @param expirationTime Timestamp until transfer request is valid.\r\n     * @param hash Hash of transfer params (kyaHash, from, to, value, nonce, expirationTime).\r\n     * @param signature Ethereum ECDSA signature of msgHash signed by one of authorities.\r\n     * @return True on success.\r\n     */\r\n    function _transferToken(\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        uint256 nonce,\r\n        uint256 expirationTime,\r\n        bytes32 hash,\r\n        bytes memory signature\r\n    )\r\n        internal returns (bool)\r\n    {\r\n        if (address(_restrictions) != address(0)) {\r\n            require(_restrictions.authorize(from, to, value), \"transferToken restrictions failed\");\r\n        }\r\n\r\n        require(now <= expirationTime, \"transferToken params expired\");\r\n        require(nonce == _nonce[from], \"transferToken params wrong nonce\");\r\n\r\n        (bytes32 kyaHash, string memory kyaUrl) = _assetRegistry.getKYA(address(this));\r\n\r\n        require(\r\n            keccak256(abi.encodePacked(kyaHash, from, to, value, nonce, expirationTime)) == hash,\r\n            \"transferToken params bad hash\"\r\n        );\r\n        require(_roles.isAuthority(hash.toEthSignedMessageHash().recover(signature)), \"transferToken params not authority\");\r\n\r\n        require(_features.checkTransfer(from, to), \"Feature transfer check\");\r\n        _transfer(from, to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified addresses.\r\n     * @param from The address to transfer from.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0), \"Recipient is zero address\");\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n\r\n        _nonce[from]++;\r\n\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * Emit Transfer event.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), 'burning from zero address');\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token on given\r\n     * account.\r\n     * Emit Transfer event.\r\n     *\r\n     * @param account The account where tokens will be minted.\r\n     * @param value The amount that will be minted.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0), 'minting to zero address');\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        require(_totalSupply <= _maxTotalSupply || _maxTotalSupply == 0, 'trying to mint too many tokens!');\r\n\r\n        _balances[account] = _balances[account].add(value);\r\n\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve an address to spend another addresses' tokens.\r\n     * NOTE: Clients SHOULD make sure to create user interfaces in such a way that\r\n     * they set the allowance first to 0 before setting it to another value for\r\n     * the same spender. THOUGH The contract itself shouldn’t enforce it, to allow\r\n     * backwards compatibility with contracts deployed before\r\n     * Emit Approval event.\r\n     *\r\n     * @param owner The address that owns the tokens.\r\n     * @param spender The address that will spend the tokens.\r\n     * @param value The number of tokens that can be spent.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), 'approve from the zero address');\r\n        require(spender != address(0), 'approve to the zero address');\r\n\r\n        _allowances[owner][spender] = value;\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * Perform multiple token transfers from the token owner's address.\r\n     * The tokens should already be minted. If this function is to be called by\r\n     * an actor other than the owner (a delegate), the owner has to call approve()\r\n     * first to set up the delegate's allowance.\r\n     *\r\n     * @param _addresses an array of addresses to transfer to\r\n     * @param _values an array of values\r\n     * @return True on success\r\n     */\r\n    function bulkTransfer (\r\n        address[] calldata _addresses, uint256[] calldata _values) external onlyDelegate returns (bool) {\r\n        require(_addresses.length == _values.length, \"Input dataset length mismatch\");\r\n\r\n        uint256 count = _addresses.length;\r\n        for (uint256 i = 0; i < count; i++) {\r\n            address to = _addresses[i];\r\n            uint256 value = _values[i];\r\n            _approve(owner(), msg.sender, _allowances[owner()][msg.sender].sub(value));\r\n            _transfer(owner(), to, value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Perform multiple token transfers from the token owner's address.\r\n     * The tokens should already be minted. If this function is to be called by\r\n     * an actor other than the owner (a delegate), the owner has to call approve()\r\n     * first to set up the delegate's allowance.\r\n     *\r\n     * Data needs to be packed correctly before calling this function.\r\n     *\r\n     * @param _lotSize number of tokens in the lot\r\n     * @param _transfers an array or encoded transfers to perform\r\n     * @return True on success\r\n     */\r\n    function encodedBulkTransfer (\r\n        uint160 _lotSize, uint256[] calldata _transfers) external onlyDelegate returns (bool) {\r\n\r\n        uint256 count = _transfers.length;\r\n        for (uint256 i = 0; i < count; i++) {\r\n            uint256 tr = _transfers[i];\r\n            uint256 value = (tr >> 160) * _lotSize;\r\n            address to = address (tr & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n            _approve(owner(), msg.sender, _allowances[owner()][msg.sender].sub(value));\r\n            _transfer(owner(), to, value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_allowances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferTokenForced\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"bulkTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"transferToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_maxTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"restrictions\",\"type\":\"address\"},{\"name\":\"rules\",\"type\":\"address\"}],\"name\":\"updateRestrictionsAndRules\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_restrictions\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lotSize\",\"type\":\"uint160\"},{\"name\":\"_transfers\",\"type\":\"uint256[]\"}],\"name\":\"encodedBulkTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_roles\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTransferNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"transferTokenFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_assetRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_features\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"executeTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_rules\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTransferNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"maxTotalSupply\",\"type\":\"uint256\"},{\"name\":\"addressList\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"restrictions\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rules\",\"type\":\"address\"}],\"name\":\"RestrictionsAndRulesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SRC20","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000084595161401484a0000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000f4445534b544f502d5251484130564d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000342435400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007000000000000000000000000c39bf343cfc1083497549d7f10468769becc79e4000000000000000000000000f6a15821e5997b4447b351f9d0336d57facc0965000000000000000000000000f6a15821e5997b4447b351f9d0336d57facc09650000000000000000000000006e3f43025ab760c4ef9d65e4ffc420c691fcf062000000000000000000000000a1be5d6123ef7e6fad65b7a5edd2af34dde81e0e00000000000000000000000030b32447137dddf089b327085d2026eaf2eaf65a00000000000000000000000090d5a4e236f21a1b8c540011415709540104b981","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://f74e0a1f5817534dad6b9d79d68914a379d4e285aa227b2ca7108ddcaf62597c"}]}