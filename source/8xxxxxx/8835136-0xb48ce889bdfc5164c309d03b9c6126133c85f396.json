{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"petersburg\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts_common/src/BaseWithStorage/ProxyImplementation.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ncontract ProxyImplementation {\\n    mapping(string => bool) _initialised;\\n\\n    modifier phase(string memory phaseName) {\\n        if (!_initialised[phaseName]) {\\n            _initialised[phaseName] = true;\\n            _;\\n        }\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0x9bfcb76a8aa264d0b33fb8b24c9401198a8e42ec8230ad6cc60ee628e3734fa4\"\r\n    },\r\n    \"contracts_common/src/Interfaces/ERC1271.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ncontract ERC1271 {\\n\\n    /**\\n    * @dev Should return whether the signature provided is valid for the provided data\\n    * @param data Arbitrary length data signed on the behalf of address(this)\\n    * @param signature Signature byte array associated with _data\\n    *\\n    * MUST return the bytes4 magic value 0x20c13b0b when function passes.\\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\n    * MUST allow external calls\\n    */\\n    function isValidSignature(bytes memory data, bytes memory signature)\\n        public\\n        view\\n        returns (bytes4 magicValue);\\n}\\n\",\r\n      \"keccak256\": \"0xc96d98567763b067bb0264c9fed2a0df1e638b82e416c86e223e7e1cf2354514\"\r\n    },\r\n    \"contracts_common/src/Interfaces/ERC1271Constants.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ncontract ERC1271Constants {\\n    bytes4 internal constant ERC1271_MAGICVALUE = 0x20c13b0b;\\n}\\n\",\r\n      \"keccak256\": \"0xe0fa0515924272c2536cc0e09428c456e0303d968cccbcb3395ea5237743c068\"\r\n    },\r\n    \"contracts_common/src/Interfaces/ERC1654.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ncontract ERC1654 {\\n\\n    /**\\n    * @dev Should return whether the signature provided is valid for the provided hash\\n    * @param hash 32 bytes hash to be signed\\n    * @param signature Signature byte array associated with hash\\n    * @return 0x1626ba7e if valid else 0x00000000\\n    */\\n    function isValidSignature(bytes32 hash, bytes memory signature)\\n        public\\n        view\\n        returns (bytes4 magicValue);\\n}\\n\",\r\n      \"keccak256\": \"0xa5a9f130315c41a3578c374651fedc45de45cf66e442442e1c6e3b5fab896db6\"\r\n    },\r\n    \"contracts_common/src/Interfaces/ERC1654Constants.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ncontract ERC1654Constants {\\n    bytes4 internal constant ERC1654_MAGICVALUE = 0x1626ba7e;\\n}\\n\",\r\n      \"keccak256\": \"0xc89fe81450f551045b148248ec1bb82156b20918e7dcb88b96e41ddcb62108a5\"\r\n    },\r\n    \"contracts_common/src/Libraries/BytesUtil.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nlibrary BytesUtil {\\n    function memcpy(uint256 dest, uint256 src, uint256 len) internal pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint256 mask = 256**(32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    function pointerToBytes(uint256 src, uint256 len)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory ret = new bytes(len);\\n        uint256 retptr;\\n        assembly {\\n            retptr := add(ret, 32)\\n        }\\n\\n        memcpy(retptr, src, len);\\n        return ret;\\n    }\\n\\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(\\n                add(m, 20),\\n                xor(0x140000000000000000000000000000000000000000, a)\\n            )\\n            mstore(0x40, add(m, 52))\\n            b := m\\n        }\\n    }\\n\\n    function uint256ToBytes(uint256 a) internal pure returns (bytes memory b) {\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 32), a)\\n            mstore(0x40, add(m, 64))\\n            b := m\\n        }\\n    }\\n\\n    function doFirstParamEqualsAddress(bytes memory data, address _address)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        if (data.length < (36 + 32)) {\\n            return false;\\n        }\\n        uint256 value;\\n        assembly {\\n            value := mload(add(data, 36))\\n        }\\n        return value == uint256(_address);\\n    }\\n\\n    function doParamEqualsUInt256(bytes memory data, uint256 i, uint256 value)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        if (data.length < (36 + (i + 1) * 32)) {\\n            return false;\\n        }\\n        uint256 offset = 36 + i * 32;\\n        uint256 valuePresent;\\n        assembly {\\n            valuePresent := mload(add(data, offset))\\n        }\\n        return valuePresent == value;\\n    }\\n\\n    function overrideFirst32BytesWithAddress(\\n        bytes memory data,\\n        address _address\\n    ) internal pure returns (bytes memory) {\\n        uint256 dest;\\n        assembly {\\n            dest := add(data, 48)\\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\\n\\n        bytes memory addressBytes = addressToBytes(_address);\\n        uint256 src;\\n        assembly {\\n            src := add(addressBytes, 32)\\n        }\\n\\n        memcpy(dest, src, 20);\\n        return data;\\n    }\\n\\n    function overrideFirstTwo32BytesWithAddressAndInt(\\n        bytes memory data,\\n        address _address,\\n        uint256 _value\\n    ) internal pure returns (bytes memory) {\\n        uint256 dest;\\n        uint256 src;\\n\\n        assembly {\\n            dest := add(data, 48)\\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\\n        bytes memory bbytes = addressToBytes(_address);\\n        assembly {\\n            src := add(bbytes, 32)\\n        }\\n        memcpy(dest, src, 20);\\n\\n        assembly {\\n            dest := add(data, 68)\\n        } // 48 = 32 (offset) + 4 (func sig) + 32 (next slot)\\n        bbytes = uint256ToBytes(_value);\\n        assembly {\\n            src := add(bbytes, 32)\\n        }\\n        memcpy(dest, src, 32);\\n\\n        return data;\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0xb5c236938e1f71524127371a015836e83103c5ac1b4ed7b7f22892a8c0429e10\"\r\n    },\r\n    \"contracts_common/src/Libraries/SigUtil.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nlibrary SigUtil {\\n    function recover(bytes32 hash, bytes memory sig)\\n        internal\\n        pure\\n        returns (address recovered)\\n    {\\n        require(sig.length == 65);\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            r := mload(add(sig, 32))\\n            s := mload(add(sig, 64))\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n\\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\\n        if (v < 27) {\\n            v += 27;\\n        }\\n        require(v == 27 || v == 28);\\n\\n        recovered = ecrecover(hash, v, r, s);\\n        require(recovered != address(0));\\n    }\\n\\n    function recoverWithZeroOnFailure(bytes32 hash, bytes memory sig)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        if (sig.length != 65) {\\n            return (address(0));\\n        }\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            r := mload(add(sig, 32))\\n            s := mload(add(sig, 64))\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n\\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\\n        if (v < 27) {\\n            v += 27;\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            return (address(0));\\n        } else {\\n            return ecrecover(hash, v, r, s);\\n        }\\n    }\\n\\n    // Builds a prefixed hash to mimic the behavior of eth_sign.\\n    function prefixed(bytes32 hash) internal pure returns (bytes memory) {\\n        return abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash);\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0xda7729e5b24c3780242ed1923b2a709ab284c18ee533669d6d0fa394ffb0491b\"\r\n    },\r\n    \"src/Sand/erc20/NativeMetaTransactionProcessor.sol\": {\r\n      \"content\": \"pragma solidity 0.5.9;\\n\\nimport \\\"../../../contracts_common/src/Libraries/BytesUtil.sol\\\";\\nimport \\\"../../../contracts_common/src/Libraries/SigUtil.sol\\\";\\nimport \\\"../../../contracts_common/src/Interfaces/ERC1271.sol\\\";\\nimport \\\"../../../contracts_common/src/Interfaces/ERC1271Constants.sol\\\";\\nimport \\\"../../../contracts_common/src/Interfaces/ERC1654.sol\\\";\\nimport \\\"../../../contracts_common/src/Interfaces/ERC1654Constants.sol\\\";\\nimport \\\"../../TheSandbox712.sol\\\";\\n\\ninterface ExecutionableERC20 {\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns(bool);\\n\\n    function approveAndExecuteWithSpecificGas(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 gasLimit,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    function approveAndExecuteWithSpecificGasAndChargeForIt(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 gasLimit,\\n        uint256 tokenGasPrice,\\n        uint256 baseGasCharge,\\n        address tokenReceiver,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    function transferAndChargeForGas(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 gasLimit,\\n        uint256 tokenGasPrice,\\n        uint256 baseGasCharge,\\n        address tokenReceiver\\n    ) external;\\n}\\n\\ncontract NativeMetaTransactionProcessor is ERC1654Constants, ERC1271Constants, TheSandbox712 {\\n    enum SignatureType { DIRECT, EIP1654, EIP1271 }\\n\\n    bytes32 constant ERC20METATRANSACTION_TYPEHASH = keccak256(\\n        \\\"ERC20MetaTransaction(address from,address to,uint256 amount,bytes data,uint256 nonce,uint256 minGasPrice,uint256 txGas,uint256 baseGas,uint256 tokenGasPrice,address relayer)\\\"\\n    );\\n    mapping(address => uint256) nonces;\\n\\n    event MetaTx(\\n        address indexed from,\\n        uint256 indexed nonce,\\n        bool success\\n    );\\n\\n    ExecutionableERC20 _tokenContract;\\n\\n    constructor(ExecutionableERC20 tokenContract) public {\\n        _tokenContract = tokenContract;\\n        init712();\\n    }\\n\\n    /// @notice gets the current nonce (number of metatx emitted) of `from`.\\n    /// @param owner The address to query the nonce of.\\n    /// @return the current nonce\\n    function meta_nonce(address owner) external view returns (uint256 nonce) {\\n        return nonces[owner];\\n    }\\n\\n    /// @notice perform the meta-tx using EIP-712 message.\\n    /// @param from address from which the meta-tx originate.\\n    /// @param to destination address where the call will be performed.\\n    /// @param amount number of tokens to be transfered/allowed as part of the call.\\n    /// @param data bytes to send to the destination.\\n    /// @param params the meta-tx parameters : nonce, minGasPrice, txGas, baseGas, tokenGasPrice.\\n    /// @param relayer the address allowed to perform the meta-tx.\\n    /// @param signature the signature that ensure from has allowed the meta-tx to be performed.\\n    /// @param tokenReceiver recipient of the gas charge.\\n    /// @param signatureType indicate whether it was signed via EOA=0, EIP-1654=1 or EIP-1271=2.\\n    /// @return success whether the execution was successful.\\n    /// @return returnData data resulting from the execution.\\n    function executeERC20MetaTx(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata data,\\n        uint256[5] calldata params, // nonce, minGasPrice, txGas, baseGas, tokenGasPrice\\n        address relayer,\\n        bytes calldata signature,\\n        address tokenReceiver,\\n        SignatureType signatureType\\n    ) external returns (bool success, bytes memory returnData) {\\n        ensureParametersValidity(from, params, relayer);\\n        ensureCorrectSigner(\\n            from,\\n            to,\\n            amount,\\n            data,\\n            params,\\n            relayer,\\n            signature,\\n            ERC20METATRANSACTION_TYPEHASH,\\n            signatureType\\n        );\\n        return\\n            performERC20MetaTx(\\n                from,\\n                to,\\n                amount,\\n                data,\\n                params,\\n                tokenReceiver\\n            );\\n    }\\n\\n    /// @notice perform the meta-tx using personal_sign message.\\n    /// @param from address from which the meta-tx originate.\\n    /// @param to destination address where the call will be performed.\\n    /// @param amount number of tokens to be transfered/allowed as part of the call.\\n    /// @param data bytes to send to the destination.\\n    /// @param params the meta-tx parameters : nonce, minGasPrice, txGas, baseGas, tokenGasPrice.\\n    /// @param relayer the address allowed to perform the meta-tx.\\n    /// @param signature the signature that ensure from has allowed the meta-tx to be performed.\\n    /// @param tokenReceiver recipient of the gas charge.\\n    /// @param signatureType indicate whether it was signed via EOA=0, EIP-1654=1 or EIP-1271=2.\\n    /// @return success whether the execution was successful.\\n    /// @return returnData data resulting from the execution.\\n    function executeERC20MetaTxViaBasicSignature(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata data,\\n        uint256[5] calldata params, // nonce, minGasPrice, txGas, baseGas, tokenGasPrice\\n        address relayer,\\n        bytes calldata signature,\\n        address tokenReceiver,\\n        SignatureType signatureType\\n    ) external returns (bool, bytes memory) {\\n        ensureParametersValidity(from, params, relayer);\\n        ensureCorrectSignerViaBasicSignature(\\n            from,\\n            to,\\n            amount,\\n            data,\\n            params,\\n            relayer,\\n            signature,\\n            ERC20METATRANSACTION_TYPEHASH,\\n            signatureType\\n        );\\n        return\\n            performERC20MetaTx(\\n                from,\\n                to,\\n                amount,\\n                data,\\n                params,\\n                tokenReceiver\\n            );\\n    }\\n\\n    function ensureParametersValidity(\\n        address from,\\n        uint256[5] memory params, // nonce, minGasPrice, txGas, baseGas, tokenGasPrice\\n        address relayer\\n    ) internal view {\\n        require(\\n            relayer == address(0) || relayer == msg.sender,\\n            \\\"wrong relayer\\\"\\n        );\\n        require(nonces[from] + 1 == params[0], \\\"nonce out of order\\\");\\n        require(tx.gasprice >= params[1], \\\"gasPrice < signer minGasPrice\\\");\\n    }\\n\\n    function ensureCorrectSigner(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes memory data,\\n        uint256[5] memory params, // nonce, minGasPrice, txGas, baseGas, tokenGasPrice\\n        address relayer,\\n        bytes memory signature,\\n        bytes32 typeHash,\\n        SignatureType signatureType\\n    ) internal view {\\n        bytes memory dataToHash = abi.encodePacked(\\n            \\\"\\\\x19\\\\x01\\\",\\n            domainSeparator(),\\n            keccak256(\\n                abi.encode(\\n                    typeHash,\\n                    from,\\n                    to,\\n                    amount,\\n                    keccak256(data),\\n                    params[0],\\n                    params[1],\\n                    params[2],\\n                    params[3],\\n                    params[4],\\n                    relayer\\n                )\\n            )\\n        );\\n        if (signatureType == SignatureType.EIP1271) {\\n            require(\\n                ERC1271(from).isValidSignature(dataToHash, signature) == ERC1271_MAGICVALUE,\\n                \\\"invalid 1271 signature\\\"\\n            );\\n        } else if(signatureType == SignatureType.EIP1654){\\n            require(\\n                ERC1654(from).isValidSignature(keccak256(dataToHash), signature) == ERC1654_MAGICVALUE,\\n                \\\"invalid 1654 signature\\\"\\n            );\\n        } else {\\n            address signer = SigUtil.recover(keccak256(dataToHash), signature);\\n            require(signer == from, \\\"signer != from\\\");\\n        }\\n    }\\n\\n    function encodeBasicSignatureData(\\n        bytes32 typeHash,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes memory data,\\n        uint256[5] memory params,\\n        address relayer\\n    ) internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    address(this),\\n                    typeHash,\\n                    from,\\n                    to,\\n                    amount,\\n                    keccak256(data),\\n                    params[0],\\n                    params[1],\\n                    params[2],\\n                    params[3],\\n                    params[4],\\n                    relayer\\n                )\\n            );\\n    }\\n\\n    function ensureCorrectSignerViaBasicSignature(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes memory data,\\n        uint256[5] memory params, // nonce, minGasPrice, txGas, baseGas, tokenGasPrice\\n        address relayer,\\n        bytes memory signature,\\n        bytes32 typeHash,\\n        SignatureType signatureType\\n    ) internal view {\\n        bytes memory dataToHash = SigUtil.prefixed(\\n            encodeBasicSignatureData(\\n                typeHash,\\n                from,\\n                to,\\n                amount,\\n                data,\\n                params,\\n                relayer\\n            )\\n        );\\n        if (signatureType == SignatureType.EIP1271) {\\n            require(\\n                ERC1271(from).isValidSignature(dataToHash, signature) == ERC1271_MAGICVALUE,\\n                \\\"invalid 1271 signature\\\"\\n            );\\n        } else if (signatureType == SignatureType.EIP1654) {\\n            require(\\n                ERC1654(from).isValidSignature(keccak256(dataToHash), signature) == ERC1654_MAGICVALUE,\\n                \\\"invalid 1654 signature\\\"\\n            );\\n        } else {\\n            address signer = SigUtil.recover(keccak256(dataToHash), signature);\\n            require(signer == from, \\\"signer != from\\\");\\n        }\\n    }\\n\\n    function performERC20MetaTx(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes memory data,\\n        uint256[5] memory params,\\n        address tokenReceiver\\n    ) internal returns (bool success, bytes memory returnData) {\\n        nonces[from] = params[0];\\n\\n        if (data.length == 0) {\\n            if(params[4] > 0) {\\n                _tokenContract.transferAndChargeForGas(\\n                    from,\\n                    to,\\n                    amount,\\n                    params[2],\\n                    params[4],\\n                    params[3],\\n                    tokenReceiver\\n                );\\n            } else {\\n                require(_tokenContract.transferFrom(from, to, amount), \\\"failed transfer\\\");\\n            }\\n            success = true;\\n        } else {\\n            require(\\n                BytesUtil.doFirstParamEqualsAddress(data, from),\\n                \\\"first param != from\\\"\\n            );\\n            if(params[4] > 0) {\\n                (success, returnData) = _tokenContract.approveAndExecuteWithSpecificGasAndChargeForIt(\\n                    from,\\n                    to,\\n                    amount,\\n                    params[2],\\n                    params[4],\\n                    params[3],\\n                    tokenReceiver,\\n                    data\\n                );\\n            } else {\\n                (success, returnData) = _tokenContract.approveAndExecuteWithSpecificGas(from, to, amount, params[2], data);\\n            }\\n        }\\n\\n        emit MetaTx(from, params[0], success);\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0x8522a1057a6efcf65284626b20125ce343edb11a7783a8e07fb252bfe9b74f30\"\r\n    },\r\n    \"src/TheSandbox712.sol\": {\r\n      \"content\": \"pragma solidity 0.5.9;\\n\\nimport {\\n    ProxyImplementation\\n} from \\\"../contracts_common/src/BaseWithStorage/ProxyImplementation.sol\\\";\\n\\ncontract TheSandbox712 is ProxyImplementation {\\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\\n        \\\"EIP712Domain(string name,string version,address verifyingContract)\\\"\\n    );\\n    bytes32 DOMAIN_SEPARATOR;\\n\\n    function init712() public phase(\\\"712\\\") {\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                EIP712DOMAIN_TYPEHASH,\\n                keccak256(\\\"The Sandbox 3D\\\"),\\n                keccak256(\\\"1\\\"),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function domainSeparator() internal view returns (bytes32) {\\n        return DOMAIN_SEPARATOR;\\n    }\\n}\\n\",\r\n      \"keccak256\": \"0x76f0233c0b532620a8d3a129d30b6551869be42514cbe2b03004400ea230de54\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"meta_nonce\",\"outputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"params\",\"type\":\"uint256[5]\"},{\"name\":\"relayer\",\"type\":\"address\"},{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"tokenReceiver\",\"type\":\"address\"},{\"name\":\"signatureType\",\"type\":\"uint8\"}],\"name\":\"executeERC20MetaTxViaBasicSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"params\",\"type\":\"uint256[5]\"},{\"name\":\"relayer\",\"type\":\"address\"},{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"tokenReceiver\",\"type\":\"address\"},{\"name\":\"signatureType\",\"type\":\"uint8\"}],\"name\":\"executeERC20MetaTx\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"init712\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"MetaTx\",\"type\":\"event\"}]","ContractName":"NativeMetaTransactionProcessor","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"0000000000000000000000003845badade8e6dff049820680d1f14bd3903a5d0","Library":"","LicenseType":"None","SwarmSource":"bzzr://31a490d829ddb4cd9001e774a0a495b144837f5228105d37cc1759031bbf7fde"}]}