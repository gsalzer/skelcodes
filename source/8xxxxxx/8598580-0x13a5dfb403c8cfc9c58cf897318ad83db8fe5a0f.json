{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IERC20 {\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external;\r\n  function transferFrom(address from, address to, uint256 value) external;\r\n  function approve(address spender, uint256 value) external;\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/// @title Utility Functions for bytes\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary LoopringBytesUtil {\r\n    function bytesToBytes32(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return bytes32(bytesToUintX(b, offset, 32));\r\n    }\r\n\r\n    function bytesToUint(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        return bytesToUintX(b, offset, 32);\r\n    }\r\n\r\n    function bytesToAddress(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        return address(bytesToUintX(b, offset, 20) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    }\r\n\r\n    function bytesToUint16(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint16)\r\n    {\r\n        return uint16(bytesToUintX(b, offset, 2) & 0xFFFF);\r\n    }\r\n\r\n    function bytesToUintX(\r\n        bytes memory b,\r\n        uint offset,\r\n        uint numBytes\r\n        )\r\n        private\r\n        pure\r\n        returns (uint data)\r\n    {\r\n        require(b.length >= offset + numBytes, \"INVALID_SIZE\");\r\n        assembly {\r\n            data := mload(add(add(b, numBytes), offset))\r\n        }\r\n    }\r\n\r\n    function subBytes(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes memory data)\r\n    {\r\n        require(b.length >= offset + 32, \"INVALID_SIZE\");\r\n        assembly {\r\n            data := add(add(b, 32), offset)\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary DydxTypes {\r\n\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par  // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    struct TotalPar {\r\n        uint128 borrow;\r\n        uint128 supply;\r\n    }\r\n\r\n    struct Par {\r\n        bool sign; // true if positive\r\n        uint128 value;\r\n    }\r\n\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n}\r\n\r\n\r\nlibrary DydxPosition {\r\n    enum Status {\r\n        Normal,\r\n        Liquid,\r\n        Vapor\r\n    }\r\n\r\n    struct Info {\r\n        address owner;\r\n        uint256 number;\r\n    }\r\n\r\n    struct Storage {\r\n        mapping (uint256 => DydxTypes.Par) balances;\r\n        Status status;\r\n    }\r\n\r\n    function equals(\r\n        Info memory a,\r\n        Info memory b\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return a.owner == b.owner && a.number == b.number;\r\n    }\r\n}\r\n\r\n\r\nlibrary DydxActions {\r\n\r\n    enum ActionType {\r\n        Deposit,   // supply tokens\r\n        Withdraw,  // borrow tokens\r\n        Transfer,  // transfer balance between accounts\r\n        Buy,       // buy an amount of some token (externally)\r\n        Sell,      // sell an amount of some token (externally)\r\n        Trade,     // trade tokens against another account\r\n        Liquidate, // liquidate an undercollateralized or expiring account\r\n        Vaporize,  // use excess tokens to zero-out a completely negative account\r\n        Call       // send arbitrary data to an address\r\n    }\r\n\r\n    enum AccountLayout {\r\n        OnePrimary,\r\n        TwoPrimary,\r\n        PrimaryAndSecondary\r\n    }\r\n\r\n    enum MarketLayout {\r\n        ZeroMarkets,\r\n        OneMarket,\r\n        TwoMarkets\r\n    }\r\n\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        DydxTypes.AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n\r\n    struct DepositArgs {\r\n        DydxTypes.AssetAmount amount;\r\n        DydxPosition.Info account;\r\n        uint256 market;\r\n        address from;\r\n    }\r\n\r\n    struct WithdrawArgs {\r\n        DydxTypes.AssetAmount amount;\r\n        DydxPosition.Info account;\r\n        uint256 market;\r\n        address to;\r\n    }\r\n\r\n    struct TransferArgs {\r\n        DydxTypes.AssetAmount amount;\r\n        DydxPosition.Info accountOne;\r\n        DydxPosition.Info accountTwo;\r\n        uint256 market;\r\n    }\r\n\r\n    struct BuyArgs {\r\n        DydxTypes.AssetAmount amount;\r\n        DydxPosition.Info account;\r\n        uint256 makerMarket;\r\n        uint256 takerMarket;\r\n        address exchangeWrapper;\r\n        bytes orderData;\r\n    }\r\n\r\n    struct SellArgs {\r\n        DydxTypes.AssetAmount amount;\r\n        DydxPosition.Info account;\r\n        uint256 takerMarket;\r\n        uint256 makerMarket;\r\n        address exchangeWrapper;\r\n        bytes orderData;\r\n    }\r\n\r\n    struct TradeArgs {\r\n        DydxTypes.AssetAmount amount;\r\n        DydxPosition.Info takerAccount;\r\n        DydxPosition.Info makerAccount;\r\n        uint256 inputMarket;\r\n        uint256 outputMarket;\r\n        address autoTrader;\r\n        bytes tradeData;\r\n    }\r\n\r\n    struct LiquidateArgs {\r\n        DydxTypes.AssetAmount amount;\r\n        DydxPosition.Info solidAccount;\r\n        DydxPosition.Info liquidAccount;\r\n        uint256 owedMarket;\r\n        uint256 heldMarket;\r\n    }\r\n\r\n    struct VaporizeArgs {\r\n        DydxTypes.AssetAmount amount;\r\n        DydxPosition.Info solidAccount;\r\n        DydxPosition.Info vaporAccount;\r\n        uint256 owedMarket;\r\n        uint256 heldMarket;\r\n    }\r\n\r\n    struct CallArgs {\r\n        DydxPosition.Info account;\r\n        address callee;\r\n        bytes data;\r\n    }\r\n}\r\n\r\n\r\ninterface IDydxExchangeWrapper {\r\n\r\n  function exchange(\r\n    address tradeOriginator,\r\n    address receiver,\r\n    address makerToken,\r\n    address takerToken,\r\n    uint256 requestedFillAmount,\r\n    bytes calldata orderData\r\n  )\r\n    external\r\n    returns (uint256);\r\n\r\n  function getExchangeCost(\r\n    address makerToken,\r\n    address takerToken,\r\n    uint256 desiredMakerToken,\r\n    bytes calldata orderData\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n}\r\n\r\n\r\ncontract DydxProtocol {\r\n  \r\n  struct OperatorArg {\r\n      address operator;\r\n      bool trusted;\r\n  }\r\n\r\n  function operate(\r\n      DydxPosition.Info[] calldata accounts,\r\n      DydxActions.ActionArgs[] calldata actions\r\n  ) external;\r\n\r\n  function getMarketTokenAddress(uint256 marketId)\r\n      external\r\n      view\r\n      returns (address);\r\n\r\n  function setOperators(OperatorArg[] calldata args) external;\r\n}\r\n\r\n\r\nlibrary LoopringTypes {\r\n\r\n    enum TokenType { ERC20 }\r\n\r\n    struct Header {\r\n        uint version;\r\n        uint numOrders;\r\n        uint numRings;\r\n        uint numSpendables;\r\n    }\r\n\r\n    struct Spendable {\r\n        bool initialized;\r\n        uint amount;\r\n        uint reserved;\r\n    }\r\n\r\n    struct Order {\r\n        uint      version;\r\n\r\n        // required fields\r\n        address   owner;\r\n        address   tokenS;\r\n        address   tokenB;\r\n        uint      amountS;\r\n        uint      amountB;\r\n        uint      validSince;\r\n        Spendable tokenSpendableS;\r\n        Spendable tokenSpendableFee;\r\n\r\n        // optional fields\r\n        address   dualAuthAddr;\r\n        address   broker;\r\n        Spendable brokerSpendableS;\r\n        Spendable brokerSpendableFee;\r\n        address   orderInterceptor;\r\n        address   wallet;\r\n        uint      validUntil;\r\n        bytes     sig;\r\n        bytes     dualAuthSig;\r\n        bool      allOrNone;\r\n        address   feeToken;\r\n        uint      feeAmount;\r\n        int16     waiveFeePercentage;\r\n        uint16    tokenSFeePercentage;    // Pre-trading\r\n        uint16    tokenBFeePercentage;   // Post-trading\r\n        address   tokenRecipient;\r\n        uint16    walletSplitPercentage;\r\n\r\n        // computed fields\r\n        bool    P2P;\r\n        bytes32 hash;\r\n        address brokerInterceptor;\r\n        uint    filledAmountS;\r\n        uint    initialFilledAmountS;\r\n        bool    valid;\r\n\r\n        TokenType tokenTypeS;\r\n        TokenType tokenTypeB;\r\n        TokenType tokenTypeFee;\r\n        bytes32 trancheS;\r\n        bytes32 trancheB;\r\n        bytes   transferDataS;\r\n    }\r\n\r\n    struct Participation {\r\n        // required fields\r\n        Order order;\r\n\r\n        // computed fields\r\n        uint splitS;\r\n        uint feeAmount;\r\n        uint feeAmountS;\r\n        uint feeAmountB;\r\n        uint rebateFee;\r\n        uint rebateS;\r\n        uint rebateB;\r\n        uint fillAmountS;\r\n        uint fillAmountB;\r\n    }\r\n\r\n    struct Ring {\r\n        uint size;\r\n        Participation[] participations;\r\n        bytes32 hash;\r\n        uint minerFeesToOrdersPercentage;\r\n        bool valid;\r\n    }\r\n}\r\n\r\n\r\nlibrary Types {\r\n\r\n  struct MarginRingSubmission {\r\n    uint positionId;\r\n    uint marginOrderIndex;\r\n    uint marketIdS;\r\n    uint marketIdB;\r\n    uint fillAmountS;\r\n    uint fillAmountB;\r\n    bytes ringData;\r\n  }\r\n\r\n  struct RelayerInfo {\r\n    uint positionId;\r\n    uint marginOrderIndex;\r\n    uint marketIdS;\r\n    uint marketIdB;\r\n    uint fillAmountS;\r\n    uint fillAmountB;\r\n  }\r\n\r\n  enum MarginOrderType { OPEN_LONG, OPEN_SHORT, CLOSE_LONG, CLOSE_SHORT }\r\n  \r\n  struct MarginOrderDetails {\r\n    MarginOrderType positionType;\r\n    uint depositAmount;\r\n    uint depositMarketId;\r\n    uint expiration;\r\n\r\n    // calculated\r\n    address owner;\r\n    address depositToken;\r\n    uint withdrawalMarketId;\r\n    bool isOpen;\r\n    bool isLong;\r\n  }\r\n\r\n  enum OrderDataSide { BUY, SELL }\r\n\r\n  struct OrderData {\r\n    OrderDataSide side;\r\n    uint fillAmountS;\r\n    uint fillAmountB;\r\n    bytes ringData;\r\n    uint marginOrderIndex;\r\n    address trader;\r\n\r\n    // Helper (not encoded/decoded)\r\n    bool bringToZero; // should bring the account balance to zero\r\n  }\r\n}\r\n\r\n\r\ncontract LoopringProtocol {\r\n  address public lrcTokenAddress;\r\n  address public delegateAddress;\r\n  function submitRings(bytes calldata data) external;\r\n}\r\n\r\n\r\ncontract ITradeDelegate {\r\n  function batchTransfer(bytes32[] calldata batch) external;\r\n}\r\n\r\n\r\nlibrary DecodeHelper {\r\n  using LoopringBytesUtil for bytes;\r\n\r\n  function decodeRelayerInfo(bytes memory self) internal pure returns (Types.RelayerInfo memory relayerInfo) {\r\n    (\r\n      relayerInfo.positionId,\r\n      relayerInfo.marginOrderIndex,\r\n      relayerInfo.marketIdS,\r\n      relayerInfo.marketIdB,\r\n      relayerInfo.fillAmountS,\r\n      relayerInfo.fillAmountB\r\n    ) = abi.decode(self, (uint, uint, uint, uint, uint, uint));\r\n  }\r\n\r\n  function decodeMarginTradeDetails(bytes memory self, bytes4 requiredOrderSelector) \r\n    internal \r\n    pure \r\n    returns (Types.MarginOrderDetails memory details) \r\n  {\r\n    uint typeRaw;\r\n    bytes4 orderSelector;\r\n\r\n    (\r\n      orderSelector,\r\n      typeRaw,\r\n      details.depositAmount,\r\n      details.depositMarketId,\r\n      details.expiration\r\n    ) = abi.decode(self, (bytes4, uint, uint, uint, uint));\r\n\r\n    require(orderSelector == requiredOrderSelector, \"Margin order must have proper selector header in transferDataS\");\r\n\r\n    if (typeRaw == 0) details.positionType = Types.MarginOrderType.OPEN_LONG;\r\n    else if (typeRaw == 1) details.positionType = Types.MarginOrderType.OPEN_SHORT;\r\n    else if (typeRaw == 2) details.positionType = Types.MarginOrderType.CLOSE_LONG;\r\n    else if (typeRaw == 3) details.positionType = Types.MarginOrderType.CLOSE_SHORT;\r\n    else revert(\"Invalid margin order type\");\r\n\r\n    details.isOpen = typeRaw < 2;\r\n    details.isLong = typeRaw == 0 || typeRaw == 2;\r\n  }\r\n\r\n  function decodeOrderData(bytes memory self) internal pure returns (Types.OrderData memory orderData) {\r\n    uint sideRaw;\r\n\r\n    (\r\n      sideRaw,\r\n      orderData.fillAmountS,\r\n      orderData.fillAmountB,\r\n      orderData.ringData,\r\n      orderData.marginOrderIndex,\r\n      orderData.trader\r\n    ) = abi.decode(self, (uint, uint, uint, bytes, uint, address));\r\n\r\n    orderData.side = sideRaw == 0 ? Types.OrderDataSide.BUY : Types.OrderDataSide.SELL;\r\n  }\r\n\r\n  /**\r\n   * Find the location of the specified order in the given bytes and\r\n   * decode it into a Loopring Order struct\r\n   */\r\n  uint private constant ORDER_STRUCT_SIZE = 38 * 32;\r\n\r\n  function decodeMinimalOrderAtIndex(\r\n    bytes memory self, \r\n    uint orderIndex, \r\n    address lrcTokenAddress\r\n  ) \r\n    internal \r\n    pure \r\n    returns (LoopringTypes.Order memory order) \r\n  {\r\n    \r\n    // Read the header\r\n    uint numOrders = self.bytesToUint16(2);\r\n    uint numRings = self.bytesToUint16(4);\r\n\r\n    // Calculate data pointers\r\n    uint dataPtr;\r\n    assembly { dataPtr := self }\r\n    uint tablesPtr = dataPtr + 8 + (3 * 2);\r\n    uint data = (tablesPtr + (30 * numOrders) * 2) + (numRings * 9) + 32;\r\n    \r\n    // Decode single order \r\n    bytes memory emptyBytes = new bytes(0);\r\n    uint offset = orderIndex * ORDER_STRUCT_SIZE; // start offset at specified order index\r\n    tablesPtr += 2;\r\n\r\n    assembly {\r\n      \r\n      // order.owner\r\n      offset := mul(and(mload(add(tablesPtr,  2)), 0xFFFF), 4)\r\n      mstore(\r\n        add(order,  32),\r\n        and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      )\r\n\r\n      // order.tokenS\r\n      offset := mul(and(mload(add(tablesPtr,  4)), 0xFFFF), 4)\r\n      mstore(\r\n        add(order,  64),\r\n        and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      )\r\n\r\n      // order.tokenB\r\n      offset := mul(and(mload(add(tablesPtr,  6)), 0xFFFF), 4)\r\n      mstore(\r\n        add(order,  96),\r\n        and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      )\r\n\r\n      // order.amountS\r\n      offset := mul(and(mload(add(tablesPtr,  8)), 0xFFFF), 4)\r\n      mstore(\r\n        add(order, 128),\r\n        mload(add(add(data, 32), offset))\r\n      )\r\n\r\n      // order.amountB\r\n      offset := mul(and(mload(add(tablesPtr, 10)), 0xFFFF), 4)\r\n      mstore(\r\n        add(order, 160),\r\n        mload(add(add(data, 32), offset))\r\n      )\r\n\r\n      // order.broker\r\n      offset := mul(and(mload(add(tablesPtr, 20)), 0xFFFF), 4)\r\n      mstore(\r\n          add(order, 320),\r\n          and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      )\r\n\r\n      // lrcTokenAddress is the default value for feeToken\r\n      mstore(add(data, 20), lrcTokenAddress)\r\n\r\n      // order.feeToken\r\n      offset := mul(and(mload(add(tablesPtr, 34)), 0xFFFF), 4)\r\n      mstore(\r\n          add(order, 608),\r\n          and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      )\r\n\r\n      // Restore default to 0\r\n      mstore(add(data, 20), 0)\r\n\r\n      // order.feeAmount\r\n      offset := mul(and(mload(add(tablesPtr, 36)), 0xFFFF), 4)\r\n      mstore(\r\n          add(order, 640),\r\n          mload(add(add(data, 32), offset))\r\n      )\r\n\r\n      // The owner is the default value of tokenRecipient\r\n      mstore(add(data, 20), mload(add(order, 32))) // order.owner\r\n\r\n      // order.tokenRecipient\r\n      offset := mul(and(mload(add(tablesPtr, 44)), 0xFFFF), 4)\r\n      mstore(\r\n          add(order, 768),\r\n          and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      )\r\n\r\n      // Restore default to 0\r\n      mstore(add(data, 20), 0)\r\n\r\n      // Default to empty bytes array for transferDataS\r\n      mstore(add(data, 32), emptyBytes)\r\n\r\n      // order.transferDataS\r\n      offset := mul(and(mload(add(tablesPtr, 58)), 0xFFFF), 4)\r\n      mstore(\r\n          add(order, 1184),\r\n          add(data, add(offset, 32))\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\n\r\nlibrary MarginOrderHelper {\r\n  using DecodeHelper for bytes;\r\n  using SafeMath for uint;\r\n\r\n  function getAmountB(LoopringTypes.Order memory self) internal pure returns (uint) {\r\n    return calculateActualAmount(self, self.amountB, self.tokenB);\r\n  }\r\n\r\n  function getAmountS(LoopringTypes.Order memory self) internal pure returns (uint) {\r\n    return calculateActualAmount(self, self.amountS, self.tokenS);\r\n  }\r\n\r\n  /**\r\n   * Calculate actual amount by matching feeToken with the given token\r\n   * and then adding/subtracting the feeAmount from the given amount\r\n   */\r\n  function calculateActualAmount(\r\n    LoopringTypes.Order memory self, \r\n    uint fillAmount, \r\n    address token\r\n  ) \r\n    internal \r\n    pure \r\n    returns (uint) \r\n  {\r\n    if (token == self.tokenS && token == self.feeToken) return fillAmount.add(self.feeAmount);\r\n    if (token == self.tokenB && token == self.feeToken) return fillAmount.sub(self.feeAmount);\r\n    return fillAmount;\r\n  }\r\n\r\n  /**\r\n   * Decode the fields necessary to open/close a long/short position from the Order.\r\n   * These fields are encoded in the `bytes transferDataS` field of an order.\r\n   */\r\n  function getMarginOrderDetails(LoopringTypes.Order memory self, bytes4 requiredOrderSelector) \r\n    internal \r\n    view \r\n    returns (Types.MarginOrderDetails memory details) \r\n  {\r\n    details = self.transferDataS.decodeMarginTradeDetails(requiredOrderSelector);\r\n    details.owner = self.owner;\r\n    details.depositToken = self.tokenB;\r\n  }\r\n\r\n  /**\r\n   * Check the validity of the provided Loopring order and the \r\n   * margin order details encoded in it's transferDataS field\r\n   * as well as confirming the validity of the information provided\r\n   * by the relayer.\r\n   */\r\n  string constant INVALID_MARKET_S = \"marketIdS provided by relayer must be have address equal to tokenS\";\r\n  string constant INVALID_MARKET_B = \"marketIdB provided by relayer must be have address equal to tokenB\";\r\n  string constant INVALID_DEPOSIT_MARKET = \"depositMarketId must have an address equal to tokenB\";\r\n  string constant INVALID_TOKEN_RECIPIENT = \"Invalid tokenRecipient - must be set correctly\";\r\n\r\n  function checkValidity(\r\n    LoopringTypes.Order memory self, \r\n    Types.RelayerInfo memory relayerInfo,\r\n    Types.MarginOrderDetails memory marginDetails,\r\n    DydxProtocol dydxProtocol\r\n  ) \r\n    internal\r\n    view \r\n  {\r\n    // Set withdrawal market id\r\n    marginDetails.withdrawalMarketId = relayerInfo.marketIdS;\r\n\r\n    // Check that marketIdS from relayer matches order's tokenS\r\n    address marketAddressS = dydxProtocol.getMarketTokenAddress(relayerInfo.marketIdS);\r\n    require(self.tokenS == marketAddressS, INVALID_MARKET_S);\r\n\r\n    // Check that marketIdB from relayer matches order's tokenB\r\n    address marketAddressB = dydxProtocol.getMarketTokenAddress(relayerInfo.marketIdB);\r\n    require(self.tokenB == marketAddressB, INVALID_MARKET_B);\r\n\r\n    // Check that depositMarketId is equal to the order's tokenB\r\n    if (marginDetails.isOpen) {\r\n      require(marginDetails.depositMarketId == relayerInfo.marketIdB, INVALID_DEPOSIT_MARKET);\r\n    }\r\n\r\n    // Token recipient must be this contract\r\n    require(self.tokenRecipient == address(this), INVALID_TOKEN_RECIPIENT);\r\n  }\r\n}\r\n\r\n\r\nlibrary ERC20SafeTransfer {\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // A transfer is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n\r\n        // bytes4(keccak256(\"transfer(address,uint256)\")) = 0xa9059cbb\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            bytes4(0xa9059cbb),\r\n            to,\r\n            value\r\n        );\r\n        (success, ) = token.call(callData);\r\n        return checkReturnValue(success);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // A transferFrom is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n\r\n        // bytes4(keccak256(\"transferFrom(address,address,uint256)\")) = 0x23b872dd\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            bytes4(0x23b872dd),\r\n            from,\r\n            to,\r\n            value\r\n        );\r\n        (success, ) = token.call(callData);\r\n        return checkReturnValue(success);\r\n    }\r\n\r\n    function checkReturnValue(\r\n        bool success\r\n        )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // A transfer/transferFrom is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n        if (success) {\r\n            assembly {\r\n                switch returndatasize()\r\n                // Non-standard ERC20: nothing is returned so if 'call' was successful we assume the transfer succeeded\r\n                case 0 {\r\n                    success := 1\r\n                }\r\n                // Standard ERC20: a single boolean value is returned which needs to be true\r\n                case 32 {\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)\r\n                }\r\n                // None of the above: not successful\r\n                default {\r\n                    success := 0\r\n                }\r\n            }\r\n        }\r\n        return success;\r\n    }\r\n\r\n}\r\n\r\n\r\nlibrary MiscHelper {\r\n  using MiscHelper for *;\r\n  using ERC20SafeTransfer for address;\r\n\r\n  // ----------------------------------------------\r\n  // TradeDelegate\r\n\r\n  /**\r\n   * Transfers tokens on behalf of a user. Transfers are done through \r\n   * Loopring's TradeDelegate which has a `batchTransfer` method that takes in encoded bytes\r\n   */\r\n  function transferTokenFrom(\r\n    ITradeDelegate self, \r\n    address token,\r\n    address from, \r\n    address to, \r\n    uint256 amount\r\n  ) internal {\r\n    bytes32[] memory transferData = new bytes32[](4);\r\n    transferData[0] = token.toBytes32();\r\n    transferData[1] = from.toBytes32();\r\n    transferData[2] = to.toBytes32();\r\n    transferData[3] = bytes32(amount);\r\n\r\n    self.batchTransfer(transferData);\r\n  }\r\n\r\n  // ----------------------------------------------\r\n  // ERC20\r\n\r\n  function safeTransfer(IERC20 self, address to, uint amount) internal {\r\n    require(address(self).safeTransfer(to, amount), \"Transfer failed\");\r\n  }\r\n\r\n  function safeTransferFrom(IERC20 self, address from, address to, uint amount) internal {\r\n    require(address(self).safeTransferFrom(from, to, amount), \"TransferFrom failed\");\r\n  }\r\n\r\n  // ----------------------------------------------\r\n  // Address\r\n\r\n  function toPayable(address self) internal pure returns (address payable) {\r\n    return address(uint160(self));\r\n  }\r\n\r\n  function toBytes32(address self) internal pure returns (bytes32) {\r\n    return bytes32(uint256(self));\r\n  }\r\n}\r\n\r\n\r\nlibrary OrderDataHelper {\r\n\r\n  /**\r\n   * Encode exchange action helper\r\n   */\r\n  function encodeWithRingData(Types.OrderData memory self, bytes memory ringData) \r\n    internal \r\n    returns (bytes memory) \r\n  {\r\n    self.ringData = ringData;\r\n    return abi.encode(\r\n      uint(self.side), \r\n      self.fillAmountS, \r\n      self.fillAmountB, \r\n      self.ringData,\r\n      self.marginOrderIndex,\r\n      self.trader\r\n    );\r\n  }\r\n}\r\n\r\n\r\ninterface IDolomiteMarginTradingBroker {\r\n  \r\n  /*\r\n   * Called by the DolomiteMarginTrading contract to request approval to deposit funds\r\n   * into itself (the msg.sender) and then into DyDx Solo. Check that the msg.sender is\r\n   * the DolomiteMarginTrading contract\r\n   */\r\n  function brokerMarginRequestApproval(address owner, address token, uint amount) external;\r\n\r\n  /*\r\n   * Called by the DolomiteMarginTrading contract to get the address that borrowed funds are expected\r\n   * to be placed into for Loopring settlement. For DolomiteDirectV1, for example, this function \r\n   * returns the address for the owner's DepositContract \r\n   */\r\n  function brokerMarginGetTrader(address owner, bytes calldata orderData) external returns (address);\r\n}\r\n\r\n\r\ncontract Globals {\r\n  using MiscHelper for *;\r\n\r\n  string constant public ORDER_SIGNATURE = \"dolomiteMarginOrder(version 1.0.0)\";\r\n  bytes4 constant public ORDER_SELECTOR = bytes4(keccak256(bytes(ORDER_SIGNATURE)));\r\n\r\n  address internal LRC_TOKEN_ADDRESS;\r\n  LoopringProtocol internal LOOPRING_PROTOCOL;\r\n  ITradeDelegate internal TRADE_DELEGATE;\r\n  DydxProtocol internal DYDX_PROTOCOL;\r\n  address internal DYDX_EXPIRATION_CONTRACT;\r\n\r\n  constructor(\r\n    address payable loopringRingSubmitterAddress, \r\n    address dydxProtocolAddress,\r\n    address dydxExpirationContractAddress\r\n  ) public {\r\n\r\n    LOOPRING_PROTOCOL = LoopringProtocol(loopringRingSubmitterAddress);\r\n    LRC_TOKEN_ADDRESS = LOOPRING_PROTOCOL.lrcTokenAddress();\r\n\r\n    address payable tradeDelegateAddress = LOOPRING_PROTOCOL.delegateAddress().toPayable();\r\n    TRADE_DELEGATE = ITradeDelegate(tradeDelegateAddress);\r\n    \r\n    DYDX_PROTOCOL = DydxProtocol(dydxProtocolAddress);\r\n    DYDX_EXPIRATION_CONTRACT = dydxExpirationContractAddress;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title MarginRingSubmitterWrapper\r\n * @author Zack Rubenstein\r\n *\r\n * Entry point for margin trading though Dydx and Loopring. Dolomite\r\n * relay calls `submitRingsWithMarginOrder` passing the same ringData \r\n * that would be passed to Loopring's `submitRings` plus some additional\r\n * info about the margin order being filled in the rings.\r\n */\r\ncontract MarginRingSubmitterWrapper is Globals {\r\n  using MiscHelper for *;\r\n  using DecodeHelper for bytes;\r\n  using MarginOrderHelper for LoopringTypes.Order;\r\n  using OrderDataHelper for Types.OrderData;\r\n\r\n  event OpenPosition(address indexed trader, uint indexed id);\r\n  event ClosePosition(address indexed trader, uint indexed id);\r\n\r\n  /*\r\n   * TODO: make this the default way to use this contract\r\n   */\r\n  function structuredSubmitRingsWithMarginOrder(Types.MarginRingSubmission calldata submissionData) external {\r\n    this.submitRingsWithMarginOrder(\r\n      submissionData.ringData,\r\n      abi.encode(\r\n        submissionData.positionId,\r\n        submissionData.marginOrderIndex,\r\n        submissionData.marketIdS,\r\n        submissionData.marketIdB,\r\n        submissionData.fillAmountS,\r\n        submissionData.fillAmountB\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Loopring protocol middleman that opens/closes a margin position with Dy/dx using\r\n   * Loopring as the medium of exchange\r\n   */\r\n  function submitRingsWithMarginOrder(\r\n    bytes calldata ringData, \r\n    bytes calldata relayData\r\n  ) external {\r\n\r\n    (\r\n      Types.RelayerInfo memory relayerInfo,\r\n      LoopringTypes.Order memory order,\r\n      Types.MarginOrderDetails memory marginDetails\r\n    ) = decodeParams(ringData, relayData);\r\n\r\n    // ----------------------\r\n    // Construct order data\r\n\r\n    Types.OrderData memory orderData;\r\n\r\n    if (order.broker == address(0x0)) {\r\n      orderData.trader = order.owner;\r\n    } else {\r\n      orderData.trader = IDolomiteMarginTradingBroker(order.broker).brokerMarginGetTrader(\r\n        order.owner, \r\n        order.transferDataS\r\n      );\r\n    }\r\n\r\n    if (marginDetails.isOpen && marginDetails.isLong) {\r\n      // Open Long\r\n      orderData.side = Types.OrderDataSide.BUY;\r\n      orderData.fillAmountS = order.calculateActualAmount(relayerInfo.fillAmountS, order.tokenS);\r\n      orderData.fillAmountB = order.getAmountB();\r\n\r\n    } else if (marginDetails.isOpen && !marginDetails.isLong) {\r\n      // Open Short\r\n      orderData.side = Types.OrderDataSide.SELL;\r\n      orderData.fillAmountS = order.getAmountS();\r\n      orderData.fillAmountB = order.calculateActualAmount(relayerInfo.fillAmountB, order.tokenB);\r\n\r\n    } else if (!marginDetails.isOpen && marginDetails.isLong) {\r\n      // Close Long\r\n      orderData.side = Types.OrderDataSide.BUY;\r\n      orderData.fillAmountS = order.getAmountS();\r\n      orderData.fillAmountB = order.calculateActualAmount(relayerInfo.fillAmountB, order.tokenB);\r\n      orderData.bringToZero = true;\r\n\r\n    } else if (!marginDetails.isOpen && !marginDetails.isLong) {\r\n      // Close Short\r\n      orderData.side = Types.OrderDataSide.BUY;\r\n      orderData.fillAmountS = order.calculateActualAmount(relayerInfo.fillAmountS, order.tokenS);\r\n      orderData.fillAmountB = order.getAmountB();\r\n      orderData.bringToZero = true;\r\n    }\r\n\r\n    bytes memory encodedOrderData = orderData.encodeWithRingData(ringData);\r\n\r\n    // ----------------------\r\n    // Construct dydx actions\r\n\r\n    DydxActions.ActionArgs[] memory actions;\r\n    DydxPosition.Info[] memory positions = new DydxPosition.Info[](1);\r\n    \r\n    // Add dydx position (account) that actions will operate on\r\n    positions[0] = DydxPosition.Info({\r\n      owner: orderData.trader,\r\n      number: marginDetails.isOpen ? generatePositionId(ringData, relayData) : relayerInfo.positionId\r\n    });\r\n\r\n    // Construct exchange action (buy or sell)\r\n    DydxActions.ActionArgs memory exchangeAction;\r\n    exchangeAction.otherAddress = address(this);\r\n    exchangeAction.data = encodedOrderData;\r\n\r\n    if (orderData.side == Types.OrderDataSide.BUY) {\r\n      // Buy Order\r\n      exchangeAction.actionType = DydxActions.ActionType.Buy;\r\n      exchangeAction.primaryMarketId = relayerInfo.marketIdB;\r\n      exchangeAction.secondaryMarketId = relayerInfo.marketIdS;\r\n\r\n      if (orderData.bringToZero) {\r\n        // Buy enough to repay the loan (end balance will be 0)\r\n        exchangeAction.amount = DydxTypes.AssetAmount({\r\n          sign: true,\r\n          denomination: DydxTypes.AssetDenomination.Wei,\r\n          ref: DydxTypes.AssetReference.Target,\r\n          value: 0\r\n        });\r\n\r\n      } else {\r\n        exchangeAction.amount = DydxTypes.AssetAmount({\r\n          sign: true,\r\n          denomination: DydxTypes.AssetDenomination.Wei,\r\n          ref: DydxTypes.AssetReference.Delta,\r\n          value: orderData.fillAmountB\r\n        });\r\n      }\r\n      \r\n    } else if (orderData.side == Types.OrderDataSide.SELL) {\r\n      // Sell Order\r\n      exchangeAction.actionType = DydxActions.ActionType.Sell;\r\n      exchangeAction.primaryMarketId = relayerInfo.marketIdS;\r\n      exchangeAction.secondaryMarketId = relayerInfo.marketIdB;\r\n      exchangeAction.amount = DydxTypes.AssetAmount({\r\n        sign: false,\r\n        denomination: DydxTypes.AssetDenomination.Wei,\r\n        ref: DydxTypes.AssetReference.Delta,\r\n        value: orderData.fillAmountS\r\n      });\r\n    }\r\n\r\n    if (marginDetails.isOpen) {\r\n      \r\n      if (order.broker == address(0x0)) {\r\n        // Pull deposit funds from owner to this contract\r\n        TRADE_DELEGATE.transferTokenFrom(\r\n          marginDetails.depositToken, \r\n          marginDetails.owner,\r\n          address(this), \r\n          marginDetails.depositAmount\r\n        );\r\n      } else {\r\n\r\n        // Request approval for deposit funds from the broker\r\n        IDolomiteMarginTradingBroker(order.broker).brokerMarginRequestApproval(\r\n          marginDetails.owner, \r\n          marginDetails.depositToken, \r\n          marginDetails.depositAmount\r\n        );\r\n\r\n        // Pull deposit funds from the broker into this contract\r\n        IERC20(marginDetails.depositToken).transferFrom(\r\n          order.broker,\r\n          address(this),\r\n          marginDetails.depositAmount\r\n        );\r\n      }\r\n\r\n      // Set allowance for dydx contract\r\n      IERC20(marginDetails.depositToken).approve(\r\n        address(DYDX_PROTOCOL), \r\n        marginDetails.depositAmount\r\n      );\r\n\r\n      // Construct action to deposit funds from this contract into a dydx position\r\n      DydxActions.ActionArgs memory depositAction;\r\n      depositAction.actionType = DydxActions.ActionType.Deposit;\r\n      depositAction.primaryMarketId = marginDetails.depositMarketId;\r\n      depositAction.otherAddress = address(this);\r\n      depositAction.amount = DydxTypes.AssetAmount({\r\n        sign: true,\r\n        denomination: DydxTypes.AssetDenomination.Wei,\r\n        ref: DydxTypes.AssetReference.Delta,\r\n        value: marginDetails.depositAmount\r\n      });\r\n\r\n      if (marginDetails.expiration == 0) {\r\n        actions = new DydxActions.ActionArgs[](2);\r\n      } else {\r\n        // Construct action to set the expiration of the dydx position\r\n        DydxActions.ActionArgs memory expirationAction;\r\n        expirationAction.actionType = DydxActions.ActionType.Call;\r\n        expirationAction.otherAddress = DYDX_EXPIRATION_CONTRACT;\r\n        expirationAction.data = encodeExpiration(relayerInfo.marketIdS, marginDetails.expiration);\r\n\r\n        actions = new DydxActions.ActionArgs[](3);\r\n        actions[2] = expirationAction;\r\n      }\r\n\r\n      // Build deposit and exchange actions in correct order\r\n      actions[0] = depositAction;\r\n      actions[1] = exchangeAction;\r\n      \r\n    } else {\r\n      // Construct action to withdraw funds to order owner or order broker trader (orderData.trader)\r\n      DydxActions.ActionArgs memory withdrawAction;\r\n      withdrawAction.actionType = DydxActions.ActionType.Withdraw;\r\n      withdrawAction.primaryMarketId = marginDetails.withdrawalMarketId;\r\n      withdrawAction.otherAddress = orderData.trader;\r\n      withdrawAction.amount = DydxTypes.AssetAmount({\r\n        sign: true,\r\n        denomination: DydxTypes.AssetDenomination.Wei,\r\n        ref: DydxTypes.AssetReference.Target,\r\n        value: 0\r\n      });\r\n\r\n      // Build actions in correct order\r\n      actions = new DydxActions.ActionArgs[](2);\r\n      actions[0] = exchangeAction;\r\n      actions[1] = withdrawAction;\r\n    }\r\n\r\n    // ----------------------\r\n    // Perform operation with dydx\r\n\r\n    DYDX_PROTOCOL.operate(positions, actions);\r\n\r\n    // ----------------------\r\n    // Finalize margin order \r\n\r\n    if (marginDetails.isOpen) emit OpenPosition(positions[0].owner, positions[0].number);\r\n    else emit ClosePosition(positions[0].owner, positions[0].number);\r\n  }\r\n\r\n  // ============================================\r\n  // Helpers\r\n\r\n  function decodeParams(bytes memory ringData, bytes memory relayData)\r\n    private\r\n    view\r\n    returns (\r\n      Types.RelayerInfo memory relayerInfo,\r\n      LoopringTypes.Order memory order,\r\n      Types.MarginOrderDetails memory marginDetails\r\n    ) \r\n  {\r\n    relayerInfo = relayData.decodeRelayerInfo();\r\n    order = ringData.decodeMinimalOrderAtIndex(\r\n      relayerInfo.marginOrderIndex, \r\n      LRC_TOKEN_ADDRESS\r\n    );\r\n    marginDetails = order.getMarginOrderDetails(ORDER_SELECTOR);\r\n    order.checkValidity(relayerInfo, marginDetails, DYDX_PROTOCOL);\r\n  }\r\n\r\n  function encodeExpiration(uint marketId, uint expiration) private pure returns (bytes memory) {\r\n    return abi.encode(marketId, expiration);\r\n  }\r\n\r\n  function generatePositionId(bytes memory ringData, bytes memory relayData)\r\n    private\r\n    pure\r\n    returns (uint)\r\n  {\r\n    return uint(keccak256(abi.encode(ringData, relayData)));\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title LoopringV2ExchangeWrapper\r\n * @author Zack Rubenstein\r\n *\r\n * Dydx compatible `ExchangeWrapper` implementation to enable\r\n * Loopring ring settlement to be performed through Dydx to settle\r\n * trades for performing margin trading with Dydx and Loopring\r\n */\r\ncontract LoopringV2ExchangeWrapper is IDydxExchangeWrapper, Globals {\r\n  using MiscHelper for *;\r\n  using DecodeHelper for bytes;\r\n  using SafeMath for uint;\r\n\r\n  address constant ZERO_ADDRESS = address(0x0);\r\n\r\n  string constant INVALID_MSG_SENDER = \"The msg.sender must be Dydx protocol\";\r\n  string constant INVALID_RECEIVER = \"Bought token receiver must be Dydx protocol\";\r\n  string constant INVALID_TOKEN_RECIPIENT = \"Invalid tokenRecipient in Loopring order\";\r\n  string constant INVALID_TRADE_ORIGINATOR = \"Loopring order owner must be originator\";\r\n  string constant INCORRECT_FILL_AMOUNT = \"Amount received must be exactly equal to expected amountB (either provided by relayer or order)\";\r\n  string constant NOTHING_RECEIVED = \"Amount received is zero. Ring submission most likely failed\";\r\n\r\n  /**\r\n   * Exchange some amount of takerToken for makerToken.\r\n   *\r\n   * @param  tradeOriginator      Address of the initiator of the trade (however, this value\r\n   *                              cannot always be trusted as it is set at the discretion of the\r\n   *                              msg.sender)\r\n   * @param  receiver             Address to set allowance on once the trade has completed\r\n   * @param  makerToken           Address of makerToken, the token to receive\r\n   * @param  takerToken           Address of takerToken, the token to pay\r\n   * @param  requestedFillAmount  Amount of takerToken being paid\r\n   * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\r\n   * @return                      The amount of makerToken received\r\n   */\r\n  function exchange(\r\n    address tradeOriginator,\r\n    address receiver,\r\n    address makerToken,\r\n    address takerToken,\r\n    uint256 requestedFillAmount,\r\n    bytes calldata orderData\r\n  ) external returns (uint256) {\r\n    require(msg.sender == address(DYDX_PROTOCOL), INVALID_MSG_SENDER);\r\n    require(receiver == address(DYDX_PROTOCOL), INVALID_RECEIVER);\r\n\r\n    Types.OrderData memory orderInfo = orderData.decodeOrderData();\r\n    LoopringTypes.Order memory order = orderInfo.ringData.decodeMinimalOrderAtIndex(\r\n      orderInfo.marginOrderIndex,\r\n      ZERO_ADDRESS\r\n    );\r\n\r\n    require(order.tokenRecipient == address(this), INVALID_TOKEN_RECIPIENT);\r\n    require(order.broker == address(0x0)\r\n      ? tradeOriginator == order.owner\r\n      : tradeOriginator == orderInfo.trader\r\n    , INVALID_TRADE_ORIGINATOR);\r\n\r\n    // Transfer sell tokens to order owner\r\n    IERC20(takerToken).safeTransfer(orderInfo.trader, requestedFillAmount);\r\n\r\n    // Record balance of buy tokens prior to ring submission\r\n    uint balanceBeforeSubmission = IERC20(makerToken).balanceOf(address(this));\r\n\r\n    // Submit & settle rings\r\n    LOOPRING_PROTOCOL.submitRings(orderInfo.ringData);\r\n\r\n    // Get actual amount of tokens received\r\n    uint amountReceived = IERC20(makerToken).balanceOf(address(this)).sub(balanceBeforeSubmission);\r\n    require(amountReceived > 0, NOTHING_RECEIVED);\r\n    require(amountReceived == orderInfo.fillAmountB, INCORRECT_FILL_AMOUNT);\r\n\r\n    // Allow Dy/dx to pull received tokens from this contract\r\n    IERC20(makerToken).approve(receiver, amountReceived);\r\n\r\n    return amountReceived;\r\n  }\r\n\r\n  /**\r\n   * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\r\n   * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\r\n   * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\r\n   * than desiredMakerToken\r\n   *\r\n   * @param  makerToken         Address of makerToken, the token to receive\r\n   * @param  takerToken         Address of takerToken, the token to pay\r\n   * @param  desiredMakerToken  Amount of makerToken requested\r\n   * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\r\n   * @return                    Amount of takerToken the needed to complete the exchange\r\n   */\r\n  function getExchangeCost(\r\n    address makerToken,\r\n    address takerToken,\r\n    uint256 desiredMakerToken,\r\n    bytes calldata orderData\r\n  ) external view returns (uint256) {\r\n    return orderData.decodeOrderData().fillAmountS;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DolomiteMarginTrading\r\n * @author Zack Rubenstein\r\n *\r\n * Combines `MarginRingSubmitterWrapper` and `LoopringV2ExchangeWrapper` into one\r\n * contract. Takes in the address to Loopring's `RingSubmitter` contract and\r\n * Dy/Dx's `SoloMargin` contract to intialize the wrappers that integrate the two.\r\n */\r\ncontract DolomiteMarginTrading is Globals, MarginRingSubmitterWrapper, LoopringV2ExchangeWrapper {\r\n\r\n  constructor(\r\n    address payable loopringRingSubmitterAddress, \r\n    address dydxProtocolAddress,\r\n    address dydxExpirationContractAddress\r\n  ) \r\n    public \r\n    Globals(loopringRingSubmitterAddress, dydxProtocolAddress, dydxExpirationContractAddress) { }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ORDER_SIGNATURE\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"desiredMakerToken\",\"type\":\"uint256\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"getExchangeCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ORDER_SELECTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeOriginator\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"requestedFillAmount\",\"type\":\"uint256\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"exchange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"positionId\",\"type\":\"uint256\"},{\"name\":\"marginOrderIndex\",\"type\":\"uint256\"},{\"name\":\"marketIdS\",\"type\":\"uint256\"},{\"name\":\"marketIdB\",\"type\":\"uint256\"},{\"name\":\"fillAmountS\",\"type\":\"uint256\"},{\"name\":\"fillAmountB\",\"type\":\"uint256\"},{\"name\":\"ringData\",\"type\":\"bytes\"}],\"name\":\"submissionData\",\"type\":\"tuple\"}],\"name\":\"structuredSubmitRingsWithMarginOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ringData\",\"type\":\"bytes\"},{\"name\":\"relayData\",\"type\":\"bytes\"}],\"name\":\"submitRingsWithMarginOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"loopringRingSubmitterAddress\",\"type\":\"address\"},{\"name\":\"dydxProtocolAddress\",\"type\":\"address\"},{\"name\":\"dydxExpirationContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OpenPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ClosePosition\",\"type\":\"event\"}]","ContractName":"DolomiteMarginTrading","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"00000000000000000000000075b51fc9436d418633a3ab078315affca12b76060000000000000000000000001e0447b19bb6ecfdae1e4ae1694b0c3659614e4e0000000000000000000000000ece224fbc24d40b446c6a94a142dc41fae76f2d","Library":"","LicenseType":"None","SwarmSource":"bzzr://2142e772c1458979882c91dd3e88f8ac40867eed4fd479840605843abcb21bd4"}]}