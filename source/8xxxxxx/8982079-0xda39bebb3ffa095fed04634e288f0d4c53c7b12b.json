{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public returns (bytes4);\r\n}\r\n\r\n/**\r\n  * @title Syntax Checker for Robe-based NFT contract\r\n  * \r\n  * @author Marco Vasapollo <ceo@metaring.com>\r\n  * @author Alessandro Mario Lagana Toschi <alet@risepic.com>\r\n*/\r\ninterface IRobeSyntaxChecker {\r\n\r\n    /**\r\n     * @return true if the given payload respects the syntax of the Robe NFT reachable at the given robeAddress, false otherwhise\r\n     */\r\n    function check(uint256 rootTokenId, uint256 newTokenId, address owner, bytes calldata payload, address robeAddress) external view returns(bool);\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721 {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n/**\r\n  * @title Robe\r\n  * @dev An open standard based on Ethereum ERC 721 to build unique NFT with XML information\r\n  * \r\n  * @dev This is the main Inteface that identifies a Robe NFT\r\n  * \r\n  * @author Marco Vasapollo <ceo@metaring.com>\r\n  * @author Alessandro Mario Lagana Toschi <alet@risepic.com>\r\n*/\r\ncontract IRobe is IERC721 {\r\n\r\n    /**\r\n      * Creates a new ERC 721 NFT\r\n      * @return a unique tokenId\r\n      */\r\n    function mint(bytes calldata payload) external returns(uint256);\r\n    \r\n    function mintAndFinalize(bytes calldata payload) external returns(uint256);\r\n\r\n    /**\r\n      * Attaches a new ERC 721 NFT to an already-existing Token\r\n      * to create a composed NFT\r\n      * @return a unique tokenId\r\n      */\r\n    function mint(uint256 rootTokenId, bytes calldata payload) external returns(uint256);\r\n    \r\n    function mintAndFinalize(uint256 rootTokenId, bytes calldata payload) external returns(uint256);\r\n\r\n    function finalize(uint256 rootTokenId) external;\r\n    \r\n    function isFinalized(uint256 tokenId) external view returns(bool);\r\n\r\n    /**\r\n      * @return all the tokenIds that composes the givend NFT\r\n      */\r\n    function getChain(uint256 tokenId) external view returns(uint256[] memory);\r\n\r\n    /**\r\n      * @return the root NFT of this tokenId\r\n      */\r\n    function getRoot(uint256 tokenId) external view returns(uint256);\r\n\r\n    /**\r\n     * @return the content of a NFT\r\n     */\r\n    function getContent(uint256 tokenId) external view returns(bytes memory);\r\n\r\n    /**\r\n     * @return the position in the chain of this NFT\r\n     */\r\n    function getPositionOf(uint256 tokenId) external view returns(uint256);\r\n\r\n    /**\r\n     * @return the tokenId of the passed NFT at the given position\r\n     */\r\n    function getTokenIdAt(uint256 tokenId, uint256 position) external view returns(uint256);\r\n\r\n    /**\r\n     * Syntactic sugar\r\n     * @return the position in the chain, the owner's address and content of the given NFT\r\n     */\r\n    function getCompleteInfo(uint256 tokenId) external view returns(uint256, address, bytes memory);\r\n    \r\n    event Mint(uint256 indexed rootTokenId, uint256 indexed newTokenId, address indexed sender);\r\n    \r\n    event Finalize(uint256 indexed rootTokenId);\r\n}\r\n\r\n/**\r\n  * @title General Purpose implementation of the Robe Interface\r\n  * @author Marco Vasapollo <ceo@metaring.com>\r\n  * @author Alessandro Mario Lagana Toschi <alet@risepic.com>\r\n  * @author The OpenZeppelin ERC721 Implementation for the safeTransferFrom method. Thank you guys!\r\n*/\r\ncontract Robe is IRobe {\r\n\r\n    address private _voidAddress = address(0);\r\n\r\n    address private _myAddress;\r\n\r\n    address private _syntaxCheckerAddress;\r\n    IRobeSyntaxChecker private _syntaxChecker;\r\n\r\n    //Registers the owner of each NFT\r\n    mapping(uint256 => address) private _owner;\r\n\r\n    //Registers the balance for each owner\r\n    mapping(address => uint256) private _balance;\r\n\r\n    //Registers the approved operators that can transfer the ownership of a specific NFT\r\n    mapping(uint256 => address) private _tokenOperator;\r\n\r\n    //Registers the approved operators that can transfer the ownership of all the NFTs of a specific owner\r\n    mapping(address => address) private _ownerOperator;\r\n\r\n    //Registers the chain of composed NFT\r\n    mapping(uint256 => uint256[]) private _chain;\r\n\r\n    //Registers the position of the NFT in its chain\r\n    mapping(uint256 => uint256) private _positionInChain;\r\n\r\n    //Registers the root NFT of each NFT\r\n    mapping(uint256 => uint256) private _root;\r\n    \r\n    //Registers finalized tokens\r\n    mapping(uint256 => bool) private _finalized;\r\n\r\n    //The content of each NFT\r\n    bytes[] private _data;\r\n\r\n    constructor(address syntaxCheckerAddress) public {\r\n        _myAddress = address(this);\r\n        if(syntaxCheckerAddress != _voidAddress) {\r\n            _syntaxCheckerAddress = syntaxCheckerAddress;\r\n            _syntaxChecker = IRobeSyntaxChecker(_syntaxCheckerAddress);\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        revert(\"ETH not accepted\");\r\n    }\r\n\r\n    /**\r\n      * Creates a new ERC 721 NFT\r\n      * @return a unique tokenId\r\n      */\r\n    function mint(bytes memory payload) public returns(uint256) {\r\n        return _mintAndOrAttach(_data.length, payload, msg.sender, false);\r\n    }\r\n    \r\n    function mintAndFinalize(bytes memory payload) public returns(uint256) {\r\n        return _mintAndOrAttach(_data.length, payload, msg.sender, true);\r\n    }\r\n\r\n    /**\r\n      * Attaches a new ERC 721 NFT to an already-existing Token\r\n      * to create a composed NFT\r\n      * @return a unique tokenId\r\n      */\r\n    function mint(uint256 rootTokenId, bytes memory payload) public returns(uint256) {\r\n        return _mintAndOrAttach(rootTokenId, payload, msg.sender, false);\r\n    }\r\n    \r\n    function mintAndFinalize(uint256 rootTokenId, bytes memory payload) public returns(uint256) {\r\n        return _mintAndOrAttach(rootTokenId, payload, msg.sender, true);\r\n    }\r\n\r\n    function _mintAndOrAttach(uint256 rootTokenId, bytes memory payload, address owner, bool finalize) private returns(uint256 newTokenId) {\r\n        newTokenId = _data.length;\r\n        if(rootTokenId != newTokenId) {\r\n            require(_owner[rootTokenId] == owner, \"Cannot extend an already-existing chain of someone else is forbidden\");\r\n            require(!_finalized[rootTokenId], \"Root token is finalized\");\r\n        }\r\n        if(_syntaxCheckerAddress != _voidAddress) {\r\n            require(_syntaxChecker.check(rootTokenId, newTokenId, owner, payload, _myAddress), \"Invalid payload Syntax\");\r\n        }\r\n        _data.push(payload);\r\n        if(rootTokenId == newTokenId) {\r\n            _owner[rootTokenId] = owner;\r\n        }\r\n        _balance[owner] = _balance[owner] + 1;\r\n        _root[newTokenId] = rootTokenId;\r\n        _positionInChain[newTokenId] = _chain[rootTokenId].length;\r\n        _chain[rootTokenId].push(newTokenId);\r\n        emit Mint(rootTokenId, newTokenId, owner);\r\n        if(finalize) {\r\n            _finalized[rootTokenId] = true;\r\n            emit Finalize(rootTokenId);\r\n        }\r\n    }\r\n    \r\n    function finalize(uint256 tokenId) public {\r\n        uint256 rootTokenId = _root[tokenId];\r\n        require(_owner[rootTokenId] == msg.sender, \"Cannot finalize an already-existing chain of someone else is forbidden\");\r\n        require(!_finalized[rootTokenId], \"Root token is finalized\");\r\n        _finalized[rootTokenId] = true;\r\n        emit Finalize(rootTokenId);\r\n    }\r\n    \r\n    function isFinalized(uint256 tokenId) public view returns(bool) {\r\n        return _finalized[_root[tokenId]];\r\n    }\r\n\r\n    /**\r\n      * @return all the tokenIds that composes the givend NFT\r\n      */\r\n    function getChain(uint256 tokenId) public view returns(uint256[] memory) {\r\n        return _chain[_root[tokenId]];\r\n    }\r\n\r\n    /**\r\n      * @return the root NFT of this tokenId\r\n      */\r\n    function getRoot(uint256 tokenId) public view returns(uint256) {\r\n        return _root[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @return the content of a NFT\r\n     */\r\n    function getContent(uint256 tokenId) public view returns(bytes memory) {\r\n        return _data[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @return the position in the chain of this NFT\r\n     */\r\n    function getPositionOf(uint256 tokenId) public view returns(uint256) {\r\n        return _positionInChain[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @return the tokenId of the passed NFT at the given position\r\n     */\r\n    function getTokenIdAt(uint256 tokenId, uint256 position) public view returns(uint256) {\r\n        return _chain[tokenId][position];\r\n    }\r\n\r\n    /**\r\n     * Syntactic sugar\r\n     * @return the position in the chain, the owner's address and content of the given NFT\r\n     */\r\n    function getCompleteInfo(uint256 tokenId) public view returns(uint256, address, bytes memory) {\r\n        return (_positionInChain[tokenId], _owner[_root[tokenId]], _data[tokenId]);\r\n    }\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return _balance[owner];\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address owner) {\r\n        return _owner[_root[tokenId]];\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) public {\r\n        require(_root[tokenId] == tokenId, \"Only root NFTs can be approved\");\r\n        require(msg.sender == _owner[tokenId], \"Only owner can approve operators\");\r\n        _tokenOperator[tokenId] = to;\r\n        emit Approval(msg.sender, to, tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view returns (address operator) {\r\n        require(_root[tokenId] == tokenId, \"Only root NFTs can be approved\");\r\n        operator = _tokenOperator[tokenId];\r\n        if(operator == _voidAddress) {\r\n            operator = _ownerOperator[_owner[tokenId]];\r\n        }\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public {\r\n        if(!_approved && operator == _ownerOperator[msg.sender]) {\r\n            _ownerOperator[msg.sender] = _voidAddress;\r\n        }\r\n        if(_approved) {\r\n            _ownerOperator[msg.sender] = operator;\r\n        }\r\n        emit ApprovalForAll(msg.sender, operator, _approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _ownerOperator[owner] == operator;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        _transferFrom(msg.sender, from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        _safeTransferFrom(msg.sender, from, to, tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {\r\n        _safeTransferFrom(msg.sender, from, to, tokenId, data);\r\n    }\r\n\r\n    function _transferFrom(address sender, address from, address to, uint256 tokenId) private {\r\n        require(_root[tokenId] == tokenId, \"Only root NFTs can be transfered\");\r\n        require(_owner[tokenId] == from, \"Given from is not the owner of given tokenId\");\r\n        require(from == sender || getApproved(tokenId) == sender, \"Sender not allowed to transfer this tokenId\");\r\n        _owner[tokenId] = to;\r\n        _balance[from] = _balance[from] - 1;\r\n        _balance[to] = _balance[to] + 1;\r\n        _tokenOperator[tokenId] = _voidAddress;\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    function _safeTransferFrom(address sender, address from, address to, uint256 tokenId, bytes memory data) public {\r\n        _transferFrom(sender, from, to, tokenId);\r\n        uint256 size;\r\n        assembly { size := extcodesize(to) }\r\n        require(size <= 0, \"Receiver address is not a contract\");\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data);\r\n        require(retval == 0x150b7a02, \"Receiver address does not support the onERC721Received method\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"syntaxCheckerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rootTokenId\",\"type\":\"uint256\"}],\"name\":\"Finalize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rootTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"_safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getChain\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCompleteInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getContent\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getPositionOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"getTokenIdAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rootTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rootTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"mintAndFinalize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"mintAndFinalize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Robe","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://00d86f6c31c84fde593e758708f978a5a826648fa73f845929574ed7ffa6e66a"}]}