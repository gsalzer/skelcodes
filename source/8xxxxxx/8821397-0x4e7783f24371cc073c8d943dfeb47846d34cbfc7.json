{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.11;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others (`ERC165Checker`).\n *\n * For an implementation, see `ERC165`.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * \n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either `approve` or `setApproveForAll`.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either `approve` or `setApproveForAll`.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\n\ncontract OldToken is IERC721 {\n\n    function getCard(uint id) public view returns (uint16, uint16);\n    function totalSupply() public view returns (uint);\n\n}\n\ncontract ICards is IERC721 {\n\n    function getDetails(uint tokenId) public view returns (uint16 proto, uint8 quality);\n    function setQuality(uint tokenId, uint8 quality) public;\n    function burn(uint tokenId) public;\n    function batchMintCards(address to, uint16[] memory _protos, uint8[] memory _qualities) public returns (uint);\n    function mintCards(address to, uint16[] memory _protos, uint8[] memory _qualities) public returns (uint);\n    function mintCard(address to, uint16 _proto, uint8 _quality) public returns (uint);\n    function batchSize() public view returns (uint);\n}\n\n\n\ncontract DirectMigration {\n\n    uint threshold;\n    OldToken old;\n    ICards cards;\n    uint limit;\n\n    event Migrated(address indexed user, uint oldStart, uint oldEnd, uint newStart);\n    event NonGenesisMigrated(address indexed user, uint oldID, uint newID);\n\n    constructor(OldToken _old, ICards _cards, uint _threshold, uint _limit) public {\n        old = _old;\n        cards = _cards;\n        threshold = _threshold;\n        limit = _limit;\n    }\n\n    struct IM {\n        uint16 proto;\n        uint16 purity;\n\n        uint16 p;\n        uint8 q;\n        uint id;\n    }\n\n    uint public migrated;\n\n    function activatedMigration() public returns (uint current) {\n        uint start = migrated;\n        address first = old.ownerOf(start);\n        current = start;\n        address owner = first;\n        uint last = old.totalSupply();\n\n        while (owner == first && current < start + limit) {\n            current++;\n            if (current >= last) {\n                break;\n            }\n            owner = old.ownerOf(current);\n        }\n\n        uint size = current - start;\n\n        require(size > 0, \"size is zero\");\n\n        uint16[] memory protos = new uint16[](size);\n        uint8[] memory qualities = new uint8[](size);\n\n        // dodge the stack variable limit\n        IM memory im;\n        \n        uint count = 0;\n\n        for (uint i = 0; i < size; i++) {\n            (im.proto, im.purity) = old.getCard(start+i);\n            im.p = convertProto(im.proto);\n            im.q = convertPurity(im.purity);\n            if (im.p > 377) {\n                im.id = cards.mintCard(first, im.p, im.q);\n                emit NonGenesisMigrated(first, start + i, im.id);\n            } else {\n                protos[count] = im.p;\n                qualities[count] = im.q;\n                count++;\n            }\n        }\n\n        // change lengths back to count\n        assembly{mstore(protos, count)}\n        assembly{mstore(qualities, count)}\n\n        uint newStart;\n        if (count <= threshold) {\n            newStart = cards.mintCards(first, protos, qualities);\n        } else {\n            newStart = cards.batchMintCards(first, protos, qualities);\n        }\n\n        migrated = current;\n\n        emit Migrated(first, start, current, newStart);\n\n        return current;\n    }\n\n\n    function convertPurity(uint16 purity) public pure returns (uint8) {\n        return uint8((purity / 1000) + 2);\n    }\n\n    function convertProto(uint16 proto) public view returns (uint16) {\n        if (proto >= 1 && proto <= 377) {\n            return proto;\n        }\n        // first phoenix\n        if (proto == 380) {\n            return 400;\n        }\n        // chimera\n        if (proto == 394) {\n            return 401;\n        }\n        // etherbots\n        (bool found, uint index) = getEtherbotsIndex(proto);\n        if (found) {\n            return uint16(380 + index);\n        }\n        // hyperion\n        if (proto == 378) {\n            return 65000;\n        }\n        // prometheus\n        if (proto == 379) {\n            return 65001;\n        }\n        // atlas\n        if (proto == 383) {\n            return 65002;\n        }\n        // tethys\n        if (proto == 384) {\n            return 65003;\n        }\n        require(false, \"unrecognised proto\");\n    }\n\n    uint16[] internal ebs = [400, 413, 414, 421, 427, 428, 389, 415, 416, 422, 424, 425, 426, 382, 420, 417];\n\n    function getEtherbotsIndex(uint16 proto) public view returns (bool, uint16) {\n        for (uint16 i = 0; i < ebs.length; i++) {\n            if (ebs[i] == proto) {\n                return (true, i);\n            }\n        }\n        return (false, 0);\n    }\n\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"}],\"name\":\"getEtherbotsIndex\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activatedMigration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"}],\"name\":\"convertProto\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"purity\",\"type\":\"uint16\"}],\"name\":\"convertPurity\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract OldToken\",\"name\":\"_old\",\"type\":\"address\"},{\"internalType\":\"contract ICards\",\"name\":\"_cards\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStart\",\"type\":\"uint256\"}],\"name\":\"Migrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newID\",\"type\":\"uint256\"}],\"name\":\"NonGenesisMigrated\",\"type\":\"event\"}]","ContractName":"DirectMigration","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006ebeaf8e8e946f0716e6533a6f2cefc83f60e8ab000000000000000000000000515e9c9ccbcf12dd11500a7463599a2c323e5f64000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000001f4","Library":"","LicenseType":"","SwarmSource":"bzzr://091757aa07b541a872dcf48164c71630eb15c338be4c2c6450c033fb28b60c56"}]}