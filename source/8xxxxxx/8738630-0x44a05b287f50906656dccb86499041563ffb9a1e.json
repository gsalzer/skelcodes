{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.0;\r\n\r\n///////// BEGIN LIB IMPORT\r\n\r\n/*\r\n * @title String & slice utility library for Solidity contracts.\r\n * @author Nick Johnson <arachnid@notdot.net>\r\n */\r\n\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string memory self) internal pure returns (slice memory) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice memory self) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      `self` and `other`.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\r\n     *      newly allocated string.\r\n     * @param self The delimiter to use.\r\n     * @param parts A list of slices to join.\r\n     * @return A newly allocated string containing all the slices in `parts`,\r\n     *         joined with `self`.\r\n     */\r\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\r\n        if (parts.length == 0)\r\n            return \"\";\r\n\r\n        uint length = self._len * (parts.length - 1);\r\n        for(uint i = 0; i < parts.length; i++)\r\n            length += parts[i]._len;\r\n\r\n        string memory ret = new string(length);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        for(uint256 i = 0; i < parts.length; i++) {\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n            retptr += parts[i]._len;\r\n            if (i < parts.length - 1) {\r\n                memcpy(retptr, self._ptr, self._len);\r\n                retptr += self._len;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}\r\n\r\n///////// END LIB IMPORT\r\n\r\n/*\r\n * v1.0\r\n */\r\ncontract Themis {\r\n\r\n    struct Stamp {\r\n        string hash;\r\n        string data;\r\n        bool exists;\r\n    }\r\n\r\n    struct AuthorityStamps {\r\n        bool enabled;\r\n        Stamp[] stamps;\r\n        mapping(string => Stamp) hashToStamp;\r\n    }\r\n\r\n    event TransferChairEvent (\r\n        address indexed newChair\r\n    );\r\n\r\n    event StampEvent (\r\n        address indexed authority,\r\n        string indexed hash,\r\n        string data\r\n    );\r\n\r\n    event AuthorityAbilitation (\r\n        address indexed authority,\r\n        bool enabled\r\n    );\r\n\r\n    address public chairAuthority;\r\n    mapping(address => AuthorityStamps) private authorities;\r\n    address[] private authorityAddresses;\r\n\r\n    constructor() public {\r\n        chairAuthority = msg.sender;\r\n        authorities[msg.sender].enabled = true;\r\n        authorityAddresses.push(msg.sender);\r\n    }\r\n\r\n    function transferChair(address authority) public {\r\n        require(msg.sender == chairAuthority, 'unauthorised');\r\n        chairAuthority = authority;\r\n        emit TransferChairEvent(authority);\r\n    }\r\n\r\n    function enableAuthority(address authority) public {\r\n        require(msg.sender == chairAuthority);\r\n        authorities[authority].enabled = true;\r\n        bool found = false;\r\n        for(uint256 i = 0; i < authorityAddresses.length; i++) {\r\n            if(authorityAddresses[i] == authority) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if(!found) {\r\n            authorityAddresses.push(authority);\r\n        }\r\n        emit AuthorityAbilitation(authority, true);\r\n    }\r\n\r\n    function disableAuthority(address authority) public {\r\n        require(msg.sender == chairAuthority);\r\n        authorities[authority].enabled = false;\r\n        emit AuthorityAbilitation(authority, false);\r\n    }\r\n\r\n    function stamp(string memory hash, string memory data) public {\r\n        require(bytes(hash).length > 0, 'hash cannot be empty');\r\n        AuthorityStamps storage authority = authorities[msg.sender];\r\n        require (authority.enabled, 'authority is not enabled');\r\n        require(authority.hashToStamp[hash].exists == false, 'Hash has been already stamped');\r\n        Stamp memory _stamp = Stamp(hash, data, true);\r\n        authority.stamps.push(_stamp);\r\n        authority.hashToStamp[hash] = _stamp;\r\n        emit StampEvent(msg.sender, hash, data);\r\n    }\r\n\r\n    function getAuthoritiesCount() public view returns(uint256 chain) {\r\n        return authorityAddresses.length;\r\n    }\r\n\r\n    function getAuthorityAddress(uint i) public view returns(address authority) {\r\n        return authorityAddresses[i];\r\n    }\r\n\r\n    function isAuthorityEnabled(address authority) public view returns(bool enabled) {\r\n        return authorities[authority].enabled;\r\n    }\r\n\r\n    function getStampsCount(address authority) public view returns(uint256 count) {\r\n        return authorities[authority].stamps.length;\r\n    }\r\n\r\n    function getStampHash(address authority, uint256 i) public view returns(string memory hash) {\r\n        Stamp memory _stamp = authorities[authority].stamps[i];\r\n        require(_stamp.exists);\r\n        return _stamp.hash;\r\n    }\r\n\r\n    function getStampData(address authority, uint256 i) public view returns(string memory data) {\r\n        Stamp memory _stamp = authorities[authority].stamps[i];\r\n        require(_stamp.exists);\r\n        return _stamp.data;\r\n    }\r\n\r\n    function getStampsRange(address authority, uint256 frm, uint256 to, string memory separator) public view returns(string memory hashstr, string memory datastr) {\r\n        Stamp[] memory stamps = authorities[authority].stamps;\r\n        strings.slice memory hashBuf = strings.toSlice(\"\");\r\n        strings.slice memory dataBuf = strings.toSlice(\"\");\r\n        strings.slice memory sep = strings.toSlice(separator);\r\n        for(uint256 c = frm; c < to; c++) {\r\n            hashBuf = strings.toSlice(strings.concat(hashBuf, strings.toSlice(strings.concat(strings.toSlice(stamps[c].hash), sep))));\r\n            dataBuf = strings.toSlice(strings.concat(dataBuf, strings.toSlice(strings.concat(strings.toSlice(stamps[c].data), sep))));\r\n        }\r\n        return (strings.toString(hashBuf), strings.toString(dataBuf));\r\n    }\r\n\r\n    function getStampByHash(address authority, string memory hash) public view returns (string memory data, bool exists) {\r\n        Stamp memory _stamp = authorities[authority].hashToStamp[hash];\r\n        return (_stamp.data, _stamp.exists);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"authority\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getStampData\",\"outputs\":[{\"name\":\"data\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"enableAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"authority\",\"type\":\"address\"},{\"name\":\"frm\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"},{\"name\":\"separator\",\"type\":\"string\"}],\"name\":\"getStampsRange\",\"outputs\":[{\"name\":\"hashstr\",\"type\":\"string\"},{\"name\":\"datastr\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"getStampsCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"authority\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getStampHash\",\"outputs\":[{\"name\":\"hash\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuthoritiesCount\",\"outputs\":[{\"name\":\"chain\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getAuthorityAddress\",\"outputs\":[{\"name\":\"authority\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chairAuthority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"transferChair\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"disableAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hash\",\"type\":\"string\"},{\"name\":\"data\",\"type\":\"string\"}],\"name\":\"stamp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"authority\",\"type\":\"address\"},{\"name\":\"hash\",\"type\":\"string\"}],\"name\":\"getStampByHash\",\"outputs\":[{\"name\":\"data\",\"type\":\"string\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"isAuthorityEnabled\",\"outputs\":[{\"name\":\"enabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newChair\",\"type\":\"address\"}],\"name\":\"TransferChairEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"hash\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"string\"}],\"name\":\"StampEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"AuthorityAbilitation\",\"type\":\"event\"}]","ContractName":"Themis","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://7207f302aa4176233a7500a2556a42eae4d42d66a3a7b747ee137a89b78a410f"}]}