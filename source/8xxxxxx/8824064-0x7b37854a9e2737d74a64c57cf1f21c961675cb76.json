{"status":"1","message":"OK","result":[{"SourceCode":"{\"TcjXraTest.sol\":{\"content\":\"pragma solidity ^0.5.12;\\n\\nimport \\\"./TokenEscrow.sol\\\";\\n\\ncontract TcjXraTest is TokenEscrow(\\n    0xC9d32Ab70a7781a128692e9B4FecEBcA6C1Bcce4,\\n    0x98719cFC0AeE5De1fF30bB5f22Ae3c2Ce45e43F7,\\n    0x44744e3e608D1243F55008b328fE1b09bd42E4Cc,\\n    0x7025baB2EC90410de37F488d1298204cd4D6b29d,\\n    10000000000000000000,\\n    10000000000000000000,\\n    1572393600,\\n    1572451200) {\\n    constructor() public{\\n\\n    }\\n}\\n\"},\"TokenEscrow.sol\":{\"content\":\"pragma solidity ^0.5.12;\\n\\ninterface Token {\\n    function balanceOf(address who) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool ok);\\n}\\n\\ncontract TokenEscrow {\\n\\n    address public tcjContractor;\\n    address public xraContractor;\\n    address public tcjToken;\\n    address public xraToken;\\n    uint256 public tcjRequiredAmount;\\n    uint256 public xraRequiredAmount;\\n    uint256 public depositDueDate;\\n    uint256 public withdrawalStartDate;\\n    bool public xraReceded;\\n    bool public tcjReceded;\\n\\n    event TokensWithdrawn(address indexed beneficiary,address indexed token, uint256 indexed amount);\\n    event ContractReceded(address indexed contractor, bool indexed contractReceded);\\n\\n    constructor(address _tcj_contractor,\\n                address _xra_contractor,\\n                address _tcjToken,\\n                address _xraToken,\\n                uint256 _tcjRequiredAmount,\\n                uint256 _xraRequiredAmount,\\n                uint256 _depositDueDate,\\n                uint256 _withdrawalStartDate) public {\\n        // sanity checks\\n        require(_tcjToken != address(0));\\n        require(_xraToken != address(0));\\n        require(_tcj_contractor != address(0));\\n        require(_xra_contractor != address(0));\\n        require(_tcjRequiredAmount \\u003e 0);\\n        require(_xraRequiredAmount \\u003e 0);\\n        require(_depositDueDate \\u003e= block.timestamp \\u0026\\u0026 _withdrawalStartDate \\u003e _depositDueDate);\\n\\n        // configure contract\\n        tcjToken = _tcjToken;\\n        xraToken = _xraToken;\\n        tcjContractor = _tcj_contractor;\\n        xraContractor = _xra_contractor;\\n        tcjRequiredAmount = _tcjRequiredAmount;\\n        xraRequiredAmount = _xraRequiredAmount;\\n        depositDueDate = _depositDueDate;\\n        withdrawalStartDate = _withdrawalStartDate;\\n    }\\n\\n    // main entry point\\n    function () external payable {\\n        require(msg.sender == xraContractor || msg.sender == tcjContractor);\\n        require(msg.value == 0);\\n        // only registered contractors can use the contract\\n        // we also check that the transaction is a 0 ether one as a safety measure\\n        if (msg.sender == xraContractor) {\\n            processWithdrawFromSender(msg.sender,Token(xraToken),xraRequiredAmount,Token(tcjToken),tcjRequiredAmount);\\n        } else if(msg.sender == tcjContractor) {\\n            processWithdrawFromSender(msg.sender,Token(tcjToken),tcjRequiredAmount, Token(xraToken),xraRequiredAmount);\\n        }\\n    }\\n\\n    // checks if the contract has been receded by both contractors\\n    function contractReceded() public view returns (bool) {\\n        return tcjReceded \\u0026\\u0026 xraReceded;\\n    }\\n\\n    // allows a contractor to recede from contract\\n    // once receded the contractor cannot take his decision back\\n    // but until both contractor have chosen to recede, the contractor\\n    // will continue to execute normally\\n    function recede() external {\\n        require(msg.sender == xraContractor || msg.sender == tcjContractor,\\n            \\\"Sender not allowed to operate on the contract\\\");\\n        if (msg.sender == xraContractor \\u0026\\u0026 !xraReceded) {\\n            xraReceded = true;\\n            emit ContractReceded(msg.sender, xraReceded \\u0026\\u0026 tcjReceded);\\n        } else if (msg.sender == tcjContractor \\u0026\\u0026 !tcjReceded) {\\n            tcjReceded = true;\\n            emit ContractReceded(msg.sender, xraReceded \\u0026\\u0026 tcjReceded);\\n        } else {\\n            revert(\\\"Already receded\\\");\\n        }\\n    }\\n\\n\\n    function processWithdrawFromSender(address contractor, Token contractorToken,uint256 requiredDeposit, Token counterpartToken, uint256 counterpartExpectedDeposit) private {\\n        if (contractReceded()) {\\n            // if the contract has been aborted the contractor will receive all the deposited tokens\\n            bool ok = withdrawAllTokens(contractor,contractorToken);\\n            if (!ok) {\\n                revert(\\\"No tokens have been deposited by the sender\\\");\\n            }\\n            return;\\n        }\\n\\n        uint256 contractorTokenBalance = contractorToken.balanceOf(address(this));\\n        uint256 counterPartTokenBalance = counterpartToken.balanceOf(address(this));\\n        uint256 timestamp = block.timestamp;\\n\\n\\n        if (timestamp \\u003c depositDueDate) {\\n            // if we are before the deposit due date the contractor will receive excess deposit back\\n            bool ok = withdrawExcessTokens(contractor,contractorToken,requiredDeposit);\\n            if (!ok) {\\n                revert(\\\"There is no excess deposit\\\");\\n            }\\n\\n        } else if (timestamp \\u003e= depositDueDate \\u0026\\u0026 timestamp \\u003c withdrawalStartDate) {\\n            // if we are between depsit due date and withdrawal start date\\n            if (contractorTokenBalance \\u003e= requiredDeposit \\u0026\\u0026\\n                counterPartTokenBalance \\u003e= counterpartExpectedDeposit) {\\n                // if the deposit from both the parties is more than the requirement\\n                // the contractor can withdraw the excess deposit\\n                bool ok = withdrawExcessTokens(contractor,contractorToken,requiredDeposit);\\n                if (!ok) {\\n                    revert(\\\"There is no excess deposit\\\");\\n                }\\n\\n            } else {\\n                // otherwise the contractor withdraws all his deposited tokens\\n                bool ok = withdrawAllTokens(contractor,contractorToken);\\n                if (!ok) {\\n                    revert(\\\"No tokens have been deposited \\\");\\n                }\\n            }\\n        } else if (timestamp \\u003e= withdrawalStartDate) {\\n            // if we are after the withdrawal start date\\n            if (contractorTokenBalance \\u003e= requiredDeposit \\u0026\\u0026\\n                counterPartTokenBalance \\u003e= counterpartExpectedDeposit) {\\n                // if the deposit from both the parties is more than the requirement\\n                // the contractor can withdraw the excess deposit and the tokens deposited by the\\n                // counterpart\\n                bool excessOk = withdrawExcessTokens(contractor,contractorToken,requiredDeposit);\\n                bool withdrawOk = withdrawTokens(contractor,counterpartToken,counterpartExpectedDeposit);\\n\\n                if (!excessOk \\u0026\\u0026 !withdrawOk) {\\n                    revert(\\\"No  excess tokens have been deposited and tokens of the counterpart have already been withdrawn\\\");\\n                }\\n            } else {\\n                // otherwise the contractor can withdraw all the deposited tokens\\n                bool ok = withdrawAllTokens(contractor,contractorToken);\\n                if (!ok) {\\n                    revert(\\\"There is no excess deposit\\\");\\n                }\\n            }\\n        }\\n\\n    }\\n\\n    function withdrawTokens(address contractor, Token token, uint256 amount) private returns (bool success){\\n        uint256 balance = token.balanceOf(address(this));\\n        if (balance\\u003e=amount) {\\n            token.transfer(contractor,amount);\\n            emit TokensWithdrawn(contractor,address(token),amount);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function withdrawAllTokens(address contractor, Token token) private returns (bool success)  {\\n        uint256 actualDeposit = token.balanceOf(address(this));\\n        if (actualDeposit\\u003e0) {\\n            token.transfer(contractor,actualDeposit);\\n            emit TokensWithdrawn(contractor,address(token),actualDeposit);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function withdrawExcessTokens(address contractor,Token token, uint256 requiredDeposit) private returns (bool success) {\\n        uint256 actualDeposit = token.balanceOf(address(this));\\n        if (actualDeposit \\u003e requiredDeposit) {\\n            uint256 amount = actualDeposit - requiredDeposit;\\n            token.transfer(contractor,amount);\\n            emit TokensWithdrawn(contractor,address(token),amount);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n\\n    function tokenFallback(address from, uint256 value, bytes memory data) public {\\n        // this is needed to accept tokens from ERC223 tokens\\n        // but we don\\u0027t need to do anything special\\n    }\\n\\n\\n}\"}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"contractReceded\",\"type\":\"bool\"}],\"name\":\"ContractReceded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractReceded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositDueDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recede\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tcjContractor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tcjReceded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tcjRequiredAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tcjToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawalStartDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xraContractor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xraReceded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xraRequiredAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xraToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TcjXraTest","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://c05eca166328d2306cc6a37f2763ec877f801224a1369324e8518e84029ba70d"}]}