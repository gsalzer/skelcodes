{"status":"1","message":"OK","result":[{"SourceCode":"{\"EIP20.sol\":{\"content\":\"/*\\r\\nImplements EIP20 token standard: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\r\\n.*/\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"./EIP20Interface.sol\\\";\\r\\n\\r\\ncontract EIP20 is EIP20Interface {\\r\\n\\r\\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\\r\\n    mapping (address =\\u003e uint256) public balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public allowed;\\r\\n    /*\\r\\n    NOTE:\\r\\n    The following variables are OPTIONAL vanities. One does not have to include them.\\r\\n    They allow one to customise the token contract \\u0026 in no way influences the core functionality.\\r\\n    Some wallets/interfaces might not even bother to look at this information.\\r\\n    */\\r\\n    string public name;                   //fancy name: eg Simon Bucks\\r\\n    uint8 public decimals;                //How many decimals to show.\\r\\n    string public symbol;                 //An identifier: eg SBX\\r\\n\\r\\n    constructor (\\r\\n        uint256 _initialAmount,\\r\\n        string memory _tokenName,\\r\\n        uint8 _decimalUnits,\\r\\n        string memory _tokenSymbol\\r\\n    ) public {\\r\\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\\r\\n        totalSupply = _initialAmount;                        // Update total supply\\r\\n        name = _tokenName;                                   // Set the name for display purposes\\r\\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\\r\\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\\r\\n    }\\r\\n\\r\\n    function transfer(address _to, uint256 _value) public returns (bool success) {\\r\\n        require(balances[msg.sender] \\u003e= _value);\\r\\n        balances[msg.sender] -= _value;\\r\\n        balances[_to] += _value;\\r\\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\\r\\n        uint256 allowance = allowed[_from][msg.sender];\\r\\n        require(balances[_from] \\u003e= _value \\u0026\\u0026 allowance \\u003e= _value);\\r\\n        balances[_to] += _value;\\r\\n        balances[_from] -= _value;\\r\\n        if (allowance \\u003c MAX_UINT256) {\\r\\n            allowed[_from][msg.sender] -= _value;\\r\\n        }\\r\\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _owner) public view returns (uint256 balance) {\\r\\n        return balances[_owner];\\r\\n    }\\r\\n\\r\\n    function approve(address _spender, uint256 _value) public returns (bool success) {\\r\\n        allowed[msg.sender][_spender] = _value;\\r\\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\\r\\n        return allowed[_owner][_spender];\\r\\n    }\\r\\n}\\r\\n\"},\"EIP20Interface.sol\":{\"content\":\"// Abstract contract for the full ERC 20 Token standard\\r\\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\ncontract EIP20Interface {\\r\\n    /* This is a slight change to the Erc20 base standard.\\r\\n    function totalSupply() constant returns (uint256 supply);\\r\\n    is replaced with:\\r\\n    uint256 public totalSupply;\\r\\n    This automatically creates a getter function for the totalSupply.\\r\\n    This is moved to the base contract since public getter functions are not\\r\\n    currently recognised as an implementation of the matching abstract\\r\\n    function by the compiler.\\r\\n    */\\r\\n    /// total amount of tokens\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    /// @param _owner The address from which the balance will be retrieved\\r\\n    /// @return The balance\\r\\n    function balanceOf(address _owner) public view returns (uint256 balance);\\r\\n\\r\\n    /// @notice send `_value` token to `_to` from `msg.sender`\\r\\n    /// @param _to The address of the recipient\\r\\n    /// @param _value The amount of token to be transferred\\r\\n    /// @return Whether the transfer was successful or not\\r\\n    function transfer(address _to, uint256 _value) public returns (bool success);\\r\\n\\r\\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\\r\\n    /// @param _from The address of the sender\\r\\n    /// @param _to The address of the recipient\\r\\n    /// @param _value The amount of token to be transferred\\r\\n    /// @return Whether the transfer was successful or not\\r\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\\r\\n\\r\\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\\r\\n    /// @param _spender The address of the account able to transfer the tokens\\r\\n    /// @param _value The amount of tokens to be approved for transfer\\r\\n    /// @return Whether the approval was successful or not\\r\\n    function approve(address _spender, uint256 _value) public returns (bool success);\\r\\n\\r\\n    /// @param _owner The address of the account owning tokens\\r\\n    /// @param _spender The address of the account able to transfer the tokens\\r\\n    /// @return Amount of remaining tokens allowed to spent\\r\\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\\r\\n\\r\\n    // solhint-disable-next-line no-simple-event-func-name\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n}\\r\\n\"},\"Erc20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\ncontract Erc20 {\\r\\n    event Transfer(address indexed src, address indexed dst, uint wad);\\r\\n    function balanceOf(address guy) public view returns (uint);\\r\\n    function transfer(address dst, uint wad) public returns (bool);\\r\\n}\"},\"interfaces.sol\":{\"content\":\"//Copyright Octobase.co 2019\\r\\npragma solidity ^0.5.1;\\r\\nimport \\\"./statuscodes.sol\\\";\\r\\n\\r\\ncontract ISigner\\r\\n{\\r\\n    enum AccessState\\r\\n    {\\r\\n        Uninitiated, //0x00\\r\\n        Active, //0x01\\r\\n        Frozen //0x02\\r\\n    }\\r\\n\\r\\n    function getNonces()\\r\\n        public\\r\\n        view\\r\\n        returns (bool isActive, uint256 callNonce, address owner);\\r\\n\\r\\n    function changeOwner(address _newOwner)\\r\\n        external\\r\\n        returns (StatusCodes.Status status);\\r\\n\\r\\n    function freeze(address _owner)\\r\\n        external\\r\\n        returns (StatusCodes.Status status);\\r\\n\\r\\n    function changeRoundTable(IRoundTable _newRoundTable)\\r\\n        external\\r\\n        returns (StatusCodes.Status status);\\r\\n\\r\\n    function getAccessState()\\r\\n        public\\r\\n        view\\r\\n        returns (ISigner.AccessState);\\r\\n\\r\\n    function getUsedOwnerKey(address _owner)\\r\\n        public\\r\\n        view\\r\\n        returns(bool);\\r\\n\\r\\n    function checkFreezeInvalidation(\\r\\n            uint256 _upgradeProposalDate,\\r\\n            uint256 _upgradeExecutionDate)\\r\\n        external\\r\\n        //view\\r\\n        returns(bool _isValid);\\r\\n}\\r\\n\\r\\ninterface IVault\\r\\n{\\r\\n    enum LimitState\\r\\n    {\\r\\n        Uninitialized,\\r\\n        NoProposal,\\r\\n        ProposalPending\\r\\n    }\\r\\n    \\r\\n    function initVault(uint256 _weiMax, uint256 _weiStartDateUtc, uint256 _weiWindowSeconds)\\r\\n        external\\r\\n        returns(StatusCodes.Status status);\\r\\n\\r\\n    function sendWei(address payable _to, uint256 _amount)\\r\\n        external\\r\\n        returns (StatusCodes.Status status);\\r\\n\\r\\n    function sendErc20(address _tokenContract, address _to, uint256 _amount)\\r\\n        external\\r\\n        returns (StatusCodes.Status status);\\r\\n}\\r\\n\\r\\ncontract IRoundTable\\r\\n{\\r\\n    function proposeAndSupportRoundTableChange(address _newRoundTable)\\r\\n        external\\r\\n        returns (StatusCodes.Status status, uint proposalId);\\r\\n}\\r\\n\\r\\ninterface IRoundTableFactory\\r\\n{\\r\\n    function produceRoundTable(\\r\\n            ISigner _signer,\\r\\n            address[] calldata _guardians)\\r\\n        external\\r\\n        returns (StatusCodes.Status status, IRoundTable roundTable);\\r\\n}\"},\"octomath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"./safemath.sol\\\";\\r\\n\\r\\nlibrary octomath\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /**\\r\\n    * @dev Ceiling of integer division of two unsigned integers, reverts on division by zero.\\r\\n    */\\r\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, \\\"Can\\u0027t divide by 0\\\");\\r\\n        uint256 c = a.add(b).sub(1).div(b);\\r\\n        return c;\\r\\n    }\\r\\n}\"},\"query.sol\":{\"content\":\"pragma solidity ^0.5.1;\\r\\n//Copyright Octobase.co 2019\\r\\nimport \\\"./signer.sol\\\";\\r\\nimport \\\"./vault.sol\\\";\\r\\nimport \\\"./roundtable.sol\\\";\\r\\n\\r\\ncontract Query\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    constructor() public { }\\r\\n\\r\\n    function getState(Vault _vault)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address _owner,\\r\\n            address _signer,\\r\\n            ISigner.AccessState _state,\\r\\n            IRoundTable _roundTable,\\r\\n            uint256 _callNonce)\\r\\n    {\\r\\n        Signer signer = Signer(_vault.signer());\\r\\n\\r\\n        return (\\r\\n            signer.getOwner(),\\r\\n            address(signer),\\r\\n            signer.getAccessState(),\\r\\n            IRoundTable(signer.getRoundTable()),\\r\\n            signer.getCallNonce());\\r\\n    }\\r\\n\\r\\n    enum ActiveProposalType\\r\\n    {\\r\\n        None,           //0x00\\r\\n        ChangeOwner,    //0x01\\r\\n        ChangeRoundTable//0x02\\r\\n    }\\r\\n\\r\\n    enum Vote\\r\\n    {\\r\\n        NotVoted,       //0x00\\r\\n        Supported,      //0x01\\r\\n        Opposed         //0x02\\r\\n    }\\r\\n\\r\\n    function getRoundTableState(Vault _vault)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            RoundTable RoundTableAddress,\\r\\n\\t\\t    address GuardianAAddress,\\r\\n            address GuardianBAddress,\\r\\n            address GuardianCAddress,\\r\\n            address GuardianDAddress,\\r\\n            address ProposalAddress,\\r\\n            uint256 ProposalCounts,\\r\\n            uint256 ProposalDate,\\r\\n            ActiveProposalType ActiveProposal,\\r\\n            Vote GuardianAVote,\\r\\n            Vote GuardianBVote,\\r\\n            Vote GuardianCVote,\\r\\n            Vote GuardianDVote,\\r\\n            Vote WardVote)\\r\\n    {\\r\\n        RoundTableAddress = RoundTable(Signer(_vault.signer()).getRoundTable());\\r\\n        {\\r\\n            address[4] memory guardians = getGuardians(RoundTableAddress);\\r\\n            GuardianAAddress = guardians[0];\\r\\n            GuardianBAddress = guardians[1];\\r\\n            GuardianCAddress = guardians[2];\\r\\n            GuardianDAddress = guardians[3];\\r\\n        }\\r\\n        {\\r\\n            (uint256[9] memory votes) = getVotes(RoundTableAddress);\\r\\n            ProposalCounts = votes[6] + (votes[7] * 4294967296); //ChangeOwnerProposalsCount and ChangeRoundTableProposalsCount offset 32 bits\\r\\n            ProposalDate = votes[8];\\r\\n            //ChangeOwnerProposalsCount = votes[6];\\r\\n            //ChangeRoundTableProposalsCount = votes[7];\\r\\n            ActiveProposal = ActiveProposalType(votes[5]);\\r\\n            GuardianAVote = Vote(votes[1]);\\r\\n            GuardianBVote = Vote(votes[2]);\\r\\n            GuardianCVote = Vote(votes[3]);\\r\\n            GuardianDVote = Vote(votes[4]);\\r\\n            WardVote = Vote(votes[0]);\\r\\n            ProposalAddress = getProposalAddress(RoundTableAddress, ActiveProposal);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getProposalAddress(RoundTable _roundTable, ActiveProposalType _activeProposal)\\r\\n        private\\r\\n        view\\r\\n        returns(address)\\r\\n    {\\r\\n        if (_activeProposal == ActiveProposalType.None)\\r\\n        {\\r\\n            return address(0);\\r\\n        }\\r\\n        else if (_activeProposal == ActiveProposalType.ChangeOwner)\\r\\n        {\\r\\n            uint256 changeOwnerProposalCount = _roundTable.changeOwnerProposalCount();\\r\\n            address proposedOwner;\\r\\n            (,, proposedOwner,,,,,) = _roundTable.changeOwnerProposals(changeOwnerProposalCount.sub(1));\\r\\n            return proposedOwner;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            uint256 changeRoundTableProposalCount = _roundTable.changeRoundTableProposalCount();\\r\\n            IRoundTable proposedRoundTable;\\r\\n            (,, proposedRoundTable,,,,,) = _roundTable.changeRoundTableProposals(changeRoundTableProposalCount.sub(1));\\r\\n            return address(proposedRoundTable);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getVotes(RoundTable _roundTable)\\r\\n        private\\r\\n        view\\r\\n        returns(uint256[9] memory _votes)\\r\\n    {\\r\\n        uint256 changeRoundTableProposalCount = _roundTable.changeRoundTableProposalCount();\\r\\n        uint256 changeOwnerProposalCount = _roundTable.changeOwnerProposalCount();\\r\\n        uint256 guardianCount = _roundTable.guardianCount();\\r\\n\\r\\n        RoundTable.ProposalExecutionState roundTableProposalState;\\r\\n        RoundTable.ProposalExecutionState ownerProposalState;\\r\\n\\r\\n        _votes[6] = changeOwnerProposalCount;\\r\\n        _votes[7] = changeRoundTableProposalCount;\\r\\n\\r\\n        if (changeRoundTableProposalCount \\u003e 0)\\r\\n        {\\r\\n            (,roundTableProposalState,,,,,_votes[8],) = _roundTable\\r\\n                .changeRoundTableProposals(changeRoundTableProposalCount.sub(1));\\r\\n        }\\r\\n\\r\\n        if (changeOwnerProposalCount \\u003e 0)\\r\\n        {\\r\\n            (,ownerProposalState,,,,,_votes[8],) = _roundTable\\r\\n                .changeOwnerProposals(changeOwnerProposalCount.sub(1));\\r\\n        }\\r\\n\\r\\n        if (roundTableProposalState == RoundTable.ProposalExecutionState.inProgress)\\r\\n        {\\r\\n            _votes[5] = 0x02;\\r\\n\\r\\n            _votes[0] = uint256(_roundTable.getWardRoundTableVote(changeRoundTableProposalCount.sub(1)));\\r\\n            if (guardianCount \\u003e= 1)\\r\\n            {\\r\\n                _votes[1] = uint256(_roundTable.getRoundTableVote(changeRoundTableProposalCount.sub(1), 0));\\r\\n            }\\r\\n            if (guardianCount \\u003e= 2)\\r\\n            {\\r\\n                _votes[2] = uint256(_roundTable.getRoundTableVote(changeRoundTableProposalCount.sub(1), 1));\\r\\n            }\\r\\n            if (guardianCount \\u003e= 3)\\r\\n            {\\r\\n                _votes[3] = uint256(_roundTable.getRoundTableVote(changeRoundTableProposalCount.sub(1), 2));\\r\\n            }\\r\\n            if (guardianCount \\u003e= 4)\\r\\n            {\\r\\n                _votes[4] = uint256(_roundTable.getRoundTableVote(changeRoundTableProposalCount.sub(1), 3));\\r\\n            }\\r\\n        }\\r\\n        else if (ownerProposalState == RoundTable.ProposalExecutionState.inProgress)\\r\\n        {\\r\\n            _votes[5] = 0x01;\\r\\n\\r\\n            _votes[0] = uint256(_roundTable.getWardOwnerVote(changeOwnerProposalCount.sub(1)));\\r\\n            if (guardianCount \\u003e= 1)\\r\\n            {\\r\\n                _votes[1] = uint256(_roundTable.getOwnerVote(changeOwnerProposalCount.sub(1), 0));\\r\\n            }\\r\\n            if (guardianCount \\u003e= 2)\\r\\n            {\\r\\n                _votes[2] = uint256(_roundTable.getOwnerVote(changeOwnerProposalCount.sub(1), 1));\\r\\n            }\\r\\n            if (guardianCount \\u003e= 3)\\r\\n            {\\r\\n                _votes[3] = uint256(_roundTable.getOwnerVote(changeOwnerProposalCount.sub(1), 2));\\r\\n            }\\r\\n            if (guardianCount \\u003e= 4)\\r\\n            {\\r\\n                _votes[4] = uint256(_roundTable.getOwnerVote(changeOwnerProposalCount.sub(1), 3));\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            _votes[5] = 0x00;\\r\\n            _votes[0] = 0x00;\\r\\n            _votes[1] = 0x00;\\r\\n            _votes[2] = 0x00;\\r\\n            _votes[3] = 0x00;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getGuardians(RoundTable _roundTable)\\r\\n        private\\r\\n        view\\r\\n        returns(address[4] memory _guardians)\\r\\n    {\\r\\n        uint256 guardianCount = _roundTable.guardianCount();\\r\\n\\r\\n        if (guardianCount \\u003e= 1)\\r\\n        {\\r\\n            _guardians[0] = address(Signer(uint256(_roundTable.guardians(0))).getVault());\\r\\n        }\\r\\n        if (guardianCount \\u003e= 2)\\r\\n        {\\r\\n            _guardians[1] = address(Signer(uint256(_roundTable.guardians(1))).getVault());\\r\\n        }\\r\\n        if (guardianCount \\u003e= 3)\\r\\n        {\\r\\n            _guardians[2] = address(Signer(uint256(_roundTable.guardians(2))).getVault());\\r\\n        }\\r\\n        if (guardianCount \\u003e= 4)\\r\\n        {\\r\\n            _guardians[3] = address(Signer(uint256(_roundTable.guardians(3))).getVault());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getVault(Signer _signer)\\r\\n        external\\r\\n        view\\r\\n        returns (IVault vault)\\r\\n    {\\r\\n        return _signer.getVault();\\r\\n    }\\r\\n\\r\\n    function getLimit(Vault _vault, address _tokenAddress)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 _max,\\r\\n            uint256 _spent,\\r\\n            uint256 _startDateUtc,\\r\\n            uint256 _windowSeconds,\\r\\n            uint256 _lastLimitWindow,\\r\\n            //uint256 _nextWindowStartDateUtc,\\r\\n            Vault.LimitState _state,\\r\\n            uint256 _proposalExecuteDate,\\r\\n            uint256 _proposalMax,\\r\\n            uint256 _proposalStartDateUtc,\\r\\n            uint256 _proposalWindowSeconds)\\r\\n    {\\r\\n        (_max, _spent, _startDateUtc, _windowSeconds, _lastLimitWindow, _state) = _vault.getLimit(_tokenAddress);\\r\\n        if (_state != IVault.LimitState.Uninitialized)\\r\\n        {\\r\\n            _startDateUtc = _windowSeconds.mul(_lastLimitWindow).add(_startDateUtc);\\r\\n            if (_state == IVault.LimitState.ProposalPending)\\r\\n            {\\r\\n                (_proposalExecuteDate, _proposalMax, _proposalStartDateUtc, _proposalWindowSeconds) = _vault.getProposal(_tokenAddress);\\r\\n                if (_proposalExecuteDate \\u003c= block.timestamp)\\r\\n                {\\r\\n                    _max = _proposalMax;\\r\\n                    _startDateUtc = _proposalWindowSeconds.mul(_lastLimitWindow).add(_proposalStartDateUtc);\\r\\n                    _windowSeconds = _proposalWindowSeconds;\\r\\n                    _state = IVault.LimitState.NoProposal;\\r\\n                    (_proposalExecuteDate, _proposalMax, _proposalStartDateUtc, _proposalWindowSeconds) = (0, 0, 0, 0);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getRoundTableStateForGuardian(Vault _vault, Signer _guardian)\\r\\n        external\\r\\n        view\\r\\n        returns(RoundTable.GuardianRoundTableState _guardianWardState)\\r\\n    {\\r\\n        return RoundTable(Signer(_vault.signer()).getRoundTable()).getRoundTableStateForGuardian(address(_guardian));\\r\\n    }\\r\\n\\r\\n    function getWardStateForGuardian(Vault _vault, Signer _guardian)\\r\\n        external\\r\\n        view\\r\\n        returns(RoundTable.GuardianWardState _guardianWardState)\\r\\n    {\\r\\n        return RoundTable(Signer(_vault.signer()).getRoundTable()).getWardStateForGuardian(address(_guardian));\\r\\n    }\\r\\n}\"},\"roundtable.sol\":{\"content\":\"//Copyright Octobase.co 2019\\r\\npragma solidity ^0.5.1;\\r\\n\\r\\nimport \\\"./safemath.sol\\\";\\r\\nimport \\\"./statuscodes.sol\\\";\\r\\nimport \\\"./interfaces.sol\\\";\\r\\n\\r\\ncontract RoundTable\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    //Structs\\r\\n    enum GuardianRoundTableState\\r\\n    {\\r\\n        Unknown, //0x00 Never a valid response, due to 0x00 being the default RPC response\\r\\n        NoActiveProposal, //0x01\\r\\n        NeedToVote, //0x02\\r\\n        SupportedProposal, //0x03\\r\\n        OpposedProposal, //0x04\\r\\n        NotAGuardian //0x05\\r\\n    }\\r\\n\\r\\n    enum GuardianWardState\\r\\n    {\\r\\n        Unknown, //0x00 Never a valid response, due to 0x00 being the default RPC response\\r\\n        Active, //0x01\\r\\n        AwaitingProposal, //0x02 Ward frozen and no proposal for a new owner exists\\r\\n        NeedToVote, //0x03\\r\\n        SupportedProposal, //0x04\\r\\n        OpposedProposal, //0x05\\r\\n        NotAGuardian //0x06\\r\\n    }\\r\\n\\r\\n    struct ChangeOwnerProposal\\r\\n    {\\r\\n        uint id;\\r\\n        ProposalExecutionState state;\\r\\n        address newOwner;\\r\\n        uint totalVotesCast;\\r\\n        uint totalSupportingVotes;\\r\\n        uint totalOpposingVotes;\\r\\n        mapping (address =\\u003e Vote) votes;\\r\\n        uint dateProposed;\\r\\n        uint256 dateResolved;\\r\\n    }\\r\\n\\r\\n    enum ProposalExecutionState\\r\\n    {\\r\\n        poposalDoesNotExist, //0x00\\r\\n        inProgress, //0x01\\r\\n        passed, //0x02\\r\\n        defeated //0x03\\r\\n    }\\r\\n\\r\\n    struct ChangeRoundTableProposal\\r\\n    {\\r\\n        uint id;\\r\\n        ProposalExecutionState state;\\r\\n        IRoundTable newRoundTable;\\r\\n        uint totalVotesCast;\\r\\n        uint totalSupportingVotes;\\r\\n        uint totalOpposingVotes;\\r\\n        mapping (address =\\u003e Vote) votes;\\r\\n        uint dateProposed;\\r\\n        uint256 dateResolved;\\r\\n    }\\r\\n\\r\\n    function getRoundTableVote(uint256 _id, uint256 _guardianIndex)\\r\\n        public\\r\\n        view\\r\\n        returns(Vote _result)\\r\\n    {\\r\\n        return changeRoundTableProposals[_id].votes[guardians[_guardianIndex]];\\r\\n    }\\r\\n\\r\\n    function getOwnerVote(uint256 _id, uint256 _guardianIndex)\\r\\n        public\\r\\n        view\\r\\n        returns(Vote _result)\\r\\n    {\\r\\n        return changeOwnerProposals[_id].votes[guardians[_guardianIndex]];\\r\\n    }\\r\\n\\r\\n    function getWardRoundTableVote(uint256 _id)\\r\\n        public\\r\\n        view\\r\\n        returns(Vote _result)\\r\\n    {\\r\\n        return changeRoundTableProposals[_id].votes[address(ward)];\\r\\n    }\\r\\n\\r\\n    function getWardOwnerVote(uint256 _id)\\r\\n        public\\r\\n        view\\r\\n        returns(Vote _result)\\r\\n    {\\r\\n        return changeOwnerProposals[_id].votes[address(ward)];\\r\\n    }\\r\\n\\r\\n    enum Vote\\r\\n    {\\r\\n        notVoted, //0x00\\r\\n        support, //0x01\\r\\n        oppose //0x02\\r\\n    }\\r\\n\\r\\n    //Events\\r\\n    event FreezeWard(address indexed freezer, ISigner indexed ward);\\r\\n    event ProposeOwnerChange(\\r\\n        address indexed proposer,\\r\\n        ISigner indexed ward,\\r\\n        address indexed owner,\\r\\n        uint256 proposalId);\\r\\n    event ProposeRoundTableChange(\\r\\n        address indexed _proposer,\\r\\n        ISigner indexed _ward,\\r\\n        IRoundTable indexed _newRoundTable,\\r\\n        uint256 proposalId);\\r\\n    event VoteOnChangeOwner(address indexed voter, ISigner indexed ward, uint256 proposalId, bool isInSupport);\\r\\n    event VoteOnChangeRoundTable(address indexed voter, ISigner indexed ward, uint256 proposalId, bool isInSupport);\\r\\n    event ResolveChangeOwner(address indexed resolver, ISigner indexed ward, uint256 proposalId, bool isPassed);\\r\\n    event ResolveChangeRoundTable(address indexed resolver, ISigner indexed ward, uint256 proposalId, bool isPassed);\\r\\n\\r\\n    //State\\r\\n    uint256 constant cooldownPeriod = 7 days;\\r\\n\\r\\n    address[] public guardians;\\r\\n    mapping(address =\\u003e bool) public guardianMappings;\\r\\n    uint256 public guardianCount;\\r\\n    ISigner public ward;\\r\\n\\r\\n    uint public supportingVotesThreshold;\\r\\n    ChangeOwnerProposal[] public changeOwnerProposals;\\r\\n    ChangeRoundTableProposal[] public changeRoundTableProposals;\\r\\n\\r\\n    IRoundTableFactory public parentFactory;\\r\\n\\r\\n    constructor(\\r\\n            ISigner _ward,\\r\\n            address[] memory _guardians,\\r\\n            IRoundTableFactory _parentFactory)\\r\\n        public\\r\\n    {\\r\\n        require(_guardians.length \\u003e 0, \\\"Needs at least 1 guardian\\\");\\r\\n\\r\\n        for (uint index = 0; index \\u003c _guardians.length; index++)\\r\\n        {\\r\\n            address guardian = _guardians[index];\\r\\n            guardianMappings[guardian] = true;\\r\\n            guardians.push(guardian);\\r\\n        }\\r\\n        guardianCount = _guardians.length;\\r\\n        supportingVotesThreshold = guardianCount.add(1).div(2).add(1); // half the the guardians+ward is the new threshold\\r\\n        ward = _ward;\\r\\n        parentFactory = _parentFactory;\\r\\n    }\\r\\n\\r\\n    modifier onlyGuardians() {\\r\\n        require(guardianMappings[msg.sender], \\\"Only Guardians\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyWard() {\\r\\n        require(address(ward) == msg.sender, \\\"Only ward\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyGuardiansOrWard() {\\r\\n        require(address(ward) == msg.sender || guardianMappings[msg.sender], \\\"Only guardians or wards\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function freezeWard(address _owner)\\r\\n        external\\r\\n        onlyGuardians\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        StatusCodes.Status result = ward.freeze(_owner);\\r\\n        require(result == StatusCodes.Status.Success || result == StatusCodes.Status.AlreadyDone, \\\"Error attempting to freeze signer\\\");\\r\\n\\r\\n        emit FreezeWard(msg.sender, ward);\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function hasActiveProposal()\\r\\n        public\\r\\n        view\\r\\n        returns(bool)\\r\\n    {\\r\\n        if (changeOwnerProposals.length \\u003e 0)\\r\\n        {\\r\\n            ChangeOwnerProposal storage lastProposal = changeOwnerProposals[changeOwnerProposals.length.sub(1)];\\r\\n            if(lastProposal.state == ProposalExecutionState.inProgress)\\r\\n                return true;\\r\\n        }\\r\\n\\r\\n        if (changeRoundTableProposals.length \\u003e 0)\\r\\n        {\\r\\n            ChangeRoundTableProposal storage lastProposal = changeRoundTableProposals[changeRoundTableProposals.length.sub(1)];\\r\\n            if (lastProposal.state == ProposalExecutionState.inProgress)\\r\\n                return true;\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function supportedRecentDefeatedProposal(address _sender)\\r\\n        public\\r\\n        view\\r\\n        returns(bool)\\r\\n    {\\r\\n        if (changeOwnerProposals.length \\u003e 0)\\r\\n        {\\r\\n            ChangeOwnerProposal storage lastChangeOwnerProposal = changeOwnerProposals[changeOwnerProposals.length.sub(1)];\\r\\n            if (lastChangeOwnerProposal.state == ProposalExecutionState.defeated \\u0026\\u0026\\r\\n                lastChangeOwnerProposal.votes[_sender] == Vote.support \\u0026\\u0026\\r\\n                lastChangeOwnerProposal.dateResolved \\u003e= block.timestamp.sub(1 days))\\r\\n            {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (changeRoundTableProposals.length \\u003e 0)\\r\\n        {\\r\\n            ChangeRoundTableProposal storage lastChangeRoundTableProposal = changeRoundTableProposals[changeRoundTableProposals.length.sub(1)];\\r\\n            if (lastChangeRoundTableProposal.state == ProposalExecutionState.defeated \\u0026\\u0026\\r\\n                lastChangeRoundTableProposal.votes[_sender] == Vote.support \\u0026\\u0026\\r\\n                lastChangeRoundTableProposal.dateResolved \\u003e= block.timestamp.sub(1 days))\\r\\n            {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function proposeAndSupportOwnerChange(address _newOwner, uint _proposalId)\\r\\n        external\\r\\n        onlyGuardians\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        require(ward.getAccessState() == ISigner.AccessState.Frozen, \\\"Ward must be frozen\\\");\\r\\n        require(ward.getUsedOwnerKey(_newOwner) == false, \\\"Owner keys cannot be reused\\\");\\r\\n        require(changeOwnerProposals.length == _proposalId, \\\"Invalid proposalID\\\");\\r\\n        require(!hasActiveProposal(), \\\"There can only be one active proposal\\\");\\r\\n        require(!supportedRecentDefeatedProposal(msg.sender), \\\"Must wait 24 hours after defeat to re-propose\\\");\\r\\n\\r\\n        if (changeOwnerProposals.length \\u003e 0)\\r\\n        {\\r\\n            ChangeOwnerProposal storage lastProposal = changeOwnerProposals[changeOwnerProposals.length.sub(1)];\\r\\n            require(\\r\\n                lastProposal.state != ProposalExecutionState.inProgress,\\r\\n                \\\"There can only be one active proposal\\\");\\r\\n        }\\r\\n\\r\\n        ChangeOwnerProposal memory proposal = ChangeOwnerProposal({\\r\\n            id: changeOwnerProposals.length,\\r\\n            state: ProposalExecutionState.inProgress,\\r\\n            newOwner: _newOwner,\\r\\n            totalVotesCast: 0,\\r\\n            totalSupportingVotes: 0,\\r\\n            totalOpposingVotes: 0,\\r\\n            dateProposed: block.timestamp,\\r\\n            dateResolved: 0\\r\\n            });\\r\\n        changeOwnerProposals.push(proposal);\\r\\n\\r\\n        emit ProposeOwnerChange(msg.sender, ward, _newOwner, _proposalId);\\r\\n        internalVoteOnChangeOwnerProposal(proposal.id, true);\\r\\n        return (StatusCodes.Status.Success);\\r\\n    }\\r\\n\\r\\n    function proposeAndSupportRoundTableChange(IRoundTable _newRoundTable)\\r\\n        external\\r\\n        onlyWard\\r\\n        returns (StatusCodes.Status status, uint proposalId)\\r\\n    {\\r\\n        require(!hasActiveProposal(), \\\"There can only be one active proposal\\\");\\r\\n        require(!supportedRecentDefeatedProposal(msg.sender), \\\"Must wait 24 hours after defeat to re-propose\\\");\\r\\n\\r\\n        if (changeRoundTableProposals.length \\u003e 0)\\r\\n        {\\r\\n            ChangeRoundTableProposal storage lastProposal = changeRoundTableProposals[changeRoundTableProposals.length.sub(1)];\\r\\n            require(\\r\\n                lastProposal.state != ProposalExecutionState.inProgress,\\r\\n                \\\"There can only be one active proposal\\\");\\r\\n        }\\r\\n\\r\\n        ChangeRoundTableProposal memory proposal = ChangeRoundTableProposal({\\r\\n            id: changeRoundTableProposals.length,\\r\\n            state: ProposalExecutionState.inProgress,\\r\\n            newRoundTable: _newRoundTable,\\r\\n            totalVotesCast: 0,\\r\\n            totalSupportingVotes: 0,\\r\\n            totalOpposingVotes: 0,\\r\\n            dateProposed: block.timestamp,\\r\\n            dateResolved: 0\\r\\n            });\\r\\n        changeRoundTableProposals.push(proposal);\\r\\n        emit ProposeRoundTableChange(\\r\\n            msg.sender,\\r\\n            ward,\\r\\n            _newRoundTable,\\r\\n            proposal.id);\\r\\n        internalVoteOnChangeRoundTableProposal(proposal.id, true);\\r\\n        return (StatusCodes.Status.Success, proposal.id);\\r\\n    }\\r\\n\\r\\n    function voteOnChangeOwner(uint _proposalId, bool _supportProposal)\\r\\n        external\\r\\n        onlyGuardiansOrWard\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        return internalVoteOnChangeOwnerProposal(_proposalId, _supportProposal);\\r\\n    }\\r\\n\\r\\n    function voteOnChangeRoundTableProposal(uint _proposalId, bool _supportProposal)\\r\\n        external\\r\\n        onlyGuardiansOrWard\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        return internalVoteOnChangeRoundTableProposal(_proposalId, _supportProposal);\\r\\n    }\\r\\n\\r\\n    function internalVoteOnChangeOwnerProposal(\\r\\n            uint _proposalId,\\r\\n            bool _supportProposal)\\r\\n        internal\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        require(_proposalId == changeOwnerProposals.length.sub(1), \\\"ProposalId mismatch\\\");\\r\\n        ChangeOwnerProposal storage proposal = changeOwnerProposals[_proposalId];\\r\\n        if (proposal.state == ProposalExecutionState.passed)\\r\\n        {\\r\\n            revert (\\\"Proposal already passed\\\");\\r\\n        }\\r\\n        if (proposal.state == ProposalExecutionState.defeated)\\r\\n        {\\r\\n            revert (\\\"Proposal already defeated\\\");\\r\\n        }\\r\\n\\r\\n        Vote existingVote = proposal.votes[address(msg.sender)];\\r\\n        if (existingVote == Vote.support)\\r\\n        {\\r\\n            proposal.totalVotesCast = proposal.totalVotesCast.sub(1);\\r\\n            proposal.totalSupportingVotes = proposal.totalSupportingVotes.sub(1);\\r\\n        }\\r\\n        else if (existingVote == Vote.oppose)\\r\\n        {\\r\\n            proposal.totalVotesCast = proposal.totalVotesCast.sub(1);\\r\\n            proposal.totalOpposingVotes = proposal.totalOpposingVotes.sub(1);\\r\\n        }\\r\\n\\r\\n        proposal.totalVotesCast = proposal.totalVotesCast.add(1);\\r\\n        proposal.totalSupportingVotes = proposal.totalSupportingVotes.add(_supportProposal ? 1 : 0);\\r\\n        proposal.totalOpposingVotes = proposal.totalOpposingVotes.add(_supportProposal ? 0 : 1);\\r\\n        proposal.votes[address(msg.sender)] = _supportProposal ? Vote.support : Vote.oppose;\\r\\n\\r\\n        emit VoteOnChangeOwner(msg.sender, ward, proposal.id, _supportProposal);\\r\\n\\r\\n        if (proposal.totalSupportingVotes \\u003e= supportingVotesThreshold)\\r\\n        {\\r\\n            privateResolveChangeOwnerProposal(proposal, msg.sender, true);\\r\\n        }\\r\\n        else if (proposal.totalOpposingVotes \\u003e guardianCount.add(1).sub(supportingVotesThreshold))\\r\\n        {\\r\\n            privateResolveChangeOwnerProposal(proposal, msg.sender, false);\\r\\n        }\\r\\n\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function internalVoteOnChangeRoundTableProposal(\\r\\n            uint _proposalId,\\r\\n            bool _supportProposal)\\r\\n        internal\\r\\n        returns (StatusCodes.Status _statusCode)\\r\\n    {\\r\\n        require(_proposalId == changeRoundTableProposals.length.sub(1), \\\"Not the id of the last active proposal\\\");\\r\\n        ChangeRoundTableProposal storage proposal = changeRoundTableProposals[_proposalId];\\r\\n        if (proposal.state == ProposalExecutionState.passed)\\r\\n        {\\r\\n            revert (\\\"Proposal already passed\\\");\\r\\n        }\\r\\n        if (proposal.state == ProposalExecutionState.defeated)\\r\\n        {\\r\\n            revert (\\\"Proposal already defeated\\\");\\r\\n        }\\r\\n\\r\\n        Vote existingVote = proposal.votes[address(msg.sender)];\\r\\n        if (existingVote == Vote.support)\\r\\n        {\\r\\n            proposal.totalVotesCast = proposal.totalVotesCast.sub(1);\\r\\n            proposal.totalSupportingVotes = proposal.totalSupportingVotes.sub(1);\\r\\n        }\\r\\n        else if (existingVote == Vote.oppose)\\r\\n        {\\r\\n            proposal.totalVotesCast = proposal.totalVotesCast.sub(1);\\r\\n            proposal.totalOpposingVotes = proposal.totalOpposingVotes.sub(1);\\r\\n        }\\r\\n\\r\\n        proposal.totalVotesCast = proposal.totalVotesCast.add(1);\\r\\n        proposal.totalSupportingVotes = proposal.totalSupportingVotes.add(_supportProposal ? 1 : 0);\\r\\n        proposal.totalOpposingVotes = proposal.totalOpposingVotes.add(_supportProposal ? 0 : 1);\\r\\n        proposal.votes[address(msg.sender)] = _supportProposal ? Vote.support : Vote.oppose;\\r\\n\\r\\n        emit VoteOnChangeRoundTable(msg.sender, ward, proposal.id, _supportProposal);\\r\\n\\r\\n        if (proposal.totalSupportingVotes \\u003e= supportingVotesThreshold)\\r\\n        {\\r\\n            privateResolveChangeRoundTableProposal(proposal, msg.sender, true);\\r\\n        }\\r\\n        else if (proposal.totalOpposingVotes \\u003e guardianCount.add(1).sub(supportingVotesThreshold))\\r\\n        {\\r\\n            privateResolveChangeRoundTableProposal(proposal, msg.sender, false);\\r\\n        }\\r\\n\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function executeChangeOwnerProposal(uint _proposalId)\\r\\n        external\\r\\n    {\\r\\n        ChangeOwnerProposal storage proposal = changeOwnerProposals[_proposalId];\\r\\n        require(proposal.state == ProposalExecutionState.inProgress, \\\"The proposal has been executed\\\");\\r\\n        if (proposal.dateProposed \\u003c= block.timestamp.sub(cooldownPeriod))\\r\\n        {\\r\\n            privateResolveChangeOwnerProposal(\\r\\n                proposal,\\r\\n                msg.sender,\\r\\n                proposal.totalSupportingVotes \\u003e proposal.totalOpposingVotes);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            revert(\\\"Proposal execution failed\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function privateResolveChangeOwnerProposal(\\r\\n            ChangeOwnerProposal storage _proposal,\\r\\n            address _resolver,\\r\\n            bool _passed)\\r\\n        private\\r\\n        returns (StatusCodes.Status Status)\\r\\n    {\\r\\n        if(_passed)\\r\\n        {\\r\\n            ward.changeOwner(_proposal.newOwner);\\r\\n            _proposal.state = ProposalExecutionState.passed;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            _proposal.state = ProposalExecutionState.defeated;\\r\\n        }\\r\\n        _proposal.dateResolved = block.timestamp;\\r\\n        emit ResolveChangeOwner(_resolver, ward, _proposal.id, _passed);\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function executeChangeRoundTableProposal(uint _proposalId)\\r\\n        external\\r\\n    {\\r\\n        ChangeRoundTableProposal storage proposal = changeRoundTableProposals[_proposalId];\\r\\n        require(proposal.state == ProposalExecutionState.inProgress, \\\"The proposal has been executed\\\");\\r\\n        if (proposal.dateProposed \\u003c= block.timestamp.sub(cooldownPeriod))\\r\\n        {\\r\\n            privateResolveChangeRoundTableProposal(\\r\\n                proposal,\\r\\n                msg.sender,\\r\\n                proposal.totalSupportingVotes \\u003e proposal.totalOpposingVotes);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            revert(\\\"Proposal execution failed\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function privateResolveChangeRoundTableProposal(\\r\\n            ChangeRoundTableProposal storage _proposal,\\r\\n            address _resolver,\\r\\n            bool _passed)\\r\\n        private\\r\\n        returns (StatusCodes.Status Status)\\r\\n    {\\r\\n        if (_passed)\\r\\n        {\\r\\n            ward.changeRoundTable(IRoundTable(_proposal.newRoundTable));\\r\\n            _proposal.state = ProposalExecutionState.passed;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            _proposal.state = ProposalExecutionState.defeated;\\r\\n        }\\r\\n        _proposal.dateResolved = block.timestamp;\\r\\n        emit ResolveChangeRoundTable(_resolver, ward, _proposal.id, _passed);\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function guardianChangeOwnerVote(uint256 _proposalId, address _guardian)\\r\\n        external\\r\\n        view\\r\\n        returns(Vote vote)\\r\\n    {\\r\\n        if (_proposalId \\u003e= changeOwnerProposals.length) {\\r\\n            return Vote.notVoted;\\r\\n        }\\r\\n        return changeOwnerProposals[_proposalId].votes[_guardian];\\r\\n    }\\r\\n\\r\\n    function guardianChangeRoundTableVote(uint256 _proposalId, address _guardian)\\r\\n        external\\r\\n        view\\r\\n        returns(Vote vote)\\r\\n    {\\r\\n        if (_proposalId \\u003e= changeRoundTableProposals.length) {\\r\\n            return Vote.notVoted;\\r\\n        }\\r\\n\\r\\n        return changeRoundTableProposals[_proposalId].votes[_guardian];\\r\\n    }\\r\\n\\r\\n    function getRoundTableStateForGuardian(address _guardian)\\r\\n        external\\r\\n        view\\r\\n        returns(GuardianRoundTableState _guardianWardState)\\r\\n    {\\r\\n        if (!guardianMappings[_guardian])\\r\\n            return GuardianRoundTableState.NotAGuardian;\\r\\n\\r\\n        if (changeRoundTableProposals.length == 0) {\\r\\n            return GuardianRoundTableState.NoActiveProposal;\\r\\n        } else {\\r\\n            ChangeRoundTableProposal storage proposal = changeRoundTableProposals[changeRoundTableProposals.length.sub(1)];\\r\\n            if (proposal.state != ProposalExecutionState.inProgress) {\\r\\n                return GuardianRoundTableState.NoActiveProposal;\\r\\n            } else {\\r\\n                Vote myVote = proposal.votes[_guardian];\\r\\n                if (myVote == Vote.support) {\\r\\n                    return GuardianRoundTableState.SupportedProposal;\\r\\n                } else if (myVote == Vote.oppose) {\\r\\n                    return GuardianRoundTableState.OpposedProposal;\\r\\n                } else if (myVote == Vote.notVoted) {\\r\\n                    return GuardianRoundTableState.NeedToVote;\\r\\n                } else {\\r\\n                    return GuardianRoundTableState.Unknown;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getWardStateForGuardian(address _guardian)\\r\\n        external\\r\\n        view\\r\\n        returns(GuardianWardState _guardianWardState)\\r\\n    {\\r\\n        if (!guardianMappings[_guardian])\\r\\n            return GuardianWardState.NotAGuardian;\\r\\n        ISigner _ward = ISigner(ward);\\r\\n\\r\\n        if (changeOwnerProposals.length == 0) {\\r\\n            if (_ward.getAccessState() == ISigner.AccessState.Active) {\\r\\n                return GuardianWardState.Active;\\r\\n            } else if (_ward.getAccessState() == ISigner.AccessState.Frozen){\\r\\n                return GuardianWardState.AwaitingProposal;\\r\\n            } else {\\r\\n                return GuardianWardState.Unknown;\\r\\n            }\\r\\n        } else {\\r\\n            ChangeOwnerProposal storage proposal = changeOwnerProposals[changeOwnerProposals.length.sub(1)];\\r\\n            if (proposal.state != ProposalExecutionState.inProgress) {\\r\\n                if (_ward.getAccessState() == ISigner.AccessState.Active) {\\r\\n                    return GuardianWardState.Active;\\r\\n                } else if (_ward.getAccessState() == ISigner.AccessState.Frozen){\\r\\n                    return GuardianWardState.AwaitingProposal;\\r\\n                } else {\\r\\n                    return GuardianWardState.Unknown;\\r\\n                }\\r\\n            } else {\\r\\n                Vote myVote = proposal.votes[_guardian];\\r\\n                if (myVote == Vote.support) {\\r\\n                    return GuardianWardState.SupportedProposal;\\r\\n                } else if (myVote == Vote.oppose) {\\r\\n                    return GuardianWardState.OpposedProposal;\\r\\n                } else if (myVote == Vote.notVoted) {\\r\\n                    return GuardianWardState.NeedToVote;\\r\\n                } else {\\r\\n                    return GuardianWardState.Unknown;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function changeOwnerProposalCount()\\r\\n        external\\r\\n        view\\r\\n        returns(uint _proposalCount)\\r\\n    {\\r\\n        return changeOwnerProposals.length;\\r\\n    }\\r\\n\\r\\n    function changeRoundTableProposalCount()\\r\\n        external\\r\\n        view\\r\\n        returns(uint _proposalCount)\\r\\n    {\\r\\n        return changeRoundTableProposals.length;\\r\\n    }\\r\\n\\r\\n    function octobaseType()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint16 typeCode)\\r\\n    {\\r\\n        return 7;\\r\\n    }\\r\\n\\r\\n    function octobaseTypeVersion()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint32 typeVersion)\\r\\n    {\\r\\n        return 1;\\r\\n    }\\r\\n}\"},\"roundtablefactory.sol\":{\"content\":\"//Copyright Octobase.co 2019\\r\\n\\r\\npragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"./safemath.sol\\\";\\r\\nimport \\\"./statuscodes.sol\\\";\\r\\nimport \\\"./roundtable.sol\\\";\\r\\n\\r\\n//Copyright Octobase.co 2019\\r\\n\\r\\ncontract RoundTableFactory is IRoundTableFactory\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    //State\\r\\n    address public factoryOwner;\\r\\n    address[] public roundTables;\\r\\n    uint public roundTableCount;\\r\\n    mapping(address=\\u003ebool) public roundTableMapping;\\r\\n    mapping(address=\\u003ebool) public successors;\\r\\n\\r\\n    //Events\\r\\n    event ProduceRoundTable(address indexed producer, ISigner indexed ward, RoundTable indexed roundTable);\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require (msg.sender == factoryOwner, \\\"Only the owner may call this method\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(address _factoryOwner)\\r\\n        public\\r\\n    {\\r\\n        factoryOwner = _factoryOwner;\\r\\n    }\\r\\n\\r\\n    function produceRoundTable(ISigner _ward, address[] calldata _guardians)\\r\\n        external\\r\\n        returns\\r\\n        (StatusCodes.Status _status, IRoundTable roundTable)\\r\\n    {\\r\\n        RoundTable createdRoundTable = new RoundTable(_ward, _guardians, this);\\r\\n        address roundTableAddress = address(createdRoundTable);\\r\\n        roundTables.push(roundTableAddress);\\r\\n        roundTableMapping[roundTableAddress] = true;\\r\\n        emit ProduceRoundTable(msg.sender, _ward, createdRoundTable);\\r\\n        roundTableCount = roundTableCount.add(1);\\r\\n        return (StatusCodes.Status.Success, IRoundTable(roundTableAddress));\\r\\n    }\\r\\n\\r\\n    function changeOwner(address _newFactoryOwner)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        factoryOwner = _newFactoryOwner;\\r\\n    }\\r\\n\\r\\n    function setSuccessor(address _successor, bool _isSuccessor)\\r\\n        external\\r\\n        onlyOwner\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        successors[_successor] = _isSuccessor;\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function octobaseType()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint16 typeCode)\\r\\n    {\\r\\n        return 8;\\r\\n    }\\r\\n\\r\\n    function octobaseTypeVersion()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint32 typeVersion)\\r\\n    {\\r\\n        return 1;\\r\\n    }\\r\\n}\"},\"safemath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Unsigned math operations with safety checks that revert on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n    * @dev Multiplies two unsigned integers, reverts on overflow.\\r\\n    */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"uint256 overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\r\\n    */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, \\\"Can\\u0027t divide by 0\\\");\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n    */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"uint256 underflow\\\");\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Adds two unsigned integers, reverts on overflow.\\r\\n    */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"uint256 overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\r\\n    * reverts when dividing by zero.\\r\\n    */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"Can\\u0027t mod by 0\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev returns the greater of two numbers\\r\\n    */\\r\\n    function max(uint a, uint b) internal pure returns (uint) {\\r\\n        return a \\u003e b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev returns the lesser of two numbers\\r\\n    */\\r\\n    function min(uint a, uint b) internal pure returns (uint) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n}\"},\"signer.sol\":{\"content\":\"//Copyright Octobase.co 2019\\r\\n\\r\\npragma solidity ^0.5.1;\\r\\nimport \\\"./statuscodes.sol\\\";\\r\\nimport \\\"./safemath.sol\\\";\\r\\nimport \\\"./interfaces.sol\\\";\\r\\nimport \\\"./storage.sol\\\";\\r\\n\\r\\ncontract SignerProxy\\r\\n{\\r\\n    address public delegate;\\r\\n\\r\\n    constructor (address _delegate)\\r\\n        public\\r\\n    {\\r\\n        delegate = _delegate;\\r\\n    }\\r\\n\\r\\n    function()\\r\\n        external\\r\\n        payable\\r\\n    {\\r\\n        assembly\\r\\n        {\\r\\n            let _target := sload(0)\\r\\n            calldatacopy(0x0, 0x0, calldatasize)\\r\\n            let result := delegatecall(gas, _target, 0x0, calldatasize, 0x0, 0)\\r\\n            returndatacopy(0x0, 0x0, returndatasize)\\r\\n            switch result case 0 {revert(0, 0)} default {return (0, returndatasize)}\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract SignerBase\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address public delegate; // CG: Since this is the proxy pattern (for SignerProxy) this state *must* be here and it *must* be *the only* state\\r\\n\\r\\n    struct SignerState\\r\\n    {\\r\\n        address parentFactory;\\r\\n        ISigner.AccessState accessState;\\r\\n        address owner;\\r\\n        address roundTable;\\r\\n        address vault;\\r\\n        uint256 callNonce;\\r\\n    }\\r\\n\\r\\n    struct UpgradeProposal\\r\\n    {\\r\\n        uint256 executionDate;\\r\\n        address implementation;\\r\\n        uint256 dateProposed;\\r\\n        address owner;\\r\\n        bool isExecuted;\\r\\n    }\\r\\n\\r\\n    function writeState(SignerState memory _in)\\r\\n        internal\\r\\n    {\\r\\n        getStore().setSignerState(\\r\\n            _in.parentFactory,\\r\\n            _in.accessState,\\r\\n            _in.owner,\\r\\n            _in.roundTable,\\r\\n            _in.vault,\\r\\n            _in.callNonce);\\r\\n    }\\r\\n\\r\\n    function readState()\\r\\n        internal\\r\\n        view\\r\\n        returns(SignerState memory)\\r\\n    {\\r\\n        SignerState memory result;\\r\\n        (result.parentFactory,\\r\\n        result.accessState,\\r\\n        result.owner,\\r\\n        result.roundTable,\\r\\n        result.vault,\\r\\n        result.callNonce) = getStore().getSignerState();\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function getState()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address parentFactory,\\r\\n            ISigner.AccessState accessState,\\r\\n            address owner,\\r\\n            IRoundTable roundTable,\\r\\n            IVault vault,\\r\\n            uint256 callNonce)\\r\\n    {\\r\\n        SignerState memory state = readState();\\r\\n        return (\\r\\n            state.parentFactory,\\r\\n            state.accessState,\\r\\n            state.owner,\\r\\n            IRoundTable(state.roundTable),\\r\\n            IVault(state.vault),\\r\\n            state.callNonce);\\r\\n    }\\r\\n\\r\\n    constructor() public { }\\r\\n\\r\\n    function enc(string memory _inputString)\\r\\n        public\\r\\n        pure\\r\\n        returns (bytes32 _encodedString)\\r\\n    {\\r\\n        return keccak256(abi.encode(_inputString));\\r\\n    }\\r\\n\\r\\n    function encMap(address _address, string memory _member)\\r\\n        public\\r\\n        pure\\r\\n        returns(bytes32)\\r\\n    {\\r\\n        return keccak256(abi.encode(_address, _member));\\r\\n    }\\r\\n\\r\\n    function encArray(uint256 _index, string memory _member)\\r\\n        public\\r\\n        pure\\r\\n        returns(bytes32)\\r\\n    {\\r\\n        return keccak256(abi.encode(_index, _member));\\r\\n    }\\r\\n\\r\\n    function getUsedOwnerKey(address _owner)\\r\\n        public\\r\\n        view\\r\\n        returns(bool)\\r\\n    {\\r\\n        return getStore().getBool(encMap(_owner, \\\"usedOwnerKeys\\\"));\\r\\n    }\\r\\n\\r\\n    function getFreezeDate(uint256 _freezeIndex)\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        return getStore().getUint256(encArray(_freezeIndex, \\\"freezeDates\\\"));\\r\\n    }\\r\\n\\r\\n    function getFreezeIndex()\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        return getStore().getUint256(\\\"freezeIndex\\\");\\r\\n    }\\r\\n\\r\\n    function getParentFactory()\\r\\n        public\\r\\n        view\\r\\n        returns (string memory)\\r\\n    {\\r\\n        return getStore().getString(\\\"parentFactory\\\");\\r\\n    }\\r\\n\\r\\n    function getAccessState()\\r\\n        public\\r\\n        view\\r\\n        returns (ISigner.AccessState)\\r\\n    {\\r\\n        return ISigner.AccessState(getStore().getUint256(\\\"accessState\\\"));\\r\\n    }\\r\\n\\r\\n    function getNonces()\\r\\n        external\\r\\n        view\\r\\n        returns (bool isActive, uint256 callNonce, address owner)\\r\\n    {\\r\\n        SignerState memory state = readState();\\r\\n        return (state.accessState == ISigner.AccessState.Active, state.callNonce, state.owner);\\r\\n    }\\r\\n\\r\\n    function getStore()\\r\\n        public\\r\\n        pure\\r\\n        returns (Storage store)\\r\\n    {\\r\\n        return Storage(0x1234567890AbcdeffedcBA98765432123454321F);\\r\\n    }\\r\\n\\r\\n    function getOwner()\\r\\n        public\\r\\n        view\\r\\n        returns (address payable)\\r\\n    {\\r\\n        return address(uint(getStore().getAddress(\\\"owner\\\")));\\r\\n    }\\r\\n\\r\\n    function getRoundTable()\\r\\n        public\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        return address(uint(getStore().getAddress(\\\"roundTable\\\")));\\r\\n    }\\r\\n\\r\\n    function getVault()\\r\\n        public\\r\\n        view\\r\\n        returns (IVault _vault)\\r\\n    {\\r\\n        return IVault(uint(getStore().getAddress(\\\"vault\\\")));\\r\\n    }\\r\\n\\r\\n    function getCallNonce()\\r\\n        public\\r\\n        view\\r\\n        returns(uint256 _callNonce)\\r\\n    {\\r\\n        return getStore().getUint256(\\\"callNonce\\\");\\r\\n    }\\r\\n\\r\\n    function getOctobase()\\r\\n        public\\r\\n        pure\\r\\n        returns (address payable)\\r\\n    {\\r\\n        return 0xB956B0ba89aD213EbbA1eaFE11Ca6E0483d6DCFE;\\r\\n        //return address(uint(getStore().getAddress(\\\"octobase\\\")));\\r\\n    }\\r\\n\\r\\n    function getUpgradeProposal()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 _executionDate,\\r\\n            address _implementation,\\r\\n            uint256 _dateProposed,\\r\\n            address _owner,\\r\\n            bool _isExecuted)\\r\\n    {\\r\\n        UpgradeProposal memory result = internalGetUpgradeProposal();\\r\\n        return(\\r\\n            result.executionDate,\\r\\n            result.implementation,\\r\\n            result.dateProposed,\\r\\n            result.owner,\\r\\n            result.isExecuted\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function internalGetUpgradeProposal()\\r\\n        internal\\r\\n        view\\r\\n        returns (UpgradeProposal memory)\\r\\n    {\\r\\n        Storage store = getStore();\\r\\n        return UpgradeProposal(\\r\\n            store.getUint256(enc(\\\"UpgradeProposal.executionDate\\\")),\\r\\n            store.getAddress(enc(\\\"UpgradeProposal.implementation\\\")),\\r\\n            store.getUint256(enc(\\\"UpgradeProposal.dateProposed\\\")),\\r\\n            store.getAddress(enc(\\\"UpgradeProposal.owner\\\")),\\r\\n            store.getBool(enc(\\\"UpgradeProposal.isExecuted\\\")));\\r\\n    }\\r\\n\\r\\n    function setUsedOwnerKey(address _owner)\\r\\n        internal\\r\\n    {\\r\\n        getStore().setBool(encMap(_owner, \\\"usedOwnerKeys\\\"), true);\\r\\n    }\\r\\n\\r\\n    function pushFreezeDate()\\r\\n        internal\\r\\n    {\\r\\n        Storage store = getStore();\\r\\n        uint256 freezeIndex = store.getUint256(\\\"freezeIndex\\\");\\r\\n        store.setUint256(encArray(freezeIndex, \\\"freezeDates\\\"), block.timestamp);\\r\\n        store.setUint256(\\\"freezeIndex\\\", freezeIndex.add(1));\\r\\n    }\\r\\n\\r\\n    function setUpgradeProposal(\\r\\n            uint256 _executionDate,\\r\\n            address _implementation,\\r\\n            address _owner,\\r\\n            uint256 _dateProposed,\\r\\n            bool _isExecuted)\\r\\n        internal\\r\\n    {\\r\\n        Storage store = getStore();\\r\\n        store.setUint256(enc(\\\"UpgradeProposal.executionDate\\\"), _executionDate);\\r\\n        store.setAddress(enc(\\\"UpgradeProposal.implementation\\\"), _implementation);\\r\\n        store.setUint256(enc(\\\"UpgradeProposal.dateProposed\\\"), _dateProposed);\\r\\n        store.setAddress(enc(\\\"UpgradeProposal.owner\\\"), _owner);\\r\\n        store.setBool(enc(\\\"UpgradeProposal.isExecuted\\\"), _isExecuted);\\r\\n    }\\r\\n\\r\\n    function internalSetUpgradeProposal(UpgradeProposal memory _proposal)\\r\\n        internal\\r\\n    {\\r\\n        Storage store = getStore();\\r\\n        store.setUint256(enc(\\\"UpgradeProposal.executionDate\\\"), _proposal.executionDate);\\r\\n        store.setAddress(enc(\\\"UpgradeProposal.implementation\\\"), _proposal.implementation);\\r\\n        store.setUint256(enc(\\\"UpgradeProposal.dateProposed\\\"), _proposal.dateProposed);\\r\\n        store.setAddress(enc(\\\"UpgradeProposal.owner\\\"), _proposal.owner);\\r\\n        store.setBool(enc(\\\"UpgradeProposal.isExecuted\\\"), _proposal.isExecuted);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Signer is SignerBase\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    event Claim(address owner);\\r\\n    event Initiation(IVault vault, address owner);\\r\\n    event OwnerChange(address owner);\\r\\n    event RoundTableChange(IRoundTable roundTable);\\r\\n    event Forward(\\r\\n        string _msg,\\r\\n        address indexed to,\\r\\n        bytes result,\\r\\n        bool success);\\r\\n    event Freeze(address indexed freezer, bool wasFrozen);\\r\\n    event MetaFreeze(\\r\\n        address indexed relayer,\\r\\n        address indexed rewardRecipient,\\r\\n        address rewardToken,\\r\\n        uint256 rewardAmount,\\r\\n        address indexed freezer);\\r\\n    event MetaCall(\\r\\n        string _msg,\\r\\n        address indexed relayer,\\r\\n        address indexed rewardRecipient,\\r\\n        address rewardToken,\\r\\n        uint256 rewardAmount,\\r\\n        bytes result,\\r\\n        bool success);\\r\\n    event WalletFee(\\r\\n        address indexed provider,\\r\\n        address rewardToken,\\r\\n        uint256 rewardAmount);\\r\\n    event ProposeUpgrade(uint256 cooldown, address newImplementation);\\r\\n    event ExecuteUpgrade(address indexed executor, address newImplementation);\\r\\n    event LogProposeNewGuardians(\\r\\n        IRoundTable _currentRoundTable,\\r\\n        IRoundTable _proposedRoundTable,\\r\\n        uint256 _proposalId);\\r\\n\\r\\n    constructor() public { }\\r\\n\\r\\n    modifier onlySelf()\\r\\n    {\\r\\n        require(msg.sender == address(this), \\\"Only self\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function()\\r\\n        external\\r\\n        payable\\r\\n    {\\r\\n        revert(\\\"No fallbacks\\\");\\r\\n    }\\r\\n\\r\\n    function claim(address _owner)\\r\\n        external\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        SignerState memory state = readState();\\r\\n        require(state.owner == address(0x0), \\\"Owner can\\u0027t be 0x0\\\");\\r\\n        require(state.accessState == ISigner.AccessState.Uninitiated, \\\"Signer already initiated\\\");\\r\\n        emit Claim(_owner);\\r\\n\\r\\n        require(getUsedOwnerKey(_owner) == false, \\\"Keys cannot be reused\\\");\\r\\n        state.owner = _owner;\\r\\n        setUsedOwnerKey(_owner);\\r\\n\\r\\n        writeState(state);\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function init(address _owner,\\r\\n            IVault _vault,\\r\\n            uint _weiMaxLimit,\\r\\n            uint _weiLimitStartDateUtc,\\r\\n            uint _weiLimitWindowSeconds)\\r\\n        external\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        SignerState memory state = readState();\\r\\n        require(msg.sender == state.owner, \\\"Not the owner\\\");\\r\\n        require(state.accessState == ISigner.AccessState.Uninitiated, \\\"Uninitiated\\\");\\r\\n\\r\\n        StatusCodes.Status callStatus = _vault.initVault(_weiMaxLimit, _weiLimitStartDateUtc, _weiLimitWindowSeconds);\\r\\n        require(callStatus == StatusCodes.Status.Success, \\\"Vault not inititialized\\\");\\r\\n\\r\\n        state.owner = _owner;\\r\\n        setUsedOwnerKey(_owner);\\r\\n\\r\\n        state.vault = address(_vault);\\r\\n        state.accessState = ISigner.AccessState.Active;\\r\\n        emit Initiation(_vault, _owner);\\r\\n\\r\\n        writeState(state);\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function changeOwner(address _newOwner)\\r\\n        external\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        SignerState memory state = readState();\\r\\n        require(msg.sender == address(state.roundTable), \\\"Only round table\\\");\\r\\n\\r\\n        require(getUsedOwnerKey(_newOwner) == false, \\\"Keys cannot be reused\\\");\\r\\n        state.owner = _newOwner;\\r\\n        setUsedOwnerKey(state.owner);\\r\\n\\r\\n        state.accessState = ISigner.AccessState.Active;\\r\\n        emit OwnerChange(_newOwner);\\r\\n\\r\\n        writeState(state);\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function changeRoundTable(IRoundTable _newRoundTable)\\r\\n        external\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        SignerState memory state = readState();\\r\\n\\r\\n        require(msg.sender == address(state.roundTable), \\\"Only round table\\\");\\r\\n        state.roundTable = address(_newRoundTable);\\r\\n        emit RoundTableChange(_newRoundTable);\\r\\n\\r\\n        writeState(state);\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function appointGuardians(\\r\\n            IRoundTableFactory _roundTableFactory,\\r\\n            address[] calldata _guardians)\\r\\n        external\\r\\n        onlySelf\\r\\n        returns (StatusCodes.Status status, IRoundTable roundTable)\\r\\n    {\\r\\n        SignerState memory state = readState();\\r\\n\\r\\n        require(state.roundTable == address(0x0), \\\"Already have guardians\\\");\\r\\n        (StatusCodes.Status code, IRoundTable createdRoundTable) = _roundTableFactory\\r\\n            .produceRoundTable(\\r\\n                ISigner(address(this)),\\r\\n                _guardians);\\r\\n        require(code == StatusCodes.Status.Success, \\\"Factory unsuccessful\\\");\\r\\n        state.roundTable = address(createdRoundTable);\\r\\n        emit RoundTableChange(createdRoundTable);\\r\\n\\r\\n        writeState(state);\\r\\n        return (code, createdRoundTable);\\r\\n    }\\r\\n\\r\\n    function proposeNewGuardians(\\r\\n            IRoundTableFactory _roundTableFactory,\\r\\n            address[] calldata _guardians)\\r\\n        external\\r\\n        onlySelf\\r\\n        returns (\\r\\n            StatusCodes.Status _status,\\r\\n            uint256 _proposalId)\\r\\n    {\\r\\n        SignerState memory state = readState(); //no need to write this state again, all state changes are external\\r\\n\\r\\n        IRoundTable rt = IRoundTable(state.roundTable);\\r\\n        require(address(rt) != address(0x0), \\\"No round table appointed yet\\\");\\r\\n        (StatusCodes.Status code, IRoundTable createdRoundTable) = _roundTableFactory\\r\\n            .produceRoundTable(\\r\\n                ISigner(address(this)),\\r\\n                _guardians);\\r\\n        require(code == StatusCodes.Status.Success, \\\"Factory unsuccessful\\\");\\r\\n        (StatusCodes.Status status, uint256 proposalId) = rt.proposeAndSupportRoundTableChange(address(createdRoundTable));\\r\\n        emit LogProposeNewGuardians(rt, createdRoundTable, proposalId);\\r\\n        return (status, proposalId);\\r\\n    }\\r\\n\\r\\n    function forward(address _to, bytes calldata _data)\\r\\n        external\\r\\n        onlySelf\\r\\n        returns (StatusCodes.Status status, bytes memory result)\\r\\n    {\\r\\n        require(_to != address(this), \\\"Cannot forward to self\\\");\\r\\n        SignerState memory state = readState();\\r\\n        require(\\r\\n            state.accessState == ISigner.AccessState.Active || _to != state.vault,\\r\\n            \\\"Inaccessible when frozen\\\");\\r\\n\\r\\n        (bool isSuccess, bytes memory callResult) = _to.call(_data);\\r\\n\\r\\n        emit Forward(\\\"Forward\\\", _to, callResult, isSuccess);\\r\\n        if (isSuccess)\\r\\n        {\\r\\n            return (StatusCodes.Status.Success, callResult);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            return (StatusCodes.Status.Failure, callResult);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function freeze(address _owner)\\r\\n        external\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        SignerState memory state = readState();\\r\\n\\r\\n        require(msg.sender == address(state.roundTable), \\\"Only round table\\\");\\r\\n        require(_owner == state.owner, \\\"Freeze nonce mismatch\\\");\\r\\n\\r\\n        if (state.accessState == ISigner.AccessState.Active)\\r\\n        {\\r\\n            state.accessState = ISigner.AccessState.Frozen;\\r\\n            emit Freeze(msg.sender, false);\\r\\n\\r\\n            pushFreezeDate();\\r\\n            writeState(state);\\r\\n            return (StatusCodes.Status.Success);\\r\\n        }\\r\\n        else if (state.accessState == ISigner.AccessState.Frozen)\\r\\n        {\\r\\n            emit Freeze(msg.sender, true);\\r\\n            return (StatusCodes.Status.AlreadyDone);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            revert(\\\"Invalid state\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function metaCall(\\r\\n            uint256 _callNonce,\\r\\n            uint256 _callGas,\\r\\n            uint256 _rewardAmount,\\r\\n            address payable _rewardRecipient,\\r\\n            address _rewardTokenAddress,\\r\\n            bytes calldata _data,\\r\\n            bytes calldata _signature)\\r\\n        external\\r\\n        payable\\r\\n        returns (StatusCodes.Status status, bytes memory result)\\r\\n    {\\r\\n        require(_callGas \\u003e 0, \\\"Insufficient vespine gas!\\\");\\r\\n        SignerState memory state = readState();\\r\\n\\r\\n        require(state.accessState != ISigner.AccessState.Uninitiated, \\\"Signer must be active\\\");\\r\\n        require(_callNonce == state.callNonce, \\\"Incorrect callNonce\\\");\\r\\n\\r\\n        // Validate the Signer\\r\\n        require(\\r\\n            getSignatureAddress(\\r\\n                metaCallHash(\\r\\n                    _callNonce,\\r\\n                    _callGas,\\r\\n                    _rewardAmount,\\r\\n                    _rewardTokenAddress,\\r\\n                    _data),\\r\\n                _signature) == state.owner,\\r\\n            \\\"Signature incorrect\\\");\\r\\n\\r\\n        // Vault ownership checks enforced by Vault, hence not included directly here\\r\\n\\r\\n        // Reward the relayer with funds the Signer controls.\\r\\n        uint256 rewardPay = payReward(state, _rewardTokenAddress, _rewardRecipient, _rewardAmount);\\r\\n\\r\\n        require(gasleft() \\u003e _callGas, \\\"Insufficient vespine gas!\\\");\\r\\n\\r\\n        // Execute the actual transaction\\r\\n        (bool success, bytes memory resultData) = address(this).call.value(msg.value).gas(_callGas)(_data);\\r\\n\\r\\n        // Ensure the callNonce increases\\r\\n        if (success) state = readState(); // necessary since a successful call may have altered the state.\\r\\n        state.callNonce = state.callNonce.add(1);\\r\\n\\r\\n        // Output business event\\r\\n        emit MetaCall(\\r\\n            \\\"Meta call\\\",\\r\\n            msg.sender,\\r\\n            _rewardRecipient,\\r\\n            _rewardTokenAddress,\\r\\n            rewardPay,\\r\\n            resultData,\\r\\n            success);\\r\\n\\r\\n        writeState(state);\\r\\n        return (\\r\\n            success ? StatusCodes.Status.Success : StatusCodes.Status.Failure,\\r\\n            resultData);\\r\\n    }\\r\\n\\r\\n    function metaCallHash(\\r\\n            uint256 _callNonce,\\r\\n            uint256 _callGas,\\r\\n            uint _rewardAmount,\\r\\n            address _rewardTokenAddress,\\r\\n            bytes memory _data)\\r\\n        public\\r\\n        view\\r\\n        returns(bytes32 _hash)\\r\\n    {\\r\\n        return keccak256(\\r\\n            abi.encodePacked(\\r\\n                address(this),\\r\\n                \\\"metaCall\\\",\\r\\n                _callNonce,\\r\\n                _callGas,\\r\\n                _rewardAmount,\\r\\n                _rewardTokenAddress,\\r\\n                _data));\\r\\n    }\\r\\n\\r\\n    function metaFreeze(\\r\\n            address _owner,\\r\\n            address payable _rewardRecipient,\\r\\n            address _rewardTokenAddress,\\r\\n            uint _rewardAmount,\\r\\n            bytes calldata _signature)\\r\\n        external\\r\\n        returns (StatusCodes.Status _statusCode)\\r\\n    {\\r\\n        SignerState memory state = readState();\\r\\n\\r\\n        //Validate the Signer\\r\\n        address signer = getSignatureAddress(\\r\\n            metaFreezeHash(\\r\\n                _owner,\\r\\n                _rewardAmount,\\r\\n                _rewardTokenAddress),\\r\\n            _signature);\\r\\n        require(signer == state.owner, \\\"Signature incorrect\\\");\\r\\n\\r\\n        //Validate the owner\\r\\n        require(_owner == state.owner, \\\"owner incorrect\\\");\\r\\n\\r\\n        if (state.accessState == ISigner.AccessState.Active)\\r\\n        {\\r\\n            // Reward the relayer with funds the Signer controls.\\r\\n            if (_rewardAmount \\u003e 0)\\r\\n                payReward(state, _rewardTokenAddress, _rewardRecipient, _rewardAmount);\\r\\n\\r\\n            state.accessState = ISigner.AccessState.Frozen;\\r\\n            emit MetaFreeze(msg.sender, _rewardRecipient, _rewardTokenAddress, _rewardAmount, signer);\\r\\n            emit Freeze(signer, false);\\r\\n\\r\\n            pushFreezeDate();\\r\\n            writeState(state);\\r\\n            return StatusCodes.Status.Success;\\r\\n        }\\r\\n        else if (state.accessState == ISigner.AccessState.Frozen)\\r\\n        {\\r\\n            emit MetaFreeze(msg.sender, _rewardRecipient, _rewardTokenAddress, 0, signer);\\r\\n            emit Freeze(signer, true);\\r\\n            return StatusCodes.Status.AlreadyDone;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            revert(\\\"Invalid state\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function metaFreezeHash(\\r\\n            address _owner,\\r\\n            uint256 _rewardAmount,\\r\\n            address _rewardTokenAddress)\\r\\n        public\\r\\n        view\\r\\n        returns(bytes32 hash)\\r\\n    {\\r\\n        return keccak256(\\r\\n            abi.encodePacked(\\r\\n                address(this),\\r\\n                \\\"metaFreeze\\\",\\r\\n                _owner,\\r\\n                _rewardAmount,\\r\\n                _rewardTokenAddress));\\r\\n    }\\r\\n\\r\\n    function getSignatureAddress(bytes32 _hash, bytes memory _signature)\\r\\n        internal\\r\\n        pure\\r\\n        returns (address signer)\\r\\n    {\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n        uint8 v;\\r\\n        if (_signature.length != 65)\\r\\n        {\\r\\n            return address(0);\\r\\n        }\\r\\n        \\r\\n        assembly\\r\\n        {\\r\\n            r := mload(add(_signature, 32))\\r\\n            s := mload(add(_signature, 64))\\r\\n            v := byte(0, mload(add(_signature, 96)))\\r\\n        }\\r\\n        if (v \\u003c 27)\\r\\n        {\\r\\n            v += 27;\\r\\n        }\\r\\n        if (v != 27 \\u0026\\u0026 v != 28)\\r\\n        {\\r\\n            return address(0);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            return ecrecover(keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _hash)), v, r, s);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function payReward(\\r\\n            SignerState memory _state,\\r\\n            address _rewardTokenAddress,\\r\\n            address payable _rewardRecipient,\\r\\n            uint256 _rewardAmount)\\r\\n        internal\\r\\n        returns (uint256)\\r\\n    {\\r\\n        if (_rewardAmount \\u003e 0)\\r\\n        {\\r\\n            require(_state.accessState == ISigner.AccessState.Active, \\\"Cannot pay relay rewards when frozen\\\");\\r\\n\\r\\n            uint256 octoPay = _rewardAmount.div(10);\\r\\n            uint rewardPay = _rewardAmount.sub(octoPay);\\r\\n\\r\\n            IVault vault = IVault(_state.vault);\\r\\n\\r\\n            // Pay the relayer\\r\\n            if (_rewardTokenAddress == address(0))\\r\\n                vault.sendWei(_rewardRecipient, rewardPay);\\r\\n            else\\r\\n                vault.sendErc20(_rewardTokenAddress, _rewardRecipient, rewardPay);\\r\\n\\r\\n            // Pay octobase\\r\\n            if (octoPay \\u003e 0)\\r\\n            {\\r\\n                if (_rewardTokenAddress == address(0))\\r\\n                    vault.sendWei(getOctobase(), octoPay);\\r\\n                else\\r\\n                    vault.sendErc20(_rewardTokenAddress, getOctobase(), octoPay);\\r\\n            }\\r\\n\\r\\n            return rewardPay;\\r\\n        }\\r\\n        else\\r\\n            return 0;\\r\\n    }\\r\\n\\r\\n    // upgrade proposal related methods\\r\\n\\r\\n    function proposeUpgrade(address _newImplementation)\\r\\n        external\\r\\n        onlySelf\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        SignerState memory state = readState();\\r\\n\\r\\n        setUpgradeProposal(\\r\\n            block.timestamp.add(7 days),\\r\\n            _newImplementation,\\r\\n            state.owner,\\r\\n            block.timestamp,\\r\\n            false);\\r\\n\\r\\n        emit ProposeUpgrade(7 days, _newImplementation);\\r\\n\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function executeUpgrade()\\r\\n        external\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        SignerState memory state = readState();\\r\\n\\r\\n        UpgradeProposal memory proposal = internalGetUpgradeProposal();\\r\\n        if (!proposal.isExecuted\\r\\n                \\u0026\\u0026 proposal.executionDate \\u003c= block.timestamp\\r\\n                \\u0026\\u0026 proposal.implementation != address(0x0)\\r\\n                \\u0026\\u0026 state.accessState == ISigner.AccessState.Active\\r\\n                \\u0026\\u0026 state.owner == proposal.owner)\\r\\n        {\\r\\n            proposal.isExecuted = true;\\r\\n            emit ExecuteUpgrade(msg.sender, proposal.implementation);\\r\\n            delegate = proposal.implementation;\\r\\n\\r\\n            internalSetUpgradeProposal(proposal);\\r\\n            return StatusCodes.Status.Success;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            revert(\\\"Proposal is invalid\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    event LogFreezeDate(uint256 freezeDate);\\r\\n    function checkFreezeInvalidation(\\r\\n            uint256 _upgradeProposalDate,\\r\\n            uint256 _upgradeExecutionDate)\\r\\n        external\\r\\n        //view\\r\\n        returns(bool _isValid)\\r\\n    {\\r\\n        uint256 freezeIndex = getFreezeIndex();\\r\\n        emit LogFreezeDate(freezeIndex);\\r\\n\\r\\n        for(uint256 i = freezeIndex; i \\u003e 0; i = i.sub(1))\\r\\n        {\\r\\n            uint256 freezeDate = getFreezeDate(i.sub(1));\\r\\n            emit LogFreezeDate(freezeDate);\\r\\n            if (_upgradeProposalDate \\u003c freezeDate \\u0026\\u0026 freezeDate \\u003c _upgradeExecutionDate)\\r\\n                return false;\\r\\n            if (_upgradeProposalDate \\u003e= freezeDate)\\r\\n                return true;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function octobaseType()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint16 typeId)\\r\\n    {\\r\\n        return 1;\\r\\n    }\\r\\n\\r\\n    function octobaseTypeVersion()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint32 typeVersion)\\r\\n    {\\r\\n        return 1;\\r\\n    }\\r\\n}\"},\"signerfactory.sol\":{\"content\":\"//Copyright Octobase.co 2019\\r\\npragma solidity ^0.5.1;\\r\\n\\r\\nimport \\\"./signer.sol\\\";\\r\\n\\r\\ncontract SignerFactory\\r\\n{\\r\\n    address public factoryOwner;\\r\\n    address public implementation;\\r\\n    address[] public signers;\\r\\n    function signersCount() external view returns (uint256 count) {\\r\\n        return signers.length;\\r\\n    }\\r\\n    mapping(address=\\u003ebool) public signerMappings;\\r\\n    mapping(address=\\u003ebool) public successors;\\r\\n\\r\\n    event ProduceSigner(address signer);\\r\\n\\r\\n    constructor(address _factoryOwner, address _implementation)\\r\\n        public\\r\\n    {\\r\\n        factoryOwner = _factoryOwner;\\r\\n        implementation = _implementation;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require (msg.sender == factoryOwner, \\\"Only the owner may call this method\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function changeOwner(address _newFactoryOwner)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        factoryOwner = _newFactoryOwner;\\r\\n    }\\r\\n\\r\\n    function produceSigner(address _owner)\\r\\n        external\\r\\n        returns (address signer)\\r\\n    {\\r\\n        SignerProxy proxy = new SignerProxy(implementation);\\r\\n        address payable signerAddress = address(proxy);\\r\\n        Signer wrapper = Signer(signerAddress);\\r\\n        wrapper.claim(_owner);\\r\\n        signers.push(signerAddress);\\r\\n        signerMappings[signerAddress] = true;\\r\\n        emit ProduceSigner(signerAddress);\\r\\n        return signerAddress;\\r\\n    }\\r\\n\\r\\n    function setSuccessor(address _successor, bool _isSuccessor)\\r\\n        external\\r\\n        onlyOwner\\r\\n        returns (StatusCodes.Status _status)\\r\\n    {\\r\\n        successors[_successor] = _isSuccessor;\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function OctobaseType()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint16 octobaseType)\\r\\n    {\\r\\n        return 3;\\r\\n    }\\r\\n\\r\\n    function OctobaseTypeVersion()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint32 octobaseTypeVersion)\\r\\n    {\\r\\n        return 1;\\r\\n    }\\r\\n}\"},\"smartwalletfactory.sol\":{\"content\":\"//Copyright Octobase.co 2019\\r\\npragma solidity ^0.5.1;\\r\\n\\r\\nimport \\\"./safemath.sol\\\";\\r\\nimport \\\"./statuscodes.sol\\\";\\r\\n\\r\\n\\r\\ninterface ISignerFactory {\\r\\n    function produceSigner(address _owner)\\r\\n        external\\r\\n        returns (address signer);\\r\\n}\\r\\n\\r\\ninterface IVaultFactory {\\r\\n    function produceVault(address _signer)\\r\\n        external\\r\\n        returns (address vault);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\ncontract SmartWalletFactory\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    //Events\\r\\n    event ProduceSmartWallet(address signer, address vault);\\r\\n\\r\\n    ISignerFactory public signerFactory;\\r\\n    IVaultFactory public vaultFactory;\\r\\n\\r\\n    address[] public signers;\\r\\n    address[] public vaults;\\r\\n    mapping(address =\\u003e bool) public signerMappings;\\r\\n    mapping(address =\\u003e bool) public vaultMappings;\\r\\n    uint public registryCount;\\r\\n\\r\\n    constructor(\\r\\n            ISignerFactory _signerFactory,\\r\\n            IVaultFactory _vaultFactory)\\r\\n        public\\r\\n    {\\r\\n        signerFactory = _signerFactory;\\r\\n        vaultFactory = _vaultFactory;\\r\\n    }\\r\\n\\r\\n    function produceSmartWallet(address _owner)\\r\\n        external\\r\\n        payable\\r\\n        returns (StatusCodes.Status status, address signer, address vault)\\r\\n    {\\r\\n        address createdSigner = signerFactory.produceSigner(_owner);\\r\\n        address createdVault = vaultFactory.produceVault(createdSigner);\\r\\n\\r\\n        if (msg.value \\u003e 0) {\\r\\n            (bool success,) = address(createdVault).call.value(msg.value)(\\\"\\\");\\r\\n            require(success, \\\"Seeding smart wallet failed\\\");\\r\\n        }\\r\\n\\r\\n        emit ProduceSmartWallet(createdSigner, createdVault);\\r\\n\\r\\n        signers.push(createdSigner);\\r\\n        vaults.push(createdVault);\\r\\n        registryCount = registryCount.add(1);\\r\\n        signerMappings[createdSigner] = true;\\r\\n        vaultMappings[createdVault] = true;\\r\\n\\r\\n        return (StatusCodes.Status.Success, createdSigner, createdVault);\\r\\n    }\\r\\n\\r\\n    function OctobaseType()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint16 octobaseType)\\r\\n    {\\r\\n        return 5;\\r\\n    }\\r\\n\\r\\n    function OctobaseTypeVersion()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint32 octobaseTypeVersion)\\r\\n    {\\r\\n        return 1;\\r\\n    }\\r\\n}\"},\"smartwalletwarehouse.sol\":{\"content\":\"//Copyright Octobase.co 2019\\r\\npragma solidity ^0.5.1;\\r\\n\\r\\nimport \\\"./safemath.sol\\\";\\r\\nimport \\\"./statuscodes.sol\\\";\\r\\n\\r\\ninterface ISmartWalletFactory {\\r\\n    function produceSmartWallet(address _owner)\\r\\n        external\\r\\n        payable\\r\\n        returns (StatusCodes.Status status, address signer, address vault);\\r\\n}\\r\\n\\r\\ninterface ISigner {\\r\\n    function init(address _owner,\\r\\n            address _vault,\\r\\n            uint _weiMaxLimit,\\r\\n            uint _weiLimitStartDateUtc,\\r\\n            uint _weiLimitWindowSeconds)\\r\\n        external\\r\\n        returns (StatusCodes.Status status);\\r\\n}\\r\\n\\r\\n\\r\\ncontract SmartWalletWarehouse\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    struct StockItem {\\r\\n        address signer;\\r\\n        address vault;\\r\\n    }\\r\\n    address public owner;\\r\\n    ISmartWalletFactory public smartWalletFactory;\\r\\n    StockItem[] public smartWalletStock;\\r\\n    uint public stockLevel;\\r\\n\\r\\n    event Stock(address indexed signer, address indexed vault);\\r\\n    event Claim(address indexed owner, address indexed signer, address indexed vault);\\r\\n\\r\\n    constructor(address _owner, ISmartWalletFactory _smartWalletFactory)\\r\\n        public\\r\\n    {\\r\\n        owner = _owner;\\r\\n        smartWalletFactory = _smartWalletFactory;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner()\\r\\n    {\\r\\n        require(msg.sender == owner, \\\"Only owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function stock()\\r\\n        external\\r\\n    {\\r\\n        (StatusCodes.Status produceStatus, address signer, address vault) = smartWalletFactory.produceSmartWallet(address(this));\\r\\n        require(produceStatus == StatusCodes.Status.Success, \\\"Smart wallet production failed\\\");\\r\\n        stockLevel = stockLevel.add(1);\\r\\n        if (stockLevel \\u003e smartWalletStock.length) {\\r\\n            smartWalletStock.push(StockItem(signer, vault));\\r\\n        } else {\\r\\n            StockItem storage stockItem = smartWalletStock[stockLevel-1];\\r\\n            stockItem.signer = signer;\\r\\n            stockItem.vault = vault;\\r\\n        }\\r\\n\\r\\n        emit Stock(signer, vault);\\r\\n    }\\r\\n\\r\\n    function claim(\\r\\n            address _owner,\\r\\n            uint256 _weiMaxLimit,\\r\\n            uint256 _weiLimitStartDateUtc,\\r\\n            uint256 _weiLimitWindowSeconds)\\r\\n        external\\r\\n        returns (address signer, address vault)\\r\\n    {\\r\\n        require(stockLevel \\u003e 0, \\\"No stock\\\");\\r\\n\\r\\n        //peek\\r\\n        StockItem storage stockItem = smartWalletStock[stockLevel-1];\\r\\n\\r\\n        //pop\\r\\n        stockLevel = stockLevel.sub(1);\\r\\n\\r\\n        //init\\r\\n        ISigner signerWrapper = ISigner(stockItem.signer);\\r\\n        StatusCodes.Status initStatus = signerWrapper.init(_owner, stockItem.vault, _weiMaxLimit, _weiLimitStartDateUtc, _weiLimitWindowSeconds);\\r\\n        require(initStatus == StatusCodes.Status.Success, \\\"Smart wallet init failed\\\");\\r\\n    \\r\\n        // //report\\r\\n        emit Claim(_owner, stockItem.signer, stockItem.vault);\\r\\n        return (stockItem.signer, stockItem.vault);\\r\\n    }\\r\\n\\r\\n    function packIndex()\\r\\n        external\\r\\n    {\\r\\n        smartWalletStock.length = stockLevel;\\r\\n    }\\r\\n\\r\\n    function OctobaseType()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint16 octobaseType)\\r\\n    {\\r\\n        return 6;\\r\\n    }\\r\\n\\r\\n    function OctobaseTypeVersion()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint32 octobaseTypeVersion)\\r\\n    {\\r\\n        return 1;\\r\\n    }\\r\\n}\"},\"statuscodes.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nlibrary StatusCodes {\\r\\n    enum Category {\\r\\n        Generic,\\r\\n        Permission,\\r\\n        Find,\\r\\n        Negotiation,\\r\\n        Availability,\\r\\n        Finance,\\r\\n\\r\\n        x60,\\r\\n        x70,\\r\\n        x80,\\r\\n        x90,\\r\\n\\r\\n        ApplicationSpecific,\\r\\n\\r\\n        xB0,\\r\\n        xC0,\\r\\n        xD0,\\r\\n\\r\\n        Cryptography,\\r\\n        OffChain\\r\\n    }\\r\\n\\r\\n    enum Reason {\\r\\n        Failure,\\r\\n        Success,\\r\\n\\r\\n        AwaitingOthers,\\r\\n        Accepted,\\r\\n        LowerLimit,\\r\\n        ActionRequested,\\r\\n        UpperLimit,\\r\\n\\r\\n        x06,\\r\\n        x07,\\r\\n\\r\\n        Inapplicable,\\r\\n\\r\\n        x09,\\r\\n        x0A,\\r\\n        x0B,\\r\\n        x0C,\\r\\n        x0D,\\r\\n        x0E,\\r\\n\\r\\n        Informational\\r\\n    }\\r\\n\\r\\n    enum Status {\\r\\n        Failure,\\r\\n        Success,\\r\\n        AwatingOthers,\\r\\n        Accepted,\\r\\n        LowerLimit,\\r\\n        RecieverActionRequested,\\r\\n        UpperLimit,\\r\\n        RESERVEDx07,\\r\\n        Inapplicable,\\r\\n        RESERVEDx09,\\r\\n        RESERVEDx0A,\\r\\n        RESERVEDx0B,\\r\\n        RESERVEDx0C,\\r\\n        RESERVEDx0D,\\r\\n        RESERVEDx0E,\\r\\n        Informational,\\r\\n\\r\\n        Disallowed_Stop,\\r\\n        Allowed_Go,\\r\\n        AwaitingOthersPermission,\\r\\n        PermissionRequested,\\r\\n        TooOpen_Insecure,\\r\\n        NeedsYourPermission_RequestForContinuation,\\r\\n        Revoked,\\r\\n        RESERVEDx17,\\r\\n        NotApplicatableToCurrentState,\\r\\n        RESERVEDx19,\\r\\n        RESERVEDx1A,\\r\\n        RESERVEDx1B,\\r\\n        RESERVEDx1C,\\r\\n        RESERVEDx1D,\\r\\n        RESERVEDx1E,\\r\\n        PermissionDetails_ControlConditions,\\r\\n\\r\\n        NotFound_Unequal_OutOfRange,\\r\\n        Found_Equal_InRange,\\r\\n        AwaitingMatch,\\r\\n        MatchRequestSent,\\r\\n        BelowRange_Underflow,\\r\\n        RequestForMatch,\\r\\n        Above_Range_Overflow,\\r\\n        RESERVEDx27,\\r\\n        Duplicate_Conflict_Collision,\\r\\n        RESERVEDx29,\\r\\n        RESERVEDx2A,\\r\\n        RESERVEDx2B,\\r\\n        RESERVEDx2C,\\r\\n        RESERVEDx2D,\\r\\n        RESERVEDx2E,\\r\\n        MatchingInformation,\\r\\n\\r\\n        SenderDisagrees_Nay,\\r\\n        SenderAgrees_Yea,\\r\\n        AwaitingRatification,\\r\\n        OfferSent_Voted,\\r\\n        QuorumNotReached,\\r\\n        ReceiversRatificationRequested,\\r\\n        OfferOrVoteLimitReached,\\r\\n        RESERVEDx37,\\r\\n        AlreadyVoted,\\r\\n        RESERVEDx39,\\r\\n        RESERVEDx3A,\\r\\n        RESERVEDx3B,\\r\\n        RESERVEDx3C,\\r\\n        RESERVEDx3D,\\r\\n        RESERVEDx3E,\\r\\n        NegotiationRules_ParticipationInformation,\\r\\n\\r\\n        Unavailable,\\r\\n        Available,\\r\\n        Paused,\\r\\n        Queued,\\r\\n        NotAvailableYet,\\r\\n        AwaitingYourAvailability,\\r\\n        Expired,\\r\\n        RESERVEDx47,\\r\\n        AlreadyDone,\\r\\n        RESERVEDx49,\\r\\n        RESERVEDx4A,\\r\\n        RESERVEDx4B,\\r\\n        RESERVEDx4C,\\r\\n        RESERVEDx4D,\\r\\n        RESERVEDx4E,\\r\\n        AvailabilityRules_Information,\\r\\n\\r\\n        TransferFailed,\\r\\n        TransferSuccessful,\\r\\n        AwaitingPaymentFromOthers,\\r\\n        Hold_Escrow,\\r\\n        InsufficientFunds,\\r\\n        FundsRequested,\\r\\n        TransferVolumeExceeded,\\r\\n        RESERVEDx57,\\r\\n        FundsNotRequired,\\r\\n        RESERVEDx59,\\r\\n        RESERVEDx5A,\\r\\n        RESERVEDx5B,\\r\\n        RESERVEDx5C,\\r\\n        RESERVEDx5D,\\r\\n        RESERVEDx5E,\\r\\n        FinancialInformation,\\r\\n\\r\\n        RESERVEDx60,\\r\\n        RESERVEDx61,\\r\\n        RESERVEDx62,\\r\\n        RESERVEDx63,\\r\\n        RESERVEDx64,\\r\\n        RESERVEDx65,\\r\\n        RESERVEDx66,\\r\\n        RESERVEDx67,\\r\\n        RESERVEDx68,\\r\\n        RESERVEDx69,\\r\\n        RESERVEDx6A,\\r\\n        RESERVEDx6B,\\r\\n        RESERVEDx6C,\\r\\n        RESERVEDx6D,\\r\\n        RESERVEDx6E,\\r\\n        RESERVEDx6F,\\r\\n\\r\\n        RESERVEDx70,\\r\\n        RESERVEDx71,\\r\\n        RESERVEDx72,\\r\\n        RESERVEDx73,\\r\\n        RESERVEDx74,\\r\\n        RESERVEDx75,\\r\\n        RESERVEDx76,\\r\\n        RESERVEDx77,\\r\\n        RESERVEDx78,\\r\\n        RESERVEDx79,\\r\\n        RESERVEDx7A,\\r\\n        RESERVEDx7B,\\r\\n        RESERVEDx7C,\\r\\n        RESERVEDx7D,\\r\\n        RESERVEDx7E,\\r\\n        RESERVEDx7F,\\r\\n\\r\\n        RESERVEDx80,\\r\\n        RESERVEDx81,\\r\\n        RESERVEDx82,\\r\\n        RESERVEDx83,\\r\\n        RESERVEDx84,\\r\\n        RESERVEDx85,\\r\\n        RESERVEDx86,\\r\\n        RESERVEDx87,\\r\\n        RESERVEDx88,\\r\\n        RESERVEDx89,\\r\\n        RESERVEDx8A,\\r\\n        RESERVEDx8B,\\r\\n        RESERVEDx8C,\\r\\n        RESERVEDx8D,\\r\\n        RESERVEDx8E,\\r\\n        RESERVEDx8F,\\r\\n\\r\\n        RESERVEDx90,\\r\\n        RESERVEDx91,\\r\\n        RESERVEDx92,\\r\\n        RESERVEDx93,\\r\\n        RESERVEDx94,\\r\\n        RESERVEDx95,\\r\\n        RESERVEDx96,\\r\\n        RESERVEDx97,\\r\\n        RESERVEDx98,\\r\\n        RESERVEDx99,\\r\\n        RESERVEDx9A,\\r\\n        RESERVEDx9B,\\r\\n        RESERVEDx9C,\\r\\n        RESERVEDx9D,\\r\\n        RESERVEDx9E,\\r\\n        RESERVEDx9F,\\r\\n\\r\\n        ApplicationSpecificFailure,\\r\\n        ApplicationSpecificSuccess,\\r\\n        ApplicationSpecificAwatingOthers,\\r\\n        ApplicationSpecificAccepted,\\r\\n        ApplicationSpecificLowerLimit,\\r\\n        ApplicationSpecificRecieverActionRequested,\\r\\n        ApplicationSpecificUpperLimit,\\r\\n        RESERVEDxA7,\\r\\n        ApplicationSpecific_Inapplicable,\\r\\n        RESERVEDxA9,\\r\\n        RESERVEDxAA,\\r\\n        RESERVEDxAB,\\r\\n        RESERVEDxAC,\\r\\n        RESERVEDxAD,\\r\\n        RESERVEDxAE,\\r\\n        ApplicationSpecificInformational,\\r\\n\\r\\n        RESERVEDxB0,\\r\\n        RESERVEDxB1,\\r\\n        RESERVEDxB2,\\r\\n        RESERVEDxB3,\\r\\n        RESERVEDxB4,\\r\\n        RESERVEDxB5,\\r\\n        RESERVEDxB6,\\r\\n        RESERVEDxB7,\\r\\n        RESERVEDxB8,\\r\\n        RESERVEDxB9,\\r\\n        RESERVEDxBA,\\r\\n        RESERVEDxBB,\\r\\n        RESERVEDxBC,\\r\\n        RESERVEDxBD,\\r\\n        RESERVEDxBE,\\r\\n        RESERVEDxBF,\\r\\n\\r\\n        RESERVEDxC0,\\r\\n        RESERVEDxC1,\\r\\n        RESERVEDxC2,\\r\\n        RESERVEDxC3,\\r\\n        RESERVEDxC4,\\r\\n        RESERVEDxC5,\\r\\n        RESERVEDxC6,\\r\\n        RESERVEDxC7,\\r\\n        RESERVEDxC8,\\r\\n        RESERVEDxC9,\\r\\n        RESERVEDxCA,\\r\\n        RESERVEDxCB,\\r\\n        RESERVEDxCC,\\r\\n        RESERVEDxCD,\\r\\n        RESERVEDxCE,\\r\\n        RESERVEDxCF,\\r\\n\\r\\n        RESERVEDxD0,\\r\\n        RESERVEDxD1,\\r\\n        RESERVEDxD2,\\r\\n        RESERVEDxD3,\\r\\n        RESERVEDxD4,\\r\\n        RESERVEDxD5,\\r\\n        RESERVEDxD6,\\r\\n        RESERVEDxD7,\\r\\n        RESERVEDxD8,\\r\\n        RESERVEDxD9,\\r\\n        RESERVEDxDA,\\r\\n        RESERVEDxDB,\\r\\n        RESERVEDxDC,\\r\\n        RESERVEDxDD,\\r\\n        RESERVEDxDE,\\r\\n        RESERVEDxDF,\\r\\n\\r\\n        DecryptFailure,\\r\\n        DecryptSuccess,\\r\\n        AwaitingOtherSignaturesOrKeys,\\r\\n        Signed,\\r\\n        Unsigned_Untrusted,\\r\\n        SignatureRequired,\\r\\n        KnownToBeCompromised,\\r\\n        RESERVEDxE7,\\r\\n        AlreadySigned_NotEncrypted,\\r\\n        RESERVEDxE9,\\r\\n        RESERVEDxEA,\\r\\n        RESERVEDxEB,\\r\\n        RESERVEDxEC,\\r\\n        RESERVEDxED,\\r\\n        RESERVEDxEE,\\r\\n        Cryptography_ID_ProofMetadata,\\r\\n\\r\\n\\r\\n        OffChainFailure,\\r\\n        OffChainSuccess,\\r\\n        AwatingOffChainProcess,\\r\\n        OffChainProcessStarted,\\r\\n        OffChainServiceUnreachable,\\r\\n        OffChainActionRequired,\\r\\n        OffChainExpiry_LimitReached,\\r\\n        RESERVEDxF7,\\r\\n        DuplicateOffChainRequest,\\r\\n        RESERVEDxF9,\\r\\n        RESERVEDxFA,\\r\\n        RESERVEDxFB,\\r\\n        RESERVEDxFC,\\r\\n        RESERVEDxFD,\\r\\n        RESERVEDxFE,\\r\\n        OffChainInformation\\r\\n    }\\r\\n}\"},\"storage.sol\":{\"content\":\"pragma solidity ^0.5.0;\\r\\n\\r\\nimport \\\"./interfaces.sol\\\";\\r\\n\\r\\ncontract Storage\\r\\n{\\r\\n    constructor() public {}\\r\\n\\r\\n    event LogSender(address _sender);\\r\\n\\r\\n    mapping(address =\\u003e mapping(bytes32 =\\u003e uint256)) public uint256s;\\r\\n    mapping(address =\\u003e mapping(bytes32 =\\u003e address)) public addresses;\\r\\n    mapping(address =\\u003e mapping(bytes32 =\\u003e string)) public strings;\\r\\n    mapping(address =\\u003e mapping(bytes32 =\\u003e bool)) public bools;\\r\\n    mapping(address =\\u003e mapping(bytes32 =\\u003e bytes1)) public bytes1s;\\r\\n\\r\\n    function getSender()\\r\\n        public\\r\\n        view\\r\\n        returns(address)\\r\\n    {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function setUint256(bytes32 _key, uint256 _value)\\r\\n        public\\r\\n    {\\r\\n        uint256s[msg.sender][_key] = _value;\\r\\n    }\\r\\n\\r\\n    function setAddress(bytes32 _key, address _value)\\r\\n        public\\r\\n    {\\r\\n        addresses[msg.sender][_key] = _value;\\r\\n    }\\r\\n\\r\\n    function setString(bytes32 _key, string memory _value)\\r\\n        public\\r\\n    {\\r\\n        strings[msg.sender][_key] = _value;\\r\\n    }\\r\\n\\r\\n    function setBool(bytes32 _key, bool _value)\\r\\n        public\\r\\n    {\\r\\n        bools[msg.sender][_key] = _value;\\r\\n        emit LogSender(msg.sender);\\r\\n    }\\r\\n\\r\\n    function setByte(bytes32 _key, byte _value)\\r\\n        public\\r\\n    {\\r\\n        bytes1s[msg.sender][_key] = _value;\\r\\n    }\\r\\n\\r\\n    function getUint256(bytes32 _key)\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        return uint256s[msg.sender][_key];\\r\\n    }\\r\\n\\r\\n    function getAddress(bytes32 _key)\\r\\n        public\\r\\n        view\\r\\n        returns(address)\\r\\n    {\\r\\n        return addresses[msg.sender][_key];\\r\\n    }\\r\\n\\r\\n    function getString(bytes32 _key)\\r\\n        public\\r\\n        view\\r\\n        returns(string memory)\\r\\n    {\\r\\n        return strings[msg.sender][_key];\\r\\n    }\\r\\n\\r\\n    function getBool(bytes32 _key)\\r\\n        public\\r\\n        view\\r\\n        returns(bool)\\r\\n    {\\r\\n        return bools[msg.sender][_key];\\r\\n    }\\r\\n\\r\\n    function getBytes1(bytes32 _key)\\r\\n        public\\r\\n        view\\r\\n        returns(bytes1)\\r\\n    {\\r\\n        return bytes1s[msg.sender][_key];\\r\\n    }\\r\\n\\r\\n    // Encoding functions\\r\\n    function enc(string memory _inputString)\\r\\n        public\\r\\n        pure\\r\\n        returns (bytes32 _encodedString)\\r\\n    {\\r\\n        return keccak256(abi.encode(_inputString));\\r\\n    }\\r\\n\\r\\n    function encMap(address _address, string memory _member)\\r\\n        public\\r\\n        pure\\r\\n        returns(bytes32)\\r\\n    {\\r\\n        return keccak256(abi.encode(_address, _member));\\r\\n    }\\r\\n\\r\\n    // Signer state\\r\\n    function setSignerState(\\r\\n            address parentFactory,\\r\\n            ISigner.AccessState accessState,\\r\\n            address owner,\\r\\n            address roundTable,\\r\\n            address vault,\\r\\n            uint256 callNonce)\\r\\n        public\\r\\n    {\\r\\n        setAddress(\\\"parentFactory\\\", parentFactory);\\r\\n        setUint256(\\\"accessState\\\", uint256(accessState));\\r\\n        setAddress(\\\"owner\\\", owner);\\r\\n        setAddress(\\\"roundTable\\\", roundTable);\\r\\n        setAddress(\\\"vault\\\", vault);\\r\\n        setUint256(\\\"callNonce\\\", callNonce);\\r\\n    }\\r\\n\\r\\n    function getSignerState()\\r\\n        public\\r\\n        view\\r\\n        returns(\\r\\n            address parentFactory,\\r\\n            ISigner.AccessState accessState,\\r\\n            address owner,\\r\\n            address roundTable,\\r\\n            address vault,\\r\\n            uint256 callNonce)\\r\\n    {\\r\\n        return (\\r\\n            getAddress(\\\"parentFactory\\\"),\\r\\n            ISigner.AccessState(getUint256(\\\"accessState\\\")),\\r\\n            getAddress(\\\"owner\\\"),\\r\\n            getAddress(\\\"roundTable\\\"),\\r\\n            getAddress(\\\"vault\\\"),\\r\\n            getUint256(\\\"callNonce\\\"));\\r\\n    }\\r\\n\\r\\n    // Vault related state\\r\\n    function getLimit(address _tokenAddress)\\r\\n        public\\r\\n        view\\r\\n        returns(\\r\\n            uint256 _max,\\r\\n            uint256 _spent,\\r\\n            uint256 _startDateUtc,\\r\\n            uint256 _windowSeconds,\\r\\n            uint256 _lastLimitWindow,\\r\\n            IVault.LimitState _state)\\r\\n    {\\r\\n        return (\\r\\n            getUint256(encMap(_tokenAddress,\\\"Limit.max\\\")),\\r\\n            getUint256(encMap(_tokenAddress,\\\"Limit.spent\\\")),\\r\\n            getUint256(encMap(_tokenAddress,\\\"Limit.startDateUtc\\\")),\\r\\n            getUint256(encMap(_tokenAddress,\\\"Limit.windowSeconds\\\")),\\r\\n            getUint256(encMap(_tokenAddress,\\\"Limit.lastLimitWindow\\\")),\\r\\n            IVault.LimitState(getUint256(encMap(_tokenAddress,\\\"Limit.state\\\"))));\\r\\n    }\\r\\n\\r\\n    function setLimit(\\r\\n            address _tokenAddress,\\r\\n            uint256 _max,\\r\\n            uint256 _spent,\\r\\n            uint256 _startDateUtc,\\r\\n            uint256 _windowSeconds,\\r\\n            uint256 _lastLimitWindow,\\r\\n            IVault.LimitState _state)\\r\\n        public\\r\\n    {\\r\\n        setUint256(encMap(_tokenAddress,\\\"Limit.max\\\"), _max);\\r\\n        setUint256(encMap(_tokenAddress,\\\"Limit.spent\\\"), _spent);\\r\\n        setUint256(encMap(_tokenAddress,\\\"Limit.startDateUtc\\\"), _startDateUtc);\\r\\n        setUint256(encMap(_tokenAddress,\\\"Limit.windowSeconds\\\"), _windowSeconds);\\r\\n        setUint256(encMap(_tokenAddress,\\\"Limit.lastLimitWindow\\\"), _lastLimitWindow);\\r\\n        setUint256(encMap(_tokenAddress,\\\"Limit.state\\\"), uint256(_state));\\r\\n    }\\r\\n\\r\\n    function getChangeLimitProposal(address _tokenAddress)\\r\\n        public\\r\\n        view\\r\\n        returns(\\r\\n            uint256 _executionDate,\\r\\n            uint256 _max,\\r\\n            uint256 _startDateUtc,\\r\\n            uint256 _windowSeconds)\\r\\n    {\\r\\n        return (\\r\\n            getUint256(encMap(_tokenAddress,\\\"ChangeLimitProposal.executionDate\\\")),\\r\\n            getUint256(encMap(_tokenAddress,\\\"ChangeLimitProposal.max\\\")),\\r\\n            getUint256(encMap(_tokenAddress,\\\"ChangeLimitProposal.startDateUtc\\\")),\\r\\n            getUint256(encMap(_tokenAddress,\\\"ChangeLimitProposal.windowSeconds\\\")));\\r\\n    }\\r\\n\\r\\n    function setChangeLimitProposal(\\r\\n            address _tokenAddress,\\r\\n            uint256 _executionDate,\\r\\n            uint256 _max,\\r\\n            uint256 _startDateUtc,\\r\\n            uint256 _windowSeconds)\\r\\n        public\\r\\n    {\\r\\n        setUint256(encMap(_tokenAddress,\\\"ChangeLimitProposal.executionDate\\\"), _executionDate);\\r\\n        setUint256(encMap(_tokenAddress,\\\"ChangeLimitProposal.max\\\"), _max);\\r\\n        setUint256(encMap(_tokenAddress,\\\"ChangeLimitProposal.startDateUtc\\\"), _startDateUtc);\\r\\n        setUint256(encMap(_tokenAddress,\\\"ChangeLimitProposal.windowSeconds\\\"), _windowSeconds);\\r\\n    }\\r\\n\\r\\n    function setUpgradeProposal(\\r\\n            uint256 _executionDate,\\r\\n            address _implementation,\\r\\n            uint256 _dateProposed,\\r\\n            address _owner,\\r\\n            bool _isExecuted)\\r\\n        public\\r\\n    {\\r\\n        setUint256(enc(\\\"UpgradeProposal.executionDate\\\"), _executionDate);\\r\\n        setAddress(enc(\\\"UpgradeProposal.implementation\\\"), _implementation);\\r\\n        setUint256(enc(\\\"UpgradeProposal.dateProposed\\\"), _dateProposed);\\r\\n        setAddress(enc(\\\"UpgradeProposal.owner\\\"), _owner);\\r\\n        setBool(enc(\\\"UpgradeProposal.isExecuted\\\"), _isExecuted);\\r\\n    }\\r\\n\\r\\n    function getUpgradeProposal()\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            uint256 _executionDate,\\r\\n            address _implementation,\\r\\n            uint256 _dateProposed,\\r\\n            address _owner,\\r\\n            bool _isExecuted)\\r\\n    {\\r\\n        _executionDate = getUint256(enc(\\\"UpgradeProposal.executionDate\\\"));\\r\\n        _implementation = getAddress(enc(\\\"UpgradeProposal.implementation\\\"));\\r\\n        _dateProposed = getUint256(enc(\\\"UpgradeProposal.dateProposed\\\"));\\r\\n        _owner = getAddress(enc(\\\"UpgradeProposal.owner\\\"));\\r\\n        _isExecuted = getBool(enc(\\\"UpgradeProposal.isExecuted\\\"));\\r\\n    }\\r\\n}\"},\"tester.sol\":{\"content\":\"//Copyright Octobase.co 2019\\r\\npragma solidity ^0.5.1;\\r\\nimport \\\"./statuscodes.sol\\\";\\r\\nimport \\\"./safemath.sol\\\";\\r\\n\\r\\ncontract Tester\\r\\n{\\r\\n    event Log(string message);\\r\\n\\r\\n    constructor() public { }\\r\\n\\r\\n    function()\\r\\n        external\\r\\n        payable\\r\\n    {\\r\\n        emit Log(\\\"fall back\\\");\\r\\n    }\\r\\n\\r\\n    function externalLog()\\r\\n        external\\r\\n    {\\r\\n        emit Log(\\\"external\\\");\\r\\n    }\\r\\n\\r\\n    function publicLog()\\r\\n        public\\r\\n    {\\r\\n        emit Log(\\\"public\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Reverter\\r\\n{\\r\\n    constructor() public { }\\r\\n\\r\\n    function()\\r\\n        external\\r\\n    {\\r\\n        revert(\\\"Always revert\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract NotSuccessfulRoundTableFactory\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    constructor() public { }\\r\\n\\r\\n    uint256 public count;\\r\\n\\r\\n    function produceRoundTable(address _ward, address[] calldata _guardians)\\r\\n        external\\r\\n        returns\\r\\n        (StatusCodes.Status status, address roundTable)\\r\\n    {\\r\\n        count = count.add(_guardians.length);\\r\\n        count = count.add(_guardians.length.div(2));\\r\\n        return (StatusCodes.Status.Failure, _ward);\\r\\n    }\\r\\n}\"},\"time.sol\":{\"content\":\"//Copyright Octobase.co 2019\\r\\npragma solidity ^0.5.1;\\r\\nimport \\\"./safemath.sol\\\";\\r\\n\\r\\ncontract TimeProvider\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n    bool public isLive;\\r\\n    uint256 public offset;\\r\\n\\r\\n    constructor()\\r\\n        public\\r\\n    { }\\r\\n\\r\\n    function travelForward(uint256 _seconds)\\r\\n        public\\r\\n    {\\r\\n        offset = offset.add(_seconds);\\r\\n    }\\r\\n\\r\\n    function travelBackwards(uint256 _seconds)\\r\\n        public\\r\\n    {\\r\\n        offset = offset.sub(_seconds);\\r\\n    }\\r\\n\\r\\n    function travelToNow()\\r\\n        public\\r\\n    {\\r\\n        offset = 0;\\r\\n    }\\r\\n\\r\\n    function blocktime()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return block.timestamp.add(offset);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract timeConsumer\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    TimeProvider public timeProvider;\\r\\n\\r\\n    constructor(bool _useChainTime)\\r\\n        public\\r\\n    {\\r\\n        if (_useChainTime)\\r\\n            timeProvider = TimeProvider(address(0));\\r\\n        else\\r\\n            timeProvider = new TimeProvider();\\r\\n    }\\r\\n\\r\\n    function blocktime()\\r\\n        public\\r\\n        view\\r\\n        returns(uint256)\\r\\n    {\\r\\n        if (address(timeProvider) == address(0))\\r\\n        {\\r\\n            return block.timestamp;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            return timeProvider.blocktime();\\r\\n        }\\r\\n    }\\r\\n}\"},\"vault.sol\":{\"content\":\"//Copyright Octobase.co 2019\\r\\npragma solidity ^0.5.1;\\r\\nimport \\\"./statuscodes.sol\\\";\\r\\nimport \\\"./safemath.sol\\\";\\r\\nimport \\\"./interfaces.sol\\\";\\r\\nimport \\\"./octomath.sol\\\";\\r\\nimport \\\"./storage.sol\\\";\\r\\n\\r\\ninterface Erc20Token\\r\\n{\\r\\n    function transfer(address _to, uint256 amount)\\r\\n        external\\r\\n        returns (bool success);\\r\\n}\\r\\n\\r\\ncontract VaultProxy\\r\\n{\\r\\n    address public delegate;\\r\\n    bool public alwaysDelegateCall = false;\\r\\n    address payable public signer;\\r\\n\\r\\n    event Receive(address _sender, uint256 _amount);\\r\\n\\r\\n    constructor (address _delegate, address payable _signer)\\r\\n        public\\r\\n    {\\r\\n        delegate = _delegate;\\r\\n        signer = _signer;\\r\\n    }\\r\\n\\r\\n    function ()\\r\\n        external\\r\\n        payable\\r\\n    {\\r\\n        if (alwaysDelegateCall || msg.value == 0 || msg.sender == signer)\\r\\n        {\\r\\n            assembly\\r\\n            {\\r\\n                let _target := sload(0)\\r\\n                calldatacopy(0x0, 0x0, calldatasize)\\r\\n                let result := delegatecall(gas, _target, 0x0, calldatasize, 0x0, 0)\\r\\n                returndatacopy(0x0, 0x0, returndatasize)\\r\\n                switch result case 0 {revert(0, 0)} default {return (0, returndatasize)}\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            emit Receive(msg.sender, msg.value);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract VaultBase { }\\r\\n\\r\\ncontract Vault is IVault\\r\\n{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // CG: These 3 state entries *must* be here *in this order* and *must* be *the only* state, because it proxy VaultProxy.\\r\\n    // CG: BEGIN STATE\\r\\n    address public delegate;\\r\\n    bool public alwaysDelegateCall;\\r\\n    address payable public signer;\\r\\n    // CG: END STATE\\r\\n\\r\\n    struct Limit\\r\\n    {\\r\\n        uint256 max;\\r\\n        uint256 spent;\\r\\n        uint256 startDateUtc;\\r\\n        uint256 windowSeconds;\\r\\n        uint256 lastLimitWindow;\\r\\n        LimitState state;\\r\\n    }\\r\\n\\r\\n    struct ChangeLimitProposal\\r\\n    {\\r\\n        uint256 executionDate;\\r\\n        uint256 max;\\r\\n        uint256 startDateUtc;\\r\\n        uint256 windowSeconds;\\r\\n    }\\r\\n\\r\\n    event InitVault(\\r\\n        uint256 max,\\r\\n        uint256 startDateUtc,\\r\\n        uint256 windowSeconds);\\r\\n    event InitErc20Limit(\\r\\n        address indexed tokenContract,\\r\\n        uint256 max,\\r\\n        uint256 startDateUtc,\\r\\n        uint256 windowSeconds);\\r\\n    event SendWei(address to, uint256 amount);\\r\\n    event SendErc20(\\r\\n        address tokenContract,\\r\\n        address to,\\r\\n        uint256 amount);\\r\\n    event ProposeWeiLimitChange(\\r\\n        uint256 proposalCooldownSeconds,\\r\\n        uint256 max,\\r\\n        uint256 startDateUtc,\\r\\n        uint256 windowSeconds);\\r\\n    event ProposeErc20LimitChange(\\r\\n        uint256 proposalCooldownSeconds,\\r\\n        address indexed tokenContract,\\r\\n        uint256 max,\\r\\n        uint256 startDateUtc,\\r\\n        uint256 windowSeconds);\\r\\n    event ProposeUpgrade(uint256 cooldown, address indexed implementation);\\r\\n    event ExecuteUpgrade(address executor, address indexed implementation);\\r\\n    event Receive(address _sender, uint256 _amount);\\r\\n\\r\\n    function getSigner()\\r\\n        public\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        return getStore().getAddress(\\\"signer\\\");\\r\\n    }\\r\\n\\r\\n    modifier onlySigner()\\r\\n    {\\r\\n        require(msg.sender == signer, \\\"Only signer may call this\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor() public { }\\r\\n\\r\\n    function()\\r\\n        external\\r\\n        payable\\r\\n    {\\r\\n        emit Receive(msg.sender, msg.value);\\r\\n    }\\r\\n\\r\\n    function getLimit(address _tokenAddress)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 max,\\r\\n            uint256 spent,\\r\\n            uint256 startDateUtc,\\r\\n            uint256 lastLimitWindow,\\r\\n            uint256 windowSeconds,\\r\\n            LimitState state)\\r\\n    {\\r\\n        Limit memory limit = privateGetLimit(_tokenAddress);\\r\\n        uint256 currentLimitWindow = getCurrentLimitWindow(limit);\\r\\n        return (\\r\\n            limit.max,\\r\\n            limit.lastLimitWindow \\u003c currentLimitWindow ? 0 : limit.spent,\\r\\n            limit.startDateUtc,\\r\\n            limit.windowSeconds,\\r\\n            currentLimitWindow,\\r\\n            limit.state);\\r\\n    }\\r\\n\\r\\n    function privateGetLimit(address _tokenAddress)\\r\\n        private\\r\\n        view\\r\\n        returns(Limit memory _result)\\r\\n    {\\r\\n        Storage store = getStore();\\r\\n        (\\r\\n            _result.max,\\r\\n            _result.spent,\\r\\n            _result.startDateUtc,\\r\\n            _result.windowSeconds,\\r\\n            _result.lastLimitWindow,\\r\\n            _result.state) = store.getLimit(_tokenAddress);\\r\\n    }\\r\\n\\r\\n    function privateSetLimit(address _tokenAddress, Limit memory _limit)\\r\\n        private\\r\\n    {\\r\\n        Storage store = getStore();\\r\\n        store.setLimit(\\r\\n            _tokenAddress,\\r\\n            _limit.max,\\r\\n            _limit.spent,\\r\\n            _limit.startDateUtc,\\r\\n            _limit.windowSeconds,\\r\\n            _limit.lastLimitWindow,\\r\\n            _limit.state);\\r\\n    }\\r\\n\\r\\n    function privateInitLimit(\\r\\n        address _tokenAddress,\\r\\n        uint256 _max,\\r\\n        uint256 _startDateUtc,\\r\\n        uint256 _windowSeconds)\\r\\n        private\\r\\n        returns (bool success)\\r\\n    {\\r\\n        Limit memory limit = privateGetLimit(_tokenAddress);\\r\\n\\r\\n        if (limit.state != LimitState.Uninitialized ||\\r\\n            _startDateUtc \\u003e block.timestamp ||\\r\\n            _windowSeconds == 0)\\r\\n        {\\r\\n            return (false);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            limit.max = _max;\\r\\n            limit.spent = 0;\\r\\n            limit.lastLimitWindow = 0;\\r\\n            limit.startDateUtc = _startDateUtc;\\r\\n            limit.windowSeconds = _windowSeconds;\\r\\n            limit.state = LimitState.NoProposal;\\r\\n            privateSetLimit(_tokenAddress, limit);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function initVault(\\r\\n            uint256 _weiMax,\\r\\n            uint256 _weiStartDateUtc,\\r\\n            uint256 _weiWindowSeconds)\\r\\n        external\\r\\n        onlySigner\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        bool success = privateInitLimit(address(0x0), _weiMax, _weiStartDateUtc, _weiWindowSeconds);\\r\\n        require(success, \\\"Limit init failed\\\");\\r\\n        emit InitVault(_weiMax, _weiStartDateUtc, _weiWindowSeconds);\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function initErc20Limit(\\r\\n            address _tokenAddress,\\r\\n            uint256 _max,\\r\\n            uint256 _startDateUtc,\\r\\n            uint256 _windowSeconds)\\r\\n        external\\r\\n        onlySigner\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        require(_tokenAddress != address(0x0), \\\"Cannot init Eth limt here\\\");\\r\\n        bool success = privateInitLimit(_tokenAddress, _max, _startDateUtc, _windowSeconds);\\r\\n        require(success, \\\"Limit init failed\\\");\\r\\n        emit InitErc20Limit(_tokenAddress, _max, _startDateUtc, _windowSeconds);\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function sendWei(address payable _to, uint256 _amount)\\r\\n        external\\r\\n        onlySigner\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        bool success = spendOnLimit(address(0x0), _amount);\\r\\n        require(success, \\\"Limit violated\\\");\\r\\n        (success,) = _to.call.value(_amount)(\\\"\\\");\\r\\n        require(success, \\\"sendWei unscucessful\\\");\\r\\n        emit SendWei(_to, _amount);\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function sendErc20(\\r\\n            address _tokenAddress,\\r\\n            address _to,\\r\\n            uint256 _amount)\\r\\n        external\\r\\n        onlySigner\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        require(_tokenAddress != address(0x0), \\\"Please use the sendWei function\\\");\\r\\n        bool success = spendOnLimit(_tokenAddress, _amount);\\r\\n        require(success, \\\"Limit violated\\\");\\r\\n        Erc20Token token = Erc20Token(_tokenAddress);\\r\\n        success = token.transfer(_to, _amount);\\r\\n        require(success, \\\"sendWei unscucessful\\\");\\r\\n        emit SendErc20(_tokenAddress, _to, _amount);\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function proposeWeiLimitChange(\\r\\n            uint256 _max,\\r\\n            uint256 _startDateUtc,\\r\\n            uint256 _windowSeconds)\\r\\n        external\\r\\n        onlySigner\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        bool success = proposeLimitChange(7 days, address(0x0), _max, _startDateUtc, _windowSeconds);\\r\\n        require(success, \\\"Limit change proposal failed\\\");\\r\\n        emit ProposeWeiLimitChange(7 days, _max, _startDateUtc, _windowSeconds);\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function proposeErc20LimitChange(\\r\\n            address _tokenAddress,\\r\\n            uint256 _max,\\r\\n            uint256 _startDateUtc,\\r\\n            uint256 _windowSeconds)\\r\\n        external\\r\\n        onlySigner\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        require(_tokenAddress != address(0x0), \\\"Cannot set wei limit with this method\\\");\\r\\n        bool success = proposeLimitChange(7 days, _tokenAddress, _max, _startDateUtc, _windowSeconds);\\r\\n        require(success, \\\"store.proposeLimitChange failed.\\\");\\r\\n        emit ProposeErc20LimitChange(7 days, _tokenAddress, _max, _startDateUtc, _windowSeconds);\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function proposeUpgrade(address _implementation)\\r\\n        external\\r\\n        onlySigner\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        ISigner signerWrapper = ISigner(signer);\\r\\n        (bool isActive, , address owner) = signerWrapper.getNonces();\\r\\n        require(isActive, \\\"Signer is not active\\\");\\r\\n        bool success = setUpgradeProposal(7 days, _implementation, owner);\\r\\n        require(success, \\\"Set upgrade proposal failed\\\");\\r\\n        emit ProposeUpgrade(7 days, _implementation);\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function setUpgradeProposal(\\r\\n            uint256 _cooldownPeriod,\\r\\n            address _implementation,\\r\\n            address _owner)\\r\\n        internal\\r\\n        returns (bool success)\\r\\n    {\\r\\n        UpgradeProposal memory proposal = internalGetUpgradeProposal();\\r\\n        proposal.executionDate = block.timestamp.add(_cooldownPeriod);\\r\\n        proposal.implementation = _implementation;\\r\\n        proposal.dateProposed = block.timestamp;\\r\\n        proposal.owner = _owner;\\r\\n        proposal.isExecuted = false;\\r\\n        internalSetUpgradeProposal(proposal);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function executeUpgrade()\\r\\n        external\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        (bool isActive, , address owner) = ISigner(signer).getNonces();\\r\\n        require(isActive, \\\"Signer is not active\\\");\\r\\n        UpgradeProposal memory proposal = internalGetUpgradeProposal();\\r\\n\\r\\n        if (!proposal.isExecuted\\r\\n                \\u0026\\u0026 proposal.executionDate \\u003c= block.timestamp\\r\\n                \\u0026\\u0026 proposal.implementation != address(0x0)\\r\\n                \\u0026\\u0026 owner == proposal.owner)\\r\\n        {\\r\\n            proposal.isExecuted = true;\\r\\n            delegate = proposal.implementation;\\r\\n            internalSetUpgradeProposal(proposal);\\r\\n            emit ExecuteUpgrade(msg.sender, proposal.implementation);\\r\\n            return StatusCodes.Status.Success;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            revert(\\\"Upgrade execution failed\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    struct UpgradeProposal\\r\\n    {\\r\\n        uint256 executionDate;\\r\\n        address implementation;\\r\\n        uint256 dateProposed;\\r\\n        address owner;\\r\\n        bool isExecuted;\\r\\n    }\\r\\n\\r\\n    function internalSetUpgradeProposal(UpgradeProposal memory _proposal)\\r\\n        internal\\r\\n    {\\r\\n        Storage store = getStore();\\r\\n        store.setUpgradeProposal(\\r\\n            _proposal.executionDate,\\r\\n            _proposal.implementation,\\r\\n            _proposal.dateProposed,\\r\\n            _proposal.owner,\\r\\n            _proposal.isExecuted);\\r\\n    }\\r\\n\\r\\n    function getUpgradeProposal()\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            uint256 _executionDate,\\r\\n            address _implementation,\\r\\n            uint256 _dateProposed,\\r\\n            address _owner,\\r\\n            bool _isExecuted)\\r\\n    {\\r\\n        UpgradeProposal memory result = internalGetUpgradeProposal();\\r\\n        return(\\r\\n            result.executionDate,\\r\\n            result.implementation,\\r\\n            result.dateProposed,\\r\\n            result.owner,\\r\\n            result.isExecuted\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function internalGetUpgradeProposal()\\r\\n        internal\\r\\n        view\\r\\n        returns (UpgradeProposal memory _result)\\r\\n    {\\r\\n        Storage store = getStore();\\r\\n        (\\r\\n            _result.executionDate,\\r\\n            _result.implementation,\\r\\n            _result.dateProposed,\\r\\n            _result.owner,\\r\\n            _result.isExecuted) = store.getUpgradeProposal();\\r\\n    }\\r\\n\\r\\n    function getProposal(address _tokenAddress)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 executionDate,\\r\\n            uint256 max,\\r\\n            uint256 startDateUtc,\\r\\n            uint256 windowSeconds)\\r\\n    {\\r\\n        ChangeLimitProposal memory proposal = privateGetChangeLimitProposal(_tokenAddress);\\r\\n        return (\\r\\n            proposal.executionDate,\\r\\n            proposal.max,\\r\\n            proposal.startDateUtc,\\r\\n            proposal.windowSeconds);\\r\\n    }\\r\\n\\r\\n    function privateGetChangeLimitProposal(address _tokenAddress)\\r\\n        private\\r\\n        view\\r\\n        returns(ChangeLimitProposal memory _result)\\r\\n    {\\r\\n        Storage store = getStore();\\r\\n        (\\r\\n            _result.executionDate,\\r\\n            _result.max,\\r\\n            _result.startDateUtc,\\r\\n            _result.windowSeconds) = store.getChangeLimitProposal(_tokenAddress);\\r\\n    }\\r\\n\\r\\n    function privateSetChangeLimitProposal(address _tokenAddress, ChangeLimitProposal memory _proposal)\\r\\n        private\\r\\n    {\\r\\n        Storage store = getStore();\\r\\n        store.setChangeLimitProposal(\\r\\n            _tokenAddress,\\r\\n            _proposal.executionDate,\\r\\n            _proposal.max,\\r\\n            _proposal.startDateUtc,\\r\\n            _proposal.windowSeconds);\\r\\n    }\\r\\n\\r\\n    function proposeLimitChange(\\r\\n            uint256 _proposalCooldownSeconds,\\r\\n            address _tokenAddress,\\r\\n            uint256 _maxLimit,\\r\\n            uint256 _startDateUtc,\\r\\n            uint256 _windowSeconds)\\r\\n        private\\r\\n        returns (bool success)\\r\\n    {\\r\\n        require(_startDateUtc \\u003c= block.timestamp, \\\"Cannot start in the future\\\");\\r\\n        require(_windowSeconds \\u003e 0, \\\"Cannot have a spending period of 0\\\");\\r\\n\\r\\n        Limit memory limit = privateGetLimit(_tokenAddress);\\r\\n        if (limit.state == LimitState.Uninitialized)\\r\\n        {\\r\\n            return false;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            ChangeLimitProposal memory proposal = privateGetChangeLimitProposal(_tokenAddress);\\r\\n            if (limit.state == LimitState.ProposalPending)\\r\\n            {\\r\\n                if (\\r\\n                    (proposal.executionDate \\u003c= block.timestamp)\\r\\n                    \\u0026\\u0026 (ISigner(signer).checkFreezeInvalidation(proposal.executionDate.sub(7 days), proposal.executionDate)))\\r\\n                {\\r\\n                    limit.max = proposal.max;\\r\\n                    limit.startDateUtc = proposal.startDateUtc;\\r\\n                    limit.windowSeconds = proposal.windowSeconds;\\r\\n                    limit.state = LimitState.NoProposal;\\r\\n                    limit.lastLimitWindow = getCurrentLimitWindow(limit);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            proposal.executionDate = block.timestamp.add(_proposalCooldownSeconds);\\r\\n            proposal.max = _maxLimit;\\r\\n            proposal.startDateUtc = _startDateUtc;\\r\\n            proposal.windowSeconds = _windowSeconds;\\r\\n\\r\\n            limit.state = LimitState.ProposalPending;\\r\\n\\r\\n            if (octomath.ceilDiv(_maxLimit.mul(limit.windowSeconds), _windowSeconds) \\u003c= limit.max)\\r\\n            {\\r\\n                limit.max = _maxLimit;\\r\\n                limit.startDateUtc = _startDateUtc;\\r\\n                limit.windowSeconds = _windowSeconds;\\r\\n                limit.state = LimitState.NoProposal;\\r\\n                limit.lastLimitWindow = getCurrentLimitWindow(limit);\\r\\n                proposal.executionDate = 0;\\r\\n                proposal.max = 0;\\r\\n                proposal.startDateUtc = 0;\\r\\n                proposal.windowSeconds = 0;\\r\\n            }\\r\\n\\r\\n            privateSetLimit(_tokenAddress, limit);\\r\\n            privateSetChangeLimitProposal(_tokenAddress, proposal);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function spendOnLimit(address _tokenAddress, uint256 _amount)\\r\\n        private\\r\\n        returns (bool success)\\r\\n    {\\r\\n        Limit memory limit = privateGetLimit(_tokenAddress);\\r\\n        uint256 currentLimitWindow = getCurrentLimitWindow(limit);\\r\\n\\r\\n        if (limit.state == LimitState.ProposalPending)\\r\\n        {\\r\\n            ChangeLimitProposal memory proposal = privateGetChangeLimitProposal(_tokenAddress);\\r\\n            if ((proposal.executionDate \\u003c= block.timestamp)\\r\\n               \\u0026\\u0026 (ISigner(signer).checkFreezeInvalidation(proposal.executionDate.sub(7 days), proposal.executionDate)))\\r\\n            {\\r\\n                limit.max = proposal.max;\\r\\n                limit.spent = 0;\\r\\n                limit.lastLimitWindow = 0;\\r\\n                limit.startDateUtc = proposal.startDateUtc;\\r\\n                limit.windowSeconds = proposal.windowSeconds;\\r\\n                limit.state = LimitState.NoProposal;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        require(\\r\\n            limit.state != LimitState.Uninitialized \\u0026\\u0026\\r\\n            limit.windowSeconds \\u003e 0 \\u0026\\u0026\\r\\n            limit.startDateUtc \\u003c= block.timestamp,\\r\\n            \\\"Invalid limit\\\");\\r\\n\\r\\n        if (limit.lastLimitWindow \\u003c currentLimitWindow)\\r\\n        {\\r\\n            limit.spent = 0;\\r\\n            limit.lastLimitWindow = currentLimitWindow;\\r\\n        }\\r\\n        require(limit.max \\u003e= limit.spent, \\\"Can\\u0027t spend more than limit\\\");\\r\\n        uint256 available = limit.max.sub(limit.spent);\\r\\n        require(available \\u003e= _amount, \\\"Can\\u0027t spend more than balance\\\");\\r\\n        limit.spent = limit.spent.add(_amount);\\r\\n        // the line below is true, but not necessary, leaving it here for clarity that the\\r\\n        // limit.lastLimitWindow = currentLimitWindow;\\r\\n        privateSetLimit(_tokenAddress, limit);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getCurrentLimitWindow(Limit memory _limit)\\r\\n        private\\r\\n        view\\r\\n        returns (uint _currentLimitWindow)\\r\\n    {\\r\\n        require(\\r\\n            block.timestamp \\u003e _limit.startDateUtc,\\r\\n            \\\"Cannot compute the limit window for a future dated start time\\\");\\r\\n        return block.timestamp.sub(_limit.startDateUtc).div(_limit.windowSeconds);\\r\\n    }\\r\\n\\r\\n    function getStore()\\r\\n        private\\r\\n        pure\\r\\n        returns (Storage store)\\r\\n    {\\r\\n        return Storage(0x1234567890AbcdeffedcBA98765432123454321F);\\r\\n    }\\r\\n\\r\\n    function octobaseType()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint16 typeId)\\r\\n    {\\r\\n        return 2;\\r\\n    }\\r\\n\\r\\n    function octobaseTypeVersion()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint32 typeVersion)\\r\\n    {\\r\\n        return 1;\\r\\n    }\\r\\n}\"},\"vaultfactory.sol\":{\"content\":\"//Copyright Octobase.co 2019\\r\\npragma solidity ^0.5.1;\\r\\n\\r\\nimport \\\"./vault.sol\\\";\\r\\n\\r\\ncontract VaultFactory {\\r\\n    address public factoryOwner;\\r\\n    address public implementation;\\r\\n    address[] public vaults;\\r\\n    function vaultsCount() external view returns (uint256 count) {\\r\\n        return vaults.length;\\r\\n    }\\r\\n    mapping(address=\\u003ebool) public vaultMappings;\\r\\n    mapping(address=\\u003ebool) public successors;\\r\\n\\r\\n    event ProduceVault(address vault);\\r\\n\\r\\n    constructor(address _factoryOwner, address _implementation)\\r\\n        public\\r\\n    {\\r\\n        factoryOwner = _factoryOwner;\\r\\n        implementation = _implementation;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require (msg.sender == factoryOwner, \\\"Only the owner may call this method\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function changeOwner(address _newFactoryOwner)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        factoryOwner = _newFactoryOwner;\\r\\n    }\\r\\n\\r\\n    function produceVault(address payable _signer)\\r\\n        external\\r\\n        returns (address vault)\\r\\n    {\\r\\n        VaultProxy proxy = new VaultProxy(implementation, _signer);\\r\\n        address proxyAddress = address(proxy);\\r\\n        vaults.push(proxyAddress);\\r\\n        vaultMappings[proxyAddress] = true;\\r\\n        emit ProduceVault(proxyAddress);\\r\\n        return (proxyAddress);\\r\\n    }\\r\\n\\r\\n    function setSuccessor(address _successor, bool _isSuccessor)\\r\\n        external\\r\\n        onlyOwner\\r\\n        returns (StatusCodes.Status status)\\r\\n    {\\r\\n        successors[_successor] = _isSuccessor;\\r\\n        return StatusCodes.Status.Success;\\r\\n    }\\r\\n\\r\\n    function OctobaseType()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint16 octobaseType)\\r\\n    {\\r\\n        return 4;\\r\\n    }\\r\\n\\r\\n    function OctobaseTypeVersion()\\r\\n        external\\r\\n        pure\\r\\n        returns (uint32 octobaseTypeVersion)\\r\\n    {\\r\\n        return 1;\\r\\n    }\\r\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getUpgradeProposal\",\"outputs\":[{\"name\":\"_executionDate\",\"type\":\"uint256\"},{\"name\":\"_implementation\",\"type\":\"address\"},{\"name\":\"_dateProposed\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_isExecuted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"uint256s\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"getLimit\",\"outputs\":[{\"name\":\"_max\",\"type\":\"uint256\"},{\"name\":\"_spent\",\"type\":\"uint256\"},{\"name\":\"_startDateUtc\",\"type\":\"uint256\"},{\"name\":\"_windowSeconds\",\"type\":\"uint256\"},{\"name\":\"_lastLimitWindow\",\"type\":\"uint256\"},{\"name\":\"_state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"strings\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getUint256\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getBytes1\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setUint256\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSender\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_member\",\"type\":\"string\"}],\"name\":\"encMap\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_executionDate\",\"type\":\"uint256\"},{\"name\":\"_implementation\",\"type\":\"address\"},{\"name\":\"_dateProposed\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_isExecuted\",\"type\":\"bool\"}],\"name\":\"setUpgradeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"bytes1\"}],\"name\":\"setByte\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"string\"}],\"name\":\"setString\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSignerState\",\"outputs\":[{\"name\":\"parentFactory\",\"type\":\"address\"},{\"name\":\"accessState\",\"type\":\"uint8\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"roundTable\",\"type\":\"address\"},{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"callNonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_inputString\",\"type\":\"string\"}],\"name\":\"enc\",\"outputs\":[{\"name\":\"_encodedString\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"getChangeLimitProposal\",\"outputs\":[{\"name\":\"_executionDate\",\"type\":\"uint256\"},{\"name\":\"_max\",\"type\":\"uint256\"},{\"name\":\"_startDateUtc\",\"type\":\"uint256\"},{\"name\":\"_windowSeconds\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getBool\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"addresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getString\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"bytes1s\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setBool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_max\",\"type\":\"uint256\"},{\"name\":\"_spent\",\"type\":\"uint256\"},{\"name\":\"_startDateUtc\",\"type\":\"uint256\"},{\"name\":\"_windowSeconds\",\"type\":\"uint256\"},{\"name\":\"_lastLimitWindow\",\"type\":\"uint256\"},{\"name\":\"_state\",\"type\":\"uint8\"}],\"name\":\"setLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_executionDate\",\"type\":\"uint256\"},{\"name\":\"_max\",\"type\":\"uint256\"},{\"name\":\"_startDateUtc\",\"type\":\"uint256\"},{\"name\":\"_windowSeconds\",\"type\":\"uint256\"}],\"name\":\"setChangeLimitProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"parentFactory\",\"type\":\"address\"},{\"name\":\"accessState\",\"type\":\"uint8\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"roundTable\",\"type\":\"address\"},{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"callNonce\",\"type\":\"uint256\"}],\"name\":\"setSignerState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"bools\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"LogSender\",\"type\":\"event\"}]","ContractName":"Storage","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://4e7f9fec87c361d3c4953103c83372bae71b860133b9fd347c50663861f084d2"}]}