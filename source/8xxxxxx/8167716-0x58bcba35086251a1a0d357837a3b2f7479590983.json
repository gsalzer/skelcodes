{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Do not send tokens to this contract directly!\r\n * \r\n * Allows EDG token holders to lend the Edgeless Casino tokens for the bankroll.\r\n * Users may pay in their tokens at any time, but they will only be used for the bankroll\r\n * begining from the next cycle. When the cycle is closed, they may\r\n * withdraw their stake of the bankroll. The casino may decide to limit the number of tokens\r\n * used for the bankroll.\r\n * Non-withdrawn tokens after cycle is finished is not automaticaly staked for the next round,\r\n * but they can be withdrawn by staker in any time.\r\n * author: Rytis Grincevicius <rytis@edgeless.io>\r\n * */\r\n\r\npragma solidity ^0.5.10;\r\n\r\ncontract Token {\r\n  function transfer(address receiver, uint amount) public returns(bool);\r\n  function transferFrom(address sender, address receiver, uint amount) public returns(bool);\r\n  function balanceOf(address holder) public view returns(uint);\r\n}\r\n\r\ncontract Casino {\r\n  mapping(address => bool) public authorized;\r\n}\r\n\r\ncontract Owned {\r\n  address public owner;\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function changeOwner(address newOwner) onlyOwner public {\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract SafeMath {\r\n\r\n\tfunction safeSub(uint a, uint b) pure internal returns(uint) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction safeAdd(uint a, uint b) pure internal returns(uint) {\r\n\t\tuint c = a + b;\r\n\t\tassert(c >= a && c >= b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction safeMul(uint a, uint b) pure internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract BankrollLending is Owned, SafeMath {\r\n  struct CycleData {\r\n      /** How musch stakers we got in this cycle */\r\n      uint numHolders;\r\n      /** Total staked amount */\r\n      uint initialStakes;\r\n      /** Amount received from bankroll (staked + 40% of bankroll surpluss) */\r\n      uint finalStakes;\r\n      /** Amount distributed to stakers for withdrawals. It decreases when user withdraws. */\r\n      uint totalStakes;\r\n      /** Last staker wallet index that had his share distributed */\r\n      uint lastUpdateIndex;\r\n      /** Amount of balance to return to bankroll. (If all stakers are ranked VIP then this amount should be 0) */\r\n      uint returnToBankroll;\r\n      /** Allows withdrawals when set to true */\r\n      bool sharesDistributed;\r\n      /** Stakers address to Staker struct */\r\n      mapping(address => Staker) addressToStaker;\r\n      /** staker address to available staker balance */\r\n      mapping(address => uint) addressToBalance;\r\n      /** Index to staker address */\r\n      address[] indexToAddress;\r\n  }\r\n  struct Staker {\r\n    /** Index of staker */\r\n    uint stakeIndex;\r\n    /** Staker rank */\r\n    StakingRank rank;\r\n    /** How much staked for this stake round */\r\n    uint staked;\r\n    /** How much staker payout was for stake round */\r\n    uint payout;\r\n  }\r\n  /** The set of lending contracts state phases **/\r\n  enum StakingPhases { deposit, bankroll }\r\n  /** The set of staking ranks **/\r\n  enum StakingRank { vip, gold, silver }\r\n  /** The number of the current cycle. Increases by 1 each round.**/\r\n  uint public cycle;\r\n  /** Cycle data */\r\n  mapping(uint => CycleData) public cycleToData;\r\n  /** Phase of current round */\r\n  StakingPhases public phase; \r\n  /** The address of the casino contract.**/\r\n  Casino public casino;\r\n  /** The Edgeless casino token contract **/\r\n  Token public token;\r\n  /** Previuos staking contract **/\r\n  address public predecessor;\r\n  /** Wallet to return bankroll surplus share of stakers who doesnt get all 100% */\r\n  address public returnBankrollTo;\r\n  /** The minimum staking amount required **/\r\n  uint public minStakingAmount;\r\n  /** The maximum number of addresses to process in one batch of stake updates **/\r\n  uint public maxUpdates; \r\n  /** Marks contract as paused. */\r\n  bool public paused;\r\n  /** Share of vip rank */\r\n  uint vipRankShare;\r\n  /** Share of gold rank */\r\n  uint goldRankShare;\r\n  /** Share of silver rank */\r\n  uint silverRankShare;\r\n  \r\n  /** notifies listeners about a stake update **/\r\n  event StakeUpdate(address holder, uint stake);\r\n\r\n  /**\r\n   * Constructor.\r\n   * @param tokenAddr the address of the edgeless token contract\r\n   *        casinoAddr the address of the edgeless casino contract\r\n   *        predecessorAdr the address of the previous bankroll lending contract.\r\n   * */\r\n  constructor(address tokenAddr, address casinoAddr, address predecessorAdr) public {\r\n    token = Token(tokenAddr);\r\n    casino = Casino(casinoAddr);\r\n    predecessor = predecessorAdr;\r\n    returnBankrollTo = casinoAddr;\r\n    maxUpdates = 5;\r\n    cycle = 90;\r\n    \r\n    vipRankShare = 1000;\r\n    goldRankShare = 500;\r\n    silverRankShare = 125;\r\n  }\r\n  \r\n  /**\r\n   * Changes share of specified ranks that would be assigned from bankroll surpluss.\r\n   * @param _rank   staking rank (0 - vip, 1 - gold, 2 - silver)\r\n   * @param _share  share 0 - 1000, 1000 is 100%.\r\n   */\r\n  function setStakingRankShare(StakingRank _rank, uint _share) public onlyOwner {\r\n    if (_rank == StakingRank.vip) {\r\n        vipRankShare = _share;\r\n    } else if (_rank == StakingRank.gold) {\r\n        goldRankShare = _share;\r\n    } else if (_rank == StakingRank.silver) {\r\n        silverRankShare = _share;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get share of staking rank.\r\n   * @param _rank staking rank  (0 - vip, 1 - gold, 2 - silver)\r\n   * @return share 0 - 1000, 1000 is 100%\r\n   */\r\n  function getStakingRankShare(StakingRank _rank) public view returns (uint) {\r\n   if (_rank == StakingRank.vip) {\r\n       return vipRankShare;\r\n    } else if (_rank == StakingRank.gold) {\r\n       return goldRankShare;\r\n    } else if (_rank == StakingRank.silver) {\r\n       return silverRankShare;\r\n    }\r\n    return 0;\r\n  }\r\n  \r\n  /**\r\n   * Allows authorized wallet to change stakers VIP ranking for current round.\r\n   * @param _address stakers wallet address\r\n   * @param _rank new vip rank of staker. (0 - vip, 1 - gold, 2 - silver)\r\n   */\r\n  function setStakerRank(address _address, StakingRank _rank) public onlyAuthorized {\r\n      Staker storage _staker = cycleToData[cycle].addressToStaker[_address];\r\n      require(_staker.staked > 0, \"Staker not staked.\");\r\n      _staker.rank = _rank;\r\n  }\r\n  \r\n  /**\r\n   * Allows owner to change returnBankrollTo address\r\n   * @param _address address to send tokens to\r\n   */\r\n  function setReturnBankrollTo(address _address) public onlyOwner {\r\n      returnBankrollTo = _address;\r\n  }\r\n  \r\n  /**\r\n   * Pause contract so it would not allow to make new deposits.\r\n   */\r\n  function setPaused() public onlyOwner onlyActive {\r\n      paused = true;\r\n  }\r\n  \r\n  /**\r\n   * Enable deposits.\r\n   */ \r\n  function setActive() public onlyOwner onlyPaused {\r\n      paused = false;\r\n  }\r\n  \r\n  /**\r\n   * Allows staker to withdraw staked amount + bankroll share of previous round.\r\n   * @param _receiver address withdraw tokens to\r\n   */\r\n  function withdraw(address _receiver) public {\r\n      makeWithdrawal(msg.sender, _receiver, safeSub(cycle, 1));\r\n  }\r\n  \r\n  /**\r\n   * Allows staker to withdraw staked amount + bankroll share of previous round.\r\n   * @param _cycle cycle index from which to withdraw.\r\n   * @param _receiver address withdraw tokens to\r\n   */\r\n  function withdraw(address _receiver, uint _cycle) public {\r\n      makeWithdrawal(msg.sender, _receiver, _cycle);\r\n  }\r\n  \r\n  /**\r\n   * Allow authorized wallet to withdraw stakers balance back to stakers wallet.\r\n   * @param _address    staker address\r\n   * @param _cycle      cycle index from which to withdraw.\r\n   */\r\n  function withdrawFor(address _address, uint _cycle) public onlyAuthorized {\r\n      makeWithdrawal(_address, _address, _cycle);\r\n  }\r\n  \r\n  /**\r\n   * Send collected stakes to casino contract and advance staking to bankroll phase.\r\n   */\r\n  function useAsBankroll() public onlyAuthorized depositPhase {\r\n      CycleData storage _cycle = cycleToData[cycle];\r\n      _cycle.initialStakes = _cycle.totalStakes;\r\n      _cycle.totalStakes = 0;\r\n      assert(token.transfer(address(casino), _cycle.initialStakes));\r\n      phase = StakingPhases.bankroll;\r\n  }\r\n  \r\n  /**\r\n   * Closes staking round with amount to distribute and creates new round with deposit phase.\r\n   * @param _finalStakes    Token amount (0 decimals) of amount to be distributed for stakers. (Staked amount + 40% casino surpluss)\r\n   */\r\n  function closeCycle(uint _finalStakes) public onlyAuthorized bankrollPhase {\r\n      CycleData storage _cycle = cycleToData[cycle];\r\n      _cycle.finalStakes = _finalStakes;\r\n      cycle = safeAdd(cycle, 1);\r\n      phase = StakingPhases.deposit;\r\n  }\r\n  \r\n  /**\r\n   * Distributes user shares for previous round.\r\n   */\r\n  function updateUserShares() public onlyAuthorized {\r\n      _updateUserShares(cycle - 1);\r\n  }\r\n\r\n  /**\r\n   * Distributes user shares for selected finished round.\r\n   * @param _cycleIndex Index of cycle to update shares.\r\n   */\r\n  function updateUserShares(uint _cycleIndex) public onlyAuthorized {\r\n      _updateUserShares(_cycleIndex);\r\n  }\r\n  \r\n  /**\r\n   * Allows to deposit tokens to staking. Wallet must approve staking contract to transfer its tokens.\r\n   * Transfaction must be signed by authorized wallet to confirm rank and allowance.\r\n   */\r\n  function deposit(uint _value, StakingRank _rank, uint _allowedMax, uint8 v, bytes32 r, bytes32 s) public depositPhase onlyActive {\r\n      require(verifySignature(msg.sender, _allowedMax, _rank, v, r, s));\r\n      makeDeposit(msg.sender, _value, _rank, _allowedMax);\r\n  }\r\n  \r\n  /**\r\n   * Allow authorized wallet to deposit on wallet behalft. Wallet must approve staking contract to transfer its tokens.\r\n   */\r\n  function depositFor(address _address, uint _value, StakingRank _rank, uint _allowedMax) public depositPhase onlyActive onlyAuthorized {\r\n      makeDeposit(_address, _value, _rank, _allowedMax);\r\n  }\r\n  \r\n  /**\r\n   * Holders of current staking round.\r\n   */\r\n  function numHolders() public view returns (uint) {\r\n      return cycleToData[cycle].numHolders;\r\n  }\r\n  \r\n  /**\r\n   * Get holder address by index.\r\n   * @param _index staker index in array.\r\n   */ \r\n  function stakeholders(uint _index) public view returns (address) {\r\n      return stakeholders(cycle, _index);\r\n  }\r\n  \r\n  /**\r\n   * Get holder balance by address.\r\n   * @param _address staker address.\r\n   */ \r\n  function stakes(address _address) public view returns (uint) {\r\n      return stakes(cycle, _address);\r\n  }\r\n  \r\n  /**\r\n   * Get holder information by address.\r\n   * @param _address staker address.\r\n   */ \r\n  function staker(address _address) public view returns (uint stakeIndex, StakingRank rank, uint staked, uint payout) {\r\n      return staker(cycle, _address);\r\n  }\r\n  \r\n  /**\r\n   * Returns token amount staked to contract\r\n   */\r\n  function totalStakes() public view returns (uint) {\r\n      return totalStakes(cycle);\r\n  }\r\n  \r\n  /**\r\n   * Returns token amount of initial stakes\r\n   */\r\n  function initialStakes() public view returns (uint) {\r\n      return initialStakes(cycle);\r\n  }\r\n  \r\n   /**\r\n   * Get holder address by cycle and index.\r\n   * @param _cycle cycle to look\r\n   * @param _index staker index in array.\r\n   */ \r\n  function stakeholders(uint _cycle, uint _index) public view returns (address) {\r\n      return cycleToData[_cycle].indexToAddress[_index];\r\n  }\r\n  \r\n  /**\r\n   * Returns available EDG balance of staker.\r\n   * @param _cycle cycle index to look\r\n   * @param _address staker address\r\n   */\r\n  function stakes(uint _cycle, address _address) public view returns (uint) {\r\n      return cycleToData[_cycle].addressToBalance[_address];\r\n  }\r\n\r\n  /**\r\n   * Returns info about staker in round. \r\n   * @param _cycle cycle index to look\r\n   * @param _address staker address\r\n   */\r\n  function staker(uint _cycle, address _address) public view returns (uint stakeIndex, StakingRank rank, uint staked, uint payout ) {\r\n      Staker memory _s = cycleToData[_cycle].addressToStaker[_address];\r\n      return (_s.stakeIndex, _s.rank, _s.staked, _s.payout);\r\n  }\r\n  \r\n  /**\r\n   * Returns token amount staked to contract\r\n   * @param _cycle cycle index to look\r\n   */\r\n  function totalStakes(uint _cycle) public view returns (uint) {\r\n      return cycleToData[_cycle].totalStakes;\r\n  }\r\n  \r\n  /**\r\n   * Returns token amount of initial stakes\r\n   * @param _cycle cycle index to look\r\n   */\r\n  function initialStakes(uint _cycle) public view returns (uint) {\r\n      return cycleToData[_cycle].initialStakes;\r\n  }\r\n  \r\n  /**\r\n   * Returns token amount of final stakes\r\n   * @param _cycle cycle index to look\r\n   */\r\n  function finalStakes(uint _cycle) public view returns (uint) {\r\n      return cycleToData[_cycle].finalStakes;\r\n  }\r\n\r\n  /**\r\n   * Sets the casino contract address.\r\n   * @param casinoAddr the new casino contract address\r\n   * */\r\n  function setCasinoAddress(address casinoAddr) public onlyOwner {\r\n    casino = Casino(casinoAddr);\r\n  }\r\n  \r\n  /**\r\n   * Sets the maximum number of user stakes to update at once\r\n   * @param newMax the new maximum\r\n   * */\r\n  function setMaxUpdates(uint newMax) public onlyAuthorized {\r\n    maxUpdates = newMax;\r\n  }\r\n  \r\n  /**\r\n   * Sets the minimum amount of user stakes\r\n   * @param amount the new minimum\r\n   * */\r\n  function setMinStakingAmount(uint amount) public onlyAuthorized {\r\n    minStakingAmount = amount;\r\n  }\r\n\r\n  /**\r\n  * Closes the contract in state of emergency or on contract update.\r\n  * Transfers all tokens held by the contract to the owner before doing so.\r\n  **/\r\n  function kill() public onlyOwner {\r\n    assert(token.transfer(owner, tokenBalance()));\r\n    selfdestruct(address(uint160(owner)));\r\n  }\r\n\r\n  /**\r\n  * @return the current token balance of the contract.\r\n  * */\r\n  function tokenBalance() public view returns(uint) {\r\n    return token.balanceOf(address(this));\r\n  }\r\n  \r\n  /**\r\n   * Withdrawal logic. Withdraws all balance from stakers staking contract and transfers to his deposit wallet.\r\n   * @param _address    staker address for which to withdraw\r\n   * @param _receiver   address withdraw to.\r\n   * @param _cycle      cycle index from which to withdraw.\r\n   */\r\n  function makeWithdrawal(address _address, address _receiver, uint _cycle) internal {\r\n      require(_cycle < cycle, \"Withdrawal possible only for finished rounds.\");\r\n      CycleData storage _cycleData = cycleToData[_cycle];\r\n      require(_cycleData.sharesDistributed == true, \"All user shares must be distributed to stakeholders first.\");\r\n      uint _balance = _cycleData.addressToBalance[_address];\r\n      require(_balance > 0, \"Staker doesn't have balance.\");\r\n      _cycleData.addressToBalance[_address] = 0;\r\n      _cycleData.totalStakes = safeSub(_cycleData.totalStakes, _balance);\r\n      emit StakeUpdate(_address, 0);\r\n      assert(token.transfer(_receiver, _balance));\r\n  }\r\n  \r\n  \r\n  /**\r\n   * Calculates and distributes shares for stakers.\r\n   * When all staker shares distributed it sets cycleToData[cycle].sharesDistributed to true and unlocks withdrawals.\r\n   * @param _cycleIndex round index for which calculations should be made.\r\n   */\r\n  function _updateUserShares(uint _cycleIndex) internal {\r\n      require(cycle > 0 && cycle > _cycleIndex, \"You can't distribute shares of previous cycle when there isn't any.\");\r\n      CycleData storage _cycle = cycleToData[_cycleIndex];\r\n      require(_cycle.sharesDistributed == false, \"Shares already distributed.\");\r\n      uint limit = safeAdd(_cycle.lastUpdateIndex, maxUpdates);\r\n      if (limit >= _cycle.numHolders) {\r\n          limit = _cycle.numHolders;\r\n      }\r\n      address _address;\r\n      uint _payout;\r\n      uint _totalStakes = _cycle.totalStakes;\r\n      for (uint i = _cycle.lastUpdateIndex; i < limit; i++) {\r\n          _address = _cycle.indexToAddress[i];\r\n          Staker storage _staker = _cycle.addressToStaker[_address];\r\n          _payout = computeFinalStake(_staker.staked, _staker.rank, _cycle);\r\n          _staker.payout = _payout;\r\n          _cycle.addressToBalance[_address] = _payout;\r\n          _totalStakes = safeAdd(_totalStakes, _payout);\r\n          emit StakeUpdate(_address, _payout);\r\n      }\r\n      _cycle.totalStakes = _totalStakes;\r\n      _cycle.lastUpdateIndex = limit;\r\n      if (limit >= _cycle.numHolders) {\r\n          if (_cycle.finalStakes > _cycle.totalStakes) {\r\n            _cycle.returnToBankroll = safeSub(_cycle.finalStakes, _cycle.totalStakes);\r\n            if (_cycle.returnToBankroll > 0) {\r\n                assert(token.transfer(returnBankrollTo, _cycle.returnToBankroll));\r\n            }\r\n          }\r\n          _cycle.sharesDistributed = true;\r\n      }\r\n  }\r\n  \r\n   /**\r\n    * Calculates stakers profit / loss.\r\n    * @param _initialStake how much holder initialy staked for the round\r\n    * @param _vipRank vip rank of the holder\r\n    * @param _cycleData data of the cycle\r\n    */\r\n   function computeFinalStake(uint _initialStake, StakingRank _vipRank, CycleData storage _cycleData) internal view returns(uint) {\r\n       if (_cycleData.finalStakes >= _cycleData.initialStakes) {\r\n        uint profit = ((_initialStake * _cycleData.finalStakes / _cycleData.initialStakes) - _initialStake) * getStakingRankShare(_vipRank) / 1000;\r\n        return _initialStake + profit;\r\n      } else {\r\n        uint loss = (_initialStake - (_initialStake * _cycleData.finalStakes / _cycleData.initialStakes));\r\n        return _initialStake - loss;\r\n      }\r\n    }\r\n    \r\n   /**\r\n    * Deposit logic.\r\n    * @param _address holder address\r\n    * @param _value how much to deposit\r\n    * @param _rank vip rank to set for holder\r\n    * @param _allowedMax what is maximum total deposit for the holder\r\n    */\r\n   function makeDeposit(address _address, uint _value, StakingRank _rank, uint _allowedMax) internal {\r\n       require(_value > 0);\r\n       CycleData storage _cycle = cycleToData[cycle];\r\n       uint _balance = _cycle.addressToBalance[_address];\r\n       uint newStake = safeAdd(_balance, _value);\r\n       require(newStake >= minStakingAmount);\r\n       if(_allowedMax > 0){ //if allowedMax > 0 the caller is the user himself\r\n           require(newStake <= _allowedMax);\r\n           assert(token.transferFrom(_address, address(this), _value));\r\n       }\r\n       Staker storage _staker = _cycle.addressToStaker[_address];\r\n       \r\n       if (_cycle.addressToBalance[_address] == 0) {\r\n           uint _numHolders = _cycle.indexToAddress.push(_address);\r\n           _cycle.numHolders = _numHolders;\r\n           _staker.stakeIndex = safeSub(_numHolders, 1);\r\n       }\r\n       \r\n       _cycle.addressToBalance[_address] = newStake;\r\n       _staker.staked = newStake;\r\n       _staker.rank = _rank;\r\n       \r\n       _cycle.totalStakes = safeAdd(_cycle.totalStakes, _value);\r\n       \r\n       emit StakeUpdate(_address, newStake);\r\n   }\r\n\r\n  /**\r\n   * verifies if the withdrawal request was signed by an authorized wallet\r\n   * @param to      the receiver address\r\n   *        value   the number of tokens\r\n   *        rank    the vip rank\r\n   *        v, r, s the signature of an authorized wallet\r\n   * */\r\n  function verifySignature(address to, uint value, StakingRank rank, uint8 v, bytes32 r, bytes32 s) internal view returns(bool) {\r\n    address signer = ecrecover(keccak256(abi.encodePacked(to, value, rank, cycle)), v, r, s);\r\n    return casino.authorized(signer);\r\n  }\r\n  \r\n  //check if the sender is an authorized casino wallet\r\n  modifier onlyAuthorized {\r\n    require(casino.authorized(msg.sender), \"Only authorized wallet can request this method.\");\r\n    _;\r\n  }\r\n\r\n  modifier depositPhase {\r\n    require(phase == StakingPhases.deposit, \"Method can be run only in deposit phase.\");\r\n    _;\r\n  }\r\n\r\n  modifier bankrollPhase {\r\n    require(phase == StakingPhases.bankroll, \"Method can be run only in bankroll phase.\");\r\n    _;\r\n  }\r\n  \r\n  modifier onlyActive() {\r\n    require(paused == false, \"Contract is paused.\");\r\n    _;\r\n  }\r\n  \r\n  modifier onlyPaused() {\r\n    require(paused == true, \"Contract is not paused.\");\r\n    _;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"initialStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"stakeholders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minStakingAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateUserShares\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_rank\",\"type\":\"uint8\"}],\"name\":\"setStakerRank\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_finalStakes\",\"type\":\"uint256\"}],\"name\":\"closeCycle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"totalStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cycle\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"stakeholders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_rank\",\"type\":\"uint8\"},{\"name\":\"_allowedMax\",\"type\":\"uint256\"}],\"name\":\"depositFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cycle\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"staker\",\"outputs\":[{\"name\":\"stakeIndex\",\"type\":\"uint256\"},{\"name\":\"rank\",\"type\":\"uint8\"},{\"name\":\"staked\",\"type\":\"uint256\"},{\"name\":\"payout\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMinStakingAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cycle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"finalStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setActive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxUpdates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"staker\",\"outputs\":[{\"name\":\"stakeIndex\",\"type\":\"uint256\"},{\"name\":\"rank\",\"type\":\"uint8\"},{\"name\":\"staked\",\"type\":\"uint256\"},{\"name\":\"payout\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"setMaxUpdates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnBankrollTo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setReturnBankrollTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"casino\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cycle\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rank\",\"type\":\"uint8\"},{\"name\":\"_share\",\"type\":\"uint256\"}],\"name\":\"setStakingRankShare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"predecessor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cycleToData\",\"outputs\":[{\"name\":\"numHolders\",\"type\":\"uint256\"},{\"name\":\"initialStakes\",\"type\":\"uint256\"},{\"name\":\"finalStakes\",\"type\":\"uint256\"},{\"name\":\"totalStakes\",\"type\":\"uint256\"},{\"name\":\"lastUpdateIndex\",\"type\":\"uint256\"},{\"name\":\"returnToBankroll\",\"type\":\"uint256\"},{\"name\":\"sharesDistributed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"withdrawFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_rank\",\"type\":\"uint8\"},{\"name\":\"_allowedMax\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cycleIndex\",\"type\":\"uint256\"}],\"name\":\"updateUserShares\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"initialStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"useAsBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rank\",\"type\":\"uint8\"}],\"name\":\"getStakingRankShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"casinoAddr\",\"type\":\"address\"}],\"name\":\"setCasinoAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"casinoAddr\",\"type\":\"address\"},{\"name\":\"predecessorAdr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"StakeUpdate\",\"type\":\"event\"}]","ContractName":"BankrollLending","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000801f67ec764459f9ec3cb9d6b998547f2de6ed3f000000000000000000000000764280456ae178591e037e36b01f69a52d9327a7000000000000000000000000f7a542a7f61d6479e8c63b8c43943df32262d71d","Library":"","SwarmSource":"bzzr://07f0b34e3238ab7b02c84a46d20c6189d2c12dcf2fe2ee7c582f51fceebefd85"}]}