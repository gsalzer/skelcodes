{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/IERC20.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\ninterface IERC20 {\r\n    /*\r\n     * Metadata\r\n     */\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Only used on BASE token\r\n     */\r\n    function transferFromWithFee(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Only used on BASE token\r\n     */\r\n    function transferWithFee(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interfaces/IUniswapExchange.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\ninterface IUniswapExchange {\r\n    // Address of ERC20 token sold on this exchange\r\n    function tokenAddress() external view returns (address token);\r\n    // Address of Uniswap Factory\r\n    function factoryAddress() external view returns (address factory);\r\n    // Provide Liquidity\r\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\r\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\r\n    // Get Prices\r\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\r\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\r\n    // Trade ETH to ERC20\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\r\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\r\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\r\n    // Trade ERC20 to ETH\r\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\r\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\r\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\r\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to ERC20\r\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\r\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\r\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\r\n    // Trade ERC20 to Custom Pool\r\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\r\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\r\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\r\n    // ERC20 comaptibility for liquidity tokens\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    // Never use\r\n    function setup(address token_addr) external;\r\n}\r\n\r\n// File: contracts/utils/IsContract.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\nlibrary IsContract {\r\n    function isContract(address _addr) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        /* solium-disable-next-line */\r\n        assembly { codehash := extcodehash(_addr) }\r\n        return codehash != bytes32(0) && codehash != bytes32(0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IDefswapExchange.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\ninterface IDefswapExchange {\r\n    function base() external view returns (IERC20);\r\n    function token() external view returns (IERC20);\r\n    function addLiquidity(uint256 _tokens, uint256 _maxBase) external returns (uint256);\r\n    function removeLiquidity(uint256 _amount, uint256 _minBase, uint256 _minTokens) external returns (uint256, uint256);\r\n    function ethToTokenSwapInput(uint256 _minTokens) external payable returns (uint256);\r\n    function baseToTokenSwapInput(uint256 _amount, uint256 _minTokens) external returns (uint256);\r\n    function baseToTokenTransferInput(uint256 _amount, uint256 _minTokens, address _recipient) external returns (uint256);\r\n    function tokenToEthSwapInput(uint256 _amount, uint256 _minEth) external returns (uint256);\r\n    function tokenToEthTransferInput(uint256 _amount, uint256 _minEth, address _recipient) external returns (uint256);\r\n    function tokenToEthExchangeTransferInput(uint256 _amount, uint256 _minTokens, address _recipient, address _exchangeAddr) external returns (uint256);\r\n    function tokenToBaseSwapInput(uint256 _amount, uint256 _minBase) external returns (uint256);\r\n    function tokenToBaseTransferInput(uint256 _amount, uint256 _minBase, address _recipient) external returns (uint256);\r\n    function tokenToBaseExchangeTransferInput(uint256 _amount, uint256 _minTokens, address _recipient, address _exchangeAddr) external returns (uint256);\r\n    // Uniswap exchange compat\r\n    function ethToTokenTransferInput(uint256 _minTokens, uint256 _deadline, address _recipient) external payable returns (uint256);\r\n}\r\n\r\n// File: contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    uint256 private _guardFlag;\r\n\r\n    uint256 private constant FLAG_LOCK = 2;\r\n    uint256 private constant FLAG_UNLOCK = 1;\r\n\r\n    constructor () internal {\r\n        // The flag starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardFlag = FLAG_UNLOCK;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(_guardFlag != FLAG_LOCK, \"reentrancy-guard: reentrant call\");\r\n        _guardFlag = FLAG_LOCK;\r\n        _;\r\n        _guardFlag = FLAG_UNLOCK;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/SafeMath.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        uint256 z = x + y;\r\n        require(z >= x, \"safemath: add overflow\");\r\n        return z;\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(x >= y, \"safemath: sub overflow\");\r\n        return x - y;\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 z = x * y;\r\n        require(z / x == y, \"safemath: mul overflow\");\r\n        return z;\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(y != 0, \"safemath: div by zero\");\r\n        return x / y;\r\n    }\r\n\r\n    function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(y != 0, \"safemath: div by zero\");\r\n        uint256 z = x / y;\r\n        if (x % y != 0) {\r\n            z = z + 1;\r\n        }\r\n\r\n        return z;\r\n    }\r\n}\r\n\r\n// File: contracts/commons/ERC20.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal p_totalSupply;\r\n    mapping(address => uint256) private p_balance;\r\n    mapping(address => mapping(address => uint256)) private p_allowance;\r\n\r\n    string private p_symbol;\r\n    string private p_name;\r\n    uint256 private p_decimals;\r\n\r\n    function _setMetadata(\r\n        string memory _symbol,\r\n        string memory _name,\r\n        uint256 _decimals\r\n    ) internal {\r\n        p_symbol = _symbol;\r\n        p_name = _name;\r\n        p_decimals = _decimals;\r\n    }\r\n\r\n    function symbol() external view returns (string memory) {\r\n        return p_symbol;\r\n    }\r\n\r\n    function name() external view returns (string memory) {\r\n        return p_name;\r\n    }\r\n\r\n    function decimals() external view returns (uint256) {\r\n        return p_decimals;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return p_totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _addr) external view returns (uint256) {\r\n        return p_balance[_addr];\r\n    }\r\n\r\n    function allowance(address _addr, address _spender) external view returns (uint256) {\r\n        return p_allowance[_addr][_spender];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _wad) external returns (bool) {\r\n        emit Approval(msg.sender, _spender, _wad);\r\n        p_allowance[msg.sender][_spender] = _wad;\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _wad) external returns (bool) {\r\n        _transfer(msg.sender, _to, _wad);\r\n        return true;\r\n    }\r\n\r\n    function transferWithFee(address _to, uint256 _wad) external returns (bool) {\r\n        _transfer(msg.sender, _to, _wad);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _wad) external returns (bool) {\r\n        _transfer(_from, _to, _wad);\r\n        return true;\r\n    }\r\n\r\n    function transferFromWithFee(address _from, address _to, uint256 _wad) external returns (bool) {\r\n        _transfer(_from, _to, _wad);\r\n        return true;\r\n    }\r\n\r\n    function _mint(\r\n        address _to,\r\n        uint256 _wad\r\n    ) internal {\r\n        p_totalSupply = p_totalSupply.add(_wad);\r\n        p_balance[_to] = p_balance[_to].add(_wad);\r\n\r\n        emit Transfer(address(0), _to, _wad);\r\n    }\r\n\r\n    function _burn(\r\n        address _from,\r\n        uint256 _wad\r\n    ) internal {\r\n        uint256 balance = p_balance[_from];\r\n        require(balance >= _wad, \"erc20: burn _from balance is not enough\");\r\n        p_balance[_from] = balance.sub(_wad);\r\n        p_totalSupply = p_totalSupply.sub(_wad);\r\n        emit Transfer(_from, address(0), _wad);\r\n    }\r\n\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _wad\r\n    ) private {\r\n        if (msg.sender != _from) {\r\n            uint256 t_allowance = p_allowance[_from][msg.sender];\r\n            if (t_allowance != uint(-1)) {\r\n                require(t_allowance >= _wad, \"erc20: sender allowance is not enough\");\r\n                p_allowance[_from][msg.sender] = t_allowance.sub(_wad);\r\n            }\r\n        }\r\n\r\n        uint256 fromBalance = p_balance[_from];\r\n        require(fromBalance >= _wad, \"erc20: transfer _from balance is not enough\");\r\n        p_balance[_from] = fromBalance.sub(_wad);\r\n        p_balance[_to] = p_balance[_to].add(_wad);\r\n\r\n        emit Transfer(_from, _to, _wad);\r\n    }\r\n}\r\n\r\n// File: contracts/utils/SafeDefERC20.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\nlibrary SafeDefERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(\r\n        IERC20 _token,\r\n        address _to,\r\n        uint256 _wad\r\n    ) internal returns (uint256) {\r\n        uint256 prev = _token.balanceOf(address(this));\r\n\r\n        (bool success, ) = address(_token).call(\r\n            abi.encodeWithSelector(\r\n                _token.transfer.selector,\r\n                _to,\r\n                _wad\r\n            )\r\n        );\r\n\r\n        require(success, \"safedeferc20: error sending tokens\");\r\n        return prev.sub(_token.balanceOf(address(this)));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _wad\r\n    ) internal returns (uint256) {\r\n        uint256 prev = _token.balanceOf(_to);\r\n\r\n        (bool success, ) = address(_token).call(\r\n            abi.encodeWithSelector(\r\n                _token.transferFrom.selector,\r\n                _from,\r\n                _to,\r\n                _wad\r\n            )\r\n        );\r\n\r\n        require(success, \"safedeferc20: error pulling tokens\");\r\n        return _token.balanceOf(_to).sub(prev);\r\n    }\r\n}\r\n\r\n// File: contracts/utils/ShufUtils.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\nlibrary ShufUtils {\r\n    using SafeMath for uint256;\r\n\r\n    function takeFee(uint256 _a) internal pure returns (uint256) {\r\n        if (_a == 1) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 fee = _a / 100;\r\n        if (_a % 100 != 0) {\r\n            fee = fee + 1;\r\n        }\r\n\r\n        return _a - (fee * 2);\r\n    }\r\n\r\n    function untakeFee(uint256 _a) internal pure returns (uint256) {\r\n        if (_a == 1) {\r\n            return 3;\r\n        }\r\n\r\n        uint256 aux = _a / 49;\r\n        if (aux % 2 == 0) {\r\n            aux = _a.add(aux);\r\n            if (aux % 100 == 0) {\r\n                return aux;\r\n            } else {\r\n                return aux.add(2);\r\n            }\r\n        } else {\r\n            return _a.add(aux).add(1);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/DefswapExchange.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\ncontract DefswapExchange is IDefswapExchange, ERC20, ReentrancyGuard {\r\n    using SafeDefERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    IERC20 private p_base;\r\n    IERC20 private p_token;\r\n    IUniswapExchange private p_uniswap;\r\n\r\n    string private constant SYMBOL_PREFIX = \"SHUF-\";\r\n    string private constant NAME_SUFIX = \" - defswap.io pooled\";\r\n    uint256 private constant DECIMALS = 18;\r\n\r\n    event AddLiquidity(\r\n        address indexed _provider,\r\n        uint256 _baseAmount,\r\n        uint256 _tokenAmount,\r\n        uint256 _minted\r\n    );\r\n\r\n    event RemoveLiquidity(\r\n        address indexed _provider,\r\n        uint256 _baseAmount,\r\n        uint256 _tokenAmount,\r\n        uint256 _burned,\r\n        uint256 _type\r\n    );\r\n\r\n    event TokenPurchase(\r\n        address indexed _buyer,\r\n        uint256 _baseSold,\r\n        uint256 _tokensBought,\r\n        uint256 _baseReserve,\r\n        uint256 _tokenReserve,\r\n        address _recipient\r\n    );\r\n\r\n    event BasePurchase(\r\n        address indexed _buyer,\r\n        uint256 _tokensSold,\r\n        uint256 _baseBought,\r\n        uint256 _tokenReserve,\r\n        uint256 _baseReserve,\r\n        address _recipient\r\n    );\r\n\r\n    constructor(IERC20 _base, IERC20 _token, IUniswapExchange _uniswap) public {\r\n        require(_uniswap.tokenAddress() == address(_base), \"defswap: uniswap token doesn't match\");\r\n        require(address(_base) != address(_token), \"defswap: token and base can't be the same\");\r\n\r\n        p_base = _base;\r\n        p_token = _token;\r\n        p_uniswap = _uniswap;\r\n\r\n        approveUniswap();\r\n        buildMetadata();\r\n    }\r\n\r\n    function approveUniswap() public nonReentrant {\r\n        p_base.approve(\r\n            address(p_uniswap),\r\n            uint(-1)\r\n        );\r\n    }\r\n\r\n    function buildMetadata() public nonReentrant {\r\n        address token = address(p_token);\r\n        require(gasleft() >= 402000, \"defswap: gasleft build metadata is not enough\");\r\n\r\n        (\r\n            bool successName,\r\n            bytes memory name\r\n        ) = token.staticcall(\r\n            abi.encodeWithSelector(p_token.name.selector)\r\n        );\r\n\r\n        (\r\n            bool successSymbol,\r\n            bytes memory symbol\r\n        ) = token.staticcall(\r\n            abi.encodeWithSelector(p_token.symbol.selector)\r\n        );\r\n\r\n        _setMetadata(\r\n            string(abi.encodePacked(SYMBOL_PREFIX, successSymbol ? abi.decode(symbol, (string)) : \"???\")),\r\n            string(abi.encodePacked(successName ? abi.decode(name, (string)) : \"Unknown\", NAME_SUFIX)),\r\n            DECIMALS\r\n        );\r\n    }\r\n\r\n    function base() external view returns (IERC20) {\r\n        return p_base;\r\n    }\r\n\r\n    function token() external view returns (IERC20) {\r\n        return p_token;\r\n    }\r\n\r\n    function uniswap() external view returns (IUniswapExchange) {\r\n        return p_uniswap;\r\n    }\r\n\r\n    function addLiquidity(\r\n        uint256 _tokens,\r\n        uint256 _maxBase\r\n    ) external nonReentrant returns (uint256 minted) {\r\n        IERC20 t_token = p_token;\r\n        IERC20 t_base = p_base;\r\n\r\n        // Pull tokens and store them in pool\r\n        // received stores the real amount of received tokens\r\n        uint256 received = t_token.safeTransferFrom(msg.sender, address(this), _tokens);\r\n        require(received != 0, \"defswap: pull zero tokens is not allowed\");\r\n\r\n        uint256 baseReceived;\r\n        uint256 t_totalSupply = p_totalSupply;\r\n\r\n        // Check if this is the first pool\r\n        if (t_totalSupply == 0) {\r\n            // Pull all _maxBase and mint received\r\n            require(t_base.transferFrom(msg.sender, address(this), _maxBase), \"defswap: error pulling base tokens\");\r\n            baseReceived = ShufUtils.takeFee(_maxBase);\r\n            minted = baseReceived;\r\n        } else {\r\n            // Calculate required pull, following current pool rate\r\n            uint256 tokenReserve = t_token.balanceOf(address(this)).sub(received);\r\n            uint256 baseReserve = t_base.balanceOf(address(this));\r\n            uint256 requiredPull = received.mul(baseReserve).divRound(tokenReserve);\r\n\r\n            // Pull tokens after untaking fee\r\n            baseReceived = t_base.safeTransferFrom(msg.sender, address(this), ShufUtils.untakeFee(requiredPull));\r\n            require(baseReceived <= _maxBase, \"defswap: _maxBase is below of pulled required\");\r\n            require(baseReceived >= requiredPull, \"defswap: pulled base is not enough\");\r\n\r\n            // Mint proportional tokens\r\n            minted = baseReceived.mul(t_totalSupply).div(baseReserve);\r\n        }\r\n\r\n        // Mint tokens and event\r\n        emit AddLiquidity(msg.sender, baseReceived, received, minted);\r\n        _mint(msg.sender, minted);\r\n    }\r\n\r\n    function removeLiquidity(\r\n        uint256 _amount,\r\n        uint256 _minBase,\r\n        uint256 _minTokens\r\n    ) external nonReentrant returns (\r\n        uint256 baseAmount,\r\n        uint256 tokenAmount\r\n    ) {\r\n        // Load totalSupply and check that it's not zero\r\n        uint256 t_totalSupply = p_totalSupply;\r\n        require(t_totalSupply != 0, \"defswap: pool is empty\");\r\n\r\n        // Load token contracts\r\n        IERC20 t_token = p_token;\r\n        IERC20 t_base = p_base;\r\n\r\n        // Load token reserves\r\n        uint256 tokenReserve = t_token.balanceOf(address(this));\r\n        uint256 baseReserve = t_base.balanceOf(address(this));\r\n\r\n        // Calculate base and tokens to withdraw\r\n        baseAmount = _amount.mul(baseReserve) / t_totalSupply;\r\n        tokenAmount = _amount.mul(tokenReserve) / t_totalSupply;\r\n\r\n        // Emit event and remove burn tokens from sender\r\n        emit RemoveLiquidity(msg.sender, baseAmount, tokenAmount, _amount, 0);\r\n        _burn(msg.sender, _amount);\r\n\r\n        // Check if taken base if above _minBase\r\n        require(baseAmount >= _minBase, \"defswap: baseAmount is below _minBase\");\r\n\r\n        // Transfer tokens and base\r\n        require(t_token.safeTransfer(msg.sender, tokenAmount) >= _minTokens, \"defswap: tokenAmount is below _minTokens\");\r\n        t_base.transferWithFee(msg.sender, baseAmount); // t_base is trusted\r\n    }\r\n\r\n    function removeBaseLiquidity(\r\n        uint256 _amount,\r\n        uint256 _minBase\r\n    ) external nonReentrant returns (\r\n        uint256 baseAmount\r\n    ) {\r\n        // Load totalSupply and check that it's not zero\r\n        uint256 t_totalSupply = p_totalSupply;\r\n        require(t_totalSupply != 0, \"defswap: pool is empty\");\r\n\r\n        // Load token contract\r\n        IERC20 t_base = p_base;\r\n\r\n        // Load base reserve\r\n        uint256 baseReserve = t_base.balanceOf(address(this));\r\n\r\n        // Calculate base to withdraw\r\n        baseAmount = _amount.mul(baseReserve) / t_totalSupply;\r\n\r\n        // Burn tokens and emit event\r\n        // it burns the full _amount\r\n        emit RemoveLiquidity(msg.sender, baseAmount, 0, _amount, 1);\r\n        _burn(msg.sender, _amount);\r\n\r\n        // Check if withdraw base is above _minBase and transfer tokens\r\n        require(baseAmount >= _minBase, \"defswap: baseAmount is below _minBase\");\r\n        t_base.transferWithFee(msg.sender, baseAmount); // t_base is trusted\r\n    }\r\n\r\n    function removeTokenLiquidity(\r\n        uint256 _amount,\r\n        uint256 _minTokens\r\n    ) external nonReentrant returns (\r\n        uint256 tokenAmount\r\n    ) {\r\n        // Load totalSupply and check that it's not zero\r\n        uint256 t_totalSupply = p_totalSupply;\r\n        require(t_totalSupply != 0, \"defswap: pool is empty\");\r\n\r\n        // Load token contract\r\n        IERC20 t_token = p_token;\r\n\r\n        // Load token reserve\r\n        uint256 tokenReserve = t_token.balanceOf(address(this));\r\n\r\n        // Calculate token to withdraw\r\n        tokenAmount = _amount.mul(tokenReserve) / t_totalSupply;\r\n\r\n        // Burn tokens and emit event\r\n        // it burns the full _amount\r\n        emit RemoveLiquidity(msg.sender, 0, tokenAmount, _amount, 2);\r\n        _burn(msg.sender, _amount);\r\n\r\n        // Transfer tokens and check if withdrawn amount is above _minTokens\r\n        require(t_token.safeTransfer(msg.sender, tokenAmount) >= _minTokens, \"defswap: tokenAmount is below _minTokens\");\r\n    }\r\n\r\n    function getBaseToTokenPrice(uint256 _baseSold) external view returns (uint256 tokensBought) {\r\n        tokensBought = _getInputPrice(\r\n            _baseSold,\r\n            p_base.balanceOf(address(this)),\r\n            p_token.balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    function getTokenToBasePrice(uint256 _tokenSold) external view returns (uint256 baseBought) {\r\n        baseBought = _getInputPrice(\r\n            _tokenSold,\r\n            p_token.balanceOf(address(this)),\r\n            p_base.balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    function ethToTokenSwapInput(\r\n        uint256 _minTokens\r\n    ) external nonReentrant payable returns (uint256 bought) {\r\n        // Trade ETH -> BASE, only if msg.value is not zero\r\n        uint256 baseBought = msg.value != 0 ? ShufUtils.takeFee(\r\n            p_uniswap.ethToTokenSwapInput.value(msg.value)(1, uint(-1))\r\n        ) : 0;\r\n\r\n        // Trade BASE -> TOKEN, and transfer to sender\r\n        bought = _baseToToken(\r\n            p_base,     // Base address\r\n            p_token,    // Token address\r\n            baseBought, // Base bought on trade ETH -> BASE\r\n            _minTokens, // Min base to receive\r\n            msg.sender, // Origin of the trade\r\n            msg.sender  // Recipient of the tokens\r\n        );\r\n    }\r\n\r\n    // Uniswap exchange compat\r\n    function ethToTokenTransferInput(\r\n        uint256 _minTokens,\r\n        uint256 _deadline,\r\n        address _recipient\r\n    ) external nonReentrant payable returns (uint256 bought) {\r\n        // Check if _deadile was exceeded\r\n        require(_deadline >= block.timestamp, \"defswap: expired transaction\");\r\n\r\n        // Trade ETH -> BASE, only if msg.value is not zero\r\n        uint256 baseBought = msg.value != 0 ? ShufUtils.takeFee(\r\n            p_uniswap.ethToTokenSwapInput.value(msg.value)(1, uint(-1))\r\n        ) : 0;\r\n\r\n        // Trade BASE -> TOKEN, and transfer to _recipient\r\n        bought = _baseToToken(\r\n            p_base,     // Base address\r\n            p_token,    // Token address\r\n            baseBought, // Base bought on trade ETH -> BASE\r\n            _minTokens, // Min base to receive\r\n            msg.sender, // Origin of the trade\r\n            _recipient  // Recipient of the tokens\r\n        );\r\n    }\r\n\r\n    function baseToTokenSwapInput(\r\n        uint256 _amount,\r\n        uint256 _minTokens\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        // Load base contract\r\n        IERC20 t_base = p_base;\r\n\r\n        // Transfer base from msg.sender to this\r\n        t_base.transferFromWithFee(msg.sender, address(this), _amount);\r\n        // real received has to take into account the transfer fee\r\n        uint256 received = ShufUtils.takeFee(_amount);\r\n\r\n        // Trade BASE -> TOKEN, and transfer to msg.sender\r\n        bought = _baseToToken(\r\n            t_base,     // Base address (already loaded)\r\n            p_token,    // Token address\r\n            received,   // Base received from msg.sender\r\n            _minTokens, // Min tokens to buy\r\n            msg.sender, // Origin of the trade\r\n            msg.sender  // Recipient of the tokens\r\n        );\r\n    }\r\n\r\n    function baseToTokenTransferInput(\r\n        uint256 _amount,\r\n        uint256 _minTokens,\r\n        address _recipient\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        // Load base contract\r\n        IERC20 t_base = p_base;\r\n\r\n        // Transfer base from msg.sender to this\r\n        t_base.transferFromWithFee(msg.sender, address(this), _amount);\r\n        // real received has to take into account the transfer fee\r\n        uint256 received = ShufUtils.takeFee(_amount);\r\n\r\n        // Trade BASE -> TOKEN, and transfer to msg.sender\r\n        bought = _baseToToken(\r\n            t_base,     // Base address (already loaded)\r\n            p_token,    // Token address\r\n            received,   // Base received from msg.sender\r\n            _minTokens, // Min tokens to buy\r\n            msg.sender, // Origin of the trade\r\n            _recipient  // Recipient of the tokens\r\n        );\r\n    }\r\n\r\n    function tokenToEthSwapInput(\r\n        uint256 _amount,\r\n        uint256 _minEth\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        // Load token contract from storage\r\n        IERC20 t_token = p_token;\r\n\r\n        // Transfer tokens from sender to this\r\n        // and store the real amount of received tokens\r\n        uint256 received = t_token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        // Convert TOKEN -> BASE and send base to this\r\n        // to later be converted into ETH\r\n        uint256 baseBought = ShufUtils.takeFee(\r\n            _tokenToBase(\r\n                p_base,       // Base address (already loaded)\r\n                t_token,      // Token address (already loaded)\r\n                received,     // Received tokens from msg.sender\r\n                0,            // Min base to buy (zero, will check the final result)\r\n                msg.sender,   // Origin of the trade\r\n                address(this) // Recipent of the base (self)\r\n            )\r\n        );\r\n\r\n        // Convert BASE -> ETH if baseBought is not zero\r\n        bought = baseBought != 0 ? p_uniswap.tokenToEthTransferInput(\r\n            baseBought, // Base amount to convert\r\n            1,          // Min ETH to buy (1, will check later using require)\r\n            uint(-1),   // Trade expiration (never)\r\n            msg.sender  // Recipent of the ETH\r\n        ) : 0;\r\n\r\n        // Check if bought ETH is above _minEth\r\n        require(bought >= _minEth, \"defswap: eth bought is below _minEth\");\r\n    }\r\n\r\n    function tokenToEthTransferInput(\r\n        uint256 _amount,\r\n        uint256 _minEth,\r\n        address _recipient\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        // Load token contract from storage\r\n        IERC20 t_token = p_token;\r\n\r\n        // Transfer tokens from sender to this\r\n        // and store the real amount of received tokens\r\n        uint256 received = t_token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        // Convert TOKEN -> BASE and send base to this\r\n        // to later be converted into ETH\r\n        uint256 baseBought = ShufUtils.takeFee(\r\n            _tokenToBase(\r\n                p_base,       // Base address (already loaded)\r\n                t_token,      // Token address (already loaded)\r\n                received,     // Received tokens from msg.sender\r\n                0,            // Min base to buy (zero, will check the final result)\r\n                msg.sender,   // Origin of the trade\r\n                address(this) // Recipent of the base (self)\r\n            )\r\n        );\r\n\r\n        // Convert BASE -> ETH if baseBought is not zero\r\n        bought = baseBought != 0 ? p_uniswap.tokenToEthTransferInput(\r\n            baseBought, // Base amount to convert\r\n            1,          // Min ETH to buy (1, will check later using require)\r\n            uint(-1),   // Trade expiration (never)\r\n            _recipient  // Recipent of the ETH\r\n        ) : 0;\r\n\r\n        // Check if bought ETH is above _minEth\r\n        require(bought >= _minEth, \"defswap: eth bought is below _minEth\");\r\n    }\r\n\r\n    function tokenToEthExchangeTransferInput(\r\n        uint256 _amount,\r\n        uint256 _minTokens,\r\n        address _recipient,\r\n        address _exchangeAddr\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        // Load token contract from storage\r\n        IERC20 t_token = p_token;\r\n\r\n        // Transfer tokens from sender to this\r\n        // and store the real amount of received tokens\r\n        uint256 received = t_token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        // Convert TOKEN -> BASE and send base to this\r\n        // to later be converted into ETH\r\n        uint256 baseBought = ShufUtils.takeFee(\r\n            _tokenToBase(\r\n                p_base,       // Base address (already loaded)\r\n                t_token,      // Token address (already loaded)\r\n                received,     // Received tokens from msg.sender\r\n                0,            // Min base to buy (zero, will check the final result)\r\n                msg.sender,   // Origin of the trade\r\n                address(this) // Recipent of the base (self)\r\n            )\r\n        );\r\n\r\n        // Convert BASE -> ETH if baseBought is not zero\r\n        // and transfer to self\r\n        uint256 ethBought = baseBought != 0 ? p_uniswap.tokenToEthSwapInput(\r\n            baseBought, // Base amount to sell\r\n            1,          // Min ETH to buy (1, will be check later)\r\n            uint(-1)    // Trade expiration (never)\r\n        ) : 0;\r\n\r\n        // Convert ETH -> TOKEN if ethBought is not zero\r\n        bought = ethBought != 0 ? IUniswapExchange(_exchangeAddr).ethToTokenTransferInput.value(\r\n            ethBought   // ETH to sell\r\n        )(\r\n            1,          // Min token buy (1, will check later)\r\n            uint(-1),   // Trade expiration (never)\r\n            _recipient  // Recipient of the tokens\r\n        ) : 0;\r\n\r\n        // Check if bought tokens is above _minTokens\r\n        // _exchangeAddr is considered trusted and it may never have transfered\r\n        // the ETH to the _recipient, this code trusts the return value of _exchangeAddr.ethToTokenTransferInput\r\n        require(bought >= _minTokens, \"defswap: tokens bought is below _minTokens\");\r\n    }\r\n\r\n    function tokenToBaseSwapInput(\r\n        uint256 _amount,\r\n        uint256 _minBase\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        // Load token contract from storage\r\n        IERC20 t_token = p_token;\r\n\r\n        // Transfer tokens from sender to this\r\n        // and store the real amount of received tokens\r\n        uint256 received = t_token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        // Convert TOKEN -> BASE and send base to msg.sender\r\n        bought = _tokenToBase(\r\n            p_base,     // Base address (already loaded)\r\n            t_token,    // Token address (already loaded)\r\n            received,   // Tokens to sell (received from msg.sender)\r\n            _minBase,   // Min base to buy\r\n            msg.sender, // Origin of the trade\r\n            msg.sender  // Recipient of the base\r\n        );\r\n    }\r\n\r\n    function tokenToBaseTransferInput(\r\n        uint256 _amount,\r\n        uint256 _minBase,\r\n        address _recipient\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        // Load token contract from storage\r\n        IERC20 t_token = p_token;\r\n\r\n        // Transfer tokens from sender to this\r\n        // and store the real amount of received tokens\r\n        uint256 received = t_token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        // Convert TOKEN -> BASE and send base to _recipient\r\n        bought = _tokenToBase(\r\n            p_base,     // Base address (already loaded)\r\n            t_token,    // Token address (already loaded)\r\n            received,   // Tokens to sell (received from msg.sender)\r\n            _minBase,   // Min base to buy\r\n            msg.sender, // Origin of the trade\r\n            _recipient  // Recipient of the base\r\n        );\r\n    }\r\n\r\n    function tokenToBaseExchangeTransferInput(\r\n        uint256 _amount,\r\n        uint256 _minTokens,\r\n        address _recipient,\r\n        address _exchangeAddr\r\n    ) external nonReentrant returns (uint256 bought) {\r\n        // _exchangeAddr can't be uniswap\r\n        // because that would remove the Uniswap approve made during the exchange creation\r\n        require(_exchangeAddr != address(p_uniswap), \"defswap: _exchange can't be Uniswap\");\r\n\r\n        // Load contracts from storage\r\n        IERC20 t_token = p_token;\r\n        IERC20 t_base = p_base;\r\n\r\n        // Transfer tokens from sender to this\r\n        // and store the real amount of received tokens\r\n        uint256 received = t_token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        // Load token and base reserves\r\n        uint256 tokenReserve = t_token.balanceOf(address(this)).sub(received);\r\n        uint256 baseReserve = t_base.balanceOf(address(this));\r\n\r\n        // Calculate baseBought, the trade it's not executed to avoid charging the transfer fee twice\r\n        // this represents TOKEN_A -> BASE\r\n        uint256 baseBought = _getInputPrice(received, tokenReserve, baseReserve);\r\n        emit BasePurchase(msg.sender, received, baseBought, tokenReserve, baseReserve, _exchangeAddr);\r\n\r\n        // Trade BASE -> TOKEN_B, using base baseBought with TOKEN_A\r\n        // the exchange is approve to withdraw `baseBought` and the approve is removed after\r\n        // the trade, _exchangeAddr can't exploit the temporal reserve ratio because of the reentrancy lock\r\n        t_base.approve(_exchangeAddr, baseBought);\r\n        bought = IDefswapExchange(_exchangeAddr).baseToTokenTransferInput(\r\n            baseBought, // BASE tokens to sell\r\n            _minTokens, // Min TOKEN_B to buy\r\n            _recipient  // Recipeint of token b\r\n        );\r\n\r\n        // Always remove the approve after the trade\r\n        t_base.approve(_exchangeAddr, 0);\r\n    }\r\n\r\n    function _getInputPrice(\r\n        uint256 _inputAmount,\r\n        uint256 _inputReserve,\r\n        uint256 _outputReserve\r\n    ) private pure returns (uint256) {\r\n        require(_inputReserve != 0 && _outputReserve != 0, \"defswap: one reserve is empty\");\r\n        uint256 inputAmountWithFee = _inputAmount.mul(997);\r\n        uint256 numerator = inputAmountWithFee.mul(_outputReserve);\r\n        uint256 denominator = _inputReserve.mul(1000).add(inputAmountWithFee);\r\n        return numerator / denominator;\r\n    }\r\n\r\n    function _baseToToken(\r\n        IERC20 t_base,\r\n        IERC20 t_token,\r\n        uint256 _amount,\r\n        uint256 _minTokens,\r\n        address _buyer,\r\n        address _recipient\r\n    ) private returns (uint256 tokensBought) {\r\n        // Load base and token reserves\r\n        uint256 tokenReserve = t_token.balanceOf(address(this));\r\n        uint256 baseReserve = t_base.balanceOf(address(this)).sub(_amount);\r\n\r\n        // Calculate tokens bought\r\n        tokensBought = _getInputPrice(_amount, baseReserve, tokenReserve);\r\n\r\n        // Check if tokens bought is above _minTokens and execute transfer\r\n        require(tokensBought >= _minTokens, \"defswap: bought tokens below _minTokens\");\r\n        require(t_token.safeTransfer(_recipient, tokensBought) != 0 || tokensBought == 0, \"defswap: error sending tokens\");\r\n\r\n        emit TokenPurchase(_buyer, _amount, tokensBought, baseReserve, tokenReserve, _recipient);\r\n    }\r\n\r\n    function _tokenToBase(\r\n        IERC20 t_base,\r\n        IERC20 t_token,\r\n        uint256 _amount,\r\n        uint256 _minBase,\r\n        address _buyer,\r\n        address _recipient\r\n    ) private returns (uint256 baseBought) {\r\n        // Load base and token reserves\r\n        uint256 tokenReserve = t_token.balanceOf(address(this)).sub(_amount);\r\n        uint256 baseReserve = t_base.balanceOf(address(this));\r\n\r\n        // Calculate base bought\r\n        baseBought = _getInputPrice(_amount, tokenReserve, baseReserve);\r\n\r\n        // Check if base bought is above _minBase and execute transfer\r\n        require(baseBought >= _minBase, \"defswap: bought base below _minBase\");\r\n        t_base.transferWithFee(_recipient, baseBought);\r\n\r\n        emit BasePurchase(_buyer, _amount, baseBought, tokenReserve, baseReserve, _recipient);\r\n    }\r\n\r\n    function() external payable {\r\n        // Revert if an EOA send's ETH\r\n        require(msg.sender != tx.origin, \"defswap: ETH rejected\");\r\n    }\r\n}\r\n\r\n// File: contracts/DefswapFactory.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\ncontract DefswapFactory {\r\n    using IsContract for address;\r\n\r\n    IUniswapExchange public uniswap;\r\n    IERC20 public base;\r\n\r\n    event CreatedExchange(address indexed _token, address indexed _exchange);\r\n\r\n    address[] private p_tokens;\r\n    mapping(address => address) public tokenToExchange;\r\n    mapping(address => address) public exchangeToToken;\r\n\r\n    constructor(IERC20 _base, IUniswapExchange _uniswap) public {\r\n        require(_uniswap.tokenAddress() == address(_base), \"defswap-factory: uniswap token doesn't match\");\r\n\r\n        base = _base;\r\n        uniswap = _uniswap;\r\n    }\r\n\r\n    function getToken(uint256 _i) external view returns (address) {\r\n        require(_i < p_tokens.length, \"defswap-factory: array out of bounds\");\r\n        return p_tokens[_i];\r\n    }\r\n\r\n    function getExchange(uint256 _i) external view returns (address) {\r\n        require(_i < p_tokens.length, \"defswap-factory: array out of bounds\");\r\n        return tokenToExchange[p_tokens[_i]];\r\n    }\r\n\r\n    function createExchange(address _token) external returns (address exchange) {\r\n        require(tokenToExchange[_token] == address(0), \"defswap-factory: exchange already exists\");\r\n        require(_token.isContract(), \"defswap-factory: _token has to be a contract\");\r\n\r\n        exchange = address(\r\n            new DefswapExchange(\r\n                base,\r\n                IERC20(_token),\r\n                uniswap\r\n            )\r\n        );\r\n\r\n        emit CreatedExchange(_token, exchange);\r\n\r\n        tokenToExchange[_token] = exchange;\r\n        exchangeToToken[exchange] = _token;\r\n        p_tokens.push(_token);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_base\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapExchange\",\"name\":\"_uniswap\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_exchange\",\"type\":\"address\"}],\"name\":\"CreatedExchange\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"base\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"createExchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exchangeToToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_i\",\"type\":\"uint256\"}],\"name\":\"getExchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_i\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenToExchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswap\",\"outputs\":[{\"internalType\":\"contract IUniswapExchange\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DefswapFactory","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003a9fff453d50d4ac52a6890647b823379ba36b9e000000000000000000000000536956fab86774fb55cfaacf496bc25e4d2b435c","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://16108c6b6e5be8c6ab955c752b4b2a3e2ddd985a394ef29a1c7702e264b420e0"}]}