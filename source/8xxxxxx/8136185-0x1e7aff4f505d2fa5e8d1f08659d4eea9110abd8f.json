{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.4;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary Callable {\r\n    struct CallResult {\r\n        bool success;\r\n        bytes data;\r\n    }\r\n\r\n    function makeCall(address to, bytes memory payload) internal returns(CallResult memory) {\r\n        (bool success, bytes memory resultRaw) = address(to).call(payload);\r\n        return CallResult(success, resultRaw);\r\n    }\r\n}\r\n\r\n\r\ncontract TestAccount {\r\n    using Callable for address;\r\n\r\n    function transfer(TestAccount to, uint256 value, address token) external returns(Callable.CallResult memory) {\r\n        return token.makeCall(abi.encodeWithSignature(\"transfer(address,uint256)\", to, value));\r\n    }\r\n\r\n    function approve(TestAccount spender, uint256 value, address token) external returns(Callable.CallResult memory) {\r\n        return token.makeCall(abi.encodeWithSignature(\"approve(address,uint256)\", spender, value));\r\n    }\r\n\r\n    function transferFrom(TestAccount from, TestAccount to, uint256 value, address token) external returns(Callable.CallResult memory) {\r\n        return token.makeCall(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", from, to, value));\r\n    }\r\n}\r\n\r\n\r\nlibrary TestedToken {\r\n    using Callable for address;\r\n\r\n    function totalSupply(address token) internal returns(Callable.CallResult memory) {\r\n        return token.makeCall(abi.encodeWithSignature(\"totalSupply()\"));\r\n    }\r\n\r\n    function balanceOf(address token, TestAccount who) internal returns(Callable.CallResult memory) {\r\n        return token.makeCall(abi.encodeWithSignature(\"balanceOf(address)\", who));\r\n    }\r\n\r\n    function allowance(address token, TestAccount owner, TestAccount spender) internal returns(Callable.CallResult memory) {\r\n        return token.makeCall(abi.encodeWithSignature(\"allowance(address,address)\", owner, spender));\r\n    }\r\n\r\n    function name(address token) internal returns(Callable.CallResult memory) {\r\n        return token.makeCall(abi.encodeWithSignature(\"name()\"));\r\n    }\r\n\r\n    function symbol(address token) internal returns(Callable.CallResult memory) {\r\n        return token.makeCall(abi.encodeWithSignature(\"symbol()\"));\r\n    }\r\n\r\n    function decimals(address token) internal returns(Callable.CallResult memory) {\r\n        return token.makeCall(abi.encodeWithSignature(\"decimals()\"));\r\n    }\r\n}\r\n\r\n\r\nlibrary TestUtils {\r\n    function returnAndRevert(bool result) internal returns(bool) {\r\n        assembly {\r\n             let memOffset := mload(0x40)\r\n             mstore(memOffset, result)\r\n             mstore(0x40, add(memOffset, 32))\r\n             revert(memOffset, 32)\r\n        }\r\n    }\r\n\r\n    function expectTrue(Callable.CallResult memory callResult) internal returns(Callable.CallResult memory) {\r\n        bytes memory data = callResult.data;\r\n        if (!callResult.success) {\r\n            returnAndRevert(false);\r\n        }\r\n        if (data.length != 32) {\r\n            returnAndRevert(false);\r\n        }\r\n        bool result = abi.decode(data, (bool));\r\n        if (!result) {\r\n            returnAndRevert(false);\r\n        }\r\n        return callResult;\r\n    }\r\n\r\n    function expectEqual(Callable.CallResult memory callResult, uint expectedResult) internal returns(Callable.CallResult memory) {\r\n        uint parsedData = toUInt(callResult);\r\n        if (parsedData != expectedResult) {\r\n            returnAndRevert(false);\r\n        }\r\n        return callResult;\r\n    }\r\n\r\n    function expectUInt(Callable.CallResult memory callResult) internal returns(Callable.CallResult memory) {\r\n        if (!callResult.success || callResult.data.length != 32) {\r\n            returnAndRevert(false);\r\n        }\r\n        return callResult;\r\n    }\r\n\r\n    function expectNonEmptyResult(Callable.CallResult memory callResult) internal returns(Callable.CallResult memory) {\r\n        if (!callResult.success || callResult.data.length == 0) {\r\n            returnAndRevert(false);\r\n        }\r\n        return callResult;\r\n    }\r\n\r\n    function expectSuccess(Callable.CallResult memory callResult) internal returns(Callable.CallResult memory) {\r\n        if (!callResult.success) {\r\n            returnAndRevert(false);\r\n        }\r\n        return callResult;\r\n    }\r\n\r\n    function expectRevert(Callable.CallResult memory callResult) internal returns(Callable.CallResult memory) {\r\n        if (callResult.success) {\r\n            returnAndRevert(false);\r\n        }\r\n        return callResult;\r\n    }\r\n\r\n    function toBool(Callable.CallResult memory callResult) internal returns(bool) {\r\n        if (callResult.data.length != 32) {\r\n            return false;\r\n        }\r\n        return abi.decode(callResult.data, (bool));\r\n    }\r\n\r\n    function toUInt(Callable.CallResult memory callResult) internal returns(uint) {\r\n        expectUInt(callResult);\r\n        return abi.decode(callResult.data, (uint));\r\n    }\r\n}\r\n\r\n\r\ncontract TestSuite {\r\n    using TestUtils for Callable.CallResult;\r\n    using TestedToken for address;\r\n    using Callable for address;\r\n\r\n    mapping(address => uint) public testResults;\r\n    TestAccount[3] public testAccounts;\r\n\r\n    bytes4[22] private testSignatures = [\r\n        bytes4(keccak256(bytes(\"existenceTransferTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"existenceApproveTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"existenceTransferFromTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"existenceAllowance(address)\"))),\r\n        bytes4(keccak256(bytes(\"existenceBalanceOf(address)\"))),\r\n        bytes4(keccak256(bytes(\"existenceTotalSupplyTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"existenceName(address)\"))),\r\n        bytes4(keccak256(bytes(\"existenceSymbol(address)\"))),\r\n        bytes4(keccak256(bytes(\"existenceDecimals(address)\"))),\r\n        bytes4(keccak256(bytes(\"basicApproveTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"approveZeroTokensTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"allowanceRewriteTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"basicTransferTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"transferZeroTokensTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"transferMoreThanBalanceTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"basicTransferFromTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"transferFromWithoutAllowanceTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"transferFromNotFullAllowanceTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"transferFromChangeAllowanceTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"transferFromMoreThanAllowedTest(address)\"))),\r\n        bytes4(keccak256(bytes(\"transferFromOnBehalf(address)\"))),\r\n        bytes4(keccak256(bytes(\"transferFromLowFunds(address)\")))\r\n    ];\r\n\r\n    modifier revertAfter() {\r\n        _;\r\n        TestUtils.returnAndRevert(true);\r\n    }\r\n\r\n    constructor() public {\r\n        testAccounts[0] = new TestAccount();\r\n        testAccounts[1] = new TestAccount();\r\n        testAccounts[2] = new TestAccount();\r\n    }\r\n\r\n    function existenceTransferTest(address token) external revertAfter returns(bool) {\r\n\r\n        testAccounts[0].transfer(testAccounts[1], 1000, token).expectTrue();\r\n    }\r\n\r\n    function existenceApproveTest(address token) external revertAfter returns(bool) {\r\n        testAccounts[0].approve(testAccounts[1], 1000, token).expectTrue();\r\n    }\r\n\r\n    function existenceTransferFromTest(address token) external revertAfter returns(bool) {\r\n        testAccounts[0].approve(testAccounts[1], 1000, token).expectTrue();\r\n        testAccounts[1].transferFrom(testAccounts[0], testAccounts[1], 1000, token).expectTrue();\r\n    }\r\n\r\n    function existenceTotalSupplyTest(address token) external revertAfter returns(bool) {\r\n        token.totalSupply().expectUInt();\r\n    }\r\n\r\n    function existenceBalanceOf(address token) external revertAfter returns(bool) {\r\n        token.balanceOf(testAccounts[0]).expectUInt();\r\n    }\r\n\r\n    function existenceAllowance(address token) external revertAfter returns(bool) {\r\n        token.allowance(testAccounts[0], testAccounts[1]).expectUInt();\r\n    }\r\n\r\n    function existenceName(address token) external revertAfter returns(bool) {\r\n        token.name().expectNonEmptyResult();\r\n    }\r\n\r\n    function existenceSymbol(address token) external revertAfter returns(bool) {\r\n        token.symbol().expectNonEmptyResult();\r\n    }\r\n\r\n    function existenceDecimals(address token) external revertAfter returns(bool) {\r\n        uint tokenDecimals = token.decimals().toUInt();\r\n        if (tokenDecimals >= 77) {\r\n            TestUtils.returnAndRevert(false);\r\n        }\r\n    }\r\n\r\n    function basicApproveTest(address token) external revertAfter returns(bool) {\r\n        testAccounts[0].approve(testAccounts[1], 1000, token).expectTrue();\r\n        token.allowance(testAccounts[0], testAccounts[1]).expectEqual(1000);\r\n    }\r\n\r\n    function approveZeroTokensTest(address token) external revertAfter returns(bool) {\r\n        testAccounts[0].approve(testAccounts[1], 0, token).expectTrue();\r\n        token.allowance(testAccounts[0], testAccounts[1]).expectEqual(0);\r\n    }\r\n\r\n    function allowanceRewriteTest(address token) external revertAfter returns(bool) {\r\n        testAccounts[0].approve(testAccounts[1], 1000, token).expectTrue();\r\n        token.allowance(testAccounts[0], testAccounts[1]).expectEqual(1000);\r\n        testAccounts[0].approve(testAccounts[1], 2000, token).expectTrue();\r\n        token.allowance(testAccounts[0], testAccounts[1]).expectEqual(2000);\r\n    }\r\n\r\n    function basicTransferTest(address token) external revertAfter returns(bool) {\r\n        uint balance0Old = token.balanceOf(testAccounts[0]).toUInt();\r\n        uint balance1Old = token.balanceOf(testAccounts[1]).toUInt();\r\n\r\n        testAccounts[0].transfer(testAccounts[1], 1000, token).expectTrue();\r\n        token.balanceOf(testAccounts[0]).expectEqual(balance0Old - 1000);\r\n        token.balanceOf(testAccounts[1]).expectEqual(balance1Old + 1000);\r\n    }\r\n\r\n    function transferZeroTokensTest(address token) external revertAfter returns(bool) {\r\n        uint balance0Old = token.balanceOf(testAccounts[0]).toUInt();\r\n        uint balance1Old = token.balanceOf(testAccounts[1]).toUInt();\r\n\r\n        testAccounts[0].transfer(testAccounts[1], 0, token).expectTrue();\r\n        token.balanceOf(testAccounts[0]).expectEqual(balance0Old);\r\n        token.balanceOf(testAccounts[1]).expectEqual(balance1Old);\r\n    }\r\n\r\n    function transferMoreThanBalanceTest(address token) external revertAfter returns(bool) {\r\n        uint balance0Old = token.balanceOf(testAccounts[0]).toUInt();\r\n        token.balanceOf(testAccounts[1]).toUInt();\r\n\r\n        testAccounts[0].transfer(testAccounts[1], balance0Old + 1, token).expectRevert();\r\n    }\r\n\r\n    function basicTransferFromTest(address token) external revertAfter returns(bool) {\r\n        uint balance0Old = token.balanceOf(testAccounts[0]).toUInt();\r\n        uint balance1Old = token.balanceOf(testAccounts[1]).toUInt();\r\n\r\n        testAccounts[0].approve(testAccounts[1], 1000, token).expectTrue();\r\n        testAccounts[1].transferFrom(testAccounts[0], testAccounts[1], 1000, token).expectTrue();\r\n\r\n        token.balanceOf(testAccounts[0]).expectEqual(balance0Old - 1000);\r\n        token.balanceOf(testAccounts[1]).expectEqual(balance1Old + 1000);\r\n        token.allowance(testAccounts[0], testAccounts[1]).expectEqual(0);\r\n    }\r\n\r\n    function transferFromWithoutAllowanceTest(address token) external revertAfter returns(bool) {\r\n        testAccounts[0].approve(testAccounts[1], 0, token).expectTrue();\r\n        token.balanceOf(testAccounts[0]).toUInt();\r\n        token.balanceOf(testAccounts[1]).toUInt();\r\n\r\n        testAccounts[1].transferFrom(testAccounts[0], testAccounts[1], 1, token).expectRevert();\r\n    }\r\n\r\n    function transferFromNotFullAllowanceTest(address token) external revertAfter returns(bool) {\r\n        uint balance0Old = token.balanceOf(testAccounts[0]).toUInt();\r\n        uint balance1Old = token.balanceOf(testAccounts[1]).toUInt();\r\n\r\n        testAccounts[0].approve(testAccounts[1], 1000, token).expectTrue();\r\n        testAccounts[1].transferFrom(testAccounts[0], testAccounts[1], 600, token).expectTrue();\r\n\r\n        token.balanceOf(testAccounts[0]).expectEqual(balance0Old - 600);\r\n        token.balanceOf(testAccounts[1]).expectEqual(balance1Old + 600);\r\n        token.allowance(testAccounts[0], testAccounts[1]).expectEqual(400);\r\n    }\r\n\r\n    function transferFromMoreThanAllowedTest(address token) external revertAfter returns(bool) {\r\n        testAccounts[0].approve(testAccounts[1], 600, token).expectTrue();\r\n        token.balanceOf(testAccounts[0]).toUInt();\r\n        token.balanceOf(testAccounts[1]).toUInt();\r\n\r\n        testAccounts[1].transferFrom(testAccounts[0], testAccounts[1], 601, token).expectRevert();\r\n    }\r\n\r\n    function transferFromChangeAllowanceTest(address token) external revertAfter returns(bool) {\r\n        testAccounts[0].approve(testAccounts[1], 1000, token).expectTrue();\r\n        uint balance0Old = token.balanceOf(testAccounts[0]).toUInt();\r\n        uint balance1Old = token.balanceOf(testAccounts[1]).toUInt();\r\n\r\n        testAccounts[1].transferFrom(testAccounts[0], testAccounts[1], 600, token).expectTrue();\r\n        token.balanceOf(testAccounts[0]).expectEqual(balance0Old - 600);\r\n        token.balanceOf(testAccounts[1]).expectEqual(balance1Old + 600);\r\n\r\n        testAccounts[0].approve(testAccounts[1], 0, token).expectTrue();\r\n        testAccounts[1].transferFrom(testAccounts[0], testAccounts[1], 400, token).expectRevert();\r\n    }\r\n\r\n    function transferFromLowFunds(address token) external revertAfter returns(bool) {\r\n        uint balance0 = token.balanceOf(testAccounts[0]).toUInt();\r\n        testAccounts[0].approve(testAccounts[1], balance0 + 1, token).expectTrue();\r\n        testAccounts[1].transferFrom(testAccounts[0], testAccounts[1], balance0 + 1, token).expectRevert();\r\n    }\r\n\r\n    function transferFromOnBehalf(address token) external revertAfter returns(bool) {\r\n        uint balance0Old = token.balanceOf(testAccounts[0]).toUInt();\r\n        uint balance1Old = token.balanceOf(testAccounts[1]).toUInt();\r\n        uint balance2Old = token.balanceOf(testAccounts[2]).toUInt();\r\n\r\n        testAccounts[0].approve(testAccounts[2], 1000, token).expectTrue();\r\n        testAccounts[2].transferFrom(testAccounts[0], testAccounts[1], 1000, token).expectTrue();\r\n        token.allowance(testAccounts[0], testAccounts[2]).expectEqual(0);\r\n        token.balanceOf(testAccounts[0]).expectEqual(balance0Old - 1000);\r\n        token.balanceOf(testAccounts[1]).expectEqual(balance1Old + 1000);\r\n        token.balanceOf(testAccounts[2]).expectEqual(balance2Old);\r\n    }\r\n\r\n    function callTest(uint testNum, address token) internal returns(bool) {\r\n        bytes memory payload = abi.encodeWithSelector(testSignatures[testNum], token);\r\n        return address(this).makeCall(payload).toBool();\r\n    }\r\n\r\n    function runTests(address token, address customer) external returns(uint) {\r\n        require(msg.sender == address(this), \"use check() function to run tests\");\r\n        IERC20(token).transferFrom(customer, address(testAccounts[0]), 1000);\r\n\r\n        // run tests\r\n        uint testsPassed = 1;  // make the least bit equal to 1 to point out tests were run\r\n        uint totalTests = testSignatures.length;\r\n        for (uint testNum = 0; testNum < totalTests; ++testNum) {\r\n            // call test\r\n            bool testResult = callTest(testNum, token);\r\n            // decode result and save\r\n            if (testResult) {\r\n                testsPassed += 1<<(testNum+1);\r\n            }\r\n        }\r\n\r\n        // return testsPassed and revert\r\n        assembly {\r\n             let memOffset := mload(0x40)\r\n             mstore(memOffset, testsPassed)\r\n             mstore(0x40, add(memOffset, 32))\r\n             revert(memOffset, 32)\r\n        }\r\n    }\r\n\r\n    function check(address token) external returns(uint) {\r\n        testResults[token] = 1;  // make the least bit equal to 1 to point out tests were run\r\n        bytes memory payload = abi.encodeWithSignature(\"runTests(address,address)\", token, msg.sender);\r\n        Callable.CallResult memory callResult = address(this).makeCall(payload);\r\n        if (callResult.data.length != 32) {\r\n            return 1;\r\n        }\r\n        uint testsPassed = abi.decode(callResult.data, (uint));\r\n        if (testsPassed <= 1) {\r\n            return 1;\r\n        }\r\n        testResults[token] = testsPassed;\r\n        return testsPassed;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"transferMoreThanBalanceTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"existenceApproveTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"allowanceRewriteTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"testAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"basicApproveTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"approveZeroTokensTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"existenceDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"transferZeroTokensTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"basicTransferTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"transferFromWithoutAllowanceTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"transferFromLowFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"transferFromChangeAllowanceTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"existenceSymbol\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"existenceBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"transferFromNotFullAllowanceTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"existenceTransferTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"existenceAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"existenceTransferFromTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"testResults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"check\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"basicTransferFromTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"transferFromMoreThanAllowedTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"transferFromOnBehalf\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"existenceTotalSupplyTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"existenceName\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"customer\",\"type\":\"address\"}],\"name\":\"runTests\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"TestSuite","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://60d1f55010288af6f484cdd58853ad3b6fedea0946d2f9a4345477eb985ade2f"}]}