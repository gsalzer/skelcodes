{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.12;\r\n\r\n // @author Authereum, Inc.\r\n \r\n/**\r\n * @title AccountStateV1\r\n * @author Authereum, Inc.\r\n * @dev This contract holds the state variables used by the account contracts.\r\n * @dev This abscraction exists in order to retain the order of the state variables.\r\n */\r\n\r\ncontract AccountStateV1 {\r\n    uint256 public lastInitializedVersion;\r\n    mapping(address => bool) public authKeys;\r\n    uint256 public nonce;\r\n    uint256 public numAuthKeys;\r\n}\r\n\r\n// File: contracts/account/state/AccountState.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n/**\r\n * @title AccountState\r\n * @author Authereum, Inc.\r\n * @dev This contract holds the state variables used by the account contracts.\r\n * @dev This exists as the main contract to hold state. This contract is inherited\r\n * @dev by Account.sol, which will not care about state as long as it inherits\r\n * @dev AccountState.sol. Any state variable additions will be made to the various\r\n * @dev versions of AccountStateVX that this contract will inherit.\r\n */\r\n\r\ncontract AccountState is AccountStateV1 {}\r\n\r\n// File: contracts/account/event/AccountEvent.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n/**\r\n * @title AccountEvent\r\n * @author Authereum, Inc.\r\n * @dev This contract holds the events used by the Authereum contracts.\r\n * @dev This abscraction exists in order to retain the order to give initialization functions\r\n * @dev access to events.\r\n * @dev This contract can be overwritten with no changes to the upgradeability.\r\n */\r\n\r\ncontract AccountEvent {\r\n\r\n    /**\r\n     * BaseAccount.sol\r\n     */\r\n\r\n    event FundsReceived(address indexed sender, uint256 indexed value);\r\n    event AddedAuthKey(address indexed authKey);\r\n    event RemovedAuthKey(address indexed authKey);\r\n    event SwappedAuthKeys(address indexed oldAuthKey, address indexed newAuthKey);\r\n\r\n    // Invalid Sigs\r\n    event InvalidAuthkey();\r\n    event InvalidTransactionDataSigner();\r\n    // Invalid Tx\r\n    event CallFailed(bytes32 encodedData);\r\n\r\n    /**\r\n     * AccountUpgradeability.sol\r\n     */\r\n\r\n    event Upgraded(address indexed implementation);\r\n\r\n}\r\n\r\n// File: contracts/account/initializer/AccountInitializeV1.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n/**\r\n * @title AccountInitializeV1\r\n * @author Authereum, Inc.\r\n * @dev This contract holds the initialize function used by the account contracts.\r\n * @dev This abscraction exists in order to retain the order of the initialization functions.\r\n */\r\n\r\ncontract AccountInitializeV1 is AccountState, AccountEvent {\r\n\r\n    /// @dev Initialize the Authereum Account\r\n    /// @param _authKey authKey that will own this account\r\n    function initializeV1(\r\n        address _authKey\r\n    )\r\n        public\r\n    {\r\n        require(lastInitializedVersion == 0);\r\n        lastInitializedVersion = 1;\r\n\r\n        // Add self as an authKey\r\n        authKeys[_authKey] = true;\r\n        numAuthKeys += 1;\r\n        emit AddedAuthKey(_authKey);\r\n    }\r\n}\r\n\r\n// File: contracts/account/initializer/AccountInitialize.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n/**\r\n * @title AccountInitialize\r\n * @author Authereum, Inc.\r\n * @dev This contract holds the intialize functions used by the account contracts.\r\n * @dev This exists as the main contract to hold these functions. This contract is inherited\r\n * @dev by AuthereumAccount.sol, which will not care about initialization functions as long as it inherits\r\n * @dev AccountInitialize.sol. Any initialization function additions will be made to the various\r\n * @dev versions of AccountInitializeVx that this contract will inherit.\r\n */\r\n\r\ncontract AccountInitialize is AccountInitializeV1 {}\r\n\r\n// File: contracts/interfaces/IERC1271.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\ncontract IERC1271 {\r\n  function isValidSignature(\r\n    bytes memory _messageHash,\r\n    bytes memory _signature)\r\n    public\r\n    view\r\n    returns (bytes4 magicValue);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * (.note) This call _does not revert_ if the signature is invalid, or\r\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\r\n     * the zero address is returned.\r\n     *\r\n     * (.warning) `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise)\r\n     * be too long), and then calling `toEthSignedMessageHash` on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * [`eth_sign`](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign)\r\n     * JSON-RPC method.\r\n     *\r\n     * See `recover`.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: solidity-bytes-utils/contracts/BytesLib.sol\r\n\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary BytesLib {\r\n    function concat(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add \r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                // Since the new array still fits in the slot, we just need to\r\n                // update the contents of the slot.\r\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                    _preBytes_slot,\r\n                    // all the modifications to the slot are inside this\r\n                    // next block\r\n                    add(\r\n                        // we can just add to the slot contents because the\r\n                        // bytes we want to change are the LSBs\r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    // load the bytes from memory\r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    // zero all bytes to the right\r\n                                    exp(0x100, sub(32, mlength))\r\n                                ),\r\n                                // and now shift left the number of bytes to\r\n                                // leave space for the length in the slot\r\n                                exp(0x100, sub(32, newlength))\r\n                            ),\r\n                            // increase length by the double of the memory\r\n                            // bytes length\r\n                            mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                // The stored value fits in the slot, but the combined value\r\n                // will exceed it.\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // The contents of the _postBytes array start 32 bytes into\r\n                // the structure. Our first read should obtain the `submod`\r\n                // bytes that can fit into the unused space in the last word\r\n                // of the stored array. To get this, we read 32 bytes starting\r\n                // from `submod`, so the data we read overlaps with the array\r\n                // contents by `submod` bytes. Masking the lowest-order\r\n                // `submod` bytes allows us to add that value directly to the\r\n                // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                        ),\r\n                        and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // Copy over the first `submod` bytes of the new data as in\r\n                // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n                \r\n                for { \r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint _start,\r\n        uint _length\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\r\n        require(_bytes.length >= (_start + 1));\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\r\n        require(_bytes.length >= (_start + 2));\r\n        uint16 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\r\n        require(_bytes.length >= (_start + 4));\r\n        uint32 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\r\n        require(_bytes.length >= (_start + 8));\r\n        uint64 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x8), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\r\n        require(_bytes.length >= (_start + 12));\r\n        uint96 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0xc), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\r\n        require(_bytes.length >= (_start + 16));\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\r\n        require(_bytes.length >= (_start + 32));\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(\r\n        bytes storage _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // slength can contain both the length and contents of the array\r\n                // if length < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n\r\n// File: contracts/account/BaseAccount.sol\r\n\r\npragma solidity 0.5.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title BaseAccount\r\n * @author Authereum, Inc.\r\n * @dev Base account contract. Performs most of the functionality\r\n * @dev of an Authereum account contract.\r\n */\r\n\r\ncontract BaseAccount is AccountInitialize, IERC1271 {\r\n    using SafeMath for uint256;\r\n    using ECDSA for bytes32;\r\n    using BytesLib for bytes;\r\n\r\n    // Include a CHAIN_ID const\r\n    uint256 constant CHAIN_ID = 1;\r\n\r\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\r\n    bytes4 constant internal VALID_SIG = 0x20c13b0b;\r\n    bytes4 constant internal INVALID_SIG = 0xffffffff;\r\n\r\n    modifier onlyValidAuthKeyOrSelf {\r\n        _validateAuthKey(msg.sender);\r\n        _;\r\n    }\r\n\r\n    // This is required for funds sent to this contract\r\n    function () external payable {}\r\n\r\n    /**\r\n     *  Getters\r\n     */\r\n\r\n    /// @dev Get the current nonce of the contract\r\n    /// @return The nonce of the contract\r\n    function getNonce() public view returns (uint256) {\r\n        return nonce;\r\n    }\r\n\r\n    /// @dev Get the chain ID constant\r\n    /// @return The chain id\r\n    function getChainId() public view returns (uint256) {\r\n        return CHAIN_ID;\r\n    }\r\n\r\n    /**\r\n     *  Public functions\r\n     */\r\n\r\n    /// @dev Execute a transaction\r\n    /// @notice This is to be called directly by an AuthKey\r\n    /// @param _destination Destination of the transaction\r\n    /// @param _value Value of the transaction\r\n    /// @param _data Data of the transaction\r\n    /// @param _gasLimit Gas limit of the transaction\r\n    /// @return Response of the call\r\n    function executeTransaction(\r\n        address _destination,\r\n        uint256 _value,\r\n        bytes memory _data,\r\n        uint256 _gasLimit\r\n    )\r\n        public\r\n        onlyValidAuthKeyOrSelf\r\n        returns (bytes memory)\r\n    {\r\n        return _executeTransaction(_destination, _value, _data, _gasLimit);\r\n    }\r\n\r\n    /// @dev Add an auth key to the list of auth keys\r\n    /// @param _authKey Address of the auth key to add\r\n    function addAuthKey(address _authKey) public onlyValidAuthKeyOrSelf {\r\n        require(!authKeys[_authKey], \"Auth key already added\");\r\n        authKeys[_authKey] = true;\r\n        numAuthKeys += 1;\r\n        emit AddedAuthKey(_authKey);\r\n    }\r\n\r\n    /// @dev Add multiple auth keys to the list of auth keys\r\n    /// @param _authKeys Array of addresses to add to the auth keys list\r\n    function addMultipleAuthKeys(address[] memory _authKeys) public onlyValidAuthKeyOrSelf {\r\n        for (uint256 i = 0; i < _authKeys.length; i++) {\r\n            addAuthKey(_authKeys[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Remove an auth key from the list of auth keys\r\n    /// @param _authKey Address of the auth key to remove\r\n    function removeAuthKey(address _authKey) public onlyValidAuthKeyOrSelf {\r\n        require(authKeys[_authKey], \"Auth key not yet added\");\r\n        require(numAuthKeys > 1, \"Cannot remove last auth key\");\r\n        authKeys[_authKey] = false;\r\n        numAuthKeys -= 1;\r\n        emit RemovedAuthKey(_authKey);\r\n    }\r\n\r\n    /// @dev Remove multiple auth keys to the list of auth keys\r\n    /// @param _authKeys Array of addresses to remove to the auth keys list\r\n    function removeMultipleAuthKeys(address[] memory _authKeys) public onlyValidAuthKeyOrSelf {\r\n        for (uint256 i = 0; i < _authKeys.length; i++) {\r\n            removeAuthKey(_authKeys[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Swap one authKey for a non-authKey\r\n    /// @param _oldAuthKey An existing authKey\r\n    /// @param _newAuthKey A non-existing authKey\r\n    function swapAuthKeys(\r\n        address _oldAuthKey,\r\n        address _newAuthKey\r\n    )\r\n        public\r\n        onlyValidAuthKeyOrSelf\r\n    {\r\n        require(authKeys[_oldAuthKey], \"Old auth key does not exist\");\r\n        require(!authKeys[_newAuthKey], \"New auth key already exists\");\r\n        addAuthKey(_newAuthKey);\r\n        removeAuthKey(_oldAuthKey);\r\n        emit SwappedAuthKeys(_oldAuthKey, _newAuthKey);\r\n    }\r\n\r\n    /// @dev Swap multiple auth keys to the list of auth keys\r\n    /// @param _oldAuthKeys Array of addresses to remove to the auth keys list\r\n    /// @param _newAuthKeys Array of addresses to add to the auth keys list\r\n    function swapMultipleAuthKeys(\r\n        address[] memory _oldAuthKeys,\r\n        address[] memory _newAuthKeys\r\n    )\r\n        public\r\n    {\r\n        require(_oldAuthKeys.length == _newAuthKeys.length, \"Input arrays not equal length\");\r\n        for (uint256 i = 0; i < _oldAuthKeys.length; i++) {\r\n            swapAuthKeys(_oldAuthKeys[i], _newAuthKeys[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Check if a message and signature pair is valid\r\n    /// @notice The _signatures parameter can either be one auth key signature or it can\r\n    /// @notice be a login key signature and an auth key signature (signed login key)\r\n    /// @param _msg Message that was signed\r\n    /// @param _signatures Signature(s) of the data. Either a single signature (login) or two (login and auth)\r\n    /// @return VALID_SIG or INVALID_SIG hex data\r\n    function isValidSignature(\r\n        bytes memory _msg,\r\n        bytes memory _signatures\r\n    )\r\n        public\r\n        view\r\n        returns (bytes4)\r\n    {\r\n        if (_signatures.length == 65) {\r\n            return isValidAuthKeySignature(_msg, _signatures);\r\n        } else if (_signatures.length == 130) {\r\n            return isValidLoginKeySignature(_msg, _signatures);\r\n        } else {\r\n            revert(\"Invalid _signatures length\");\r\n        }\r\n    }\r\n\r\n    /// @dev Check if a message and auth key signature pair is valid\r\n    /// @param _msg Message that was signed\r\n    /// @param _signature Signature of the data signed by the authkey\r\n    /// @return VALID_SIG or INVALID_SIG hex data\r\n    function isValidAuthKeySignature(\r\n        bytes memory _msg,\r\n        bytes memory _signature\r\n    )\r\n        public\r\n        view\r\n        returns (bytes4)\r\n    {\r\n        address authKeyAddress = _getEthSignedMessageHash(_msg).recover(\r\n            _signature\r\n        );\r\n\r\n        if(authKeys[authKeyAddress]) {\r\n            return VALID_SIG;\r\n        } else {\r\n            return INVALID_SIG;\r\n        }\r\n    }\r\n\r\n    /// @dev Check if a message and login key signature pair is valid, as well as a signed login key by an auth key\r\n    /// @param _msg Message that was signed\r\n    /// @param _signatures Signatures of the data. Signed msg data by the login key and signed login key by auth key\r\n    /// @return VALID_SIG or INVALID_SIG hex data\r\n    function isValidLoginKeySignature(\r\n        bytes memory _msg,\r\n        bytes memory _signatures\r\n    )\r\n        public\r\n        view\r\n        returns (bytes4)\r\n    {\r\n        bytes memory msgHashSignature = _signatures.slice(0, 65);\r\n        bytes memory loginKeyAuthorizationSignature = _signatures.slice(65, 65);\r\n\r\n        address loginKeyAddress = _getEthSignedMessageHash(_msg).recover(\r\n            msgHashSignature\r\n        );\r\n\r\n        bytes32 loginKeyAuthorizationMessageHash = keccak256(abi.encodePacked(\r\n            loginKeyAddress\r\n        )).toEthSignedMessageHash();\r\n\r\n        address authorizationSigner = loginKeyAuthorizationMessageHash.recover(\r\n            loginKeyAuthorizationSignature\r\n        );\r\n\r\n        if(authKeys[authorizationSigner]) {\r\n            return VALID_SIG;\r\n        } else {\r\n            return INVALID_SIG;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Internal functions\r\n     */\r\n\r\n    /// @dev Validate an authKey\r\n    /// @param _authKey Address of the auth key to validate\r\n    function _validateAuthKey(address _authKey) internal view {\r\n        require(authKeys[_authKey] == true || msg.sender == address(this), \"Auth key is invalid\");\r\n    }\r\n\r\n    /// @dev Validate signatures from an AuthKeyMetaTx\r\n    /// @param _txDataMessageHash Ethereum signed message of the transaction\r\n    /// @param _transactionDataSignature Signed tx data\r\n    /// @return Address of the auth key that signed the data\r\n    function _validateAuthKeyMetaTxSigs(\r\n        bytes32 _txDataMessageHash,\r\n        bytes memory _transactionDataSignature\r\n    )\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        address transactionDataSigner = _txDataMessageHash.recover(_transactionDataSignature);\r\n        _validateAuthKey(transactionDataSigner);\r\n        return transactionDataSigner;\r\n    }\r\n\r\n    /// @dev Validate signatures from an AuthKeyMetaTx\r\n    /// @param _txDataMessageHash Ethereum signed message of the transaction\r\n    /// @param _transactionDataSignature Signed tx data\r\n    /// @param _loginKeyAuthorizationSignature Signed loginKey\r\n    /// @return Address of the login key that signed the data\r\n    function validateLoginKeyMetaTxSigs(\r\n        bytes32 _txDataMessageHash,\r\n        bytes memory _transactionDataSignature,\r\n        bytes memory _loginKeyAuthorizationSignature\r\n    )\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        address transactionDataSigner = _txDataMessageHash.recover(\r\n            _transactionDataSignature\r\n        );\r\n\r\n        bytes32 loginKeyAuthorizationMessageHash = keccak256(abi.encodePacked(\r\n            transactionDataSigner\r\n        )).toEthSignedMessageHash();\r\n\r\n        address authorizationSigner = loginKeyAuthorizationMessageHash.recover(\r\n            _loginKeyAuthorizationSignature\r\n        );\r\n        _validateAuthKey(authorizationSigner);\r\n\r\n        return transactionDataSigner;\r\n    }\r\n\r\n    /// @dev Execute a transaction without a refund\r\n    /// @notice This is the transaction sent from the CBA\r\n    /// @param _destination Destination of the transaction\r\n    /// @param _value Value of the transaction\r\n    /// @param _data Data of the transaction\r\n    /// @param _gasLimit Gas limit of the transaction\r\n    /// @return Response of the call\r\n    function _executeTransaction(\r\n        address _destination,\r\n        uint256 _value,\r\n        bytes memory _data,\r\n        uint256 _gasLimit\r\n    )\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        (bool success, bytes memory response) = _destination.call.gas(_gasLimit).value(_value)(_data);\r\n\r\n        if (!success) {\r\n            bytes32 encodedData = _encodeData(nonce, _destination, _value, _data);\r\n            emit CallFailed(encodedData);\r\n        }\r\n\r\n        // Increment nonce here so that both relayed and non-relayed calls will increment nonce\r\n        // Must be incremented after !success data encode in order to encode original nonce\r\n        nonce++;\r\n\r\n        return response;\r\n    }\r\n\r\n    /// @dev Issue a refund\r\n    /// @param _startGas Starting gas at the beginning of the transaction\r\n    /// @param _gasPrice Gas price to use when sending a refund\r\n    function _issueRefund(\r\n        uint256 _startGas,\r\n        uint256 _gasPrice\r\n    )\r\n        internal\r\n    {\r\n        uint256 _gasUsed = _startGas.sub(gasleft());\r\n        require(_gasUsed.mul(_gasPrice) <= address(this).balance, \"Insufficient gas for refund\");\r\n        msg.sender.transfer(_gasUsed.mul(_gasPrice));\r\n    }\r\n\r\n    /// @dev Get the gas buffer for each transaction\r\n    /// @notice This takes into account the input params as well as the fixed\r\n    /// @notice cost of checking if the account has enough gas left as well as the\r\n    /// @notice transfer to the relayer\r\n    /// @param _txData Input data of the transaction\r\n    /// @return Total cost of input data and final require and transfer\r\n    function _getGasBuffer(bytes memory _txData) internal view returns (uint256) {\r\n        // Input data cost\r\n        uint256 costPerByte = 68;\r\n        uint256 txDataCost = _txData.length * costPerByte;\r\n        \r\n        // Cost of require and transfer\r\n        uint256 costPerCheck = 10000;\r\n        return txDataCost.add(costPerCheck);\r\n    }\r\n\r\n    /// @dev Encode data for a failed transaction\r\n    /// @param _nonce Nonce of the transaction\r\n    /// @param _destination Destination of the transaction\r\n    /// @param _value Value of the transaction\r\n    /// @param _data Data of the transaction\r\n    /// @return Encoded data hash\r\n    function _encodeData(\r\n        uint256 _nonce,\r\n        address _destination,\r\n        uint256 _value,\r\n        bytes memory _data\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\r\n            _nonce,\r\n            _destination,\r\n            _value,\r\n            _data\r\n        ));\r\n    }\r\n\r\n    /// @dev Adds ETH signed message prefix to bytes message and hashes it\r\n    /// @param _msg Bytes message before adding the prefix\r\n    /// @return Prefixed and hashed message\r\n    function _getEthSignedMessageHash(bytes memory _msg) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", _uint2str(_msg.length), _msg));\r\n    }\r\n\r\n    /// @dev Convert uint to string\r\n    /// @param _num Uint to be converted\r\n    /// @return String equivalent of the uint\r\n    function _uint2str(uint _num) private pure returns (string memory _uintAsString) {\r\n        if (_num == 0) {\r\n            return \"0\";\r\n        }\r\n        uint i = _num;\r\n        uint j = _num;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0) {\r\n            bstr[k--] = byte(uint8(48 + i % 10));\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}\r\n\r\n// File: contracts/account/LoginKeyMetaTxAccount.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n/**\r\n * @title LoginKeyMetaTxAccount\r\n * @author Authereum, Inc.\r\n * @dev Contract used by login keys to send transactions. Login key firwall checks\r\n * @dev are performed in this contract as well.\r\n */\r\n\r\ncontract LoginKeyMetaTxAccount is BaseAccount {\r\n\r\n    /// @dev Execute an loginKey meta transaction\r\n    /// @param _destinations Destinations of the transaction\r\n    /// @param _datas Datas of the transaction\r\n    /// @param _values Values of the transaction\r\n    /// @param _gasLimits Gas limits of the transaction\r\n    /// @param _transactionDataSignatures Signed tx datas\r\n    /// @param _loginKeyAuthorizationSignature Signed loginKey\r\n    /// @return Response of the call\r\n    function executeMultipleLoginKeyMetaTx(\r\n        address[] memory _destinations,\r\n        bytes[] memory _datas,\r\n        uint256[] memory _values,\r\n        uint256[] memory _gasLimits,\r\n        bytes[] memory _transactionDataSignatures,\r\n        bytes memory _loginKeyAuthorizationSignature\r\n    )\r\n        public\r\n        returns (bytes[] memory)\r\n    {\r\n        uint256 startGas = gasleft();\r\n\r\n        // Verify data length\r\n        verifyLoginKeyParamDataLength(\r\n            _destinations, _datas, _values, _gasLimits, _transactionDataSignatures\r\n        );\r\n\r\n        // Execute transactions individually\r\n        bytes[] memory returnValues = new bytes[](_destinations.length);\r\n        for(uint i = 0; i < _destinations.length; i++) {\r\n            returnValues[i] = _executeLoginKeyMetaTx(\r\n                _destinations[i], _datas[i], _values[i], _gasLimits[i], _transactionDataSignatures[i], _loginKeyAuthorizationSignature\r\n            );\r\n        }\r\n\r\n        // Refund gas costs\r\n        _issueRefund(startGas, tx.gasprice);\r\n\r\n        return returnValues;\r\n    }\r\n\r\n    /// @dev Check if a loginKey is valid\r\n    /// @param _transactionDataSigner loginKey that signed the tx data\r\n    /// @param _loginKeyAuthorizationSignature Signed loginKey\r\n    /// @return True if login key is valid\r\n    function isValidLoginKey(\r\n        address _transactionDataSigner,\r\n        bytes memory _loginKeyAuthorizationSignature\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes32 loginKeyAuthorizationMessageHash = keccak256(abi.encodePacked(\r\n            _transactionDataSigner\r\n        )).toEthSignedMessageHash();\r\n\r\n        address authorizationSigner = loginKeyAuthorizationMessageHash.recover(\r\n            _loginKeyAuthorizationSignature\r\n        );\r\n\r\n        return authKeys[authorizationSigner];\r\n    }\r\n\r\n    /**\r\n     *  Internal functions\r\n     */\r\n\r\n    /// @dev Execute an loginKey meta transaction\r\n    /// @param _destination Destination of the transaction\r\n    /// @param _data Data of the transaction\r\n    /// @param _value Value of the transaction\r\n    /// @param _gasLimit Gas limit of the transaction\r\n    /// @param _transactionDataSignature Signed tx data\r\n    /// @param _loginKeyAuthorizationSignature Signed loginKey\r\n    /// @return Response of the call\r\n    function _executeLoginKeyMetaTx(\r\n        address _destination,\r\n        bytes memory _data,\r\n        uint256 _value,\r\n        uint256 _gasLimit,\r\n        bytes memory _transactionDataSignature,\r\n        bytes memory _loginKeyAuthorizationSignature\r\n    )\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        uint256 startGas = gasleft();\r\n\r\n        // Login key cannot upgrade the contract\r\n        require(_checkDestination(_destination), \"Login key is not able to upgrade to proxy\");\r\n\r\n        bytes32 _txDataMessageHash = keccak256(abi.encodePacked(\r\n            address(this),\r\n            msg.sig,\r\n            CHAIN_ID,\r\n            _destination,\r\n            _data,\r\n            _value,\r\n            nonce,\r\n            tx.gasprice,\r\n            _gasLimit\r\n        )).toEthSignedMessageHash();\r\n\r\n        validateLoginKeyMetaTxSigs(\r\n            _txDataMessageHash, _transactionDataSignature, _loginKeyAuthorizationSignature\r\n        );\r\n\r\n        return _executeTransaction(\r\n            _destination, _value, _data, _gasLimit\r\n        );\r\n    }\r\n\r\n    /// @dev Verify the length of the input data\r\n    /// @param _destinations Destinations of the transaction\r\n    /// @param _dataArray Data of the transactions\r\n    /// @param _values Values of the transaction\r\n    /// @param _gasLimits Gas limits of the transaction\r\n    /// @param _transactionDataSignatures Signed tx data\r\n     function verifyLoginKeyParamDataLength(\r\n        address[] memory _destinations,\r\n        bytes[] memory _dataArray,\r\n        uint256[] memory _values,\r\n        uint256[] memory _gasLimits,\r\n        bytes[] memory _transactionDataSignatures\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(_destinations.length == _values.length, \"Invalid values length\");\r\n        require(_destinations.length == _dataArray.length, \"Invalid dataArray length\");\r\n        require(_destinations.length == _gasLimits.length, \"Invalid gasLimits length\");\r\n        require(_destinations.length == _transactionDataSignatures.length, \"Invalid transactionDataSignatures length\");\r\n    }\r\n\r\n    /// @dev Check to see if the destination is self.\r\n    /// @notice The login key is not able to upgrade the proxy by transacting with itself.\r\n    /// @notice This transaction will throw if an upgrade is attempted\r\n    /// @param _destination Destination address\r\n    /// @return True if the destination is not self\r\n    function _checkDestination(address _destination) internal view returns (bool) {\r\n        return (address(this) != _destination);\r\n    }\r\n}\r\n\r\n// File: contracts/account/AuthKeyMetaTxAccount.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n/**\r\n * @title AuthKeyMetaTxAccount\r\n * @author Authereum, Inc.\r\n * @dev Contract used by auth keys to send transactions.\r\n */\r\n\r\ncontract AuthKeyMetaTxAccount is BaseAccount {\r\n\r\n    /// @dev Execute multiple authKey meta transactiona\r\n    /// @param _destinations Destinations of the transaction\r\n    /// @param _datas Data of the transactions\r\n    /// @param _values Values of the transaction\r\n    /// @param _gasLimits Gas limits of the transaction\r\n    /// @param _transactionDataSignatures Signed tx data\r\n    function executeMultipleAuthKeyMetaTx(\r\n        address[] memory _destinations,\r\n        bytes[] memory _datas,\r\n        uint256[] memory _values,\r\n        uint256[] memory _gasLimits,\r\n        bytes[] memory _transactionDataSignatures\r\n    )\r\n        public\r\n        returns (bytes[] memory)\r\n    {\r\n        uint256 startGas = gasleft();\r\n\r\n        // Verify data length\r\n        verifyAuthKeyParamDataLength(\r\n            _destinations, _datas, _values, _gasLimits, _transactionDataSignatures\r\n        );\r\n\r\n        // Execute transactions individually\r\n        bytes[] memory returnValues = new bytes[](_destinations.length);\r\n        for(uint i = 0; i < _destinations.length; i++) {\r\n            returnValues[i] = _executeAuthKeyMetaTx(\r\n                _destinations[i], _datas[i], _values[i], _gasLimits[i], _transactionDataSignatures[i]\r\n            );\r\n        }\r\n\r\n        // Refund gas costs\r\n        _issueRefund(startGas, tx.gasprice);\r\n\r\n        return returnValues;\r\n    }\r\n\r\n    /**\r\n     *  Internal functions\r\n     */\r\n\r\n    /// @dev Execute an authKey meta transaction\r\n    /// @param _destination Destination of the transaction\r\n    /// @param _data Data of the transaction\r\n    /// @param _value Value of the transaction\r\n    /// @param _gasLimit Gas limit of the transaction\r\n    /// @param _transactionDataSignature Signed tx data\r\n    /// @return Response of the call\r\n    function _executeAuthKeyMetaTx(\r\n        address _destination,\r\n        bytes memory _data,\r\n        uint256 _value,\r\n        uint256 _gasLimit,\r\n        bytes memory _transactionDataSignature\r\n    )\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        bytes32 _txDataMessageHash = keccak256(abi.encodePacked(\r\n            address(this),\r\n            msg.sig,\r\n            CHAIN_ID,\r\n            _destination,\r\n            _data,\r\n            _value,\r\n            nonce,\r\n            tx.gasprice,\r\n            _gasLimit\r\n        )).toEthSignedMessageHash();\r\n\r\n        // Validate the signer\r\n        _validateAuthKeyMetaTxSigs(\r\n            _txDataMessageHash, _transactionDataSignature\r\n        );\r\n\r\n        return _executeTransaction(\r\n            _destination, _value, _data, _gasLimit\r\n        );\r\n    }\r\n\r\n    /// @dev Verify the length of the input data\r\n    /// @param _destinations Destinations of the transaction\r\n    /// @param _dataArray Data of the transactions\r\n    /// @param _values Values of the transaction\r\n    /// @param _gasLimits Gas limits of the transaction\r\n    /// @param _transactionDataSignatures Signed tx data\r\n     function verifyAuthKeyParamDataLength(\r\n        address[] memory _destinations,\r\n        bytes[] memory _dataArray,\r\n        uint256[] memory _values,\r\n        uint256[] memory _gasLimits,\r\n        bytes[] memory _transactionDataSignatures\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(_destinations.length == _values.length, \"Invalid values length\");\r\n        require(_destinations.length == _dataArray.length, \"Invalid dataArray length\");\r\n        require(_destinations.length == _gasLimits.length, \"Invalid gasLimits length\");\r\n        require(_destinations.length == _transactionDataSignatures.length, \"Invalid gasLimits length\");\r\n    }\r\n}\r\n\r\n// File: contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n *\r\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\r\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\r\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\r\n * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\r\n */\r\nlibrary OpenZeppelinUpgradesAddress {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/account/AccountUpgradeability.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n/**\r\n * @title AccountUpgradeability\r\n * @author Authereum, Inc.\r\n * @dev The upgradeability logic for an Authereum account.\r\n */\r\n\r\ncontract AccountUpgradeability is BaseAccount {\r\n    /// @dev Storage slot with the address of the current implementation.\r\n    /// @notice This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted \r\n    /// @notice by 1, and is validated in the constructor.\r\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /// Only allow this contract to perform upgrade logic\r\n    modifier onlySelf() {\r\n        require(address(this) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /// @dev Upgrades the proxy to the newest implementation of a contract and \r\n    /// @dev forwards a function call to it.\r\n    /// @notice This is useful to initialize the proxied contract.\r\n    /// @param _newImplementation Address of the new implementation.\r\n    /// @param _data Array of initialize data\r\n    function upgradeToAndCall(\r\n        address _newImplementation, \r\n        bytes memory _data\r\n    ) \r\n        public \r\n        onlySelf\r\n    {\r\n        setImplementation(_newImplementation);\r\n        (bool success,) = _newImplementation.delegatecall(_data);\r\n        require(success);\r\n        emit Upgraded(_newImplementation);\r\n    }\r\n\r\n    /// @dev Sets the implementation address of the proxy.\r\n    /// @notice This is only meant to be called when upgrading self\r\n    /// @notice The initial setImplementation for a proxy is set during\r\n    /// @notice the proxy's initialization, not with this call\r\n    /// @param _newImplementation Address of the new implementation.\r\n    function setImplementation(address _newImplementation) internal {\r\n        require(OpenZeppelinUpgradesAddress.isContract(_newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\r\n\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n\r\n        assembly {\r\n            sstore(slot, _newImplementation)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/account/AuthereumAccount.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AuthereumAccount\r\n * @author Authereum, Inc.\r\n * @dev Top-level contract used when creating an Authereum account.\r\n * @dev This contract is meant to only hold the version. All other logic is inherited.\r\n */\r\n\r\ncontract AuthereumAccount is BaseAccount, LoginKeyMetaTxAccount, AuthKeyMetaTxAccount, AccountUpgradeability {\r\n    string constant public authereumVersion = \"2019102500\";\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authKey\",\"type\":\"address\"}],\"name\":\"AddedAuthKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"encodedData\",\"type\":\"bytes32\"}],\"name\":\"CallFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FundsReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InvalidAuthkey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InvalidTransactionDataSigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authKey\",\"type\":\"address\"}],\"name\":\"RemovedAuthKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAuthKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAuthKey\",\"type\":\"address\"}],\"name\":\"SwappedAuthKeys\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authKey\",\"type\":\"address\"}],\"name\":\"addAuthKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_authKeys\",\"type\":\"address[]\"}],\"name\":\"addMultipleAuthKeys\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authKeys\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authereumVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_destinations\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_datas\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_gasLimits\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_transactionDataSignatures\",\"type\":\"bytes[]\"}],\"name\":\"executeMultipleAuthKeyMetaTx\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_destinations\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_datas\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_gasLimits\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_transactionDataSignatures\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes\",\"name\":\"_loginKeyAuthorizationSignature\",\"type\":\"bytes\"}],\"name\":\"executeMultipleLoginKeyMetaTx\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"}],\"name\":\"executeTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authKey\",\"type\":\"address\"}],\"name\":\"initializeV1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_msg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidAuthKeySignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transactionDataSigner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_loginKeyAuthorizationSignature\",\"type\":\"bytes\"}],\"name\":\"isValidLoginKey\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_msg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"isValidLoginKeySignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_msg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signatures\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastInitializedVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numAuthKeys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authKey\",\"type\":\"address\"}],\"name\":\"removeAuthKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_authKeys\",\"type\":\"address[]\"}],\"name\":\"removeMultipleAuthKeys\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldAuthKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newAuthKey\",\"type\":\"address\"}],\"name\":\"swapAuthKeys\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_oldAuthKeys\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_newAuthKeys\",\"type\":\"address[]\"}],\"name\":\"swapMultipleAuthKeys\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_txDataMessageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_transactionDataSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_loginKeyAuthorizationSignature\",\"type\":\"bytes\"}],\"name\":\"validateLoginKeyMetaTxSigs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AuthereumAccount","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://80380f6ece6e2784333874a85f2cd1d7f9092eba8d244a4a3c5ee5fc0e0882c7"}]}