{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/*\r\n * Origin Protocol\r\n * Origin is a protocol for creating peer-to-peer marketplaces using the Ethereum blockchain and IPFS\r\n * https://originprotocol.com\r\n *\r\n * Released under the MIT license\r\n * https://github.com/OriginProtocol\r\n *\r\n * Copyright 2019 Origin Protocol, Inc\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title A Marketplace contract for managing listings, offers, payments, escrow and arbitration\r\n *\r\n * Listings may be priced in ETH or ERC20.\r\n */\r\ncontract V01_Marketplace is Ownable {\r\n\r\n    /**\r\n    * @notice All events have the same indexed signature offsets for easy filtering\r\n    */\r\n    event MarketplaceData  (address indexed party, bytes32 ipfsHash);\r\n    event AffiliateAdded   (address indexed party, bytes32 ipfsHash);\r\n    event AffiliateRemoved (address indexed party, bytes32 ipfsHash);\r\n    event ListingCreated   (address indexed party, uint indexed listingID, bytes32 ipfsHash);\r\n    event ListingUpdated   (address indexed party, uint indexed listingID, bytes32 ipfsHash);\r\n    event ListingWithdrawn (address indexed party, uint indexed listingID, bytes32 ipfsHash);\r\n    event ListingArbitrated(address indexed party, uint indexed listingID, bytes32 ipfsHash);\r\n    event ListingData      (address indexed party, uint indexed listingID, bytes32 ipfsHash);\r\n    event OfferCreated     (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash);\r\n    event OfferAccepted    (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash);\r\n    event OfferFinalized   (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash);\r\n    event OfferWithdrawn   (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash);\r\n    event OfferFundsAdded  (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash);\r\n    event OfferDisputed    (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash);\r\n    event OfferRuling      (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash, uint ruling);\r\n    event OfferData        (address indexed party, uint indexed listingID, uint indexed offerID, bytes32 ipfsHash);\r\n\r\n    struct Listing {\r\n        address seller;     // Seller wallet / identity contract / other contract\r\n        uint deposit;       // Deposit in Origin Token\r\n        address depositManager; // Address that decides token distribution\r\n    }\r\n\r\n    struct Offer {\r\n        uint value;         // Amount in Eth or ERC20 buyer is offering\r\n        uint commission;    // Amount of commission earned if offer is finalized\r\n        uint refund;        // Amount to refund buyer upon finalization\r\n        ERC20 currency;     // Currency of listing\r\n        address buyer;      // Buyer wallet / identity contract / other contract\r\n        address affiliate;  // Address to send any commission\r\n        address arbitrator; // Address that settles disputes\r\n        uint finalizes;     // Timestamp offer finalizes\r\n        uint8 status;       // 0: Undefined, 1: Created, 2: Accepted, 3: Disputed\r\n    }\r\n\r\n    Listing[] public listings;\r\n    mapping(uint => Offer[]) public offers; // listingID => Offers\r\n    mapping(address => bool) public allowedAffiliates;\r\n\r\n    ERC20 public tokenAddr; // Origin Token address\r\n\r\n    constructor(address _tokenAddr) public {\r\n        owner = msg.sender;\r\n        setTokenAddr(_tokenAddr); // Origin Token contract\r\n        allowedAffiliates[0x0] = true; // Allow null affiliate by default\r\n    }\r\n\r\n    // @dev Return the total number of listings\r\n    function totalListings() public view returns (uint) {\r\n        return listings.length;\r\n    }\r\n\r\n    // @dev Return the total number of offers\r\n    function totalOffers(uint listingID) public view returns (uint) {\r\n        return offers[listingID].length;\r\n    }\r\n\r\n    // @dev Seller creates listing\r\n    function createListing(bytes32 _ipfsHash, uint _deposit, address _depositManager)\r\n        public\r\n    {\r\n        _createListing(msg.sender, _ipfsHash, _deposit, _depositManager);\r\n    }\r\n\r\n    // @dev Can only be called by token\r\n    function createListingWithSender(\r\n        address _seller,\r\n        bytes32 _ipfsHash,\r\n        uint _deposit,\r\n        address _depositManager\r\n    )\r\n        public returns (bool)\r\n    {\r\n        require(msg.sender == address(tokenAddr), \"Token must call\");\r\n        _createListing(_seller, _ipfsHash, _deposit, _depositManager);\r\n        return true;\r\n    }\r\n\r\n    // Private\r\n    function _createListing(\r\n        address _seller,\r\n        bytes32 _ipfsHash,  // IPFS JSON with details, pricing, availability\r\n        uint _deposit,      // Deposit in Origin Token\r\n        address _depositManager // Address of listing depositManager\r\n    )\r\n        private\r\n    {\r\n        /* require(_deposit > 0); // Listings must deposit some amount of Origin Token */\r\n        require(_depositManager != 0x0, \"Must specify depositManager\");\r\n\r\n        listings.push(Listing({\r\n            seller: _seller,\r\n            deposit: _deposit,\r\n            depositManager: _depositManager\r\n        }));\r\n\r\n        if (_deposit > 0) {\r\n            tokenAddr.transferFrom(_seller, this, _deposit); // Transfer Origin Token\r\n        }\r\n        emit ListingCreated(_seller, listings.length - 1, _ipfsHash);\r\n    }\r\n\r\n    // @dev Seller updates listing\r\n    function updateListing(\r\n        uint listingID,\r\n        bytes32 _ipfsHash,\r\n        uint _additionalDeposit\r\n    ) public {\r\n        _updateListing(msg.sender, listingID, _ipfsHash, _additionalDeposit);\r\n    }\r\n\r\n    function updateListingWithSender(\r\n        address _seller,\r\n        uint listingID,\r\n        bytes32 _ipfsHash,\r\n        uint _additionalDeposit\r\n    )\r\n        public returns (bool)\r\n    {\r\n        require(msg.sender == address(tokenAddr), \"Token must call\");\r\n        _updateListing(_seller, listingID, _ipfsHash, _additionalDeposit);\r\n        return true;\r\n    }\r\n\r\n    function _updateListing(\r\n        address _seller,\r\n        uint listingID,\r\n        bytes32 _ipfsHash,      // Updated IPFS hash\r\n        uint _additionalDeposit // Additional deposit to add\r\n    ) private {\r\n        Listing storage listing = listings[listingID];\r\n        require(listing.seller == _seller, \"Seller must call\");\r\n\r\n        if (_additionalDeposit > 0) {\r\n            tokenAddr.transferFrom(_seller, this, _additionalDeposit);\r\n            listing.deposit += _additionalDeposit;\r\n        }\r\n\r\n        emit ListingUpdated(listing.seller, listingID, _ipfsHash);\r\n    }\r\n\r\n    // @dev Listing depositManager withdraws listing. IPFS hash contains reason for withdrawl.\r\n    function withdrawListing(uint listingID, address _target, bytes32 _ipfsHash) public {\r\n        Listing storage listing = listings[listingID];\r\n        require(msg.sender == listing.depositManager, \"Must be depositManager\");\r\n        require(_target != 0x0, \"No target\");\r\n        tokenAddr.transfer(_target, listing.deposit); // Send deposit to target\r\n        listing.deposit = 0; // Prevent multiple deposit withdrawals\r\n        emit ListingWithdrawn(_target, listingID, _ipfsHash);\r\n    }\r\n\r\n    // @dev Buyer makes offer.\r\n    function makeOffer(\r\n        uint listingID,\r\n        bytes32 _ipfsHash,   // IPFS hash containing offer data\r\n        uint _finalizes,     // Timestamp an accepted offer will finalize\r\n        address _affiliate,  // Address to send any required commission to\r\n        uint256 _commission, // Amount of commission to send in Origin Token if offer finalizes\r\n        uint _value,         // Offer amount in ERC20 or Eth\r\n        ERC20 _currency,     // ERC20 token address or 0x0 for Eth\r\n        address _arbitrator  // Escrow arbitrator\r\n    )\r\n        public\r\n        payable\r\n    {\r\n        bool affiliateWhitelistDisabled = allowedAffiliates[address(this)];\r\n        require(\r\n            affiliateWhitelistDisabled || allowedAffiliates[_affiliate],\r\n            \"Affiliate not allowed\"\r\n        );\r\n\r\n        if (_affiliate == 0x0) {\r\n            // Avoid commission tokens being trapped in marketplace contract.\r\n            require(_commission == 0, \"commission requires affiliate\");\r\n        }\r\n\r\n        offers[listingID].push(Offer({\r\n            status: 1,\r\n            buyer: msg.sender,\r\n            finalizes: _finalizes,\r\n            affiliate: _affiliate,\r\n            commission: _commission,\r\n            currency: _currency,\r\n            value: _value,\r\n            arbitrator: _arbitrator,\r\n            refund: 0\r\n        }));\r\n\r\n        if (address(_currency) == 0x0) { // Listing is in ETH\r\n            require(msg.value == _value, \"ETH value doesn't match offer\");\r\n        } else { // Listing is in ERC20\r\n            require(msg.value == 0, \"ETH would be lost\");\r\n            require(\r\n                _currency.transferFrom(msg.sender, this, _value),\r\n                \"transferFrom failed\"\r\n            );\r\n        }\r\n\r\n        emit OfferCreated(msg.sender, listingID, offers[listingID].length-1, _ipfsHash);\r\n    }\r\n\r\n    // @dev Make new offer after withdrawl\r\n    function makeOffer(\r\n        uint listingID,\r\n        bytes32 _ipfsHash,\r\n        uint _finalizes,\r\n        address _affiliate,\r\n        uint256 _commission,\r\n        uint _value,\r\n        ERC20 _currency,\r\n        address _arbitrator,\r\n        uint _withdrawOfferID\r\n    )\r\n        public\r\n        payable\r\n    {\r\n        withdrawOffer(listingID, _withdrawOfferID, _ipfsHash);\r\n        makeOffer(listingID, _ipfsHash, _finalizes, _affiliate, _commission, _value, _currency, _arbitrator);\r\n    }\r\n\r\n    // @dev Seller accepts offer\r\n    function acceptOffer(uint listingID, uint offerID, bytes32 _ipfsHash) public {\r\n        Listing storage listing = listings[listingID];\r\n        Offer storage offer = offers[listingID][offerID];\r\n        require(msg.sender == listing.seller, \"Seller must accept\");\r\n        require(offer.status == 1, \"status != created\");\r\n        require(\r\n            listing.deposit >= offer.commission,\r\n            \"deposit must cover commission\"\r\n        );\r\n        if (offer.finalizes < 1000000000) { // Relative finalization window\r\n            offer.finalizes = now + offer.finalizes;\r\n        }\r\n        listing.deposit -= offer.commission; // Accepting an offer puts Origin Token into escrow\r\n        offer.status = 2; // Set offer to 'Accepted'\r\n        emit OfferAccepted(msg.sender, listingID, offerID, _ipfsHash);\r\n    }\r\n\r\n    // @dev Buyer withdraws offer. IPFS hash contains reason for withdrawl.\r\n    function withdrawOffer(uint listingID, uint offerID, bytes32 _ipfsHash) public {\r\n        Listing storage listing = listings[listingID];\r\n        Offer storage offer = offers[listingID][offerID];\r\n        require(\r\n            msg.sender == offer.buyer || msg.sender == listing.seller,\r\n            \"Restricted to buyer or seller\"\r\n        );\r\n        require(offer.status == 1, \"status != created\");\r\n        refundBuyer(listingID, offerID);\r\n        emit OfferWithdrawn(msg.sender, listingID, offerID, _ipfsHash);\r\n        delete offers[listingID][offerID];\r\n    }\r\n\r\n    // @dev Buyer adds extra funds to an accepted offer.\r\n    function addFunds(uint listingID, uint offerID, bytes32 _ipfsHash, uint _value) public payable {\r\n        Offer storage offer = offers[listingID][offerID];\r\n        require(msg.sender == offer.buyer, \"Buyer must call\");\r\n        require(offer.status == 2, \"status != accepted\");\r\n        if (address(offer.currency) == 0x0) { // Listing is in ETH\r\n            require(\r\n                msg.value == _value,\r\n                \"sent != offered value\"\r\n            );\r\n        } else { // Listing is in ERC20\r\n            require(msg.value == 0, \"ETH must not be sent\");\r\n            require(\r\n                offer.currency.transferFrom(msg.sender, this, _value),\r\n                \"transferFrom failed\"\r\n            );\r\n        }\r\n        offer.value += _value;\r\n        emit OfferFundsAdded(msg.sender, listingID, offerID, _ipfsHash);\r\n    }\r\n\r\n    // @dev Buyer must finalize transaction to receive commission\r\n    function finalize(uint listingID, uint offerID, bytes32 _ipfsHash) public {\r\n        Listing storage listing = listings[listingID];\r\n        Offer storage offer = offers[listingID][offerID];\r\n        if (now <= offer.finalizes) { // Only buyer can finalize before finalization window\r\n            require(\r\n                msg.sender == offer.buyer,\r\n                \"Only buyer can finalize\"\r\n            );\r\n        } else { // Allow both seller and buyer to finalize if finalization window has passed\r\n            require(\r\n                msg.sender == offer.buyer || msg.sender == listing.seller,\r\n                \"Seller or buyer must finalize\"\r\n            );\r\n        }\r\n        require(offer.status == 2, \"status != accepted\");\r\n        paySeller(listingID, offerID); // Pay seller\r\n        if (msg.sender == offer.buyer) { // Only pay commission if buyer is finalizing\r\n            payCommission(listingID, offerID);\r\n        } else {\r\n            listing.deposit += offer.commission; // Refund commission to seller\r\n        }\r\n        emit OfferFinalized(msg.sender, listingID, offerID, _ipfsHash);\r\n        delete offers[listingID][offerID];\r\n    }\r\n\r\n    // @dev Buyer or seller can dispute transaction during finalization window\r\n    function dispute(uint listingID, uint offerID, bytes32 _ipfsHash) public {\r\n        Listing storage listing = listings[listingID];\r\n        Offer storage offer = offers[listingID][offerID];\r\n        require(\r\n            msg.sender == offer.buyer || msg.sender == listing.seller,\r\n            \"Must be seller or buyer\"\r\n        );\r\n        require(offer.status == 2, \"status != accepted\");\r\n        require(now <= offer.finalizes, \"Already finalized\");\r\n        offer.status = 3; // Set status to \"Disputed\"\r\n        emit OfferDisputed(msg.sender, listingID, offerID, _ipfsHash);\r\n    }\r\n\r\n    // @dev Called by arbitrator\r\n    function executeRuling(\r\n        uint listingID,\r\n        uint offerID,\r\n        bytes32 _ipfsHash,\r\n        uint _ruling, // 0: Seller, 1: Buyer, 2: Com + Seller, 3: Com + Buyer\r\n        uint _refund\r\n    ) public {\r\n        Offer storage offer = offers[listingID][offerID];\r\n        require(msg.sender == offer.arbitrator, \"Must be arbitrator\");\r\n        require(offer.status == 3, \"status != disputed\");\r\n        require(_refund <= offer.value, \"refund too high\");\r\n        offer.refund = _refund;\r\n        if (_ruling & 1 == 1) {\r\n            refundBuyer(listingID, offerID);\r\n        } else  {\r\n            paySeller(listingID, offerID);\r\n        }\r\n        if (_ruling & 2 == 2) {\r\n            payCommission(listingID, offerID);\r\n        } else  { // Refund commission to seller\r\n            listings[listingID].deposit += offer.commission;\r\n        }\r\n        emit OfferRuling(offer.arbitrator, listingID, offerID, _ipfsHash, _ruling);\r\n        delete offers[listingID][offerID];\r\n    }\r\n\r\n    // @dev Sets the amount that a seller wants to refund to a buyer.\r\n    function updateRefund(uint listingID, uint offerID, uint _refund, bytes32 _ipfsHash) public {\r\n        Offer storage offer = offers[listingID][offerID];\r\n        Listing storage listing = listings[listingID];\r\n        require(msg.sender == listing.seller, \"Seller must call\");\r\n        require(offer.status == 2, \"status != accepted\");\r\n        require(_refund <= offer.value, \"Excessive refund\");\r\n        offer.refund = _refund;\r\n        emit OfferData(msg.sender, listingID, offerID, _ipfsHash);\r\n    }\r\n\r\n    // @dev Refunds buyer in ETH or ERC20 - used by 1) executeRuling() and 2) to allow a seller to refund a purchase\r\n    function refundBuyer(uint listingID, uint offerID) private {\r\n        Offer storage offer = offers[listingID][offerID];\r\n        if (address(offer.currency) == 0x0) {\r\n            require(offer.buyer.send(offer.value), \"ETH refund failed\");\r\n        } else {\r\n            require(\r\n                offer.currency.transfer(offer.buyer, offer.value),\r\n                \"Refund failed\"\r\n            );\r\n        }\r\n    }\r\n\r\n    // @dev Pay seller in ETH or ERC20\r\n    function paySeller(uint listingID, uint offerID) private {\r\n        Listing storage listing = listings[listingID];\r\n        Offer storage offer = offers[listingID][offerID];\r\n        uint value = offer.value - offer.refund;\r\n\r\n        if (address(offer.currency) == 0x0) {\r\n            require(offer.buyer.send(offer.refund), \"ETH refund failed\");\r\n            require(listing.seller.send(value), \"ETH send failed\");\r\n        } else {\r\n            require(\r\n                offer.currency.transfer(offer.buyer, offer.refund),\r\n                \"Refund failed\"\r\n            );\r\n            require(\r\n                offer.currency.transfer(listing.seller, value),\r\n                \"Transfer failed\"\r\n            );\r\n        }\r\n    }\r\n\r\n    // @dev Pay commission to affiliate\r\n    function payCommission(uint listingID, uint offerID) private {\r\n        Offer storage offer = offers[listingID][offerID];\r\n        if (offer.affiliate != 0x0) {\r\n            require(\r\n                tokenAddr.transfer(offer.affiliate, offer.commission),\r\n                \"Commission transfer failed\"\r\n            );\r\n        }\r\n    }\r\n\r\n    // @dev Associate ipfs data with the marketplace\r\n    function addData(bytes32 ipfsHash) public {\r\n        emit MarketplaceData(msg.sender, ipfsHash);\r\n    }\r\n\r\n    // @dev Associate ipfs data with a listing\r\n    function addData(uint listingID, bytes32 ipfsHash) public {\r\n        emit ListingData(msg.sender, listingID, ipfsHash);\r\n    }\r\n\r\n    // @dev Associate ipfs data with an offer\r\n    function addData(uint listingID, uint offerID, bytes32 ipfsHash) public {\r\n        emit OfferData(msg.sender, listingID, offerID, ipfsHash);\r\n    }\r\n\r\n    // @dev Allow listing depositManager to send deposit\r\n    function sendDeposit(uint listingID, address target, uint value, bytes32 ipfsHash) public {\r\n        Listing storage listing = listings[listingID];\r\n        require(listing.depositManager == msg.sender, \"depositManager must call\");\r\n        require(listing.deposit >= value, \"Value too high\");\r\n        listing.deposit -= value;\r\n        require(tokenAddr.transfer(target, value), \"Transfer failed\");\r\n        emit ListingArbitrated(target, listingID, ipfsHash);\r\n    }\r\n\r\n    // @dev Set the address of the Origin token contract\r\n    function setTokenAddr(address _tokenAddr) public onlyOwner {\r\n        tokenAddr = ERC20(_tokenAddr);\r\n    }\r\n\r\n    // @dev Add affiliate to whitelist. Set to address(this) to disable.\r\n    function addAffiliate(address _affiliate, bytes32 ipfsHash) public onlyOwner {\r\n        allowedAffiliates[_affiliate] = true;\r\n        emit AffiliateAdded(_affiliate, ipfsHash);\r\n    }\r\n\r\n    // @dev Remove affiliate from whitelist.\r\n    function removeAffiliate(address _affiliate, bytes32 ipfsHash) public onlyOwner {\r\n        delete allowedAffiliates[_affiliate];\r\n        emit AffiliateRemoved(_affiliate, ipfsHash);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"offerID\",\"type\":\"uint256\"},{\"name\":\"_refund\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"updateRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"addData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"setTokenAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offers\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"commission\",\"type\":\"uint256\"},{\"name\":\"refund\",\"type\":\"uint256\"},{\"name\":\"currency\",\"type\":\"address\"},{\"name\":\"buyer\",\"type\":\"address\"},{\"name\":\"affiliate\",\"type\":\"address\"},{\"name\":\"arbitrator\",\"type\":\"address\"},{\"name\":\"finalizes\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"},{\"name\":\"_finalizes\",\"type\":\"uint256\"},{\"name\":\"_affiliate\",\"type\":\"address\"},{\"name\":\"_commission\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_currency\",\"type\":\"address\"},{\"name\":\"_arbitrator\",\"type\":\"address\"}],\"name\":\"makeOffer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"sendDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"offerID\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"dispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affiliate\",\"type\":\"address\"},{\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"addAffiliate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"offerID\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addFunds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"}],\"name\":\"totalOffers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedAffiliates\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"addData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"offerID\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"acceptOffer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affiliate\",\"type\":\"address\"},{\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"removeAffiliate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"withdrawListing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"},{\"name\":\"_additionalDeposit\",\"type\":\"uint256\"}],\"name\":\"updateListing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"offerID\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"},{\"name\":\"_ruling\",\"type\":\"uint256\"},{\"name\":\"_refund\",\"type\":\"uint256\"}],\"name\":\"executeRuling\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalListings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"},{\"name\":\"_finalizes\",\"type\":\"uint256\"},{\"name\":\"_affiliate\",\"type\":\"address\"},{\"name\":\"_commission\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_currency\",\"type\":\"address\"},{\"name\":\"_arbitrator\",\"type\":\"address\"},{\"name\":\"_withdrawOfferID\",\"type\":\"uint256\"}],\"name\":\"makeOffer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"},{\"name\":\"_deposit\",\"type\":\"uint256\"},{\"name\":\"_depositManager\",\"type\":\"address\"}],\"name\":\"createListing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"},{\"name\":\"_additionalDeposit\",\"type\":\"uint256\"}],\"name\":\"updateListingWithSender\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"offerID\",\"type\":\"uint256\"},{\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"addData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"},{\"name\":\"_deposit\",\"type\":\"uint256\"},{\"name\":\"_depositManager\",\"type\":\"address\"}],\"name\":\"createListingWithSender\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"listings\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"depositManager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"offerID\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"withdrawOffer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"listingID\",\"type\":\"uint256\"},{\"name\":\"offerID\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"MarketplaceData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"AffiliateAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"AffiliateRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"listingID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"ListingCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"listingID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"ListingUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"listingID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"ListingWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"listingID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"ListingArbitrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"listingID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"ListingData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"listingID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"offerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"OfferCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"listingID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"offerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"OfferAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"listingID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"offerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"OfferFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"listingID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"offerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"OfferWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"listingID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"offerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"OfferFundsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"listingID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"offerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"OfferDisputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"listingID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"offerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ruling\",\"type\":\"uint256\"}],\"name\":\"OfferRuling\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"party\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"listingID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"offerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"OfferData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"V01_Marketplace","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008207c1ffc5b6804f6024322ccf34f29c3541ae26","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://0a2899c82766872d634f8c89264ff80533077d03fe448866b0086e0e7b390be3"}]}