{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IERC20 {\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external;\r\n  function transferFrom(address from, address to, uint256 value) external;\r\n  function approve(address spender, uint256 value) external;\r\n}\r\n\r\n\r\n/*\r\n * Implemented by all contracts that a deposit contract can be created with or \r\n * upgraded to\r\n */\r\ninterface IVersionable {\r\n  \r\n  /*\r\n   * Is called by DepositContractRegistry when this version\r\n   * is being upgraded to. Will call `versionEndUsage` on the\r\n   * old contract before calling this one\r\n   */\r\n  function versionBeginUsage(\r\n    address owner, \r\n    address payable depositAddress, \r\n    address oldVersion, \r\n    bytes calldata additionalData\r\n  ) external;\r\n\r\n  /*\r\n   * Is called by DepositContractRegistry when this version is\r\n   * being upgraded from. DepositContractRegistry will then call\r\n   * `versionBeginUsage` on the new contract\r\n   */\r\n  function versionEndUsage(\r\n    address owner,\r\n    address payable depositAddress,\r\n    address newVersion,\r\n    bytes calldata additionalData\r\n  ) external;\r\n}\r\n\r\n\r\n/*\r\n * Types used by the DepositContractRegistry\r\n */\r\nlibrary Types {\r\n\r\n  struct RequestFee {\r\n    address feeRecipient;\r\n    address feeToken;\r\n    uint feeAmount;\r\n  }\r\n\r\n  struct RequestSignature {\r\n    uint8 v; \r\n    bytes32 r; \r\n    bytes32 s;\r\n  }\r\n\r\n  enum RequestType { Update, Transfer }\r\n\r\n  struct Request {\r\n    address owner;\r\n    address target;\r\n    RequestType requestType;\r\n    bytes payload;\r\n    uint nonce;\r\n    RequestFee fee;\r\n    RequestSignature signature;\r\n  }\r\n\r\n  struct UpdateRequest {\r\n    address version;\r\n    bytes additionalData;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Helper functions for a Request struct type\r\n */\r\nlibrary RequestHelper {\r\n\r\n  bytes constant personalPrefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n\r\n  function getSigner(Types.Request memory self) internal pure returns (address) {\r\n    bytes32 messageHash = keccak256(abi.encode(\r\n      self.owner,\r\n      self.target,\r\n      self.requestType,\r\n      self.payload,\r\n      self.nonce,\r\n      abi.encode(self.fee.feeRecipient, self.fee.feeToken, self.fee.feeAmount)\r\n    ));\r\n\r\n    bytes32 prefixedHash = keccak256(abi.encodePacked(personalPrefix, messageHash));\r\n    return ecrecover(prefixedHash, self.signature.v, self.signature.r, self.signature.s);\r\n  }\r\n\r\n  function decodeUpdateRequest(Types.Request memory self) \r\n    internal \r\n    pure \r\n    returns (Types.UpdateRequest memory updateRequest) \r\n  {\r\n    require(self.requestType == Types.RequestType.Update, \"INVALID_REQUEST_TYPE\");\r\n\r\n    (\r\n      updateRequest.version,\r\n      updateRequest.additionalData\r\n    ) = abi.decode(self.payload, (address, bytes));\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Subclassable contract used to manage requests and verify wallet signatures\r\n */\r\ncontract Requestable {\r\n  using RequestHelper for Types.Request;\r\n\r\n  mapping(address => uint) nonces;\r\n\r\n  function validateRequest(Types.Request memory request) internal {\r\n    require(request.target == address(this), \"INVALID_TARGET\");\r\n    require(request.getSigner() == request.owner, \"INVALID_SIGNATURE\");\r\n    require(nonces[request.owner] + 1 == request.nonce, \"INVALID_NONCE\");\r\n    \r\n    if (request.fee.feeAmount > 0) {\r\n      require(balanceOf(request.owner, request.fee.feeToken) >= request.fee.feeAmount, \"INSUFFICIENT_FEE_BALANCE\");\r\n    }\r\n\r\n    nonces[request.owner] += 1;\r\n  }\r\n\r\n  function completeRequest(Types.Request memory request) internal {\r\n    if (request.fee.feeAmount > 0) {\r\n      _payRequestFee(request.owner, request.fee.feeToken, request.fee.feeRecipient, request.fee.feeAmount);\r\n    }\r\n  }\r\n\r\n  function nonceOf(address owner) public view returns (uint) {\r\n    return nonces[owner];\r\n  }\r\n\r\n  // Abtract functions\r\n  function balanceOf(address owner, address token) public view returns (uint);\r\n  function _payRequestFee(address owner, address feeToken, address feeRecipient, uint feeAmount) internal;\r\n}\r\n\r\n\r\n/**\r\n * @title DepositContract\r\n * @author Zack Rubenstein\r\n *\r\n * Allows owner, parent (DepositContractRegistry) and the \r\n * current set version (presumably of Dolomite Direct) to\r\n * call contract functions and transfer Ether from the context\r\n * of this address (pass-though functions).\r\n *\r\n * Using CREATE-2 this address can be sent tokens/Ether before it\r\n * is created.\r\n */\r\ncontract DepositContract {\r\n  address public owner;\r\n  address public parent;\r\n  address public version;\r\n\r\n  constructor(address _owner) public {\r\n    parent = msg.sender;\r\n    owner = _owner;\r\n  }\r\n\r\n  /*\r\n   * Contract can receive Ether\r\n   */\r\n  function() external payable { }\r\n\r\n  /*\r\n   * Set the version that has access to this contracts \r\n   * `transfer` and `perform` functions. Can only be set by\r\n   * the parent (DepositContractRegistry)\r\n   */\r\n  function setVersion(address newVersion) external {\r\n    require(msg.sender == parent);\r\n    version = newVersion;\r\n  }\r\n\r\n  /*\r\n   * Will call a smart contract function from the context of this contract;\r\n   * msg.sender on the receiving end will equal this contract's address.\r\n   *\r\n   * Only the owner, parent (DepositContractRegistry) and version are allowed to call\r\n   * this function. When upgrading versions, make sure the code of the version being\r\n   * upgraded to does not abuse this function.\r\n   *\r\n   * Because the msg.sender of the receiving end will equal this contract's address,\r\n   * this function allows the caller to perform actions such as setting token approvals\r\n   * and wrapping Ether (to WETH).\r\n   *\r\n   * If the signature is an empty string (\"\" where bytes(signature).length == 0) this method\r\n   * will instead execute the transfer function, passing along the specified value\r\n   */\r\n  function perform(\r\n    address addr, \r\n    string calldata signature, \r\n    bytes calldata encodedParams,\r\n    uint value\r\n  ) \r\n    external \r\n    returns (bytes memory) \r\n  {\r\n    require(msg.sender == owner || msg.sender == parent || msg.sender == version, \"NOT_PERMISSIBLE\");\r\n\r\n    if (bytes(signature).length == 0) {\r\n      address(uint160(addr)).transfer(value); // convert address to address payable\r\n    } else {\r\n      bytes4 functionSelector = bytes4(keccak256(bytes(signature)));\r\n      bytes memory payload = abi.encodePacked(functionSelector, encodedParams);\r\n      \r\n      (bool success, bytes memory returnData) = addr.call.value(value)(payload);\r\n      require(success, \"OPERATION_REVERTED\");\r\n\r\n      return returnData;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Helper functions for a DepositContract instance\r\n */\r\nlibrary DepositContractHelper {\r\n\r\n  function wrapAndTransferToken(DepositContract self, address token, address recipient, uint amount, address wethAddress) internal {\r\n    if (token == wethAddress) {\r\n      uint etherBalance = address(self).balance;\r\n      if (etherBalance > 0) wrapEth(self, token, etherBalance);\r\n    }\r\n    transferToken(self, token, recipient, amount);\r\n  }\r\n\r\n  function transferToken(DepositContract self, address token, address recipient, uint amount) internal {\r\n    self.perform(token, \"transfer(address,uint256)\", abi.encode(recipient, amount), 0);\r\n  }\r\n\r\n  function transferEth(DepositContract self, address recipient, uint amount) internal {\r\n    self.perform(recipient, \"\", abi.encode(), amount);\r\n  }\r\n\r\n  function approveToken(DepositContract self, address token, address broker, uint amount) internal {\r\n    self.perform(token, \"approve(address,uint256)\", abi.encode(broker, amount), 0);\r\n  }\r\n\r\n  function wrapEth(DepositContract self, address wethToken, uint amount) internal {\r\n    self.perform(wethToken, \"deposit()\", abi.encode(), amount);\r\n  }\r\n\r\n  function unwrapWeth(DepositContract self, address wethToken, uint amount) internal {\r\n    self.perform(wethToken, \"withdraw(uint256)\", abi.encode(amount), 0);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DepositContractRegistry\r\n * @author Zack Rubenstein\r\n *\r\n * Factory for creating and upgrading DepositContracts using\r\n * user signatures to ensure non-custodianship. Uses CREATE-2 to\r\n * enable deposit addresses to safely receive ERC20 Tokens/Ether prior\r\n * to the deposit contract being deployed\r\n */\r\ncontract DepositContractRegistry is Requestable {\r\n  using DepositContractHelper for DepositContract;\r\n\r\n  event CreatedDepositContract(address indexed owner, address indexed depositAddress);\r\n  event UpgradedVersion(address indexed owner, address indexed depositAddress, address newVersion);\r\n\r\n  bytes constant public DEPOSIT_CONTRACT_BYTECODE = type(DepositContract).creationCode;\r\n\r\n  // =============================\r\n  \r\n  address public wethTokenAddress;\r\n  mapping(address => address payable) public registry;\r\n  mapping(address => address) public versions;\r\n\r\n  constructor(address _wethTokenAddress) public {\r\n    wethTokenAddress = _wethTokenAddress;\r\n  }\r\n\r\n  /*\r\n   * Get the deterministic address of the given address's deposit contract.\r\n   * Whether this contract has been created yet or not, the address returned\r\n   * here will be the address of the deposit address\r\n   */\r\n  function depositAddressOf(address owner) public view returns (address payable) {\r\n    bytes32 codeHash = keccak256(_getCreationBytecode(owner));\r\n    bytes32 addressHash = keccak256(abi.encodePacked(byte(0xff), address(this), uint256(owner), codeHash));\r\n    return address(uint160(uint256(addressHash)));\r\n  }\r\n\r\n  function isDepositContractCreatedFor(address owner) public view returns (bool) {\r\n    return registry[owner] != address(0x0);\r\n  }\r\n\r\n  /*\r\n   * Get the version of the deposit contract for a specified owner address\r\n   */\r\n  function versionOf(address owner) public view returns (address) {\r\n    return versions[owner];\r\n  }\r\n\r\n  /*\r\n   * Get the balance of the given token for the specified address's deposit address\r\n   */\r\n  function balanceOf(address owner, address token) public view returns (uint) {\r\n    address depositAddress = depositAddressOf(owner);\r\n    uint tokenBalance = IERC20(token).balanceOf(depositAddress);\r\n    if (token == wethTokenAddress) tokenBalance = tokenBalance + depositAddress.balance;\r\n    return tokenBalance;\r\n  }\r\n\r\n  /*\r\n   * Create a deposit contract by providing a signed UpgradeRequest.\r\n   * The deposit contract will be created and then immediately upgraded\r\n   * to the version specified in the signed request\r\n   */\r\n  function createDepositContract(Types.Request memory request) public {\r\n    validateRequest(request);\r\n    _createDepositContract(request.owner);\r\n    _upgradeVersion(request);\r\n  }\r\n\r\n  /*\r\n   * Upgrade the version used by a deposit contract by providing a signed UpgradeRequest\r\n   */\r\n  function upgradeVersion(Types.Request memory request) public {\r\n    validateRequest(request);\r\n    _upgradeVersion(request);\r\n  }\r\n\r\n  // =============================\r\n  // Internal functions\r\n\r\n  function _payRequestFee(address owner, address feeToken, address feeRecipient, uint feeAmount) internal {\r\n    DepositContract(registry[owner]).wrapAndTransferToken(feeToken, feeRecipient, feeAmount, wethTokenAddress);\r\n  }\r\n\r\n  function _getCreationBytecode(address owner) private view returns (bytes memory) {\r\n    return abi.encodePacked(DEPOSIT_CONTRACT_BYTECODE, bytes12(0x000000000000000000000000), owner);\r\n  }\r\n\r\n  function _createDepositContract(address owner) private returns (address) {\r\n    require(registry[owner] == address(0x0), \"ALREADY_CREATED\");\r\n\r\n    address payable depositAddress;\r\n    bytes memory code = _getCreationBytecode(owner);\r\n    uint256 salt = uint256(owner);\r\n\r\n    assembly {\r\n      depositAddress := create2(0, add(code, 0x20), mload(code), salt)\r\n      if iszero(extcodesize(depositAddress)) { revert(0, 0) }\r\n    }\r\n\r\n    emit CreatedDepositContract(owner, depositAddress);\r\n\r\n    registry[owner] = depositAddress;\r\n    return depositAddress;\r\n  }\r\n\r\n  function _upgradeVersion(Types.Request memory request) internal {\r\n    require(registry[request.owner] != address(0x0), \"NEEDS_CREATION\");\r\n    \r\n    Types.UpdateRequest memory upgradeRequest = request.decodeUpdateRequest();\r\n    address currentVersion = versions[request.owner];\r\n    address payable depositAddress = registry[request.owner];\r\n\r\n    // End usage of current version if one exists\r\n    if (currentVersion != address(0x0)) {\r\n      IVersionable(currentVersion).versionEndUsage(\r\n        request.owner,\r\n        depositAddress,\r\n        upgradeRequest.version,\r\n        upgradeRequest.additionalData\r\n      );\r\n    }\r\n\r\n    // Payout request fee & set version before upgrading\r\n    completeRequest(request);\r\n    DepositContract(depositAddress).setVersion(upgradeRequest.version);\r\n    versions[request.owner] = upgradeRequest.version;\r\n\r\n    // Begin usage of new version\r\n    IVersionable(upgradeRequest.version).versionBeginUsage(\r\n      request.owner,\r\n      depositAddress,\r\n      currentVersion,\r\n      upgradeRequest.additionalData\r\n    );\r\n\r\n    emit UpgradedVersion(request.owner, depositAddress, upgradeRequest.version);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"requestType\",\"type\":\"uint8\"},{\"name\":\"payload\",\"type\":\"bytes\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"feeRecipient\",\"type\":\"address\"},{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"fee\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"createDepositContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"versionOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"versions\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"requestType\",\"type\":\"uint8\"},{\"name\":\"payload\",\"type\":\"bytes\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"feeRecipient\",\"type\":\"address\"},{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"fee\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"upgradeVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"isDepositContractCreatedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEPOSIT_CONTRACT_BYTECODE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"depositAddressOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_wethTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"depositAddress\",\"type\":\"address\"}],\"name\":\"CreatedDepositContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"depositAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newVersion\",\"type\":\"address\"}],\"name\":\"UpgradedVersion\",\"type\":\"event\"}]","ContractName":"DepositContractRegistry","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","Library":"","LicenseType":"Apache-2.0","SwarmSource":"bzzr://c1dddeea225a8c74a83d3bd79fbbe6f092e585f43be13cc6331d6436d6320ed3"}]}