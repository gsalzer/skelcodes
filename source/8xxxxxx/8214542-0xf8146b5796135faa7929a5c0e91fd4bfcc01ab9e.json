{"status":"1","message":"OK","result":[{"SourceCode":"// File: zos-lib/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.6.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool wasInitializing = initializing;\r\n    initializing = true;\r\n    initialized = true;\r\n\r\n    _;\r\n\r\n    initializing = wasInitializing;\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: openzeppelin-eth/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-eth/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Detailed token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract ERC20Detailed is Initializable, IERC20 {\r\n  string private _name;\r\n  string private _symbol;\r\n  uint8 private _decimals;\r\n\r\n  function initialize(string name, string symbol, uint8 decimals) public initializer {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _decimals = decimals;\r\n  }\r\n\r\n  /**\r\n   * @return the name of the token.\r\n   */\r\n  function name() public view returns(string) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @return the symbol of the token.\r\n   */\r\n  function symbol() public view returns(string) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * @return the number of decimals of the token.\r\n   */\r\n  function decimals() public view returns(uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: openzeppelin-eth/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-eth/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract ERC20 is Initializable, IERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) private _balances;\r\n\r\n  mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return _balances[owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param owner address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address owner,\r\n    address spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    _transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n/**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param from address The address which you want to send tokens from\r\n   * @param to address The address which you want to transfer to\r\n   * @param value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {    \r\n    _transfer(from, to, value);\r\n    _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseAllowance(\r\n    address spender,\r\n    uint256 addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseAllowance(\r\n    address spender,\r\n    uint256 subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified addresses\r\n  * @param from The address to transfer from.\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function _transfer(address from, address to, uint256 value) internal {\r\n    require(value <= _balances[from]);\r\n    require(to != address(0));\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that mints an amount of the token and assigns it to\r\n   * an account. This encapsulates the modification of balances such that the\r\n   * proper events are emitted.\r\n   * @param account The account that will receive the created tokens.\r\n   * @param amount The amount that will be created.\r\n   */\r\n  function _mint(address account, uint256 amount) internal {\r\n    require(account != 0);\r\n    _totalSupply = _totalSupply.add(amount);\r\n    _balances[account] = _balances[account].add(amount);\r\n    emit Transfer(address(0), account, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param amount The amount that will be burnt.\r\n   */\r\n  function _burn(address account, uint256 amount) internal {\r\n    require(account != 0);\r\n    require(amount <= _balances[account]);\r\n\r\n    _totalSupply = _totalSupply.sub(amount);\r\n    _balances[account] = _balances[account].sub(amount);\r\n    emit Transfer(account, address(0), amount);\r\n  }\r\n\r\n  /**\r\n     * @dev Approve an address to spend another addresses' tokens.\r\n     * @param owner The address that owns the tokens.\r\n     * @param spender The address that will spend the tokens.\r\n     * @param value The number of tokens that can be spent.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(spender != address(0));\r\n        require(owner != address(0));\r\n\r\n        _allowed[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account, deducting from the sender's allowance for said account. Uses the\r\n   * internal burn function.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param value The amount that will be burnt.\r\n   */\r\n  function _burnFrom(address account, uint256 value) internal {    \r\n    _burn(account, value);\r\n    _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\r\n  }\r\n\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/token/PropsTimeBasedTransfers.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Props Time Based Transfers\r\n * @dev Contract allows to set a transfer start time (unix timestamp) from which transfers are allowed excluding one address defined in initialize\r\n **/\r\ncontract PropsTimeBasedTransfers is Initializable, ERC20 {\r\n    uint256 public transfersStartTime;\r\n    address public canTransferBeforeStartTime;\r\n    /**\r\n    Contract logic is no longer relevant.\r\n    Leaving in the variables used for upgrade compatibility but the checks are no longer required\r\n    */\r\n\r\n    // modifier canTransfer(address _account)\r\n    // {\r\n    //     require(\r\n    //         now > transfersStartTime ||\r\n    //         _account==canTransferBeforeStartTime,\r\n    //         \"Cannot transfer before transfers start time from this account\"\r\n    //     );\r\n    //     _;\r\n    // }\r\n\r\n    // /**\r\n    // * @dev The initializer function, with transfers start time `transfersStartTime` (unix timestamp)\r\n    // * and `canTransferBeforeStartTime` address which is exempt from start time restrictions\r\n    // * @param start uint Unix timestamp of when transfers can start\r\n    // * @param account uint256 address exempt from the start date check\r\n    // */\r\n    // function initialize(\r\n    //     uint256 start,\r\n    //     address account\r\n    // )\r\n    //     public\r\n    //     initializer\r\n    // {\r\n    //     transfersStartTime = start;\r\n    //     canTransferBeforeStartTime = account;\r\n    // }\r\n    // /**\r\n    // * @dev Transfer token for a specified address if allowed\r\n    // * @param to The address to transfer to.\r\n    // * @param value The amount to be transferred.\r\n    // */\r\n    // function transfer(\r\n    //     address to,\r\n    //     uint256 value\r\n    // )\r\n    // public canTransfer(msg.sender)\r\n    // returns (bool)\r\n    // {\r\n    //     return super.transfer(to, value);\r\n    // }\r\n\r\n    // /**\r\n    //  * @dev Transfer tokens from one address to another if allowed\r\n    //  * Note that while this function emits an Approval event, this is not required as per the specification,\r\n    //  * and other compliant implementations may not emit the event.\r\n    //  * @param from address The address which you want to send tokens from\r\n    //  * @param to address The address which you want to transfer to\r\n    //  * @param value uint256 the amount of tokens to be transferred\r\n    //  */\r\n    // function transferFrom(\r\n    //     address from,\r\n    //     address to,\r\n    //     uint256 value\r\n    // )\r\n    // public canTransfer(from)\r\n    // returns (bool)\r\n    // {\r\n    //     return super.transferFrom(from, to, value);\r\n    // }\r\n}\r\n\r\n// File: openzeppelin-eth/contracts/cryptography/ECDSA.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Elliptic curve signature operations\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n */\r\n\r\nlibrary ECDSA {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes signature)\r\n    internal\r\n    pure\r\n    returns (address)\r\n  {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    // Check the signature length\r\n    if (signature.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    // ecrecover takes the signature parameters, and the only way to get them\r\n    // currently is to use assembly.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      r := mload(add(signature, 32))\r\n      s := mload(add(signature, 64))\r\n      v := byte(0, mload(add(signature, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      // solium-disable-next-line arg-overflow\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * toEthSignedMessageHash\r\n   * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n   * and hash the result\r\n   */\r\n  function toEthSignedMessageHash(bytes32 hash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    // 32 is the length in bytes of hash,\r\n    // enforced by the type signature above\r\n    return keccak256(\r\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n    );\r\n  }\r\n}\r\n\r\n// File: contracts/token/IERC865.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title ERC865 Interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/865\r\n *\r\n */\r\n\r\ncontract IERC865 {\r\n\r\n    event TransferPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\r\n    event ApprovalPreSigned(address indexed from, address indexed to, address indexed delegate, uint256 amount, uint256 fee);\r\n\r\n    function transferPreSigned(\r\n        bytes _signature,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool);\r\n\r\n    function approvePreSigned(\r\n        bytes _signature,\r\n        address _spender,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool);\r\n\r\n    function increaseAllowancePreSigned(\r\n        bytes _signature,\r\n        address _spender,\r\n        uint256 _addedValue,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool);\r\n\r\n    function decreaseAllowancePreSigned(\r\n        bytes _signature,\r\n        address _spender,\r\n        uint256 _subtractedValue,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool);\r\n\r\n    function transferFromPreSigned(\r\n        bytes _signature,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/token/ERC865Token.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC865Token Token\r\n *\r\n * ERC865Token allows users paying transfers in tokens instead of gas\r\n * https://github.com/ethereum/EIPs/issues/865\r\n *\r\n */\r\n\r\ncontract ERC865Token is Initializable, ERC20, IERC865 {\r\n\r\n    /* hashed tx of transfers performed */\r\n    mapping(bytes32 => bool) hashedTxs;\r\n    /**\r\n     * @dev Submit a presigned transfer\r\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\r\n     * @param _signature bytes The signature, issued by the owner.\r\n     * @param _to address The address which you want to transfer to.\r\n     * @param _value uint256 The amount of tokens to be transferred.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function transferPreSigned(\r\n        bytes _signature,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0), \"Invalid _to address\");\r\n\r\n        bytes32 hashedParams = getTransferPreSignedHash(address(this), _to, _value, _fee, _nonce);\r\n        address from = ECDSA.recover(hashedParams, _signature);\r\n        require(from != address(0), \"Invalid from address recovered\");\r\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\r\n        require(hashedTxs[hashedTx] == false,\"Transaction hash was already used\");\r\n        hashedTxs[hashedTx] = true;\r\n        _transfer(from, _to, _value);\r\n        _transfer(from, msg.sender, _fee);\r\n\r\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Submit a presigned approval\r\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\r\n     * @param _signature bytes The signature, issued by the owner.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @param _value uint256 The amount of tokens to allow.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function approvePreSigned(\r\n        bytes _signature,\r\n        address _spender,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_spender != address(0),\"Invalid _spender address\");\r\n\r\n        bytes32 hashedParams = getApprovePreSignedHash(address(this), _spender, _value, _fee, _nonce);\r\n        address from = ECDSA.recover(hashedParams, _signature);\r\n        require(from != address(0),\"Invalid from address recovered\");\r\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\r\n        require(hashedTxs[hashedTx] == false,\"Transaction hash was already used\");\r\n        hashedTxs[hashedTx] = true;\r\n        _approve(from, _spender, _value);\r\n        _transfer(from, msg.sender, _fee);\r\n\r\n        emit ApprovalPreSigned(from, _spender, msg.sender, _value, _fee);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\r\n     * @param _signature bytes The signature, issued by the owner.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function increaseAllowancePreSigned(\r\n        bytes _signature,\r\n        address _spender,\r\n        uint256 _addedValue,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_spender != address(0),\"Invalid _spender address\");\r\n\r\n        bytes32 hashedParams = getIncreaseAllowancePreSignedHash(address(this), _spender, _addedValue, _fee, _nonce);\r\n        address from = ECDSA.recover(hashedParams, _signature);\r\n        require(from != address(0),\"Invalid from address recovered\");\r\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\r\n        require(hashedTxs[hashedTx] == false,\"Transaction hash was already used\");\r\n        hashedTxs[hashedTx] = true;\r\n        _approve(from, _spender, allowance(from, _spender).add(_addedValue));\r\n        _transfer(from, msg.sender, _fee);\r\n\r\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowance(from, _spender), _fee);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\r\n     * @param _signature bytes The signature, issued by the owner\r\n     * @param _spender address The address which will spend the funds.\r\n     * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function decreaseAllowancePreSigned(\r\n        bytes _signature,\r\n        address _spender,\r\n        uint256 _subtractedValue,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_spender != address(0),\"Invalid _spender address\");\r\n\r\n        bytes32 hashedParams = getDecreaseAllowancePreSignedHash(address(this), _spender, _subtractedValue, _fee, _nonce);\r\n        address from = ECDSA.recover(hashedParams, _signature);\r\n        require(from != address(0),\"Invalid from address recovered\");\r\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\r\n        require(hashedTxs[hashedTx] == false,\"Transaction hash was already used\");\r\n        // if substractedValue is greater than allowance will fail as allowance is uint256\r\n        hashedTxs[hashedTx] = true;\r\n        _approve(from, _spender, allowance(from,_spender).sub(_subtractedValue));\r\n        _transfer(from, msg.sender, _fee);\r\n\r\n        emit ApprovalPreSigned(from, _spender, msg.sender, allowance(from, _spender), _fee);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\r\n     * @param _signature bytes The signature, issued by the spender.\r\n     * @param _from address The address which you want to send tokens from.\r\n     * @param _to address The address which you want to transfer to.\r\n     * @param _value uint256 The amount of tokens to be transferred.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function transferFromPreSigned(\r\n        bytes _signature,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0),\"Invalid _to address\");\r\n\r\n        bytes32 hashedParams = getTransferFromPreSignedHash(address(this), _from, _to, _value, _fee, _nonce);\r\n\r\n        address spender = ECDSA.recover(hashedParams, _signature);\r\n        require(spender != address(0),\"Invalid spender address recovered\");\r\n        bytes32 hashedTx = keccak256(abi.encodePacked(spender, hashedParams));\r\n        require(hashedTxs[hashedTx] == false,\"Transaction hash was already used\");\r\n        hashedTxs[hashedTx] = true;\r\n        _transfer(_from, _to, _value);\r\n        _approve(_from, spender, allowance(_from, spender).sub(_value));\r\n        _transfer(spender, msg.sender, _fee);\r\n\r\n        emit TransferPreSigned(_from, _to, msg.sender, _value, _fee);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Hash (keccak256) of the payload used by transferPreSigned\r\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\r\n     * @param _token address The address of the token.\r\n     * @param _to address The address which you want to transfer to.\r\n     * @param _value uint256 The amount of tokens to be transferred.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function getTransferPreSignedHash(\r\n        address _token,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"0d98dcb1\": getTransferPreSignedHash(address,address,uint256,uint256,uint256) */\r\n        return keccak256(abi.encodePacked(bytes4(0x0d98dcb1), _token, _to, _value, _fee, _nonce));\r\n    }\r\n\r\n    /**\r\n     * @dev Hash (keccak256) of the payload used by approvePreSigned\r\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\r\n     * @param _token address The address of the token\r\n     * @param _spender address The address which will spend the funds.\r\n     * @param _value uint256 The amount of tokens to allow.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function getApprovePreSignedHash(\r\n        address _token,\r\n        address _spender,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"79250dcf\": getApprovePreSignedHash(address,address,uint256,uint256,uint256) */\r\n        return keccak256(abi.encodePacked(bytes4(0x79250dcf), _token, _spender, _value, _fee, _nonce));\r\n    }\r\n\r\n    /**\r\n     * @dev Hash (keccak256) of the payload used by increaseAllowancePreSigned\r\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\r\n     * @param _token address The address of the token\r\n     * @param _spender address The address which will spend the funds.\r\n     * @param _addedValue uint256 The amount of tokens to increase the allowance by.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function getIncreaseAllowancePreSignedHash(\r\n        address _token,\r\n        address _spender,\r\n        uint256 _addedValue,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"138e8da1\": getIncreaseAllowancePreSignedHash(address,address,uint256,uint256,uint256) */\r\n        return keccak256(abi.encodePacked(bytes4(0x138e8da1), _token, _spender, _addedValue, _fee, _nonce));\r\n    }\r\n\r\n     /**\r\n      * @dev Hash (keccak256) of the payload used by decreaseAllowancePreSigned\r\n      * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\r\n      * @param _token address The address of the token\r\n      * @param _spender address The address which will spend the funds.\r\n      * @param _subtractedValue uint256 The amount of tokens to decrease the allowance by.\r\n      * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\r\n      * @param _nonce uint256 Presigned transaction number.\r\n      */\r\n    function getDecreaseAllowancePreSignedHash(\r\n        address _token,\r\n        address _spender,\r\n        uint256 _subtractedValue,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"5229c56f\": getDecreaseAllowancePreSignedHash(address,address,uint256,uint256,uint256) */\r\n        return keccak256(abi.encodePacked(bytes4(0x5229c56f), _token, _spender, _subtractedValue, _fee, _nonce));\r\n    }\r\n\r\n    /**\r\n     * @dev Hash (keccak256) of the payload used by transferFromPreSigned\r\n     * @notice fee will be given to sender if it's a smart contract make sure it can accept funds\r\n     * @param _token address The address of the token\r\n     * @param _from address The address which you want to send tokens from.\r\n     * @param _to address The address which you want to transfer to.\r\n     * @param _value uint256 The amount of tokens to be transferred.\r\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the spender.\r\n     * @param _nonce uint256 Presigned transaction number.\r\n     */\r\n    function getTransferFromPreSignedHash(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _fee,\r\n        uint256 _nonce\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        /* \"a70c41b4\": getTransferFromPreSignedHash(address,address,address,uint256,uint256,uint256) */\r\n        return keccak256(abi.encodePacked(bytes4(0xa70c41b4), _token, _from, _to, _value, _fee, _nonce));\r\n    }\r\n}\r\n\r\n// File: contracts/token/PropsRewardsLib.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Props Rewards Library\r\n * @dev Library to manage application and validators and parameters\r\n **/\r\nlibrary PropsRewardsLib {\r\n    using SafeMath for uint256;\r\n    /*\r\n    *  Events\r\n    */\r\n\r\n    /*\r\n    *  Storage\r\n    */\r\n\r\n    // The various parameters used by the contract\r\n    enum ParameterName { ApplicationRewardsPercent, ApplicationRewardsMaxVariationPercent, ValidatorMajorityPercent, ValidatorRewardsPercent}\r\n    enum RewardedEntityType { Application, Validator }\r\n\r\n    // Represents a parameter current, previous and time of change\r\n    struct Parameter {\r\n        uint256 currentValue;                   // current value in Pphm valid after timestamp\r\n        uint256 previousValue;                  // previous value in Pphm for use before timestamp\r\n        uint256 rewardsDay;                     // timestamp of when the value was updated\r\n    }\r\n    // Represents application details\r\n    struct RewardedEntity {\r\n        bytes32 name;                           // Application name\r\n        address rewardsAddress;                 // address where rewards will be minted to\r\n        address sidechainAddress;               // address used on the sidechain\r\n        bool isInitializedState;                // A way to check if there's something in the map and whether it is already added to the list\r\n        RewardedEntityType entityType;          // Type of rewarded entity\r\n    }\r\n\r\n    // Represents validators current and previous lists\r\n    struct RewardedEntityList {\r\n        mapping (address => bool) current;\r\n        mapping (address => bool) previous;\r\n        address[] currentList;\r\n        address[] previousList;\r\n        uint256 rewardsDay;\r\n    }\r\n\r\n    // Represents daily rewards submissions and confirmations\r\n    struct DailyRewards {\r\n        mapping (bytes32 => Submission) submissions;\r\n        bytes32[] submittedRewardsHashes;\r\n        uint256 totalSupply;\r\n        bytes32 lastConfirmedRewardsHash;\r\n        uint256 lastApplicationsRewardsDay;\r\n    }\r\n\r\n    struct Submission {\r\n        mapping (address => bool) validators;\r\n        address[] validatorsList;\r\n        uint256 confirmations;\r\n        uint256 finalizedStatus;               // 0 - initialized, 1 - finalized\r\n        bool isInitializedState;               // A way to check if there's something in the map and whether it is already added to the list\r\n    }\r\n\r\n\r\n    // represent the storage structures\r\n    struct Data {\r\n        // applications data\r\n        mapping (address => RewardedEntity) applications;\r\n        address[] applicationsList;\r\n        // validators data\r\n        mapping (address => RewardedEntity) validators;\r\n        address[] validatorsList;\r\n        // adjustable parameters data\r\n        mapping (uint256 => Parameter) parameters; // uint256 is the parameter enum index\r\n        // the participating validators\r\n        RewardedEntityList selectedValidators;\r\n        // the participating applications\r\n        RewardedEntityList selectedApplications;\r\n        // daily rewards submission data\r\n        DailyRewards dailyRewards;\r\n        uint256 minSecondsBetweenDays;\r\n        uint256 rewardsStartTimestamp;\r\n        uint256 maxTotalSupply;\r\n        uint256 lastValidatorsRewardsDay;\r\n    }\r\n    /*\r\n    *  Modifiers\r\n    */\r\n    modifier onlyOneConfirmationPerValidatorPerRewardsHash(Data storage _self, bytes32 _rewardsHash) {\r\n        require(\r\n            !_self.dailyRewards.submissions[_rewardsHash].validators[msg.sender],\r\n            \"Must be one submission per validator\"\r\n        );\r\n         _;\r\n    }\r\n\r\n    modifier onlyExistingApplications(Data storage _self, address[] _entities) {\r\n        for (uint256 i = 0; i < _entities.length; i++) {\r\n            require(\r\n                _self.applications[_entities[i]].isInitializedState,\r\n                \"Application must exist\"\r\n            );\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyExistingValidators(Data storage _self, address[] _entities) {\r\n        for (uint256 i = 0; i < _entities.length; i++) {\r\n            require(\r\n                _self.validators[_entities[i]].isInitializedState,\r\n                \"Validator must exist\"\r\n            );\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlySelectedValidators(Data storage _self, uint256 _rewardsDay) {\r\n        if (!_usePreviousSelectedRewardsEntityList(_self.selectedValidators, _rewardsDay)) {\r\n            require (\r\n                _self.selectedValidators.current[msg.sender],\r\n                \"Must be a current selected validator\"\r\n            );\r\n        } else {\r\n            require (\r\n                _self.selectedValidators.previous[msg.sender],\r\n                \"Must be a previous selected validator\"\r\n            );\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidRewardsDay(Data storage _self, uint256 _rewardsDay) {\r\n        require(\r\n            _currentRewardsDay(_self) > _rewardsDay && _rewardsDay > _self.lastValidatorsRewardsDay,\r\n            \"Must be for a previous day but after the last rewards day\"\r\n        );\r\n         _;\r\n    }\r\n\r\n    modifier onlyValidFutureRewardsDay(Data storage _self, uint256 _rewardsDay) {\r\n        require(\r\n            _rewardsDay >= _currentRewardsDay(_self),\r\n            \"Must be future rewardsDay\"\r\n        );\r\n         _;\r\n    }\r\n\r\n    modifier onlyValidAddresses(address _rewardsAddress, address _sidechainAddress) {\r\n        require(\r\n            _rewardsAddress != address(0) &&\r\n            _sidechainAddress != address(0),\r\n            \"Must have valid rewards and sidechain addresses\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev The function is called by validators with the calculation of the daily rewards\r\n    * @param _self Data pointer to storage\r\n    * @param _rewardsDay uint256 the rewards day\r\n    * @param _rewardsHash bytes32 hash of the rewards data\r\n    * @param _allValidators bool should the calculation be based on all the validators or just those which submitted\r\n    */\r\n    function calculateValidatorRewards(\r\n        Data storage _self,\r\n        uint256 _rewardsDay,\r\n        bytes32 _rewardsHash,\r\n        bool _allValidators\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 numOfValidators;\r\n        if (_self.dailyRewards.submissions[_rewardsHash].finalizedStatus == 1)\r\n        {\r\n            if (_allValidators) {\r\n                numOfValidators = _requiredValidatorsForValidatorsRewards(_self, _rewardsDay);\r\n                if (numOfValidators > _self.dailyRewards.submissions[_rewardsHash].confirmations) return 0;\r\n            } else {\r\n                numOfValidators = _self.dailyRewards.submissions[_rewardsHash].confirmations;\r\n            }\r\n            uint256 rewardsPerValidator = _getValidatorRewardsDailyAmountPerValidator(_self, _rewardsDay, numOfValidators);\r\n            return rewardsPerValidator;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n    * @dev The function is called by validators with the calculation of the daily rewards\r\n    * @param _self Data pointer to storage\r\n    * @param _rewardsDay uint256 the rewards day\r\n    * @param _rewardsHash bytes32 hash of the rewards data\r\n    * @param _applications address[] array of application addresses getting the daily reward\r\n    * @param _amounts uint256[] array of amounts each app should get\r\n    * @param _currentTotalSupply uint256 current total supply\r\n    */\r\n    function calculateAndFinalizeApplicationRewards(\r\n        Data storage _self,\r\n        uint256 _rewardsDay,\r\n        bytes32 _rewardsHash,\r\n        address[] _applications,\r\n        uint256[] _amounts,\r\n        uint256 _currentTotalSupply\r\n    )\r\n        public\r\n        onlyValidRewardsDay(_self, _rewardsDay)\r\n        onlyOneConfirmationPerValidatorPerRewardsHash(_self, _rewardsHash)\r\n        onlySelectedValidators(_self, _rewardsDay)\r\n        returns (uint256)\r\n    {\r\n        require(\r\n                _rewardsHashIsValid(_self, _rewardsDay, _rewardsHash, _applications, _amounts),\r\n                \"Rewards Hash is invalid\"\r\n        );\r\n        if (!_self.dailyRewards.submissions[_rewardsHash].isInitializedState) {\r\n            _self.dailyRewards.submissions[_rewardsHash].isInitializedState = true;\r\n            _self.dailyRewards.submittedRewardsHashes.push(_rewardsHash);\r\n        }\r\n        _self.dailyRewards.submissions[_rewardsHash].validators[msg.sender] = true;\r\n        _self.dailyRewards.submissions[_rewardsHash].validatorsList.push(msg.sender);\r\n        _self.dailyRewards.submissions[_rewardsHash].confirmations++;\r\n\r\n        if (_self.dailyRewards.submissions[_rewardsHash].confirmations == _requiredValidatorsForAppRewards(_self, _rewardsDay)) {\r\n            uint256 sum = _validateSubmittedData(_self, _applications, _amounts);\r\n            require(\r\n                sum <= _getMaxAppRewardsDailyAmount(_self, _rewardsDay, _currentTotalSupply),\r\n                \"Rewards data is invalid - exceed daily variation\"\r\n            );\r\n            _finalizeDailyApplicationRewards(_self, _rewardsDay, _rewardsHash, _currentTotalSupply);\r\n            return sum;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Finalizes the state, rewards Hash, total supply and block timestamp for the day\r\n    * @param _self Data pointer to storage\r\n    * @param _rewardsDay uint256 the rewards day\r\n    * @param _rewardsHash bytes32 the daily rewards hash\r\n    * @param _currentTotalSupply uint256 the current total supply\r\n    */\r\n    function _finalizeDailyApplicationRewards(Data storage _self, uint256 _rewardsDay, bytes32 _rewardsHash, uint256 _currentTotalSupply)\r\n        public\r\n    {\r\n        _self.dailyRewards.totalSupply = _currentTotalSupply;\r\n        _self.dailyRewards.lastConfirmedRewardsHash = _rewardsHash;\r\n        _self.dailyRewards.lastApplicationsRewardsDay = _rewardsDay;\r\n        _self.dailyRewards.submissions[_rewardsHash].finalizedStatus = 1;\r\n    }\r\n\r\n    /**\r\n    * @dev Get parameter's value\r\n    * @param _self Data pointer to storage\r\n    * @param _name ParameterName name of the parameter\r\n    * @param _rewardsDay uint256 the rewards day\r\n    */\r\n    function getParameterValue(\r\n        Data storage _self,\r\n        ParameterName _name,\r\n        uint256 _rewardsDay\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (_rewardsDay >= _self.parameters[uint256(_name)].rewardsDay) {\r\n            return _self.parameters[uint256(_name)].currentValue;\r\n        } else {\r\n            return _self.parameters[uint256(_name)].previousValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the controller/owner to update rewards parameters\r\n    * @param _self Data pointer to storage\r\n    * @param _name ParameterName name of the parameter\r\n    * @param _value uint256 new value for the parameter\r\n    * @param _rewardsDay uint256 the rewards day\r\n    */\r\n    function updateParameter(\r\n        Data storage _self,\r\n        ParameterName _name,\r\n        uint256 _value,\r\n        uint256 _rewardsDay\r\n    )\r\n        public\r\n        onlyValidFutureRewardsDay(_self, _rewardsDay)\r\n    {\r\n        if (_rewardsDay <= _self.parameters[uint256(_name)].rewardsDay) {\r\n           _self.parameters[uint256(_name)].currentValue = _value;\r\n           _self.parameters[uint256(_name)].rewardsDay = _rewardsDay;\r\n        } else {\r\n            _self.parameters[uint256(_name)].previousValue = _self.parameters[uint256(_name)].currentValue;\r\n            _self.parameters[uint256(_name)].currentValue = _value;\r\n           _self.parameters[uint256(_name)].rewardsDay = _rewardsDay;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows an application to add/update its details\r\n    * @param _self Data pointer to storage\r\n    * @param _entityType RewardedEntityType either application (0) or validator (1)\r\n    * @param _name bytes32 name of the app\r\n    * @param _rewardsAddress address an address for the app to receive the rewards\r\n    * @param _sidechainAddress address the address used for using the sidechain\r\n    */\r\n    function updateEntity(\r\n        Data storage _self,\r\n        RewardedEntityType _entityType,\r\n        bytes32 _name,\r\n        address _rewardsAddress,\r\n        address _sidechainAddress\r\n    )\r\n        public\r\n        onlyValidAddresses(_rewardsAddress, _sidechainAddress)\r\n    {\r\n        if (_entityType == RewardedEntityType.Application) {\r\n            updateApplication(_self, _name, _rewardsAddress, _sidechainAddress);\r\n        } else {\r\n            updateValidator(_self, _name, _rewardsAddress, _sidechainAddress);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows an application to add/update its details\r\n    * @param _self Data pointer to storage\r\n    * @param _name bytes32 name of the app\r\n    * @param _rewardsAddress address an address for the app to receive the rewards\r\n    * @param _sidechainAddress address the address used for using the sidechain\r\n    */\r\n    function updateApplication(\r\n        Data storage _self,\r\n        bytes32 _name,\r\n        address _rewardsAddress,\r\n        address _sidechainAddress\r\n    )\r\n        public\r\n        returns (uint256)\r\n    {\r\n        _self.applications[msg.sender].name = _name;\r\n        _self.applications[msg.sender].rewardsAddress = _rewardsAddress;\r\n        _self.applications[msg.sender].sidechainAddress = _sidechainAddress;\r\n        if (!_self.applications[msg.sender].isInitializedState) {\r\n            _self.applicationsList.push(msg.sender);\r\n            _self.applications[msg.sender].isInitializedState = true;\r\n            _self.applications[msg.sender].entityType = RewardedEntityType.Application;\r\n        }\r\n        return uint256(RewardedEntityType.Application);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows a validator to add/update its details\r\n    * @param _self Data pointer to storage\r\n    * @param _name bytes32 name of the validator\r\n    * @param _rewardsAddress address an address for the validator to receive the rewards\r\n    * @param _sidechainAddress address the address used for using the sidechain\r\n    */\r\n    function updateValidator(\r\n        Data storage _self,\r\n        bytes32 _name,\r\n        address _rewardsAddress,\r\n        address _sidechainAddress\r\n    )\r\n        public\r\n        returns (uint256)\r\n    {\r\n        _self.validators[msg.sender].name = _name;\r\n        _self.validators[msg.sender].rewardsAddress = _rewardsAddress;\r\n        _self.validators[msg.sender].sidechainAddress = _sidechainAddress;\r\n        if (!_self.validators[msg.sender].isInitializedState) {\r\n            _self.validatorsList.push(msg.sender);\r\n            _self.validators[msg.sender].isInitializedState = true;\r\n            _self.validators[msg.sender].entityType = RewardedEntityType.Validator;\r\n        }\r\n        return uint256(RewardedEntityType.Validator);\r\n    }\r\n\r\n    /**\r\n    * @dev Set new validators list\r\n    * @param _self Data pointer to storage\r\n    * @param _rewardsDay uint256 the rewards day from which the list should be active\r\n    * @param _validators address[] array of validators\r\n    */\r\n    function setValidators(\r\n        Data storage _self,\r\n        uint256 _rewardsDay,\r\n        address[] _validators\r\n    )\r\n        public\r\n        onlyValidFutureRewardsDay(_self, _rewardsDay)\r\n        onlyExistingValidators(_self, _validators)\r\n    {\r\n        // no need to update the previous if its' the first time or second update in the same day\r\n        if (_rewardsDay > _self.selectedValidators.rewardsDay && _self.selectedValidators.currentList.length > 0)\r\n            _updatePreviousEntityList(_self.selectedValidators);\r\n\r\n        _updateCurrentEntityList(_self.selectedValidators, _validators);\r\n        _self.selectedValidators.rewardsDay = _rewardsDay;\r\n    }\r\n\r\n   /**\r\n    * @dev Set new applications list\r\n    * @param _self Data pointer to storage\r\n    * @param _rewardsDay uint256 the rewards day from which the list should be active\r\n    * @param _applications address[] array of applications\r\n    */\r\n    function setApplications(\r\n        Data storage _self,\r\n        uint256 _rewardsDay,\r\n        address[] _applications\r\n    )\r\n        public\r\n        onlyValidFutureRewardsDay(_self, _rewardsDay)\r\n        onlyExistingApplications(_self, _applications)\r\n    {\r\n\r\n        if (_rewardsDay > _self.selectedApplications.rewardsDay && _self.selectedApplications.currentList.length > 0)\r\n                _updatePreviousEntityList(_self.selectedApplications);\r\n        _updateCurrentEntityList(_self.selectedApplications, _applications);\r\n        _self.selectedApplications.rewardsDay = _rewardsDay;\r\n    }\r\n\r\n    /**\r\n    * @dev Get applications or validators list\r\n    * @param _self Data pointer to storage\r\n    * @param _entityType RewardedEntityType either application (0) or validator (1)\r\n    * @param _rewardsDay uint256 the rewards day to determine which list to get\r\n    */\r\n    function getEntities(\r\n        Data storage _self,\r\n        RewardedEntityType _entityType,\r\n        uint256 _rewardsDay\r\n    )\r\n        public\r\n        view\r\n        returns (address[])\r\n    {\r\n        if (_entityType == RewardedEntityType.Application) {\r\n            if (!_usePreviousSelectedRewardsEntityList(_self.selectedApplications, _rewardsDay)) {\r\n                return _self.selectedApplications.currentList;\r\n            } else {\r\n                return _self.selectedApplications.previousList;\r\n            }\r\n        } else {\r\n            if (!_usePreviousSelectedRewardsEntityList(_self.selectedValidators, _rewardsDay)) {\r\n                return _self.selectedValidators.currentList;\r\n            } else {\r\n                return _self.selectedValidators.previousList;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Get which entity list to use. If true use previous if false use current\r\n    * @param _rewardedEntitylist RewardedEntityList pointer to storage\r\n    * @param _rewardsDay uint256 the rewards day to determine which list to get\r\n    */\r\n    function _usePreviousSelectedRewardsEntityList(RewardedEntityList _rewardedEntitylist, uint256 _rewardsDay)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (_rewardsDay >= _rewardedEntitylist.rewardsDay) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Checks how many validators are needed for app rewards\r\n    * @param _self Data pointer to storage\r\n    * @param _rewardsDay uint256 the rewards day\r\n    * @param _currentTotalSupply uint256 current total supply\r\n    */\r\n    function _getMaxAppRewardsDailyAmount(\r\n        Data storage _self,\r\n        uint256 _rewardsDay,\r\n        uint256 _currentTotalSupply\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return ((_self.maxTotalSupply.sub(_currentTotalSupply)).mul(\r\n        getParameterValue(_self, ParameterName.ApplicationRewardsPercent, _rewardsDay)).mul(\r\n        getParameterValue(_self, ParameterName.ApplicationRewardsMaxVariationPercent, _rewardsDay))).div(1e16);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Checks how many validators are needed for app rewards\r\n    * @param _self Data pointer to storage\r\n    * @param _rewardsDay uint256 the rewards day\r\n    * @param _numOfValidators uint256 number of validators\r\n    */\r\n    function _getValidatorRewardsDailyAmountPerValidator(\r\n        Data storage _self,\r\n        uint256 _rewardsDay,\r\n        uint256 _numOfValidators\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return (((_self.maxTotalSupply.sub(_self.dailyRewards.totalSupply)).mul(\r\n        getParameterValue(_self, ParameterName.ValidatorRewardsPercent, _rewardsDay))).div(1e8)).div(_numOfValidators);\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if app daily rewards amount is valid\r\n    * @param _self Data pointer to storage\r\n    * @param _applications address[] array of application addresses getting the daily rewards\r\n    * @param _amounts uint256[] array of amounts each app should get\r\n    */\r\n    function _validateSubmittedData(\r\n        Data storage _self,\r\n        address[] _applications,\r\n        uint256[] _amounts\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 sum;\r\n        bool valid = true;\r\n        for (uint256 i = 0; i < _amounts.length; i++) {\r\n            sum = sum.add(_amounts[i]);\r\n            if (!_self.applications[_applications[i]].isInitializedState) valid = false;\r\n        }\r\n        require(\r\n                sum > 0 && valid,\r\n                \"Sum zero or none existing app submitted\"\r\n        );\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if submitted data matches rewards hash\r\n    * @param _rewardsDay uint256 the rewards day\r\n    * @param _rewardsHash bytes32 hash of the rewards data\r\n    * @param _applications address[] array of application addresses getting the daily rewards\r\n    * @param _amounts uint256[] array of amounts each app should get\r\n    */\r\n    function _rewardsHashIsValid(\r\n        Data storage _self,\r\n        uint256 _rewardsDay,\r\n        bytes32 _rewardsHash,\r\n        address[] _applications,\r\n        uint256[] _amounts\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool nonActiveApplication = false;\r\n        if (!_usePreviousSelectedRewardsEntityList(_self.selectedApplications, _rewardsDay)) {\r\n            for (uint256 i = 0; i < _applications.length; i++) {\r\n                if (!_self.selectedApplications.current[_applications[i]]) {\r\n                    nonActiveApplication = true;\r\n                }\r\n            }\r\n        } else {\r\n            for (uint256 j = 0; j < _applications.length; j++) {\r\n                if (!_self.selectedApplications.previous[_applications[j]]) {\r\n                    nonActiveApplication = true;\r\n                }\r\n            }\r\n        }\r\n        return\r\n            _applications.length > 0 &&\r\n            _applications.length == _amounts.length &&\r\n            !nonActiveApplication &&\r\n            keccak256(abi.encodePacked(_rewardsDay, _applications.length, _amounts.length, _applications, _amounts)) == _rewardsHash;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks how many validators are needed for app rewards\r\n    * @param _self Data pointer to storage\r\n    * @param _rewardsDay uint256 the rewards day\r\n    */\r\n    function _requiredValidatorsForValidatorsRewards(Data storage _self, uint256 _rewardsDay)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (!_usePreviousSelectedRewardsEntityList(_self.selectedValidators, _rewardsDay)) {\r\n            return _self.selectedValidators.currentList.length;\r\n        } else {\r\n            return _self.selectedValidators.previousList.length;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Checks how many validators are needed for app rewards\r\n    * @param _self Data pointer to storage\r\n    * @param _rewardsDay uint256 the rewards day\r\n    */\r\n    function _requiredValidatorsForAppRewards(Data storage _self, uint256 _rewardsDay)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (!_usePreviousSelectedRewardsEntityList(_self.selectedValidators, _rewardsDay)) {\r\n            return ((_self.selectedValidators.currentList.length.mul(getParameterValue(_self, ParameterName.ValidatorMajorityPercent, _rewardsDay))).div(1e8)).add(1);\r\n        } else {\r\n            return ((_self.selectedValidators.previousList.length.mul(getParameterValue(_self, ParameterName.ValidatorMajorityPercent, _rewardsDay))).div(1e8)).add(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Get rewards day from block.timestamp\r\n    * @param _self Data pointer to storage\r\n    */\r\n    function _currentRewardsDay(Data storage _self)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //the the start time - floor timestamp to previous midnight divided by seconds in a day will give the rewards day number\r\n       if (_self.minSecondsBetweenDays > 0) {\r\n            return (block.timestamp.sub(_self.rewardsStartTimestamp)).div(_self.minSecondsBetweenDays).add(1);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Update current daily applications list.\r\n    * If new, push.\r\n    * If same size, replace\r\n    * If different size, delete, and then push.\r\n    * @param _rewardedEntitylist RewardedEntityList pointer to storage\r\n    * @param _entities address[] array of entities\r\n    */\r\n    //_updateCurrentEntityList(_rewardedEntitylist, _entities,_rewardedEntityType),\r\n    function _updateCurrentEntityList(\r\n        RewardedEntityList storage _rewardedEntitylist,\r\n        address[] _entities\r\n    )\r\n        internal\r\n    {\r\n        bool emptyCurrentList = _rewardedEntitylist.currentList.length == 0;\r\n        if (!emptyCurrentList && _rewardedEntitylist.currentList.length != _entities.length) {\r\n            _deleteCurrentEntityList(_rewardedEntitylist);\r\n            emptyCurrentList = true;\r\n        }\r\n\r\n        for (uint256 i = 0; i < _entities.length; i++) {\r\n            if (emptyCurrentList) {\r\n                _rewardedEntitylist.currentList.push(_entities[i]);\r\n            } else {\r\n                _rewardedEntitylist.currentList[i] = _entities[i];\r\n            }\r\n            _rewardedEntitylist.current[_entities[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Update previous daily list\r\n    * @param _rewardedEntitylist RewardedEntityList pointer to storage\r\n    */\r\n    function _updatePreviousEntityList(RewardedEntityList storage _rewardedEntitylist)\r\n        internal\r\n    {\r\n        bool emptyPreviousList = _rewardedEntitylist.previousList.length == 0;\r\n        if (\r\n            !emptyPreviousList &&\r\n            _rewardedEntitylist.previousList.length != _rewardedEntitylist.currentList.length\r\n        ) {\r\n            _deletePreviousEntityList(_rewardedEntitylist);\r\n            emptyPreviousList = true;\r\n        }\r\n        for (uint256 i = 0; i < _rewardedEntitylist.currentList.length; i++) {\r\n            if (emptyPreviousList) {\r\n                _rewardedEntitylist.previousList.push(_rewardedEntitylist.currentList[i]);\r\n            } else {\r\n                _rewardedEntitylist.previousList[i] = _rewardedEntitylist.currentList[i];\r\n            }\r\n            _rewardedEntitylist.previous[_rewardedEntitylist.currentList[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Delete existing values from the current list\r\n    * @param _rewardedEntitylist RewardedEntityList pointer to storage\r\n    */\r\n    function _deleteCurrentEntityList(RewardedEntityList storage _rewardedEntitylist)\r\n        internal\r\n    {\r\n        for (uint256 i = 0; i < _rewardedEntitylist.currentList.length ; i++) {\r\n             delete _rewardedEntitylist.current[_rewardedEntitylist.currentList[i]];\r\n        }\r\n        delete  _rewardedEntitylist.currentList;\r\n    }\r\n\r\n    /**\r\n    * @dev Delete existing values from the previous applications list\r\n    * @param _rewardedEntitylist RewardedEntityList pointer to storage\r\n    */\r\n    function _deletePreviousEntityList(RewardedEntityList storage _rewardedEntitylist)\r\n        internal\r\n    {\r\n        for (uint256 i = 0; i < _rewardedEntitylist.previousList.length ; i++) {\r\n            delete _rewardedEntitylist.previous[_rewardedEntitylist.previousList[i]];\r\n        }\r\n        delete _rewardedEntitylist.previousList;\r\n    }\r\n\r\n    /**\r\n    * @dev Deletes rewards day submission data\r\n    * @param _self Data pointer to storage\r\n    * @param _rewardsHash bytes32 rewardsHash\r\n    */\r\n    function _resetDailyRewards(\r\n        Data storage _self,\r\n        bytes32 _rewardsHash\r\n    )\r\n        public\r\n    {\r\n         _self.lastValidatorsRewardsDay = _self.dailyRewards.lastApplicationsRewardsDay;\r\n        for (uint256 j = 0; j < _self.dailyRewards.submissions[_rewardsHash].validatorsList.length; j++) {\r\n            delete(\r\n                _self.dailyRewards.submissions[_rewardsHash].validators[_self.dailyRewards.submissions[_rewardsHash].validatorsList[j]]\r\n            );\r\n        }\r\n            delete _self.dailyRewards.submissions[_rewardsHash].validatorsList;\r\n            _self.dailyRewards.submissions[_rewardsHash].confirmations = 0;\r\n            _self.dailyRewards.submissions[_rewardsHash].finalizedStatus = 0;\r\n            _self.dailyRewards.submissions[_rewardsHash].isInitializedState = false;\r\n    }\r\n}\r\n\r\n// File: contracts/token/PropsRewards.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Props Rewards\r\n * @dev Contract allows to set approved apps and validators. Submit and mint rewards...\r\n **/\r\ncontract PropsRewards is Initializable, ERC20 {\r\n    using SafeMath for uint256;\r\n    /*\r\n    *  Events\r\n    */\r\n    event DailyRewardsSubmitted(\r\n        uint256 indexed rewardsDay,\r\n        bytes32 indexed rewardsHash,\r\n        address indexed validator\r\n    );\r\n\r\n    event DailyRewardsApplicationsMinted(\r\n        uint256 indexed rewardsDay,\r\n        bytes32 indexed rewardsHash,\r\n        uint256 numOfApplications,\r\n        uint256 amount\r\n    );\r\n\r\n    event DailyRewardsValidatorsMinted(\r\n        uint256 indexed rewardsDay,\r\n        bytes32 indexed rewardsHash,\r\n        uint256 numOfValidators,\r\n        uint256 amount\r\n    );\r\n\r\n    event EntityUpdated(\r\n        address indexed id,\r\n        PropsRewardsLib.RewardedEntityType indexed entityType,\r\n        bytes32 name,\r\n        address rewardsAddress,\r\n        address indexed sidechainAddress\r\n    );\r\n\r\n    event ParameterUpdated(\r\n        PropsRewardsLib.ParameterName param,\r\n        uint256 newValue,\r\n        uint256 oldValue,\r\n        uint256 rewardsDay\r\n    );\r\n\r\n    event ValidatorsListUpdated(\r\n        address[] validatorsList,\r\n        uint256 indexed rewardsDay\r\n    );\r\n\r\n    event ApplicationsListUpdated(\r\n        address[] applicationsList,\r\n        uint256 indexed rewardsDay\r\n    );\r\n\r\n    event ControllerUpdated(address indexed newController);\r\n\r\n    event Settlement(\r\n        address indexed applicationId,\r\n        bytes32 indexed userId,\r\n        address indexed to,\r\n        uint256 amount,\r\n        address rewardsAddress\r\n    );\r\n    /*\r\n    *  Storage\r\n    */\r\n\r\n    PropsRewardsLib.Data internal rewardsLibData;\r\n    uint256 public maxTotalSupply;\r\n    uint256 public rewardsStartTimestamp;\r\n    address public controller; // controller entity\r\n\r\n    /*\r\n    *  Modifiers\r\n    */\r\n    modifier onlyController() {\r\n        require(\r\n            msg.sender == controller,\r\n            \"Must be the controller\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev The initializer function for upgrade as initialize was already called, get the decimals used in the token to initialize the params\r\n    * @param _controller address that will have controller functionality on rewards protocol\r\n    * @param _minSecondsBetweenDays uint256 seconds required to pass between consecutive rewards day\r\n    * @param _rewardsStartTimestamp uint256 day 0 timestamp\r\n    */\r\n    function initializePostRewardsUpgrade1(\r\n        address _controller,\r\n        uint256 _minSecondsBetweenDays,\r\n        uint256 _rewardsStartTimestamp\r\n    )\r\n        public\r\n    {\r\n        uint256 decimals = 18;\r\n        _initializePostRewardsUpgrade1(_controller, decimals, _minSecondsBetweenDays, _rewardsStartTimestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev Set new validators list\r\n    * @param _rewardsDay uint256 the rewards day from which this change should take effect\r\n    * @param _validators address[] array of validators\r\n    */\r\n    function setValidators(uint256 _rewardsDay, address[] _validators)\r\n        public\r\n        onlyController\r\n    {\r\n        PropsRewardsLib.setValidators(rewardsLibData, _rewardsDay, _validators);\r\n        emit ValidatorsListUpdated(_validators, _rewardsDay);\r\n    }\r\n\r\n    /**\r\n    * @dev Set new applications list\r\n    * @param _rewardsDay uint256 the rewards day from which this change should take effect\r\n    * @param _applications address[] array of applications\r\n    */\r\n    function setApplications(uint256 _rewardsDay, address[] _applications)\r\n        public\r\n        onlyController\r\n    {\r\n        PropsRewardsLib.setApplications(rewardsLibData, _rewardsDay, _applications);\r\n        emit ApplicationsListUpdated(_applications, _rewardsDay);\r\n    }\r\n\r\n    /**\r\n    * @dev Get the applications or validators list\r\n    * @param _entityType RewardedEntityType either application (0) or validator (1)\r\n    * @param _rewardsDay uint256 the rewards day to use for this value\r\n    */\r\n    function getEntities(PropsRewardsLib.RewardedEntityType _entityType, uint256 _rewardsDay)\r\n        public\r\n        view\r\n        returns (address[])\r\n    {\r\n        return PropsRewardsLib.getEntities(rewardsLibData, _entityType, _rewardsDay);\r\n    }\r\n\r\n    /**\r\n    * @dev The function is called by validators with the calculation of the daily rewards\r\n    * @param _rewardsDay uint256 the rewards day\r\n    * @param _rewardsHash bytes32 hash of the rewards data\r\n    * @param _applications address[] array of application addresses getting the daily reward\r\n    * @param _amounts uint256[] array of amounts each app should get\r\n    */\r\n    function submitDailyRewards(\r\n        uint256 _rewardsDay,\r\n        bytes32 _rewardsHash,\r\n        address[] _applications,\r\n        uint256[] _amounts\r\n    )\r\n        public\r\n    {\r\n        // if submission is for a new day check if previous day validator rewards were given if not give to participating ones\r\n        if (_rewardsDay > rewardsLibData.dailyRewards.lastApplicationsRewardsDay) {\r\n            uint256 previousDayValidatorRewardsAmount = PropsRewardsLib.calculateValidatorRewards(\r\n                rewardsLibData,\r\n                rewardsLibData.dailyRewards.lastApplicationsRewardsDay,\r\n                rewardsLibData.dailyRewards.lastConfirmedRewardsHash,\r\n                false\r\n            );\r\n            if (previousDayValidatorRewardsAmount > 0) {\r\n                _mintDailyRewardsForValidators(rewardsLibData.dailyRewards.lastApplicationsRewardsDay, rewardsLibData.dailyRewards.lastConfirmedRewardsHash, previousDayValidatorRewardsAmount);\r\n            }\r\n        }\r\n        // check and give application rewards if majority of validators agree\r\n        uint256 appRewardsSum = PropsRewardsLib.calculateAndFinalizeApplicationRewards(\r\n            rewardsLibData,\r\n            _rewardsDay,\r\n            _rewardsHash,\r\n            _applications,\r\n            _amounts,\r\n            totalSupply()\r\n        );\r\n        if (appRewardsSum > 0) {\r\n            _mintDailyRewardsForApps(_rewardsDay, _rewardsHash, _applications, _amounts, appRewardsSum);\r\n        }\r\n\r\n        // check and give validator rewards if all validators submitted\r\n        uint256 validatorRewardsAmount = PropsRewardsLib.calculateValidatorRewards(\r\n            rewardsLibData,\r\n            _rewardsDay,\r\n            _rewardsHash,\r\n            true\r\n        );\r\n        if (validatorRewardsAmount > 0) {\r\n            _mintDailyRewardsForValidators(_rewardsDay, _rewardsHash, validatorRewardsAmount);\r\n        }\r\n\r\n        emit DailyRewardsSubmitted(_rewardsDay, _rewardsHash, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the controller/owner to update to a new controller\r\n    * @param _controller address address of the new controller\r\n    */\r\n    function updateController(\r\n        address _controller\r\n    )\r\n        public\r\n        onlyController\r\n    {\r\n        require(_controller != address(0), \"Controller cannot be the zero address\");\r\n        controller = _controller;\r\n        emit ControllerUpdated\r\n        (\r\n            _controller\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Allows getting a parameter value based on timestamp\r\n    * @param _name ParameterName name of the parameter\r\n    * @param _rewardsDay uint256 starting when should this parameter use the current value\r\n    */\r\n    function getParameter(\r\n        PropsRewardsLib.ParameterName _name,\r\n        uint256 _rewardsDay\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return PropsRewardsLib.getParameterValue(rewardsLibData, _name, _rewardsDay);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the controller/owner to update rewards parameters\r\n    * @param _name ParameterName name of the parameter\r\n    * @param _value uint256 new value for the parameter\r\n    * @param _rewardsDay uint256 starting when should this parameter use the current value\r\n    */\r\n    function updateParameter(\r\n        PropsRewardsLib.ParameterName _name,\r\n        uint256 _value,\r\n        uint256 _rewardsDay\r\n    )\r\n        public\r\n        onlyController\r\n    {\r\n        PropsRewardsLib.updateParameter(rewardsLibData, _name, _value, _rewardsDay);\r\n        emit ParameterUpdated(\r\n            _name,\r\n            rewardsLibData.parameters[uint256(_name)].currentValue,\r\n            rewardsLibData.parameters[uint256(_name)].previousValue,\r\n            rewardsLibData.parameters[uint256(_name)].rewardsDay\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Allows an application or validator to add/update its details\r\n    * @param _entityType RewardedEntityType either application (0) or validator (1)\r\n    * @param _name bytes32 name of the app\r\n    * @param _rewardsAddress address an address for the app to receive the rewards\r\n    * @param _sidechainAddress address the address used for using the sidechain\r\n    */\r\n    function updateEntity(\r\n        PropsRewardsLib.RewardedEntityType _entityType,\r\n        bytes32 _name,\r\n        address _rewardsAddress,\r\n        address _sidechainAddress\r\n    )\r\n        public\r\n    {\r\n        PropsRewardsLib.updateEntity(rewardsLibData, _entityType, _name, _rewardsAddress, _sidechainAddress);\r\n        emit EntityUpdated(msg.sender, _entityType, _name, _rewardsAddress, _sidechainAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows an application to settle sidechain props. Should be called from an application rewards address\r\n    * @param _applicationAddress address the application main address (used to setup the application)\r\n    * @param _userId bytes32 identification of the user on the sidechain that was settled\r\n    * @param _to address where to send the props to\r\n    * @param _amount uint256 the address used for using the sidechain\r\n    */\r\n    function settle(\r\n        address _applicationAddress,\r\n        bytes32 _userId,\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n        public\r\n    {\r\n        require(\r\n            rewardsLibData.applications[_applicationAddress].rewardsAddress == msg.sender,\r\n            \"settle may only be called by an application\"\r\n        );\r\n        _transfer(msg.sender, _to, _amount);\r\n        emit Settlement(_applicationAddress, _userId, _to, _amount, msg.sender);\r\n    }\r\n    /**\r\n    * @dev internal intialize rewards upgrade1\r\n    * @param _controller address that will have controller functionality on rewards protocol\r\n    * @param _decimals uint256 number of decimals used in total supply\r\n    * @param _minSecondsBetweenDays uint256 seconds required to pass between consecutive rewards day\r\n    * @param _rewardsStartTimestamp uint256 day 0 timestamp\r\n    */\r\n    function _initializePostRewardsUpgrade1(\r\n        address _controller,\r\n        uint256 _decimals,\r\n        uint256 _minSecondsBetweenDays,\r\n        uint256 _rewardsStartTimestamp\r\n    )\r\n        internal\r\n    {\r\n        require(maxTotalSupply==0, \"Initialize rewards upgrade1 can happen only once\");\r\n        controller = _controller;\r\n        // ApplicationRewardsPercent pphm ==> 0.03475%\r\n        PropsRewardsLib.updateParameter(rewardsLibData, PropsRewardsLib.ParameterName.ApplicationRewardsPercent, 34750, 0);\r\n        // // ApplicationRewardsMaxVariationPercent pphm ==> 150%\r\n        PropsRewardsLib.updateParameter(rewardsLibData, PropsRewardsLib.ParameterName.ApplicationRewardsMaxVariationPercent, 150 * 1e6, 0);\r\n        // // ValidatorMajorityPercent pphm ==> 50%\r\n        PropsRewardsLib.updateParameter(rewardsLibData, PropsRewardsLib.ParameterName.ValidatorMajorityPercent, 50 * 1e6, 0);\r\n        //  // ValidatorRewardsPercent pphm ==> 0.001829%\r\n        PropsRewardsLib.updateParameter(rewardsLibData, PropsRewardsLib.ParameterName.ValidatorRewardsPercent, 1829, 0);\r\n\r\n        // max total supply is 1,000,000,000 PROPS specified in AttoPROPS\r\n        rewardsLibData.maxTotalSupply = maxTotalSupply = 1 * 1e9 * (10 ** _decimals);\r\n        rewardsLibData.rewardsStartTimestamp = rewardsStartTimestamp = _rewardsStartTimestamp;\r\n        rewardsLibData.minSecondsBetweenDays = _minSecondsBetweenDays;\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev Mint rewards for validators\r\n    * @param _rewardsDay uint256 the rewards day\r\n    * @param _rewardsHash bytes32 hash of the rewards data\r\n    * @param _amount uint256 amount each validator should get\r\n    */\r\n    function _mintDailyRewardsForValidators(uint256 _rewardsDay, bytes32 _rewardsHash, uint256 _amount)\r\n        internal\r\n    {\r\n        uint256 validatorsCount = rewardsLibData.dailyRewards.submissions[_rewardsHash].validatorsList.length;\r\n        for (uint256 i = 0; i < validatorsCount; i++) {\r\n            _mint(rewardsLibData.validators[rewardsLibData.dailyRewards.submissions[_rewardsHash].validatorsList[i]].rewardsAddress,_amount);\r\n        }\r\n        PropsRewardsLib._resetDailyRewards(rewardsLibData, _rewardsHash);\r\n        emit DailyRewardsValidatorsMinted(\r\n            _rewardsDay,\r\n            _rewardsHash,\r\n            validatorsCount,\r\n            (_amount * validatorsCount)\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Mint rewards for apps\r\n    * @param _rewardsDay uint256 the rewards day\r\n    * @param _rewardsHash bytes32 hash of the rewards data\r\n    * @param _applications address[] array of application addresses getting the daily reward\r\n    * @param _amounts uint256[] array of amounts each app should get\r\n    * @param _sum uint256 the sum of all application rewards given\r\n    */\r\n    function _mintDailyRewardsForApps(\r\n        uint256 _rewardsDay,\r\n        bytes32 _rewardsHash,\r\n        address[] _applications,\r\n        uint256[] _amounts,\r\n        uint256 _sum\r\n    )\r\n        internal\r\n    {\r\n        for (uint256 i = 0; i < _applications.length; i++) {\r\n            _mint(rewardsLibData.applications[_applications[i]].rewardsAddress, _amounts[i]);\r\n        }\r\n        emit DailyRewardsApplicationsMinted(_rewardsDay, _rewardsHash, _applications.length, _sum);\r\n    }\r\n}\r\n\r\n// File: contracts/token/PropsToken.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title PROPSToken\r\n * @dev PROPS token contract (based of ZEPToken by openzeppelin), a detailed ERC20 token\r\n * https://github.com/zeppelinos/zos-vouching/blob/master/contracts/ZEPToken.sol\r\n * PROPS are divisible by 1e18 base\r\n * units referred to as 'AttoPROPS'.\r\n *\r\n * PROPS are displayed using 18 decimal places of precision.\r\n *\r\n * 1 PROPS is equivalent to:\r\n *   1 * 1e18 == 1e18 == One Quintillion AttoPROPS\r\n *\r\n * 600 Million PROPS (total supply) is equivalent to:\r\n *   600000000 * 1e18 == 6e26 AttoPROPS\r\n *\r\n\r\n */\r\n\r\n\r\ncontract PropsToken is Initializable, ERC20Detailed, ERC865Token, PropsTimeBasedTransfers, PropsRewards {\r\n\r\n  /**\r\n   * @dev Initializer function. Called only once when a proxy for the contract is created.\r\n   * @param _holder address that will receive its initial supply and be able to transfer before transfers start time\r\n   * @param _controller address that will have controller functionality on rewards protocol\r\n   * @param _minSecondsBetweenDays uint256 seconds required to pass between consecutive rewards day\r\n   * @param _rewardsStartTimestamp uint256 day 0 timestamp\r\n   */\r\n  function initialize(\r\n    address _holder,\r\n    address _controller,\r\n    uint256 _minSecondsBetweenDays,\r\n    uint256 _rewardsStartTimestamp\r\n  )\r\n    public\r\n    initializer\r\n  {\r\n    uint8 decimals = 18;\r\n    // total supply is 600,000,000 PROPS specified in AttoPROPS\r\n    uint256 totalSupply = 0.6 * 1e9 * (10 ** uint256(decimals));\r\n\r\n    ERC20Detailed.initialize(\"Props Token\", \"PROPS\", decimals);\r\n    PropsRewards.initializePostRewardsUpgrade1(_controller, _minSecondsBetweenDays, _rewardsStartTimestamp);\r\n    _mint(_holder, totalSupply);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"updateController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_entityType\",\"type\":\"uint8\"},{\"name\":\"_rewardsDay\",\"type\":\"uint256\"}],\"name\":\"getEntities\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getTransferPreSignedHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"transferPreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getIncreaseAllowancePreSignedHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"uint8\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_rewardsDay\",\"type\":\"uint256\"}],\"name\":\"updateParameter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canTransferBeforeStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_name\",\"type\":\"uint8\"},{\"name\":\"_rewardsDay\",\"type\":\"uint256\"}],\"name\":\"getParameter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getDecreaseAllowancePreSignedHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rewardsDay\",\"type\":\"uint256\"},{\"name\":\"_rewardsHash\",\"type\":\"bytes32\"},{\"name\":\"_applications\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"submitDailyRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"approvePreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsStartTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rewardsDay\",\"type\":\"uint256\"},{\"name\":\"_applications\",\"type\":\"address[]\"}],\"name\":\"setApplications\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getApprovePreSignedHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entityType\",\"type\":\"uint8\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_rewardsAddress\",\"type\":\"address\"},{\"name\":\"_sidechainAddress\",\"type\":\"address\"}],\"name\":\"updateEntity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getTransferFromPreSignedHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"transferFromPreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_applicationAddress\",\"type\":\"address\"},{\"name\":\"_userId\",\"type\":\"bytes32\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rewardsDay\",\"type\":\"uint256\"},{\"name\":\"_validators\",\"type\":\"address[]\"}],\"name\":\"setValidators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"},{\"name\":\"_minSecondsBetweenDays\",\"type\":\"uint256\"},{\"name\":\"_rewardsStartTimestamp\",\"type\":\"uint256\"}],\"name\":\"initializePostRewardsUpgrade1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_controller\",\"type\":\"address\"},{\"name\":\"_minSecondsBetweenDays\",\"type\":\"uint256\"},{\"name\":\"_rewardsStartTimestamp\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowancePreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"increaseAllowancePreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"rewardsDay\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"rewardsHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"DailyRewardsSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"rewardsDay\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"rewardsHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"numOfApplications\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DailyRewardsApplicationsMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"rewardsDay\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"rewardsHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"numOfValidators\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DailyRewardsValidatorsMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"entityType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"rewardsAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sidechainAddress\",\"type\":\"address\"}],\"name\":\"EntityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"param\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardsDay\",\"type\":\"uint256\"}],\"name\":\"ParameterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"validatorsList\",\"type\":\"address[]\"},{\"indexed\":true,\"name\":\"rewardsDay\",\"type\":\"uint256\"}],\"name\":\"ValidatorsListUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"applicationsList\",\"type\":\"address[]\"},{\"indexed\":true,\"name\":\"rewardsDay\",\"type\":\"uint256\"}],\"name\":\"ApplicationsListUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"ControllerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"applicationId\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"userId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardsAddress\",\"type\":\"address\"}],\"name\":\"Settlement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"TransferPreSigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"ApprovalPreSigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"PropsToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"PropsRewardsLib:293d63660b2acbab8ce6a5d358d10dab3f046a7c","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://412710e103a140fd3a1b6c5177bbc23ae71e062c25c714e2e063c63b47061050"}]}