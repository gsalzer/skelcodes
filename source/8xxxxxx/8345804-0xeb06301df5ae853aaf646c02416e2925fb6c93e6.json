{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/IWallet.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n\r\ninterface IWallet {\r\n    /**\r\n    * @dev Verifies that a signature is valid.\r\n    * @param _hash - Message hash that is signed.\r\n    * @param _signature - Proof of signing.\r\n    * @return Validity of order signature.\r\n    */\r\n    function isValidSignature(\r\n        bytes32 _hash,\r\n        bytes calldata _signature\r\n    )\r\n    external\r\n    view\r\n    returns (bool isValid);\r\n}\r\n\r\n// File: contracts/SignatureValidator.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n\r\n\r\ncontract SignatureValidator {\r\n    // Allowed signature types.\r\n    enum SignatureType {\r\n        Invalid,         // 0x00, default value\r\n        EIP712,          // 0x01\r\n        EthSign,         // 0x02\r\n        Wallet,          // 0x03\r\n        NSignatureTypes  // 0x04, number of signature types. Always leave at end.\r\n    }\r\n\r\n    function isValidSignature(\r\n        bytes32 _hash,\r\n        address _signerAddress,\r\n        uint8 _signatureType,\r\n        bytes memory _signature\r\n    )\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n\r\n        require(\r\n            _signature.length > 0,\r\n            \"The signature length should be greather than 0\"\r\n        );\r\n\r\n        // Ensure signature is supported\r\n        require(\r\n            _signatureType != uint8(SignatureType.Invalid) &&\r\n            _signatureType < uint8(SignatureType.NSignatureTypes),\r\n            \"Signature unsopported\"\r\n        );\r\n\r\n        SignatureType signatureType = SignatureType(_signatureType);\r\n\r\n        bool isValid;\r\n\r\n        // Signature using EIP712\r\n        if (signatureType == SignatureType.EIP712) {\r\n            isValid = _isValid712Signature(_hash, _signerAddress, _signature);\r\n\r\n        // Signed using web3.eth_sign\r\n        } else if (signatureType == SignatureType.EthSign) {\r\n            isValid = _isValidPersonalSignature(_hash, _signerAddress, _signature);\r\n\r\n        // Signature verified by wallet contract.\r\n        } else if (signatureType == SignatureType.Wallet) {\r\n            isValid = _isValidWalletSignature(_hash, _signerAddress, _signature);\r\n        }\r\n\r\n        return isValid;\r\n    }\r\n\r\n    function _isValid712Signature(\r\n        bytes32 _hash,\r\n        address _signerAddress,\r\n        bytes memory _signature\r\n    )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        require(\r\n            _signature.length == 65,\r\n            \"The signature length should be 65\"\r\n        );\r\n\r\n        (uint8 v, bytes32 r, bytes32 s) = _getVRS(_signature);\r\n\r\n        return _signerAddress == ecrecover(\r\n            _hash,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n\r\n    function _isValidPersonalSignature(\r\n        bytes32 _hash,\r\n        address _signerAddress,\r\n        bytes memory _signature\r\n    )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        require(\r\n            _signature.length == 65,\r\n            \"The signature length should be 65\"\r\n        );\r\n\r\n        (uint8 v, bytes32 r, bytes32 s) = _getVRS(_signature);\r\n\r\n        return _signerAddress == ecrecover(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19Ethereum Signed Message:\\n32\",\r\n                    _hash\r\n            )),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n\r\n    function _isValidWalletSignature(\r\n        bytes32 _hash,\r\n        address _walletAddress,\r\n        bytes memory _signature\r\n    )\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            IWallet(_walletAddress).isValidSignature.selector,\r\n            _hash,\r\n            _signature\r\n        );\r\n\r\n        // Static call the verification function.\r\n        (bool didSucceed, bytes memory returnData) = _walletAddress.staticcall(callData);\r\n\r\n        // Return data should be a single bool.\r\n        if (didSucceed && returnData.length == 32) {\r\n            bytes32 encodedReturnData;\r\n            /* solium-disable-next-line */\r\n            assembly {\r\n                encodedReturnData := mload(add(returnData, 0x20))\r\n            }\r\n            return uint256(encodedReturnData) == 1;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function _getVRS(\r\n        bytes memory _signature\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint8 v, bytes32 r, bytes32 s)\r\n    {\r\n        /* solium-disable-next-line */\r\n        assembly {\r\n            r := mload(add(_signature, 32))\r\n            s := mload(add(_signature, 64))\r\n            v := and(mload(add(_signature, 65)), 255)\r\n        }\r\n\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_signerAddress\",\"type\":\"address\"},{\"name\":\"_signatureType\",\"type\":\"uint8\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SignatureValidator","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a28b4a5435ed1e46e5c52c87164a3acbfe0a4490b38a1786c8e5d21a48f70550"}]}