{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.25 <0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract Modifiable {\r\n    \r\n    \r\n    \r\n    modifier notNullAddress(address _address) {\r\n        require(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier notThisAddress(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    modifier notNullOrThisAddress(address _address) {\r\n        require(_address != address(0));\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    modifier notSameAddresses(address _address1, address _address2) {\r\n        if (_address1 != _address2)\r\n            _;\r\n    }\r\n}\r\n\r\ncontract SelfDestructible {\r\n    \r\n    \r\n    \r\n    bool public selfDestructionDisabled;\r\n\r\n    \r\n    \r\n    \r\n    event SelfDestructionDisabledEvent(address wallet);\r\n    event TriggerSelfDestructionEvent(address wallet);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function destructor()\r\n    public\r\n    view\r\n    returns (address);\r\n\r\n    \r\n    \r\n    function disableSelfDestruction()\r\n    public\r\n    {\r\n        \r\n        require(destructor() == msg.sender);\r\n\r\n        \r\n        selfDestructionDisabled = true;\r\n\r\n        \r\n        emit SelfDestructionDisabledEvent(msg.sender);\r\n    }\r\n\r\n    \r\n    function triggerSelfDestruction()\r\n    public\r\n    {\r\n        \r\n        require(destructor() == msg.sender);\r\n\r\n        \r\n        require(!selfDestructionDisabled);\r\n\r\n        \r\n        emit TriggerSelfDestructionEvent(msg.sender);\r\n\r\n        \r\n        selfdestruct(msg.sender);\r\n    }\r\n}\r\n\r\ncontract Ownable is Modifiable, SelfDestructible {\r\n    \r\n    \r\n    \r\n    address public deployer;\r\n    address public operator;\r\n\r\n    \r\n    \r\n    \r\n    event SetDeployerEvent(address oldDeployer, address newDeployer);\r\n    event SetOperatorEvent(address oldOperator, address newOperator);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address _deployer) internal notNullOrThisAddress(_deployer) {\r\n        deployer = _deployer;\r\n        operator = _deployer;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function destructor()\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        return deployer;\r\n    }\r\n\r\n    \r\n    \r\n    function setDeployer(address newDeployer)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(newDeployer)\r\n    {\r\n        if (newDeployer != deployer) {\r\n            \r\n            address oldDeployer = deployer;\r\n            deployer = newDeployer;\r\n\r\n            \r\n            emit SetDeployerEvent(oldDeployer, newDeployer);\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    function setOperator(address newOperator)\r\n    public\r\n    onlyOperator\r\n    notNullOrThisAddress(newOperator)\r\n    {\r\n        if (newOperator != operator) {\r\n            \r\n            address oldOperator = operator;\r\n            operator = newOperator;\r\n\r\n            \r\n            emit SetOperatorEvent(oldOperator, newOperator);\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    function isDeployer()\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return msg.sender == deployer;\r\n    }\r\n\r\n    \r\n    \r\n    function isOperator()\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return msg.sender == operator;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isDeployerOrOperator()\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return isDeployer() || isOperator();\r\n    }\r\n\r\n    \r\n    \r\n    modifier onlyDeployer() {\r\n        require(isDeployer());\r\n        _;\r\n    }\r\n\r\n    modifier notDeployer() {\r\n        require(!isDeployer());\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(isOperator());\r\n        _;\r\n    }\r\n\r\n    modifier notOperator() {\r\n        require(!isOperator());\r\n        _;\r\n    }\r\n\r\n    modifier onlyDeployerOrOperator() {\r\n        require(isDeployerOrOperator());\r\n        _;\r\n    }\r\n\r\n    modifier notDeployerOrOperator() {\r\n        require(!isDeployerOrOperator());\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Servable is Ownable {\r\n    \r\n    \r\n    \r\n    struct ServiceInfo {\r\n        bool registered;\r\n        uint256 activationTimestamp;\r\n        mapping(bytes32 => bool) actionsEnabledMap;\r\n        bytes32[] actionsList;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    mapping(address => ServiceInfo) internal registeredServicesMap;\r\n    uint256 public serviceActivationTimeout;\r\n\r\n    \r\n    \r\n    \r\n    event ServiceActivationTimeoutEvent(uint256 timeoutInSeconds);\r\n    event RegisterServiceEvent(address service);\r\n    event RegisterServiceDeferredEvent(address service, uint256 timeout);\r\n    event DeregisterServiceEvent(address service);\r\n    event EnableServiceActionEvent(address service, string action);\r\n    event DisableServiceActionEvent(address service, string action);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setServiceActivationTimeout(uint256 timeoutInSeconds)\r\n    public\r\n    onlyDeployer\r\n    {\r\n        serviceActivationTimeout = timeoutInSeconds;\r\n\r\n        \r\n        emit ServiceActivationTimeoutEvent(timeoutInSeconds);\r\n    }\r\n\r\n    \r\n    \r\n    function registerService(address service)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        _registerService(service, 0);\r\n\r\n        \r\n        emit RegisterServiceEvent(service);\r\n    }\r\n\r\n    \r\n    \r\n    function registerServiceDeferred(address service)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        _registerService(service, serviceActivationTimeout);\r\n\r\n        \r\n        emit RegisterServiceDeferredEvent(service, serviceActivationTimeout);\r\n    }\r\n\r\n    \r\n    \r\n    function deregisterService(address service)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        require(registeredServicesMap[service].registered);\r\n\r\n        registeredServicesMap[service].registered = false;\r\n\r\n        \r\n        emit DeregisterServiceEvent(service);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function enableServiceAction(address service, string memory action)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        require(registeredServicesMap[service].registered);\r\n\r\n        bytes32 actionHash = hashString(action);\r\n\r\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\r\n\r\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\r\n        registeredServicesMap[service].actionsList.push(actionHash);\r\n\r\n        \r\n        emit EnableServiceActionEvent(service, action);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function disableServiceAction(address service, string memory action)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        bytes32 actionHash = hashString(action);\r\n\r\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\r\n\r\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\r\n\r\n        \r\n        emit DisableServiceActionEvent(service, action);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isRegisteredService(address service)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return registeredServicesMap[service].registered;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isRegisteredActiveService(address service)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return isRegisteredService(service) && block.timestamp >= registeredServicesMap[service].activationTimestamp;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isEnabledServiceAction(address service, string memory action)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        bytes32 actionHash = hashString(action);\r\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function hashString(string memory _string)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_string));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function _registerService(address service, uint256 timeout)\r\n    private\r\n    {\r\n        if (!registeredServicesMap[service].registered) {\r\n            registeredServicesMap[service].registered = true;\r\n            registeredServicesMap[service].activationTimestamp = block.timestamp + timeout;\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier onlyActiveService() {\r\n        require(isRegisteredActiveService(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier onlyEnabledServiceAction(string memory action) {\r\n        require(isEnabledServiceAction(msg.sender, action));\r\n        _;\r\n    }\r\n}\r\n\r\nlibrary SafeMathIntLib {\r\n    int256 constant INT256_MIN = int256((uint256(1) << 255));\r\n    int256 constant INT256_MAX = int256(~((uint256(1) << 255)));\r\n\r\n    \r\n    \r\n    \r\n    function div(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a != INT256_MIN || b != - 1);\r\n        return a / b;\r\n    }\r\n\r\n    function mul(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a != - 1 || b != INT256_MIN);\r\n        \r\n        require(b != - 1 || a != INT256_MIN);\r\n        \r\n        int256 c = a * b;\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    function sub(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\r\n        return a - b;\r\n    }\r\n\r\n    function add(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function div_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b > 0);\r\n        return a / b;\r\n    }\r\n\r\n    function mul_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b >= 0);\r\n        int256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        require(c >= 0);\r\n        return c;\r\n    }\r\n\r\n    function sub_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b >= 0 && b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b >= 0);\r\n        int256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function abs(int256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return a < 0 ? neg(a) : a;\r\n    }\r\n\r\n    function neg(int256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return mul(a, - 1);\r\n    }\r\n\r\n    function toNonZeroInt256(uint256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a > 0 && a < (uint256(1) << 255));\r\n        return int256(a);\r\n    }\r\n\r\n    function toInt256(uint256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && a < (uint256(1) << 255));\r\n        return int256(a);\r\n    }\r\n\r\n    function toUInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        require(a >= 0);\r\n        return uint256(a);\r\n    }\r\n\r\n    function isNonZeroPositiveInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a > 0);\r\n    }\r\n\r\n    function isPositiveInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a >= 0);\r\n    }\r\n\r\n    function isNonZeroNegativeInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a < 0);\r\n    }\r\n\r\n    function isNegativeInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a <= 0);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function clamp(int256 a, int256 min, int256 max)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        if (a < min)\r\n            return min;\r\n        return (a > max) ? max : a;\r\n    }\r\n\r\n    function clampMin(int256 a, int256 min)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return (a < min) ? min : a;\r\n    }\r\n\r\n    function clampMax(int256 a, int256 max)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return (a > max) ? max : a;\r\n    }\r\n}\r\n\r\nlibrary BlockNumbUintsLib {\r\n    \r\n    \r\n    \r\n    struct Entry {\r\n        uint256 blockNumber;\r\n        uint256 value;\r\n    }\r\n\r\n    struct BlockNumbUints {\r\n        Entry[] entries;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function currentValue(BlockNumbUints storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return valueAt(self, block.number);\r\n    }\r\n\r\n    function currentEntry(BlockNumbUints storage self)\r\n    internal\r\n    view\r\n    returns (Entry memory)\r\n    {\r\n        return entryAt(self, block.number);\r\n    }\r\n\r\n    function valueAt(BlockNumbUints storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return entryAt(self, _blockNumber).value;\r\n    }\r\n\r\n    function entryAt(BlockNumbUints storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (Entry memory)\r\n    {\r\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\r\n    }\r\n\r\n    function addEntry(BlockNumbUints storage self, uint256 blockNumber, uint256 value)\r\n    internal\r\n    {\r\n        require(\r\n            0 == self.entries.length ||\r\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\r\n            \"Later entry found [BlockNumbUintsLib.sol:62]\"\r\n        );\r\n\r\n        self.entries.push(Entry(blockNumber, value));\r\n    }\r\n\r\n    function count(BlockNumbUints storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.entries.length;\r\n    }\r\n\r\n    function entries(BlockNumbUints storage self)\r\n    internal\r\n    view\r\n    returns (Entry[] memory)\r\n    {\r\n        return self.entries;\r\n    }\r\n\r\n    function indexByBlockNumber(BlockNumbUints storage self, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(0 < self.entries.length, \"No entries found [BlockNumbUintsLib.sol:92]\");\r\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\r\n            if (blockNumber >= self.entries[i].blockNumber)\r\n                return i;\r\n        revert();\r\n    }\r\n}\r\n\r\nlibrary BlockNumbIntsLib {\r\n    \r\n    \r\n    \r\n    struct Entry {\r\n        uint256 blockNumber;\r\n        int256 value;\r\n    }\r\n\r\n    struct BlockNumbInts {\r\n        Entry[] entries;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function currentValue(BlockNumbInts storage self)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return valueAt(self, block.number);\r\n    }\r\n\r\n    function currentEntry(BlockNumbInts storage self)\r\n    internal\r\n    view\r\n    returns (Entry memory)\r\n    {\r\n        return entryAt(self, block.number);\r\n    }\r\n\r\n    function valueAt(BlockNumbInts storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return entryAt(self, _blockNumber).value;\r\n    }\r\n\r\n    function entryAt(BlockNumbInts storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (Entry memory)\r\n    {\r\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\r\n    }\r\n\r\n    function addEntry(BlockNumbInts storage self, uint256 blockNumber, int256 value)\r\n    internal\r\n    {\r\n        require(\r\n            0 == self.entries.length ||\r\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\r\n            \"Later entry found [BlockNumbIntsLib.sol:62]\"\r\n        );\r\n\r\n        self.entries.push(Entry(blockNumber, value));\r\n    }\r\n\r\n    function count(BlockNumbInts storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.entries.length;\r\n    }\r\n\r\n    function entries(BlockNumbInts storage self)\r\n    internal\r\n    view\r\n    returns (Entry[] memory)\r\n    {\r\n        return self.entries;\r\n    }\r\n\r\n    function indexByBlockNumber(BlockNumbInts storage self, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(0 < self.entries.length, \"No entries found [BlockNumbIntsLib.sol:92]\");\r\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\r\n            if (blockNumber >= self.entries[i].blockNumber)\r\n                return i;\r\n        revert();\r\n    }\r\n}\r\n\r\nlibrary ConstantsLib {\r\n    \r\n    function PARTS_PER()\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return 1e18;\r\n    }\r\n}\r\n\r\nlibrary BlockNumbDisdIntsLib {\r\n    using SafeMathIntLib for int256;\r\n\r\n    \r\n    \r\n    \r\n    struct Discount {\r\n        int256 tier;\r\n        int256 value;\r\n    }\r\n\r\n    struct Entry {\r\n        uint256 blockNumber;\r\n        int256 nominal;\r\n        Discount[] discounts;\r\n    }\r\n\r\n    struct BlockNumbDisdInts {\r\n        Entry[] entries;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function currentNominalValue(BlockNumbDisdInts storage self)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return nominalValueAt(self, block.number);\r\n    }\r\n\r\n    function currentDiscountedValue(BlockNumbDisdInts storage self, int256 tier)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return discountedValueAt(self, block.number, tier);\r\n    }\r\n\r\n    function currentEntry(BlockNumbDisdInts storage self)\r\n    internal\r\n    view\r\n    returns (Entry memory)\r\n    {\r\n        return entryAt(self, block.number);\r\n    }\r\n\r\n    function nominalValueAt(BlockNumbDisdInts storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return entryAt(self, _blockNumber).nominal;\r\n    }\r\n\r\n    function discountedValueAt(BlockNumbDisdInts storage self, uint256 _blockNumber, int256 tier)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        Entry memory entry = entryAt(self, _blockNumber);\r\n        if (0 < entry.discounts.length) {\r\n            uint256 index = indexByTier(entry.discounts, tier);\r\n            if (0 < index)\r\n                return entry.nominal.mul(\r\n                    ConstantsLib.PARTS_PER().sub(entry.discounts[index - 1].value)\r\n                ).div(\r\n                    ConstantsLib.PARTS_PER()\r\n                );\r\n            else\r\n                return entry.nominal;\r\n        } else\r\n            return entry.nominal;\r\n    }\r\n\r\n    function entryAt(BlockNumbDisdInts storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (Entry memory)\r\n    {\r\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\r\n    }\r\n\r\n    function addNominalEntry(BlockNumbDisdInts storage self, uint256 blockNumber, int256 nominal)\r\n    internal\r\n    {\r\n        require(\r\n            0 == self.entries.length ||\r\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\r\n            \"Later entry found [BlockNumbDisdIntsLib.sol:101]\"\r\n        );\r\n\r\n        self.entries.length++;\r\n        Entry storage entry = self.entries[self.entries.length - 1];\r\n\r\n        entry.blockNumber = blockNumber;\r\n        entry.nominal = nominal;\r\n    }\r\n\r\n    function addDiscountedEntry(BlockNumbDisdInts storage self, uint256 blockNumber, int256 nominal,\r\n        int256[] memory discountTiers, int256[] memory discountValues)\r\n    internal\r\n    {\r\n        require(discountTiers.length == discountValues.length, \"Parameter array lengths mismatch [BlockNumbDisdIntsLib.sol:118]\");\r\n\r\n        addNominalEntry(self, blockNumber, nominal);\r\n\r\n        Entry storage entry = self.entries[self.entries.length - 1];\r\n        for (uint256 i = 0; i < discountTiers.length; i++)\r\n            entry.discounts.push(Discount(discountTiers[i], discountValues[i]));\r\n    }\r\n\r\n    function count(BlockNumbDisdInts storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.entries.length;\r\n    }\r\n\r\n    function entries(BlockNumbDisdInts storage self)\r\n    internal\r\n    view\r\n    returns (Entry[] memory)\r\n    {\r\n        return self.entries;\r\n    }\r\n\r\n    function indexByBlockNumber(BlockNumbDisdInts storage self, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(0 < self.entries.length, \"No entries found [BlockNumbDisdIntsLib.sol:148]\");\r\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\r\n            if (blockNumber >= self.entries[i].blockNumber)\r\n                return i;\r\n        revert();\r\n    }\r\n\r\n    \r\n    function indexByTier(Discount[] memory discounts, int256 tier)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        require(0 < discounts.length, \"No discounts found [BlockNumbDisdIntsLib.sol:161]\");\r\n        for (uint256 i = discounts.length; i > 0; i--)\r\n            if (tier >= discounts[i - 1].tier)\r\n                return i;\r\n        return 0;\r\n    }\r\n}\r\n\r\nlibrary MonetaryTypesLib {\r\n    \r\n    \r\n    \r\n    struct Currency {\r\n        address ct;\r\n        uint256 id;\r\n    }\r\n\r\n    struct Figure {\r\n        int256 amount;\r\n        Currency currency;\r\n    }\r\n\r\n    struct NoncedAmount {\r\n        uint256 nonce;\r\n        int256 amount;\r\n    }\r\n}\r\n\r\nlibrary BlockNumbReferenceCurrenciesLib {\r\n    \r\n    \r\n    \r\n    struct Entry {\r\n        uint256 blockNumber;\r\n        MonetaryTypesLib.Currency currency;\r\n    }\r\n\r\n    struct BlockNumbReferenceCurrencies {\r\n        mapping(address => mapping(uint256 => Entry[])) entriesByCurrency;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function currentCurrency(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Currency storage)\r\n    {\r\n        return currencyAt(self, referenceCurrency, block.number);\r\n    }\r\n\r\n    function currentEntry(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\r\n    internal\r\n    view\r\n    returns (Entry storage)\r\n    {\r\n        return entryAt(self, referenceCurrency, block.number);\r\n    }\r\n\r\n    function currencyAt(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency,\r\n        uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Currency storage)\r\n    {\r\n        return entryAt(self, referenceCurrency, _blockNumber).currency;\r\n    }\r\n\r\n    function entryAt(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency,\r\n        uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (Entry storage)\r\n    {\r\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][indexByBlockNumber(self, referenceCurrency, _blockNumber)];\r\n    }\r\n\r\n    function addEntry(BlockNumbReferenceCurrencies storage self, uint256 blockNumber,\r\n        MonetaryTypesLib.Currency memory referenceCurrency, MonetaryTypesLib.Currency memory currency)\r\n    internal\r\n    {\r\n        require(\r\n            0 == self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length ||\r\n        blockNumber > self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length - 1].blockNumber,\r\n            \"Later entry found for currency [BlockNumbReferenceCurrenciesLib.sol:67]\"\r\n        );\r\n\r\n        self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].push(Entry(blockNumber, currency));\r\n    }\r\n\r\n    function count(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length;\r\n    }\r\n\r\n    function entriesByCurrency(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\r\n    internal\r\n    view\r\n    returns (Entry[] storage)\r\n    {\r\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id];\r\n    }\r\n\r\n    function indexByBlockNumber(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(0 < self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length, \"No entries found for currency [BlockNumbReferenceCurrenciesLib.sol:97]\");\r\n        for (uint256 i = self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length - 1; i >= 0; i--)\r\n            if (blockNumber >= self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][i].blockNumber)\r\n                return i;\r\n        revert();\r\n    }\r\n}\r\n\r\nlibrary BlockNumbFiguresLib {\r\n    \r\n    \r\n    \r\n    struct Entry {\r\n        uint256 blockNumber;\r\n        MonetaryTypesLib.Figure value;\r\n    }\r\n\r\n    struct BlockNumbFigures {\r\n        Entry[] entries;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function currentValue(BlockNumbFigures storage self)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Figure storage)\r\n    {\r\n        return valueAt(self, block.number);\r\n    }\r\n\r\n    function currentEntry(BlockNumbFigures storage self)\r\n    internal\r\n    view\r\n    returns (Entry storage)\r\n    {\r\n        return entryAt(self, block.number);\r\n    }\r\n\r\n    function valueAt(BlockNumbFigures storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Figure storage)\r\n    {\r\n        return entryAt(self, _blockNumber).value;\r\n    }\r\n\r\n    function entryAt(BlockNumbFigures storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (Entry storage)\r\n    {\r\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\r\n    }\r\n\r\n    function addEntry(BlockNumbFigures storage self, uint256 blockNumber, MonetaryTypesLib.Figure memory value)\r\n    internal\r\n    {\r\n        require(\r\n            0 == self.entries.length ||\r\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\r\n            \"Later entry found [BlockNumbFiguresLib.sol:65]\"\r\n        );\r\n\r\n        self.entries.push(Entry(blockNumber, value));\r\n    }\r\n\r\n    function count(BlockNumbFigures storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.entries.length;\r\n    }\r\n\r\n    function entries(BlockNumbFigures storage self)\r\n    internal\r\n    view\r\n    returns (Entry[] storage)\r\n    {\r\n        return self.entries;\r\n    }\r\n\r\n    function indexByBlockNumber(BlockNumbFigures storage self, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(0 < self.entries.length, \"No entries found [BlockNumbFiguresLib.sol:95]\");\r\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\r\n            if (blockNumber >= self.entries[i].blockNumber)\r\n                return i;\r\n        revert();\r\n    }\r\n}\r\n\r\ncontract Configuration is Modifiable, Ownable, Servable {\r\n    using SafeMathIntLib for int256;\r\n    using BlockNumbUintsLib for BlockNumbUintsLib.BlockNumbUints;\r\n    using BlockNumbIntsLib for BlockNumbIntsLib.BlockNumbInts;\r\n    using BlockNumbDisdIntsLib for BlockNumbDisdIntsLib.BlockNumbDisdInts;\r\n    using BlockNumbReferenceCurrenciesLib for BlockNumbReferenceCurrenciesLib.BlockNumbReferenceCurrencies;\r\n    using BlockNumbFiguresLib for BlockNumbFiguresLib.BlockNumbFigures;\r\n\r\n    \r\n    \r\n    \r\n    string constant public OPERATIONAL_MODE_ACTION = \"operational_mode\";\r\n\r\n    \r\n    \r\n    \r\n    enum OperationalMode {Normal, Exit}\r\n\r\n    \r\n    \r\n    \r\n    OperationalMode public operationalMode = OperationalMode.Normal;\r\n\r\n    BlockNumbUintsLib.BlockNumbUints private updateDelayBlocksByBlockNumber;\r\n    BlockNumbUintsLib.BlockNumbUints private confirmationBlocksByBlockNumber;\r\n\r\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private tradeMakerFeeByBlockNumber;\r\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private tradeTakerFeeByBlockNumber;\r\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private paymentFeeByBlockNumber;\r\n    mapping(address => mapping(uint256 => BlockNumbDisdIntsLib.BlockNumbDisdInts)) private currencyPaymentFeeByBlockNumber;\r\n\r\n    BlockNumbIntsLib.BlockNumbInts private tradeMakerMinimumFeeByBlockNumber;\r\n    BlockNumbIntsLib.BlockNumbInts private tradeTakerMinimumFeeByBlockNumber;\r\n    BlockNumbIntsLib.BlockNumbInts private paymentMinimumFeeByBlockNumber;\r\n    mapping(address => mapping(uint256 => BlockNumbIntsLib.BlockNumbInts)) private currencyPaymentMinimumFeeByBlockNumber;\r\n\r\n    BlockNumbReferenceCurrenciesLib.BlockNumbReferenceCurrencies private feeCurrencyByCurrencyBlockNumber;\r\n\r\n    BlockNumbUintsLib.BlockNumbUints private walletLockTimeoutByBlockNumber;\r\n    BlockNumbUintsLib.BlockNumbUints private cancelOrderChallengeTimeoutByBlockNumber;\r\n    BlockNumbUintsLib.BlockNumbUints private settlementChallengeTimeoutByBlockNumber;\r\n\r\n    BlockNumbUintsLib.BlockNumbUints private fraudStakeFractionByBlockNumber;\r\n    BlockNumbUintsLib.BlockNumbUints private walletSettlementStakeFractionByBlockNumber;\r\n    BlockNumbUintsLib.BlockNumbUints private operatorSettlementStakeFractionByBlockNumber;\r\n\r\n    BlockNumbFiguresLib.BlockNumbFigures private operatorSettlementStakeByBlockNumber;\r\n\r\n    uint256 public earliestSettlementBlockNumber;\r\n    bool public earliestSettlementBlockNumberUpdateDisabled;\r\n\r\n    \r\n    \r\n    \r\n    event SetOperationalModeExitEvent();\r\n    event SetUpdateDelayBlocksEvent(uint256 fromBlockNumber, uint256 newBlocks);\r\n    event SetConfirmationBlocksEvent(uint256 fromBlockNumber, uint256 newBlocks);\r\n    event SetTradeMakerFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\r\n    event SetTradeTakerFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\r\n    event SetPaymentFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\r\n    event SetCurrencyPaymentFeeEvent(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\r\n        int256[] discountTiers, int256[] discountValues);\r\n    event SetTradeMakerMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\r\n    event SetTradeTakerMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\r\n    event SetPaymentMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\r\n    event SetCurrencyPaymentMinimumFeeEvent(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal);\r\n    event SetFeeCurrencyEvent(uint256 fromBlockNumber, address referenceCurrencyCt, uint256 referenceCurrencyId,\r\n        address feeCurrencyCt, uint256 feeCurrencyId);\r\n    event SetWalletLockTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\r\n    event SetCancelOrderChallengeTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\r\n    event SetSettlementChallengeTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\r\n    event SetWalletSettlementStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\r\n    event SetOperatorSettlementStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\r\n    event SetOperatorSettlementStakeEvent(uint256 fromBlockNumber, int256 stakeAmount, address stakeCurrencyCt,\r\n        uint256 stakeCurrencyId);\r\n    event SetFraudStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\r\n    event SetEarliestSettlementBlockNumberEvent(uint256 earliestSettlementBlockNumber);\r\n    event DisableEarliestSettlementBlockNumberUpdateEvent();\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n        updateDelayBlocksByBlockNumber.addEntry(block.number, 0);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setOperationalModeExit()\r\n    public\r\n    onlyEnabledServiceAction(OPERATIONAL_MODE_ACTION)\r\n    {\r\n        operationalMode = OperationalMode.Exit;\r\n        emit SetOperationalModeExitEvent();\r\n    }\r\n\r\n    \r\n    function isOperationalModeNormal()\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return OperationalMode.Normal == operationalMode;\r\n    }\r\n\r\n    \r\n    function isOperationalModeExit()\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return OperationalMode.Exit == operationalMode;\r\n    }\r\n\r\n    \r\n    \r\n    function updateDelayBlocks()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return updateDelayBlocksByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    function updateDelayBlocksCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return updateDelayBlocksByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setUpdateDelayBlocks(uint256 fromBlockNumber, uint256 newUpdateDelayBlocks)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        updateDelayBlocksByBlockNumber.addEntry(fromBlockNumber, newUpdateDelayBlocks);\r\n        emit SetUpdateDelayBlocksEvent(fromBlockNumber, newUpdateDelayBlocks);\r\n    }\r\n\r\n    \r\n    \r\n    function confirmationBlocks()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return confirmationBlocksByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    function confirmationBlocksCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return confirmationBlocksByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setConfirmationBlocks(uint256 fromBlockNumber, uint256 newConfirmationBlocks)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        confirmationBlocksByBlockNumber.addEntry(fromBlockNumber, newConfirmationBlocks);\r\n        emit SetConfirmationBlocksEvent(fromBlockNumber, newConfirmationBlocks);\r\n    }\r\n\r\n    \r\n    function tradeMakerFeesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return tradeMakerFeeByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function tradeMakerFee(uint256 blockNumber, int256 discountTier)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return tradeMakerFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\r\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\r\n    }\r\n\r\n    \r\n    function tradeTakerFeesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return tradeTakerFeeByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function tradeTakerFee(uint256 blockNumber, int256 discountTier)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return tradeTakerFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\r\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\r\n    }\r\n\r\n    \r\n    function paymentFeesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return paymentFeeByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function paymentFee(uint256 blockNumber, int256 discountTier)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return paymentFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\r\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function currencyPaymentFeesCount(address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return currencyPaymentFeeByBlockNumber[currencyCt][currencyId].count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function currencyPaymentFee(uint256 blockNumber, address currencyCt, uint256 currencyId, int256 discountTier)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        if (0 < currencyPaymentFeeByBlockNumber[currencyCt][currencyId].count())\r\n            return currencyPaymentFeeByBlockNumber[currencyCt][currencyId].discountedValueAt(\r\n                blockNumber, discountTier\r\n            );\r\n        else\r\n            return paymentFee(blockNumber, discountTier);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\r\n        int256[] memory discountTiers, int256[] memory discountValues)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\r\n            fromBlockNumber, nominal, discountTiers, discountValues\r\n        );\r\n        emit SetCurrencyPaymentFeeEvent(\r\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\r\n        );\r\n    }\r\n\r\n    \r\n    function tradeMakerMinimumFeesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return tradeMakerMinimumFeeByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    function tradeMakerMinimumFee(uint256 blockNumber)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return tradeMakerMinimumFeeByBlockNumber.valueAt(blockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setTradeMakerMinimumFee(uint256 fromBlockNumber, int256 nominal)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        tradeMakerMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\r\n        emit SetTradeMakerMinimumFeeEvent(fromBlockNumber, nominal);\r\n    }\r\n\r\n    \r\n    function tradeTakerMinimumFeesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return tradeTakerMinimumFeeByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    function tradeTakerMinimumFee(uint256 blockNumber)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return tradeTakerMinimumFeeByBlockNumber.valueAt(blockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setTradeTakerMinimumFee(uint256 fromBlockNumber, int256 nominal)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        tradeTakerMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\r\n        emit SetTradeTakerMinimumFeeEvent(fromBlockNumber, nominal);\r\n    }\r\n\r\n    \r\n    function paymentMinimumFeesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return paymentMinimumFeeByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    function paymentMinimumFee(uint256 blockNumber)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return paymentMinimumFeeByBlockNumber.valueAt(blockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setPaymentMinimumFee(uint256 fromBlockNumber, int256 nominal)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        paymentMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\r\n        emit SetPaymentMinimumFeeEvent(fromBlockNumber, nominal);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function currencyPaymentMinimumFeesCount(address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function currencyPaymentMinimumFee(uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        if (0 < currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].count())\r\n            return currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].valueAt(blockNumber);\r\n        else\r\n            return paymentMinimumFee(blockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setCurrencyPaymentMinimumFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].addEntry(fromBlockNumber, nominal);\r\n        emit SetCurrencyPaymentMinimumFeeEvent(fromBlockNumber, currencyCt, currencyId, nominal);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function feeCurrenciesCount(address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return feeCurrencyByCurrencyBlockNumber.count(MonetaryTypesLib.Currency(currencyCt, currencyId));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function feeCurrency(uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (address ct, uint256 id)\r\n    {\r\n        MonetaryTypesLib.Currency storage _feeCurrency = feeCurrencyByCurrencyBlockNumber.currencyAt(\r\n            MonetaryTypesLib.Currency(currencyCt, currencyId), blockNumber\r\n        );\r\n        ct = _feeCurrency.ct;\r\n        id = _feeCurrency.id;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setFeeCurrency(uint256 fromBlockNumber, address referenceCurrencyCt, uint256 referenceCurrencyId,\r\n        address feeCurrencyCt, uint256 feeCurrencyId)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        feeCurrencyByCurrencyBlockNumber.addEntry(\r\n            fromBlockNumber,\r\n            MonetaryTypesLib.Currency(referenceCurrencyCt, referenceCurrencyId),\r\n            MonetaryTypesLib.Currency(feeCurrencyCt, feeCurrencyId)\r\n        );\r\n        emit SetFeeCurrencyEvent(fromBlockNumber, referenceCurrencyCt, referenceCurrencyId,\r\n            feeCurrencyCt, feeCurrencyId);\r\n    }\r\n\r\n    \r\n    \r\n    function walletLockTimeout()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletLockTimeoutByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setWalletLockTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        walletLockTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\r\n        emit SetWalletLockTimeoutEvent(fromBlockNumber, timeoutInSeconds);\r\n    }\r\n\r\n    \r\n    \r\n    function cancelOrderChallengeTimeout()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return cancelOrderChallengeTimeoutByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setCancelOrderChallengeTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        cancelOrderChallengeTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\r\n        emit SetCancelOrderChallengeTimeoutEvent(fromBlockNumber, timeoutInSeconds);\r\n    }\r\n\r\n    \r\n    \r\n    function settlementChallengeTimeout()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return settlementChallengeTimeoutByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setSettlementChallengeTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        settlementChallengeTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\r\n        emit SetSettlementChallengeTimeoutEvent(fromBlockNumber, timeoutInSeconds);\r\n    }\r\n\r\n    \r\n    \r\n    function fraudStakeFraction()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return fraudStakeFractionByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function setFraudStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        fraudStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\r\n        emit SetFraudStakeFractionEvent(fromBlockNumber, stakeFraction);\r\n    }\r\n\r\n    \r\n    \r\n    function walletSettlementStakeFraction()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletSettlementStakeFractionByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function setWalletSettlementStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        walletSettlementStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\r\n        emit SetWalletSettlementStakeFractionEvent(fromBlockNumber, stakeFraction);\r\n    }\r\n\r\n    \r\n    \r\n    function operatorSettlementStakeFraction()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return operatorSettlementStakeFractionByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function setOperatorSettlementStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        operatorSettlementStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\r\n        emit SetOperatorSettlementStakeFractionEvent(fromBlockNumber, stakeFraction);\r\n    }\r\n\r\n    \r\n    \r\n    function operatorSettlementStake()\r\n    public\r\n    view\r\n    returns (int256 amount, address currencyCt, uint256 currencyId)\r\n    {\r\n        MonetaryTypesLib.Figure storage stake = operatorSettlementStakeByBlockNumber.currentValue();\r\n        amount = stake.amount;\r\n        currencyCt = stake.currency.ct;\r\n        currencyId = stake.currency.id;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setOperatorSettlementStake(uint256 fromBlockNumber, int256 stakeAmount,\r\n        address stakeCurrencyCt, uint256 stakeCurrencyId)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        MonetaryTypesLib.Figure memory stake = MonetaryTypesLib.Figure(stakeAmount, MonetaryTypesLib.Currency(stakeCurrencyCt, stakeCurrencyId));\r\n        operatorSettlementStakeByBlockNumber.addEntry(fromBlockNumber, stake);\r\n        emit SetOperatorSettlementStakeEvent(fromBlockNumber, stakeAmount, stakeCurrencyCt, stakeCurrencyId);\r\n    }\r\n\r\n    \r\n    \r\n    function setEarliestSettlementBlockNumber(uint256 _earliestSettlementBlockNumber)\r\n    public\r\n    onlyOperator\r\n    {\r\n        require(!earliestSettlementBlockNumberUpdateDisabled, \"Earliest settlement block number update disabled [Configuration.sol:715]\");\r\n\r\n        earliestSettlementBlockNumber = _earliestSettlementBlockNumber;\r\n        emit SetEarliestSettlementBlockNumberEvent(earliestSettlementBlockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    function disableEarliestSettlementBlockNumberUpdate()\r\n    public\r\n    onlyOperator\r\n    {\r\n        earliestSettlementBlockNumberUpdateDisabled = true;\r\n        emit DisableEarliestSettlementBlockNumberUpdateEvent();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier onlyDelayedBlockNumber(uint256 blockNumber) {\r\n        require(\r\n            0 == updateDelayBlocksByBlockNumber.count() ||\r\n        blockNumber >= block.number + updateDelayBlocksByBlockNumber.currentValue(),\r\n            \"Block number not sufficiently delayed [Configuration.sol:735]\"\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Configurable is Ownable {\r\n    \r\n    \r\n    \r\n    Configuration public configuration;\r\n\r\n    \r\n    \r\n    \r\n    event SetConfigurationEvent(Configuration oldConfiguration, Configuration newConfiguration);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setConfiguration(Configuration newConfiguration)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(newConfiguration))\r\n    notSameAddresses(address(newConfiguration), address(configuration))\r\n    {\r\n        \r\n        Configuration oldConfiguration = configuration;\r\n        configuration = newConfiguration;\r\n\r\n        \r\n        emit SetConfigurationEvent(oldConfiguration, newConfiguration);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier configurationInitialized() {\r\n        require(address(configuration) != address(0), \"Configuration not initialized [Configurable.sol:52]\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract ConfigurableOperational is Configurable {\r\n    \r\n    \r\n    \r\n    modifier onlyOperationalModeNormal() {\r\n        require(configuration.isOperationalModeNormal(), \"Operational mode is not normal [ConfigurableOperational.sol:22]\");\r\n        _;\r\n    }\r\n}\r\n\r\nlibrary SafeMathUintLib {\r\n    function mul(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        \r\n        uint256 c = a / b;\r\n        \r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function clamp(uint256 a, uint256 min, uint256 max)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return (a > max) ? max : ((a < min) ? min : a);\r\n    }\r\n\r\n    function clampMin(uint256 a, uint256 min)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return (a < min) ? min : a;\r\n    }\r\n\r\n    function clampMax(uint256 a, uint256 max)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return (a > max) ? max : a;\r\n    }\r\n}\r\n\r\nlibrary CurrenciesLib {\r\n    using SafeMathUintLib for uint256;\r\n\r\n    \r\n    \r\n    \r\n    struct Currencies {\r\n        MonetaryTypesLib.Currency[] currencies;\r\n        mapping(address => mapping(uint256 => uint256)) indexByCurrency;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function add(Currencies storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        \r\n        if (0 == self.indexByCurrency[currencyCt][currencyId]) {\r\n            self.currencies.push(MonetaryTypesLib.Currency(currencyCt, currencyId));\r\n            self.indexByCurrency[currencyCt][currencyId] = self.currencies.length;\r\n        }\r\n    }\r\n\r\n    function removeByCurrency(Currencies storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        \r\n        uint256 index = self.indexByCurrency[currencyCt][currencyId];\r\n        if (0 < index)\r\n            removeByIndex(self, index - 1);\r\n    }\r\n\r\n    function removeByIndex(Currencies storage self, uint256 index)\r\n    internal\r\n    {\r\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:51]\");\r\n\r\n        address currencyCt = self.currencies[index].ct;\r\n        uint256 currencyId = self.currencies[index].id;\r\n\r\n        if (index < self.currencies.length - 1) {\r\n            self.currencies[index] = self.currencies[self.currencies.length - 1];\r\n            self.indexByCurrency[self.currencies[index].ct][self.currencies[index].id] = index + 1;\r\n        }\r\n        self.currencies.length--;\r\n        self.indexByCurrency[currencyCt][currencyId] = 0;\r\n    }\r\n\r\n    function count(Currencies storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.currencies.length;\r\n    }\r\n\r\n    function has(Currencies storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return 0 != self.indexByCurrency[currencyCt][currencyId];\r\n    }\r\n\r\n    function getByIndex(Currencies storage self, uint256 index)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Currency memory)\r\n    {\r\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:85]\");\r\n        return self.currencies[index];\r\n    }\r\n\r\n    function getByIndices(Currencies storage self, uint256 low, uint256 up)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Currency[] memory)\r\n    {\r\n        require(0 < self.currencies.length, \"No currencies found [CurrenciesLib.sol:94]\");\r\n        require(low <= up, \"Bounds parameters mismatch [CurrenciesLib.sol:95]\");\r\n\r\n        up = up.clampMax(self.currencies.length - 1);\r\n        MonetaryTypesLib.Currency[] memory _currencies = new MonetaryTypesLib.Currency[](up - low + 1);\r\n        for (uint256 i = low; i <= up; i++)\r\n            _currencies[i - low] = self.currencies[i];\r\n\r\n        return _currencies;\r\n    }\r\n}\r\n\r\nlibrary FungibleBalanceLib {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n    using CurrenciesLib for CurrenciesLib.Currencies;\r\n\r\n    \r\n    \r\n    \r\n    struct Record {\r\n        int256 amount;\r\n        uint256 blockNumber;\r\n    }\r\n\r\n    struct Balance {\r\n        mapping(address => mapping(uint256 => int256)) amountByCurrency;\r\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\r\n\r\n        CurrenciesLib.Currencies inUseCurrencies;\r\n        CurrenciesLib.Currencies everUsedCurrencies;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function get(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return self.amountByCurrency[currencyCt][currencyId];\r\n    }\r\n\r\n    function getByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        (int256 amount,) = recordByBlockNumber(self, currencyCt, currencyId, blockNumber);\r\n        return amount;\r\n    }\r\n\r\n    function set(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = amount;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function setByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\r\n        uint256 blockNumber)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = amount;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function add(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function addByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\r\n        uint256 blockNumber)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function sub(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function subByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\r\n        uint256 blockNumber)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function transfer(Balance storage _from, Balance storage _to, int256 amount,\r\n        address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        sub(_from, amount, currencyCt, currencyId);\r\n        add(_to, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    function add_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add_nn(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function sub_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub_nn(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function transfer_nn(Balance storage _from, Balance storage _to, int256 amount,\r\n        address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        sub_nn(_from, amount, currencyCt, currencyId);\r\n        add_nn(_to, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.recordsByCurrency[currencyCt][currencyId].length;\r\n    }\r\n\r\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (int256, uint256)\r\n    {\r\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\r\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (0, 0);\r\n    }\r\n\r\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\r\n    internal\r\n    view\r\n    returns (int256, uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return (0, 0);\r\n\r\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\r\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\r\n        return (record.amount, record.blockNumber);\r\n    }\r\n\r\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (int256, uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return (0, 0);\r\n\r\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\r\n        return (record.amount, record.blockNumber);\r\n    }\r\n\r\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return self.inUseCurrencies.has(currencyCt, currencyId);\r\n    }\r\n\r\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\r\n    }\r\n\r\n    function updateCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        if (0 == self.amountByCurrency[currencyCt][currencyId] && self.inUseCurrencies.has(currencyCt, currencyId))\r\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\r\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\r\n            self.inUseCurrencies.add(currencyCt, currencyId);\r\n            self.everUsedCurrencies.add(currencyCt, currencyId);\r\n        }\r\n    }\r\n\r\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return 0;\r\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\r\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\r\n                return i;\r\n        return 0;\r\n    }\r\n}\r\n\r\nlibrary NonFungibleBalanceLib {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n    using CurrenciesLib for CurrenciesLib.Currencies;\r\n\r\n    \r\n    \r\n    \r\n    struct Record {\r\n        int256[] ids;\r\n        uint256 blockNumber;\r\n    }\r\n\r\n    struct Balance {\r\n        mapping(address => mapping(uint256 => int256[])) idsByCurrency;\r\n        mapping(address => mapping(uint256 => mapping(int256 => uint256))) idIndexById;\r\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\r\n\r\n        CurrenciesLib.Currencies inUseCurrencies;\r\n        CurrenciesLib.Currencies everUsedCurrencies;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function get(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (int256[] memory)\r\n    {\r\n        return self.idsByCurrency[currencyCt][currencyId];\r\n    }\r\n\r\n    function getByIndices(Balance storage self, address currencyCt, uint256 currencyId, uint256 indexLow, uint256 indexUp)\r\n    internal\r\n    view\r\n    returns (int256[] memory)\r\n    {\r\n        if (0 == self.idsByCurrency[currencyCt][currencyId].length)\r\n            return new int256[](0);\r\n\r\n        indexUp = indexUp.clampMax(self.idsByCurrency[currencyCt][currencyId].length - 1);\r\n\r\n        int256[] memory idsByCurrency = new int256[](indexUp - indexLow + 1);\r\n        for (uint256 i = indexLow; i < indexUp; i++)\r\n            idsByCurrency[i - indexLow] = self.idsByCurrency[currencyCt][currencyId][i];\r\n\r\n        return idsByCurrency;\r\n    }\r\n\r\n    function idsCount(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.idsByCurrency[currencyCt][currencyId].length;\r\n    }\r\n\r\n    function hasId(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return 0 < self.idIndexById[currencyCt][currencyId][id];\r\n    }\r\n\r\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (int256[] memory, uint256)\r\n    {\r\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\r\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (new int256[](0), 0);\r\n    }\r\n\r\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\r\n    internal\r\n    view\r\n    returns (int256[] memory, uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return (new int256[](0), 0);\r\n\r\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\r\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\r\n        return (record.ids, record.blockNumber);\r\n    }\r\n\r\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (int256[] memory, uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return (new int256[](0), 0);\r\n\r\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\r\n        return (record.ids, record.blockNumber);\r\n    }\r\n\r\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.recordsByCurrency[currencyCt][currencyId].length;\r\n    }\r\n\r\n    function set(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        int256[] memory ids = new int256[](1);\r\n        ids[0] = id;\r\n        set(self, ids, currencyCt, currencyId);\r\n    }\r\n\r\n    function set(Balance storage self, int256[] memory ids, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        uint256 i;\r\n        for (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\r\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\r\n\r\n        self.idsByCurrency[currencyCt][currencyId] = ids;\r\n\r\n        for (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\r\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = i + 1;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateInUseCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function reset(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        for (uint256 i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\r\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\r\n\r\n        self.idsByCurrency[currencyCt][currencyId].length = 0;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateInUseCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function add(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\r\n    internal\r\n    returns (bool)\r\n    {\r\n        if (0 < self.idIndexById[currencyCt][currencyId][id])\r\n            return false;\r\n\r\n        self.idsByCurrency[currencyCt][currencyId].push(id);\r\n\r\n        self.idIndexById[currencyCt][currencyId][id] = self.idsByCurrency[currencyCt][currencyId].length;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateInUseCurrencies(self, currencyCt, currencyId);\r\n\r\n        return true;\r\n    }\r\n\r\n    function sub(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\r\n    internal\r\n    returns (bool)\r\n    {\r\n        uint256 index = self.idIndexById[currencyCt][currencyId][id];\r\n\r\n        if (0 == index)\r\n            return false;\r\n\r\n        if (index < self.idsByCurrency[currencyCt][currencyId].length) {\r\n            self.idsByCurrency[currencyCt][currencyId][index - 1] = self.idsByCurrency[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId].length - 1];\r\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][index - 1]] = index;\r\n        }\r\n        self.idsByCurrency[currencyCt][currencyId].length--;\r\n        self.idIndexById[currencyCt][currencyId][id] = 0;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateInUseCurrencies(self, currencyCt, currencyId);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(Balance storage _from, Balance storage _to, int256 id,\r\n        address currencyCt, uint256 currencyId)\r\n    internal\r\n    returns (bool)\r\n    {\r\n        return sub(_from, id, currencyCt, currencyId) && add(_to, id, currencyCt, currencyId);\r\n    }\r\n\r\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return self.inUseCurrencies.has(currencyCt, currencyId);\r\n    }\r\n\r\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\r\n    }\r\n\r\n    function updateInUseCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        if (0 == self.idsByCurrency[currencyCt][currencyId].length && self.inUseCurrencies.has(currencyCt, currencyId))\r\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\r\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\r\n            self.inUseCurrencies.add(currencyCt, currencyId);\r\n            self.everUsedCurrencies.add(currencyCt, currencyId);\r\n        }\r\n    }\r\n\r\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return 0;\r\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\r\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\r\n                return i;\r\n        return 0;\r\n    }\r\n}\r\n\r\ncontract BalanceTracker is Ownable, Servable {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\r\n    using NonFungibleBalanceLib for NonFungibleBalanceLib.Balance;\r\n\r\n    \r\n    \r\n    \r\n    string constant public DEPOSITED_BALANCE_TYPE = \"deposited\";\r\n    string constant public SETTLED_BALANCE_TYPE = \"settled\";\r\n    string constant public STAGED_BALANCE_TYPE = \"staged\";\r\n\r\n    \r\n    \r\n    \r\n    struct Wallet {\r\n        mapping(bytes32 => FungibleBalanceLib.Balance) fungibleBalanceByType;\r\n        mapping(bytes32 => NonFungibleBalanceLib.Balance) nonFungibleBalanceByType;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    bytes32 public depositedBalanceType;\r\n    bytes32 public settledBalanceType;\r\n    bytes32 public stagedBalanceType;\r\n\r\n    bytes32[] public _allBalanceTypes;\r\n    bytes32[] public _activeBalanceTypes;\r\n\r\n    bytes32[] public trackedBalanceTypes;\r\n    mapping(bytes32 => bool) public trackedBalanceTypeMap;\r\n\r\n    mapping(address => Wallet) private walletMap;\r\n\r\n    address[] public trackedWallets;\r\n    mapping(address => uint256) public trackedWalletIndexByWallet;\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer)\r\n    public\r\n    {\r\n        depositedBalanceType = keccak256(abi.encodePacked(DEPOSITED_BALANCE_TYPE));\r\n        settledBalanceType = keccak256(abi.encodePacked(SETTLED_BALANCE_TYPE));\r\n        stagedBalanceType = keccak256(abi.encodePacked(STAGED_BALANCE_TYPE));\r\n\r\n        _allBalanceTypes.push(settledBalanceType);\r\n        _allBalanceTypes.push(depositedBalanceType);\r\n        _allBalanceTypes.push(stagedBalanceType);\r\n\r\n        _activeBalanceTypes.push(settledBalanceType);\r\n        _activeBalanceTypes.push(depositedBalanceType);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function get(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return walletMap[wallet].fungibleBalanceByType[_type].get(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function getByIndices(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\r\n        uint256 indexLow, uint256 indexUp)\r\n    public\r\n    view\r\n    returns (int256[] memory)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].getByIndices(\r\n            currencyCt, currencyId, indexLow, indexUp\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function getAll(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256[] memory)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].get(\r\n            currencyCt, currencyId\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function idsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].idsCount(\r\n            currencyCt, currencyId\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function hasId(address wallet, bytes32 _type, int256 id, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].hasId(\r\n            id, currencyCt, currencyId\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function set(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId, bool fungible)\r\n    public\r\n    onlyActiveService\r\n    {\r\n        \r\n        if (fungible)\r\n            walletMap[wallet].fungibleBalanceByType[_type].set(\r\n                value, currencyCt, currencyId\r\n            );\r\n\r\n        else\r\n            walletMap[wallet].nonFungibleBalanceByType[_type].set(\r\n                value, currencyCt, currencyId\r\n            );\r\n\r\n        \r\n        _updateTrackedBalanceTypes(_type);\r\n\r\n        \r\n        _updateTrackedWallets(wallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setIds(address wallet, bytes32 _type, int256[] memory ids, address currencyCt, uint256 currencyId)\r\n    public\r\n    onlyActiveService\r\n    {\r\n        \r\n        walletMap[wallet].nonFungibleBalanceByType[_type].set(\r\n            ids, currencyCt, currencyId\r\n        );\r\n\r\n        \r\n        _updateTrackedBalanceTypes(_type);\r\n\r\n        \r\n        _updateTrackedWallets(wallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function add(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId,\r\n        bool fungible)\r\n    public\r\n    onlyActiveService\r\n    {\r\n        \r\n        if (fungible)\r\n            walletMap[wallet].fungibleBalanceByType[_type].add(\r\n                value, currencyCt, currencyId\r\n            );\r\n        else\r\n            walletMap[wallet].nonFungibleBalanceByType[_type].add(\r\n                value, currencyCt, currencyId\r\n            );\r\n\r\n        \r\n        _updateTrackedBalanceTypes(_type);\r\n\r\n        \r\n        _updateTrackedWallets(wallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function sub(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId,\r\n        bool fungible)\r\n    public\r\n    onlyActiveService\r\n    {\r\n        \r\n        if (fungible)\r\n            walletMap[wallet].fungibleBalanceByType[_type].sub(\r\n                value, currencyCt, currencyId\r\n            );\r\n        else\r\n            walletMap[wallet].nonFungibleBalanceByType[_type].sub(\r\n                value, currencyCt, currencyId\r\n            );\r\n\r\n        \r\n        _updateTrackedWallets(wallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function hasInUseCurrency(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return walletMap[wallet].fungibleBalanceByType[_type].hasInUseCurrency(currencyCt, currencyId)\r\n        || walletMap[wallet].nonFungibleBalanceByType[_type].hasInUseCurrency(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function hasEverUsedCurrency(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return walletMap[wallet].fungibleBalanceByType[_type].hasEverUsedCurrency(currencyCt, currencyId)\r\n        || walletMap[wallet].nonFungibleBalanceByType[_type].hasEverUsedCurrency(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function fungibleRecordsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletMap[wallet].fungibleBalanceByType[_type].recordsCount(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function fungibleRecordByIndex(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\r\n        uint256 index)\r\n    public\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        return walletMap[wallet].fungibleBalanceByType[_type].recordByIndex(currencyCt, currencyId, index);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function fungibleRecordByBlockNumber(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\r\n        uint256 _blockNumber)\r\n    public\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        return walletMap[wallet].fungibleBalanceByType[_type].recordByBlockNumber(currencyCt, currencyId, _blockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function lastFungibleRecord(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        return walletMap[wallet].fungibleBalanceByType[_type].lastRecord(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function nonFungibleRecordsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordsCount(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function nonFungibleRecordByIndex(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\r\n        uint256 index)\r\n    public\r\n    view\r\n    returns (int256[] memory ids, uint256 blockNumber)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordByIndex(currencyCt, currencyId, index);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function nonFungibleRecordByBlockNumber(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\r\n        uint256 _blockNumber)\r\n    public\r\n    view\r\n    returns (int256[] memory ids, uint256 blockNumber)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordByBlockNumber(currencyCt, currencyId, _blockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function lastNonFungibleRecord(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256[] memory ids, uint256 blockNumber)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].lastRecord(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    function trackedBalanceTypesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return trackedBalanceTypes.length;\r\n    }\r\n\r\n    \r\n    \r\n    function trackedWalletsCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return trackedWallets.length;\r\n    }\r\n\r\n    \r\n    \r\n    function allBalanceTypes()\r\n    public\r\n    view\r\n    returns (bytes32[] memory)\r\n    {\r\n        return _allBalanceTypes;\r\n    }\r\n\r\n    \r\n    \r\n    function activeBalanceTypes()\r\n    public\r\n    view\r\n    returns (bytes32[] memory)\r\n    {\r\n        return _activeBalanceTypes;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function trackedWalletsByIndices(uint256 low, uint256 up)\r\n    public\r\n    view\r\n    returns (address[] memory)\r\n    {\r\n        require(0 < trackedWallets.length, \"No tracked wallets found [BalanceTracker.sol:473]\");\r\n        require(low <= up, \"Bounds parameters mismatch [BalanceTracker.sol:474]\");\r\n\r\n        up = up.clampMax(trackedWallets.length - 1);\r\n        address[] memory _trackedWallets = new address[](up - low + 1);\r\n        for (uint256 i = low; i <= up; i++)\r\n            _trackedWallets[i - low] = trackedWallets[i];\r\n\r\n        return _trackedWallets;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function _updateTrackedBalanceTypes(bytes32 _type)\r\n    private\r\n    {\r\n        if (!trackedBalanceTypeMap[_type]) {\r\n            trackedBalanceTypeMap[_type] = true;\r\n            trackedBalanceTypes.push(_type);\r\n        }\r\n    }\r\n\r\n    function _updateTrackedWallets(address wallet)\r\n    private\r\n    {\r\n        if (0 == trackedWalletIndexByWallet[wallet]) {\r\n            trackedWallets.push(wallet);\r\n            trackedWalletIndexByWallet[wallet] = trackedWallets.length;\r\n        }\r\n    }\r\n}\r\n\r\ncontract BalanceTrackable is Ownable {\r\n    \r\n    \r\n    \r\n    BalanceTracker public balanceTracker;\r\n    bool public balanceTrackerFrozen;\r\n\r\n    \r\n    \r\n    \r\n    event SetBalanceTrackerEvent(BalanceTracker oldBalanceTracker, BalanceTracker newBalanceTracker);\r\n    event FreezeBalanceTrackerEvent();\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setBalanceTracker(BalanceTracker newBalanceTracker)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(newBalanceTracker))\r\n    notSameAddresses(address(newBalanceTracker), address(balanceTracker))\r\n    {\r\n        \r\n        require(!balanceTrackerFrozen, \"Balance tracker frozen [BalanceTrackable.sol:43]\");\r\n\r\n        \r\n        BalanceTracker oldBalanceTracker = balanceTracker;\r\n        balanceTracker = newBalanceTracker;\r\n\r\n        \r\n        emit SetBalanceTrackerEvent(oldBalanceTracker, newBalanceTracker);\r\n    }\r\n\r\n    \r\n    \r\n    function freezeBalanceTracker()\r\n    public\r\n    onlyDeployer\r\n    {\r\n        balanceTrackerFrozen = true;\r\n\r\n        \r\n        emit FreezeBalanceTrackerEvent();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier balanceTrackerInitialized() {\r\n        require(address(balanceTracker) != address(0), \"Balance tracker not initialized [BalanceTrackable.sol:69]\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract AuthorizableServable is Servable {\r\n    \r\n    \r\n    \r\n    bool public initialServiceAuthorizationDisabled;\r\n\r\n    mapping(address => bool) public initialServiceAuthorizedMap;\r\n    mapping(address => mapping(address => bool)) public initialServiceWalletUnauthorizedMap;\r\n\r\n    mapping(address => mapping(address => bool)) public serviceWalletAuthorizedMap;\r\n\r\n    mapping(address => mapping(bytes32 => mapping(address => bool))) public serviceActionWalletAuthorizedMap;\r\n    mapping(address => mapping(bytes32 => mapping(address => bool))) public serviceActionWalletTouchedMap;\r\n    mapping(address => mapping(address => bytes32[])) public serviceWalletActionList;\r\n\r\n    \r\n    \r\n    \r\n    event AuthorizeInitialServiceEvent(address wallet, address service);\r\n    event AuthorizeRegisteredServiceEvent(address wallet, address service);\r\n    event AuthorizeRegisteredServiceActionEvent(address wallet, address service, string action);\r\n    event UnauthorizeRegisteredServiceEvent(address wallet, address service);\r\n    event UnauthorizeRegisteredServiceActionEvent(address wallet, address service, string action);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function authorizeInitialService(address service)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        require(!initialServiceAuthorizationDisabled);\r\n        require(msg.sender != service);\r\n\r\n        \r\n        require(registeredServicesMap[service].registered);\r\n\r\n        \r\n        initialServiceAuthorizedMap[service] = true;\r\n\r\n        \r\n        emit AuthorizeInitialServiceEvent(msg.sender, service);\r\n    }\r\n\r\n    \r\n    \r\n    function disableInitialServiceAuthorization()\r\n    public\r\n    onlyDeployer\r\n    {\r\n        initialServiceAuthorizationDisabled = true;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function authorizeRegisteredService(address service)\r\n    public\r\n    notNullOrThisAddress(service)\r\n    {\r\n        require(msg.sender != service);\r\n\r\n        \r\n        require(registeredServicesMap[service].registered);\r\n\r\n        \r\n        require(!initialServiceAuthorizedMap[service]);\r\n\r\n        \r\n        serviceWalletAuthorizedMap[service][msg.sender] = true;\r\n\r\n        \r\n        emit AuthorizeRegisteredServiceEvent(msg.sender, service);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function unauthorizeRegisteredService(address service)\r\n    public\r\n    notNullOrThisAddress(service)\r\n    {\r\n        require(msg.sender != service);\r\n\r\n        \r\n        require(registeredServicesMap[service].registered);\r\n\r\n        \r\n        if (initialServiceAuthorizedMap[service])\r\n            initialServiceWalletUnauthorizedMap[service][msg.sender] = true;\r\n\r\n        \r\n        else {\r\n            serviceWalletAuthorizedMap[service][msg.sender] = false;\r\n            for (uint256 i = 0; i < serviceWalletActionList[service][msg.sender].length; i++)\r\n                serviceActionWalletAuthorizedMap[service][serviceWalletActionList[service][msg.sender][i]][msg.sender] = true;\r\n        }\r\n\r\n        \r\n        emit UnauthorizeRegisteredServiceEvent(msg.sender, service);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function isAuthorizedRegisteredService(address service, address wallet)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return isRegisteredActiveService(service) &&\r\n        (isInitialServiceAuthorizedForWallet(service, wallet) || serviceWalletAuthorizedMap[service][wallet]);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function authorizeRegisteredServiceAction(address service, string memory action)\r\n    public\r\n    notNullOrThisAddress(service)\r\n    {\r\n        require(msg.sender != service);\r\n\r\n        bytes32 actionHash = hashString(action);\r\n\r\n        \r\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\r\n\r\n        \r\n        require(!initialServiceAuthorizedMap[service]);\r\n\r\n        \r\n        serviceWalletAuthorizedMap[service][msg.sender] = false;\r\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\r\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\r\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\r\n            serviceWalletActionList[service][msg.sender].push(actionHash);\r\n        }\r\n\r\n        \r\n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function unauthorizeRegisteredServiceAction(address service, string memory action)\r\n    public\r\n    notNullOrThisAddress(service)\r\n    {\r\n        require(msg.sender != service);\r\n\r\n        bytes32 actionHash = hashString(action);\r\n\r\n        \r\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\r\n\r\n        \r\n        require(!initialServiceAuthorizedMap[service]);\r\n\r\n        \r\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\r\n\r\n        \r\n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function isAuthorizedRegisteredServiceAction(address service, string memory action, address wallet)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        bytes32 actionHash = hashString(action);\r\n\r\n        return isEnabledServiceAction(service, action) &&\r\n        (\r\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\r\n        serviceWalletAuthorizedMap[service][wallet] ||\r\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\r\n        );\r\n    }\r\n\r\n    function isInitialServiceAuthorizedForWallet(address service, address wallet)\r\n    private\r\n    view\r\n    returns (bool)\r\n    {\r\n        return initialServiceAuthorizedMap[service] ? !initialServiceWalletUnauthorizedMap[service][wallet] : false;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier onlyAuthorizedService(address wallet) {\r\n        require(isAuthorizedRegisteredService(msg.sender, wallet));\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorizedServiceAction(string memory action, address wallet) {\r\n        require(isAuthorizedRegisteredServiceAction(msg.sender, action, wallet));\r\n        _;\r\n    }\r\n}\r\n\r\ncontract WalletLocker is Ownable, Configurable, AuthorizableServable {\r\n    using SafeMathUintLib for uint256;\r\n\r\n    \r\n    \r\n    \r\n    struct FungibleLock {\r\n        address locker;\r\n        address currencyCt;\r\n        uint256 currencyId;\r\n        int256 amount;\r\n        uint256 visibleTime;\r\n        uint256 unlockTime;\r\n    }\r\n\r\n    struct NonFungibleLock {\r\n        address locker;\r\n        address currencyCt;\r\n        uint256 currencyId;\r\n        int256[] ids;\r\n        uint256 visibleTime;\r\n        uint256 unlockTime;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    mapping(address => FungibleLock[]) public walletFungibleLocks;\r\n    mapping(address => mapping(address => mapping(uint256 => mapping(address => uint256)))) public lockedCurrencyLockerFungibleLockIndex;\r\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public walletCurrencyFungibleLockCount;\r\n\r\n    mapping(address => NonFungibleLock[]) public walletNonFungibleLocks;\r\n    mapping(address => mapping(address => mapping(uint256 => mapping(address => uint256)))) public lockedCurrencyLockerNonFungibleLockIndex;\r\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public walletCurrencyNonFungibleLockCount;\r\n\r\n    \r\n    \r\n    \r\n    event LockFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256 amount,\r\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds);\r\n    event LockNonFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256[] ids,\r\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds);\r\n    event UnlockFungibleEvent(address lockedWallet, address lockerWallet, int256 amount, address currencyCt,\r\n        uint256 currencyId);\r\n    event UnlockFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256 amount, address currencyCt,\r\n        uint256 currencyId);\r\n    event UnlockNonFungibleEvent(address lockedWallet, address lockerWallet, int256[] ids, address currencyCt,\r\n        uint256 currencyId);\r\n    event UnlockNonFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256[] ids, address currencyCt,\r\n        uint256 currencyId);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer)\r\n    public\r\n    {\r\n    }\r\n\r\n    \r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function lockFungibleByProxy(address lockedWallet, address lockerWallet, int256 amount,\r\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\r\n    public\r\n    onlyAuthorizedService(lockedWallet)\r\n    {\r\n        \r\n        require(lockedWallet != lockerWallet);\r\n\r\n        \r\n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\r\n\r\n        \r\n        require(\r\n            (0 == lockIndex) ||\r\n            (block.timestamp >= walletFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\r\n        );\r\n\r\n        \r\n        if (0 == lockIndex) {\r\n            lockIndex = ++(walletFungibleLocks[lockedWallet].length);\r\n            lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\r\n            walletCurrencyFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\r\n        }\r\n\r\n        \r\n        walletFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\r\n        walletFungibleLocks[lockedWallet][lockIndex - 1].amount = amount;\r\n        walletFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\r\n        walletFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\r\n        walletFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\r\n        block.timestamp.add(visibleTimeoutInSeconds);\r\n        walletFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\r\n        block.timestamp.add(configuration.walletLockTimeout());\r\n\r\n        \r\n        emit LockFungibleByProxyEvent(lockedWallet, lockerWallet, amount, currencyCt, currencyId, visibleTimeoutInSeconds);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function lockNonFungibleByProxy(address lockedWallet, address lockerWallet, int256[] memory ids,\r\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\r\n    public\r\n    onlyAuthorizedService(lockedWallet)\r\n    {\r\n        \r\n        require(lockedWallet != lockerWallet);\r\n\r\n        \r\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\r\n\r\n        \r\n        require(\r\n            (0 == lockIndex) ||\r\n            (block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\r\n        );\r\n\r\n        \r\n        if (0 == lockIndex) {\r\n            lockIndex = ++(walletNonFungibleLocks[lockedWallet].length);\r\n            lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\r\n            walletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\r\n        }\r\n\r\n        \r\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\r\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids = ids;\r\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\r\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\r\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\r\n        block.timestamp.add(visibleTimeoutInSeconds);\r\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\r\n        block.timestamp.add(configuration.walletLockTimeout());\r\n\r\n        \r\n        emit LockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId, visibleTimeoutInSeconds);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function unlockFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    {\r\n        \r\n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\r\n\r\n        \r\n        if (0 == lockIndex)\r\n            return;\r\n\r\n        \r\n        require(\r\n            block.timestamp >= walletFungibleLocks[lockedWallet][lockIndex - 1].unlockTime\r\n        );\r\n\r\n        \r\n        int256 amount = _unlockFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\r\n\r\n        \r\n        emit UnlockFungibleEvent(lockedWallet, lockerWallet, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function unlockFungibleByProxy(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    onlyAuthorizedService(lockedWallet)\r\n    {\r\n        \r\n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\r\n\r\n        \r\n        if (0 == lockIndex)\r\n            return;\r\n\r\n        \r\n        int256 amount = _unlockFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\r\n\r\n        \r\n        emit UnlockFungibleByProxyEvent(lockedWallet, lockerWallet, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function unlockNonFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    {\r\n        \r\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\r\n\r\n        \r\n        if (0 == lockIndex)\r\n            return;\r\n\r\n        \r\n        require(\r\n            block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime\r\n        );\r\n\r\n        \r\n        int256[] memory ids = _unlockNonFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\r\n\r\n        \r\n        emit UnlockNonFungibleEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function unlockNonFungibleByProxy(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    onlyAuthorizedService(lockedWallet)\r\n    {\r\n        \r\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\r\n\r\n        \r\n        if (0 == lockIndex)\r\n            return;\r\n\r\n        \r\n        int256[] memory ids = _unlockNonFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\r\n\r\n        \r\n        emit UnlockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function fungibleLocksCount(address wallet)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletFungibleLocks[wallet].length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function nonFungibleLocksCount(address wallet)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletNonFungibleLocks[wallet].length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function lockedAmount(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\r\n\r\n        if (0 == lockIndex || block.timestamp < walletFungibleLocks[lockedWallet][lockIndex - 1].visibleTime)\r\n            return 0;\r\n\r\n        return walletFungibleLocks[lockedWallet][lockIndex - 1].amount;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function lockedIdsCount(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\r\n\r\n        if (0 == lockIndex || block.timestamp < walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime)\r\n            return 0;\r\n\r\n        return walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids.length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function lockedIdsByIndices(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId,\r\n        uint256 low, uint256 up)\r\n    public\r\n    view\r\n    returns (int256[] memory)\r\n    {\r\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\r\n\r\n        if (0 == lockIndex || block.timestamp < walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime)\r\n            return new int256[](0);\r\n\r\n        NonFungibleLock storage lock = walletNonFungibleLocks[lockedWallet][lockIndex - 1];\r\n\r\n        if (0 == lock.ids.length)\r\n            return new int256[](0);\r\n\r\n        up = up.clampMax(lock.ids.length - 1);\r\n        int256[] memory _ids = new int256[](up - low + 1);\r\n        for (uint256 i = low; i <= up; i++)\r\n            _ids[i - low] = lock.ids[i];\r\n\r\n        return _ids;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isLocked(address wallet)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return 0 < walletFungibleLocks[wallet].length ||\r\n        0 < walletNonFungibleLocks[wallet].length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function isLocked(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return 0 < walletCurrencyFungibleLockCount[wallet][currencyCt][currencyId] ||\r\n        0 < walletCurrencyNonFungibleLockCount[wallet][currencyCt][currencyId];\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function isLocked(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return 0 < lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] ||\r\n        0 < lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function _unlockFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId, uint256 lockIndex)\r\n    private\r\n    returns (int256)\r\n    {\r\n        int256 amount = walletFungibleLocks[lockedWallet][lockIndex - 1].amount;\r\n\r\n        if (lockIndex < walletFungibleLocks[lockedWallet].length) {\r\n            walletFungibleLocks[lockedWallet][lockIndex - 1] =\r\n            walletFungibleLocks[lockedWallet][walletFungibleLocks[lockedWallet].length - 1];\r\n\r\n            lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][walletFungibleLocks[lockedWallet][lockIndex - 1].locker] = lockIndex;\r\n        }\r\n        walletFungibleLocks[lockedWallet].length--;\r\n\r\n        lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = 0;\r\n\r\n        walletCurrencyFungibleLockCount[lockedWallet][currencyCt][currencyId]--;\r\n\r\n        return amount;\r\n    }\r\n\r\n    function _unlockNonFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId, uint256 lockIndex)\r\n    private\r\n    returns (int256[] memory)\r\n    {\r\n        int256[] memory ids = walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids;\r\n\r\n        if (lockIndex < walletNonFungibleLocks[lockedWallet].length) {\r\n            walletNonFungibleLocks[lockedWallet][lockIndex - 1] =\r\n            walletNonFungibleLocks[lockedWallet][walletNonFungibleLocks[lockedWallet].length - 1];\r\n\r\n            lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][walletNonFungibleLocks[lockedWallet][lockIndex - 1].locker] = lockIndex;\r\n        }\r\n        walletNonFungibleLocks[lockedWallet].length--;\r\n\r\n        lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = 0;\r\n\r\n        walletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]--;\r\n\r\n        return ids;\r\n    }\r\n}\r\n\r\ncontract WalletLockable is Ownable {\r\n    \r\n    \r\n    \r\n    WalletLocker public walletLocker;\r\n    bool public walletLockerFrozen;\r\n\r\n    \r\n    \r\n    \r\n    event SetWalletLockerEvent(WalletLocker oldWalletLocker, WalletLocker newWalletLocker);\r\n    event FreezeWalletLockerEvent();\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setWalletLocker(WalletLocker newWalletLocker)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(newWalletLocker))\r\n    notSameAddresses(address(newWalletLocker), address(walletLocker))\r\n    {\r\n        \r\n        require(!walletLockerFrozen, \"Wallet locker frozen [WalletLockable.sol:43]\");\r\n\r\n        \r\n        WalletLocker oldWalletLocker = walletLocker;\r\n        walletLocker = newWalletLocker;\r\n\r\n        \r\n        emit SetWalletLockerEvent(oldWalletLocker, newWalletLocker);\r\n    }\r\n\r\n    \r\n    \r\n    function freezeWalletLocker()\r\n    public\r\n    onlyDeployer\r\n    {\r\n        walletLockerFrozen = true;\r\n\r\n        \r\n        emit FreezeWalletLockerEvent();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier walletLockerInitialized() {\r\n        require(address(walletLocker) != address(0), \"Wallet locker not initialized [WalletLockable.sol:69]\");\r\n        _;\r\n    }\r\n}\r\n\r\nlibrary NahmiiTypesLib {\r\n    \r\n    \r\n    \r\n    enum ChallengePhase {Dispute, Closed}\r\n\r\n    \r\n    \r\n    \r\n    struct OriginFigure {\r\n        uint256 originId;\r\n        MonetaryTypesLib.Figure figure;\r\n    }\r\n\r\n    struct IntendedConjugateCurrency {\r\n        MonetaryTypesLib.Currency intended;\r\n        MonetaryTypesLib.Currency conjugate;\r\n    }\r\n\r\n    struct SingleFigureTotalOriginFigures {\r\n        MonetaryTypesLib.Figure single;\r\n        OriginFigure[] total;\r\n    }\r\n\r\n    struct TotalOriginFigures {\r\n        OriginFigure[] total;\r\n    }\r\n\r\n    struct CurrentPreviousInt256 {\r\n        int256 current;\r\n        int256 previous;\r\n    }\r\n\r\n    struct SingleTotalInt256 {\r\n        int256 single;\r\n        int256 total;\r\n    }\r\n\r\n    struct IntendedConjugateCurrentPreviousInt256 {\r\n        CurrentPreviousInt256 intended;\r\n        CurrentPreviousInt256 conjugate;\r\n    }\r\n\r\n    struct IntendedConjugateSingleTotalInt256 {\r\n        SingleTotalInt256 intended;\r\n        SingleTotalInt256 conjugate;\r\n    }\r\n\r\n    struct WalletOperatorHashes {\r\n        bytes32 wallet;\r\n        bytes32 operator;\r\n    }\r\n\r\n    struct Signature {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n    }\r\n\r\n    struct Seal {\r\n        bytes32 hash;\r\n        Signature signature;\r\n    }\r\n\r\n    struct WalletOperatorSeal {\r\n        Seal wallet;\r\n        Seal operator;\r\n    }\r\n}\r\n\r\nlibrary PaymentTypesLib {\r\n    \r\n    \r\n    \r\n    enum PaymentPartyRole {Sender, Recipient}\r\n\r\n    \r\n    \r\n    \r\n    struct PaymentSenderParty {\r\n        uint256 nonce;\r\n        address wallet;\r\n\r\n        NahmiiTypesLib.CurrentPreviousInt256 balances;\r\n\r\n        NahmiiTypesLib.SingleFigureTotalOriginFigures fees;\r\n\r\n        string data;\r\n    }\r\n\r\n    struct PaymentRecipientParty {\r\n        uint256 nonce;\r\n        address wallet;\r\n\r\n        NahmiiTypesLib.CurrentPreviousInt256 balances;\r\n\r\n        NahmiiTypesLib.TotalOriginFigures fees;\r\n    }\r\n\r\n    struct Operator {\r\n        uint256 id;\r\n        string data;\r\n    }\r\n\r\n    struct Payment {\r\n        int256 amount;\r\n        MonetaryTypesLib.Currency currency;\r\n\r\n        PaymentSenderParty sender;\r\n        PaymentRecipientParty recipient;\r\n\r\n        \r\n        NahmiiTypesLib.SingleTotalInt256 transfers;\r\n\r\n        NahmiiTypesLib.WalletOperatorSeal seals;\r\n        uint256 blockNumber;\r\n\r\n        Operator operator;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function PAYMENT_KIND()\r\n    public\r\n    pure\r\n    returns (string memory)\r\n    {\r\n        return \"payment\";\r\n    }\r\n}\r\n\r\ncontract PaymentHasher is Ownable {\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function hashPaymentAsWallet(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        bytes32 amountCurrencyHash = hashPaymentAmountCurrency(payment);\r\n        bytes32 senderHash = hashPaymentSenderPartyAsWallet(payment.sender);\r\n        bytes32 recipientHash = hashAddress(payment.recipient.wallet);\r\n\r\n        return keccak256(abi.encodePacked(amountCurrencyHash, senderHash, recipientHash));\r\n    }\r\n\r\n    function hashPaymentAsOperator(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        bytes32 walletSignatureHash = hashSignature(payment.seals.wallet.signature);\r\n        bytes32 senderHash = hashPaymentSenderPartyAsOperator(payment.sender);\r\n        bytes32 recipientHash = hashPaymentRecipientPartyAsOperator(payment.recipient);\r\n        bytes32 transfersHash = hashSingleTotalInt256(payment.transfers);\r\n        bytes32 operatorHash = hashString(payment.operator.data);\r\n\r\n        return keccak256(abi.encodePacked(\r\n                walletSignatureHash, senderHash, recipientHash, transfersHash, operatorHash\r\n            ));\r\n    }\r\n\r\n    function hashPaymentAmountCurrency(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\r\n                payment.amount,\r\n                payment.currency.ct,\r\n                payment.currency.id\r\n            ));\r\n    }\r\n\r\n    function hashPaymentSenderPartyAsWallet(\r\n        PaymentTypesLib.PaymentSenderParty memory paymentSenderParty)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\r\n                paymentSenderParty.wallet,\r\n                paymentSenderParty.data\r\n            ));\r\n    }\r\n\r\n    function hashPaymentSenderPartyAsOperator(\r\n        PaymentTypesLib.PaymentSenderParty memory paymentSenderParty)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        bytes32 rootHash = hashUint256(paymentSenderParty.nonce);\r\n        bytes32 balancesHash = hashCurrentPreviousInt256(paymentSenderParty.balances);\r\n        bytes32 singleFeeHash = hashFigure(paymentSenderParty.fees.single);\r\n        bytes32 totalFeesHash = hashOriginFigures(paymentSenderParty.fees.total);\r\n\r\n        return keccak256(abi.encodePacked(\r\n                rootHash, balancesHash, singleFeeHash, totalFeesHash\r\n            ));\r\n    }\r\n\r\n    function hashPaymentRecipientPartyAsOperator(\r\n        PaymentTypesLib.PaymentRecipientParty memory paymentRecipientParty)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        bytes32 rootHash = hashUint256(paymentRecipientParty.nonce);\r\n        bytes32 balancesHash = hashCurrentPreviousInt256(paymentRecipientParty.balances);\r\n        bytes32 totalFeesHash = hashOriginFigures(paymentRecipientParty.fees.total);\r\n\r\n        return keccak256(abi.encodePacked(\r\n                rootHash, balancesHash, totalFeesHash\r\n            ));\r\n    }\r\n\r\n    function hashCurrentPreviousInt256(\r\n        NahmiiTypesLib.CurrentPreviousInt256 memory currentPreviousInt256)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\r\n                currentPreviousInt256.current,\r\n                currentPreviousInt256.previous\r\n            ));\r\n    }\r\n\r\n    function hashSingleTotalInt256(\r\n        NahmiiTypesLib.SingleTotalInt256 memory singleTotalInt256)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\r\n                singleTotalInt256.single,\r\n                singleTotalInt256.total\r\n            ));\r\n    }\r\n\r\n    function hashFigure(MonetaryTypesLib.Figure memory figure)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\r\n                figure.amount,\r\n                figure.currency.ct,\r\n                figure.currency.id\r\n            ));\r\n    }\r\n\r\n    function hashOriginFigures(NahmiiTypesLib.OriginFigure[] memory originFigures)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        bytes32 hash;\r\n        for (uint256 i = 0; i < originFigures.length; i++) {\r\n            hash = keccak256(abi.encodePacked(\r\n                    hash,\r\n                    originFigures[i].originId,\r\n                    originFigures[i].figure.amount,\r\n                    originFigures[i].figure.currency.ct,\r\n                    originFigures[i].figure.currency.id\r\n                )\r\n            );\r\n        }\r\n        return hash;\r\n    }\r\n\r\n    function hashUint256(uint256 _uint256)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_uint256));\r\n    }\r\n\r\n    function hashString(string memory _string)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_string));\r\n    }\r\n\r\n    function hashAddress(address _address)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_address));\r\n    }\r\n\r\n    function hashSignature(NahmiiTypesLib.Signature memory signature)\r\n    public\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\r\n                signature.v,\r\n                signature.r,\r\n                signature.s\r\n            ));\r\n    }\r\n}\r\n\r\ncontract PaymentHashable is Ownable {\r\n    \r\n    \r\n    \r\n    PaymentHasher public paymentHasher;\r\n\r\n    \r\n    \r\n    \r\n    event SetPaymentHasherEvent(PaymentHasher oldPaymentHasher, PaymentHasher newPaymentHasher);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setPaymentHasher(PaymentHasher newPaymentHasher)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(newPaymentHasher))\r\n    notSameAddresses(address(newPaymentHasher), address(paymentHasher))\r\n    {\r\n        \r\n        PaymentHasher oldPaymentHasher = paymentHasher;\r\n        paymentHasher = newPaymentHasher;\r\n\r\n        \r\n        emit SetPaymentHasherEvent(oldPaymentHasher, newPaymentHasher);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier paymentHasherInitialized() {\r\n        require(address(paymentHasher) != address(0), \"Payment hasher not initialized [PaymentHashable.sol:52]\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract SignerManager is Ownable {\r\n    using SafeMathUintLib for uint256;\r\n    \r\n    \r\n    \r\n    \r\n    mapping(address => uint256) public signerIndicesMap; \r\n    address[] public signers;\r\n\r\n    \r\n    \r\n    \r\n    event RegisterSignerEvent(address signer);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n        registerSigner(deployer);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function isSigner(address _address)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return 0 < signerIndicesMap[_address];\r\n    }\r\n\r\n    \r\n    \r\n    function signersCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return signers.length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function signerIndex(address _address)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(isSigner(_address), \"Address not signer [SignerManager.sol:71]\");\r\n        return signerIndicesMap[_address] - 1;\r\n    }\r\n\r\n    \r\n    \r\n    function registerSigner(address newSigner)\r\n    public\r\n    onlyOperator\r\n    notNullOrThisAddress(newSigner)\r\n    {\r\n        if (0 == signerIndicesMap[newSigner]) {\r\n            \r\n            signers.push(newSigner);\r\n            signerIndicesMap[newSigner] = signers.length;\r\n\r\n            \r\n            emit RegisterSignerEvent(newSigner);\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function signersByIndices(uint256 low, uint256 up)\r\n    public\r\n    view\r\n    returns (address[] memory)\r\n    {\r\n        require(0 < signers.length, \"No signers found [SignerManager.sol:101]\");\r\n        require(low <= up, \"Bounds parameters mismatch [SignerManager.sol:102]\");\r\n\r\n        up = up.clampMax(signers.length - 1);\r\n        address[] memory _signers = new address[](up - low + 1);\r\n        for (uint256 i = low; i <= up; i++)\r\n            _signers[i - low] = signers[i];\r\n\r\n        return _signers;\r\n    }\r\n}\r\n\r\ncontract SignerManageable is Ownable {\r\n    \r\n    \r\n    \r\n    SignerManager public signerManager;\r\n\r\n    \r\n    \r\n    \r\n    event SetSignerManagerEvent(address oldSignerManager, address newSignerManager);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address manager) public notNullAddress(manager) {\r\n        signerManager = SignerManager(manager);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setSignerManager(address newSignerManager)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(newSignerManager)\r\n    {\r\n        if (newSignerManager != address(signerManager)) {\r\n            \r\n            address oldSignerManager = address(signerManager);\r\n            signerManager = SignerManager(newSignerManager);\r\n\r\n            \r\n            emit SetSignerManagerEvent(oldSignerManager, newSignerManager);\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function ethrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\r\n    public\r\n    pure\r\n    returns (address)\r\n    {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\r\n        return ecrecover(prefixedHash, v, r, s);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function isSignedByRegisteredSigner(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return signerManager.isSigner(ethrecover(hash, v, r, s));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function isSignedBy(bytes32 hash, uint8 v, bytes32 r, bytes32 s, address signer)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return signer == ethrecover(hash, v, r, s);\r\n    }\r\n\r\n    \r\n    \r\n    modifier signerManagerInitialized() {\r\n        require(address(signerManager) != address(0), \"Signer manager not initialized [SignerManageable.sol:105]\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Validator is Ownable, SignerManageable, Configurable, PaymentHashable {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer, address signerManager) Ownable(deployer) SignerManageable(signerManager) public {\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isGenuineOperatorSignature(bytes32 hash, NahmiiTypesLib.Signature memory signature)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return isSignedByRegisteredSigner(hash, signature.v, signature.r, signature.s);\r\n    }\r\n\r\n    function isGenuineWalletSignature(bytes32 hash, NahmiiTypesLib.Signature memory signature, address wallet)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return isSignedBy(hash, signature.v, signature.r, signature.s, wallet);\r\n    }\r\n\r\n    function isGenuinePaymentWalletHash(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return paymentHasher.hashPaymentAsWallet(payment) == payment.seals.wallet.hash;\r\n    }\r\n\r\n    function isGenuinePaymentOperatorHash(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return paymentHasher.hashPaymentAsOperator(payment) == payment.seals.operator.hash;\r\n    }\r\n\r\n    function isGenuinePaymentWalletSeal(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return isGenuinePaymentWalletHash(payment)\r\n        && isGenuineWalletSignature(payment.seals.wallet.hash, payment.seals.wallet.signature, payment.sender.wallet);\r\n    }\r\n\r\n    function isGenuinePaymentOperatorSeal(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return isGenuinePaymentOperatorHash(payment)\r\n        && isGenuineOperatorSignature(payment.seals.operator.hash, payment.seals.operator.signature);\r\n    }\r\n\r\n    function isGenuinePaymentSeals(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return isGenuinePaymentWalletSeal(payment) && isGenuinePaymentOperatorSeal(payment);\r\n    }\r\n\r\n    \r\n    function isGenuinePaymentFeeOfFungible(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        int256 feePartsPer = int256(ConstantsLib.PARTS_PER());\r\n\r\n        int256 feeAmount = payment.amount\r\n        .mul(\r\n            configuration.currencyPaymentFee(\r\n                payment.blockNumber, payment.currency.ct, payment.currency.id, payment.amount\r\n            )\r\n        ).div(feePartsPer);\r\n\r\n        if (1 > feeAmount)\r\n            feeAmount = 1;\r\n\r\n        return (payment.sender.fees.single.amount == feeAmount);\r\n    }\r\n\r\n    \r\n    function isGenuinePaymentFeeOfNonFungible(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        (address feeCurrencyCt, uint256 feeCurrencyId) = configuration.feeCurrency(\r\n            payment.blockNumber, payment.currency.ct, payment.currency.id\r\n        );\r\n\r\n        return feeCurrencyCt == payment.sender.fees.single.currency.ct\r\n        && feeCurrencyId == payment.sender.fees.single.currency.id;\r\n    }\r\n\r\n    \r\n    function isGenuinePaymentSenderOfFungible(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return (payment.sender.wallet != payment.recipient.wallet)\r\n        && (!signerManager.isSigner(payment.sender.wallet))\r\n        && (payment.sender.balances.current == payment.sender.balances.previous.sub(payment.transfers.single).sub(payment.sender.fees.single.amount));\r\n    }\r\n\r\n    \r\n    function isGenuinePaymentRecipientOfFungible(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (payment.sender.wallet != payment.recipient.wallet)\r\n        && (payment.recipient.balances.current == payment.recipient.balances.previous.add(payment.transfers.single));\r\n    }\r\n\r\n    \r\n    function isGenuinePaymentSenderOfNonFungible(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return (payment.sender.wallet != payment.recipient.wallet)\r\n        && (!signerManager.isSigner(payment.sender.wallet));\r\n    }\r\n\r\n    \r\n    function isGenuinePaymentRecipientOfNonFungible(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (payment.sender.wallet != payment.recipient.wallet);\r\n    }\r\n\r\n    function isSuccessivePaymentsPartyNonces(\r\n        PaymentTypesLib.Payment memory firstPayment,\r\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\r\n        PaymentTypesLib.Payment memory lastPayment,\r\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole\r\n    )\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        uint256 firstNonce = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.nonce : firstPayment.recipient.nonce);\r\n        uint256 lastNonce = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.nonce : lastPayment.recipient.nonce);\r\n        return lastNonce == firstNonce.add(1);\r\n    }\r\n\r\n    function isGenuineSuccessivePaymentsBalances(\r\n        PaymentTypesLib.Payment memory firstPayment,\r\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\r\n        PaymentTypesLib.Payment memory lastPayment,\r\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole,\r\n        int256 delta\r\n    )\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        NahmiiTypesLib.CurrentPreviousInt256 memory firstCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.balances : firstPayment.recipient.balances);\r\n        NahmiiTypesLib.CurrentPreviousInt256 memory lastCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.balances : lastPayment.recipient.balances);\r\n\r\n        return lastCurrentPreviousBalances.previous == firstCurrentPreviousBalances.current.add(delta);\r\n    }\r\n\r\n    function isGenuineSuccessivePaymentsTotalFees(\r\n        PaymentTypesLib.Payment memory firstPayment,\r\n        PaymentTypesLib.Payment memory lastPayment\r\n    )\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        MonetaryTypesLib.Figure memory firstTotalFee = getProtocolFigureByCurrency(firstPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\r\n        MonetaryTypesLib.Figure memory lastTotalFee = getProtocolFigureByCurrency(lastPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\r\n        return lastTotalFee.amount == firstTotalFee.amount.add(lastPayment.sender.fees.single.amount);\r\n    }\r\n\r\n    function isPaymentParty(PaymentTypesLib.Payment memory payment, address wallet)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return wallet == payment.sender.wallet || wallet == payment.recipient.wallet;\r\n    }\r\n\r\n    function isPaymentSender(PaymentTypesLib.Payment memory payment, address wallet)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return wallet == payment.sender.wallet;\r\n    }\r\n\r\n    function isPaymentRecipient(PaymentTypesLib.Payment memory payment, address wallet)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return wallet == payment.recipient.wallet;\r\n    }\r\n\r\n    function isPaymentCurrency(PaymentTypesLib.Payment memory payment, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return currency.ct == payment.currency.ct && currency.id == payment.currency.id;\r\n    }\r\n\r\n    function isPaymentCurrencyNonFungible(PaymentTypesLib.Payment memory payment)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return payment.currency.ct != payment.sender.fees.single.currency.ct\r\n        || payment.currency.id != payment.sender.fees.single.currency.id;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function getProtocolFigureByCurrency(NahmiiTypesLib.OriginFigure[] memory originFigures, MonetaryTypesLib.Currency memory currency)\r\n    private\r\n    pure\r\n    returns (MonetaryTypesLib.Figure memory) {\r\n        for (uint256 i = 0; i < originFigures.length; i++)\r\n            if (originFigures[i].figure.currency.ct == currency.ct && originFigures[i].figure.currency.id == currency.id\r\n            && originFigures[i].originId == 0)\r\n                return originFigures[i].figure;\r\n        return MonetaryTypesLib.Figure(0, currency);\r\n    }\r\n}\r\n\r\nlibrary TradeTypesLib {\r\n    \r\n    \r\n    \r\n    enum CurrencyRole {Intended, Conjugate}\r\n    enum LiquidityRole {Maker, Taker}\r\n    enum Intention {Buy, Sell}\r\n    enum TradePartyRole {Buyer, Seller}\r\n\r\n    \r\n    \r\n    \r\n    struct OrderPlacement {\r\n        Intention intention;\r\n\r\n        int256 amount;\r\n        NahmiiTypesLib.IntendedConjugateCurrency currencies;\r\n        int256 rate;\r\n\r\n        NahmiiTypesLib.CurrentPreviousInt256 residuals;\r\n    }\r\n\r\n    struct Order {\r\n        uint256 nonce;\r\n        address wallet;\r\n\r\n        OrderPlacement placement;\r\n\r\n        NahmiiTypesLib.WalletOperatorSeal seals;\r\n        uint256 blockNumber;\r\n        uint256 operatorId;\r\n    }\r\n\r\n    struct TradeOrder {\r\n        int256 amount;\r\n        NahmiiTypesLib.WalletOperatorHashes hashes;\r\n        NahmiiTypesLib.CurrentPreviousInt256 residuals;\r\n    }\r\n\r\n    struct TradeParty {\r\n        uint256 nonce;\r\n        address wallet;\r\n\r\n        uint256 rollingVolume;\r\n\r\n        LiquidityRole liquidityRole;\r\n\r\n        TradeOrder order;\r\n\r\n        NahmiiTypesLib.IntendedConjugateCurrentPreviousInt256 balances;\r\n\r\n        NahmiiTypesLib.SingleFigureTotalOriginFigures fees;\r\n    }\r\n\r\n    struct Trade {\r\n        uint256 nonce;\r\n\r\n        int256 amount;\r\n        NahmiiTypesLib.IntendedConjugateCurrency currencies;\r\n        int256 rate;\r\n\r\n        TradeParty buyer;\r\n        TradeParty seller;\r\n\r\n        \r\n        \r\n        NahmiiTypesLib.IntendedConjugateSingleTotalInt256 transfers;\r\n\r\n        NahmiiTypesLib.Seal seal;\r\n        uint256 blockNumber;\r\n        uint256 operatorId;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function TRADE_KIND()\r\n    public\r\n    pure\r\n    returns (string memory)\r\n    {\r\n        return \"trade\";\r\n    }\r\n\r\n    function ORDER_KIND()\r\n    public\r\n    pure\r\n    returns (string memory)\r\n    {\r\n        return \"order\";\r\n    }\r\n}\r\n\r\ncontract Validatable is Ownable {\r\n    \r\n    \r\n    \r\n    Validator public validator;\r\n\r\n    \r\n    \r\n    \r\n    event SetValidatorEvent(Validator oldValidator, Validator newValidator);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setValidator(Validator newValidator)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(newValidator))\r\n    notSameAddresses(address(newValidator), address(validator))\r\n    {\r\n        \r\n        Validator oldValidator = validator;\r\n        validator = newValidator;\r\n\r\n        \r\n        emit SetValidatorEvent(oldValidator, newValidator);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier validatorInitialized() {\r\n        require(address(validator) != address(0), \"Validator not initialized [Validatable.sol:55]\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperatorSealedPayment(PaymentTypesLib.Payment memory payment) {\r\n        require(validator.isGenuinePaymentOperatorSeal(payment), \"Payment operator seal not genuine [Validatable.sol:60]\");\r\n        _;\r\n    }\r\n\r\n    modifier onlySealedPayment(PaymentTypesLib.Payment memory payment) {\r\n        require(validator.isGenuinePaymentSeals(payment), \"Payment seals not genuine [Validatable.sol:65]\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPaymentParty(PaymentTypesLib.Payment memory payment, address wallet) {\r\n        require(validator.isPaymentParty(payment, wallet), \"Wallet not payment party [Validatable.sol:70]\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPaymentSender(PaymentTypesLib.Payment memory payment, address wallet) {\r\n        require(validator.isPaymentSender(payment, wallet), \"Wallet not payment sender [Validatable.sol:75]\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Beneficiary {\r\n    \r\n    \r\n    \r\n    function receiveEthersTo(address wallet, string memory balanceType)\r\n    public\r\n    payable;\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function receiveTokensTo(address wallet, string memory balanceType, int256 amount, address currencyCt,\r\n        uint256 currencyId, string memory standard)\r\n    public;\r\n}\r\n\r\ncontract AccrualBeneficiary is Beneficiary {\r\n    \r\n    \r\n    \r\n    event CloseAccrualPeriodEvent();\r\n\r\n    \r\n    \r\n    \r\n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\r\n    public\r\n    {\r\n        emit CloseAccrualPeriodEvent();\r\n    }\r\n}\r\n\r\ncontract TransferController {\r\n    \r\n    \r\n    \r\n    event CurrencyTransferred(address from, address to, uint256 value,\r\n        address currencyCt, uint256 currencyId);\r\n\r\n    \r\n    \r\n    \r\n    function isFungible()\r\n    public\r\n    view\r\n    returns (bool);\r\n\r\n    function standard()\r\n    public\r\n    view\r\n    returns (string memory);\r\n\r\n    \r\n    function receive(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\r\n    public;\r\n\r\n    \r\n    function approve(address to, uint256 value, address currencyCt, uint256 currencyId)\r\n    public;\r\n\r\n    \r\n    function dispatch(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\r\n    public;\r\n\r\n    \r\n\r\n    function getReceiveSignature()\r\n    public\r\n    pure\r\n    returns (bytes4)\r\n    {\r\n        return bytes4(keccak256(\"receive(address,address,uint256,address,uint256)\"));\r\n    }\r\n\r\n    function getApproveSignature()\r\n    public\r\n    pure\r\n    returns (bytes4)\r\n    {\r\n        return bytes4(keccak256(\"approve(address,uint256,address,uint256)\"));\r\n    }\r\n\r\n    function getDispatchSignature()\r\n    public\r\n    pure\r\n    returns (bytes4)\r\n    {\r\n        return bytes4(keccak256(\"dispatch(address,address,uint256,address,uint256)\"));\r\n    }\r\n}\r\n\r\ncontract TransferControllerManager is Ownable {\r\n    \r\n    \r\n    \r\n    struct CurrencyInfo {\r\n        bytes32 standard;\r\n        bool blacklisted;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    mapping(bytes32 => address) public registeredTransferControllers;\r\n    mapping(address => CurrencyInfo) public registeredCurrencies;\r\n\r\n    \r\n    \r\n    \r\n    event RegisterTransferControllerEvent(string standard, address controller);\r\n    event ReassociateTransferControllerEvent(string oldStandard, string newStandard, address controller);\r\n\r\n    event RegisterCurrencyEvent(address currencyCt, string standard);\r\n    event DeregisterCurrencyEvent(address currencyCt);\r\n    event BlacklistCurrencyEvent(address currencyCt);\r\n    event WhitelistCurrencyEvent(address currencyCt);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function registerTransferController(string calldata standard, address controller)\r\n    external\r\n    onlyDeployer\r\n    notNullAddress(controller)\r\n    {\r\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:58]\");\r\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\r\n\r\n        registeredTransferControllers[standardHash] = controller;\r\n\r\n        \r\n        emit RegisterTransferControllerEvent(standard, controller);\r\n    }\r\n\r\n    function reassociateTransferController(string calldata oldStandard, string calldata newStandard, address controller)\r\n    external\r\n    onlyDeployer\r\n    notNullAddress(controller)\r\n    {\r\n        require(bytes(newStandard).length > 0, \"Empty new standard not supported [TransferControllerManager.sol:72]\");\r\n        bytes32 oldStandardHash = keccak256(abi.encodePacked(oldStandard));\r\n        bytes32 newStandardHash = keccak256(abi.encodePacked(newStandard));\r\n\r\n        require(registeredTransferControllers[oldStandardHash] != address(0), \"Old standard not registered [TransferControllerManager.sol:76]\");\r\n        require(registeredTransferControllers[newStandardHash] == address(0), \"New standard previously registered [TransferControllerManager.sol:77]\");\r\n\r\n        registeredTransferControllers[newStandardHash] = registeredTransferControllers[oldStandardHash];\r\n        registeredTransferControllers[oldStandardHash] = address(0);\r\n\r\n        \r\n        emit ReassociateTransferControllerEvent(oldStandard, newStandard, controller);\r\n    }\r\n\r\n    function registerCurrency(address currencyCt, string calldata standard)\r\n    external\r\n    onlyOperator\r\n    notNullAddress(currencyCt)\r\n    {\r\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:91]\");\r\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\r\n\r\n        require(registeredCurrencies[currencyCt].standard == bytes32(0), \"Currency previously registered [TransferControllerManager.sol:94]\");\r\n\r\n        registeredCurrencies[currencyCt].standard = standardHash;\r\n\r\n        \r\n        emit RegisterCurrencyEvent(currencyCt, standard);\r\n    }\r\n\r\n    function deregisterCurrency(address currencyCt)\r\n    external\r\n    onlyOperator\r\n    {\r\n        require(registeredCurrencies[currencyCt].standard != 0, \"Currency not registered [TransferControllerManager.sol:106]\");\r\n\r\n        registeredCurrencies[currencyCt].standard = bytes32(0);\r\n        registeredCurrencies[currencyCt].blacklisted = false;\r\n\r\n        \r\n        emit DeregisterCurrencyEvent(currencyCt);\r\n    }\r\n\r\n    function blacklistCurrency(address currencyCt)\r\n    external\r\n    onlyOperator\r\n    {\r\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:119]\");\r\n\r\n        registeredCurrencies[currencyCt].blacklisted = true;\r\n\r\n        \r\n        emit BlacklistCurrencyEvent(currencyCt);\r\n    }\r\n\r\n    function whitelistCurrency(address currencyCt)\r\n    external\r\n    onlyOperator\r\n    {\r\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:131]\");\r\n\r\n        registeredCurrencies[currencyCt].blacklisted = false;\r\n\r\n        \r\n        emit WhitelistCurrencyEvent(currencyCt);\r\n    }\r\n\r\n    \r\n    function transferController(address currencyCt, string memory standard)\r\n    public\r\n    view\r\n    returns (TransferController)\r\n    {\r\n        if (bytes(standard).length > 0) {\r\n            bytes32 standardHash = keccak256(abi.encodePacked(standard));\r\n\r\n            require(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\r\n            return TransferController(registeredTransferControllers[standardHash]);\r\n        }\r\n\r\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\r\n        require(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\r\n\r\n        address controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\r\n        require(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\r\n\r\n        return TransferController(controllerAddress);\r\n    }\r\n}\r\n\r\ncontract TransferControllerManageable is Ownable {\r\n    \r\n    \r\n    \r\n    TransferControllerManager public transferControllerManager;\r\n\r\n    \r\n    \r\n    \r\n    event SetTransferControllerManagerEvent(TransferControllerManager oldTransferControllerManager,\r\n        TransferControllerManager newTransferControllerManager);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setTransferControllerManager(TransferControllerManager newTransferControllerManager)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(newTransferControllerManager))\r\n    notSameAddresses(address(newTransferControllerManager), address(transferControllerManager))\r\n    {\r\n        \r\n        TransferControllerManager oldTransferControllerManager = transferControllerManager;\r\n        transferControllerManager = newTransferControllerManager;\r\n\r\n        \r\n        emit SetTransferControllerManagerEvent(oldTransferControllerManager, newTransferControllerManager);\r\n    }\r\n\r\n    \r\n    function transferController(address currencyCt, string memory standard)\r\n    internal\r\n    view\r\n    returns (TransferController)\r\n    {\r\n        return transferControllerManager.transferController(currencyCt, standard);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier transferControllerManagerInitialized() {\r\n        require(address(transferControllerManager) != address(0), \"Transfer controller manager not initialized [TransferControllerManageable.sol:63]\");\r\n        _;\r\n    }\r\n}\r\n\r\nlibrary TxHistoryLib {\r\n    \r\n    \r\n    \r\n    struct AssetEntry {\r\n        int256 amount;\r\n        uint256 blockNumber;\r\n        address currencyCt;      \r\n        uint256 currencyId;\r\n    }\r\n\r\n    struct TxHistory {\r\n        AssetEntry[] deposits;\r\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyDeposits;\r\n\r\n        AssetEntry[] withdrawals;\r\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyWithdrawals;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function addDeposit(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        AssetEntry memory deposit = AssetEntry(amount, block.number, currencyCt, currencyId);\r\n        self.deposits.push(deposit);\r\n        self.currencyDeposits[currencyCt][currencyId].push(deposit);\r\n    }\r\n\r\n    function addWithdrawal(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        AssetEntry memory withdrawal = AssetEntry(amount, block.number, currencyCt, currencyId);\r\n        self.withdrawals.push(withdrawal);\r\n        self.currencyWithdrawals[currencyCt][currencyId].push(withdrawal);\r\n    }\r\n\r\n    \r\n\r\n    function deposit(TxHistory storage self, uint index)\r\n    internal\r\n    view\r\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        require(index < self.deposits.length, \"Index ouf of bounds [TxHistoryLib.sol:56]\");\r\n\r\n        amount = self.deposits[index].amount;\r\n        blockNumber = self.deposits[index].blockNumber;\r\n        currencyCt = self.deposits[index].currencyCt;\r\n        currencyId = self.deposits[index].currencyId;\r\n    }\r\n\r\n    function depositsCount(TxHistory storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.deposits.length;\r\n    }\r\n\r\n    function currencyDeposit(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\r\n    internal\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        require(index < self.currencyDeposits[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:77]\");\r\n\r\n        amount = self.currencyDeposits[currencyCt][currencyId][index].amount;\r\n        blockNumber = self.currencyDeposits[currencyCt][currencyId][index].blockNumber;\r\n    }\r\n\r\n    function currencyDepositsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.currencyDeposits[currencyCt][currencyId].length;\r\n    }\r\n\r\n    \r\n\r\n    function withdrawal(TxHistory storage self, uint index)\r\n    internal\r\n    view\r\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        require(index < self.withdrawals.length, \"Index out of bounds [TxHistoryLib.sol:98]\");\r\n\r\n        amount = self.withdrawals[index].amount;\r\n        blockNumber = self.withdrawals[index].blockNumber;\r\n        currencyCt = self.withdrawals[index].currencyCt;\r\n        currencyId = self.withdrawals[index].currencyId;\r\n    }\r\n\r\n    function withdrawalsCount(TxHistory storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.withdrawals.length;\r\n    }\r\n\r\n    function currencyWithdrawal(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\r\n    internal\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        require(index < self.currencyWithdrawals[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:119]\");\r\n\r\n        amount = self.currencyWithdrawals[currencyCt][currencyId][index].amount;\r\n        blockNumber = self.currencyWithdrawals[currencyCt][currencyId][index].blockNumber;\r\n    }\r\n\r\n    function currencyWithdrawalsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.currencyWithdrawals[currencyCt][currencyId].length;\r\n    }\r\n}\r\n\r\ncontract SecurityBond is Ownable, Configurable, AccrualBeneficiary, Servable, TransferControllerManageable {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\r\n    using TxHistoryLib for TxHistoryLib.TxHistory;\r\n    using CurrenciesLib for CurrenciesLib.Currencies;\r\n\r\n    \r\n    \r\n    \r\n    string constant public REWARD_ACTION = \"reward\";\r\n    string constant public DEPRIVE_ACTION = \"deprive\";\r\n\r\n    \r\n    \r\n    \r\n    struct FractionalReward {\r\n        uint256 fraction;\r\n        uint256 nonce;\r\n        uint256 unlockTime;\r\n    }\r\n\r\n    struct AbsoluteReward {\r\n        int256 amount;\r\n        uint256 nonce;\r\n        uint256 unlockTime;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    FungibleBalanceLib.Balance private deposited;\r\n    TxHistoryLib.TxHistory private txHistory;\r\n    CurrenciesLib.Currencies private inUseCurrencies;\r\n\r\n    mapping(address => FractionalReward) public fractionalRewardByWallet;\r\n\r\n    mapping(address => mapping(address => mapping(uint256 => AbsoluteReward))) public absoluteRewardByWallet;\r\n\r\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public claimNonceByWalletCurrency;\r\n\r\n    mapping(address => FungibleBalanceLib.Balance) private stagedByWallet;\r\n\r\n    mapping(address => uint256) public nonceByWallet;\r\n\r\n    \r\n    \r\n    \r\n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\r\n    event RewardFractionalEvent(address wallet, uint256 fraction, uint256 unlockTimeoutInSeconds);\r\n    event RewardAbsoluteEvent(address wallet, int256 amount, address currencyCt, uint256 currencyId,\r\n        uint256 unlockTimeoutInSeconds);\r\n    event DepriveFractionalEvent(address wallet);\r\n    event DepriveAbsoluteEvent(address wallet, address currencyCt, uint256 currencyId);\r\n    event ClaimAndTransferToBeneficiaryEvent(address from, Beneficiary beneficiary, string balanceType, int256 amount,\r\n        address currencyCt, uint256 currencyId, string standard);\r\n    event ClaimAndStageEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\r\n    event WithdrawEvent(address from, int256 amount, address currencyCt, uint256 currencyId, string standard);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) Servable() public {\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function() external payable {\r\n        receiveEthersTo(msg.sender, \"\");\r\n    }\r\n\r\n    \r\n    \r\n    function receiveEthersTo(address wallet, string memory)\r\n    public\r\n    payable\r\n    {\r\n        int256 amount = SafeMathIntLib.toNonZeroInt256(msg.value);\r\n\r\n        \r\n        deposited.add(amount, address(0), 0);\r\n        txHistory.addDeposit(amount, address(0), 0);\r\n\r\n        \r\n        inUseCurrencies.add(address(0), 0);\r\n\r\n        \r\n        emit ReceiveEvent(wallet, amount, address(0), 0);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function receiveTokens(string memory, int256 amount, address currencyCt,\r\n        uint256 currencyId, string memory standard)\r\n    public\r\n    {\r\n        receiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function receiveTokensTo(address wallet, string memory, int256 amount, address currencyCt,\r\n        uint256 currencyId, string memory standard)\r\n    public\r\n    {\r\n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [SecurityBond.sol:145]\");\r\n\r\n        \r\n        TransferController controller = transferController(currencyCt, standard);\r\n        (bool success,) = address(controller).delegatecall(\r\n            abi.encodeWithSelector(\r\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\r\n            )\r\n        );\r\n        require(success, \"Reception by controller failed [SecurityBond.sol:154]\");\r\n\r\n        \r\n        deposited.add(amount, currencyCt, currencyId);\r\n        txHistory.addDeposit(amount, currencyCt, currencyId);\r\n\r\n        \r\n        inUseCurrencies.add(currencyCt, currencyId);\r\n\r\n        \r\n        emit ReceiveEvent(wallet, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    function depositsCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return txHistory.depositsCount();\r\n    }\r\n\r\n    \r\n    \r\n    function deposit(uint index)\r\n    public\r\n    view\r\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    {\r\n        return txHistory.deposit(index);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function depositedBalance(address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return deposited.get(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function depositedFractionalBalance(address currencyCt, uint256 currencyId, uint256 fraction)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return deposited.get(currencyCt, currencyId)\r\n        .mul(SafeMathIntLib.toInt256(fraction))\r\n        .div(ConstantsLib.PARTS_PER());\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function stagedBalance(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return stagedByWallet[wallet].get(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    function inUseCurrenciesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return inUseCurrencies.count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function inUseCurrenciesByIndices(uint256 low, uint256 up)\r\n    public\r\n    view\r\n    returns (MonetaryTypesLib.Currency[] memory)\r\n    {\r\n        return inUseCurrencies.getByIndices(low, up);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function rewardFractional(address wallet, uint256 fraction, uint256 unlockTimeoutInSeconds)\r\n    public\r\n    notNullAddress(wallet)\r\n    onlyEnabledServiceAction(REWARD_ACTION)\r\n    {\r\n        \r\n        fractionalRewardByWallet[wallet].fraction = fraction.clampMax(uint256(ConstantsLib.PARTS_PER()));\r\n        fractionalRewardByWallet[wallet].nonce = ++nonceByWallet[wallet];\r\n        fractionalRewardByWallet[wallet].unlockTime = block.timestamp.add(unlockTimeoutInSeconds);\r\n\r\n        \r\n        emit RewardFractionalEvent(wallet, fraction, unlockTimeoutInSeconds);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function rewardAbsolute(address wallet, int256 amount, address currencyCt, uint256 currencyId,\r\n        uint256 unlockTimeoutInSeconds)\r\n    public\r\n    notNullAddress(wallet)\r\n    onlyEnabledServiceAction(REWARD_ACTION)\r\n    {\r\n        \r\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].amount = amount;\r\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].nonce = ++nonceByWallet[wallet];\r\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].unlockTime = block.timestamp.add(unlockTimeoutInSeconds);\r\n\r\n        \r\n        emit RewardAbsoluteEvent(wallet, amount, currencyCt, currencyId, unlockTimeoutInSeconds);\r\n    }\r\n\r\n    \r\n    \r\n    function depriveFractional(address wallet)\r\n    public\r\n    onlyEnabledServiceAction(DEPRIVE_ACTION)\r\n    {\r\n        \r\n        fractionalRewardByWallet[wallet].fraction = 0;\r\n        fractionalRewardByWallet[wallet].nonce = ++nonceByWallet[wallet];\r\n        fractionalRewardByWallet[wallet].unlockTime = 0;\r\n\r\n        \r\n        emit DepriveFractionalEvent(wallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function depriveAbsolute(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    onlyEnabledServiceAction(DEPRIVE_ACTION)\r\n    {\r\n        \r\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].amount = 0;\r\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].nonce = ++nonceByWallet[wallet];\r\n        absoluteRewardByWallet[wallet][currencyCt][currencyId].unlockTime = 0;\r\n\r\n        \r\n        emit DepriveAbsoluteEvent(wallet, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function claimAndTransferToBeneficiary(Beneficiary beneficiary, string memory balanceType, address currencyCt,\r\n        uint256 currencyId, string memory standard)\r\n    public\r\n    {\r\n        \r\n        int256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\r\n\r\n        \r\n        deposited.sub(claimedAmount, currencyCt, currencyId);\r\n\r\n        \r\n        if (address(0) == currencyCt && 0 == currencyId)\r\n            beneficiary.receiveEthersTo.value(uint256(claimedAmount))(msg.sender, balanceType);\r\n\r\n        else {\r\n            TransferController controller = transferController(currencyCt, standard);\r\n            (bool success,) = address(controller).delegatecall(\r\n                abi.encodeWithSelector(\r\n                    controller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\r\n                )\r\n            );\r\n            require(success, \"Approval by controller failed [SecurityBond.sol:350]\");\r\n            beneficiary.receiveTokensTo(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\r\n        }\r\n\r\n        \r\n        emit ClaimAndTransferToBeneficiaryEvent(msg.sender, beneficiary, balanceType, claimedAmount, currencyCt, currencyId, standard);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function claimAndStage(address currencyCt, uint256 currencyId)\r\n    public\r\n    {\r\n        \r\n        int256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\r\n\r\n        \r\n        deposited.sub(claimedAmount, currencyCt, currencyId);\r\n\r\n        \r\n        stagedByWallet[msg.sender].add(claimedAmount, currencyCt, currencyId);\r\n\r\n        \r\n        emit ClaimAndStageEvent(msg.sender, claimedAmount, currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\r\n    public\r\n    {\r\n        \r\n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [SecurityBond.sol:386]\");\r\n\r\n        \r\n        amount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\r\n\r\n        \r\n        stagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\r\n\r\n        \r\n        if (address(0) == currencyCt && 0 == currencyId)\r\n            msg.sender.transfer(uint256(amount));\r\n\r\n        else {\r\n            TransferController controller = transferController(currencyCt, standard);\r\n            (bool success,) = address(controller).delegatecall(\r\n                abi.encodeWithSelector(\r\n                    controller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\r\n                )\r\n            );\r\n            require(success, \"Dispatch by controller failed [SecurityBond.sol:405]\");\r\n        }\r\n\r\n        \r\n        emit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function _claim(address wallet, address currencyCt, uint256 currencyId)\r\n    private\r\n    returns (int256)\r\n    {\r\n        \r\n        uint256 claimNonce = fractionalRewardByWallet[wallet].nonce.clampMin(\r\n            absoluteRewardByWallet[wallet][currencyCt][currencyId].nonce\r\n        );\r\n\r\n        \r\n        require(\r\n            claimNonce > claimNonceByWalletCurrency[wallet][currencyCt][currencyId],\r\n            \"Claim nonce not strictly greater than previously claimed nonce [SecurityBond.sol:425]\"\r\n        );\r\n\r\n        \r\n        int256 claimAmount = _fractionalRewardAmountByWalletCurrency(wallet, currencyCt, currencyId).add(\r\n            _absoluteRewardAmountByWalletCurrency(wallet, currencyCt, currencyId)\r\n        ).clampMax(\r\n            deposited.get(currencyCt, currencyId)\r\n        );\r\n\r\n        \r\n        require(claimAmount.isNonZeroPositiveInt256(), \"Claim amount not strictly positive [SecurityBond.sol:438]\");\r\n\r\n        \r\n        claimNonceByWalletCurrency[wallet][currencyCt][currencyId] = claimNonce;\r\n\r\n        return claimAmount;\r\n    }\r\n\r\n    function _fractionalRewardAmountByWalletCurrency(address wallet, address currencyCt, uint256 currencyId)\r\n    private\r\n    view\r\n    returns (int256)\r\n    {\r\n        if (\r\n            claimNonceByWalletCurrency[wallet][currencyCt][currencyId] < fractionalRewardByWallet[wallet].nonce &&\r\n            block.timestamp >= fractionalRewardByWallet[wallet].unlockTime\r\n        )\r\n            return deposited.get(currencyCt, currencyId)\r\n            .mul(SafeMathIntLib.toInt256(fractionalRewardByWallet[wallet].fraction))\r\n            .div(ConstantsLib.PARTS_PER());\r\n\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    function _absoluteRewardAmountByWalletCurrency(address wallet, address currencyCt, uint256 currencyId)\r\n    private\r\n    view\r\n    returns (int256)\r\n    {\r\n        if (\r\n            claimNonceByWalletCurrency[wallet][currencyCt][currencyId] < absoluteRewardByWallet[wallet][currencyCt][currencyId].nonce &&\r\n            block.timestamp >= absoluteRewardByWallet[wallet][currencyCt][currencyId].unlockTime\r\n        )\r\n            return absoluteRewardByWallet[wallet][currencyCt][currencyId].amount.clampMax(\r\n                deposited.get(currencyCt, currencyId)\r\n            );\r\n\r\n        else\r\n            return 0;\r\n    }\r\n}\r\n\r\ncontract SecurityBondable is Ownable {\r\n    \r\n    \r\n    \r\n    SecurityBond public securityBond;\r\n\r\n    \r\n    \r\n    \r\n    event SetSecurityBondEvent(SecurityBond oldSecurityBond, SecurityBond newSecurityBond);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setSecurityBond(SecurityBond newSecurityBond)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(newSecurityBond))\r\n    notSameAddresses(address(newSecurityBond), address(securityBond))\r\n    {\r\n        \r\n        SecurityBond oldSecurityBond = securityBond;\r\n        securityBond = newSecurityBond;\r\n\r\n        \r\n        emit SetSecurityBondEvent(oldSecurityBond, newSecurityBond);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier securityBondInitialized() {\r\n        require(address(securityBond) != address(0), \"Security bond not initialized [SecurityBondable.sol:52]\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract FraudChallenge is Ownable, Servable {\r\n    \r\n    \r\n    \r\n    string constant public ADD_SEIZED_WALLET_ACTION = \"add_seized_wallet\";\r\n    string constant public ADD_DOUBLE_SPENDER_WALLET_ACTION = \"add_double_spender_wallet\";\r\n    string constant public ADD_FRAUDULENT_ORDER_ACTION = \"add_fraudulent_order\";\r\n    string constant public ADD_FRAUDULENT_TRADE_ACTION = \"add_fraudulent_trade\";\r\n    string constant public ADD_FRAUDULENT_PAYMENT_ACTION = \"add_fraudulent_payment\";\r\n\r\n    \r\n    \r\n    \r\n    address[] public doubleSpenderWallets;\r\n    mapping(address => bool) public doubleSpenderByWallet;\r\n\r\n    bytes32[] public fraudulentOrderHashes;\r\n    mapping(bytes32 => bool) public fraudulentByOrderHash;\r\n\r\n    bytes32[] public fraudulentTradeHashes;\r\n    mapping(bytes32 => bool) public fraudulentByTradeHash;\r\n\r\n    bytes32[] public fraudulentPaymentHashes;\r\n    mapping(bytes32 => bool) public fraudulentByPaymentHash;\r\n\r\n    \r\n    \r\n    \r\n    event AddDoubleSpenderWalletEvent(address wallet);\r\n    event AddFraudulentOrderHashEvent(bytes32 hash);\r\n    event AddFraudulentTradeHashEvent(bytes32 hash);\r\n    event AddFraudulentPaymentHashEvent(bytes32 hash);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function isDoubleSpenderWallet(address wallet)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return doubleSpenderByWallet[wallet];\r\n    }\r\n\r\n    \r\n    \r\n    function doubleSpenderWalletsCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return doubleSpenderWallets.length;\r\n    }\r\n\r\n    \r\n    \r\n    function addDoubleSpenderWallet(address wallet)\r\n    public\r\n    onlyEnabledServiceAction(ADD_DOUBLE_SPENDER_WALLET_ACTION) {\r\n        if (!doubleSpenderByWallet[wallet]) {\r\n            doubleSpenderWallets.push(wallet);\r\n            doubleSpenderByWallet[wallet] = true;\r\n            emit AddDoubleSpenderWalletEvent(wallet);\r\n        }\r\n    }\r\n\r\n    \r\n    function fraudulentOrderHashesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return fraudulentOrderHashes.length;\r\n    }\r\n\r\n    \r\n    \r\n    function isFraudulentOrderHash(bytes32 hash)\r\n    public\r\n    view returns (bool) {\r\n        return fraudulentByOrderHash[hash];\r\n    }\r\n\r\n    \r\n    function addFraudulentOrderHash(bytes32 hash)\r\n    public\r\n    onlyEnabledServiceAction(ADD_FRAUDULENT_ORDER_ACTION)\r\n    {\r\n        if (!fraudulentByOrderHash[hash]) {\r\n            fraudulentByOrderHash[hash] = true;\r\n            fraudulentOrderHashes.push(hash);\r\n            emit AddFraudulentOrderHashEvent(hash);\r\n        }\r\n    }\r\n\r\n    \r\n    function fraudulentTradeHashesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return fraudulentTradeHashes.length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isFraudulentTradeHash(bytes32 hash)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return fraudulentByTradeHash[hash];\r\n    }\r\n\r\n    \r\n    function addFraudulentTradeHash(bytes32 hash)\r\n    public\r\n    onlyEnabledServiceAction(ADD_FRAUDULENT_TRADE_ACTION)\r\n    {\r\n        if (!fraudulentByTradeHash[hash]) {\r\n            fraudulentByTradeHash[hash] = true;\r\n            fraudulentTradeHashes.push(hash);\r\n            emit AddFraudulentTradeHashEvent(hash);\r\n        }\r\n    }\r\n\r\n    \r\n    function fraudulentPaymentHashesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return fraudulentPaymentHashes.length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isFraudulentPaymentHash(bytes32 hash)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return fraudulentByPaymentHash[hash];\r\n    }\r\n\r\n    \r\n    function addFraudulentPaymentHash(bytes32 hash)\r\n    public\r\n    onlyEnabledServiceAction(ADD_FRAUDULENT_PAYMENT_ACTION)\r\n    {\r\n        if (!fraudulentByPaymentHash[hash]) {\r\n            fraudulentByPaymentHash[hash] = true;\r\n            fraudulentPaymentHashes.push(hash);\r\n            emit AddFraudulentPaymentHashEvent(hash);\r\n        }\r\n    }\r\n}\r\n\r\ncontract FraudChallengable is Ownable {\r\n    \r\n    \r\n    \r\n    FraudChallenge public fraudChallenge;\r\n\r\n    \r\n    \r\n    \r\n    event SetFraudChallengeEvent(FraudChallenge oldFraudChallenge, FraudChallenge newFraudChallenge);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setFraudChallenge(FraudChallenge newFraudChallenge)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(newFraudChallenge))\r\n    notSameAddresses(address(newFraudChallenge), address(fraudChallenge))\r\n    {\r\n        \r\n        FraudChallenge oldFraudChallenge = fraudChallenge;\r\n        fraudChallenge = newFraudChallenge;\r\n\r\n        \r\n        emit SetFraudChallengeEvent(oldFraudChallenge, newFraudChallenge);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier fraudChallengeInitialized() {\r\n        require(address(fraudChallenge) != address(0), \"Fraud challenge not initialized [FraudChallengable.sol:52]\");\r\n        _;\r\n    }\r\n}\r\n\r\nlibrary SettlementChallengeTypesLib {\r\n    \r\n    \r\n    \r\n    enum Status {Qualified, Disqualified}\r\n\r\n    struct Proposal {\r\n        address wallet;\r\n        uint256 nonce;\r\n        uint256 referenceBlockNumber;\r\n        uint256 definitionBlockNumber;\r\n\r\n        uint256 expirationTime;\r\n\r\n        \r\n        Status status;\r\n\r\n        \r\n        Amounts amounts;\r\n\r\n        \r\n        MonetaryTypesLib.Currency currency;\r\n\r\n        \r\n        Driip challenged;\r\n\r\n        \r\n        bool walletInitiated;\r\n\r\n        \r\n        bool terminated;\r\n\r\n        \r\n        Disqualification disqualification;\r\n    }\r\n\r\n    struct Amounts {\r\n        \r\n        int256 cumulativeTransfer;\r\n\r\n        \r\n        int256 stage;\r\n\r\n        \r\n        int256 targetBalance;\r\n    }\r\n\r\n    struct Driip {\r\n        \r\n        string kind;\r\n\r\n        \r\n        bytes32 hash;\r\n    }\r\n\r\n    struct Disqualification {\r\n        \r\n        address challenger;\r\n        uint256 nonce;\r\n        uint256 blockNumber;\r\n\r\n        \r\n        Driip candidate;\r\n    }\r\n}\r\n\r\ncontract Upgradable {\r\n    \r\n    \r\n    \r\n    address public upgradeAgent;\r\n    bool public upgradesFrozen;\r\n\r\n    \r\n    \r\n    \r\n    event SetUpgradeAgentEvent(address upgradeAgent);\r\n    event FreezeUpgradesEvent();\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setUpgradeAgent(address _upgradeAgent)\r\n    public\r\n    onlyWhenUpgradable\r\n    {\r\n        require(address(0) == upgradeAgent, \"Upgrade agent has already been set [Upgradable.sol:37]\");\r\n\r\n        \r\n        upgradeAgent = _upgradeAgent;\r\n\r\n        \r\n        emit SetUpgradeAgentEvent(upgradeAgent);\r\n    }\r\n\r\n    \r\n    \r\n    function freezeUpgrades()\r\n    public\r\n    onlyWhenUpgrading\r\n    {\r\n        \r\n        upgradesFrozen = true;\r\n\r\n        \r\n        emit FreezeUpgradesEvent();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier onlyWhenUpgrading() {\r\n        require(msg.sender == upgradeAgent, \"Caller is not upgrade agent [Upgradable.sol:63]\");\r\n        require(!upgradesFrozen, \"Upgrades have been frozen [Upgradable.sol:64]\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenUpgradable() {\r\n        require(!upgradesFrozen, \"Upgrades have been frozen [Upgradable.sol:69]\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract NullSettlementChallengeState is Ownable, Servable, Configurable, BalanceTrackable, Upgradable {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n\r\n    \r\n    \r\n    \r\n    string constant public INITIATE_PROPOSAL_ACTION = \"initiate_proposal\";\r\n    string constant public TERMINATE_PROPOSAL_ACTION = \"terminate_proposal\";\r\n    string constant public REMOVE_PROPOSAL_ACTION = \"remove_proposal\";\r\n    string constant public DISQUALIFY_PROPOSAL_ACTION = \"disqualify_proposal\";\r\n\r\n    \r\n    \r\n    \r\n    SettlementChallengeTypesLib.Proposal[] public proposals;\r\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public proposalIndexByWalletCurrency;\r\n\r\n    \r\n    \r\n    \r\n    event InitiateProposalEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated);\r\n    event TerminateProposalEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated);\r\n    event RemoveProposalEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated);\r\n    event DisqualifyProposalEvent(address challengedWallet, uint256 challangedNonce, int256 stageAmount,\r\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\r\n        address challengerWallet, uint256 candidateNonce, bytes32 candidateHash, string candidateKind);\r\n    event UpgradeProposalEvent(SettlementChallengeTypesLib.Proposal proposal);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function proposalsCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return proposals.length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function initiateProposal(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        MonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated)\r\n    public\r\n    onlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        _initiateProposal(\r\n            wallet, nonce, stageAmount, targetBalanceAmount,\r\n            currency, blockNumber, walletInitiated\r\n        );\r\n\r\n        \r\n        emit InitiateProposalEvent(\r\n            wallet, nonce, stageAmount, targetBalanceAmount, currency,\r\n            blockNumber, walletInitiated\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index)\r\n            return;\r\n\r\n        \r\n        proposals[index - 1].terminated = true;\r\n\r\n        \r\n        emit TerminateProposalEvent(\r\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\r\n            proposals[index - 1].amounts.targetBalance, currency,\r\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\r\n    public\r\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index)\r\n            return;\r\n\r\n        \r\n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:145]\");\r\n\r\n        \r\n        proposals[index - 1].terminated = true;\r\n\r\n        \r\n        emit TerminateProposalEvent(\r\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\r\n            proposals[index - 1].amounts.targetBalance, currency,\r\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index)\r\n            return;\r\n\r\n        \r\n        emit RemoveProposalEvent(\r\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\r\n            proposals[index - 1].amounts.targetBalance, currency,\r\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\r\n        );\r\n\r\n        \r\n        _removeProposal(index);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\r\n    public\r\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index)\r\n            return;\r\n\r\n        \r\n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:199]\");\r\n\r\n        \r\n        emit RemoveProposalEvent(\r\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\r\n            proposals[index - 1].amounts.targetBalance, currency,\r\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\r\n        );\r\n\r\n        \r\n        _removeProposal(index);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\r\n        uint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\r\n    public\r\n    onlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\r\n        require(0 != index, \"No settlement found for wallet and currency [NullSettlementChallengeState.sol:228]\");\r\n\r\n        \r\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\r\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\r\n        proposals[index - 1].disqualification.challenger = challengerWallet;\r\n        proposals[index - 1].disqualification.nonce = candidateNonce;\r\n        proposals[index - 1].disqualification.blockNumber = blockNumber;\r\n        proposals[index - 1].disqualification.candidate.hash = candidateHash;\r\n        proposals[index - 1].disqualification.candidate.kind = candidateKind;\r\n\r\n        \r\n        emit DisqualifyProposalEvent(\r\n            challengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\r\n            proposals[index - 1].amounts.targetBalance, currency, proposals[index - 1].referenceBlockNumber,\r\n            proposals[index - 1].walletInitiated, challengerWallet, candidateNonce, candidateHash, candidateKind\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        \r\n        return 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:271]\");\r\n        return proposals[index - 1].terminated;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:286]\");\r\n        return block.timestamp >= proposals[index - 1].expirationTime;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:300]\");\r\n        return proposals[index - 1].nonce;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:314]\");\r\n        return proposals[index - 1].referenceBlockNumber;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:328]\");\r\n        return proposals[index - 1].definitionBlockNumber;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:342]\");\r\n        return proposals[index - 1].expirationTime;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (SettlementChallengeTypesLib.Status)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:356]\");\r\n        return proposals[index - 1].status;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:370]\");\r\n        return proposals[index - 1].amounts.stage;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:384]\");\r\n        return proposals[index - 1].amounts.targetBalance;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:398]\");\r\n        return proposals[index - 1].walletInitiated;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:412]\");\r\n        return proposals[index - 1].disqualification.challenger;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:426]\");\r\n        return proposals[index - 1].disqualification.blockNumber;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:440]\");\r\n        return proposals[index - 1].disqualification.nonce;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bytes32)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:454]\");\r\n        return proposals[index - 1].disqualification.candidate.hash;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (string memory)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:468]\");\r\n        return proposals[index - 1].disqualification.candidate.kind;\r\n    }\r\n\r\n    \r\n    \r\n    function upgradeProposal(SettlementChallengeTypesLib.Proposal memory proposal)\r\n    public\r\n    onlyWhenUpgrading\r\n    {\r\n        \r\n        require(\r\n            0 == proposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id],\r\n            \"Proposal exists for wallet and currency [NullSettlementChallengeState.sol:479]\"\r\n        );\r\n\r\n        \r\n        proposals.push(proposal);\r\n\r\n        \r\n        uint256 index = proposals.length;\r\n\r\n        \r\n        proposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id] = index;\r\n\r\n        \r\n        emit UpgradeProposalEvent(proposal);\r\n    }\r\n\r\n\r\n    \r\n    \r\n    \r\n    function _initiateProposal(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        MonetaryTypesLib.Currency memory currency, uint256 referenceBlockNumber, bool walletInitiated)\r\n    private\r\n    {\r\n        \r\n        require(stageAmount.isPositiveInt256(), \"Stage amount not positive [NullSettlementChallengeState.sol:506]\");\r\n        require(targetBalanceAmount.isPositiveInt256(), \"Target balance amount not positive [NullSettlementChallengeState.sol:507]\");\r\n\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index) {\r\n            index = ++(proposals.length);\r\n            proposalIndexByWalletCurrency[wallet][currency.ct][currency.id] = index;\r\n        }\r\n\r\n        \r\n        proposals[index - 1].wallet = wallet;\r\n        proposals[index - 1].nonce = nonce;\r\n        proposals[index - 1].referenceBlockNumber = referenceBlockNumber;\r\n        proposals[index - 1].definitionBlockNumber = block.number;\r\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\r\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\r\n        proposals[index - 1].currency = currency;\r\n        proposals[index - 1].amounts.stage = stageAmount;\r\n        proposals[index - 1].amounts.targetBalance = targetBalanceAmount;\r\n        proposals[index - 1].walletInitiated = walletInitiated;\r\n        proposals[index - 1].terminated = false;\r\n    }\r\n\r\n    function _removeProposal(uint256 index)\r\n    private\r\n    returns (bool)\r\n    {\r\n        \r\n        proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = 0;\r\n        if (index < proposals.length) {\r\n            proposals[index - 1] = proposals[proposals.length - 1];\r\n            proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = index;\r\n        }\r\n        proposals.length--;\r\n    }\r\n\r\n    function _activeBalanceLogEntry(address wallet, address currencyCt, uint256 currencyId)\r\n    private\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        \r\n        (int256 depositedAmount, uint256 depositedBlockNumber) = balanceTracker.lastFungibleRecord(\r\n            wallet, balanceTracker.depositedBalanceType(), currencyCt, currencyId\r\n        );\r\n        (int256 settledAmount, uint256 settledBlockNumber) = balanceTracker.lastFungibleRecord(\r\n            wallet, balanceTracker.settledBalanceType(), currencyCt, currencyId\r\n        );\r\n\r\n        \r\n        amount = depositedAmount.add(settledAmount);\r\n\r\n        \r\n        blockNumber = depositedBlockNumber > settledBlockNumber ? depositedBlockNumber : settledBlockNumber;\r\n    }\r\n}\r\n\r\nlibrary BalanceTrackerLib {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n\r\n    function fungibleActiveRecordByBlockNumber(BalanceTracker self, address wallet,\r\n        MonetaryTypesLib.Currency memory currency, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        \r\n        (int256 depositedAmount, uint256 depositedBlockNumber) = self.fungibleRecordByBlockNumber(\r\n            wallet, self.depositedBalanceType(), currency.ct, currency.id, _blockNumber\r\n        );\r\n        (int256 settledAmount, uint256 settledBlockNumber) = self.fungibleRecordByBlockNumber(\r\n            wallet, self.settledBalanceType(), currency.ct, currency.id, _blockNumber\r\n        );\r\n\r\n        \r\n        amount = depositedAmount.add(settledAmount);\r\n        blockNumber = depositedBlockNumber.clampMin(settledBlockNumber);\r\n    }\r\n\r\n    function fungibleActiveBalanceAmountByBlockNumber(BalanceTracker self, address wallet,\r\n        MonetaryTypesLib.Currency memory currency, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        (int256 amount,) = fungibleActiveRecordByBlockNumber(self, wallet, currency, blockNumber);\r\n        return amount;\r\n    }\r\n\r\n    function fungibleActiveDeltaBalanceAmountByBlockNumbers(BalanceTracker self, address wallet,\r\n        MonetaryTypesLib.Currency memory currency, uint256 fromBlockNumber, uint256 toBlockNumber)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return fungibleActiveBalanceAmountByBlockNumber(self, wallet, currency, toBlockNumber) -\r\n        fungibleActiveBalanceAmountByBlockNumber(self, wallet, currency, fromBlockNumber);\r\n    }\r\n\r\n    function fungibleActiveRecord(BalanceTracker self, address wallet,\r\n        MonetaryTypesLib.Currency memory currency)\r\n    internal\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        \r\n        (int256 depositedAmount, uint256 depositedBlockNumber) = self.lastFungibleRecord(\r\n            wallet, self.depositedBalanceType(), currency.ct, currency.id\r\n        );\r\n        (int256 settledAmount, uint256 settledBlockNumber) = self.lastFungibleRecord(\r\n            wallet, self.settledBalanceType(), currency.ct, currency.id\r\n        );\r\n\r\n        \r\n        amount = depositedAmount.add(settledAmount);\r\n        blockNumber = depositedBlockNumber.clampMin(settledBlockNumber);\r\n    }\r\n\r\n    function fungibleActiveBalanceAmount(BalanceTracker self, address wallet, MonetaryTypesLib.Currency memory currency)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return self.get(wallet, self.depositedBalanceType(), currency.ct, currency.id).add(\r\n            self.get(wallet, self.settledBalanceType(), currency.ct, currency.id)\r\n        );\r\n    }\r\n}\r\n\r\ncontract NullSettlementDisputeByPayment is Ownable, Configurable, Validatable, SecurityBondable, WalletLockable,\r\nBalanceTrackable, FraudChallengable, Servable {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n    using BalanceTrackerLib for BalanceTracker;\r\n\r\n    \r\n    \r\n    \r\n    string constant public CHALLENGE_BY_PAYMENT_ACTION = \"challenge_by_payment\";\r\n\r\n    \r\n    \r\n    \r\n    NullSettlementChallengeState public nullSettlementChallengeState;\r\n\r\n    \r\n    \r\n    \r\n    event SetNullSettlementChallengeStateEvent(NullSettlementChallengeState oldNullSettlementChallengeState,\r\n        NullSettlementChallengeState newNullSettlementChallengeState);\r\n    event ChallengeByPaymentEvent(address wallet, uint256 nonce, PaymentTypesLib.Payment payment,\r\n        address challenger);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    \r\n    \r\n    function setNullSettlementChallengeState(NullSettlementChallengeState newNullSettlementChallengeState) public\r\n    onlyDeployer\r\n    notNullAddress(address(newNullSettlementChallengeState))\r\n    {\r\n        NullSettlementChallengeState oldNullSettlementChallengeState = nullSettlementChallengeState;\r\n        nullSettlementChallengeState = newNullSettlementChallengeState;\r\n        emit SetNullSettlementChallengeStateEvent(oldNullSettlementChallengeState, nullSettlementChallengeState);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function challengeByPayment(address wallet, PaymentTypesLib.Payment memory payment, address challenger)\r\n    public\r\n    onlyEnabledServiceAction(CHALLENGE_BY_PAYMENT_ACTION)\r\n    onlySealedPayment(payment)\r\n    onlyPaymentSender(payment, wallet)\r\n    {\r\n        \r\n        require(!fraudChallenge.isFraudulentPaymentHash(payment.seals.operator.hash), \"Payment deemed fraudulent [NullSettlementDisputeByPayment.sol:86]\");\r\n\r\n        \r\n        require(nullSettlementChallengeState.hasProposal(wallet, payment.currency), \"No proposal found [NullSettlementDisputeByPayment.sol:89]\");\r\n\r\n        \r\n        require(!nullSettlementChallengeState.hasProposalExpired(wallet, payment.currency), \"Proposal found expired [NullSettlementDisputeByPayment.sol:92]\");\r\n\r\n        \r\n        \r\n        require(payment.sender.nonce > nullSettlementChallengeState.proposalNonce(\r\n            wallet, payment.currency\r\n        ), \"Payment nonce not strictly greater than proposal nonce [NullSettlementDisputeByPayment.sol:96]\");\r\n        require(payment.sender.nonce > nullSettlementChallengeState.proposalDisqualificationNonce(\r\n            wallet, payment.currency\r\n        ), \"Payment nonce not strictly greater than proposal disqualification nonce [NullSettlementDisputeByPayment.sol:99]\");\r\n\r\n        \r\n        require(_overrun(wallet, payment), \"No overrun found [NullSettlementDisputeByPayment.sol:104]\");\r\n\r\n        \r\n        _settleRewards(wallet, payment.sender.balances.current, payment.currency, challenger);\r\n\r\n        \r\n        nullSettlementChallengeState.disqualifyProposal(\r\n            wallet, payment.currency, challenger, payment.blockNumber,\r\n            payment.sender.nonce, payment.seals.operator.hash, PaymentTypesLib.PAYMENT_KIND()\r\n        );\r\n\r\n        \r\n        emit ChallengeByPaymentEvent(\r\n            wallet, nullSettlementChallengeState.proposalNonce(wallet, payment.currency), payment, challenger\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function _overrun(address wallet, PaymentTypesLib.Payment memory payment)\r\n    private\r\n    view\r\n    returns (bool)\r\n    {\r\n        \r\n        int targetBalanceAmount = nullSettlementChallengeState.proposalTargetBalanceAmount(\r\n            wallet, payment.currency\r\n        );\r\n\r\n        \r\n        int256 deltaBalanceSinceStart = balanceTracker.fungibleActiveBalanceAmount(\r\n            wallet, payment.currency\r\n        ).sub(\r\n            balanceTracker.fungibleActiveBalanceAmountByBlockNumber(\r\n                wallet, payment.currency,\r\n                nullSettlementChallengeState.proposalReferenceBlockNumber(wallet, payment.currency)\r\n            )\r\n        );\r\n\r\n        \r\n        int256 cumulativeTransfer = balanceTracker.fungibleActiveBalanceAmountByBlockNumber(\r\n            wallet, payment.currency, payment.blockNumber\r\n        ).sub(payment.sender.balances.current);\r\n\r\n        return targetBalanceAmount.add(deltaBalanceSinceStart) < cumulativeTransfer;\r\n    }\r\n\r\n    \r\n    function _settleRewards(address wallet, int256 walletAmount, MonetaryTypesLib.Currency memory currency,\r\n        address challenger)\r\n    private\r\n    {\r\n        if (nullSettlementChallengeState.proposalWalletInitiated(wallet, currency))\r\n            _settleBalanceReward(wallet, walletAmount, currency, challenger);\r\n\r\n        else\r\n            _settleSecurityBondReward(wallet, walletAmount, currency, challenger);\r\n    }\r\n\r\n    function _settleBalanceReward(address wallet, int256 walletAmount, MonetaryTypesLib.Currency memory currency,\r\n        address challenger)\r\n    private\r\n    {\r\n        \r\n        if (SettlementChallengeTypesLib.Status.Disqualified == nullSettlementChallengeState.proposalStatus(\r\n            wallet, currency\r\n        ))\r\n            walletLocker.unlockFungibleByProxy(\r\n                wallet,\r\n                nullSettlementChallengeState.proposalDisqualificationChallenger(\r\n                    wallet, currency\r\n                ),\r\n                currency.ct, currency.id\r\n            );\r\n\r\n        \r\n        walletLocker.lockFungibleByProxy(\r\n            wallet, challenger, walletAmount, currency.ct, currency.id, configuration.settlementChallengeTimeout()\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function _settleSecurityBondReward(address wallet, int256 walletAmount, MonetaryTypesLib.Currency memory currency,\r\n        address challenger)\r\n    private\r\n    {\r\n        \r\n        if (SettlementChallengeTypesLib.Status.Disqualified == nullSettlementChallengeState.proposalStatus(\r\n            wallet, currency\r\n        ))\r\n            securityBond.depriveAbsolute(\r\n                nullSettlementChallengeState.proposalDisqualificationChallenger(\r\n                    wallet, currency\r\n                ),\r\n                currency.ct, currency.id\r\n            );\r\n\r\n        \r\n        MonetaryTypesLib.Figure memory flatReward = _flatReward();\r\n        securityBond.rewardAbsolute(\r\n            challenger, flatReward.amount, flatReward.currency.ct, flatReward.currency.id, 0\r\n        );\r\n\r\n        \r\n        int256 progressiveRewardAmount = walletAmount.clampMax(\r\n            securityBond.depositedFractionalBalance(\r\n                currency.ct, currency.id, configuration.operatorSettlementStakeFraction()\r\n            )\r\n        );\r\n        securityBond.rewardAbsolute(\r\n            challenger, progressiveRewardAmount, currency.ct, currency.id, 0\r\n        );\r\n    }\r\n\r\n    function _flatReward()\r\n    private\r\n    view\r\n    returns (MonetaryTypesLib.Figure memory)\r\n    {\r\n        (int256 amount, address currencyCt, uint256 currencyId) = configuration.operatorSettlementStake();\r\n        return MonetaryTypesLib.Figure(amount, MonetaryTypesLib.Currency(currencyCt, currencyId));\r\n    }\r\n}\r\n\r\ncontract DriipSettlementChallengeState is Ownable, Servable, Configurable, Upgradable {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n\r\n    \r\n    \r\n    \r\n    string constant public INITIATE_PROPOSAL_ACTION = \"initiate_proposal\";\r\n    string constant public TERMINATE_PROPOSAL_ACTION = \"terminate_proposal\";\r\n    string constant public REMOVE_PROPOSAL_ACTION = \"remove_proposal\";\r\n    string constant public DISQUALIFY_PROPOSAL_ACTION = \"disqualify_proposal\";\r\n    string constant public QUALIFY_PROPOSAL_ACTION = \"qualify_proposal\";\r\n\r\n    \r\n    \r\n    \r\n    SettlementChallengeTypesLib.Proposal[] public proposals;\r\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public proposalIndexByWalletCurrency;\r\n    mapping(address => mapping(uint256 => mapping(address => mapping(uint256 => uint256)))) public proposalIndexByWalletNonceCurrency;\r\n\r\n    \r\n    \r\n    \r\n    event InitiateProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\r\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\r\n        bytes32 challengedHash, string challengedKind);\r\n    event TerminateProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\r\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\r\n        bytes32 challengedHash, string challengedKind);\r\n    event RemoveProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\r\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\r\n        bytes32 challengedHash, string challengedKind);\r\n    event DisqualifyProposalEvent(address challengedWallet, uint256 challengedNonce, int256 cumulativeTransferAmount,\r\n        int256 stageAmount, int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber,\r\n        bool walletInitiated, address challengerWallet, uint256 candidateNonce, bytes32 candidateHash,\r\n        string candidateKind);\r\n    event QualifyProposalEvent(address challengedWallet, uint256 challengedNonce, int256 cumulativeTransferAmount,\r\n        int256 stageAmount, int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber,\r\n        bool walletInitiated, address challengerWallet, uint256 candidateNonce, bytes32 candidateHash,\r\n        string candidateKind);\r\n    event UpgradeProposalEvent(SettlementChallengeTypesLib.Proposal proposal);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function proposalsCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return proposals.length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\r\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated,\r\n        bytes32 challengedHash, string memory challengedKind)\r\n    public\r\n    onlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        _initiateProposal(\r\n            wallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\r\n            currency, blockNumber, walletInitiated, challengedHash, challengedKind\r\n        );\r\n\r\n        \r\n        emit InitiateProposalEvent(\r\n            wallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\r\n            blockNumber, walletInitiated, challengedHash, challengedKind\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce)\r\n    public\r\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index)\r\n            return;\r\n\r\n        \r\n        if (clearNonce)\r\n            proposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\r\n\r\n        \r\n        proposals[index - 1].terminated = true;\r\n\r\n        \r\n        emit TerminateProposalEvent(\r\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\r\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\r\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\r\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce,\r\n        bool walletTerminated)\r\n    public\r\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index)\r\n            return;\r\n\r\n        \r\n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:165]\");\r\n\r\n        \r\n        if (clearNonce)\r\n            proposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\r\n\r\n        \r\n        proposals[index - 1].terminated = true;\r\n\r\n        \r\n        emit TerminateProposalEvent(\r\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\r\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\r\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\r\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index)\r\n            return;\r\n\r\n        \r\n        emit RemoveProposalEvent(\r\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\r\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\r\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\r\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\r\n        );\r\n\r\n        \r\n        _removeProposal(index);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\r\n    public\r\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index)\r\n            return;\r\n\r\n        \r\n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:225]\");\r\n\r\n        \r\n        emit RemoveProposalEvent(\r\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\r\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\r\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\r\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\r\n        );\r\n\r\n        \r\n        _removeProposal(index);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\r\n        uint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\r\n    public\r\n    onlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:255]\");\r\n\r\n        \r\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\r\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\r\n        proposals[index - 1].disqualification.challenger = challengerWallet;\r\n        proposals[index - 1].disqualification.nonce = candidateNonce;\r\n        proposals[index - 1].disqualification.blockNumber = blockNumber;\r\n        proposals[index - 1].disqualification.candidate.hash = candidateHash;\r\n        proposals[index - 1].disqualification.candidate.kind = candidateKind;\r\n\r\n        \r\n        emit DisqualifyProposalEvent(\r\n            challengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\r\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\r\n            currency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\r\n            challengerWallet, candidateNonce, candidateHash, candidateKind\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function qualifyProposal(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    onlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:284]\");\r\n\r\n        \r\n        emit QualifyProposalEvent(\r\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\r\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\r\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\r\n            proposals[index - 1].disqualification.challenger,\r\n            proposals[index - 1].disqualification.nonce,\r\n            proposals[index - 1].disqualification.candidate.hash,\r\n            proposals[index - 1].disqualification.candidate.kind\r\n        );\r\n\r\n        \r\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\r\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\r\n        delete proposals[index - 1].disqualification;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        \r\n        return 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        \r\n        return 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:342]\");\r\n        return proposals[index - 1].terminated;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:357]\");\r\n        return block.timestamp >= proposals[index - 1].expirationTime;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:371]\");\r\n        return proposals[index - 1].nonce;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:385]\");\r\n        return proposals[index - 1].referenceBlockNumber;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:399]\");\r\n        return proposals[index - 1].definitionBlockNumber;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:413]\");\r\n        return proposals[index - 1].expirationTime;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (SettlementChallengeTypesLib.Status)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:427]\");\r\n        return proposals[index - 1].status;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:441]\");\r\n        return proposals[index - 1].amounts.cumulativeTransfer;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:455]\");\r\n        return proposals[index - 1].amounts.stage;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:469]\");\r\n        return proposals[index - 1].amounts.targetBalance;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalChallengedHash(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bytes32)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:483]\");\r\n        return proposals[index - 1].challenged.hash;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalChallengedKind(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (string memory)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:497]\");\r\n        return proposals[index - 1].challenged.kind;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:511]\");\r\n        return proposals[index - 1].walletInitiated;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:525]\");\r\n        return proposals[index - 1].disqualification.challenger;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:539]\");\r\n        return proposals[index - 1].disqualification.nonce;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:553]\");\r\n        return proposals[index - 1].disqualification.blockNumber;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bytes32)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:567]\");\r\n        return proposals[index - 1].disqualification.candidate.hash;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (string memory)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:581]\");\r\n        return proposals[index - 1].disqualification.candidate.kind;\r\n    }\r\n\r\n    \r\n    \r\n    function upgradeProposal(SettlementChallengeTypesLib.Proposal memory proposal)\r\n    public\r\n    onlyWhenUpgrading\r\n    {\r\n        \r\n        require(\r\n            0 == proposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id],\r\n            \"Proposal exists for wallet, nonce and currency [DriipSettlementChallengeState.sol:592]\"\r\n        );\r\n\r\n        \r\n        proposals.push(proposal);\r\n\r\n        \r\n        uint256 index = proposals.length;\r\n\r\n        \r\n        proposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id] = index;\r\n        proposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id] = index;\r\n\r\n        \r\n        emit UpgradeProposalEvent(proposal);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function _initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\r\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency memory currency, uint256 referenceBlockNumber, bool walletInitiated,\r\n        bytes32 challengedHash, string memory challengedKind)\r\n    private\r\n    {\r\n        \r\n        require(\r\n            0 == proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id],\r\n            \"Existing proposal found for wallet, nonce and currency [DriipSettlementChallengeState.sol:620]\"\r\n        );\r\n\r\n        \r\n        require(stageAmount.isPositiveInt256(), \"Stage amount not positive [DriipSettlementChallengeState.sol:626]\");\r\n        require(targetBalanceAmount.isPositiveInt256(), \"Target balance amount not positive [DriipSettlementChallengeState.sol:627]\");\r\n\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index) {\r\n            index = ++(proposals.length);\r\n            proposalIndexByWalletCurrency[wallet][currency.ct][currency.id] = index;\r\n        }\r\n\r\n        \r\n        proposals[index - 1].wallet = wallet;\r\n        proposals[index - 1].nonce = nonce;\r\n        proposals[index - 1].referenceBlockNumber = referenceBlockNumber;\r\n        proposals[index - 1].definitionBlockNumber = block.number;\r\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\r\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\r\n        proposals[index - 1].currency = currency;\r\n        proposals[index - 1].amounts.cumulativeTransfer = cumulativeTransferAmount;\r\n        proposals[index - 1].amounts.stage = stageAmount;\r\n        proposals[index - 1].amounts.targetBalance = targetBalanceAmount;\r\n        proposals[index - 1].walletInitiated = walletInitiated;\r\n        proposals[index - 1].terminated = false;\r\n        proposals[index - 1].challenged.hash = challengedHash;\r\n        proposals[index - 1].challenged.kind = challengedKind;\r\n\r\n        \r\n        proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id] = index;\r\n    }\r\n\r\n    function _removeProposal(uint256 index)\r\n    private\r\n    {\r\n        \r\n        proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = 0;\r\n        proposalIndexByWalletNonceCurrency[proposals[index - 1].wallet][proposals[index - 1].nonce][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = 0;\r\n        if (index < proposals.length) {\r\n            proposals[index - 1] = proposals[proposals.length - 1];\r\n            proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = index;\r\n            proposalIndexByWalletNonceCurrency[proposals[index - 1].wallet][proposals[index - 1].nonce][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = index;\r\n        }\r\n        proposals.length--;\r\n    }\r\n}\r\n\r\ncontract NullSettlementChallengeByPayment is Ownable, ConfigurableOperational, BalanceTrackable, WalletLockable {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n    using BalanceTrackerLib for BalanceTracker;\r\n\r\n    \r\n    \r\n    \r\n    NullSettlementDisputeByPayment public nullSettlementDisputeByPayment;\r\n    NullSettlementChallengeState public nullSettlementChallengeState;\r\n    DriipSettlementChallengeState public driipSettlementChallengeState;\r\n\r\n    \r\n    \r\n    \r\n    event SetNullSettlementDisputeByPaymentEvent(NullSettlementDisputeByPayment oldNullSettlementDisputeByPayment,\r\n        NullSettlementDisputeByPayment newNullSettlementDisputeByPayment);\r\n    event SetNullSettlementChallengeStateEvent(NullSettlementChallengeState oldNullSettlementChallengeState,\r\n        NullSettlementChallengeState newNullSettlementChallengeState);\r\n    event SetDriipSettlementChallengeStateEvent(DriipSettlementChallengeState oldDriipSettlementChallengeState,\r\n        DriipSettlementChallengeState newDriipSettlementChallengeState);\r\n    event StartChallengeEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        address currencyCt, uint currencyId);\r\n    event StartChallengeByProxyEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        address currencyCt, uint currencyId, address proxy);\r\n    event StopChallengeEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        address currencyCt, uint256 currencyId);\r\n    event StopChallengeByProxyEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        address currencyCt, uint256 currencyId, address proxy);\r\n    event ChallengeByPaymentEvent(address challengedWallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        address currencyCt, uint256 currencyId, address challengerWallet);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setNullSettlementDisputeByPayment(NullSettlementDisputeByPayment newNullSettlementDisputeByPayment)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(newNullSettlementDisputeByPayment))\r\n    {\r\n        NullSettlementDisputeByPayment oldNullSettlementDisputeByPayment = nullSettlementDisputeByPayment;\r\n        nullSettlementDisputeByPayment = newNullSettlementDisputeByPayment;\r\n        emit SetNullSettlementDisputeByPaymentEvent(oldNullSettlementDisputeByPayment, nullSettlementDisputeByPayment);\r\n    }\r\n\r\n    \r\n    \r\n    function setNullSettlementChallengeState(NullSettlementChallengeState newNullSettlementChallengeState)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(newNullSettlementChallengeState))\r\n    {\r\n        NullSettlementChallengeState oldNullSettlementChallengeState = nullSettlementChallengeState;\r\n        nullSettlementChallengeState = newNullSettlementChallengeState;\r\n        emit SetNullSettlementChallengeStateEvent(oldNullSettlementChallengeState, nullSettlementChallengeState);\r\n    }\r\n\r\n    \r\n    \r\n    function setDriipSettlementChallengeState(DriipSettlementChallengeState newDriipSettlementChallengeState)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(newDriipSettlementChallengeState))\r\n    {\r\n        DriipSettlementChallengeState oldDriipSettlementChallengeState = driipSettlementChallengeState;\r\n        driipSettlementChallengeState = newDriipSettlementChallengeState;\r\n        emit SetDriipSettlementChallengeStateEvent(oldDriipSettlementChallengeState, driipSettlementChallengeState);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function startChallenge(int256 amount, address currencyCt, uint256 currencyId)\r\n    public\r\n    {\r\n        \r\n        require(!walletLocker.isLocked(msg.sender), \"Wallet found locked [NullSettlementChallengeByPayment.sol:116]\");\r\n\r\n        \r\n        MonetaryTypesLib.Currency memory currency = MonetaryTypesLib.Currency(currencyCt, currencyId);\r\n\r\n        \r\n        _startChallenge(msg.sender, amount, currency, true);\r\n\r\n        \r\n        emit StartChallengeEvent(\r\n            msg.sender,\r\n            nullSettlementChallengeState.proposalNonce(msg.sender, currency),\r\n            amount,\r\n            nullSettlementChallengeState.proposalTargetBalanceAmount(msg.sender, currency),\r\n            currencyCt, currencyId\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function startChallengeByProxy(address wallet, int256 amount, address currencyCt, uint256 currencyId)\r\n    public\r\n    onlyOperator\r\n    {\r\n        \r\n        MonetaryTypesLib.Currency memory currency = MonetaryTypesLib.Currency(currencyCt, currencyId);\r\n\r\n        \r\n        _startChallenge(wallet, amount, currency, false);\r\n\r\n        \r\n        emit StartChallengeByProxyEvent(\r\n            wallet,\r\n            nullSettlementChallengeState.proposalNonce(wallet, currency),\r\n            amount,\r\n            nullSettlementChallengeState.proposalTargetBalanceAmount(wallet, currency),\r\n            currencyCt, currencyId, msg.sender\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function stopChallenge(address currencyCt, uint256 currencyId)\r\n    public\r\n    {\r\n        \r\n        MonetaryTypesLib.Currency memory currency = MonetaryTypesLib.Currency(currencyCt, currencyId);\r\n\r\n        \r\n        _stopChallenge(msg.sender, currency, true);\r\n\r\n        \r\n        emit StopChallengeEvent(\r\n            msg.sender,\r\n            nullSettlementChallengeState.proposalNonce(msg.sender, currency),\r\n            nullSettlementChallengeState.proposalStageAmount(msg.sender, currency),\r\n            nullSettlementChallengeState.proposalTargetBalanceAmount(msg.sender, currency),\r\n            currencyCt, currencyId\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function stopChallengeByProxy(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    onlyOperator\r\n    {\r\n        \r\n        MonetaryTypesLib.Currency memory currency = MonetaryTypesLib.Currency(currencyCt, currencyId);\r\n\r\n        \r\n        _stopChallenge(wallet, currency, false);\r\n\r\n        \r\n        emit StopChallengeByProxyEvent(\r\n            wallet,\r\n            nullSettlementChallengeState.proposalNonce(wallet, currency),\r\n            nullSettlementChallengeState.proposalStageAmount(wallet, currency),\r\n            nullSettlementChallengeState.proposalTargetBalanceAmount(wallet, currency),\r\n            currencyCt, currencyId, msg.sender\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function hasProposal(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return nullSettlementChallengeState.hasProposal(\r\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function hasProposalTerminated(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return nullSettlementChallengeState.hasProposalTerminated(\r\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function hasProposalExpired(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return nullSettlementChallengeState.hasProposalExpired(\r\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function proposalNonce(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return nullSettlementChallengeState.proposalNonce(\r\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function proposalReferenceBlockNumber(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return nullSettlementChallengeState.proposalReferenceBlockNumber(\r\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function proposalExpirationTime(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return nullSettlementChallengeState.proposalExpirationTime(\r\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function proposalStatus(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (SettlementChallengeTypesLib.Status)\r\n    {\r\n        return nullSettlementChallengeState.proposalStatus(\r\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function proposalStageAmount(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return nullSettlementChallengeState.proposalStageAmount(\r\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function proposalTargetBalanceAmount(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return nullSettlementChallengeState.proposalTargetBalanceAmount(\r\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function proposalWalletInitiated(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return nullSettlementChallengeState.proposalWalletInitiated(\r\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationChallenger(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        return nullSettlementChallengeState.proposalDisqualificationChallenger(\r\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationBlockNumber(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return nullSettlementChallengeState.proposalDisqualificationBlockNumber(\r\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationCandidateKind(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (string memory)\r\n    {\r\n        return nullSettlementChallengeState.proposalDisqualificationCandidateKind(\r\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationCandidateHash(address wallet, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (bytes32)\r\n    {\r\n        return nullSettlementChallengeState.proposalDisqualificationCandidateHash(\r\n            wallet, MonetaryTypesLib.Currency(currencyCt, currencyId)\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function challengeByPayment(address wallet, PaymentTypesLib.Payment memory payment)\r\n    public\r\n    onlyOperationalModeNormal\r\n    {\r\n        \r\n        nullSettlementDisputeByPayment.challengeByPayment(wallet, payment, msg.sender);\r\n\r\n        \r\n        emit ChallengeByPaymentEvent(\r\n            wallet,\r\n            nullSettlementChallengeState.proposalNonce(wallet, payment.currency),\r\n            nullSettlementChallengeState.proposalStageAmount(wallet, payment.currency),\r\n            nullSettlementChallengeState.proposalTargetBalanceAmount(wallet, payment.currency),\r\n            payment.currency.ct, payment.currency.id, msg.sender\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function _startChallenge(address wallet, int256 stageAmount, MonetaryTypesLib.Currency memory currency,\r\n        bool walletInitiated)\r\n    private\r\n    {\r\n        \r\n        require(\r\n            block.number >= configuration.earliestSettlementBlockNumber(),\r\n            \"Current block number below earliest settlement block number [NullSettlementChallengeByPayment.sol:443]\"\r\n        );\r\n\r\n        \r\n        require(\r\n            !nullSettlementChallengeState.hasProposal(wallet, currency) ||\r\n        nullSettlementChallengeState.hasProposalExpired(wallet, currency),\r\n            \"Overlapping null settlement challenge proposal found [NullSettlementChallengeByPayment.sol:449]\"\r\n        );\r\n\r\n        \r\n        \r\n        (\r\n        int256 currentActiveBalanceAmount, uint256 currentActiveBalanceBlockNumber,\r\n        int256 dscCumulativeTransferAmount, int256 dscStageAmount,\r\n        uint256 nonce\r\n        ) = _walletProperties(\r\n            wallet, currency\r\n        );\r\n\r\n        \r\n        \r\n        nullSettlementChallengeState.initiateProposal(\r\n            wallet, nonce, stageAmount,\r\n            currentActiveBalanceAmount.add(\r\n                dscCumulativeTransferAmount.sub(dscStageAmount).sub(stageAmount)\r\n            ),\r\n            currency,\r\n            currentActiveBalanceBlockNumber, walletInitiated\r\n        );\r\n    }\r\n\r\n    function _stopChallenge(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\r\n    private\r\n    {\r\n        \r\n        require(nullSettlementChallengeState.hasProposal(wallet, currency), \"No proposal found [NullSettlementChallengeByPayment.sol:481]\");\r\n        require(!nullSettlementChallengeState.hasProposalTerminated(wallet, currency), \"Proposal found terminated [NullSettlementChallengeByPayment.sol:482]\");\r\n\r\n        \r\n        nullSettlementChallengeState.terminateProposal(\r\n            wallet, currency, walletTerminated\r\n        );\r\n    }\r\n\r\n    function _walletProperties(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    private\r\n    view\r\n    returns (\r\n        int256 currentActiveBalanceAmount, uint256 currentActiveBalanceBlockNumber,\r\n        int256 dscCumulativeTransferAmount, int256 dscStageAmount,\r\n        uint256 nonce\r\n    ) {\r\n        (currentActiveBalanceAmount, currentActiveBalanceBlockNumber) = balanceTracker.fungibleActiveRecord(\r\n            wallet, currency\r\n        );\r\n\r\n        if (driipSettlementChallengeState.hasProposal(wallet, currency)) {\r\n            if (!driipSettlementChallengeState.hasProposalTerminated(wallet, currency)) {\r\n                dscCumulativeTransferAmount = driipSettlementChallengeState.proposalCumulativeTransferAmount(wallet, currency);\r\n                dscStageAmount = driipSettlementChallengeState.proposalStageAmount(wallet, currency);\r\n            }\r\n\r\n            nonce = driipSettlementChallengeState.proposalNonce(wallet, currency);\r\n        }\r\n\r\n        if (nullSettlementChallengeState.hasProposal(wallet, currency))\r\n            nonce = nonce.clampMin(nullSettlementChallengeState.proposalNonce(wallet, currency));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalStatus\",\"outputs\":[{\"internalType\":\"enum SettlementChallengeTypesLib.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalTargetBalanceAmount\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceTracker\",\"outputs\":[{\"internalType\":\"contract BalanceTracker\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletLockerFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract DriipSettlementChallengeState\",\"name\":\"newDriipSettlementChallengeState\",\"type\":\"address\"}],\"name\":\"setDriipSettlementChallengeState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructionDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract NullSettlementDisputeByPayment\",\"name\":\"newNullSettlementDisputeByPayment\",\"type\":\"address\"}],\"name\":\"setNullSettlementDisputeByPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"hasProposalExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceTrackerFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalStageAmount\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nullSettlementDisputeByPayment\",\"outputs\":[{\"internalType\":\"contract NullSettlementDisputeByPayment\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destructor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"hasProposalTerminated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"driipSettlementChallengeState\",\"outputs\":[{\"internalType\":\"contract DriipSettlementChallengeState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract BalanceTracker\",\"name\":\"newBalanceTracker\",\"type\":\"address\"}],\"name\":\"setBalanceTracker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeWalletLocker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Configuration\",\"name\":\"newConfiguration\",\"type\":\"address\"}],\"name\":\"setConfiguration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"configuration\",\"outputs\":[{\"internalType\":\"contract Configuration\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract NullSettlementChallengeState\",\"name\":\"newNullSettlementChallengeState\",\"type\":\"address\"}],\"name\":\"setNullSettlementChallengeState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalReferenceBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalWalletInitiated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract WalletLocker\",\"name\":\"newWalletLocker\",\"type\":\"address\"}],\"name\":\"setWalletLocker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"single\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.SingleFigureTotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.PaymentSenderParty\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.TotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"}],\"internalType\":\"struct PaymentTypesLib.PaymentRecipientParty\",\"name\":\"recipient\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"single\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"total\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.SingleTotalInt256\",\"name\":\"transfers\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"wallet\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"operator\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.WalletOperatorSeal\",\"name\":\"seals\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.Operator\",\"name\":\"operator\",\"type\":\"tuple\"}],\"internalType\":\"struct PaymentTypesLib.Payment\",\"name\":\"payment\",\"type\":\"tuple\"}],\"name\":\"challengeByPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"stopChallengeByProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalDisqualificationCandidateHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeBalanceTracker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"hasProposal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"stopChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"startChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalDisqualificationCandidateKind\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalDisqualificationBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletLocker\",\"outputs\":[{\"internalType\":\"contract WalletLocker\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"startChallengeByProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nullSettlementChallengeState\",\"outputs\":[{\"internalType\":\"contract NullSettlementChallengeState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalExpirationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"proposalDisqualificationChallenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract NullSettlementDisputeByPayment\",\"name\":\"oldNullSettlementDisputeByPayment\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract NullSettlementDisputeByPayment\",\"name\":\"newNullSettlementDisputeByPayment\",\"type\":\"address\"}],\"name\":\"SetNullSettlementDisputeByPaymentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract NullSettlementChallengeState\",\"name\":\"oldNullSettlementChallengeState\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract NullSettlementChallengeState\",\"name\":\"newNullSettlementChallengeState\",\"type\":\"address\"}],\"name\":\"SetNullSettlementChallengeStateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract DriipSettlementChallengeState\",\"name\":\"oldDriipSettlementChallengeState\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract DriipSettlementChallengeState\",\"name\":\"newDriipSettlementChallengeState\",\"type\":\"address\"}],\"name\":\"SetDriipSettlementChallengeStateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"StartChallengeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"StartChallengeByProxyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"StopChallengeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"StopChallengeByProxyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengedWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengerWallet\",\"type\":\"address\"}],\"name\":\"ChallengeByPaymentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract WalletLocker\",\"name\":\"oldWalletLocker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract WalletLocker\",\"name\":\"newWalletLocker\",\"type\":\"address\"}],\"name\":\"SetWalletLockerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeWalletLockerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract BalanceTracker\",\"name\":\"oldBalanceTracker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract BalanceTracker\",\"name\":\"newBalanceTracker\",\"type\":\"address\"}],\"name\":\"SetBalanceTrackerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeBalanceTrackerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract Configuration\",\"name\":\"oldConfiguration\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract Configuration\",\"name\":\"newConfiguration\",\"type\":\"address\"}],\"name\":\"SetConfigurationEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDeployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"SetDeployerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"SetOperatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SelfDestructionDisabledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TriggerSelfDestructionEvent\",\"type\":\"event\"}]","ContractName":"NullSettlementChallengeByPayment","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000f05179bac3d1fbef58a2fcd7ad0f769840027cc6","Library":"SafeMathUintLib:0ff948c236c8d4dfcd0168bf243314c8ff8ec967","SwarmSource":"bzzr://ec11891ae893dc40a94e0a00a061097a00765330c7bde81d8f1b97d9d4340658"}]}