{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\r\n\r\n\r\ninterface MinimalEscapeHatchRegistryInterface {\r\n  function getEscapeHatch() external view returns (\r\n    bool exists, address escapeHatch\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * @title AdharmaSmartWalletImplementation\r\n * @author 0age\r\n * @notice The Adharma smart wallet is an emergency implementation wallet that\r\n * can be immediately upgraded to by the Upgrade Beacon Controller Manager in\r\n * the event of a critical-severity exploit, or after a 90-day period of\r\n * inactivity by Dharma. It gives the user direct, sole custody and control over\r\n * their smart wallet until the Upgrade Beacon Controller Manager issues another\r\n * upgrade to the implementation contract. If the user has set an escape hatch\r\n * for the account, it will have authority over the smart wallet during the\r\n * contingency - otherwise, the user signing key in storage slot zero will have\r\n * that authority.\r\n */\r\ncontract AdharmaSmartWalletImplementation {\r\n  // The key is still held in storage slot zero.\r\n  address private _key;\r\n\r\n  // The escape hatch registry address is hard-coded as a constant.\r\n  MinimalEscapeHatchRegistryInterface private constant _ESCAPE_HATCH = (\r\n    MinimalEscapeHatchRegistryInterface(\r\n      0x00000000005280B515004B998a944630B6C663f8\r\n    )\r\n  );\r\n\r\n  // The smart wallet can receive funds, though it is inadvisable.\r\n  function () external payable {}\r\n\r\n  // Keep the initializer function on the contract in case a smart wallet has\r\n  // not yet been deployed but the account still contains funds.\r\n  function initialize(address key) external {\r\n    // Ensure that this function is only callable during contract construction.\r\n    assembly { if extcodesize(address) { revert(0, 0) } }\r\n\r\n    // Ensure that a key is set on this smart wallet.\r\n    require(key != address(0), \"No key provided.\");\r\n\r\n    // Set up the key.\r\n    _key = key;\r\n  }\r\n\r\n  // The escape hatch account, or the key account if no escape hatch is set, has\r\n  // sole authority to make calls from the smart wallet during the contingency.\r\n  function performCall(\r\n    address payable to, uint256 amount, bytes calldata data\r\n  ) external payable returns (\r\n    bool ok, bytes memory returnData\r\n  ) {\r\n    // Determine if an escape hatch is set on the registry for this account.\r\n    (bool escapeHatchSet, address escapeHatch) = _ESCAPE_HATCH.getEscapeHatch();\r\n\r\n    // Set escape hatch account as permitted caller, or user key if none is set.\r\n    address authority = escapeHatchSet ? escapeHatch : _key;\r\n\r\n    // Ensure that the call originates from the designated caller.\r\n    require(msg.sender == authority, \"Caller prohibited.\");\r\n\r\n    // Perform the call, forwarding all gas and supplying given value and data.\r\n    (ok, returnData) = to.call.value(amount)(data);\r\n\r\n    // Revert and pass along the revert reason if the call reverted.\r\n    require(ok, string(returnData));\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"performCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"key\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"AdharmaSmartWalletImplementation","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://41646861726d61536d61727457616c6c6574496d706c656d656e746174696f6e"}]}