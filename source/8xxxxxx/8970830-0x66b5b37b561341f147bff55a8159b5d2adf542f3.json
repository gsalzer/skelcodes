{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: contracts/interfaces/SyscoinSuperblocksI.sol\n\npragma solidity ^0.5.13;\n\ninterface SyscoinSuperblocksI {\n\n    // @dev - Superblock status\n    enum Status { Uninitialized, New, InBattle, SemiApproved, Approved, Invalid }\n    struct SuperblockInfo {\n        bytes32 blocksMerkleRoot;\n        uint timestamp;\n        uint mtpTimestamp;\n        bytes32 lastHash;\n        bytes32 parentId;\n        address submitter;\n        uint32 lastBits;\n        uint32 height;\n        Status status;\n    }\n    function propose(\n        bytes32 _blocksMerkleRoot,\n        uint _timestamp,\n        uint _mtpTimestamp,\n        bytes32 _lastHash,\n        uint32 _lastBits,\n        bytes32 _parentId,\n        address submitter\n    ) external returns (uint, bytes32);\n\n    function getSuperblock(bytes32 superblockHash) external view returns (\n        bytes32 _blocksMerkleRoot,\n        uint _timestamp,\n        uint _mtpTimestamp,\n        bytes32 _lastHash,\n        uint32 _lastBits,\n        bytes32 _parentId,\n        address _submitter,\n        Status _status,\n        uint32 _height\n    );\n\n    function relayTx(\n        bytes calldata _txBytes,\n        uint _txIndex,\n        uint[] calldata _txSiblings,\n        bytes calldata _syscoinBlockHeader,\n        uint _syscoinBlockIndex,\n        uint[] calldata _syscoinBlockSiblings,\n        bytes32 _superblockHash\n    ) external returns (uint);\n\n    function confirm(bytes32 _superblockHash, address _validator) external returns (uint);\n    function challenge(bytes32 _superblockHash, address _challenger) external returns (uint);\n    function semiApprove(bytes32 _superblockHash, address _validator) external returns (uint);\n    function invalidate(bytes32 _superblockHash, address _validator) external returns (uint);\n    function getBestSuperblock() external view returns (bytes32);\n    function getChainHeight() external view returns (uint);\n    function getSuperblockHeight(bytes32 superblockHash) external view returns (uint32);\n    function getSuperblockParentId(bytes32 _superblockHash) external view returns (bytes32);\n    function getSuperblockStatus(bytes32 _superblockHash) external view returns (Status);\n    function getSuperblockAt(uint _height) external view returns (bytes32);\n    function getSuperblockTimestamp(bytes32 _superblockHash) external view returns (uint);\n    function getSuperblockMedianTimestamp(bytes32 _superblockHash) external view returns (uint);\n}\n\n// File: contracts/interfaces/SyscoinClaimManagerI.sol\n\npragma solidity ^0.5.13;\n\n\ninterface SyscoinClaimManagerI {\n    function bondDeposit(bytes32 superblockHash, address account, uint amount) external returns (uint);\n    function getDeposit(address account) external view returns (uint);\n    function checkClaimFinished(bytes32 superblockHash) external returns (bool);\n    function sessionDecided(bytes32 superblockHash, address winner, address loser) external;\n}\n\n// File: contracts/SyscoinErrorCodes.sol\n\npragma solidity ^0.5.13;\n\n// @dev - SyscoinSuperblocks error codes\ncontract SyscoinErrorCodes {\n    // Error codes\n    uint constant ERR_INVALID_HEADER = 10050;\n    uint constant ERR_COINBASE_INDEX = 10060; // coinbase tx index within Bitcoin merkle isn't 0\n    uint constant ERR_NOT_MERGE_MINED = 10070; // trying to check AuxPoW on a block that wasn't merge mined\n    uint constant ERR_FOUND_TWICE = 10080; // 0xfabe6d6d found twice\n    uint constant ERR_NO_MERGE_HEADER = 10090; // 0xfabe6d6d not found\n    uint constant ERR_CHAIN_MERKLE = 10110;\n    uint constant ERR_PARENT_MERKLE = 10120;\n    uint constant ERR_PROOF_OF_WORK = 10130;\n    uint constant ERR_INVALID_HEADER_HASH = 10140;\n    uint constant ERR_PROOF_OF_WORK_AUXPOW = 10150;\n    uint constant ERR_PARSE_TX_OUTPUT_LENGTH = 10160;\n\n\n    uint constant ERR_SUPERBLOCK_OK = 0;\n    uint constant ERR_SUPERBLOCK_MISSING_BLOCKS = 1;\n    uint constant ERR_SUPERBLOCK_BAD_STATUS = 50020;\n    uint constant ERR_SUPERBLOCK_BAD_SYSCOIN_STATUS = 50025;\n    uint constant ERR_SUPERBLOCK_TIMEOUT = 50026;\n    uint constant ERR_SUPERBLOCK_NO_TIMEOUT = 50030;\n    uint constant ERR_SUPERBLOCK_BAD_TIMESTAMP = 50035;\n    uint constant ERR_SUPERBLOCK_INVALID_TIMESTAMP = 50036;\n    uint constant ERR_SUPERBLOCK_INVALID_MERKLE = 50038;\n\n    // The error codes \"ERR_SUPERBLOCK_BAD_PARENT_*\" corresponds to ERR_SUPERBLOCK_BAD_PARENT + superblock.status\n    uint constant ERR_SUPERBLOCK_BAD_PARENT = 50040;\n    uint constant ERR_SUPERBLOCK_BAD_PARENT_UNINITIALIZED = 50040;\n    uint constant ERR_SUPERBLOCK_BAD_PARENT_NEW = 50041;\n    uint constant ERR_SUPERBLOCK_BAD_PARENT_INBATTLE = 50042;\n    uint constant ERR_SUPERBLOCK_BAD_PARENT_INVALID = 50045;\n\n    uint constant ERR_SUPERBLOCK_OWN_CHALLENGE = 50055;\n    uint constant ERR_SUPERBLOCK_BAD_PREV_TIMESTAMP = 50056;\n    uint constant ERR_SUPERBLOCK_BITS_SUPERBLOCK = 50057;\n    uint constant ERR_SUPERBLOCK_BITS_PREVBLOCK = 50058;\n    uint constant ERR_SUPERBLOCK_HASH_SUPERBLOCK = 50059;\n    uint constant ERR_SUPERBLOCK_HASH_PREVBLOCK = 50060;\n    uint constant ERR_SUPERBLOCK_HASH_PREVSUPERBLOCK = 50061;\n    uint constant ERR_SUPERBLOCK_BITS_LASTBLOCK = 50064;\n    uint constant ERR_SUPERBLOCK_MIN_DEPOSIT = 50065;\n    uint constant ERR_SUPERBLOCK_BITS_INTERIM_PREVBLOCK = 50066;\n    uint constant ERR_SUPERBLOCK_HASH_INTERIM_PREVBLOCK = 50067;\n    uint constant ERR_SUPERBLOCK_BAD_TIMESTAMP_AVERAGE = 50068;\n    uint constant ERR_SUPERBLOCK_BAD_TIMESTAMP_MTP = 50069;\n\n    uint constant ERR_SUPERBLOCK_NOT_CLAIMMANAGER = 50070;\n    uint constant ERR_SUPERBLOCK_MISMATCH_TIMESTAMP_MTP = 50071;\n    uint constant ERR_SUPERBLOCK_TOOSMALL_TIMESTAMP_MTP = 50072;\n\n    uint constant ERR_SUPERBLOCK_BAD_CLAIM = 50080;\n    uint constant ERR_SUPERBLOCK_VERIFICATION_PENDING = 50090;\n    uint constant ERR_SUPERBLOCK_CLAIM_DECIDED = 50100;\n    uint constant ERR_SUPERBLOCK_CHALLENGE_EXISTS = 50110;\n\n    uint constant ERR_SUPERBLOCK_BAD_ACCUMULATED_WORK = 50120;\n    uint constant ERR_SUPERBLOCK_BAD_BITS = 50130;\n    uint constant ERR_SUPERBLOCK_MISSING_CONFIRMATIONS = 50140;\n    uint constant ERR_SUPERBLOCK_BAD_LASTBLOCK = 50150;\n    uint constant ERR_SUPERBLOCK_BAD_LASTBLOCK_STATUS = 50160;\n    uint constant ERR_SUPERBLOCK_BAD_BLOCKHEIGHT = 50170;\n    uint constant ERR_SUPERBLOCK_BAD_PREVBLOCK = 50190;\n    uint constant ERR_SUPERBLOCK_BAD_MISMATCH = 50210;\n    uint constant ERR_SUPERBLOCK_INTERIMBLOCK_MISSING = 50220;\n    uint constant ERR_SUPERBLOCK_BAD_INTERIM_PREVHASH = 50230;\n    uint constant ERR_SUPERBLOCK_BAD_INTERIM_BLOCKINDEX = 50240;\n\n\n    // error codes for verifyTx\n    uint constant ERR_BAD_FEE = 20010;\n    uint constant ERR_CONFIRMATIONS = 20020;\n    uint constant ERR_CHAIN = 20030;\n    uint constant ERR_SUPERBLOCK = 20040;\n    uint constant ERR_MERKLE_ROOT = 20050;\n    uint constant ERR_TX_64BYTE = 20060;\n    // error codes for relayTx\n    uint constant ERR_RELAY_VERIFY = 30010;\n    uint constant public minProposalDeposit = 3000000000000000000;\n}\n\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: contracts/SyscoinBattleManager.sol\n\npragma solidity ^0.5.13;\n\n\n\n\n\n// @dev - Manages a battle session between superblock submitter and challenger\ncontract SyscoinBattleManager is Initializable, SyscoinErrorCodes {\n\n    // For verifying Syscoin difficulty\n    uint constant TARGET_TIMESPAN =  21600;\n    uint constant TARGET_TIMESPAN_MIN = 17280; // TARGET_TIMESPAN * (8/10);\n    uint constant TARGET_TIMESPAN_MAX = 27000; // TARGET_TIMESPAN * (10/8);\n    uint constant TARGET_TIMESPAN_ADJUSTMENT =  360;  // 6 hour\n    uint constant POW_LIMIT =    0x00000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    struct BattleSession {\n        address submitter;\n        address challenger;\n        uint lastActionTimestamp;         // Last action timestamp\n        bytes32 prevSubmitBlockhash;\n        bytes32[] merkleRoots;            // interim merkle roots to recreate final root hash on last set of headers\n    }\n    // AuxPoW block fields\n    struct AuxPoW {\n        uint blockHash;\n\n        uint txHash;\n\n        uint coinbaseMerkleRoot; // Merkle root of auxiliary block hash tree; stored in coinbase tx field\n        uint[] chainMerkleProof; // proves that a given Syscoin block hash belongs to a tree with the above root\n        uint syscoinHashIndex; // index of Syscoin block hash within block hash tree\n        uint coinbaseMerkleRootCode; // encodes whether or not the root was found properly\n\n        uint parentMerkleRoot; // Merkle root of transaction tree from parent Bitcoin block header\n        uint[] parentMerkleProof; // proves that coinbase tx belongs to a tree with the above root\n        uint coinbaseTxIndex; // index of coinbase tx within Bitcoin tx tree\n\n        uint parentNonce;\n        uint pos;\n    }\n    // Syscoin block header stored as a struct, mostly for readability purposes.\n    // BlockHeader structs can be obtained by parsing a block header's first 80 bytes\n    // with parseHeaderBytes.\n    struct BlockHeader {\n        uint32 bits;\n        bytes32 prevBlock;\n        uint32 timestamp;\n        bytes32 blockHash;\n    }\n    mapping (bytes32 => BattleSession) sessions;\n\n    enum Network { MAINNET, TESTNET, REGTEST }\n\n    uint public superblockDuration;         // Superblock duration (in blocks)\n    uint public superblockTimeout;          // Timeout action (in seconds)\n\n\n    // network that the stored blocks belong to\n    Network private net;\n\n\n    // Syscoin claim manager\n    SyscoinClaimManagerI trustedSyscoinClaimManager;\n\n    // Superblocks contract\n    SyscoinSuperblocksI trustedSuperblocks;\n\n    event NewBattle(bytes32 superblockHash,address submitter, address challenger);\n    event ChallengerConvicted(bytes32 superblockHash, uint err, address challenger);\n    event SubmitterConvicted(bytes32 superblockHash, uint err, address submitter);\n    event RespondBlockHeaders(bytes32 superblockHash, uint merkleHashCount, address submitter);\n    modifier onlyFrom(address sender) {\n        require(msg.sender == sender);\n        _;\n    }\n\n    modifier onlyChallenger(bytes32 superblockHash) {\n        require(msg.sender == sessions[superblockHash].challenger);\n        _;\n    }\n\n    // @dev – Configures the contract managing superblocks battles\n    // @param _network Network type to use for block difficulty validation\n    // @param _superblocks Contract that manages superblocks\n    // @param _superblockDuration Superblock duration (in blocks)\n    // @param _superblockTimeout Time to wait for challenges (in seconds)\n    function init(\n        Network _network,\n        SyscoinSuperblocksI _superblocks,\n        uint _superblockDuration,\n        uint _superblockTimeout\n    ) external initializer {\n        net = _network;\n        trustedSuperblocks = _superblocks;\n        superblockDuration = _superblockDuration;\n        superblockTimeout = _superblockTimeout;\n    }\n\n    function setSyscoinClaimManager(SyscoinClaimManagerI _syscoinClaimManager) external {\n        require(address(trustedSyscoinClaimManager) == address(0) && address(_syscoinClaimManager) != address(0));\n        trustedSyscoinClaimManager = _syscoinClaimManager;\n    }\n\n    // @dev - Start a battle session\n    function beginBattleSession(bytes32 superblockHash, address submitter, address challenger)\n        external onlyFrom(address(trustedSyscoinClaimManager)) {\n        BattleSession storage session = sessions[superblockHash];\n\n        require(session.submitter == address(0));\n\n        session.submitter = submitter;\n        session.challenger = challenger;\n        session.merkleRoots.length = 0;\n        session.lastActionTimestamp = block.timestamp;\n\n        emit NewBattle(superblockHash, submitter, challenger);\n    }\n    // 0x00 version\n    // 0x04 prev block hash\n    // 0x24 merkle root\n    // 0x44 timestamp\n    // 0x48 bits\n    // 0x4c nonce\n\n    // @dev - extract previous block field from a raw Syscoin block header\n    //\n    // @param _blockHeader - Syscoin block header bytes\n    // @param pos - where to start reading hash from\n    // @return - hash of block's parent in big endian format\n    function getHashPrevBlock(bytes memory _blockHeader, uint pos) private pure returns (uint) {\n        uint hashPrevBlock;\n        uint index = 0x04+pos;\n        assembly {\n            hashPrevBlock := mload(add(add(_blockHeader, 32), index))\n        }\n        return flip32Bytes(hashPrevBlock);\n    }\n\n\n    // @dev - extract timestamp field from a raw Syscoin block header\n    //\n    // @param _blockHeader - Syscoin block header bytes\n    // @param pos - where to start reading bits from\n    // @return - block's timestamp in big-endian format\n    function getTimestamp(bytes memory _blockHeader, uint pos) private pure returns (uint32 time) {\n        return bytesToUint32Flipped(_blockHeader, 0x44+pos);\n    }\n\n    // @dev - extract bits field from a raw Syscoin block header\n    //\n    // @param _blockHeader - Syscoin block header bytes\n    // @param pos - where to start reading bits from\n    // @return - block's difficulty in bits format, also big-endian\n    function getBits(bytes memory _blockHeader, uint pos) private pure returns (uint32 bits) {\n        return bytesToUint32Flipped(_blockHeader, 0x48+pos);\n    }\n    // @dev - converts raw bytes representation of a Syscoin block header to struct representation\n    //\n    // @param _rawBytes - first 80 bytes of a block header\n    // @return - exact same header information in BlockHeader struct form\n    function parseHeaderBytes(bytes memory _rawBytes, uint pos) private view returns (BlockHeader memory bh) {\n        bh.bits = getBits(_rawBytes, pos);\n        bh.blockHash = bytes32(dblShaFlipMem(_rawBytes, pos, 80));\n        bh.timestamp = getTimestamp(_rawBytes, pos);\n        bh.prevBlock = bytes32(getHashPrevBlock(_rawBytes, pos));\n    }\n    // Convert a variable integer into something useful and return it and\n    // the index to after it.\n    function parseVarInt(bytes memory txBytes, uint pos) private pure returns (uint, uint) {\n        // the first byte tells us how big the integer is\n        uint8 ibit = uint8(txBytes[pos]);\n        pos += 1;  // skip ibit\n\n        if (ibit < 0xfd) {\n            return (ibit, pos);\n        } else if (ibit == 0xfd) {\n            return (getBytesLE(txBytes, pos, 16), pos + 2);\n        } else if (ibit == 0xfe) {\n            return (getBytesLE(txBytes, pos, 32), pos + 4);\n        } else if (ibit == 0xff) {\n            return (getBytesLE(txBytes, pos, 64), pos + 8);\n        }\n    }\n    // convert little endian bytes to uint\n    function getBytesLE(bytes memory data, uint pos, uint bits) private pure returns (uint256 result) {\n        for (uint256 i = 0; i < bits / 8; i++) {\n            result += uint256(uint8(data[pos + i])) * 2 ** (i * 8);\n        }\n    }\n    function parseAuxPoW(bytes memory rawBytes, uint pos) private view\n             returns (AuxPoW memory auxpow)\n    {\n        bytes memory coinbaseScript;\n        uint slicePos;\n        // we need to traverse the bytes with a pointer because some fields are of variable length\n        pos += 80; // skip non-AuxPoW header\n\n        (slicePos, coinbaseScript) = getSlicePos(rawBytes, pos);\n        auxpow.txHash = dblShaFlipMem(rawBytes, pos, slicePos - pos);\n        pos = slicePos;\n        // parent block hash, skip and manually hash below\n        pos += 32;\n        (auxpow.parentMerkleProof, pos) = scanMerkleBranch(rawBytes, pos, 0);\n        auxpow.coinbaseTxIndex = getBytesLE(rawBytes, pos, 32);\n        pos += 4;\n        (auxpow.chainMerkleProof, pos) = scanMerkleBranch(rawBytes, pos, 0);\n        auxpow.syscoinHashIndex = getBytesLE(rawBytes, pos, 32);\n        pos += 4;\n        // calculate block hash instead of reading it above, as some are LE and some are BE, we cannot know endianness and have to calculate from parent block header\n        auxpow.blockHash = dblShaFlipMem(rawBytes, pos, 80);\n        pos += 36; // skip parent version and prev block\n        auxpow.parentMerkleRoot = sliceBytes32Int(rawBytes, pos);\n        pos += 40; // skip root that was just read, parent block timestamp and bits\n        auxpow.parentNonce = getBytesLE(rawBytes, pos, 32);\n        auxpow.pos = pos+4;\n        uint coinbaseMerkleRootPosition;\n        (auxpow.coinbaseMerkleRoot, coinbaseMerkleRootPosition, auxpow.coinbaseMerkleRootCode) = findCoinbaseMerkleRoot(coinbaseScript);\n    }\n   function skipOutputs(bytes memory txBytes, uint pos) private pure\n             returns (uint)\n    {\n        uint n_outputs;\n        uint script_len;\n\n        (n_outputs, pos) = parseVarInt(txBytes, pos);\n\n        require(n_outputs < 10);\n\n        for (uint i = 0; i < n_outputs; i++) {\n            pos += 8;\n            (script_len, pos) = parseVarInt(txBytes, pos);\n            pos += script_len;\n        }\n\n        return pos;\n    }\n    // get final position of inputs, outputs and lock time\n    // this is a helper function to slice a byte array and hash the inputs, outputs and lock time\n    function getSlicePos(bytes memory txBytes, uint pos) private view\n             returns (uint slicePos, bytes memory coinbaseScript)\n    {\n\n        (slicePos, coinbaseScript) = skipInputsCoinbase(txBytes, pos + 4);\n        slicePos = skipOutputs(txBytes, slicePos);\n        slicePos += 4; // skip lock time\n    }\n    // scan a Merkle branch.\n    // return array of values and the end position of the sibling hashes.\n    // takes a 'stop' argument which sets the maximum number of\n    // siblings to scan through. stop=0 => scan all.\n    function scanMerkleBranch(bytes memory txBytes, uint pos, uint stop) private pure\n             returns (uint[] memory, uint)\n    {\n        uint n_siblings;\n        uint halt;\n\n        (n_siblings, pos) = parseVarInt(txBytes, pos);\n\n        if (stop == 0 || stop > n_siblings) {\n            halt = n_siblings;\n        } else {\n            halt = stop;\n        }\n\n        uint[] memory sibling_values = new uint[](halt);\n\n        for (uint i = 0; i < halt; i++) {\n            sibling_values[i] = flip32Bytes(sliceBytes32Int(txBytes, pos));\n            pos += 32;\n        }\n\n        return (sibling_values, pos);\n    }\n\n    // Slice 32 contiguous bytes from bytes `data`, starting at `start`\n    function sliceBytes32Int(bytes memory data, uint start) private pure returns (uint slice) {\n        assembly {\n            slice := mload(add(data, add(0x20, start)))\n        }\n    }\n\n    // @dev returns a portion of a given byte array specified by its starting and ending points\n    // Breaks underscore naming convention for parameters because it raises a compiler error\n    // if `offset` is changed to `_offset`.\n    //\n    // @param _rawBytes - array to be sliced\n    // @param offset - first byte of sliced array\n    // @param _endIndex - last byte of sliced array\n    function sliceArray(bytes memory _rawBytes, uint offset, uint _endIndex) private view returns (bytes memory) {\n        uint len = _endIndex - offset;\n        bytes memory result = new bytes(len);\n        assembly {\n            // Call precompiled contract to copy data\n            if iszero(staticcall(gas, 0x04, add(add(_rawBytes, 0x20), offset), len, add(result, 0x20), len)) {\n                revert(0, 0)\n            }\n        }\n        return result;\n    }\n    function skipInputsCoinbase(bytes memory txBytes, uint pos) private view\n             returns (uint, bytes memory)\n    {\n        uint n_inputs;\n        uint script_len;\n        (n_inputs, pos) = parseVarInt(txBytes, pos);\n        // if dummy 0x00 is present this is a witness transaction\n        if(n_inputs == 0x00){\n            (n_inputs, pos) = parseVarInt(txBytes, pos); // flag\n            require(n_inputs != 0x00);\n            // after dummy/flag the real var int comes for txins\n            (n_inputs, pos) = parseVarInt(txBytes, pos);\n        }\n        require(n_inputs == 1);\n\n        pos += 36;  // skip outpoint\n        (script_len, pos) = parseVarInt(txBytes, pos);\n        bytes memory coinbaseScript;\n        coinbaseScript = sliceArray(txBytes, pos, pos+script_len);\n        pos += script_len + 4;  // skip sig_script, seq\n\n        return (pos, coinbaseScript);\n    }\n    // @dev - looks for {0xfa, 0xbe, 'm', 'm'} byte sequence\n    // returns the following 32 bytes if it appears once and only once,\n    // 0 otherwise\n    // also returns the position where the bytes first appear\n    function findCoinbaseMerkleRoot(bytes memory rawBytes) private pure\n             returns (uint, uint, uint)\n    {\n        uint position;\n        uint found = 0;\n        uint target = 0xfabe6d6d00000000000000000000000000000000000000000000000000000000;\n        uint mask = 0xffffffff00000000000000000000000000000000000000000000000000000000;\n        assembly {\n            let len := mload(rawBytes)\n            let data := add(rawBytes, 0x20)\n            let end := add(data, len)\n\n            for { } lt(data, end) { } {     // while(i < end)\n                if eq(and(mload(data), mask), target) {\n                    if eq(found, 0x0) {\n                        position := add(sub(len, sub(end, data)), 4)\n                    }\n                    found := add(found, 1)\n                }\n                data := add(data, 0x1)\n            }\n        }\n\n        if (found >= 2) {\n            return (0, position - 4, ERR_FOUND_TWICE);\n        } else if (found == 1) {\n            return (sliceBytes32Int(rawBytes, position), position - 4, 1);\n        } else { // no merge mining header\n            return (0, position - 4, ERR_NO_MERGE_HEADER);\n        }\n    }\n\n    // @dev - For a valid proof, returns the root of the Merkle tree.\n    //\n    // @param _txHash - transaction hash\n    // @param _txIndex - transaction's index within the block it's assumed to be in\n    // @param _siblings - transaction's Merkle siblings\n    // @return - Merkle tree root of the block the transaction belongs to if the proof is valid,\n    // garbage if it's invalid\n    function computeMerkle(uint _txHash, uint _txIndex, uint[] memory _siblings) private pure returns (uint) {\n        \n        uint length = _siblings.length;\n        uint i;\n        for (i = 0; i < length; i++) {\n            _siblings[i] = flip32Bytes(_siblings[i]);\n        }\n\n        i = 0;\n        uint resultHash = flip32Bytes(_txHash);        \n\n        while (i < length) {\n            uint proofHex = _siblings[i];\n\n            uint left;\n            uint right;\n            if (_txIndex % 2 == 1) { // 0 means _siblings is on the right; 1 means left\n                left = proofHex;\n                right = resultHash;\n            } else {\n                left = resultHash;\n                right = proofHex;\n            }\n            resultHash = uint(sha256(abi.encodePacked(sha256(abi.encodePacked(left, right)))));\n\n            _txIndex /= 2;\n            i += 1;\n        }\n\n        return flip32Bytes(resultHash);\n    }\n\n    // @dev - convert an unsigned integer from little-endian to big-endian representation\n    //\n    // @param _input - little-endian value\n    // @return - input value in big-endian format\n    function flip32Bytes(uint _input) private pure returns (uint result) {\n        assembly {\n            let pos := mload(0x40)\n            mstore8(add(pos, 0), byte(31, _input))\n            mstore8(add(pos, 1), byte(30, _input))\n            mstore8(add(pos, 2), byte(29, _input))\n            mstore8(add(pos, 3), byte(28, _input))\n            mstore8(add(pos, 4), byte(27, _input))\n            mstore8(add(pos, 5), byte(26, _input))\n            mstore8(add(pos, 6), byte(25, _input))\n            mstore8(add(pos, 7), byte(24, _input))\n            mstore8(add(pos, 8), byte(23, _input))\n            mstore8(add(pos, 9), byte(22, _input))\n            mstore8(add(pos, 10), byte(21, _input))\n            mstore8(add(pos, 11), byte(20, _input))\n            mstore8(add(pos, 12), byte(19, _input))\n            mstore8(add(pos, 13), byte(18, _input))\n            mstore8(add(pos, 14), byte(17, _input))\n            mstore8(add(pos, 15), byte(16, _input))\n            mstore8(add(pos, 16), byte(15, _input))\n            mstore8(add(pos, 17), byte(14, _input))\n            mstore8(add(pos, 18), byte(13, _input))\n            mstore8(add(pos, 19), byte(12, _input))\n            mstore8(add(pos, 20), byte(11, _input))\n            mstore8(add(pos, 21), byte(10, _input))\n            mstore8(add(pos, 22), byte(9, _input))\n            mstore8(add(pos, 23), byte(8, _input))\n            mstore8(add(pos, 24), byte(7, _input))\n            mstore8(add(pos, 25), byte(6, _input))\n            mstore8(add(pos, 26), byte(5, _input))\n            mstore8(add(pos, 27), byte(4, _input))\n            mstore8(add(pos, 28), byte(3, _input))\n            mstore8(add(pos, 29), byte(2, _input))\n            mstore8(add(pos, 30), byte(1, _input))\n            mstore8(add(pos, 31), byte(0, _input))\n            result := mload(pos)\n        }\n    }\n    // @dev - calculates the Merkle root of a tree containing Bitcoin transactions\n    // in order to prove that `ap`'s coinbase tx is in that Bitcoin block.\n    //\n    // @param _ap - AuxPoW information\n    // @return - Merkle root of Bitcoin block that the Syscoin block\n    // with this info was mined in if AuxPoW Merkle proof is correct,\n    // garbage otherwise\n    function computeParentMerkle(AuxPoW memory _ap) private pure returns (uint) {\n        return flip32Bytes(computeMerkle(_ap.txHash,\n                                         _ap.coinbaseTxIndex,\n                                         _ap.parentMerkleProof));\n    }\n\n    // @dev - calculates the Merkle root of a tree containing auxiliary block hashes\n    // in order to prove that the Syscoin block identified by _blockHash\n    // was merge-mined in a Bitcoin block.\n    //\n    // @param _blockHash - SHA-256 hash of a certain Syscoin block\n    // @param _ap - AuxPoW information corresponding to said block\n    // @return - Merkle root of auxiliary chain tree\n    // if AuxPoW Merkle proof is correct, garbage otherwise\n    function computeChainMerkle(uint _blockHash, AuxPoW memory _ap) private pure returns (uint) {\n        return computeMerkle(_blockHash,\n                             _ap.syscoinHashIndex,\n                             _ap.chainMerkleProof);\n    }    \n\n    // @dev - checks if a merge-mined block's Merkle proofs are correct,\n    // i.e. Syscoin block hash is in coinbase Merkle tree\n    // and coinbase transaction is in parent Merkle tree.\n    //\n    // @param _blockHash - SHA-256 hash of the block whose Merkle proofs are being checked\n    // @param _ap - AuxPoW struct corresponding to the block\n    // @return 1 if block was merge-mined and coinbase index, chain Merkle root and Merkle proofs are correct,\n    // respective error code otherwise\n    function checkAuxPoW(uint _blockHash, AuxPoW memory _ap) private pure returns (uint) {\n        if (_ap.coinbaseTxIndex != 0) {\n            return ERR_COINBASE_INDEX;\n        }\n\n        if (_ap.coinbaseMerkleRootCode != 1) {\n            return _ap.coinbaseMerkleRootCode;\n        }\n\n        if (computeChainMerkle(_blockHash, _ap) != _ap.coinbaseMerkleRoot) {\n            return ERR_CHAIN_MERKLE;\n        }\n\n        if (computeParentMerkle(_ap) != _ap.parentMerkleRoot) {\n            return ERR_PARENT_MERKLE;\n        }\n\n        return 1;\n    }\n\n    function sha256mem(bytes memory _rawBytes, uint offset, uint len) private view returns (bytes32 result) {\n        assembly {\n            // Call sha256 precompiled contract (located in address 0x02) to copy data.\n            // Assign to ptr the next available memory position (stored in memory position 0x40).\n            let ptr := mload(0x40)\n            if iszero(staticcall(gas, 0x02, add(add(_rawBytes, 0x20), offset), len, ptr, 0x20)) {\n                revert(0, 0)\n            }\n            result := mload(ptr)\n        }\n    }\n\n    // @dev - Bitcoin-way of hashing\n    // @param _dataBytes - raw data to be hashed\n    // @return - result of applying SHA-256 twice to raw data and then flipping the bytes\n    function dblShaFlip(bytes memory _dataBytes) private pure returns (uint) {\n        return flip32Bytes(uint(sha256(abi.encodePacked(sha256(abi.encodePacked(_dataBytes))))));\n    }\n\n    // @dev - Bitcoin-way of hashing\n    // @param _dataBytes - raw data to be hashed\n    // @return - result of applying SHA-256 twice to raw data and then flipping the bytes\n    function dblShaFlipMem(bytes memory _rawBytes, uint offset, uint len) private view returns (uint) {\n        return flip32Bytes(uint(sha256(abi.encodePacked(sha256mem(_rawBytes, offset, len)))));\n    }\n\n    // @dev - Bitcoin-way of computing the target from the 'bits' field of a block header\n    // based on http://www.righto.com/2014/02/bitcoin-mining-hard-way-algorithms.html//ref3\n    //\n    // @param _bits - difficulty in bits format\n    // @return - difficulty in target format\n    function targetFromBits(uint32 _bits) private pure returns (uint) {\n        uint exp = _bits / 0x1000000;  // 2**24\n        uint mant = _bits & 0xffffff;\n        return mant * 256**(exp - 3);\n    }\n    \n    // @param _actualTimespan - time elapsed from previous block creation til current block creation;\n    // i.e., how much time it took to mine the current block\n    // @param _bits - previous block header difficulty (in bits)\n    // @return - expected difficulty for the next block\n    function calculateDifficulty(uint _actualTimespan, uint32 _bits) private pure returns (uint32 result) {\n        uint actualTimespan = _actualTimespan;\n        // Limit adjustment step\n        if (actualTimespan < TARGET_TIMESPAN_MIN) {\n            actualTimespan = TARGET_TIMESPAN_MIN;\n        } else if (actualTimespan > TARGET_TIMESPAN_MAX) {\n            actualTimespan = TARGET_TIMESPAN_MAX;\n        }\n\n        // Retarget\n        uint bnNew = targetFromBits(_bits);\n        bnNew = bnNew * actualTimespan;\n        bnNew = bnNew / TARGET_TIMESPAN;\n\n        if (bnNew > POW_LIMIT) {\n            bnNew = POW_LIMIT;\n        }\n\n        return toCompactBits(bnNew);\n    }\n\n    // @dev - shift information to the right by a specified number of bits\n    //\n    // @param _val - value to be shifted\n    // @param _shift - number of bits to shift\n    // @return - `_val` shifted `_shift` bits to the right, i.e. divided by 2**`_shift`\n    function shiftRight(uint _val, uint _shift) private pure returns (uint) {\n        return _val / uint(2)**_shift;\n    }\n\n    // @dev - shift information to the left by a specified number of bits\n    //\n    // @param _val - value to be shifted\n    // @param _shift - number of bits to shift\n    // @return - `_val` shifted `_shift` bits to the left, i.e. multiplied by 2**`_shift`\n    function shiftLeft(uint _val, uint _shift) private pure returns (uint) {\n        return _val * uint(2)**_shift;\n    }\n\n    // @dev - get the number of bits required to represent a given integer value without losing information\n    //\n    // @param _val - unsigned integer value\n    // @return - given value's bit length\n    function bitLen(uint _val) private pure returns (uint length) {\n        uint int_type = _val;\n        while (int_type > 0) {\n            int_type = shiftRight(int_type, 1);\n            length += 1;\n        }\n    }\n\n    // @dev - Convert uint256 to compact encoding\n    // based on https://github.com/petertodd/python-bitcoinlib/blob/2a5dda45b557515fb12a0a18e5dd48d2f5cd13c2/bitcoin/core/serialize.py\n    // Analogous to arith_uint256::GetCompact from C++ implementation\n    //\n    // @param _val - difficulty in target format\n    // @return - difficulty in bits format\n    function toCompactBits(uint _val) private pure returns (uint32) {\n        uint nbytes = uint (shiftRight((bitLen(_val) + 7), 3));\n        uint32 compact = 0;\n        if (nbytes <= 3) {\n            compact = uint32 (shiftLeft((_val & 0xFFFFFF), 8 * (3 - nbytes)));\n        } else {\n            compact = uint32 (shiftRight(_val, 8 * (nbytes - 3)));\n            compact = uint32 (compact & 0xFFFFFF);\n        }\n\n        // If the sign bit (0x00800000) is set, divide the mantissa by 256 and\n        // increase the exponent to get an encoding without it set.\n        if ((compact & 0x00800000) > 0) {\n            compact = uint32(shiftRight(compact, 8));\n            nbytes += 1;\n        }\n\n        return compact | uint32(shiftLeft(nbytes, 24));\n    }\n    // @dev - Verify block headers sent by challenger\n    function doRespondBlockHeaders(\n        BattleSession storage session,\n        SyscoinSuperblocksI.SuperblockInfo memory superblockInfo,\n        bytes32 merkleRoot,\n        BlockHeader memory lastHeader\n    ) private returns (uint) {\n        if (session.merkleRoots.length == 3 || net == Network.REGTEST) {\n            bytes32[] memory merkleRoots = new bytes32[](net != Network.REGTEST ? 4 : 1);\n            uint i;\n            for (i = 0; i < session.merkleRoots.length; i++) {\n                merkleRoots[i] = session.merkleRoots[i];\n            }\n            merkleRoots[i] = merkleRoot;\n            if (superblockInfo.blocksMerkleRoot != makeMerkle(merkleRoots)) {\n                return ERR_SUPERBLOCK_INVALID_MERKLE;\n            }\n\n            // if you have the last set of headers we can enfoce checks against the end\n            // ensure the last block's timestamp matches the superblock's proposed timestamp\n            if (superblockInfo.timestamp != lastHeader.timestamp) {\n                return ERR_SUPERBLOCK_INVALID_TIMESTAMP;\n            }\n            // ensure last headers hash matches the last hash of the superblock\n            if (lastHeader.blockHash != superblockInfo.lastHash) {\n                return ERR_SUPERBLOCK_HASH_SUPERBLOCK;\n            }\n        } else {\n            session.merkleRoots.push(merkleRoot);\n        }\n\n        return ERR_SUPERBLOCK_OK;\n    }\n\n    function respondBlockHeaders (\n        bytes32 superblockHash,\n        bytes memory blockHeaders,\n        uint numHeaders\n    ) public {\n        BattleSession storage session = sessions[superblockHash];\n        address submitter = session.submitter;\n\n        require(msg.sender == submitter);\n\n        uint merkleRootsLen = session.merkleRoots.length;\n\n        if (net != Network.REGTEST) {\n            if ((merkleRootsLen <= 2 && numHeaders != 16) || (merkleRootsLen == 3 && numHeaders != 12)) {\n                revert();\n            }\n        }\n\n        SyscoinSuperblocksI.SuperblockInfo memory superblockInfo;\n        (superblockInfo.blocksMerkleRoot, superblockInfo.timestamp,superblockInfo.mtpTimestamp,superblockInfo.lastHash,superblockInfo.lastBits,superblockInfo.parentId,,,superblockInfo.height) =\n            trustedSuperblocks.getSuperblock(superblockHash);\n\n        uint pos = 0;\n        bytes32[] memory blockHashes = new bytes32[](numHeaders);\n        BlockHeader[] memory parsedBlockHeaders = new BlockHeader[](numHeaders);\n\n        uint err = ERR_SUPERBLOCK_OK;\n\n        for (uint i = 0; i < parsedBlockHeaders.length; i++){\n            parsedBlockHeaders[i] = parseHeaderBytes(blockHeaders, pos);\n            uint target = targetFromBits(parsedBlockHeaders[i].bits);\n\n            if (isMergeMined(blockHeaders, pos)) {\n                AuxPoW memory ap = parseAuxPoW(blockHeaders, pos);\n                if (ap.blockHash > target) {\n                    err = ERR_PROOF_OF_WORK_AUXPOW;\n                    break;\n                }\n\n                uint auxPoWCode = checkAuxPoW(uint(parsedBlockHeaders[i].blockHash), ap);\n                if (auxPoWCode != 1) {\n                    err = auxPoWCode;\n                    break;\n                }\n\n                pos = ap.pos;\n            } else {\n                if (uint(parsedBlockHeaders[i].blockHash) > target) {\n                    err = ERR_PROOF_OF_WORK;\n                    break;\n                }\n\n                pos = pos+80;\n            }\n\n            blockHashes[i] = parsedBlockHeaders[i].blockHash;\n        }\n\n        if (err != ERR_SUPERBLOCK_OK) {\n            convictSubmitter(superblockHash, submitter, session.challenger, err);\n            return;\n        }\n\n        err = doRespondBlockHeaders(\n            session,\n            superblockInfo,\n            makeMerkle(blockHashes),\n            parsedBlockHeaders[parsedBlockHeaders.length-1]\n        );\n        if (err != ERR_SUPERBLOCK_OK) {\n            convictSubmitter(superblockHash, submitter, session.challenger, err);\n        } else {\n            session.lastActionTimestamp = block.timestamp;\n            err = validateHeaders(session, superblockInfo, parsedBlockHeaders);\n            if (err != ERR_SUPERBLOCK_OK) {\n                convictSubmitter(superblockHash, submitter, session.challenger, err);\n                return;\n            }\n            // only convict challenger at the end if all headers have been provided\n            if(numHeaders == 12 || net == Network.REGTEST){\n                convictChallenger(superblockHash, submitter, session.challenger, err);\n                return;\n            }\n            emit RespondBlockHeaders(superblockHash, merkleRootsLen + 1, submitter);\n        }\n    }\n    // @dev - Converts a bytes of size 4 to uint32,\n    // e.g. for input [0x01, 0x02, 0x03 0x04] returns 0x01020304\n    function bytesToUint32Flipped(bytes memory input, uint pos) private pure returns (uint32 result) {\n        assembly {\n            let data := mload(add(add(input, 0x20), pos))\n            let flip := mload(0x40)\n            mstore8(add(flip, 0), byte(3, data))\n            mstore8(add(flip, 1), byte(2, data))\n            mstore8(add(flip, 2), byte(1, data))\n            mstore8(add(flip, 3), byte(0, data))\n            result := shr(mul(8, 28), mload(flip))\n        }\n    }\n    uint32 constant VERSION_AUXPOW = (1 << 8);\n    // @dev - checks version to determine if a block has merge mining information\n    function isMergeMined(bytes memory _rawBytes, uint pos) private pure returns (bool) {\n        return bytesToUint32Flipped(_rawBytes, pos) & VERSION_AUXPOW != 0;\n    }\n    \n    // @dev - Evaluate the merkle root\n    //\n    // Given an array of hashes it calculates the\n    // root of the merkle tree.\n    //\n    // @return root of merkle tree\n    function makeMerkle(bytes32[] memory hashes) private pure returns (bytes32) {\n        uint length = hashes.length;\n\n        if (length == 1) return hashes[0];\n        require(length > 0, \"Must provide hashes\");\n\n        uint i;\n        for (i = 0; i < length; i++) {\n            hashes[i] = bytes32(flip32Bytes(uint(hashes[i])));\n        }\n\n        uint j;\n        uint k;\n\n        while (length > 1) {\n            k = 0;\n            for (i = 0; i < length; i += 2) {\n                j = (i + 1 < length) ? i + 1 : length - 1;\n                hashes[k] = sha256(abi.encodePacked(sha256(abi.encodePacked(hashes[i], hashes[j]))));\n                k += 1;\n            }\n            length = k;\n        }\n        return bytes32(flip32Bytes(uint(hashes[0])));\n    }\n\n    // @dev - Validate prev bits, prev hash of block header\n    function checkBlocks(BattleSession storage session, BlockHeader[] memory blockHeadersParsed, uint32 prevBits) private view returns (uint) {\n        for(uint i = blockHeadersParsed.length-1;i>0;i--){\n            BlockHeader memory thisHeader = blockHeadersParsed[i];\n            BlockHeader memory prevHeader = blockHeadersParsed[i-1];\n            // except for the last header except all the bits to match\n            // last chunk has 12 headers which is the only time we care to skip the last header\n            if (blockHeadersParsed.length != 12 || i < (blockHeadersParsed.length-1)){\n                if (prevBits != thisHeader.bits)\n                    return ERR_SUPERBLOCK_BITS_PREVBLOCK;\n            }\n            if(prevHeader.blockHash != thisHeader.prevBlock)\n                return ERR_SUPERBLOCK_HASH_PREVBLOCK;\n        }\n\n        if (prevBits != blockHeadersParsed[0].bits) {\n            return ERR_SUPERBLOCK_BITS_PREVBLOCK;\n        }\n\n        // enforce linking against previous submitted batch of blocks\n        if (session.merkleRoots.length >= 2) {\n            if (session.prevSubmitBlockhash != blockHeadersParsed[0].prevBlock)\n                return ERR_SUPERBLOCK_HASH_INTERIM_PREVBLOCK;\n        }\n        return ERR_SUPERBLOCK_OK;\n    }\n    function sort_array(uint[11] memory arr) private pure {\n        for(uint i = 0; i < 11; i++) {\n            for(uint j = i+1; j < 11 ;j++) {\n                if(arr[i] > arr[j]) {\n                    uint temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n    }\n\n    // @dev - Gets the median timestamp of the last 11 blocks\n    function getMedianTimestamp(BlockHeader[] memory blockHeadersParsed) private pure returns (uint){\n        uint[11] memory timestamps;\n        // timestamps 0->10 = blockHeadersParsed 1->11\n        for(uint i=0;i<11;i++){\n            timestamps[i] = blockHeadersParsed[i+1].timestamp;\n        }\n        sort_array(timestamps);\n        return timestamps[5];\n    }\n    // @dev - Validate superblock accumulated work + other block header fields\n    function validateHeaders(BattleSession storage session, SyscoinSuperblocksI.SuperblockInfo memory superblockInfo, BlockHeader[] memory blockHeadersParsed) private returns (uint) {\n        SyscoinSuperblocksI.SuperblockInfo memory prevSuperblockInfo;\n        BlockHeader memory lastHeader = blockHeadersParsed[blockHeadersParsed.length-1];\n        (,,prevSuperblockInfo.mtpTimestamp,prevSuperblockInfo.lastHash,prevSuperblockInfo.lastBits,,,,) =\n            trustedSuperblocks.getSuperblock(superblockInfo.parentId);\n        // for blocks 0 -> 16 we can check the first header\n        if(session.merkleRoots.length <= 1){\n            // ensure first headers prev block matches the last hash of the prev superblock\n            if(blockHeadersParsed[0].prevBlock != prevSuperblockInfo.lastHash)\n                return ERR_SUPERBLOCK_HASH_PREVSUPERBLOCK;\n\n        }\n        // make sure all bits are the same and timestamps are within range as well as headers are all linked\n        uint err = checkBlocks(session, blockHeadersParsed, prevSuperblockInfo.lastBits);\n        if(err != ERR_SUPERBLOCK_OK)\n            return err;\n        // for every batch of blocks up to the last one (at superblockDuration blocks we have all the headers so we can complete the game)\n        if(blockHeadersParsed.length != 12){\n            // set the last block header details in the session for subsequent batch of blocks to validate it connects to this header\n            session.prevSubmitBlockhash = lastHeader.blockHash;\n        }\n        // once all the headers are received we can check merkle and enforce difficulty\n        else{\n            uint mtpTimestamp = getMedianTimestamp(blockHeadersParsed);\n\n            // make sure calculated MTP is same as superblock MTP\n            if(mtpTimestamp != superblockInfo.mtpTimestamp)\n                 return ERR_SUPERBLOCK_MISMATCH_TIMESTAMP_MTP;\n\n            // ensure MTP of this SB is > than last SB MTP\n            if(mtpTimestamp <= prevSuperblockInfo.mtpTimestamp)\n                return ERR_SUPERBLOCK_TOOSMALL_TIMESTAMP_MTP;\n\n\n            // make sure every 6th superblock adjusts difficulty\n            // calculate the new work from prevBits minus one as if its an adjustment we need to account for new bits, if not then just add one more prevBits work\n            if (net != Network.REGTEST) {\n                if (((superblockInfo.height-1) % 6) == 0) {\n                    BlockHeader memory prevToLastHeader = blockHeadersParsed[blockHeadersParsed.length-2];\n\n                    // ie: superblockHeight = 7 meaning blocks 661->720, we need to check timestamp from block 719 - to block 360\n                    // get 6 superblocks previous for second timestamp (for example block 360 has the timetamp 6 superblocks ago on second adjustment)\n                    superblockInfo.timestamp = trustedSuperblocks.getSuperblockTimestamp(trustedSuperblocks.getSuperblockAt(superblockInfo.height - 6));\n                    uint32 newBits = calculateDifficulty(prevToLastHeader.timestamp - superblockInfo.timestamp, prevSuperblockInfo.lastBits);\n\n                    // ensure bits of superblock match derived bits from calculateDifficulty\n                    if (superblockInfo.lastBits != newBits) {\n                        return ERR_SUPERBLOCK_BITS_SUPERBLOCK;\n                    }\n                } else {\n                    if (superblockInfo.lastBits != prevSuperblockInfo.lastBits) {\n                        return ERR_SUPERBLOCK_BITS_LASTBLOCK;\n                    }\n                }\n\n                // make sure superblock bits match that of the last block\n                if (superblockInfo.lastBits != lastHeader.bits)\n                    return ERR_SUPERBLOCK_BITS_LASTBLOCK;\n            }\n        }\n\n        return ERR_SUPERBLOCK_OK;\n    }\n\n\n    // @dev - Trigger conviction if response is not received in time\n    function timeout(bytes32 superblockHash) external returns (uint) {\n        BattleSession storage session = sessions[superblockHash];\n        require(session.submitter != address(0));\n\n        if (block.timestamp > session.lastActionTimestamp + superblockTimeout) {\n            convictSubmitter(superblockHash, session.submitter, session.challenger, ERR_SUPERBLOCK_TIMEOUT);\n            trustedSyscoinClaimManager.checkClaimFinished(superblockHash);\n            return ERR_SUPERBLOCK_TIMEOUT;\n        }\n        return ERR_SUPERBLOCK_NO_TIMEOUT;\n    }\n\n    // @dev - To be called when a challenger is convicted\n    function convictChallenger(bytes32 superblockHash, address submitter, address challenger, uint err) private {\n        trustedSyscoinClaimManager.sessionDecided(superblockHash, submitter, challenger);\n        emit ChallengerConvicted(superblockHash, err, challenger);\n        disable(superblockHash);\n    }\n\n    // @dev - To be called when a submitter is convicted\n    function convictSubmitter(bytes32 superblockHash, address submitter, address challenger, uint err) private {\n        trustedSyscoinClaimManager.sessionDecided(superblockHash, challenger, submitter);\n        emit SubmitterConvicted(superblockHash, err, submitter);\n        disable(superblockHash);\n    }\n\n    // @dev - Disable session\n    // It should be called only when either the submitter or the challenger were convicted.\n    function disable(bytes32 superblockHash) private {\n        delete sessions[superblockHash];\n    }\n\n    // @dev - Check if a session's submitter did not respond before timeout\n    function getSubmitterHitTimeout(bytes32 superblockHash) external view returns (bool) {\n        BattleSession storage session = sessions[superblockHash];\n        return (block.timestamp > session.lastActionTimestamp + superblockTimeout);\n    }\n    function getNumMerkleHashesBySession(bytes32 superblockHash) external view returns (uint) {\n        BattleSession memory session = sessions[superblockHash];\n        if (session.submitter == address(0))\n            return 0;\n        return sessions[superblockHash].merkleRoots.length;\n    }\n    function sessionExists(bytes32 superblockHash) external view returns (bool) {\n        return sessions[superblockHash].submitter != address(0);\n    }\n}\n","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"err\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"}],\"name\":\"ChallengerConvicted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"}],\"name\":\"NewBattle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"merkleHashCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"}],\"name\":\"RespondBlockHeaders\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"err\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"}],\"name\":\"SubmitterConvicted\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"}],\"name\":\"beginBattleSession\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getNumMerkleHashesBySession\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getSubmitterHitTimeout\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum SyscoinBattleManager.Network\",\"name\":\"_network\",\"type\":\"uint8\"},{\"internalType\":\"contract SyscoinSuperblocksI\",\"name\":\"_superblocks\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_superblockDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_superblockTimeout\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minProposalDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"blockHeaders\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"numHeaders\",\"type\":\"uint256\"}],\"name\":\"respondBlockHeaders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"sessionExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract SyscoinClaimManagerI\",\"name\":\"_syscoinClaimManager\",\"type\":\"address\"}],\"name\":\"setSyscoinClaimManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superblockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superblockTimeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"timeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SyscoinBattleManager","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://a8e8b2d804696ad723930e9fcae3ed2b1026cbed146420d68a90369600c24af0"}]}