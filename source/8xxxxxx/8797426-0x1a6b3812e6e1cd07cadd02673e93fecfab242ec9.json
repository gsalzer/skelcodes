{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/common/upgradeability/Delegatable.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n/// @title Delegatable\r\n/// @notice Implements delegation of calls to other contracts, with proper\r\n/// \tforwarding of return values and bubbling of failures.\r\ncontract Delegatable {\r\n\r\n    /// @dev Delegates execution to an implementation contract.\r\n    /// \tThis is a low level function that doesn't return to its internal call site.\r\n    /// \tIt will return to the external caller whatever the implementation returns.\r\n    /// @param implementation Address to delegate.\r\n    function _delegate(address implementation) internal {\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize)\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize)\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize) }\r\n            default { return(0, returndatasize) }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/upgradeability/Proxy.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n/// @title Proxy\r\n/// @notice Implements delegation of calls to other contracts, with proper\r\n/// \tforwarding of return values and bubbling of failures.\r\n/// \tIt defines a fallback function that delegates all calls to the address\r\n/// \treturned by the abstract _implementation() internal function.\r\ncontract Proxy is Delegatable {\r\n\r\n    /// @notice Fallback function.\r\n    /// Implemented entirely in `_fallback`.\r\n    function () external payable {\r\n        _fallback();\r\n    }\r\n\r\n    /// @return The Address of the implementation.\r\n    function _implementation() internal view returns (address);\r\n\r\n    /// @dev Function that is run as the first thing in the fallback function.\r\n    /// \tCan be redefined in derived contracts to add functionality.\r\n    /// \tRedefinitions must call super._willFallback().\r\n    function _willFallback() internal {\r\n    }\r\n\r\n    /// @dev fallback implementation.\r\n    /// \tExtracted to enable manual triggering.\r\n    function _fallback() internal {\r\n        _willFallback();\r\n        _delegate(_implementation());\r\n    }\r\n}\r\n\r\n// File: contracts/libs/Address.sol\r\n\r\npragma solidity ^0.4.25;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n *\r\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\r\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\r\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\r\n * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\r\n */\r\nlibrary LaborxAddressLib {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/common/upgradeability/BaseUpgradeabilityProxy.sol\r\n\r\n/**\r\n * Copyright 2017–2019, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n\r\n/// @title BaseUpgradeabilityProxy\r\n/// @notice This contract implements a proxy that allows to change the\r\n/// implementation address to which it will delegate.\r\n/// Such a change is called an implementation upgrade.\r\ncontract BaseUpgradeabilityProxy is Proxy {\r\n\r\n    /// @dev Emitted when the implementation is upgraded.\r\n    /// @param implementation Address of the new implementation.\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /// @dev Storage slot with the address of the current implementation.\r\n    /// This is the keccak-256 hash of \"io.laborx.proxy.implementation\", and is\r\n    /// validated in the constructor.\r\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x00dce392765b11486902ac3a76afbfed3e68464872bbbc647d8773854f05fedb;\r\n\r\n    /// @dev Returns the current implementation.\r\n    /// @return Address of the current implementation\r\n    function _implementation() internal view returns (address impl) {\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n\r\n    /// @dev Upgrades the proxy to a new implementation.\r\n    /// @param newImplementation Address of the new implementation.\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /// @dev Sets the implementation address of the proxy.\r\n    /// @param newImplementation Address of the new implementation.\r\n    function _setImplementation(address newImplementation) internal {\r\n        require(LaborxAddressLib.isContract(newImplementation), \"PROXY_CANNOT_SET_NON_CONTRACT\");\r\n\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            sstore(slot, newImplementation)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/upgradeability/UpgradeabilityProxy.sol\r\n\r\n/**\r\n* Copyright 2017–2019, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n/// @title UpgradeabilityProxy\r\n/// @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\r\n///     implementation and init data.\r\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n\r\n    /// @dev Contract constructor.\r\n    /// @param _logic Address of the initial implementation.\r\n    /// @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n    ///\r\n    /// It should include the signature and the parameters of the function to be called, as described in\r\n    /// https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n    /// This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n    constructor(address _logic, bytes memory _data) public payable {\r\n        assert(IMPLEMENTATION_SLOT == keccak256(\"io.laborx.proxy.implementation\"));\r\n\r\n        _setImplementation(_logic);\r\n\r\n        if (_data.length > 0) {\r\n            (bool success,) = _logic.delegatecall(_data);\r\n            require(success, \"PROXY_INIT_FAILED\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/upgradeability/OwnedUpgradeabilityProxy.sol\r\n\r\n/**\r\n* Copyright 2017–2019, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n/// @title OwnedUpgradeabilityProxy\r\n/// @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n\r\n    /// @dev Event to show ownership has been transferred\r\n    /// @param previousOwner representing the address of the previous owner\r\n    /// @param newOwner representing the address of the new owner\r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    /// @dev Storage slot of the owner of the contract\r\n    /// This is the keccak-256 hash of \"io.laborx.proxy.implementation\"\r\n    bytes32 private constant PROXY_OWNER_SLOT = 0x9f0cb10b07044a26ed5e46aa863117e6277a419ad770761a6659221f518998bd;\r\n\r\n    /// @dev the constructor sets the original owner of the contract to the sender account.\r\n    constructor(address _logic, bytes memory _data) public UpgradeabilityProxy(_logic, _data) {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner(), \"PROXY_OWNER_ONLY\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Tells the address of the owner\r\n    /// @return the address of the owner\r\n    function proxyOwner() public view returns (address owner) {\r\n        bytes32 slot = PROXY_OWNER_SLOT;\r\n        assembly {\r\n            owner := sload(slot)\r\n        }\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferProxyOwnership(address newOwner) external onlyProxyOwner {\r\n        require(newOwner != address(0), \"PROXY_INVALID_NEW_OWNER\");\r\n        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\r\n        _setUpgradeabilityOwner(newOwner);\r\n    }\r\n\r\n    /// @notice Allows the proxy owner to upgrade the current version of the proxy.\r\n    /// @param implementation representing the address of the new implementation to be set.\r\n    function upgradeTo(address implementation) public onlyProxyOwner {\r\n        _upgradeTo(implementation);\r\n    }\r\n\r\n    /// @notice Allows the proxy owner to upgrade the current version of the proxy and call the new implementation\r\n    ///     to initialize whatever is needed through a low level call.\r\n    /// @param implementation representing the address of the new implementation to be set.\r\n    /// @param data represents the msg.data to bet sent in the low level call. This parameter may include the function\r\n    ///     signature of the implementation to be called with the needed payload\r\n    function upgradeToAndCall(address implementation, bytes data) external payable onlyProxyOwner {\r\n        upgradeTo(implementation);\r\n        require(this.call.value(msg.value)(data), \"PROXY_FAILED_CALL\");\r\n    }\r\n\r\n    /// @dev Sets the address of the owner\r\n    function _setUpgradeabilityOwner(address newProxyOwner) internal {\r\n        bytes32 slot = PROXY_OWNER_SLOT;\r\n        assembly {\r\n            sstore(slot, newProxyOwner)\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"proxyOwner\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"implementation\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferProxyOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_logic\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ProxyOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"}]","ContractName":"OwnedUpgradeabilityProxy","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e0805fee7fa1e2334072378d2d5c1c5986058d5a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000642f1636e0000000000000000000000000ed232ca37621cec3344f1a7b4d733c70d6c45f6c0000000000000000000000007d9a27dbba3619c1d8b42f22fdf28edb85bf744c4c61626f72436f6e74726163745f76325f325f70726f6400000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"GNU LGPLv3","SwarmSource":"bzzr://0afd0fc4e3ea40fa42ea9072659a7e73c52ec8e0b1cf1646b9c250bc6b5e54cb"}]}