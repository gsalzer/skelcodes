{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\n\n/**\n * @title Interface that every module contract should implement\n */\ninterface IModule {\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() external pure returns(bytes4 initFunction);\n\n    /**\n     * @notice Return the permission flags that are associated with a module\n     */\n    function getPermissions() external view returns(bytes32[] memory permissions);\n\n}\n\n/**\n * @title Utility contract to allow pausing and unpausing of certain functions\n */\ncontract Pausable {\n    event Pause(address account);\n    event Unpause(address account);\n\n    bool public paused = false;\n\n    /**\n    * @notice Modifier to make a function callable only when the contract is not paused.\n    */\n    modifier whenNotPaused() {\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n\n    /**\n    * @notice Modifier to make a function callable only when the contract is paused.\n    */\n    modifier whenPaused() {\n        require(paused, \"Contract is not paused\");\n        _;\n    }\n\n    /**\n    * @notice Called by the owner to pause, triggers stopped state\n    */\n    function _pause() internal whenNotPaused {\n        paused = true;\n        /*solium-disable-next-line security/no-block-members*/\n        emit Pause(msg.sender);\n    }\n\n    /**\n    * @notice Called by the owner to unpause, returns to normal state\n    */\n    function _unpause() internal whenPaused {\n        paused = false;\n        /*solium-disable-next-line security/no-block-members*/\n        emit Unpause(msg.sender);\n    }\n\n}\n\n/**\n * @title Interface that every module factory contract should implement\n */\ninterface IModuleFactory {\n    event ChangeSetupCost(uint256 _oldSetupCost, uint256 _newSetupCost);\n    event ChangeCostType(bool _isOldCostInPoly, bool _isNewCostInPoly);\n    event GenerateModuleFromFactory(\n        address _module,\n        bytes32 indexed _moduleName,\n        address indexed _moduleFactory,\n        address _creator,\n        uint256 _setupCost,\n        uint256 _setupCostInPoly\n    );\n    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);\n\n    //Should create an instance of the Module, or throw\n    function deploy(bytes calldata _data) external returns(address moduleAddress);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function version() external view returns(string memory moduleVersion);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function name() external view returns(bytes32 moduleName);\n\n    /**\n     * @notice Returns the title associated with the module\n     */\n    function title() external view returns(string memory moduleTitle);\n\n    /**\n     * @notice Returns the description associated with the module\n     */\n    function description() external view returns(string memory moduleDescription);\n\n    /**\n     * @notice Get the setup cost of the module in USD\n     */\n    function setupCost() external returns(uint256 usdSetupCost);\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external view returns(uint8[] memory moduleTypes);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external view returns(bytes32[] memory moduleTags);\n\n    /**\n     * @notice Used to change the setup fee\n     * @param _newSetupCost New setup fee\n     */\n    function changeSetupCost(uint256 _newSetupCost) external;\n\n    /**\n     * @notice Used to change the currency and amount setup cost\n     * @param _setupCost new setup cost\n     * @param _isCostInPoly new setup cost currency. USD or POLY\n     */\n    function changeCostAndType(uint256 _setupCost, bool _isCostInPoly) external;\n\n    /**\n     * @notice Function use to change the lower and upper bound of the compatible version st\n     * @param _boundType Type of bound\n     * @param _newVersion New version array\n     */\n    function changeSTVersionBounds(string calldata _boundType, uint8[] calldata _newVersion) external;\n\n    /**\n     * @notice Get the setup cost of the module\n     */\n    function setupCostInPoly() external returns (uint256 polySetupCost);\n\n    /**\n     * @notice Used to get the lower bound\n     * @return Lower bound\n     */\n    function getLowerSTVersionBounds() external view returns(uint8[] memory lowerBounds);\n\n    /**\n     * @notice Used to get the upper bound\n     * @return Upper bound\n     */\n    function getUpperSTVersionBounds() external view returns(uint8[] memory upperBounds);\n\n    /**\n     * @notice Updates the tags of the ModuleFactory\n     * @param _tagsData New list of tags\n     */\n    function changeTags(bytes32[] calldata _tagsData) external;\n\n    /**\n     * @notice Updates the name of the ModuleFactory\n     * @param _name New name that will replace the old one.\n     */\n    function changeName(bytes32 _name) external;\n\n    /**\n     * @notice Updates the description of the ModuleFactory\n     * @param _description New description that will replace the old one.\n     */\n    function changeDescription(string calldata _description) external;\n\n    /**\n     * @notice Updates the title of the ModuleFactory\n     * @param _title New Title that will replace the old one.\n     */\n    function changeTitle(string calldata _title) external;\n\n}\n\ninterface IDataStore {\n    /**\n     * @dev Changes security token atatched to this data store\n     * @param _securityToken address of the security token\n     */\n    function setSecurityToken(address _securityToken) external;\n\n    /**\n     * @dev Stores a uint256 data against a key\n     * @param _key Unique key to identify the data\n     * @param _data Data to be stored against the key\n     */\n    function setUint256(bytes32 _key, uint256 _data) external;\n\n    function setBytes32(bytes32 _key, bytes32 _data) external;\n\n    function setAddress(bytes32 _key, address _data) external;\n\n    function setString(bytes32 _key, string calldata _data) external;\n\n    function setBytes(bytes32 _key, bytes calldata _data) external;\n\n    function setBool(bytes32 _key, bool _data) external;\n\n    /**\n     * @dev Stores a uint256 array against a key\n     * @param _key Unique key to identify the array\n     * @param _data Array to be stored against the key\n     */\n    function setUint256Array(bytes32 _key, uint256[] calldata _data) external;\n\n    function setBytes32Array(bytes32 _key, bytes32[] calldata _data) external ;\n\n    function setAddressArray(bytes32 _key, address[] calldata _data) external;\n\n    function setBoolArray(bytes32 _key, bool[] calldata _data) external;\n\n    /**\n     * @dev Inserts a uint256 element to the array identified by the key\n     * @param _key Unique key to identify the array\n     * @param _data Element to push into the array\n     */\n    function insertUint256(bytes32 _key, uint256 _data) external;\n\n    function insertBytes32(bytes32 _key, bytes32 _data) external;\n\n    function insertAddress(bytes32 _key, address _data) external;\n\n    function insertBool(bytes32 _key, bool _data) external;\n\n    /**\n     * @dev Deletes an element from the array identified by the key.\n     * When an element is deleted from an Array, last element of that array is moved to the index of deleted element.\n     * @param _key Unique key to identify the array\n     * @param _index Index of the element to delete\n     */\n    function deleteUint256(bytes32 _key, uint256 _index) external;\n\n    function deleteBytes32(bytes32 _key, uint256 _index) external;\n\n    function deleteAddress(bytes32 _key, uint256 _index) external;\n\n    function deleteBool(bytes32 _key, uint256 _index) external;\n\n    /**\n     * @dev Stores multiple uint256 data against respective keys\n     * @param _keys Array of keys to identify the data\n     * @param _data Array of data to be stored against the respective keys\n     */\n    function setUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\n\n    function setBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\n\n    function setAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\n\n    function setBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\n\n    /**\n     * @dev Inserts multiple uint256 elements to the array identified by the respective keys\n     * @param _keys Array of keys to identify the data\n     * @param _data Array of data to be inserted in arrays of the respective keys\n     */\n    function insertUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\n\n    function insertBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\n\n    function insertAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\n\n    function insertBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\n\n    function getUint256(bytes32 _key) external view returns(uint256);\n\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    function getAddress(bytes32 _key) external view returns(address);\n\n    function getString(bytes32 _key) external view returns(string memory);\n\n    function getBytes(bytes32 _key) external view returns(bytes memory);\n\n    function getBool(bytes32 _key) external view returns(bool);\n\n    function getUint256Array(bytes32 _key) external view returns(uint256[] memory);\n\n    function getBytes32Array(bytes32 _key) external view returns(bytes32[] memory);\n\n    function getAddressArray(bytes32 _key) external view returns(address[] memory);\n\n    function getBoolArray(bytes32 _key) external view returns(bool[] memory);\n\n    function getUint256ArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getBytes32ArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getAddressArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getBoolArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getUint256ArrayElement(bytes32 _key, uint256 _index) external view returns(uint256);\n\n    function getBytes32ArrayElement(bytes32 _key, uint256 _index) external view returns(bytes32);\n\n    function getAddressArrayElement(bytes32 _key, uint256 _index) external view returns(address);\n\n    function getBoolArrayElement(bytes32 _key, uint256 _index) external view returns(bool);\n\n    function getUint256ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(uint256[] memory);\n\n    function getBytes32ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bytes32[] memory);\n\n    function getAddressArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(address[] memory);\n\n    function getBoolArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bool[] memory);\n}\n\n/**\n * @title Interface for all security tokens\n */\ninterface ISecurityToken {\n    // Standard ERC20 interface\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function decimals() external view returns(uint8);\n    function totalSupply() external view returns(uint256);\n    function balanceOf(address owner) external view returns(uint256);\n    function allowance(address owner, address spender) external view returns(uint256);\n    function transfer(address to, uint256 value) external returns(bool);\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\n    function approve(address spender, uint256 value) external returns(bool);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     * @return byte Ethereum status code (ESC)\n     * @return bytes32 Application specific reason code\n     */\n    function canTransfer(address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\n\n    // Emit at the time when module get added\n    event ModuleAdded(\n        uint8[] _types,\n        bytes32 indexed _name,\n        address indexed _moduleFactory,\n        address _module,\n        uint256 _moduleCost,\n        uint256 _budget,\n        bytes32 _label,\n        bool _archived\n    );\n\n    // Emit when the token details get updated\n    event UpdateTokenDetails(string _oldDetails, string _newDetails);\n    // Emit when the token name get updated\n    event UpdateTokenName(string _oldName, string _newName);\n    // Emit when the granularity get changed\n    event GranularityChanged(uint256 _oldGranularity, uint256 _newGranularity);\n    // Emit when is permanently frozen by the issuer\n    event FreezeIssuance();\n    // Emit when transfers are frozen or unfrozen\n    event FreezeTransfers(bool _status);\n    // Emit when new checkpoint created\n    event CheckpointCreated(uint256 indexed _checkpointId, uint256 _investorLength);\n    // Events to log controller actions\n    event SetController(address indexed _oldController, address indexed _newController);\n    //Event emit when the global treasury wallet address get changed\n    event TreasuryWalletChanged(address _oldTreasuryWallet, address _newTreasuryWallet);\n    event DisableController();\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event TokenUpgraded(uint8 _major, uint8 _minor, uint8 _patch);\n\n    // Emit when Module get archived from the securityToken\n    event ModuleArchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when Module get unarchived from the securityToken\n    event ModuleUnarchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when Module get removed from the securityToken\n    event ModuleRemoved(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when the budget allocated to a module is changed\n    event ModuleBudgetChanged(uint8[] _moduleTypes, address _module, uint256 _oldBudget, uint256 _budget); //Event emitted by the tokenLib.\n\n    // Transfer Events\n    event TransferByPartition(\n        bytes32 indexed _fromPartition,\n        address _operator,\n        address indexed _from,\n        address indexed _to,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    // Operator Events\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n\n    // Issuance / Redemption Events\n    event IssuedByPartition(bytes32 indexed partition, address indexed to, uint256 value, bytes data);\n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\n\n    // Document Events\n    event DocumentRemoved(bytes32 indexed _name, string _uri, bytes32 _documentHash);\n    event DocumentUpdated(bytes32 indexed _name, string _uri, bytes32 _documentHash);\n\n    // Controller Events\n    event ControllerTransfer(\n        address _controller,\n        address indexed _from,\n        address indexed _to,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    event ControllerRedemption(\n        address _controller,\n        address indexed _tokenHolder,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    // Issuance / Redemption Events\n    event Issued(address indexed _operator, address indexed _to, uint256 _value, bytes _data);\n    event Redeemed(address indexed _operator, address indexed _from, uint256 _value, bytes _data);\n\n    /**\n     * @notice Initialization function\n     * @dev Expected to be called atomically with the proxy being created, by the owner of the token\n     * @dev Can only be called once\n     */\n    function initialize(address _getterDelegate) external;\n\n    /**\n     * @notice The standard provides an on-chain function to determine whether a transfer will succeed,\n     * and return details indicating the reason if the transfer is not valid.\n     * @param _from The address from whom the tokens get transferred.\n     * @param _to The address to which to transfer tokens to.\n     * @param _partition The partition from which to transfer tokens\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @return ESC (Ethereum Status Code) following the EIP-1066 standard\n     * @return Application specific reason codes with additional details\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function canTransferByPartition(\n        address _from,\n        address _to,\n        bytes32 _partition,\n        uint256 _value,\n        bytes calldata _data\n    )\n        external\n        view\n        returns (byte statusCode, bytes32 reasonCode, bytes32 partition);\n\n    /**\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     * @return byte Ethereum status code (ESC)\n     * @return bytes32 Application specific reason code\n     */\n    function canTransferFrom(address _from, address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\n\n    /**\n     * @notice Used to attach a new document to the contract, or update the URI or hash of an existing attached document\n     * @dev Can only be executed by the owner of the contract.\n     * @param _name Name of the document. It should be unique always\n     * @param _uri Off-chain uri of the document from where it is accessible to investors/advisors to read.\n     * @param _documentHash hash (of the contents) of the document.\n     */\n    function setDocument(bytes32 _name, string calldata _uri, bytes32 _documentHash) external;\n\n    /**\n     * @notice Used to remove an existing document from the contract by giving the name of the document.\n     * @dev Can only be executed by the owner of the contract.\n     * @param _name Name of the document. It should be unique always\n     */\n    function removeDocument(bytes32 _name) external;\n\n    /**\n     * @notice Used to return the details of a document with a known name (`bytes32`).\n     * @param _name Name of the document\n     * @return string The URI associated with the document.\n     * @return bytes32 The hash (of the contents) of the document.\n     * @return uint256 the timestamp at which the document was last modified.\n     */\n    function getDocument(bytes32 _name) external view returns (string memory documentUri, bytes32 documentHash, uint256 documentTime);\n\n    /**\n     * @notice Used to retrieve a full list of documents attached to the smart contract.\n     * @return bytes32 List of all documents names present in the contract.\n     */\n    function getAllDocuments() external view returns (bytes32[] memory documentNames);\n\n    /**\n     * @notice In order to provide transparency over whether `controllerTransfer` / `controllerRedeem` are useable\n     * or not `isControllable` function will be used.\n     * @dev If `isControllable` returns `false` then it always return `false` and\n     * `controllerTransfer` / `controllerRedeem` will always revert.\n     * @return bool `true` when controller address is non-zero otherwise return `false`.\n     */\n    function isControllable() external view returns (bool controlled);\n\n    /**\n     * @notice Checks if an address is a module of certain type\n     * @param _module Address to check\n     * @param _type type to check against\n     */\n    function isModule(address _module, uint8 _type) external view returns(bool isValid);\n\n    /**\n     * @notice This function must be called to increase the total supply (Corresponds to mint function of ERC20).\n     * @dev It only be called by the token issuer or the operator defined by the issuer. ERC1594 doesn't have\n     * have the any logic related to operator but its superset ERC1400 have the operator logic and this function\n     * is allowed to call by the operator.\n     * @param _tokenHolder The account that will receive the created tokens (account should be whitelisted or KYCed).\n     * @param _value The amount of tokens need to be issued\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     */\n    function issue(address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice issue new tokens and assigns them to the target _tokenHolder.\n     * @dev Can only be called by the issuer or STO attached to the token.\n     * @param _tokenHolders A list of addresses to whom the minted tokens will be dilivered\n     * @param _values A list of number of tokens get minted and transfer to corresponding address of the investor from _tokenHolders[] list\n     * @return success\n     */\n    function issueMulti(address[] calldata _tokenHolders, uint256[] calldata _values) external;\n\n    /**\n     * @notice Increases totalSupply and the corresponding amount of the specified owners partition\n     * @param _partition The partition to allocate the increase in balance\n     * @param _tokenHolder The token holder whose balance should be increased\n     * @param _value The amount by which to increase the balance\n     * @param _data Additional data attached to the minting of tokens\n     */\n    function issueByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of msg.sender\n     * @param _partition The partition to allocate the decrease in balance\n     * @param _value The amount by which to decrease the balance\n     * @param _data Additional data attached to the burning of tokens\n     */\n    function redeemByPartition(bytes32 _partition, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\n     * are out of the scope of the ERC1594.\n     * @param _value The amount of tokens need to be redeemed\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\n     */\n    function redeem(uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\n     * are out of the scope of the ERC1594.\n     * @dev It is analogy to `transferFrom`\n     * @param _tokenHolder The account whose tokens gets redeemed.\n     * @param _value The amount of tokens need to be redeemed\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\n     */\n    function redeemFrom(address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of tokenHolder\n     * @dev This function can only be called by the authorised operator.\n     * @param _partition The partition to allocate the decrease in balance.\n     * @param _tokenHolder The token holder whose balance should be decreased\n     * @param _value The amount by which to decrease the balance\n     * @param _data Additional data attached to the burning of tokens\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\n     */\n    function operatorRedeemByPartition(\n        bytes32 _partition,\n        address _tokenHolder,\n        uint256 _value,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    ) external;\n\n    /**\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n     * @param _delegate address of delegate\n     * @param _module address of PermissionManager module\n     * @param _perm the permissions\n     * @return success\n     */\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPermission);\n\n    /**\n     * @notice Returns module list for a module type\n     * @param _module Address of the module\n     * @return bytes32 Name\n     * @return address Module address\n     * @return address Module factory address\n     * @return bool Module archived\n     * @return uint8 Array of module types\n     * @return bytes32 Module label\n     */\n    function getModule(address _module) external view returns (bytes32 moduleName, address moduleAddress, address factoryAddress, bool isArchived, uint8[] memory moduleTypes, bytes32 moduleLabel);\n\n    /**\n     * @notice Returns module list for a module name\n     * @param _name Name of the module\n     * @return address[] List of modules with this name\n     */\n    function getModulesByName(bytes32 _name) external view returns(address[] memory modules);\n\n    /**\n     * @notice Returns module list for a module type\n     * @param _type Type of the module\n     * @return address[] List of modules with this type\n     */\n    function getModulesByType(uint8 _type) external view returns(address[] memory modules);\n\n    /**\n     * @notice use to return the global treasury wallet\n     */\n    function getTreasuryWallet() external view returns(address treasuryWallet);\n\n    /**\n     * @notice Queries totalSupply at a specified checkpoint\n     * @param _checkpointId Checkpoint ID to query as of\n     */\n    function totalSupplyAt(uint256 _checkpointId) external view returns(uint256 supply);\n\n    /**\n     * @notice Queries balance at a specified checkpoint\n     * @param _investor Investor to query balance for\n     * @param _checkpointId Checkpoint ID to query as of\n     */\n    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns(uint256 balance);\n\n    /**\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\n     */\n    function createCheckpoint() external returns(uint256 checkpointId);\n\n    /**\n     * @notice Gets list of times that checkpoints were created\n     * @return List of checkpoint times\n     */\n    function getCheckpointTimes() external view returns(uint256[] memory checkpointTimes);\n\n    /**\n     * @notice returns an array of investors\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\n     * @return list of addresses\n     */\n    function getInvestors() external view returns(address[] memory investors);\n\n    /**\n     * @notice returns an array of investors at a given checkpoint\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\n     * @return list of investors\n     */\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[] memory investors);\n\n    /**\n     * @notice returns an array of investors with non zero balance at a given checkpoint\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\n     * @param _start Position of investor to start iteration from\n     * @param _end Position of investor to stop iteration at\n     * @return list of investors\n     */\n    function getInvestorsSubsetAt(uint256 _checkpointId, uint256 _start, uint256 _end) external view returns(address[] memory investors);\n\n    /**\n     * @notice generates subset of investors\n     * NB - can be used in batches if investor list is large\n     * @param _start Position of investor to start iteration from\n     * @param _end Position of investor to stop iteration at\n     * @return list of investors\n     */\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[] memory investors);\n\n    /**\n     * @notice Gets current checkpoint ID\n     * @return Id\n     */\n    function currentCheckpointId() external view returns(uint256 checkpointId);\n\n    /**\n     * @notice Determines whether `_operator` is an operator for all partitions of `_tokenHolder`\n     * @param _operator The operator to check\n     * @param _tokenHolder The token holder to check\n     * @return Whether the `_operator` is an operator for all partitions of `_tokenHolder`\n     */\n    function isOperator(address _operator, address _tokenHolder) external view returns (bool isValid);\n\n    /**\n     * @notice Determines whether `_operator` is an operator for a specified partition of `_tokenHolder`\n     * @param _partition The partition to check\n     * @param _operator The operator to check\n     * @param _tokenHolder The token holder to check\n     * @return Whether the `_operator` is an operator for a specified partition of `_tokenHolder`\n     */\n    function isOperatorForPartition(bytes32 _partition, address _operator, address _tokenHolder) external view returns (bool isValid);\n\n    /**\n     * @notice Return all partitions\n     * @param _tokenHolder Whom balance need to queried\n     * @return List of partitions\n     */\n    function partitionsOf(address _tokenHolder) external view returns (bytes32[] memory partitions);\n\n    /**\n     * @notice Gets data store address\n     * @return data store address\n     */\n    function dataStore() external view returns (address dataStoreAddress);\n\n    /**\n    * @notice Allows owner to change data store\n    * @param _dataStore Address of the token data store\n    */\n    function changeDataStore(address _dataStore) external;\n\n\n    /**\n     * @notice Allows to change the treasury wallet address\n     * @param _wallet Ethereum address of the treasury wallet\n     */\n    function changeTreasuryWallet(address _wallet) external;\n\n    /**\n     * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\n     * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\n     * @param _tokenContract Address of the ERC20Basic compliance token\n     * @param _value Amount of POLY to withdraw\n     */\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\n\n    /**\n    * @notice Allows owner to increase/decrease POLY approval of one of the modules\n    * @param _module Module address\n    * @param _change Change in allowance\n    * @param _increase True if budget has to be increased, false if decrease\n    */\n    function changeModuleBudget(address _module, uint256 _change, bool _increase) external;\n\n    /**\n     * @notice Changes the tokenDetails\n     * @param _newTokenDetails New token details\n     */\n    function updateTokenDetails(string calldata _newTokenDetails) external;\n\n    /**\n    * @notice Allows owner to change token name\n    * @param _name new name of the token\n    */\n    function changeName(string calldata _name) external;\n\n    /**\n    * @notice Allows the owner to change token granularity\n    * @param _granularity Granularity level of the token\n    */\n    function changeGranularity(uint256 _granularity) external;\n\n    /**\n     * @notice Freezes all the transfers\n     */\n    function freezeTransfers() external;\n\n    /**\n     * @notice Un-freezes all the transfers\n     */\n    function unfreezeTransfers() external;\n\n    /**\n     * @notice Permanently freeze issuance of this security token.\n     * @dev It MUST NOT be possible to increase `totalSuppy` after this function is called.\n     */\n    function freezeIssuance(bytes calldata _signature) external;\n\n    /**\n      * @notice Attachs a module to the SecurityToken\n      * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\n      * @dev to control restrictions on transfers.\n      * @param _moduleFactory is the address of the module factory to be added\n      * @param _data is data packed into bytes used to further configure the module (See STO usage)\n      * @param _maxCost max amount of POLY willing to pay to the module.\n      * @param _budget max amount of ongoing POLY willing to assign to the module.\n      * @param _label custom module label.\n      * @param _archived whether to add the module as an archived module\n      */\n    function addModuleWithLabel(\n        address _moduleFactory,\n        bytes calldata _data,\n        uint256 _maxCost,\n        uint256 _budget,\n        bytes32 _label,\n        bool _archived\n    ) external;\n\n    /**\n     * @notice Function used to attach a module to the security token\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\n     * @dev to control restrictions on transfers.\n     * @dev You are allowed to add a new moduleType if:\n     * @dev - there is no existing module of that type yet added\n     * @dev - the last member of the module list is replacable\n     * @param _moduleFactory is the address of the module factory to be added\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\n     * @param _budget max amount of ongoing POLY willing to assign to the module.\n     * @param _archived whether to add the module as an archived module\n     */\n    function addModule(address _moduleFactory, bytes calldata _data, uint256 _maxCost, uint256 _budget, bool _archived) external;\n\n    /**\n    * @notice Archives a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function archiveModule(address _module) external;\n\n    /**\n    * @notice Unarchives a module attached to the SecurityToken\n    * @param _module address of module to unarchive\n    */\n    function unarchiveModule(address _module) external;\n\n    /**\n    * @notice Removes a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function removeModule(address _module) external;\n\n    /**\n     * @notice Used by the issuer to set the controller addresses\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) external;\n\n    /**\n     * @notice This function allows an authorised address to transfer tokens between any two token holders.\n     * The transfer must still respect the balances of the token holders (so the transfer must be for at most\n     * `balanceOf(_from)` tokens) and potentially also need to respect other transfer restrictions.\n     * @dev This function can only be executed by the `controller` address.\n     * @param _from Address The address which you want to send tokens from\n     * @param _to Address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\n     * because use of `_data` parameter is implementation specific).\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\n     */\n    function controllerTransfer(address _from, address _to, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\n\n    /**\n     * @notice This function allows an authorised address to redeem tokens for any token holder.\n     * The redemption must still respect the balances of the token holder (so the redemption must be for at most\n     * `balanceOf(_tokenHolder)` tokens) and potentially also need to respect other transfer restrictions.\n     * @dev This function can only be executed by the `controller` address.\n     * @param _tokenHolder The account whose tokens will be redeemed.\n     * @param _value uint256 the amount of tokens need to be redeemed.\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\n     * because use of `_data` parameter is implementation specific).\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\n     */\n    function controllerRedeem(address _tokenHolder, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\n\n    /**\n     * @notice Used by the issuer to permanently disable controller functionality\n     * @dev enabled via feature switch \"disableControllerAllowed\"\n     */\n    function disableController(bytes calldata _signature) external;\n\n    /**\n     * @notice Used to get the version of the securityToken\n     */\n    function getVersion() external view returns(uint8[] memory version);\n\n    /**\n     * @notice Gets the investor count\n     */\n    function getInvestorCount() external view returns(uint256 investorCount);\n\n    /**\n     * @notice Gets the holder count (investors with non zero balance)\n     */\n    function holderCount() external view returns(uint256 count);\n\n    /**\n      * @notice Overloaded version of the transfer function\n      * @param _to receiver of transfer\n      * @param _value value of transfer\n      * @param _data data to indicate validation\n      * @return bool success\n      */\n    function transferWithData(address _to, uint256 _value, bytes calldata _data) external;\n\n    /**\n      * @notice Overloaded version of the transferFrom function\n      * @param _from sender of transfer\n      * @param _to receiver of transfer\n      * @param _value value of transfer\n      * @param _data data to indicate validation\n      * @return bool success\n      */\n    function transferFromWithData(address _from, address _to, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\n     * @param _partition The partition from which to transfer tokens\n     * @param _to The address to which to transfer tokens to\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function transferByPartition(bytes32 _partition, address _to, uint256 _value, bytes calldata _data) external returns (bytes32 partition);\n\n    /**\n     * @notice Get the balance according to the provided partitions\n     * @param _partition Partition which differentiate the tokens.\n     * @param _tokenHolder Whom balance need to queried\n     * @return Amount of tokens as per the given partitions\n     */\n    function balanceOfByPartition(bytes32 _partition, address _tokenHolder) external view returns(uint256 balance);\n\n    /**\n      * @notice Provides the granularity of the token\n      * @return uint256\n      */\n    function granularity() external view returns(uint256 granularityAmount);\n\n    /**\n      * @notice Provides the address of the polymathRegistry\n      * @return address\n      */\n    function polymathRegistry() external view returns(address registryAddress);\n\n    /**\n    * @notice Upgrades a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function upgradeModule(address _module) external;\n\n    /**\n    * @notice Upgrades security token\n    */\n    function upgradeToken() external;\n\n    /**\n     * @notice A security token issuer can specify that issuance has finished for the token\n     * (i.e. no new tokens can be minted or issued).\n     * @dev If a token returns FALSE for `isIssuable()` then it MUST always return FALSE in the future.\n     * If a token returns FALSE for `isIssuable()` then it MUST never allow additional tokens to be issued.\n     * @return bool `true` signifies the minting is allowed. While `false` denotes the end of minting\n     */\n    function isIssuable() external view returns (bool issuable);\n\n    /**\n     * @notice Authorises an operator for all partitions of `msg.sender`.\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\n     * @param _operator An address which is being authorised.\n     */\n    function authorizeOperator(address _operator) external;\n\n    /**\n     * @notice Revokes authorisation of an operator previously given for all partitions of `msg.sender`.\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\n     * @param _operator An address which is being de-authorised\n     */\n    function revokeOperator(address _operator) external;\n\n    /**\n     * @notice Authorises an operator for a given partition of `msg.sender`\n     * @param _partition The partition to which the operator is authorised\n     * @param _operator An address which is being authorised\n     */\n    function authorizeOperatorByPartition(bytes32 _partition, address _operator) external;\n\n    /**\n     * @notice Revokes authorisation of an operator previously given for a specified partition of `msg.sender`\n     * @param _partition The partition to which the operator is de-authorised\n     * @param _operator An address which is being de-authorised\n     */\n    function revokeOperatorByPartition(bytes32 _partition, address _operator) external;\n\n    /**\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\n     * @param _partition The partition from which to transfer tokens.\n     * @param _from The address from which to transfer tokens from\n     * @param _to The address to which to transfer tokens to\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function operatorTransferByPartition(\n        bytes32 _partition,\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    )\n        external\n        returns (bytes32 partition);\n\n    /*\n    * @notice Returns if transfers are currently frozen or not\n    */\n    function transfersFrozen() external view returns (bool isFrozen);\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) external;\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() external view returns (bool);\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() external view returns (address ownerAddress);\n\n    function controller() external view returns(address controllerAddress);\n\n    function moduleRegistry() external view returns(address moduleRegistryAddress);\n\n    function securityTokenRegistry() external view returns(address securityTokenRegistryAddress);\n\n    function polyToken() external view returns(address polyTokenAddress);\n\n    function tokenFactory() external view returns(address tokenFactoryAddress);\n\n    function getterDelegate() external view returns(address delegate);\n\n    function controllerDisabled() external view returns(bool isDisabled);\n\n    function initialized() external view returns(bool isInitialized);\n\n    function tokenDetails() external view returns(string memory details);\n\n    function updateFromRegistry() external;\n\n}\n\ninterface ICheckPermission {\n    /**\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n     * @param _delegate address of delegate\n     * @param _module address of PermissionManager module\n     * @param _perm the permissions\n     * @return success\n     */\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPerm);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Storage for Module contract\n * @notice Contract is abstract\n */\ncontract ModuleStorage {\n    address public factory;\n\n    ISecurityToken public securityToken;\n\n    // Permission flag\n    bytes32 public constant ADMIN = \"ADMIN\";\n    bytes32 public constant OPERATOR = \"OPERATOR\";\n\n    bytes32 internal constant TREASURY = 0xaae8817359f3dcb67d050f44f3e49f982e0359d90ca4b5f18569926304aaece6; // keccak256(abi.encodePacked(\"TREASURY_WALLET\"))\n\n    IERC20 public polyToken;\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor(address _securityToken, address _polyAddress) public {\n        securityToken = ISecurityToken(_securityToken);\n        factory = msg.sender;\n        polyToken = IERC20(_polyAddress);\n    }\n\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     * @notice Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @title Interface that any module contract should implement\n * @notice Contract is abstract\n */\ncontract Module is IModule, ModuleStorage, Pausable {\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     */\n    constructor (address _securityToken, address _polyAddress) public\n    ModuleStorage(_securityToken, _polyAddress)\n    {\n    }\n\n    //Allows owner, factory or permissioned delegate\n    modifier withPerm(bytes32 _perm) {\n        require(_checkPerm(_perm, msg.sender), \"Invalid permission\");\n        _;\n    }\n\n    function _checkPerm(bytes32 _perm, address _caller) internal view returns (bool) {\n        bool isOwner = _caller == Ownable(address(securityToken)).owner();\n        bool isFactory = _caller == factory;\n        return isOwner || isFactory || ICheckPermission(address(securityToken)).checkPermission(_caller, address(this), _perm);\n    }\n\n    function _onlySecurityTokenOwner() internal view {\n        require(msg.sender == Ownable(address(securityToken)).owner(), \"Sender is not owner\");\n    }\n\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Sender is not factory\");\n        _;\n    }\n\n    /**\n     * @notice Pause (overridden function)\n     */\n    function pause() public {\n        _onlySecurityTokenOwner();\n        super._pause();\n    }\n\n    /**\n     * @notice Unpause (overridden function)\n     */\n    function unpause() public {\n        _onlySecurityTokenOwner();\n        super._unpause();\n    }\n\n    /**\n     * @notice used to return the data store address of securityToken\n     */\n    function getDataStore() public view returns(IDataStore) {\n        return IDataStore(securityToken.dataStore());\n    }\n\n    /**\n    * @notice Reclaims ERC20Basic compatible tokens\n    * @dev We duplicate here due to the overriden owner & onlyOwner\n    * @param _tokenContract The address of the token contract\n    */\n    function reclaimERC20(address _tokenContract) external {\n        _onlySecurityTokenOwner();\n        require(_tokenContract != address(0), \"Invalid address\");\n        IERC20 token = IERC20(_tokenContract);\n        uint256 balance = token.balanceOf(address(this));\n        require(token.transfer(msg.sender, balance), \"Transfer failed\");\n    }\n\n   /**\n    * @notice Reclaims ETH\n    * @dev We duplicate here due to the overriden owner & onlyOwner\n    */\n    function reclaimETH() external {\n        _onlySecurityTokenOwner();\n        msg.sender.transfer(address(this).balance);\n    }\n}\n\n/**\n * @title Storage layout for the STO contract\n */\n\ncontract STOStorage {\n    bytes32 internal constant INVESTORFLAGS = \"INVESTORFLAGS\";\n\n    mapping (uint8 => bool) public fundRaiseTypes;\n    mapping (uint8 => uint256) public fundsRaised;\n\n    // Start time of the STO\n    uint256 public startTime;\n    // End time of the STO\n    uint256 public endTime;\n    // Time STO was paused\n    uint256 public pausedTime;\n    // Number of individual investors\n    uint256 public investorCount;\n    // Address where ETH & POLY funds are delivered\n    address payable public wallet;\n    // Final amount of tokens sold\n    uint256 public totalTokensSold;\n\n}\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n/**\n * @title Interface to be implemented by all STO modules\n */\ninterface ISTO {\n\n    enum FundRaiseType {ETH, POLY, SC}\n\n    // Event\n    event SetFundRaiseTypes(FundRaiseType[] _fundRaiseTypes);\n\n    /**\n     * @notice Returns the total no. of tokens sold\n     */\n    function getTokensSold() external view returns(uint256 soldTokens);\n\n    /**\n     * @notice Returns funds raised by the STO\n     */\n    function getRaised(FundRaiseType _fundRaiseType) external view returns(uint256 raisedAmount);\n\n    /**\n     * @notice Pause (overridden function)\n     * @dev Only securityToken owner restriction applied on the super function\n     */\n    function pause() external;\n\n}\n\n/**\n * @title Base abstract contract to be extended by all STO modules\n */\ncontract STO is ISTO, STOStorage, Module {\n    using SafeMath for uint256;\n\n    /**\n     * @notice Returns funds raised by the STO\n     */\n    function getRaised(FundRaiseType _fundRaiseType) public view returns(uint256) {\n        return fundsRaised[uint8(_fundRaiseType)];\n    }\n\n    /**\n     * @notice Returns the total no. of tokens sold\n     */\n    function getTokensSold() external view returns (uint256);\n\n    /**\n     * @notice Pause (overridden function)\n     * @dev Only securityToken owner restriction applied on the super function\n     */\n    function pause() public {\n        /*solium-disable-next-line security/no-block-members*/\n        require(now < endTime, \"STO has been finalized\");\n        super.pause();\n    }\n\n    function _setFundRaiseType(FundRaiseType[] memory _fundRaiseTypes) internal {\n        // FundRaiseType[] parameter type ensures only valid values for _fundRaiseTypes\n        require(_fundRaiseTypes.length > 0 && _fundRaiseTypes.length <= 3, \"Raise type is not specified\");\n        fundRaiseTypes[uint8(FundRaiseType.ETH)] = false;\n        fundRaiseTypes[uint8(FundRaiseType.POLY)] = false;\n        fundRaiseTypes[uint8(FundRaiseType.SC)] = false;\n        for (uint8 j = 0; j < _fundRaiseTypes.length; j++) {\n            fundRaiseTypes[uint8(_fundRaiseTypes[j])] = true;\n        }\n        emit SetFundRaiseTypes(_fundRaiseTypes);\n    }\n\n    function _canBuy(address _investor) internal view returns(bool) {\n        IDataStore dataStore = getDataStore();\n        uint256 flags = dataStore.getUint256(_getKey(INVESTORFLAGS, _investor));\n        return(flags & (uint256(1) << 1) == 0);\n    }\n\n    function _getKey(bytes32 _key1, address _key2) internal pure returns(bytes32) {\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\n    }\n}\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n    /// @dev counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n}\n\n/**\n * @title Contract used to store layout for the CappedSTO storage\n */\ncontract CappedSTOStorage {\n\n    // Determine whether users can invest on behalf of a beneficiary\n    bool public allowBeneficialInvestments = false;\n    // How many token units a buyer gets (multiplied by 10^18) per wei / base unit of POLY\n    // If rate is 10^18, buyer will get 1 token unit for every wei / base unit of poly.\n    uint256 public rate;\n    //How many token base units this STO will be allowed to sell to investors\n    // 1 full token = 10^decimals_of_token base units\n    uint256 public cap;\n\n    mapping (address => uint256) public investors;\n\n}\n\n/**\n * @title STO module for standard capped crowdsale\n */\ncontract CappedSTO is CappedSTOStorage, STO, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    /**\n    * Event for token purchase logging\n    * @param purchaser who paid for the tokens\n    * @param beneficiary who got the tokens\n    * @param value weis paid for purchase\n    * @param amount amount of tokens purchased\n    */\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\n    event SetAllowBeneficialInvestments(bool _allowed);\n\n    constructor(address _securityToken, address _polyToken) public Module(_securityToken, _polyToken) {\n\n    }\n\n    //////////////////////////////////\n    /**\n    * @notice fallback function ***DO NOT OVERRIDE***\n    */\n    function() external payable {\n        buyTokens(msg.sender);\n    }\n\n    /**\n     * @notice Function used to intialize the contract variables\n     * @param _startTime Unix timestamp at which offering get started\n     * @param _endTime Unix timestamp at which offering get ended\n     * @param _cap Maximum No. of token base units for sale\n     * @param _rate Token units a buyer gets multiplied by 10^18 per wei / base unit of POLY\n     * @param _fundRaiseTypes Type of currency used to collect the funds\n     * @param _fundsReceiver Ethereum account address to hold the funds\n     */\n    function configure(\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _cap,\n        uint256 _rate,\n        FundRaiseType[] memory _fundRaiseTypes,\n        address payable _fundsReceiver\n    )\n        public\n        onlyFactory\n    {\n        require(endTime == 0, \"Already configured\");\n        require(_rate > 0, \"Rate of token should be greater than 0\");\n        require(_fundsReceiver != address(0), \"Zero address is not permitted\");\n        /*solium-disable-next-line security/no-block-members*/\n        require(_startTime >= now && _endTime > _startTime, \"Date parameters are not valid\");\n        require(_cap > 0, \"Cap should be greater than 0\");\n        require(_fundRaiseTypes.length == 1, \"It only selects single fund raise type\");\n        startTime = _startTime;\n        endTime = _endTime;\n        cap = _cap;\n        rate = _rate;\n        wallet = _fundsReceiver;\n        _setFundRaiseType(_fundRaiseTypes);\n    }\n\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() public pure returns(bytes4) {\n        return this.configure.selector;\n    }\n\n    /**\n     * @notice Function to set allowBeneficialInvestments (allow beneficiary to be different to funder)\n     * @param _allowBeneficialInvestments Boolean to allow or disallow beneficial investments\n     */\n    function changeAllowBeneficialInvestments(bool _allowBeneficialInvestments) public withPerm(OPERATOR) {\n        require(_allowBeneficialInvestments != allowBeneficialInvestments, \"Does not change value\");\n        allowBeneficialInvestments = _allowBeneficialInvestments;\n        emit SetAllowBeneficialInvestments(allowBeneficialInvestments);\n    }\n\n    /**\n      * @notice Low level token purchase ***DO NOT OVERRIDE***\n      * @param _beneficiary Address performing the token purchase\n      */\n    function buyTokens(address _beneficiary) public payable whenNotPaused nonReentrant {\n        if (!allowBeneficialInvestments) {\n            require(_beneficiary == msg.sender, \"Beneficiary address does not match msg.sender\");\n        }\n\n        require(fundRaiseTypes[uint8(FundRaiseType.ETH)], \"Mode of investment is not ETH\");\n\n        uint256 weiAmount = msg.value;\n        uint256 refund = _processTx(_beneficiary, weiAmount);\n        weiAmount = weiAmount.sub(refund);\n\n        _forwardFunds(refund);\n    }\n\n    /**\n      * @notice low level token purchase\n      * @param _investedPOLY Amount of POLY invested\n      */\n    function buyTokensWithPoly(uint256 _investedPOLY) public whenNotPaused nonReentrant {\n        require(fundRaiseTypes[uint8(FundRaiseType.POLY)], \"Mode of investment is not POLY\");\n        uint256 refund = _processTx(msg.sender, _investedPOLY);\n        _forwardPoly(msg.sender, wallet, _investedPOLY.sub(refund));\n    }\n\n    /**\n    * @notice Checks whether the cap has been reached.\n    * @return bool Whether the cap was reached\n    */\n    function capReached() public view returns(bool) {\n        return totalTokensSold >= cap;\n    }\n\n    /**\n     * @notice Return the total no. of tokens sold\n     */\n    function getTokensSold() external view returns (uint256) {\n        return totalTokensSold;\n    }\n\n    /**\n     * @notice Return the permissions flag that are associated with STO\n     */\n    function getPermissions() public view returns(bytes32[] memory) {\n        bytes32[] memory allPermissions = new bytes32[](1);\n        allPermissions[0] = OPERATOR;\n        return allPermissions;\n    }\n\n    /**\n     * @notice Return the STO details\n     * @return Unixtimestamp at which offering gets start.\n     * @return Unixtimestamp at which offering ends.\n     * @return Number of token base units this STO will be allowed to sell to investors.\n     * @return Token units a buyer gets(multiplied by 10^18) per wei / base unit of POLY\n     * @return Amount of funds raised\n     * @return Number of individual investors this STO have.\n     * @return Amount of tokens get sold.\n     * @return Boolean value to justify whether the fund raise type is POLY or not, i.e true for POLY.\n     */\n    function getSTODetails() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, bool) {\n        return (startTime, endTime, cap, rate, (fundRaiseTypes[uint8(FundRaiseType.POLY)]) ? fundsRaised[uint8(\n            FundRaiseType.POLY\n        )] : fundsRaised[uint8(FundRaiseType.ETH)], investorCount, totalTokensSold, (fundRaiseTypes[uint8(FundRaiseType.POLY)]));\n    }\n\n    // -----------------------------------------\n    // Internal interface (extensible)\n    // -----------------------------------------\n    /**\n      * Processing the purchase as well as verify the required validations\n      * @param _beneficiary Address performing the token purchase\n      * @param _investedAmount Value in wei involved in the purchase\n    */\n    function _processTx(address _beneficiary, uint256 _investedAmount) internal returns(uint256 refund) {\n        _preValidatePurchase(_beneficiary, _investedAmount);\n        // calculate token amount to be created\n        uint256 tokens;\n        (tokens, refund) = _getTokenAmount(_investedAmount);\n        _investedAmount = _investedAmount.sub(refund);\n\n        // update state\n        if (fundRaiseTypes[uint8(FundRaiseType.POLY)]) {\n            fundsRaised[uint8(FundRaiseType.POLY)] = fundsRaised[uint8(FundRaiseType.POLY)].add(_investedAmount);\n        } else {\n            fundsRaised[uint8(FundRaiseType.ETH)] = fundsRaised[uint8(FundRaiseType.ETH)].add(_investedAmount);\n        }\n        totalTokensSold = totalTokensSold.add(tokens);\n\n        _processPurchase(_beneficiary, tokens);\n        emit TokenPurchase(msg.sender, _beneficiary, _investedAmount, tokens);\n\n    }\n\n    /**\n    * @notice Validation of an incoming purchase.\n      Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n    * @param _beneficiary Address performing the token purchase\n    * @param _investedAmount Value in wei involved in the purchase\n    */\n    function _preValidatePurchase(address _beneficiary, uint256 _investedAmount) internal view {\n        require(_beneficiary != address(0), \"Beneficiary address should not be 0x\");\n        require(_investedAmount != 0, \"Amount invested should not be equal to 0\");\n        require(_canBuy(_beneficiary), \"Unauthorized\");\n        /*solium-disable-next-line security/no-block-members*/\n        require(now >= startTime && now <= endTime, \"Offering is closed/Not yet started\");\n    }\n\n    /**\n    * @notice Source of tokens.\n      Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n    * @param _beneficiary Address performing the token purchase\n    * @param _tokenAmount Number of tokens to be emitted\n    */\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n        securityToken.issue(_beneficiary, _tokenAmount, \"\");\n    }\n\n    /**\n    * @notice Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n    * @param _beneficiary Address receiving the tokens\n    * @param _tokenAmount Number of tokens to be purchased\n    */\n    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n        if (investors[_beneficiary] == 0) {\n            investorCount = investorCount + 1;\n        }\n        investors[_beneficiary] = investors[_beneficiary].add(_tokenAmount);\n\n        _deliverTokens(_beneficiary, _tokenAmount);\n    }\n\n    /**\n    * @notice Overrides to extend the way in which ether is converted to tokens.\n    * @param _investedAmount Value in wei to be converted into tokens\n    * @return Number of tokens that can be purchased with the specified _investedAmount\n    * @return Remaining amount that should be refunded to the investor\n    */\n    function _getTokenAmount(uint256 _investedAmount) internal view returns(uint256 tokens, uint256 refund) {\n        tokens = _investedAmount.mul(rate);\n        tokens = tokens.div(uint256(10) ** 18);\n        if (totalTokensSold.add(tokens) > cap) {\n            tokens = cap.sub(totalTokensSold);\n        }\n        uint256 granularity = securityToken.granularity();\n        tokens = tokens.div(granularity);\n        tokens = tokens.mul(granularity);\n        require(tokens > 0, \"Cap reached\");\n        refund = _investedAmount.sub((tokens.mul(uint256(10) ** 18)).div(rate));\n    }\n\n    /**\n    * @notice Determines how ETH is stored/forwarded on purchases.\n    */\n    function _forwardFunds(uint256 _refund) internal {\n        wallet.transfer(msg.value.sub(_refund));\n        msg.sender.transfer(_refund);\n    }\n\n    /**\n     * @notice Internal function used to forward the POLY raised to beneficiary address\n     * @param _beneficiary Address of the funds reciever\n     * @param _to Address who wants to ST-20 tokens\n     * @param _fundsAmount Amount invested by _to\n     */\n    function _forwardPoly(address _beneficiary, address _to, uint256 _fundsAmount) internal {\n        polyToken.transferFrom(_beneficiary, _to, _fundsAmount);\n    }\n\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"reclaimETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSTODetails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_fundRaiseTypes\",\"type\":\"uint8[]\"},{\"name\":\"_fundsReceiver\",\"type\":\"address\"}],\"name\":\"configure\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitFunction\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowBeneficialInvestments\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allowBeneficialInvestments\",\"type\":\"bool\"}],\"name\":\"changeAllowBeneficialInvestments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"polyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"reclaimERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OPERATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fundRaiseType\",\"type\":\"uint8\"}],\"name\":\"getRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pausedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"securityToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPermissions\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"fundsRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investedPOLY\",\"type\":\"uint256\"}],\"name\":\"buyTokensWithPoly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"fundRaiseTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDataStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_securityToken\",\"type\":\"address\"},{\"name\":\"_polyToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"SetAllowBeneficialInvestments\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_fundRaiseTypes\",\"type\":\"uint8[]\"}],\"name\":\"SetFundRaiseTypes\",\"type\":\"event\"}]","ContractName":"CappedSTO","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://5d49d587f05287dfac8b728f0114c504f9498a14b33fb5b3e3d4493d7b858f8f"}]}