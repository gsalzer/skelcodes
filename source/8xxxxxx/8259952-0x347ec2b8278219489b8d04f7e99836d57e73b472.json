{"status":"1","message":"OK","result":[{"SourceCode":"{\"AllowanceChecker.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./IAllowanceChecker.sol\\\";\\n\\n\\ncontract AllowanceChecker is Constants {\\n\\n    modifier requireAllowance(\\n        address _coinAddress,\\n        address _coinHolder,\\n        uint256 _expectedBalance\\n    ) {\\n        require(\\n            getCoinAllowance(\\n                _coinAddress,\\n                _coinHolder\\n            ) \\u003e= _expectedBalance,\\n            ERROR_BALANCE_IS_NOT_ALLOWED\\n        );\\n        _;\\n    }\\n\\n    function getCoinAllowance(\\n        address _coinAddress,\\n        address _coinHolder\\n    )\\n    internal\\n    view\\n    returns (uint256)\\n    {\\n        return IERC20(_coinAddress).allowance(\\n            _coinHolder,\\n            address(this)\\n        );\\n    }\\n}\\n\"},\"CoinExchangeRates.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IManagement.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./ICoinExchangeRates.sol\\\";\\n\\n\\n/*solium-disable-next-line*/\\ncontract CoinExchangeRates is ICoinExchangeRates, IManagement, Constants, Ownable {\\n    using SafeMath for uint256;\\n\\n    uint256 private blobCoinPrice_;\\n\\n    address[] private permittedCoinsAddresses_;\\n\\n    mapping(address =\\u003e uint256) public stableCoinsPrices;\\n    mapping(address =\\u003e uint256) public stableCoinsDecimals;\\n    mapping(address =\\u003e uint256) public priceUpdatedAt;\\n    mapping(address =\\u003e uint256) public stableCoinsToProportion;\\n\\n    mapping(address =\\u003e uint256) public permittedTokensToId;\\n\\n    modifier requirePermission(uint256 _permissionBit) {\\n        require(\\n            hasPermission(msg.sender, _permissionBit),\\n            ERROR_ACCESS_DENIED\\n        );\\n        _;\\n    }\\n\\n    event PriceUpdated(uint256 newPrice);\\n\\n    constructor(uint256 _blobCoinPrice)\\n    public\\n    {\\n        blobCoinPrice_ = _blobCoinPrice;\\n        permittedCoinsAddresses_.push(address(0));\\n    }\\n\\n    // 5 00000\\n    function setBlobCoinPrice(uint256 _blobCoinPrice)\\n    public\\n    requirePermission(CAN_REGISTER_COINS)\\n    {\\n        blobCoinPrice_ = _blobCoinPrice;\\n        emit PriceUpdated(_blobCoinPrice);\\n    }\\n\\n    function setCoinsPricesInUSD(\\n        address[] memory _coinsAddresses,\\n        uint256[] memory _prices\\n    )\\n    public\\n    requirePermission(CAN_REGISTER_COINS)\\n    returns(bool)\\n    {\\n        require(\\n            _coinsAddresses.length == _prices.length,\\n            ERROR_WRONG_AMOUNT\\n        );\\n\\n        for (uint256 i = 0; i \\u003c _coinsAddresses.length; i++) {\\n            setCoinPrice(_coinsAddresses[i], _prices[i]);\\n        }\\n        return true;\\n    }\\n\\n    function setCoinsCoverageProportion(\\n        address[] memory _coinsAddresses,\\n        uint256[] memory _percentageProportion\\n    )\\n    public\\n    requirePermission(CAN_REGISTER_COINS)\\n    returns(bool)\\n    {\\n        require(\\n            _coinsAddresses.length == _percentageProportion.length,\\n            ERROR_WRONG_AMOUNT\\n        );\\n        uint256 totalProportion;\\n        for (uint256 i = 0; i \\u003c _coinsAddresses.length; i++) {\\n            require(\\n                hasPermission(_coinsAddresses[i], PERMITTED_COINS),\\n                ERROR_ACCESS_DENIED\\n            );\\n            stableCoinsToProportion[\\n            _coinsAddresses[i]\\n            ] = _percentageProportion[i];\\n            totalProportion = totalProportion.add(_percentageProportion[i]);\\n        }\\n        require(totalProportion == PERCENTS_ABS_MAX, ERROR_WRONG_AMOUNT);\\n        return true;\\n    }\\n\\n    function calculateUSDByBlobs(uint256 _blobsAmount)\\n    public\\n    view\\n    returns(uint256)\\n    {\\n        uint256 coefficientWithoutFee = PERCENTS_ABS_MAX\\n        .sub(getFeePercentage());\\n\\n        return _blobsAmount\\n        .mul(blobCoinPrice())\\n        .mul(coefficientWithoutFee)\\n        .div(PERCENTS_ABS_MAX);\\n    }\\n\\n    function calculateUsdByCoin(\\n        address _stableCoinAddress,\\n        uint256 _coinsAmount\\n    )\\n    public\\n    view\\n    returns (uint256)\\n    {\\n        uint256 coinDecimals = stableCoinsDecimals[_stableCoinAddress];\\n        uint256 coinsAmount = _coinsAmount;\\n        if (coinDecimals \\u003c 18) {\\n            coinsAmount = _coinsAmount.mul(1e18).div(10 ** coinDecimals);\\n        }\\n        return getCoinPrice(_stableCoinAddress).mul(coinsAmount);\\n    }\\n\\n    function calculateCoinsAmountByUSD(\\n        uint256 _usdAmount\\n    )\\n    public\\n    view\\n    returns (address[] memory, uint256[] memory)\\n    {\\n        uint256[] memory coinsAmount = new uint[](\\n            permittedCoinsAddresses_.length\\n        );\\n        for (uint256 i = 1; i \\u003c permittedCoinsAddresses_.length; i++) {\\n            coinsAmount[i] = _usdAmount\\n            .mul(10**stableCoinsDecimals[permittedCoinsAddresses_[i]])\\n            .mul(stableCoinsToProportion[permittedCoinsAddresses_[i]])\\n            .div(getCoinPrice(permittedCoinsAddresses_[i]))\\n            .div(PERCENTS_ABS_MAX);\\n        }\\n        return (permittedCoinsAddresses_, coinsAmount);\\n    }\\n\\n    function calculateBlobsAmount(\\n        address _stableCoinAddress,\\n        uint256 _coinsAmount\\n    )\\n    public\\n    view\\n    returns (uint256)\\n    {\\n\\n        return calculateUsdByCoin(_stableCoinAddress, _coinsAmount)\\n        .div(blobCoinPrice());\\n    }\\n\\n    function coinPriceUpdatedAt(address _stableCoinAddress)\\n    public\\n    view\\n    returns(uint256)\\n    {\\n        return priceUpdatedAt[_stableCoinAddress];\\n    }\\n\\n    function getCoinPrice(address _stableCoinAddress)\\n    public\\n    view\\n    returns(uint256)\\n    {\\n        return stableCoinsPrices[_stableCoinAddress];\\n    }\\n\\n    function permittedCoinsAddresses()\\n    public\\n    view\\n    returns (address[] memory)\\n    {\\n        return permittedCoinsAddresses_;\\n    }\\n\\n    function blobCoinPrice()\\n    public\\n    view\\n    returns (uint256)\\n    {\\n        return blobCoinPrice_;\\n    }\\n\\n    function setCoinPrice(address _stableCoinAddress, uint256 _price)\\n    internal\\n    {\\n        require(\\n            hasPermission(_stableCoinAddress, PERMITTED_COINS),\\n            ERROR_ACCESS_DENIED\\n        );\\n        stableCoinsPrices[_stableCoinAddress] = _price;\\n        priceUpdatedAt[_stableCoinAddress] = block.timestamp;\\n    }\\n\\n    function internalSetPermissionsForCoins(\\n        address _address,\\n        bool _value,\\n        uint256 _decimals\\n    )\\n    internal\\n    {\\n        stableCoinsDecimals[_address] = _decimals;\\n        if (true == _value) {\\n            require(permittedTokensToId[_address] == 0, ERROR_COIN_REGISTERED);\\n            permittedTokensToId[_address] = permittedCoinsAddresses_.length;\\n            permittedCoinsAddresses_.push(_address);\\n        }\\n        if (false == _value) {\\n            uint256 coinIndex = permittedTokensToId[_address];\\n            require(coinIndex != 0, ERROR_NO_CONTRACT);\\n            uint256 lastCoinIndex = permittedCoinsAddresses_.length.sub(1);\\n            permittedCoinsAddresses_[coinIndex] = permittedCoinsAddresses_[\\n            lastCoinIndex\\n            ];\\n            permittedTokensToId[permittedCoinsAddresses_[coinIndex]] = coinIndex;\\n            delete permittedCoinsAddresses_[lastCoinIndex];\\n            permittedTokensToId[_address] = 0;\\n            permittedCoinsAddresses_.length = permittedCoinsAddresses_.length.sub(1);\\n        }\\n    }\\n\\n    function hasPermission(\\n        address _subject,\\n        uint256 _permissionBit\\n    )\\n    internal\\n    view\\n    returns (bool)\\n    {\\n        return permissions(_subject, _permissionBit);\\n    }\\n}\\n\"},\"Constants.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n\\ncontract Constants {\\n\\n    // Permissions constants\\n    uint256 public constant CAN_EXCHANGE_COINS = 1;\\n    uint256 public constant CAN_REGISTER_COINS = 2;\\n    uint256 public constant CAN_MINT_COINS = 3;\\n    uint256 public constant CAN_BURN_COINS = 4;\\n    uint256 public constant CAN_LOCK_COINS = 5;\\n    uint256 public constant PERMITTED_COINS = 6;\\n\\n    // Contract Registry keys\\n\\n    //public block-chain\\n    uint256 public constant CONTRACT_TOKEN = 1;\\n    uint256 public constant CONTRACT_EXCHANGE = 2;\\n    uint256 public constant CONTRACT_WITHDRAW = 3;\\n    uint256 public constant COIN_HOLDER = 4;\\n\\n\\n\\n    uint256 public constant PERCENTS_ABS_MAX = 1e4;\\n    uint256 public constant USD_PRECISION = 1e5;\\n\\n    string public constant ERROR_ACCESS_DENIED = \\\"ERROR_ACCESS_DENIED\\\";\\n    string public constant ERROR_NO_CONTRACT = \\\"ERROR_NO_CONTRACT\\\";\\n    string public constant ERROR_NOT_AVAILABLE = \\\"ERROR_NOT_AVAILABLE\\\";\\n    string public constant ERROR_WRONG_AMOUNT = \\\"ERROR_WRONG_AMOUNT\\\";\\n    /*solium-disable-next-line*/\\n    string public constant ERROR_NOT_PERMITTED_COIN = \\\"ERROR_NOT_PERMITTED_COIN\\\";\\n    /*solium-disable-next-line*/\\n    string public constant ERROR_BALANCE_IS_NOT_ALLOWED = \\\"BALANCE_IS_NOT_ALLOWED\\\";\\n    string public constant ERROR_COIN_REGISTERED = \\\"ERROR_COIN_REGISTERED\\\";\\n\\n    // Campaign Sates\\n    enum RequestState{\\n        Pending,\\n        PaidPartially,\\n        FullyPaid,\\n        Rejected,\\n        Refunded,\\n        Undefined,\\n        Canceled\\n    }\\n}\\n\\n\"},\"IAllowanceChecker.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\n\\ncontract IAllowanceChecker {\\n\\n    /**\\n    * @dev Function to get stable coin allowed amount for originater\\n    * @param _coinAddress address of stable coin\\n    * @param _coinHolderAddress address of coin holder\\n    * @return uint256 that indicates amount of allowed amount for originate address\\n    */\\n    function getCoinAllowance(\\n        address _coinAddress,\\n        address _coinHolderAddress\\n    )\\n    internal\\n    view\\n    returns (uint256);\\n\\n}\\n\"},\"ICoinExchangeRates.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\n\\ncontract ICoinExchangeRates {\\n\\n    /**\\n    * @dev Function to set CoinsPrices In USD\\n    * @param _coinsAddresses The array of addresses of stablecoins.\\n    * @param _prices The array of prices for stablecoins.\\n    * @return A boolean that indicates if the operation was successful.\\n    */\\n    function setCoinsPricesInUSD(\\n        address[] memory _coinsAddresses,\\n        uint256[] memory _prices\\n    )\\n    public\\n    returns(bool);\\n\\n    /**\\n    * @dev Function to set backed up proportions for permitted coins\\n    * @param _coinsAddresses The array of addresses of stablecoins.\\n    * @param _percentageProportion percents proportions\\n    * @return A boolean that indicates if the operation was successful.\\n    */\\n    function setCoinsCoverageProportion(\\n        address[] memory _coinsAddresses,\\n        uint256[] memory _percentageProportion\\n    )\\n    public\\n    returns(bool);\\n\\n    /**\\n       * @dev sets or unset permissions to make some actions\\n       * @param _address address stablecoin which is allowed/disalwed\\n       * @param _decimals adecimals value of stablecoin\\n       * @param _value bool sets/unsets _permission\\n    */\\n    function setPermissionsForCoins(\\n        address _address,\\n        bool _value,\\n        uint256 _decimals\\n    )\\n    public;\\n\\n    /**\\n    * @dev Function to get USD amount from converting blobs\\n    * @param _blobsAmount the amount of blobs to be converted\\n    * @return A number of coins you can receive by converting blobs\\n    */\\n    function calculateUSDByBlobs(uint256 _blobsAmount)\\n    public\\n    view\\n    returns(uint256);\\n\\n    /**\\n    * @dev Function to get amount of each stable coin based on proportion and price\\n    * which user can receive by blobs dissolveing\\n    * @param _usdAmount the amount to get stable coins\\n    * @return two arrays: stable coins and appropriate balances\\n    */\\n    function calculateCoinsAmountByUSD(\\n        uint256 _usdAmount\\n    )\\n    public\\n    view\\n    returns (address[] memory, uint256[] memory);\\n\\n    /**\\n    * @dev Function to get amount of usd by converting stable coins\\n    * @param _stableCoinAddress stable coin address\\n    * @param _coinsAmount amount of coins to exchange\\n    * @return A usd amount you can receive by exchanging coin\\n    */\\n    function calculateUsdByCoin(\\n        address _stableCoinAddress,\\n        uint256 _coinsAmount\\n    )\\n    public\\n    view\\n    returns(uint256);\\n\\n    /**\\n    * @dev Function to get amount of blobs by converting stable coins\\n    * @param _stableCoinAddress stable coin address\\n    * @param _coinsAmount amount of coins to exchange\\n    * @return A usd amount you can receive by exchanging coin\\n    */\\n    function calculateBlobsAmount(\\n        address _stableCoinAddress,\\n        uint256 _coinsAmount\\n    )\\n    public\\n    view\\n    returns (uint256);\\n\\n    /**\\n    * @dev Function to get timestamp of last price update\\n    * @param _stableCoinAddress stable coin address\\n    * @return A timestamp of last update\\n    */\\n    function coinPriceUpdatedAt(address _stableCoinAddress)\\n    public\\n    view\\n    returns(uint256);\\n\\n    /**\\n    * @dev Function to get price of stablecoin\\n    * @param _stableCoinAddress stable coin address\\n    * @return A price in usd\\n    */\\n    function getCoinPrice(address _stableCoinAddress)\\n    public\\n    view\\n    returns(uint256);\\n\\n    /**\\n    * @dev Function to return permitted coins List\\n    * @return An array of coins addresses\\n    */\\n    function permittedCoinsAddresses()\\n    public\\n    view\\n    returns (address[] memory);\\n\\n    /**\\n    * @dev Function to get price of blob coin\\n    * @return A price in usd\\n    */\\n    function blobCoinPrice()\\n    public\\n    view\\n    returns (uint256);\\n\\n    /**\\n    * @dev Function to set price in usd for exact stable coin\\n    * @param _stableCoinAddress stable coin address\\n    * @param _price coin price in usd\\n    */\\n    function setCoinPrice(address _stableCoinAddress, uint256 _price) internal;\\n\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IERC20Mintable.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n/**\\n * @title ERC20Mintable\\n * @dev ERC20 minting logic\\n */\\ncontract IERC20Mintable{\\n    /**\\n     * @dev Function to mint coins\\n     * @param to The address that will receive the minted tokens.\\n     * @param value The amount of tokens to mint.\\n     * @return A boolean that indicates if the operation was successful.\\n     */\\n    function mint(address to, uint256 value)\\n    public\\n    returns (bool);\\n}\\n\"},\"IManaged.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\n\\ncontract IManaged {\\n\\n    /**\\n       * @dev updates managed contract address\\n       * @param _management address contract address\\n   */\\n    function setManagementContract(address _management) public;\\n\\n    /**\\n       * @dev checks if address is permitted to  make an action\\n       * @param _subject address requested address\\n       * @param _permissionBit uint256 action constant value\\n       * @return true in case when address has a permision\\n   */\\n    function hasPermission(\\n        address _subject,\\n        uint256 _permissionBit\\n    )\\n    internal\\n    view\\n    returns (bool);\\n\\n}\\n\"},\"IManagement.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n\\ncontract IManagement {\\n\\n    /**\\n        * @dev sets or unset permissions to make some actions\\n        * @param _address address Address which  is allowed/disallowed to run function\\n        * @param _permission uint256 constant value describes one of the permission\\n        * @param _value bool sets/unsets _permission\\n    */\\n    function setPermission(\\n        address _address,\\n        uint256 _permission,\\n        bool _value\\n    )\\n    public;\\n\\n    /**\\n      * @dev register contract with ID\\n      * @param _key uint256 constant value, indicates the contract\\n      * @param _target address Address of the contract\\n    */\\n    function registerContract(uint256 _key, address _target) public;\\n\\n    /**\\n     * @dev updates the percentage fee amount for dissolve request\\n     * @param _valueInPercentage uint256 fee amount which  should receive Platform per each dissolve\\n    */\\n    function setFeePercentage(\\n        uint256 _valueInPercentage\\n    )\\n    public;\\n\\n    /**\\n      * @dev gets the fee percentage value for dissolve\\n      * @return uint256 the fee percentage value for dissolve\\n    */\\n    function getFeePercentage()\\n    public\\n    view\\n    returns (uint256);\\n\\n    /**\\n      * @dev checks if permissions is specified for exact address\\n      * @return bool identifier of permissions\\n    */\\n    function permissions(address _subject, uint256 _permissionBit)\\n    public\\n    view\\n    returns (bool);\\n}\\n\"},\"IOriginate.sol\":{\"content\":\"pragma solidity ^0.5.6;\\n\\n\\ncontract IOriginate {\\n\\n\\n    /**\\n       * @dev Function to perform originate and mint Blobs for requester\\n       * @param _originateId The id of Originate request\\n       * @param _stableCoinAddresses coins addresses list to exchange\\n       * @param _maxCoinsAmount max amounts for each coin allowed to exchange\\n       * @return A boolean that indicates if the operation was successful.\\n    */\\n    function externalOriginate(\\n        uint256 _originateId,\\n        address[] calldata _stableCoinAddresses,\\n        uint256[] calldata _maxCoinsAmount\\n    )\\n    external\\n    returns (bool);\\n\\n    /**\\n    * @dev Function to receive stable coin and mint blobcoins\\n    * @param _stableCoinAddresses The addresses of the coins that will be exchanged to originate blobs.\\n    * @param _values The amounts of stable coins to contribute .\\n    * @return A boolean that indicates if the operation was successful.\\n    */\\n    function createOriginateRequest(\\n        address[] memory _stableCoinAddresses,\\n        uint256[] memory _values\\n    )\\n    public\\n    returns (bool);\\n\\n    /**\\n   * @dev Function to get total and exchanged stable coin amounts per originate request\\n   * @param _originateId The id of Originate request\\n   * @param _stableCoin stable coin address to be checked\\n   * @return uint256[2] array where [0] element indicates total stablecoins to be exchanged\\n    [1] index shows the amount of already exchanged stable coin\\n   */\\n    function getStableCoinAmountsByRequestId(\\n        uint256 _originateId,\\n        address _stableCoin\\n    )\\n    public\\n    view\\n    returns (uint256[2] memory);\\n\\n    /**\\n      * @dev Function to perform originate and mint Blobs for requester\\n       * @param _originateId The id of Originate request\\n       * @param _stableCoinAddresses coins addresses list to exchange\\n       * @param _maxCoinsAmount max amounts for each coin allowed to exchange\\n    */\\n    function internalOriginate(\\n        uint256 _originateId,\\n        address[] memory _stableCoinAddresses,\\n        uint256[] memory _maxCoinsAmount\\n    )\\n    internal;\\n\\n    /**\\n    * @dev Function to validate stablecoin registry and balance allowance\\n    * @param _stableCoinAddress stable coin address to be checked\\n    * @param _value stable coin amount needs to be allowed\\n    */\\n    function internalValidateCoin(\\n        address _stableCoinAddress,\\n        uint256 _value\\n    )\\n    internal;\\n}\\n\"},\"Managed.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IManaged.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./Management.sol\\\";\\n\\ncontract Managed is IManaged, Constants, Ownable {\\n\\n    using SafeMath for uint256;\\n\\n    Management public management;\\n\\n    modifier requirePermission(uint256 _permissionBit) {\\n        require(\\n            hasPermission(msg.sender, _permissionBit),\\n            ERROR_ACCESS_DENIED\\n        );\\n        _;\\n    }\\n\\n    modifier canCallOnlyRegisteredContract(uint256 _key) {\\n        require(\\n            msg.sender == management.contractRegistry(_key),\\n            ERROR_ACCESS_DENIED\\n        );\\n        _;\\n    }\\n\\n    modifier requireContractExistsInRegistry(uint256 _key) {\\n        require(\\n            management.contractRegistry(_key) != address(0),\\n            ERROR_NO_CONTRACT\\n        );\\n        _;\\n    }\\n\\n    constructor(address _managementAddress) public {\\n        management = Management(_managementAddress);\\n    }\\n\\n    function setManagementContract(address _management) public onlyOwner {\\n        require(address(0) != _management, ERROR_ACCESS_DENIED);\\n\\n        management = Management(_management);\\n    }\\n\\n    function hasPermission(\\n        address _subject,\\n        uint256 _permissionBit\\n    )\\n    internal\\n    view\\n    returns (bool)\\n    {\\n        return management.permissions(_subject, _permissionBit);\\n    }\\n\\n}\\n\"},\"Management.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IManagement.sol\\\";\\nimport \\\"./CoinExchangeRates.sol\\\";\\nimport \\\"./Constants.sol\\\";\\n\\ncontract Management is CoinExchangeRates{\\n\\n    uint256 private feeValueInPercentage_;\\n\\n    mapping(address =\\u003e mapping(uint256 =\\u003e bool)) private permissions_;\\n\\n    mapping(uint256 =\\u003e address) public contractRegistry;\\n\\n    event PermissionsSet(address subject, uint256 permission, bool value);\\n    event ContractRegistered(uint256 key, address target);\\n    event FeeUpdated(uint256 valueInPercentage);\\n\\n    constructor(uint256 _blobCoinPrice, uint256 _feeInPercentage)\\n    public\\n    CoinExchangeRates(_blobCoinPrice)\\n    {\\n        feeValueInPercentage_ = _feeInPercentage;\\n        permissions_[msg.sender][CAN_EXCHANGE_COINS] = true;\\n        permissions_[msg.sender][CAN_REGISTER_COINS] = true;\\n        permissions_[msg.sender][CAN_MINT_COINS] = true;\\n        permissions_[msg.sender][CAN_BURN_COINS] = true;\\n        permissions_[msg.sender][CAN_LOCK_COINS] = true;\\n    }\\n\\n    function setPermission(\\n        address _address,\\n        uint256 _permission,\\n        bool _value\\n    )\\n    public\\n    onlyOwner\\n    {\\n        require(\\n            PERMITTED_COINS != _permission,\\n            ERROR_ACCESS_DENIED\\n        );\\n        permissions_[_address][_permission] = _value;\\n        emit PermissionsSet(_address, _permission, _value);\\n    }\\n\\n    function setPermissionsForCoins(\\n        address _address,\\n        bool _value,\\n        uint256 _decimals\\n    )\\n    public\\n    onlyOwner\\n    {\\n        permissions_[_address][PERMITTED_COINS] = _value;\\n        internalSetPermissionsForCoins(_address, _value, _decimals);\\n        emit PermissionsSet(_address, PERMITTED_COINS, _value);\\n    }\\n\\n    function registerContract(uint256 _key, address _target) public onlyOwner {\\n        contractRegistry[_key] = _target;\\n        emit ContractRegistered(_key, _target);\\n    }\\n\\n    function setFeePercentage(\\n        uint256 _valueInPercentage\\n    )\\n    public\\n    onlyOwner\\n    {\\n        require(_valueInPercentage \\u003c= PERCENTS_ABS_MAX, ERROR_WRONG_AMOUNT);\\n        feeValueInPercentage_ = _valueInPercentage;\\n        emit FeeUpdated(_valueInPercentage);\\n    }\\n\\n    function getFeePercentage()\\n    public\\n    view\\n    returns (uint256)\\n    {\\n        return feeValueInPercentage_;\\n    }\\n\\n    function coinsHolder()\\n    public\\n    view\\n    returns (address)\\n    {\\n        if (contractRegistry[COIN_HOLDER] != address(0)) {\\n            return contractRegistry[COIN_HOLDER];\\n        }\\n        return owner();\\n    }\\n\\n    function permissions(address _subject, uint256 _permissionBit)\\n    public\\n    view\\n    returns (bool)\\n    {\\n        return permissions_[_subject][_permissionBit];\\n    }\\n}\\n\"},\"Originate.sol\":{\"content\":\"pragma solidity ^0.5.7;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Managed.sol\\\";\\nimport \\\"./AllowanceChecker.sol\\\";\\nimport \\\"./IERC20Mintable.sol\\\";\\nimport \\\"./IOriginate.sol\\\";\\n\\n/*solium-disable-next-line*/\\ncontract Originate is Managed, IOriginate, AllowanceChecker {\\n\\n    struct Request {\\n        address requesterAddress;\\n        mapping(address =\\u003e uint256[2]) stableCoinAddressToAmount;\\n        address[] stableCoins;\\n        RequestState originateRequestState;\\n    }\\n\\n    Request[] public allOriginatesRequests;\\n\\n    event OriginateRequestCreated(\\n        uint256 _originateId,\\n        address requesterAddress,\\n        address[] stableCoins,\\n        uint256[] coinsAmount\\n    );\\n\\n    event CoinsOriginated(\\n        uint256 _originateId,\\n        address[] stableCoins,\\n        uint256[] exchangedCoinsAmount\\n    );\\n\\n    event OriginateRequestCanceled(\\n        uint256 _originateId,\\n        address requesterAddress\\n    );\\n\\n    modifier requireOriginateIdExisting(uint256 _originateId) {\\n        require(\\n            _originateId \\u003c allOriginatesRequests.length,\\n            ERROR_ACCESS_DENIED\\n        );\\n        _;\\n    }\\n\\n    modifier onlyPermittedCoin(address _stableCoinAddress) {\\n        require(\\n            true == hasPermission(\\n            _stableCoinAddress,\\n            PERMITTED_COINS\\n        ),\\n            ERROR_NOT_PERMITTED_COIN\\n        );\\n        _;\\n    }\\n\\n    constructor(address _managementAddress)\\n    public\\n    Managed(_managementAddress)\\n    {}\\n\\n    function externalOriginate(\\n        uint256 _originateId,\\n        address[] calldata _stableCoinAddresses,\\n        uint256[] calldata _maxCoinsAmount\\n    )\\n    external\\n    requirePermission(CAN_EXCHANGE_COINS)\\n    returns (bool)\\n    {\\n        internalOriginate(\\n            _originateId,\\n            _stableCoinAddresses,\\n            _maxCoinsAmount\\n        );\\n        return true;\\n    }\\n\\n    function externalMultiOriginate(\\n        uint256[] calldata _originateIds,\\n        address[] calldata _stableCoinAddresses,\\n        uint256[] calldata _maxCoinsAmount\\n    )\\n    external\\n    requirePermission(CAN_EXCHANGE_COINS)\\n    {\\n        for (uint256 i = 0; i \\u003c _originateIds.length; i++) {\\n            if (\\n                allOriginatesRequests[_originateIds[i]].originateRequestState != RequestState.PaidPartially \\u0026\\u0026\\n                allOriginatesRequests[_originateIds[i]].originateRequestState != RequestState.Pending\\n            ) {\\n                continue;\\n            }\\n            internalOriginate(\\n                _originateIds[i],\\n                _stableCoinAddresses,\\n                _maxCoinsAmount\\n            );\\n        }\\n    }\\n\\n    function createOriginateRequest(\\n        address[] memory _stableCoinAddresses,\\n        uint256[] memory _values\\n    )\\n    public\\n    requireContractExistsInRegistry(CONTRACT_TOKEN)\\n    returns (bool)\\n    {\\n        require(\\n            _stableCoinAddresses.length == _values.length,\\n            ERROR_WRONG_AMOUNT\\n        );\\n        allOriginatesRequests.push(\\n            Request(\\n                {\\n                requesterAddress : msg.sender,\\n                originateRequestState : RequestState.Pending,\\n                stableCoins : _stableCoinAddresses\\n                }\\n            )\\n        );\\n        Request storage request = allOriginatesRequests[\\n        allOriginatesRequests.length.sub(1)\\n        ];\\n        for (uint256 i = 0; i \\u003c _stableCoinAddresses.length; i++) {\\n            internalValidateCoin(_stableCoinAddresses[i], _values[i]);\\n            request.stableCoinAddressToAmount[\\n            _stableCoinAddresses[i]\\n            ] = [\\n            _values[i],\\n            0\\n            ];\\n        }\\n        emit OriginateRequestCreated(\\n            allOriginatesRequests.length.sub(1),\\n            msg.sender,\\n            _stableCoinAddresses,\\n            _values\\n        );\\n        for (uint256 i = 0; i \\u003c _stableCoinAddresses.length; i++) {\\n            IERC20(_stableCoinAddresses[i]).transferFrom(\\n                msg.sender,\\n                address(this),\\n                _values[i]\\n            );\\n        }\\n        return true;\\n    }\\n\\n    function cancelOriginateRequest(\\n        uint256 _originateRequestId\\n    )\\n    public\\n    requireOriginateIdExisting(_originateRequestId)\\n    returns (bool)\\n    {\\n        Request storage request = allOriginatesRequests[_originateRequestId];\\n        require(request.requesterAddress == msg.sender, ERROR_ACCESS_DENIED);\\n        require(\\n            request.originateRequestState == RequestState.Pending,\\n            ERROR_ACCESS_DENIED\\n        );\\n        request.originateRequestState = RequestState.Canceled;\\n\\n        emit OriginateRequestCanceled(\\n            _originateRequestId,\\n            msg.sender\\n        );\\n        for (uint256 i = 0; i \\u003c request.stableCoins.length; i++) {\\n            IERC20(request.stableCoins[i]).transfer(\\n                msg.sender,\\n                request.stableCoinAddressToAmount[request.stableCoins[i]][0]\\n            );\\n        }\\n        return true;\\n    }\\n\\n    function getStableCoinAmountsByRequestId(\\n        uint256 _originateId,\\n        address _stableCoin\\n    )\\n    public\\n    view\\n    returns (uint256[2] memory)\\n    {\\n        Request storage request = allOriginatesRequests[_originateId];\\n        return request.stableCoinAddressToAmount[_stableCoin];\\n    }\\n\\n    function getStableCoinsAddressesByRequestId(\\n        uint256 _originateId\\n    )\\n    public\\n    view\\n    returns (address[] memory)\\n    {\\n        Request storage request = allOriginatesRequests[_originateId];\\n        return request.stableCoins;\\n    }\\n\\n    function internalOriginate(\\n        uint256 _originateId,\\n        address[] memory _stableCoinAddresses,\\n        uint256[] memory _maxCoinsAmount\\n    )\\n    internal\\n    requireOriginateIdExisting(_originateId)\\n    {\\n        require(\\n            _maxCoinsAmount.length == _stableCoinAddresses.length,\\n            ERROR_WRONG_AMOUNT\\n        );\\n        Request storage request = allOriginatesRequests[_originateId];\\n        bool originated;\\n        uint256 usdAmount;\\n\\n        for (uint256 i = 0; i \\u003c _stableCoinAddresses.length; i++) {\\n            requirePermittedCoin(_stableCoinAddresses[i]);\\n\\n            uint256[2] memory coinAmounts = request.stableCoinAddressToAmount[\\n            _stableCoinAddresses[i]\\n            ];\\n            uint256 amountToExchange = coinAmounts[0].sub(coinAmounts[1]);\\n            if (_maxCoinsAmount[i] \\u003c amountToExchange) {\\n                amountToExchange = _maxCoinsAmount[i];\\n            }\\n            coinAmounts[1] = coinAmounts[1].add(amountToExchange);\\n            if (\\n                coinAmounts[0] \\u003e coinAmounts[1] ||\\n                (i \\u003e 0 \\u0026\\u0026 false == originated)\\n            ) {\\n                originated = false;\\n            } else {\\n                originated = true;\\n            }\\n\\n            usdAmount = usdAmount.add(\\n                management.calculateUsdByCoin(\\n                    _stableCoinAddresses[i],\\n                    amountToExchange\\n                )\\n            );\\n            IERC20(_stableCoinAddresses[i]).transfer(\\n                management.coinsHolder(),\\n                amountToExchange\\n            );\\n        }\\n        internalMintBlobsByUSD(\\n            request.requesterAddress,\\n            usdAmount\\n        );\\n        if (false == originated) {\\n            request.originateRequestState = RequestState.PaidPartially;\\n        } else {\\n            request.originateRequestState = RequestState.FullyPaid;\\n        }\\n\\n        emit CoinsOriginated(\\n            _originateId,\\n            _stableCoinAddresses,\\n            _maxCoinsAmount\\n        );\\n    }\\n\\n    function internalMintBlobsByUSD(\\n        address _holderAddress,\\n        uint256 _usdAmount\\n    )\\n    internal\\n    {\\n        IERC20Mintable(\\n            management.contractRegistry(CONTRACT_TOKEN)\\n        ).mint(\\n            _holderAddress,\\n            (_usdAmount).div(management.blobCoinPrice())\\n        );\\n    }\\n\\n    function requirePermittedCoin(address _stableCoinAddress)\\n    internal\\n    onlyPermittedCoin(_stableCoinAddress)\\n    {\\n\\n    }\\n\\n    function internalValidateCoin(address _stableCoinAddress, uint256 _value)\\n    internal\\n    requireAllowance(\\n        _stableCoinAddress,\\n        msg.sender,\\n        _value\\n    )\\n    onlyPermittedCoin(_stableCoinAddress)\\n    {}\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n    * @dev Multiplies two unsigned integers, reverts on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two unsigned integers, reverts on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_WITHDRAW\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stableCoinAddresses\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"createOriginateRequest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERMITTED_COINS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_management\",\"type\":\"address\"}],\"name\":\"setManagementContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CAN_BURN_COINS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CAN_LOCK_COINS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CAN_REGISTER_COINS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USD_PRECISION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_originateId\",\"type\":\"uint256\"},{\"name\":\"_stableCoin\",\"type\":\"address\"}],\"name\":\"getStableCoinAmountsByRequestId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERROR_BALANCE_IS_NOT_ALLOWED\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_originateId\",\"type\":\"uint256\"},{\"name\":\"_stableCoinAddresses\",\"type\":\"address[]\"},{\"name\":\"_maxCoinsAmount\",\"type\":\"uint256[]\"}],\"name\":\"externalOriginate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CAN_MINT_COINS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allOriginatesRequests\",\"outputs\":[{\"name\":\"requesterAddress\",\"type\":\"address\"},{\"name\":\"originateRequestState\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERROR_NOT_AVAILABLE\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_originateIds\",\"type\":\"uint256[]\"},{\"name\":\"_stableCoinAddresses\",\"type\":\"address[]\"},{\"name\":\"_maxCoinsAmount\",\"type\":\"uint256[]\"}],\"name\":\"externalMultiOriginate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_EXCHANGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_originateRequestId\",\"type\":\"uint256\"}],\"name\":\"cancelOriginateRequest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COIN_HOLDER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CAN_EXCHANGE_COINS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERROR_COIN_REGISTERED\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERROR_WRONG_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERCENTS_ABS_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERROR_NOT_PERMITTED_COIN\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERROR_NO_CONTRACT\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_originateId\",\"type\":\"uint256\"}],\"name\":\"getStableCoinsAddressesByRequestId\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERROR_ACCESS_DENIED\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_managementAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_originateId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requesterAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stableCoins\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"coinsAmount\",\"type\":\"uint256[]\"}],\"name\":\"OriginateRequestCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_originateId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stableCoins\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"exchangedCoinsAmount\",\"type\":\"uint256[]\"}],\"name\":\"CoinsOriginated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_originateId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requesterAddress\",\"type\":\"address\"}],\"name\":\"OriginateRequestCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Originate","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000cfbe8899fd873cb19539b58211a9120dc0306897","Library":"","SwarmSource":"bzzr://9c4e5fb54f3005ead1bcfd008e818a970b524eb7b0ef02a1f37e7098051b8e80"}]}