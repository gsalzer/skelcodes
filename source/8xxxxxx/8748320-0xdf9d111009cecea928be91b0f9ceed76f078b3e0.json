{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.12;\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ncontract PauserRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event PauserAdded(address indexed account);\r\n    event PauserRemoved(address indexed account);\r\n\r\n    Roles.Role private _pausers;\r\n\r\n    constructor () internal {\r\n        _addPauser(msg.sender);\r\n    }\r\n\r\n    modifier onlyPauser() {\r\n        require(isPauser(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isPauser(address account) public view returns (bool) {\r\n        return _pausers.has(account);\r\n    }\r\n\r\n    function addPauser(address account) public onlyPauser {\r\n        _addPauser(account);\r\n    }\r\n\r\n    function renouncePauser() public {\r\n        _removePauser(msg.sender);\r\n    }\r\n\r\n    function _addPauser(address account) internal {\r\n        _pausers.add(account);\r\n        emit PauserAdded(account);\r\n    }\r\n\r\n    function _removePauser(address account) internal {\r\n        _pausers.remove(account);\r\n        emit PauserRemoved(account);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @return true if the contract is paused, false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyPauser whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\ncontract CheezyExchangeAdmin is Ownable, Pausable, ReentrancyGuard {\r\n\r\n    /* ****** */\r\n    /* EVENTS */\r\n    /* ****** */\r\n\r\n    /// @notice This event is fired when the developer changes the fee applied\r\n    ///  to successful trades. The fee is measured in basis points (hundredths\r\n    ///  of a percent).\r\n    /// @param newSuccessfulTradeFeeInBasisPoints  The new fee applying to\r\n    ///  successful trades (measured in basis points/hundredths of a percent).\r\n    event SuccessfulTradeFeeInBasisPointsUpdated(uint256 newSuccessfulTradeFeeInBasisPoints);\r\n\r\n    /* ******* */\r\n    /* STORAGE */\r\n    /* ******* */\r\n\r\n    /// @notice The amount of fees collected (in wei). This includes both fees to\r\n    ///  the contract owner and fees to any referrers. Storing earnings saves\r\n    ///  gas rather than performing an additional transfer() call on every\r\n    ///  successful trade.\r\n    mapping (address => uint256) public addressToFeeEarnings;\r\n\r\n    /// @notice If a trade is successfully fulfilled, this fee applies before\r\n    ///  the remaining funds are sent to the seller. This fee is measured in\r\n    ///  basis points (hundredths of a percent), and is taken out of the total\r\n    ///  value that the seller asked for when creating their order.\r\n    uint256 public successfulTradeFeeInBasisPoints = 375;\r\n\r\n    /* ********* */\r\n    /* CONSTANTS */\r\n    /* ********* */\r\n\r\n    /// @notice The address of Core CheezeWizards contract, handling the ownership\r\n    ///  and approval logic for any particular wizard.\r\n    address public wizardGuildAddress = 0x35B7838dd7507aDA69610397A85310AE0abD5034;\r\n\r\n    /* ********* */\r\n    /* FUNCTIONS */\r\n    /* ********* */\r\n\r\n    /// @dev The owner is not capable of changing the address of the\r\n    ///  CheezeWizards Core contract once the contract has been deployed.\r\n    constructor() internal {\r\n\r\n    }\r\n\r\n    /// @notice Sets the successfulTradeFeeInBasisPoints value (in basis\r\n    ///  points). Any trades that are successfully fulfilled will have this fee\r\n    ///  deducted from amount sent to the seller.\r\n    /// @dev Only callable by the owner.\r\n    /// @dev As this configuration is a basis point, the value to set must be\r\n    ///  less than or equal to 10000.\r\n    /// @param _newSuccessfulTradeFeeInBasisPoints  The\r\n    ///  successfulTradeFeeInBasisPoints value to set (measured in basis\r\n    ///  points).\r\n    function setSuccessfulTradeFeeInBasisPoints(uint256 _newSuccessfulTradeFeeInBasisPoints) external onlyOwner {\r\n        require(_newSuccessfulTradeFeeInBasisPoints <= 10000, 'new successful trade fee must be in basis points (hundredths of a percent), not wei');\r\n        successfulTradeFeeInBasisPoints = _newSuccessfulTradeFeeInBasisPoints;\r\n        emit SuccessfulTradeFeeInBasisPointsUpdated(_newSuccessfulTradeFeeInBasisPoints);\r\n    }\r\n\r\n    /// @notice Withdraws the fees that have been earned by either the contract\r\n    ///  owner or referrers.\r\n    /// @notice Only callable by the address that had earned the fees.\r\n    function withdrawFeeEarningsForAddress() external nonReentrant {\r\n        uint256 balance = addressToFeeEarnings[msg.sender];\r\n        require(balance > 0, 'there are no fees to withdraw for this address');\r\n        addressToFeeEarnings[msg.sender] = 0;\r\n        msg.sender.transfer(balance);\r\n    }\r\n\r\n    /// @notice Gives the authority for the contract owner to remove any\r\n    ///  additional accounts that have been granted the ability to pause the\r\n    ///  contract\r\n    /// @dev Only callable by the owner.\r\n    /// @param _account  The account to have the ability to pause the contract\r\n    ///  revoked\r\n    function removePauser(address _account) external onlyOwner {\r\n        _removePauser(_account);\r\n    }\r\n\r\n    /// @dev By calling 'revert' in the fallback function, we prevent anyone\r\n    ///  from accidentally sending funds directly to this contract.\r\n    function() external payable {\r\n        revert();\r\n    }\r\n}\r\n\r\n/// @title Interface for interacting with the CheezeWizards Core contract\r\n///  created by Dapper Labs Inc.\r\ncontract WizardGuild {\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n    function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\r\n}\r\n\r\n/// @title Interface for interacting with the BasicTournament contract created\r\n///  by Dapper Labs Inc.\r\ncontract BasicTournament {\r\n    function getWizard(uint256 wizardId) public view returns(\r\n        uint256 affinity,\r\n        uint256 power,\r\n        uint256 maxPower,\r\n        uint256 nonce,\r\n        bytes32 currentDuel,\r\n        bool ascending,\r\n        uint256 ascensionOpponent,\r\n        bool molded,\r\n        bool ready\r\n    );\r\n    function giftPower(uint256 sendingWizardId, uint256 receivingWizardId) external;\r\n}\r\n\r\n/// @title Main contract for CheezyExchange. This contract manages the creation,\r\n///  editing, and fulfillment of trades of CheezeWizard power only, not the NFT\r\n///  itself.\r\n/// @notice Consider each CheezeWizard NFT as a vessel that holds power. This\r\n///  contract allows a seller to list their Wizard's power for a specified\r\n///  price. If a buyer accepts their order, then they pay the specified price\r\n///  multiplied by the amount of power that the Wizard has, and all of the\r\n///  wizard's power is transferred from the seller's wizard to the buyer's\r\n///  wizard. This leaves the seller's wizard with no power, but the seller\r\n///  still possesses the wizard NFT.\r\n/// @notice Power is tournament-specific. Multiple CheezeWizard tournaments can\r\n///  exist, even at the same time. A single wizard can be entered into\r\n///  multiple tournaments at once, and can have different power levels in each\r\n///  tournament. This contract contains a different orderbook for each\r\n///  tournament. This means that this contract can simultaneously accept orders\r\n///  for multiple tournaments at the same time, even for the same wizard.\r\ncontract CheezyExchange is CheezyExchangeAdmin {\r\n\r\n    // OpenZeppelin's SafeMath library is used for all arithmetic operations to\r\n    // avoid overflows/underflows.\r\n    using SafeMath for uint256;\r\n\r\n\t/* ********** */\r\n    /* DATA TYPES */\r\n    /* ********** */\r\n\r\n    /// @notice The main Order struct. The struct fits into two 256-bit words\r\n    ///  due to Solidity's rules for struct packing, saving gas.\r\n    struct Order {\r\n        // The tokenId for the seller's wizard. This is the wizard that will\r\n        // relinquish its power if an order is fulfilled.\r\n        uint256 wizardId;\r\n        // An order creator specifies how much wei they are willing to sell\r\n        // their wizard's power for. Note that this price is per-power, so\r\n        // the buyer will actually have to pay this price multiplied by the\r\n        // amount of power that the wizard has.\r\n        uint128 pricePerPower;\r\n        // The address of the creator of the order, the seller, the owner\r\n        // of the wizard whose power will be relinquished.\r\n\t\taddress makerAddress;\r\n        // The address of the tournament that this order pertains to. Note that\r\n        // each Wizard has an independent power value for each tournament, and\r\n        // call sell each one separately, so orders can exist simultaneously\r\n        // for the same wizard for different tournaments.\r\n\t\taddress basicTournamentAddress;\r\n        // We save the dev fee at the time of order creation. This prevents an\r\n        // attack where the dev could frontrun an order acceptance with a\r\n        // change to the dev fee.\r\n        uint16 savedSuccessfulTradeFeeInBasisPoints;\r\n    }\r\n\r\n    /* ****** */\r\n    /* EVENTS */\r\n    /* ****** */\r\n\r\n    /// @notice This event is fired a user creates an order selling their wizard's\r\n    ///  power, but not the NFT itself.\r\n    /// @param wizardId  The tokenId for the seller's wizard. This is the\r\n    ///  wizard that will relinquish its power if an order is fulfilled.\r\n    /// @param pricePerPower  An order creator specifies how much wei they are\r\n    ///  willing to sell their wizard's power for. Note that this price is\r\n    ///  per-power, so the buyer will actually have to pay this price\r\n    ///  multiplied by the amount of power that the wizard has.\r\n    /// @param makerAddress  The address of the creator of the order, the\r\n    ///  seller, the owner of the wizard whose power will be relinquished.\r\n    /// @param basicTournamentAddress  The address of the tournament that this\r\n    ///  order pertains to. Note that each Wizard has an independent power\r\n    ///  value for each tournament, and call sell each one separately, so\r\n    ///  orders can exist simultaneously for the same wizard for different\r\n    ///  tournaments.\r\n    /// @param savedSuccessfulTradeFeeInBasisPoints  We save the dev fee at the\r\n    ///  time of order creation. This prevents an attack where the dev could\r\n    ///  frontrun an order acceptance with a change to the dev fee.\r\n    event CreateSellOrder(\r\n    \tuint256 wizardId,\r\n        uint256 pricePerPower,\r\n\t\taddress makerAddress,\r\n        address basicTournamentAddress,\r\n        uint256 savedSuccessfulTradeFeeInBasisPoints\r\n    );\r\n\r\n    /// @notice This event is fired a user updates an existing order to have a\r\n    ///  different pricePerPower. It saves a small amount of gas to only change\r\n    ///  that one part of the oder.\r\n    /// @param wizardId  The tokenId for the seller's wizard. This is the\r\n    ///  wizard that will relinquish its power if an order is fulfilled.\r\n    /// @param oldPricePerPower  This is the old pricePerPower, the price that\r\n    ///  is being replaced in this update() call. An order creator specifies\r\n    ///  how much wei they are willing to sell their wizard's power for. Note\r\n    ///  that this price is per-power, so the buyer will actually have to pay\r\n    ///  this price multiplied by the amount of power that the wizard has.\r\n    /// @param newPricePerPower  This is the new pricePerPower, the price that\r\n    ///  will now be valid after this update() call. An order creator specifies\r\n    ///  how much wei they are willing to sell their wizard's power for. Note\r\n    ///  that this price is per-power, so the buyer will actually have to pay\r\n    ///  this price multiplied by the amount of power that the wizard has.\r\n    /// @param makerAddress  The address of the creator of the order, the\r\n    ///  seller, the owner of the wizard whose power will be relinquished.\r\n    /// @param basicTournamentAddress  The address of the tournament that this\r\n    ///  order pertains to. Note that each Wizard has an independent power\r\n    ///  value for each tournament, and call sell each one separately, so\r\n    ///  orders can exist simultaneously for the same wizard for different\r\n    ///  tournaments.\r\n    /// @param savedSuccessfulTradeFeeInBasisPoints  We save the dev fee at the\r\n    ///  time of order creation. This prevents an attack where the dev could\r\n    ///  frontrun an order acceptance with a change to the dev fee.\r\n    event UpdateSellOrder(\r\n    \tuint256 wizardId,\r\n        uint256 oldPricePerPower,\r\n        uint256 newPricePerPower,\r\n\t\taddress makerAddress,\r\n        address basicTournamentAddress,\r\n        uint256 savedSuccessfulTradeFeeInBasisPoints\r\n    );\r\n\r\n    /// @notice This event is fired a user cancels an existing order. It is also\r\n    ///  fired when a user calls createSellOrder() for a wizard that already\r\n    ///  has a (potentially invalid) order on the books.\r\n    /// @dev The reason that this contract emits the CancelSellOrder event\r\n    ///  when a user calls createSellOrder() for a wizard that already\r\n    ///  has a (potentially invalid) order on the books is illustrated by the\r\n    ///  following scenario: if Alice creates an order for Wizard1 on this\r\n    ///  contract, but then sells Wizard1 to Bob, then this contract will still\r\n    ///  have an order on the books for Wizard1. However, this contract will\r\n    ///  not allow that order to be fulfilled, since the owner of Wizard1 has\r\n    ///  changed, and this contract will only view an order as valid if the\r\n    ///  wizard is still owned by the original order creator. Thus, if Bob is\r\n    ///  now trying to create a sell order for Wizard1, we need to delete\r\n    ///  Alice's old order.\r\n    /// @param wizardId  The tokenId for the seller's wizard. This is the\r\n    ///  wizard that will relinquish its power if an order is fulfilled.\r\n    /// @param pricePerPower  An order creator specifies how much wei they are\r\n    ///  willing to sell their wizard's power for. Note that this price is\r\n    ///  per-power, so the buyer will actually have to pay this price\r\n    ///  multiplied by the amount of power that the wizard has.\r\n    /// @param makerAddress  The address of the creator of the order, the\r\n    ///  seller, the owner of the wizard whose power will be relinquished.\r\n    /// @param basicTournamentAddress  The address of the tournament that this\r\n    ///  order pertains to. Note that each Wizard has an independent power\r\n    ///  value for each tournament, and call sell each one separately, so\r\n    ///  orders can exist simultaneously for the same wizard for different\r\n    ///  tournaments.\r\n    /// @param savedSuccessfulTradeFeeInBasisPoints  We save the dev fee at the\r\n    ///  time of order creation. This prevents an attack where the dev could\r\n    ///  frontrun an order acceptance with a change to the dev fee.\r\n    event CancelSellOrder(\r\n    \tuint256 wizardId,\r\n        uint256 pricePerPower,\r\n\t\taddress makerAddress,\r\n        address basicTournamentAddress,\r\n        uint256 savedSuccessfulTradeFeeInBasisPoints\r\n    );\r\n\r\n    /// @notice This event is fired a buyer successfully fills a seller's order.\r\n    /// @param makerWizardId  The tokenId for the seller's wizard. This is the\r\n    ///  wizard that will relinquish its power if an order is fulfilled.\r\n    /// @param takerWizardId  The tokenId for the buyer's wizard. This is the\r\n    ///  wizard that will receive its power if an order is fulfilled.\r\n    /// @param pricePerPower  An order creator specifies how much wei they are\r\n    ///  willing to sell their wizard's power for. Note that this price is\r\n    ///  per-power, so the buyer will actually have to pay this price\r\n    ///  multiplied by the amount of power that the wizard has.\r\n    /// @param makerAddress  The address of the creator of the order, the\r\n    ///  seller, the owner of the wizard whose power will be relinquished.\r\n    /// @param takerAddress  The address of the fulfiller of the order, the\r\n    ///  buyer, the owner of the wizard who will receive power.\r\n    /// @param basicTournamentAddress  The address of the tournament that this\r\n    ///  order pertains to. Note that each Wizard has an independent power\r\n    ///  value for each tournament, and call sell each one separately, so\r\n    ///  orders can exist simultaneously for the same wizard for different\r\n    ///  tournaments.\r\n    /// @param savedSuccessfulTradeFeeInBasisPoints  We save the dev fee at the\r\n    ///  time of order creation. This prevents an attack where the dev could\r\n    ///  frontrun an order acceptance with a change to the dev fee.\r\n    event FillSellOrder(\r\n    \tuint256 makerWizardId,\r\n        uint256 takerWizardId,\r\n        uint256 pricePerPower,\r\n\t\taddress makerAddress,\r\n        address takerAddress,\r\n        address basicTournamentAddress,\r\n        uint256 savedSuccessfulTradeFeeInBasisPoints\r\n    );\r\n\r\n    /* ******* */\r\n    /* STORAGE */\r\n    /* ******* */\r\n\r\n    /// @notice A mapping that tracks current order structs, indexed first by\r\n    ///  tournament address and then by wizardId.\r\n    /// @dev This contract is generalized to accept orders for multiple\r\n    ///  cheezewizard tournaments, potentially simultaneously, potentially even\r\n    ///  for the same wizard. This is because power is tournament-specific, so\r\n    ///  the same wizard can have different amounts of power in different\r\n    ///  tournaments.\r\n    mapping(address => mapping(uint256 => Order)) internal orderForWizardIdAndTournamentAddress;\r\n\r\n    /// @notice A simple ticker keeping track of the pricePerPower of the last\r\n    ///  successful sale for this particular tournament. This could be useful\r\n    ///  for displaying on a frontend UI as a guide for new orders, or the\r\n    ///  current state of the market.\r\n    mapping(address => uint256) public lastSuccessfulPricePerPowerForTournamentAddress;\r\n\r\n    /* ********* */\r\n    /* FUNCTIONS */\r\n    /* ********* */\r\n\r\n    /// @notice After calling approve() in the CheezeWizards Core contract\r\n    ///  (called WizardGuild.sol), a seller can post an order to sell the power\r\n    ///  of one of their wizards for a particular tournament (found in the\r\n    ///  contract BasicTournament.sol). Note that this only sells the wizard's\r\n    ///  power, but the seller will retain the NFT itself.\r\n    /// @dev The reason that this contract emits the CancelSellOrder event\r\n    ///  when a user calls createSellOrder() for a wizard that already\r\n    ///  has a (potentially invalid) order on the books is illustrated by the\r\n    ///  following scenario: if Alice creates an order for Wizard1 on this\r\n    ///  contract, but then sells Wizard1 to Bob, then this contract will still\r\n    ///  have an order on the books for Wizard1. However, this contract will\r\n    ///  not allow that order to be fulfilled, since the owner of Wizard1 has\r\n    ///  changed, and this contract will only view an order as valid if the\r\n    ///  wizard is still owned by the original order creator. Thus, if Bob is\r\n    ///  now trying to create a sell order for Wizard1, we need to delete\r\n    ///  Alice's old order.\r\n    /// @param _wizardId  The tokenId for the seller's wizard. This is the\r\n    ///  wizard that will relinquish its power if an order is fulfilled.\r\n    /// @param _pricePerPower  An order creator specifies how much wei they are\r\n    ///  willing to sell their wizard's power for. Note that this price is\r\n    ///  per-power, so the buyer will actually have to pay this price\r\n    ///  multiplied by the amount of power that the wizard has.\r\n    /// @param _basicTournamentAddress  The address of the tournament that this\r\n    ///  order pertains to. Note that each Wizard has an independent power\r\n    ///  value for each tournament, and call sell each one separately, so\r\n    ///  orders can exist simultaneously for the same wizard for different\r\n    ///  tournaments.\r\n    function createSellOrder(uint256 _wizardId, uint256 _pricePerPower, address _basicTournamentAddress) external whenNotPaused nonReentrant {\r\n        require(WizardGuild(wizardGuildAddress).ownerOf(_wizardId) == msg.sender, 'only the owner of the wizard can create a sell order');\r\n        require(WizardGuild(wizardGuildAddress).isApprovedOrOwner(address(this), _wizardId), 'you must call the approve() function on WizardGuild before you can create a sell order');\r\n        require(_pricePerPower <= uint256(~uint128(0)), 'you cannot specify a _pricePerPower greater than uint128_max');\r\n\r\n        // Fetch wizard's stats from BasicTournament contract\r\n        bool molded;\r\n        bool ready;\r\n        ( , , , , , , , molded, ready) = BasicTournament(_basicTournamentAddress).getWizard(_wizardId);\r\n        require(molded == false, 'you cannot sell the power from a molded wizard');\r\n        require(ready == true, 'you cannot sell the power from a wizard that is not ready');\r\n\r\n        Order memory previousOrder = orderForWizardIdAndTournamentAddress[_basicTournamentAddress][_wizardId];\r\n\r\n        // Check if an order already exists for this wizard within this\r\n        // tournament\r\n        if(previousOrder.makerAddress != address(0)){\r\n            // If an order already exists, delete it before we create a new one\r\n            emit CancelSellOrder(\r\n                uint256(previousOrder.wizardId),\r\n                uint256(previousOrder.pricePerPower),\r\n                previousOrder.makerAddress,\r\n                previousOrder.basicTournamentAddress,\r\n                uint256(previousOrder.savedSuccessfulTradeFeeInBasisPoints)\r\n            );\r\n            delete orderForWizardIdAndTournamentAddress[_basicTournamentAddress][_wizardId];\r\n        }\r\n\r\n        // Save the new order to storage\r\n        Order memory order = Order({\r\n            wizardId: uint256(_wizardId),\r\n            pricePerPower: uint128(_pricePerPower),\r\n            makerAddress: msg.sender,\r\n            basicTournamentAddress: _basicTournamentAddress,\r\n            savedSuccessfulTradeFeeInBasisPoints: uint16(successfulTradeFeeInBasisPoints)\r\n        });\r\n        orderForWizardIdAndTournamentAddress[_basicTournamentAddress][_wizardId] = order;\r\n        emit CreateSellOrder(\r\n            _wizardId,\r\n            _pricePerPower,\r\n            msg.sender,\r\n            _basicTournamentAddress,\r\n            successfulTradeFeeInBasisPoints\r\n        );\r\n    }\r\n\r\n    /// @notice A seller/maker calls this function to update the pricePerPower\r\n    ///  of an order that they already have stored in this contract. This saves\r\n    ///  some gas for the seller by allowing them to just update the\r\n    ///  pricePerPower parameter of their order.\r\n    /// @param _wizardId  The tokenId for the seller's wizard. This is the\r\n    ///  wizard that will relinquish its power if an order is fulfilled.\r\n    /// @param _newPricePerPower  An order creator specifies how much wei they\r\n    ///  are willing to sell their wizard's power for. Note that this price is\r\n    ///  per-power, so the buyer will actually have to pay this price\r\n    ///  multiplied by the amount of power that the wizard has.\r\n    /// @param _basicTournamentAddress  The address of the tournament that this\r\n    ///  order pertains to. Note that each Wizard has an independent power\r\n    ///  value for each tournament, and call sell each one separately, so\r\n    ///  orders can exist simultaneously for the same wizard for different\r\n    ///  tournaments.\r\n    function updateSellOrder(uint256 _wizardId, uint256 _newPricePerPower, address _basicTournamentAddress) external whenNotPaused nonReentrant {\r\n        require(WizardGuild(wizardGuildAddress).ownerOf(_wizardId) == msg.sender, 'only the owner of the wizard can update a sell order');\r\n        require(WizardGuild(wizardGuildAddress).isApprovedOrOwner(address(this), _wizardId), 'you must call the approve() function on WizardGuild before you can update a sell order');\r\n        require(_newPricePerPower <= uint256(~uint128(0)), 'you cannot specify a _newPricePerPower greater than uint128_max');\r\n\r\n        // Fetch order\r\n        Order storage order = orderForWizardIdAndTournamentAddress[_basicTournamentAddress][_wizardId];\r\n\r\n        // Check that order is not from a previous owner\r\n        require(msg.sender == order.makerAddress, 'you can only update a sell order that you created');\r\n\r\n        // Emit event\r\n        emit UpdateSellOrder(\r\n            _wizardId,\r\n            uint256(order.pricePerPower),\r\n            _newPricePerPower,\r\n            msg.sender,\r\n            _basicTournamentAddress,\r\n            uint256(order.savedSuccessfulTradeFeeInBasisPoints)\r\n        );\r\n\r\n        // Update price\r\n        order.pricePerPower = uint128(_newPricePerPower);\r\n    }\r\n\r\n    /// @notice A seller/maker calls this function to cancel an existing order\r\n    ///  that they have posted to this contract.\r\n    /// @dev Unlike the other Order functions, this function can be called even\r\n    ///  if the contract is paused, so that users can clear out their orderbook\r\n    ///  if they would like.\r\n    /// @param _wizardId  The tokenId for the seller's wizard. This is the\r\n    ///  wizard that will relinquish its power if an order is fulfilled.\r\n    /// @param _basicTournamentAddress  The address of the tournament that this\r\n    ///  order pertains to. Note that each Wizard has an independent power\r\n    ///  value for each tournament, and call sell each one separately, so\r\n    ///  orders can exist simultaneously for the same wizard for different\r\n    ///  tournaments.\r\n    function cancelSellOrder(uint256 _wizardId, address _basicTournamentAddress) external nonReentrant {\r\n        require(WizardGuild(wizardGuildAddress).ownerOf(_wizardId) == msg.sender, 'only the owner of the wizard can cancel a sell order');\r\n\r\n        // Wait until after emitting event to delete order so that event data\r\n        // can be pulled from soon-to-be-deleted order\r\n        Order memory order = orderForWizardIdAndTournamentAddress[_basicTournamentAddress][_wizardId];\r\n        emit CancelSellOrder(\r\n            uint256(order.wizardId),\r\n            uint256(order.pricePerPower),\r\n            msg.sender,\r\n            _basicTournamentAddress,\r\n            uint256(order.savedSuccessfulTradeFeeInBasisPoints)\r\n        );\r\n\r\n        // Delete order\r\n        delete orderForWizardIdAndTournamentAddress[_basicTournamentAddress][_wizardId];\r\n    }\r\n\r\n    /// @notice A buyer/taker calls this function to complete an order, paying\r\n    ///  pricePerPower multiplied by the makerWizard's current power in order\r\n    ///  to transfer the makerWizard's power to the takerWizard.\r\n    /// @dev The buyer/taker must send enough wei along with this function call\r\n    ///  to cover pricePerPower multiplied by the makerWizard's current power.\r\n    /// @param _makerWizardId  The tokenId for the seller's wizard. This is the\r\n    ///  wizard that will relinquish its power if an order is fulfilled.\r\n    /// @param _takerWizardId  The tokenId for the buyer's wizard. This is the\r\n    ///  wizard that will receive its power if an order is fulfilled.\r\n    /// @param _basicTournamentAddress  The address of the tournament that this\r\n    ///  order pertains to. Note that each Wizard has an independent power\r\n    ///  value for each tournament, and call sell each one separately, so\r\n    ///  orders can exist simultaneously for the same wizard for different\r\n    ///  tournaments.\r\n    /// @param _referrer  This address gets half of the successful trade fees.\r\n    ///  This encourages third party developers to develop their own front-end\r\n    ///  UI's for this contract in order to receive half of the rewards.\r\n    function fillSellOrder(uint256 _makerWizardId, uint256 _takerWizardId, address _basicTournamentAddress, address _referrer) external payable whenNotPaused nonReentrant {\r\n        require(WizardGuild(wizardGuildAddress).ownerOf(_takerWizardId) == msg.sender, 'you can only purchase power for a wizard that you own');\r\n        Order memory order = orderForWizardIdAndTournamentAddress[_basicTournamentAddress][_makerWizardId];\r\n        require(WizardGuild(wizardGuildAddress).ownerOf(_makerWizardId) == order.makerAddress, 'an order is only valid while the order creator owns the wizard');\r\n\r\n        // Fetch wizard's stats from BasicTournament contract\r\n        uint256 power;\r\n        bool molded;\r\n        bool ready;\r\n        ( , power, , , , , , molded, ready) = BasicTournament(_basicTournamentAddress).getWizard(_makerWizardId);\r\n        require(molded == false, 'you cannot sell the power from a molded wizard');\r\n        require(ready == true, 'you cannot sell the power from a wizard that is not ready');\r\n\r\n        // Update the global ticker for the last successful pricePerPower sale\r\n        // price\r\n        lastSuccessfulPricePerPowerForTournamentAddress[_basicTournamentAddress] = uint256(order.pricePerPower);\r\n\r\n        // Calculate seller proceeds and contractCreator fees\r\n        uint256 priceToFillOrder = (uint256(order.pricePerPower)).mul(power);\r\n        require(msg.value >= priceToFillOrder, 'you did not send enough wei to fulfill this order');\r\n        uint256 sellerProceeds = _computeSellerProceeds(priceToFillOrder, uint256(order.savedSuccessfulTradeFeeInBasisPoints));\r\n        uint256 fees = priceToFillOrder.sub(sellerProceeds);\r\n        uint256 excess = (msg.value).sub(priceToFillOrder);\r\n\r\n        // Save the seller's address before we delete the order\r\n        address payable orderMakerAddress = address(uint160(order.makerAddress));\r\n\r\n        // Emit event\r\n        emit FillSellOrder(\r\n            uint256(order.wizardId),\r\n            _takerWizardId,\r\n            uint256(order.pricePerPower),\r\n            address(order.makerAddress),\r\n            msg.sender,\r\n            order.basicTournamentAddress,\r\n            uint256(order.savedSuccessfulTradeFeeInBasisPoints)\r\n        );\r\n\r\n        // Delete the order prior to sending any funds\r\n        delete orderForWizardIdAndTournamentAddress[_basicTournamentAddress][_makerWizardId];\r\n\r\n        // Transfer Power from maker wizard to taker wizard\r\n        BasicTournament(_basicTournamentAddress).giftPower(_makerWizardId, _takerWizardId);\r\n\r\n        // Send proceeds to seller/maker\r\n        orderMakerAddress.transfer(sellerProceeds);\r\n\r\n        // Store fees earned by contract creator in contract until creator calls\r\n        // withdrawsEarnings()\r\n        // This prevents a halting condition that would occur if one of the fee\r\n        // earners rejects incoming transfers\r\n        if(_referrer != address(0)){\r\n            uint256 halfOfFees = fees.div(uint256(2));\r\n            addressToFeeEarnings[_referrer] = addressToFeeEarnings[_referrer].add(halfOfFees);\r\n            addressToFeeEarnings[owner()] = addressToFeeEarnings[owner()].add(halfOfFees);\r\n        } else {\r\n            addressToFeeEarnings[owner()] = addressToFeeEarnings[owner()].add(fees);\r\n        }\r\n\r\n        // Send any excess wei back to buyer/taker\r\n        if(excess > 0){\r\n            msg.sender.transfer(excess);\r\n        }\r\n    }\r\n\r\n    /// @notice A simple getter function to return an order for a given wizard\r\n    ///  and tournament address.\r\n    /// @dev The reason that we cannot simply use Solidity's automatically\r\n    ///  created getter functions is that the orders are stored in a nested\r\n    ///  mapping, which messes with Solidity's automatically created getters.\r\n    /// @param _wizardId The id of the wizard NFT whose order we would like to\r\n    ///  see the details of.\r\n    /// @param _basicTournamentAddress The address of the tournament that this\r\n    ///  order pertains to. Note that each Wizard has an independent power\r\n    ///  value for each tournament, and call sell each one separately.\r\n    /// @return The values from the Order struct, returned in tuple-form.\r\n    function getOrder(uint256 _wizardId, address _basicTournamentAddress) external view returns (uint256 wizardId, uint256 pricePerPower, address makerAddress, address basicTournamentAddress, uint256 savedSuccessfulTradeFeeInBasisPoints){\r\n        Order memory order = orderForWizardIdAndTournamentAddress[_basicTournamentAddress][_wizardId];\r\n        return (uint256(order.wizardId), uint256(order.pricePerPower), address(order.makerAddress), address(order.basicTournamentAddress), uint256(order.savedSuccessfulTradeFeeInBasisPoints));\r\n    }\r\n\r\n    /// @notice A convenience function providing the caller with the current\r\n    ///  amount needed (in wei) to fulfill this order.\r\n    /// @param _wizardId The id of the wizard NFT whose order we would like to\r\n    ///  see the details of.\r\n    /// @param _basicTournamentAddress The address of the tournament that this\r\n    ///  order pertains to. Note that each Wizard has an independent power\r\n    ///  value for each tournament, and call sell each one separately.\r\n    /// @return The amount needed (in wei) to fulfill this order\r\n    function getCurrentPriceForOrder(uint256 _wizardId, address _basicTournamentAddress) external view returns (uint256){\r\n        Order memory order = orderForWizardIdAndTournamentAddress[_basicTournamentAddress][_wizardId];\r\n        uint256 power;\r\n        ( , power, , , , , , , ) = BasicTournament(_basicTournamentAddress).getWizard(_wizardId);\r\n        uint256 price = power.mul(uint256(order.pricePerPower));\r\n        return price;\r\n    }\r\n\r\n    /// @notice A convenience function checking whether the order is currently\r\n    ///  valid. Note that an order can become invalid for a period of time, but\r\n    ///  then become valid again (for example, during the time that a wizard\r\n    ///  is dueling).\r\n    /// @param _wizardId The id of the wizard NFT whose order we would like to\r\n    ///  see the details of.\r\n    /// @param _basicTournamentAddress The address of the tournament that this\r\n    ///  order pertains to. Note that each Wizard has an independent power\r\n    ///  value for each tournament, and call sell each one separately.\r\n    /// @return Whether the order is currently valid or not.\r\n    function getIsOrderCurrentlyValid(uint256 _wizardId, address _basicTournamentAddress) external view returns (bool){\r\n        Order memory order = orderForWizardIdAndTournamentAddress[_basicTournamentAddress][_wizardId];\r\n        if(order.makerAddress == address(0)){\r\n            // Order is not valid if order does not exist\r\n            return false;\r\n        } else {\r\n\r\n            if(WizardGuild(wizardGuildAddress).ownerOf(_wizardId) != order.makerAddress){\r\n                // Order is not valid if order's creator no longer owns wizard\r\n                return false;\r\n            }\r\n            bool molded;\r\n            bool ready;\r\n            ( , , , , , , , molded, ready) = BasicTournament(_basicTournamentAddress).getWizard(_wizardId);\r\n            if(molded == true || ready == false){\r\n                // Order is not valid if makerWizard is molded or is dueling\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Computes the seller proceeds given a total value sent,\r\n    ///  and the successfulTradeFee in percentage basis points that was saved\r\n    ///  at the time of the order's creation.\r\n    /// @dev 10000 is not a magic number, but is the maximum number of basis\r\n    ///  points that can exist (with basis points being hundredths of a\r\n    ///  percent).\r\n    /// @param _totalValueIncludingFees The amount of ether (in wei) that was\r\n    ///  sent to complete the trade\r\n    /// @param _successfulTradeFeeInBasisPoints The percentage (in basis points)\r\n    ///  of that total amount that will be taken as a fee if the trade is\r\n    ///  successfully completed.\r\n    /// @return The amount of ether (in wei) that will be sent to the seller if\r\n    ///  the trade is successfully completed\r\n    function _computeSellerProceeds(uint256 _totalValueIncludingFees, uint256 _successfulTradeFeeInBasisPoints) internal pure returns (uint256) {\r\n    \treturn (_totalValueIncludingFees.mul(uint256(10000).sub(_successfulTradeFeeInBasisPoints))).div(uint256(10000));\r\n    }\r\n\r\n    /// @dev By calling 'revert' in the fallback function, we prevent anyone from\r\n    ///  accidentally sending funds directly to this contract.\r\n    function() external payable {\r\n        revert();\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wizardId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pricePerPower\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"basicTournamentAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"savedSuccessfulTradeFeeInBasisPoints\",\"type\":\"uint256\"}],\"name\":\"CancelSellOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wizardId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pricePerPower\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"basicTournamentAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"savedSuccessfulTradeFeeInBasisPoints\",\"type\":\"uint256\"}],\"name\":\"CreateSellOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"makerWizardId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerWizardId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pricePerPower\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"basicTournamentAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"savedSuccessfulTradeFeeInBasisPoints\",\"type\":\"uint256\"}],\"name\":\"FillSellOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSuccessfulTradeFeeInBasisPoints\",\"type\":\"uint256\"}],\"name\":\"SuccessfulTradeFeeInBasisPointsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wizardId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPricePerPower\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPricePerPower\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"basicTournamentAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"savedSuccessfulTradeFeeInBasisPoints\",\"type\":\"uint256\"}],\"name\":\"UpdateSellOrder\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToFeeEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wizardId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_basicTournamentAddress\",\"type\":\"address\"}],\"name\":\"cancelSellOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wizardId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pricePerPower\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_basicTournamentAddress\",\"type\":\"address\"}],\"name\":\"createSellOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_makerWizardId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_takerWizardId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_basicTournamentAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"fillSellOrder\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wizardId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_basicTournamentAddress\",\"type\":\"address\"}],\"name\":\"getCurrentPriceForOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wizardId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_basicTournamentAddress\",\"type\":\"address\"}],\"name\":\"getIsOrderCurrentlyValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wizardId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_basicTournamentAddress\",\"type\":\"address\"}],\"name\":\"getOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wizardId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pricePerPower\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"basicTournamentAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"savedSuccessfulTradeFeeInBasisPoints\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastSuccessfulPricePerPowerForTournamentAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newSuccessfulTradeFeeInBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setSuccessfulTradeFeeInBasisPoints\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"successfulTradeFeeInBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wizardId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newPricePerPower\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_basicTournamentAddress\",\"type\":\"address\"}],\"name\":\"updateSellOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFeeEarningsForAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wizardGuildAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CheezyExchange","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://f7b4d8e5034d7b5a8503ba0d8166e667b899826158bcafc00888a83ae3c8d7d0"}]}