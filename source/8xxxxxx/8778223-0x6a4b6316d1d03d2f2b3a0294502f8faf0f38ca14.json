{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >= 0.5 .0 < 0.7 .0;\r\n\r\n/*\r\n+-----------------------------------+\r\n|HZHZHZHZHZHZHZHZ/ /HZHZHZHZHZHZHZHZ|\r\n|HZHZHZHZHZHZHZH`   `HZHZHZHZHZHZHZH|\r\n|HZHZHZHZHZHZH-       -HZHZHZHZHZHZH|\r\n|HZHZHZHZHZH/           /HZHZHZHZHZH|\r\n|HZHZHZHZHZHZHZHZH+:     `HZHZHZHZHZ|\r\n|HZHZHZHZHZHZHZHZHZHZ-     -HZHZHZHZ|\r\n|HZHZHZHZHZHZHZHZHZHZHZ`     /HZHZHZ|\r\n|HZHZHZHZHZHZHZHZHZHZHZH/`    .HZHZH|\r\n|HZH-------/HZHZHZHZHZHZH+      -HZH|\r\n|H/`         /HZHZHZ-            `/H|\r\n||            `HZHZHZH`            ||\r\n|H/`            -HZHZHZ:         `/H|\r\n|HZH-      +HZHZHZHZHZHZH/-------HZH|\r\n|HZHZH.     /HZHZHZHZHZHZHZHZHZHZHZH|\r\n|HZHZHZ/     `HZHZHZHZHZHZHZHZHZHZHZ|\r\n|HZHZHZHZ-     -HZHZHZHZHZHZHZHZHZHZ|\r\n|HZHZHZHZHZ`     :+HZHZHZHZHZHZHZHZH|\r\n|HZHZHZHZHZH/           /HZHZHZHZHZH|\r\n|HZHZHZHZHZHZH-       -HZHZHZHZHZHZH|\r\n|HZHZHZHZHZHZHZH`   `HZHZHZHZHZHZHZH|\r\n|HZHZHZHZHZHZHZHZ/ /HZHZHZHZHZHZHZHZ|\r\n+-----------------------------------+\r\n\r\n _    ____________________________\r\n| |  |   ____   __  __   ______  /\r\n| |__|  |__  | |__) | | |     / / \r\n|  __    __| |  _  /  | |    / /  \r\n| |  |  |____| | \\ \\  | |   / /__ \r\n|_|  |_________|  \\_\\ |_|  /_____| V1.0\r\n     \r\nA deflationary stable-coin, with a constantly increasing price.\r\n\r\n Symbol        :  HZ\r\n Name          :  Hertz Token \r\n Total supply  :  21,000.0 (or 21 thousand tokens)\r\n Decimals      :  18\r\n Transfer Fees :  2% deducted from each transfer (a burning fee).\r\n Exchange Fees :  no fees deducted while purchasing, \r\n                  2% fee while converting back to Ethereum\r\n \r\n*/\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint a, uint b) internal pure returns(uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns(uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns(uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns(uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n    \r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract ERC20Interface {\r\n\r\n    function totalSupply() public view returns(uint);\r\n    function balanceOf(address tokenOwner) public view returns(uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns(uint remaining);\r\n    function transfer(address to, uint tokens) public returns(bool success);\r\n    function approve(address spender, uint tokens) public returns(bool success);\r\n    function approveAndCall(address spender, uint tokens, bytes memory data) public returns(bool);\r\n    function transferFrom(address from, address to, uint tokens) public returns(bool success);\r\n    // function burnTokens(uint tokens) public returns(bool success); // for testing purposes only !\r\n    function purchaseTokens() external payable;\r\n    function purchaseEth(uint tokens) public;\r\n    function sellAllTokens() public;\r\n    function weiToTokens(uint weiPurchase) public view returns(uint);\r\n    function tokensToWei(uint tokens) public view returns(uint);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call\r\n// ----------------------------------------------------------------------------\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract, it is necessary to make 100% sure that there is no contract owner.\r\n// We are making address(0) the owner, which means, nobody.\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token\r\n// ----------------------------------------------------------------------------\r\ncontract _HERTZ is ERC20Interface, Owned {\r\n\r\n    using SafeMath\r\n    for uint;\r\n    \r\n    string public symbol;\r\n    string public name;\r\n    uint8 public decimals;\r\n    uint private _DECIMALSCONSTANT;\r\n    uint public _totalSupply;\r\n    uint public _currentSupply;\r\n    bool constructorLocked = false;\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n    uint public weiDeposited;\r\n\r\n// ------------------------------------------------------------------------------\r\n// The constructor function is called only once, and parameters are set.\r\n// We are making sure that the token owner becomes address(0), that is, no owner.\r\n// ------------------------------------------------------------------------------\r\n    constructor() public onlyOwner{\r\n        if (constructorLocked) revert();\r\n        constructorLocked = true; // a bullet-proof mechanism\r\n\r\n        symbol = \"HZ\";\r\n        name = \"Hertz\";\r\n        decimals = 18;\r\n        _DECIMALSCONSTANT = 10 ** uint(decimals);\r\n        _totalSupply = (uint(21000)).mul(_DECIMALSCONSTANT);\r\n        _currentSupply = 0;\r\n\r\n        //We will transfer the ownership only once, making sure there is no owner.\r\n        emit OwnershipTransferred(msg.sender, address(0));\r\n        owner = address(0);\r\n    }\r\n\r\n// ------------------------------------------------------------------------------\r\n// Total supply\r\n// ------------------------------------------------------------------------------\r\n    function totalSupply() public view returns(uint) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    \r\n// ------------------------------------------------------------------------------\r\n// Current supply\r\n// ------------------------------------------------------------------------------\r\n    function currentSupply() public view returns(uint) {\r\n        return _currentSupply;\r\n    }\r\n    \r\n\r\n// ------------------------------------------------------------------------------\r\n// Get the token balance for the account\r\n// ------------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public view returns(uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n// ------------------------------------------------------------------------\r\n// Transfer the tokens from owner's account to a `to` account\r\n// - Owner's account must have sufficient balance to transfer\r\n// - 0 value transfers are not allowed\r\n// - We cannot use this function to burn tokens\r\n// ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns(bool success) {\r\n        require(balances[msg.sender] >= tokens && tokens > 0, \"Zero transfer or not enough funds\");\r\n        require(address(to) != address(0), \"No burning allowed\");\r\n        require(address(msg.sender) != address(0), \"You can't mint this token, purchase it instead\");\r\n\r\n        uint burn = tokens.div(50); //2% burn\r\n        uint send = tokens.sub(burn);\r\n        _transfer(to, send);\r\n        _transfer(address(0), burn);\r\n        return true;\r\n    }\r\n\r\n\r\n// -------------------------------------------------------------------------\r\n// The internal transfer function. We don't keep a balance of a burn address\r\n// -------------------------------------------------------------------------\r\n    function _transfer(address to, uint tokens) internal returns(bool success) {\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        if (address(to) != address(0)) {\r\n            balances[to] = balances[to].add(tokens);\r\n        } else if (address(to) == address(0)) {\r\n            _currentSupply = _currentSupply.sub(tokens);\r\n        }\r\n        emit Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n// ------------------------------------------------------------------------\r\n// Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n// from the token owner's account\r\n// ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns(bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n// ------------------------------------------------------------------------\r\n// Transfer `tokens` from the `from` account to the `to` account\r\n//\r\n// The calling account must already have sufficient tokens approved\r\n// - From account must have sufficient balance to transfer\r\n// - Spender must have sufficient allowance to transfer\r\n// - 0 value transfers are not allowed\r\n// - This function cannot be used for burning tokens.\r\n// - This function cannot be used for minting tokens.\r\n// ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns(bool) {\r\n        require(balances[from] >= tokens && allowed[from][msg.sender] >= tokens && tokens > 0, \"Zero transfer or not enough (allowed) funds\");\r\n        require(address(to) != address(0), \"No burning allowed\");\r\n        require(address(from) != address(0), \"You can't mint this token, purchase it instead\");\r\n\r\n        uint burn = tokens.div(50); //2% burn\r\n        uint send = tokens.sub(burn);\r\n        _transferFrom(from, to, send);\r\n        _transferFrom(from, address(0), burn);\r\n    }\r\n\r\n// -----------------------------------------------------------------------------\r\n// The internal transferFrom function. We don't keep a balance of a burn address\r\n// -----------------------------------------------------------------------------\r\n    function _transferFrom(address from, address to, uint tokens) internal returns(bool) {\r\n        balances[from] = balances[from].sub(tokens);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        if (address(to) != address(0)) {\r\n            balances[to] = balances[to].add(tokens);\r\n        } else if (address(to) == address(0)) {\r\n            _currentSupply = _currentSupply.sub(tokens);\r\n        }\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n// ----------------------------------------------------------------------------------------------------\r\n// Returns the amount of tokens approved by the owner that can be transferred to the spender's account\r\n// ----------------------------------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public view returns(uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n// ------------------------------------------------------------------------\r\n// Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n// from the token owner's account. The `spender` contract function\r\n// `receiveApproval(...)` is then executed\r\n// ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes memory data) public returns(bool) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n        return true;\r\n    }\r\n\r\n// ------------------------------------------------------------------------\r\n// This is a function which allows us to burn any amount of tokens.\r\n// This is commented out and to be used for the testing purposes only.\r\n// Otherwise, the contract could be abused in multiple ways.\r\n// ------------------------------------------------------------------------     \r\n    // function burnTokens(uint tokens) public returns(bool success) {\r\n    //     balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n    //     _currentSupply = _currentSupply.sub(tokens);\r\n    //     tokensBurned = tokensBurned.add(tokens);\r\n    //     emit Transfer(msg.sender, address(0), tokens);\r\n    //     return true;\r\n    // }\r\n\r\n\r\n// -------------------------------------------------------------------------\r\n// This view function shows how many tokens will be obtained for your Wei.\r\n// - Decimals are included in the result\r\n// - There is no fee for purchasing tokens\r\n// -------------------------------------------------------------------------\r\n    function weiToTokens(uint weiPurchase) public view returns(uint) {\r\n        if(_currentSupply==0 && weiDeposited==0 ) return weiPurchase; //initial step\r\n        if(weiDeposited==0 || _currentSupply==0 || weiPurchase==0) return 0;\r\n\r\n        uint ret = (weiPurchase.mul(_currentSupply)).div(weiDeposited);\r\n        return ret;\r\n    }\r\n    \r\n// ----------------------------------------------------------------------------\r\n// This view function shows how much Wei will be obtained for your tokens.\r\n// - You must include decimals for an input.\r\n// - There is 2% fee for converting to Ethereum\r\n// ----------------------------------------------------------------------------\r\n    function tokensToWei(uint tokens) public view returns(uint){\r\n        if(tokens==0 || weiDeposited==0 || _currentSupply==0) return 0;\r\n        uint ret = (weiDeposited.mul(tokens)).div(_currentSupply);\r\n        ret = ret.sub(ret.div(50)); //2% fee, it stays to be shared with everyone\r\n        return ret;\r\n    }\r\n\r\n// ------------------------------------------------------------------------\r\n// This is the function which allows us to purchase tokens from a contract\r\n// - Nobody collects Ethereum, it stays in a contract\r\n// - There is a no fee for purchasing Tokens\r\n// ------------------------------------------------------------------------\r\n    function purchaseTokens() external payable {\r\n        require(msg.value>0);\r\n        \r\n        uint tokens = weiToTokens(msg.value);\r\n        require(_currentSupply.add(tokens)<=_totalSupply,\"We have reached our contract limit\");\r\n        require(tokens>0);\r\n\r\n        //mint new tokens\r\n        emit Transfer(address(0), msg.sender, tokens);\r\n        \r\n        balances[msg.sender] = balances[msg.sender].add(tokens);\r\n        _currentSupply = _currentSupply.add(tokens);\r\n\r\n        weiDeposited = weiDeposited.add(msg.value);\r\n    }\r\n    \r\n// ------------------------------------------------------------------------\r\n// This is the function which allows us to exchange tokens back to Ethereum\r\n// - Burns deposited tokens, returns Ethereum.\r\n// ------------------------------------------------------------------------ \r\n    function purchaseEth(uint tokens) public {\r\n        require(tokens>0);\r\n        uint getWei = tokensToWei(tokens);\r\n        require(getWei>0);\r\n        //burn tokens to get wei\r\n        emit Transfer(msg.sender, address(0), tokens);\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        _currentSupply = _currentSupply.sub(tokens);\r\n        address(msg.sender).transfer(getWei);\r\n        weiDeposited = weiDeposited.sub(getWei);\r\n    }\r\n    \r\n// ------------------------------------------------------------------------\r\n// This is the function which allows us to exchange all tokens back to Ethereum\r\n// - Burns deposited tokens, returns Ethereum.\r\n// ------------------------------------------------------------------------ \r\n    function sellAllTokens() public {\r\n        purchaseEth(balances[msg.sender]);\r\n    }   \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchaseTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weiPurchase\",\"type\":\"uint256\"}],\"name\":\"weiToTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"tokensToWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"purchaseEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_currentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sellAllTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"_HERTZ","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://4c096454d5d10f29f6325907d5bc2eb0fd49b19a27fa279e45a87e709b53a0ea"}]}