{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with buidler v1.0.0-beta.7 https://getbuidler.com\r\n\r\n// File contracts/oz/Ownable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/oz/IERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File contracts/oz/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/GuildBank.sol\r\n\r\npragma solidity 0.5.3;\r\n\r\n\r\n\r\n\r\ncontract GuildBank is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    IERC20 public approvedToken; // approved token contract reference\r\n\r\n    event Withdrawal(address indexed receiver, uint256 amount);\r\n\r\n    constructor(address approvedTokenAddress) public {\r\n        approvedToken = IERC20(approvedTokenAddress);\r\n    }\r\n\r\n    function withdraw(address receiver, uint256 shares, uint256 totalShares) public onlyOwner returns (bool) {\r\n        uint256 amount = approvedToken.balanceOf(address(this)).mul(shares).div(totalShares);\r\n        emit Withdrawal(receiver, amount);\r\n        return approvedToken.transfer(receiver, amount);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Moloch.sol\r\n\r\n// Goals\r\n// - Defensibility -> Kick out malicious members via forceRagequit\r\n// - Separation of Wealth and Power -> voting / loot tokens - grant pool can't be claimed (controlled by separate contract?)\r\n// - batch proposals -> 1 month between proposal batches, 2 week voting period, 2 week grace period\r\n// - better spam protection -> exponential increase in deposit for same member / option to claim deposit\r\n// - replacing members?\r\n//   - hasn't been discussed\r\n// - accountability to stakeholders\r\n//   - some kind of siganlling\r\n\r\n\r\npragma solidity 0.5.3;\r\n\r\n\r\n\r\n\r\ncontract Moloch {\r\n    using SafeMath for uint256;\r\n\r\n    /***************\r\n    GLOBAL CONSTANTS\r\n    ***************/\r\n  uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\r\n    uint256 public votingPeriodLength; // default = 35 periods (7 days)\r\n    uint256 public gracePeriodLength; // default = 35 periods (7 days)\r\n    uint256 public abortWindow; // default = 5 periods (1 day)\r\n    uint256 public proposalDeposit; // default = 10 ETH (~$1,000 worth of ETH at contract deployment)\r\n    uint256 public dilutionBound; // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit\r\n    uint256 public processingReward; // default = 0.1 - amount of ETH to give to whoever processes a proposal\r\n    uint256 public summoningTime; // needed to determine the current period\r\n\r\n    IERC20 public approvedToken; // approved token contract reference; default = wETH\r\n    GuildBank public guildBank; // guild bank contract reference\r\n\r\n    // HARD-CODED LIMITS\r\n    // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations\r\n    // with periods or shares, yet big enough to not limit reasonable use cases.\r\n    uint256 constant MAX_VOTING_PERIOD_LENGTH = 10**18; // maximum length of voting period\r\n    uint256 constant MAX_GRACE_PERIOD_LENGTH = 10**18; // maximum length of grace period\r\n    uint256 constant MAX_DILUTION_BOUND = 10**18; // maximum dilution bound\r\n    uint256 constant MAX_NUMBER_OF_SHARES = 10**18; // maximum number of shares that can be minted\r\n\r\n    /***************\r\n    EVENTS\r\n    ***************/\r\n    event SubmitProposal(uint256 proposalIndex, address indexed delegateKey, address indexed memberAddress, address indexed applicant, uint256 tokenTribute, uint256 sharesRequested);\r\n    event SubmitVote(uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\r\n    event ProcessProposal(uint256 indexed proposalIndex, address indexed applicant, address indexed memberAddress, uint256 tokenTribute, uint256 sharesRequested, bool didPass);\r\n    event Ragequit(address indexed memberAddress, uint256 sharesToBurn);\r\n    event Abort(uint256 indexed proposalIndex, address applicantAddress);\r\n    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\r\n    event SummonComplete(address indexed summoner, uint256 shares);\r\n\r\n    /******************\r\n    INTERNAL ACCOUNTING\r\n    ******************/\r\n    uint256 public totalShares = 0; // total shares across all members\r\n    uint256 public totalSharesRequested = 0; // total shares that have been requested in unprocessed proposals\r\n\r\n    enum Vote {\r\n        Null, // default value, counted as abstention\r\n        Yes,\r\n        No\r\n    }\r\n\r\n    struct Member {\r\n        address delegateKey; // the key responsible for submitting proposals and voting - defaults to member address unless updated\r\n        uint256 shares; // the # of shares assigned to this member\r\n        bool exists; // always true once a member has been created\r\n        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\r\n    }\r\n\r\n    struct Proposal {\r\n        address proposer; // the member who submitted the proposal\r\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals\r\n        uint256 sharesRequested; // the # of shares the applicant is requesting\r\n        uint256 startingPeriod; // the period in which voting can start for this proposal\r\n        uint256 yesVotes; // the total number of YES votes for this proposal\r\n        uint256 noVotes; // the total number of NO votes for this proposal\r\n        bool processed; // true only if the proposal has been processed\r\n        bool didPass; // true only if the proposal passed\r\n        bool aborted; // true only if applicant calls \"abort\" fn before end of voting period\r\n        uint256 tokenTribute; // amount of tokens offered as tribute\r\n        string details; // proposal details - could be IPFS hash, plaintext, or JSON\r\n        uint256 maxTotalSharesAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\r\n        mapping (address => Vote) votesByMember; // the votes on this proposal by each member\r\n    }\r\n\r\n    mapping (address => Member) public members;\r\n    mapping (address => address) public memberAddressByDelegateKey;\r\n    Proposal[] public proposalQueue;\r\n\r\n    /********\r\n    MODIFIERS\r\n    ********/\r\n    modifier onlyMember {\r\n        require(members[msg.sender].shares > 0, \"Moloch::onlyMember - not a member\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDelegate {\r\n        require(members[memberAddressByDelegateKey[msg.sender]].shares > 0, \"Moloch::onlyDelegate - not a delegate\");\r\n        _;\r\n    }\r\n\r\n    /********\r\n    FUNCTIONS\r\n    ********/\r\n    constructor(\r\n        address summoner,\r\n        address _approvedToken,\r\n        uint256 _periodDuration,\r\n        uint256 _votingPeriodLength,\r\n        uint256 _gracePeriodLength,\r\n        uint256 _abortWindow,\r\n        uint256 _proposalDeposit,\r\n        uint256 _dilutionBound,\r\n        uint256 _processingReward\r\n    ) public {\r\n        require(summoner != address(0), \"Moloch::constructor - summoner cannot be 0\");\r\n        require(_approvedToken != address(0), \"Moloch::constructor - _approvedToken cannot be 0\");\r\n        require(_periodDuration > 0, \"Moloch::constructor - _periodDuration cannot be 0\");\r\n        require(_votingPeriodLength > 0, \"Moloch::constructor - _votingPeriodLength cannot be 0\");\r\n        require(_votingPeriodLength <= MAX_VOTING_PERIOD_LENGTH, \"Moloch::constructor - _votingPeriodLength exceeds limit\");\r\n        require(_gracePeriodLength <= MAX_GRACE_PERIOD_LENGTH, \"Moloch::constructor - _gracePeriodLength exceeds limit\");\r\n        require(_abortWindow > 0, \"Moloch::constructor - _abortWindow cannot be 0\");\r\n        require(_abortWindow <= _votingPeriodLength, \"Moloch::constructor - _abortWindow must be smaller than or equal to _votingPeriodLength\");\r\n        require(_dilutionBound > 0, \"Moloch::constructor - _dilutionBound cannot be 0\");\r\n        require(_dilutionBound <= MAX_DILUTION_BOUND, \"Moloch::constructor - _dilutionBound exceeds limit\");\r\n        require(_proposalDeposit >= _processingReward, \"Moloch::constructor - _proposalDeposit cannot be smaller than _processingReward\");\r\n\r\n        approvedToken = IERC20(_approvedToken);\r\n\r\n        guildBank = new GuildBank(_approvedToken);\r\n\r\n        periodDuration = _periodDuration;\r\n        votingPeriodLength = _votingPeriodLength;\r\n        gracePeriodLength = _gracePeriodLength;\r\n        abortWindow = _abortWindow;\r\n        proposalDeposit = _proposalDeposit;\r\n        dilutionBound = _dilutionBound;\r\n        processingReward = _processingReward;\r\n\r\n        summoningTime = now;\r\n\r\n        members[summoner] = Member(summoner, 1, true, 0);\r\n        memberAddressByDelegateKey[summoner] = summoner;\r\n        totalShares = 1;\r\n\r\n        emit SummonComplete(summoner, 1);\r\n    }\r\n\r\n    /*****************\r\n    PROPOSAL FUNCTIONS\r\n    *****************/\r\n\r\n    function submitProposal(\r\n        address applicant,\r\n        uint256 tokenTribute,\r\n        uint256 sharesRequested,\r\n        string memory details\r\n    )\r\n        public\r\n        onlyDelegate\r\n    {\r\n        require(applicant != address(0), \"Moloch::submitProposal - applicant cannot be 0\");\r\n\r\n        // Make sure we won't run into overflows when doing calculations with shares.\r\n        // Note that totalShares + totalSharesRequested + sharesRequested is an upper bound\r\n        // on the number of shares that can exist until this proposal has been processed.\r\n        require(totalShares.add(totalSharesRequested).add(sharesRequested) <= MAX_NUMBER_OF_SHARES, \"Moloch::submitProposal - too many shares requested\");\r\n\r\n        totalSharesRequested = totalSharesRequested.add(sharesRequested);\r\n\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n\r\n        // collect proposal deposit from proposer and store it in the Moloch until the proposal is processed\r\n        require(approvedToken.transferFrom(msg.sender, address(this), proposalDeposit), \"Moloch::submitProposal - proposal deposit token transfer failed\");\r\n\r\n        // collect tribute from applicant and store it in the Moloch until the proposal is processed\r\n        require(approvedToken.transferFrom(applicant, address(this), tokenTribute), \"Moloch::submitProposal - tribute token transfer failed\");\r\n\r\n        // compute startingPeriod for proposal\r\n        uint256 startingPeriod = max(\r\n            getCurrentPeriod(),\r\n            proposalQueue.length == 0 ? 0 : proposalQueue[proposalQueue.length.sub(1)].startingPeriod\r\n        ).add(1);\r\n\r\n        // create proposal ...\r\n        Proposal memory proposal = Proposal({\r\n            proposer: memberAddress,\r\n            applicant: applicant,\r\n            sharesRequested: sharesRequested,\r\n            startingPeriod: startingPeriod,\r\n            yesVotes: 0,\r\n            noVotes: 0,\r\n            processed: false,\r\n            didPass: false,\r\n            aborted: false,\r\n            tokenTribute: tokenTribute,\r\n            details: details,\r\n            maxTotalSharesAtYesVote: 0\r\n        });\r\n\r\n        // ... and append it to the queue\r\n        proposalQueue.push(proposal);\r\n\r\n        uint256 proposalIndex = proposalQueue.length.sub(1);\r\n        emit SubmitProposal(proposalIndex, msg.sender, memberAddress, applicant, tokenTribute, sharesRequested);\r\n    }\r\n\r\n    function submitVote(uint256 proposalIndex, uint8 uintVote) public onlyDelegate {\r\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\r\n        Member storage member = members[memberAddress];\r\n\r\n        require(proposalIndex < proposalQueue.length, \"Moloch::submitVote - proposal does not exist\");\r\n        Proposal storage proposal = proposalQueue[proposalIndex];\r\n\r\n        require(uintVote < 3, \"Moloch::submitVote - uintVote must be less than 3\");\r\n        Vote vote = Vote(uintVote);\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod, \"Moloch::submitVote - voting period has not started\");\r\n        require(!hasVotingPeriodExpired(proposal.startingPeriod), \"Moloch::submitVote - proposal voting period has expired\");\r\n        require(proposal.votesByMember[memberAddress] == Vote.Null, \"Moloch::submitVote - member has already voted on this proposal\");\r\n        require(vote == Vote.Yes || vote == Vote.No, \"Moloch::submitVote - vote must be either Yes or No\");\r\n        require(!proposal.aborted, \"Moloch::submitVote - proposal has been aborted\");\r\n\r\n        // store vote\r\n        proposal.votesByMember[memberAddress] = vote;\r\n\r\n        // count vote\r\n        if (vote == Vote.Yes) {\r\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\r\n\r\n            // set highest index (latest) yes vote - must be processed for member to ragequit\r\n            if (proposalIndex > member.highestIndexYesVote) {\r\n                member.highestIndexYesVote = proposalIndex;\r\n            }\r\n\r\n            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\r\n            if (totalShares > proposal.maxTotalSharesAtYesVote) {\r\n                proposal.maxTotalSharesAtYesVote = totalShares;\r\n            }\r\n\r\n        } else if (vote == Vote.No) {\r\n            proposal.noVotes = proposal.noVotes.add(member.shares);\r\n        }\r\n\r\n        emit SubmitVote(proposalIndex, msg.sender, memberAddress, uintVote);\r\n    }\r\n\r\n    function processProposal(uint256 proposalIndex) public {\r\n        require(proposalIndex < proposalQueue.length, \"Moloch::processProposal - proposal does not exist\");\r\n        Proposal storage proposal = proposalQueue[proposalIndex];\r\n\r\n        require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \"Moloch::processProposal - proposal is not ready to be processed\");\r\n        require(proposal.processed == false, \"Moloch::processProposal - proposal has already been processed\");\r\n        require(proposalIndex == 0 || proposalQueue[proposalIndex.sub(1)].processed, \"Moloch::processProposal - previous proposal must be processed\");\r\n\r\n        proposal.processed = true;\r\n        totalSharesRequested = totalSharesRequested.sub(proposal.sharesRequested);\r\n\r\n        bool didPass = proposal.yesVotes > proposal.noVotes;\r\n\r\n        // Make the proposal fail if the dilutionBound is exceeded\r\n        if (totalShares.mul(dilutionBound) < proposal.maxTotalSharesAtYesVote) {\r\n            didPass = false;\r\n        }\r\n\r\n        // PROPOSAL PASSED\r\n        if (didPass && !proposal.aborted) {\r\n\r\n            proposal.didPass = true;\r\n\r\n            // if the applicant is already a member, add to their existing shares\r\n            if (members[proposal.applicant].exists) {\r\n                members[proposal.applicant].shares = members[proposal.applicant].shares.add(proposal.sharesRequested);\r\n\r\n            // the applicant is a new member, create a new record for them\r\n            } else {\r\n                // if the applicant address is already taken by a member's delegateKey, reset it to their member address\r\n                if (members[memberAddressByDelegateKey[proposal.applicant]].exists) {\r\n                    address memberToOverride = memberAddressByDelegateKey[proposal.applicant];\r\n                    memberAddressByDelegateKey[memberToOverride] = memberToOverride;\r\n                    members[memberToOverride].delegateKey = memberToOverride;\r\n                }\r\n\r\n                // use applicant address as delegateKey by default\r\n                members[proposal.applicant] = Member(proposal.applicant, proposal.sharesRequested, true, 0);\r\n                memberAddressByDelegateKey[proposal.applicant] = proposal.applicant;\r\n            }\r\n\r\n            // mint new shares\r\n            totalShares = totalShares.add(proposal.sharesRequested);\r\n\r\n            // transfer tokens to guild bank\r\n            require(\r\n                approvedToken.transfer(address(guildBank), proposal.tokenTribute),\r\n                \"Moloch::processProposal - token transfer to guild bank failed\"\r\n            );\r\n\r\n        // PROPOSAL FAILED OR ABORTED\r\n        } else {\r\n            // return all tokens to the applicant\r\n            require(\r\n                approvedToken.transfer(proposal.applicant, proposal.tokenTribute),\r\n                \"Moloch::processProposal - failing vote token transfer failed\"\r\n            );\r\n        }\r\n\r\n        // send msg.sender the processingReward\r\n        require(\r\n            approvedToken.transfer(msg.sender, processingReward),\r\n            \"Moloch::processProposal - failed to send processing reward to msg.sender\"\r\n        );\r\n\r\n        // return deposit to proposer (subtract processing reward)\r\n        require(\r\n            approvedToken.transfer(proposal.proposer, proposalDeposit.sub(processingReward)),\r\n            \"Moloch::processProposal - failed to return proposal deposit to proposer\"\r\n        );\r\n\r\n        emit ProcessProposal(\r\n            proposalIndex,\r\n            proposal.applicant,\r\n            proposal.proposer,\r\n            proposal.tokenTribute,\r\n            proposal.sharesRequested,\r\n            didPass\r\n        );\r\n    }\r\n\r\n    function ragequit(uint256 sharesToBurn) public onlyMember {\r\n        uint256 initialTotalShares = totalShares;\r\n\r\n        Member storage member = members[msg.sender];\r\n\r\n        require(member.shares >= sharesToBurn, \"Moloch::ragequit - insufficient shares\");\r\n\r\n        require(canRagequit(member.highestIndexYesVote), \"Moloch::ragequit - cant ragequit until highest index proposal member voted YES on is processed\");\r\n\r\n        // burn shares\r\n        member.shares = member.shares.sub(sharesToBurn);\r\n        totalShares = totalShares.sub(sharesToBurn);\r\n\r\n        // instruct guildBank to transfer fair share of tokens to the ragequitter\r\n        require(\r\n            guildBank.withdraw(msg.sender, sharesToBurn, initialTotalShares),\r\n            \"Moloch::ragequit - withdrawal of tokens from guildBank failed\"\r\n        );\r\n\r\n        emit Ragequit(msg.sender, sharesToBurn);\r\n    }\r\n\r\n    function abort(uint256 proposalIndex) public {\r\n        require(proposalIndex < proposalQueue.length, \"Moloch::abort - proposal does not exist\");\r\n        Proposal storage proposal = proposalQueue[proposalIndex];\r\n\r\n        require(msg.sender == proposal.applicant, \"Moloch::abort - msg.sender must be applicant\");\r\n        require(getCurrentPeriod() < proposal.startingPeriod.add(abortWindow), \"Moloch::abort - abort window must not have passed\");\r\n        require(!proposal.aborted, \"Moloch::abort - proposal must not have already been aborted\");\r\n\r\n        uint256 tokensToAbort = proposal.tokenTribute;\r\n        proposal.tokenTribute = 0;\r\n        proposal.aborted = true;\r\n\r\n        // return all tokens to the applicant\r\n        require(\r\n            approvedToken.transfer(proposal.applicant, tokensToAbort),\r\n            \"Moloch::processProposal - failed to return tribute to applicant\"\r\n        );\r\n\r\n        emit Abort(proposalIndex, msg.sender);\r\n    }\r\n\r\n    function updateDelegateKey(address newDelegateKey) public onlyMember {\r\n        require(newDelegateKey != address(0), \"Moloch::updateDelegateKey - newDelegateKey cannot be 0\");\r\n\r\n        // skip checks if member is setting the delegate key to their member address\r\n        if (newDelegateKey != msg.sender) {\r\n            require(!members[newDelegateKey].exists, \"Moloch::updateDelegateKey - cant overwrite existing members\");\r\n            require(!members[memberAddressByDelegateKey[newDelegateKey]].exists, \"Moloch::updateDelegateKey - cant overwrite existing delegate keys\");\r\n        }\r\n\r\n        Member storage member = members[msg.sender];\r\n        memberAddressByDelegateKey[member.delegateKey] = address(0);\r\n        memberAddressByDelegateKey[newDelegateKey] = msg.sender;\r\n        member.delegateKey = newDelegateKey;\r\n\r\n        emit UpdateDelegateKey(msg.sender, newDelegateKey);\r\n    }\r\n\r\n    /***************\r\n    GETTER FUNCTIONS\r\n    ***************/\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    function getCurrentPeriod() public view returns (uint256) {\r\n        return now.sub(summoningTime).div(periodDuration);\r\n    }\r\n\r\n    function getProposalQueueLength() public view returns (uint256) {\r\n        return proposalQueue.length;\r\n    }\r\n\r\n    // can only ragequit if the latest proposal you voted YES on has been processed\r\n    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) {\r\n        require(highestIndexYesVote < proposalQueue.length, \"Moloch::canRagequit - proposal does not exist\");\r\n        return proposalQueue[highestIndexYesVote].processed;\r\n    }\r\n\r\n    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) {\r\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\r\n    }\r\n\r\n    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) public view returns (Vote) {\r\n        require(members[memberAddress].exists, \"Moloch::getMemberProposalVote - member doesn't exist\");\r\n        require(proposalIndex < proposalQueue.length, \"Moloch::getMemberProposalVote - proposal doesn't exist\");\r\n        return proposalQueue[proposalIndex].votesByMember[memberAddress];\r\n    }\r\n}\r\n\r\n\r\n// File contracts/oz/ERC20.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Originally based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n * compliant implementations may not do it.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the balance of.\r\n     * @return An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified address\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _transfer(from, to, value);\r\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed_[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified addresses\r\n     * @param from The address to transfer from.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0));\r\n\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that mints an amount of the token and assigns it to\r\n     * an account. This encapsulates the modification of balances such that the\r\n     * proper events are emitted.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param value The amount that will be created.\r\n     */\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[account] = _balances[account].add(value);\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account.\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0));\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve an address to spend another addresses' tokens.\r\n     * @param owner The address that owns the tokens.\r\n     * @param spender The address that will spend the tokens.\r\n     * @param value The number of tokens that can be spent.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(spender != address(0));\r\n        require(owner != address(0));\r\n\r\n        _allowed[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that burns an amount of the token of a given\r\n     * account, deducting from the sender's allowance for said account. Uses the\r\n     * internal burn function.\r\n     * Emits an Approval event (reflecting the reduced allowance).\r\n     * @param account The account whose tokens will be burnt.\r\n     * @param value The amount that will be burnt.\r\n     */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        _burn(account, value);\r\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Pool.sol\r\n\r\n// Pool.sol\r\n// - mints a pool share when someone donates tokens\r\n// - syncs with Moloch proposal queue to mint shares for grantees\r\n// - allows donors to withdraw tokens at any time\r\n\r\npragma solidity 0.5.3;\r\n\r\n\r\n\r\n\r\ncontract MolochPool {\r\n    using SafeMath for uint256;\r\n\r\n    event Sync (\r\n        uint256 currentProposalIndex\r\n    );\r\n\r\n    event Deposit (\r\n        uint256 tokenAmount,\r\n        address donor\r\n    );\r\n\r\n    event Withdraw (\r\n        uint256 sharesToBurn,\r\n        address donor\r\n    );\r\n\r\n    event KeeperWithdraw (\r\n        uint256 sharesToBurn,\r\n        address donor,\r\n        address keeper\r\n    );\r\n\r\n    event AddKeepers (\r\n        address[] addedKeepers\r\n    );\r\n\r\n    event RemoveKeepers (\r\n        address[] removedKeepers\r\n    );\r\n\r\n    event SharesMinted (\r\n        uint256 sharesToMint,\r\n        address recipient,\r\n        uint256 totalPoolShares\r\n    );\r\n\r\n    event SharesBurned (\r\n        uint256 sharesToBurn,\r\n        address recipient,\r\n        uint256 totalPoolShares\r\n    );\r\n\r\n    uint256 public totalPoolShares = 0; // the total shares outstanding of the pool\r\n    uint256 public currentProposalIndex = 0; // the moloch proposal index that this pool has been synced to\r\n\r\n    Moloch public moloch; // moloch contract reference\r\n    IERC20 public approvedToken; // approved token contract reference (copied from moloch contract)\r\n\r\n    bool locked; // prevent re-entrancy\r\n\r\n    uint256 constant MAX_NUMBER_OF_SHARES = 10**30; // maximum number of shares that can be minted\r\n\r\n    struct Donor {\r\n        uint256 shares;\r\n        mapping (address => bool) keepers;\r\n    }\r\n\r\n    // the amount of shares each pool shareholder has\r\n    mapping (address => Donor) public donors;\r\n\r\n    modifier active {\r\n        require(totalPoolShares > 0, \"MolochPool: Not active\");\r\n        _;\r\n    }\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked, \"MolochPool: Reentrant call\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    constructor(address _moloch) public {\r\n        moloch = Moloch(_moloch);\r\n        approvedToken = IERC20(moloch.approvedToken());\r\n    }\r\n\r\n    function activate(uint256 initialTokens, uint256 initialPoolShares) public noReentrancy {\r\n        require(totalPoolShares == 0, \"MolochPool: Already active\");\r\n\r\n        require(\r\n            approvedToken.transferFrom(msg.sender, address(this), initialTokens),\r\n            \"MolochPool: Initial tokens transfer failed\"\r\n        );\r\n        _mintSharesForAddress(initialPoolShares, msg.sender);\r\n    }\r\n\r\n    // updates Pool state based on Moloch proposal queue\r\n    // - we only want to mint shares for grants, which are 0 tribute\r\n    // - mints pool shares to applicants based on sharesRequested / maxTotalSharesAtYesVote\r\n    // - use maxTotalSharesAtYesVote because:\r\n    //   - cant read shares at the time of proposal processing (womp womp)\r\n    //   - should be close enough if grant shares are small relative to total shares, which they should be\r\n    //   - protects pool contributors if many Moloch members ragequit before the proposal is processed by reducing follow on funding\r\n    //   - e.g. if 50% of Moloch shares ragequit after someone voted yes, the grant proposal would get 50% less follow-on from the pool\r\n    function sync(uint256 toIndex) public active noReentrancy {\r\n        require(\r\n            toIndex <= moloch.getProposalQueueLength(),\r\n            \"MolochPool: Proposal index too high\"\r\n        );\r\n\r\n        // declare proposal params\r\n        address applicant;\r\n        uint256 sharesRequested;\r\n        bool processed;\r\n        bool didPass;\r\n        bool aborted;\r\n        uint256 tokenTribute;\r\n        uint256 maxTotalSharesAtYesVote;\r\n\r\n        uint256 i = currentProposalIndex;\r\n\r\n        while (i < toIndex) {\r\n\r\n            (, applicant, sharesRequested, , , , processed, didPass, aborted, tokenTribute, , maxTotalSharesAtYesVote) = moloch.proposalQueue(i);\r\n\r\n            if (!processed) { break; }\r\n\r\n            // passing grant proposal, mint pool shares proportionally on behalf of the applicant\r\n            if (!aborted && didPass && tokenTribute == 0 && sharesRequested > 0) {\r\n                // This can't revert:\r\n                //   1. maxTotalSharesAtYesVote > 0, otherwise nobody could have voted.\r\n                //   2. sharesRequested is <= 10**18 (see Moloch.sol:172), and\r\n                //      totalPoolShares <= 10**30, so multiplying them is <= 10**48 and < 2**160\r\n                uint256 sharesToMint = totalPoolShares.mul(sharesRequested).div(maxTotalSharesAtYesVote); // for a passing proposal, maxTotalSharesAtYesVote is > 0\r\n                _mintSharesForAddress(sharesToMint, applicant);\r\n            }\r\n\r\n            i++;\r\n        }\r\n\r\n        currentProposalIndex = i;\r\n\r\n        emit Sync(currentProposalIndex);\r\n    }\r\n\r\n    // add tokens to the pool, mint new shares proportionally\r\n    function deposit(uint256 tokenAmount) public active noReentrancy {\r\n\r\n        uint256 sharesToMint = totalPoolShares.mul(tokenAmount).div(approvedToken.balanceOf(address(this)));\r\n\r\n        require(\r\n            approvedToken.transferFrom(msg.sender, address(this), tokenAmount),\r\n            \"MolochPool: Deposit transfer failed\"\r\n        );\r\n\r\n        _mintSharesForAddress(sharesToMint, msg.sender);\r\n\r\n        emit Deposit(\r\n            tokenAmount,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    // burn shares to proportionally withdraw tokens in pool\r\n    function withdraw(uint256 sharesToBurn) public active noReentrancy {\r\n        _withdraw(msg.sender, sharesToBurn);\r\n\r\n        emit Withdraw(\r\n            sharesToBurn,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    // keeper burns shares to withdraw on behalf of the donor\r\n    function keeperWithdraw(uint256 sharesToBurn, address recipient) public active noReentrancy {\r\n        require(\r\n            donors[recipient].keepers[msg.sender],\r\n            \"MolochPool: Sender is not a keeper\"\r\n        );\r\n\r\n        _withdraw(recipient, sharesToBurn);\r\n\r\n        emit KeeperWithdraw(\r\n            sharesToBurn,\r\n            recipient,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function addKeepers(address[] calldata newKeepers) external active noReentrancy {\r\n        Donor storage donor = donors[msg.sender];\r\n\r\n        for (uint256 i = 0; i < newKeepers.length; i++) {\r\n            donor.keepers[newKeepers[i]] = true;\r\n        }\r\n\r\n        emit AddKeepers(newKeepers);\r\n    }\r\n\r\n    function removeKeepers(address[] calldata keepersToRemove) external active noReentrancy {\r\n        Donor storage donor = donors[msg.sender];\r\n\r\n        for (uint256 i = 0; i < keepersToRemove.length; i++) {\r\n            donor.keepers[keepersToRemove[i]] = false;\r\n        }\r\n\r\n        emit RemoveKeepers(keepersToRemove);\r\n    }\r\n\r\n    function _mintSharesForAddress(uint256 sharesToMint, address recipient) internal {\r\n        totalPoolShares = totalPoolShares.add(sharesToMint);\r\n        donors[recipient].shares = donors[recipient].shares.add(sharesToMint);\r\n\r\n        require(\r\n            totalPoolShares <= MAX_NUMBER_OF_SHARES,\r\n            \"MolochPool: Max number of shares exceeded\"\r\n        );\r\n\r\n        emit SharesMinted(\r\n            sharesToMint,\r\n            recipient,\r\n            totalPoolShares\r\n        );\r\n    }\r\n\r\n    function _withdraw(address recipient, uint256 sharesToBurn) internal {\r\n        Donor storage donor = donors[recipient];\r\n\r\n        require(\r\n            donor.shares >= sharesToBurn,\r\n            \"MolochPool: Not enough shares to burn\"\r\n        );\r\n\r\n        uint256 tokensToWithdraw = approvedToken.balanceOf(address(this)).mul(sharesToBurn).div(totalPoolShares);\r\n\r\n        totalPoolShares = totalPoolShares.sub(sharesToBurn);\r\n        donor.shares = donor.shares.sub(sharesToBurn);\r\n\r\n        require(\r\n            approvedToken.transfer(recipient, tokensToWithdraw),\r\n            \"MolochPool: Withdrawal transfer failed\"\r\n        );\r\n\r\n        emit SharesBurned(\r\n            sharesToBurn,\r\n            recipient,\r\n            totalPoolShares\r\n        );\r\n    }\r\n\r\n}\r\n\r\n\r\n// File contracts/Token.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract Token is ERC20 {\r\n  constructor(uint256 supply) public {\r\n    _mint(msg.sender, supply);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"sharesToBurn\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newKeepers\",\"type\":\"address[]\"}],\"name\":\"addKeepers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentProposalIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"moloch\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPoolShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"initialTokens\",\"type\":\"uint256\"},{\"name\":\"initialPoolShares\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"keeperWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toIndex\",\"type\":\"uint256\"}],\"name\":\"sync\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approvedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"donors\",\"outputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"keepersToRemove\",\"type\":\"address[]\"}],\"name\":\"removeKeepers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_moloch\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"currentProposalIndex\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"donor\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"donor\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"donor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"keeper\",\"type\":\"address\"}],\"name\":\"KeeperWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addedKeepers\",\"type\":\"address[]\"}],\"name\":\"AddKeepers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"removedKeepers\",\"type\":\"address[]\"}],\"name\":\"RemoveKeepers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sharesToMint\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalPoolShares\",\"type\":\"uint256\"}],\"name\":\"SharesMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sharesToBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalPoolShares\",\"type\":\"uint256\"}],\"name\":\"SharesBurned\",\"type\":\"event\"}]","ContractName":"MolochPool","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001fd169a4f5c59acf79d0fd5d91d1201ef1bce9f1","Library":"","SwarmSource":"bzzr://f25ed1287a0682b99ea44554a390b210406c4554cf289e2b10893ad127cb98dc"}]}