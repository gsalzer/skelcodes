{"status":"1","message":"OK","result":[{"SourceCode":"/**\nCrypto-Cards by Phat-Cats Inc., Copyright 2019\n*/\n\npragma solidity 0.5.0;\n\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    \n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    \n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    \n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    \n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    \n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\ninterface IERC165 {\n    \n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    \n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    \n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    \n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    \n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\ncontract IERC721Enumerable is IERC721 {\n    function totalSupply() public view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) public view returns (uint256);\n}\n\ncontract ERC165 is IERC165 {\n    \n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    \n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        \n        \n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    \n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    \n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\ncontract IERC721Receiver {\n    \n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        \n        \n        \n\n        uint256 size;\n        \n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\ncontract ERC721 is ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    \n    \n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    \n    mapping (uint256 => address) private _tokenOwner;\n\n    \n    mapping (uint256 => address) private _tokenApprovals;\n\n    \n    mapping (address => uint256) internal _ownedTokensCount;\n\n    \n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n    \n\n    constructor () public {\n        \n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    \n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0));\n        return _ownedTokensCount[owner];\n    }\n\n    \n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0));\n        return owner;\n    }\n\n    \n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    \n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId));\n        return _tokenApprovals[tokenId];\n    }\n\n    \n    function setApprovalForAll(address to, bool approved) public {\n        require(to != msg.sender);\n        _operatorApprovals[msg.sender][to] = approved;\n        emit ApprovalForAll(msg.sender, to, approved);\n    }\n\n    \n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    \n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    \n    function fastTransferFrom(address from, address to, uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n\n        _fastTransferFrom(from, to, tokenId);\n    }\n\n    \n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    \n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data));\n    }\n\n    \n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    \n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    \n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0));\n        require(!_exists(tokenId));\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    \n    function _fastMint(address to, uint256 tokenId) internal {\n        if (_tokenOwner[tokenId] == address(0)) {\n            _tokenOwner[tokenId] = to;\n        }\n        emit Transfer(address(0), to, tokenId); \n    }\n\n    \n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner);\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    \n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    \n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from);\n        require(to != address(0));\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    \n    function _fastTransferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from);\n        _clearApproval(tokenId);\n        _tokenOwner[tokenId] = to;\n        emit Transfer(from, to, tokenId); \n    }\n\n    \n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n    internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    \n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\n    \n    mapping(address => uint256[]) private _ownedTokens;\n\n    \n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    \n    uint256[] private _allTokens;\n\n    \n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n    \n\n    \n    constructor () public {\n        \n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    \n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        require(index < balanceOf(owner));\n        return _ownedTokens[owner][index];\n    }\n\n    \n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    \n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply());\n        return _allTokens[index];\n    }\n\n    \n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        super._transferFrom(from, to, tokenId);\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    \n    function _fastTransferFrom(address from, address to, uint256 tokenId) internal {\n        super._fastTransferFrom(from, to, tokenId);\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    \n    function _mint(address to, uint256 tokenId) internal {\n        super._mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    \n    function _fastMint(address to, uint256 tokenId) internal {\n        super._fastMint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    \n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\n        \n        _ownedTokensIndex[tokenId] = 0;\n\n        _removeTokenFromAllTokensEnumeration(tokenId);\n    }\n\n    \n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n        return _ownedTokens[owner];\n    }\n\n    \n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    \n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    \n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        \n        \n\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        \n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; \n            _ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n\n        \n        _ownedTokens[from].length--;\n\n        \n        \n    }\n\n    \n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        \n        \n\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        \n        \n        \n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; \n        _allTokensIndex[lastTokenId] = tokenIndex; \n\n        \n        _allTokens.length--;\n        _allTokensIndex[tokenId] = 0;\n    }\n}\n\ncontract OwnableDelegateProxy { }\n\ncontract ProxyRegistry {\n    mapping(address => OwnableDelegateProxy) public proxies;\n}\n\ncontract CryptoCardsERC721Batched is ERC721Enumerable {\n\n    \n    \n    \n    string internal _tokenName;\n    string internal _tokenSymbol;\n    string internal _baseTokenURI;\n\n    \n    address internal _proxyRegistryAddress;\n\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n    \n\n    \n    \n    \n    event BatchTransfer(address from, address to, uint256[] tokenIds);\n\n    \n    \n    \n    constructor(string memory name, string memory symbol, string memory uri) public {\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n\n        _tokenName = name;\n        _tokenSymbol = symbol;\n        _baseTokenURI = uri;\n    }\n\n    \n    \n    \n\n    function getVersion() public pure returns (string memory) {\n        return \"v2.2.1\";\n    }\n\n    function name() external view returns (string memory) {\n        return _tokenName;\n    }\n\n    function symbol() external view returns (string memory) {\n        return _tokenSymbol;\n    }\n\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        require(_exists(tokenId), \"Token doesn't exist\");\n        return string(abi.encodePacked(\n                _baseTokenURI,\n                uint2str(tokenId),\n                \".json\"\n            ));\n    }\n\n    function exists(uint256 tokenId) public view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    function batchTransferFrom(address from, address to, uint256[] memory tokenIds) public {\n        require(to != address(0));\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _fastTransferFrom(from, to, tokenIds[i]);\n        }\n\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(tokenIds.length);\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(tokenIds.length);\n\n\n    }\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        \n        ProxyRegistry proxyRegistry = ProxyRegistry(_proxyRegistryAddress);\n        if (address(proxyRegistry.proxies(owner)) == operator) {\n            return true;\n        }\n\n        return super.isApprovedForAll(owner, operator);\n    }\n\n    \n    \n    \n\n    function _setProxyRegistryAddress(address proxy) internal {\n        _proxyRegistryAddress = proxy;\n    }\n\n    function _mintBatch(address to, uint256[] memory tokenIds) internal {\n        require(to != address(0));\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _fastMint(to, tokenIds[i]);\n        }\n\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(tokenIds.length);\n\n\n    }\n\n    function uint2str(uint _i) private pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = byte(uint8(48 + _i % 10));\n            _i /= 10;\n        }\n\n        return string(bstr);\n    }\n}\n\ncontract CryptoCardsCardToken is CryptoCardsERC721Batched, MinterRole, Ownable {\n    uint internal constant ETH_DIV = 1000000;\n    uint internal constant ETH_MAX = 4194304;\n\n    \n    \n    \n    \n    mapping(uint => bool) internal _printedTokens;\n\n    \n    \n    uint internal _wrappedEtherDemand;\n\n    \n    \n    \n    event CardsCombined(address indexed owner, uint tokenA, uint tokenB, uint newTokenId, bytes16 uuid);\n    event CardPrinted(address indexed owner, uint tokenId, uint wrappedEther, bytes16 uuid);\n    event CardMelted(address indexed owner, uint tokenId, uint wrappedEther, uint wrappedGum, bytes16 uuid);\n    event WrappedEtherDeposit(uint amount);\n\n    \n    \n    \n    constructor() public CryptoCardsERC721Batched(\"Crypto-Cards - Cards\", \"CARDS\", \"https://crypto-cards.io/card-info/\") { }\n\n    \n    \n    \n\n    \n    function getYear(uint tokenId) public pure returns (uint64) {\n        return _readBits(tokenId, 0, 4);\n    }\n\n    \n    function getGeneration(uint tokenId) public pure returns (uint64) {\n        return _readBits(tokenId, 4, 6);\n    }\n\n    \n    function getRank(uint tokenId) public pure returns (uint64) {\n        return _readBits(tokenId, 10, 10);\n    }\n\n    \n    function getIssue(uint tokenId) public pure returns (uint64) {\n        return _readBits(tokenId, 20, 12);\n    }\n\n    function getTypeIndicators(uint tokenId) public pure returns (uint64, uint64, uint64) {\n        uint64 y = getYear(tokenId);\n        uint64 g = getGeneration(tokenId);\n        uint64 r = getRank(tokenId);\n        return (y, g, r);\n    }\n\n    \n    function getWrappedGum(uint tokenId) public pure returns (uint64) {\n        return _readBits(tokenId, 32, 10);\n    }\n\n    \n    function getWrappedEther(uint tokenId) public pure returns (uint) {\n        return _convertToEther(_getWrappedEtherRaw(tokenId));\n    }\n\n    function isTokenPrinted(uint tokenId) public view returns (bool) {\n        return _printedTokens[tokenId];\n    }\n\n    function canCombine(uint tokenA, uint tokenB) public view returns (bool) {\n        if (isTokenPrinted(tokenA) || isTokenPrinted(tokenB)) { return false; }\n        if (getGeneration(tokenA) < 1) { return false; }\n\n        uint32 typeA = uint32(_readBits(tokenA, 0, 20)); \n        uint32 typeB = uint32(_readBits(tokenB, 0, 20)); \n        return (typeA == typeB);\n    }\n\n    \n    \n    \n    \n    \n    \n\n    function mintCardsFromPack(address to, uint[] memory tokenIds) public onlyMinter {\n        \n        _mintBatch(to, tokenIds);\n\n        \n        uint totalWrappedEth;\n        for (uint i = 0; i < tokenIds.length; i++) {\n            totalWrappedEth = totalWrappedEth + getWrappedEther(tokenIds[i]);\n        }\n        if (totalWrappedEth > 0) {\n            _wrappedEtherDemand = _wrappedEtherDemand + totalWrappedEth;\n        }\n    }\n\n    function migrateCards(address to, uint[] memory tokenIds) public onlyMinter {\n        _mintBatch(to, tokenIds);\n    }\n\n    function printFor(address owner, uint tokenId, bytes16 uuid) public onlyMinter {\n        require(owner == ownerOf(tokenId), \"User does not own this Card\");\n        _printToken(owner, tokenId, uuid);\n    }\n\n    function combineFor(address owner, uint tokenA, uint tokenB, uint newIssue, bytes16 uuid) public onlyMinter returns (uint) {\n        require(owner == ownerOf(tokenA), \"User does not own this Card\"); \n        return _combineTokens(tokenA, tokenB, newIssue, uuid);\n    }\n\n    function meltFor(address owner, uint tokenId, bytes16 uuid) public onlyMinter returns (uint) {\n        require(owner == ownerOf(tokenId), \"User does not own this Card\");\n        return _meltToken(tokenId, uuid);\n    }\n\n    function tokenTransfer(address from, address to, uint tokenId) public onlyMinter {\n        _transferFrom(from, to, tokenId);\n    }\n\n    \n    \n    \n\n    function setBaseTokenURI(string memory uri) public onlyOwner {\n        _baseTokenURI = uri;\n    }\n\n    function setProxyRegistryAddress(address proxy) public onlyOwner {\n        _setProxyRegistryAddress(proxy);\n    }\n\n    function depositWrappedEther(uint amount) public payable onlyOwner {\n        require(amount == msg.value, \"Specified amount does not match actual amount received\");\n        emit WrappedEtherDeposit(amount);\n    }\n\n    function getWrappedEtherDemand() public view onlyOwner returns (uint) {\n        return _wrappedEtherDemand; \n    }\n\n    \n    \n    \n\n    function _combineTokens(uint tokenA, uint tokenB, uint newIssue, bytes16 uuid) private returns (uint) {\n        address owner = ownerOf(tokenA);  \n        require(owner == ownerOf(tokenB), \"User does not own both Cards\");\n        require(canCombine(tokenA, tokenB), \"Cards are not compatible\");\n\n        uint newTokenId = _generateCombinedToken(tokenA, tokenB, newIssue);\n        _mint(owner, newTokenId);\n\n        _burn(owner, tokenA);\n        _burn(owner, tokenB);\n\n        emit CardsCombined(owner, tokenA, tokenB, newTokenId, uuid);\n        return newTokenId;\n    }\n\n    function _printToken(address owner, uint tokenId, bytes16 uuid) private {\n        require(!isTokenPrinted(tokenId), \"Card has already been printed\");\n\n        \n        \n        uint wrappedEth = getWrappedEther(tokenId);\n\n        _printedTokens[tokenId] = true;\n        _payoutEther(owner, wrappedEth);\n\n        emit CardPrinted(owner, tokenId, wrappedEth, uuid);\n    }\n\n    function _meltToken(uint tokenId, bytes16 uuid) private returns (uint) {\n        require(!isTokenPrinted(tokenId), \"Cannot melt printed Cards\");\n        address owner = ownerOf(tokenId);\n\n        \n        uint wrappedGum = getWrappedGum(tokenId);\n        uint wrappedEth = getWrappedEther(tokenId);\n\n        _burn(owner, tokenId);\n        _payoutEther(owner, wrappedEth);\n\n        emit CardMelted(owner, tokenId, wrappedEth, wrappedGum, uuid);\n        return wrappedGum;\n    }\n\n    function _payoutEther(address owner, uint256 ethAmount) private returns (uint) {\n        address payable ownerWallet = address(uint160(owner));\n\n        \n        require(ethAmount <= address(this).balance, \"Not enough funds to pay out wrapped ether, please try again later.\");\n\n        _wrappedEtherDemand = _wrappedEtherDemand - ethAmount;\n\n        ownerWallet.transfer(ethAmount);\n        return ethAmount;\n    }\n\n    function _generateCombinedToken(uint tokenA, uint tokenB, uint newIssue) private returns (uint) {\n        uint64 y = getYear(tokenA);\n        uint64 g = getGeneration(tokenA) - 1;\n        uint64 r = getRank(tokenA);\n        uint64 eth = _getCombinedEtherRaw(tokenA, tokenB);\n\n        uint64[6] memory bits = [\n            y, g, r, uint64(newIssue),\n            getWrappedGum(tokenA) + getWrappedGum(tokenB),\n            eth\n        ];\n        return _generateTokenId(bits);\n    }\n\n    function _getCombinedEtherRaw(uint tokenA, uint tokenB) private returns (uint64) {\n        uint64 eA = _getWrappedEtherRaw(tokenA);\n        uint64 eB = _getWrappedEtherRaw(tokenB);\n        uint combined = uint(eA + eB);\n\n        \n        if (combined > ETH_MAX) { \n            uint overage = _convertToEther(combined - ETH_MAX);\n            _payoutEther(ownerOf(tokenA), overage);\n            combined = ETH_MAX;\n        }\n        return uint64(combined);\n    }\n\n    function _getWrappedEtherRaw(uint tokenId) private pure returns (uint64) {\n        return _readBits(tokenId, 42, 22);\n    }\n\n    function _convertToEther(uint rawValue) private pure returns (uint) {\n        return rawValue * (1 ether) / ETH_DIV;\n    }\n\n    function _generateTokenId(uint64[6] memory bits) private pure returns (uint) {\n        return uint(bits[0] | (bits[1] << 4) | (bits[2] << 10) | (bits[3] << 20) | (bits[4] << 32) | (bits[5] << 42));\n    }\n\n    function _readBits(uint num, uint from, uint len) private pure returns (uint64) {\n        uint mask = ((1 << len) - 1) << from;\n        return uint64((num & mask) >> from);\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenA\",\"type\":\"uint256\"},{\"name\":\"tokenB\",\"type\":\"uint256\"}],\"name\":\"canCombine\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"printFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWrappedEtherDemand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setBaseTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"fastTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getWrappedEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getWrappedGum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getGeneration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"migrateCards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"meltFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getIssue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositWrappedEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRank\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTypeIndicators\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"tokenA\",\"type\":\"uint256\"},{\"name\":\"tokenB\",\"type\":\"uint256\"},{\"name\":\"newIssue\",\"type\":\"uint256\"},{\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"combineFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"setProxyRegistryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"mintCardsFromPack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isTokenPrinted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenA\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenB\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"CardsCombined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"wrappedEther\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"CardPrinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"wrappedEther\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"wrappedGum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"uuid\",\"type\":\"bytes16\"}],\"name\":\"CardMelted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WrappedEtherDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"BatchTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"CryptoCardsCardToken","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://fa179c050f6121053686c80815dac01f3de7989a747538d75a87ae3893900522"}]}