{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n/**\r\n * @title IERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function setup() public;\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721Enumerable is IERC721 {\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\r\n\r\n    function tokenByIndex(uint256 index) public view returns (uint256);\r\n}\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721Full is IERC721, IERC721Enumerable, IERC721Metadata {\r\n    // solhint-disable-previous-line no-empty-blocks\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\ncontract VitalikSteward {\r\n    \r\n    /*\r\n    This smart contract collects patronage from current owner through a Harberger tax model and \r\n    takes stewardship of the asset token if the patron can't pay anymore.\r\n\r\n    Harberger Tax (COST): \r\n    - Asset is always on sale.\r\n    - You have to have a price set.\r\n    - Tax (Patronage) is paid to maintain ownership.\r\n    - Steward maints control over ERC721.\r\n    */\r\n    using SafeMath for uint256;\r\n    \r\n    uint256 public price; //in wei\r\n    IERC721Full public assetToken; // ERC721 NFT.\r\n    \r\n    uint256 public totalCollected; // all patronage ever collected\r\n    uint256 public currentCollected; // amount currently collected for patron  \r\n    uint256 public timeLastCollected; // \r\n    uint256 public deposit;\r\n\r\n    address payable public organization; // non-profit organization\r\n    uint256 public organizationFund;\r\n    \r\n    mapping (address => bool) public patrons;\r\n    mapping (address => uint256) public timeHeld;\r\n\r\n    uint256 public timeAcquired;\r\n    \r\n    // 30% patronage\r\n    uint256 patronageNumerator = 300000000000;\r\n    uint256 patronageDenominator = 1000000000000;\r\n\r\n    enum StewardState { Foreclosed, Owned }\r\n    StewardState public state;\r\n\r\n    constructor(address payable _organization, address _assetToken) public {\r\n        assetToken = IERC721Full(_assetToken);\r\n        assetToken.setup();\r\n        organization = _organization;\r\n        state = StewardState.Foreclosed;\r\n    } \r\n\r\n    event LogBuy(address indexed owner, uint256 indexed price);\r\n    event LogPriceChange(uint256 indexed newPrice);\r\n    event LogForeclosure(address indexed prevOwner);\r\n    event LogCollection(uint256 indexed collected);\r\n    \r\n    modifier onlyPatron() {\r\n        require(msg.sender == assetToken.ownerOf(42), \"Not patron\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyReceivingOrganization() {\r\n        require(msg.sender == organization, \"Not organization\");\r\n        _;\r\n    }\r\n\r\n    modifier collectPatronage() {\r\n       _collectPatronage(); \r\n       _;\r\n    }\r\n\r\n    function changeReceivingOrganization(address payable _newReceivingOrganization) public onlyReceivingOrganization {\r\n        organization = _newReceivingOrganization;\r\n    }\r\n\r\n    /* public view functions */\r\n    function patronageOwed() public view returns (uint256 patronageDue) {\r\n        return price.mul(now.sub(timeLastCollected)).mul(patronageNumerator)\r\n            .div(patronageDenominator).div(365 days);\r\n    }\r\n\r\n    function patronageOwedWithTimestamp() public view returns (uint256 patronageDue, uint256 timestamp) {\r\n        return (patronageOwed(), now);\r\n    }\r\n\r\n    function foreclosed() public view returns (bool) {\r\n        // returns whether it is in foreclosed state or not\r\n        // depending on whether deposit covers patronage due\r\n        // useful helper function when price should be zero, but contract doesn't reflect it yet.\r\n        uint256 collection = patronageOwed();\r\n        if(collection >= deposit) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // same function as above, basically\r\n    function depositAbleToWithdraw() public view returns (uint256) {\r\n        uint256 collection = patronageOwed();\r\n        if(collection >= deposit) {\r\n            return 0;\r\n        } else {\r\n            return deposit.sub(collection);\r\n        }\r\n    }\r\n\r\n    /*\r\n    now + deposit/patronage per second \r\n    now + depositAbleToWithdraw/(price*nume/denom/365).\r\n    */\r\n    function foreclosureTime() public view returns (uint256) {\r\n        // patronage per second\r\n        uint256 pps = price.mul(patronageNumerator).div(patronageDenominator).div(365 days);\r\n        return now + depositAbleToWithdraw().div(pps); // zero division if price is zero.\r\n    }\r\n\r\n    /* actions */\r\n    function _collectPatronage() public {\r\n        // determine patronage to pay\r\n        if (state == StewardState.Owned) {\r\n            uint256 collection = patronageOwed();\r\n            \r\n            // should foreclose and stake stewardship\r\n            if (collection >= deposit) {\r\n                // up to when was it actually paid for?\r\n                timeLastCollected = timeLastCollected.add(((now.sub(timeLastCollected)).mul(deposit).div(collection)));\r\n                collection = deposit; // take what's left.\r\n\r\n                _foreclose();\r\n            } else  {\r\n                // just a normal collection\r\n                timeLastCollected = now;\r\n                currentCollected = currentCollected.add(collection);\r\n            }\r\n            \r\n            deposit = deposit.sub(collection);\r\n            totalCollected = totalCollected.add(collection);\r\n            organizationFund = organizationFund.add(collection);\r\n            emit LogCollection(collection);\r\n        }\r\n    }\r\n    \r\n    // note: anyone can deposit\r\n    function depositWei() public payable collectPatronage {\r\n        require(state != StewardState.Foreclosed, \"Foreclosed\");\r\n        deposit = deposit.add(msg.value);\r\n    }\r\n    \r\n    function buy(uint256 _newPrice) public payable collectPatronage {\r\n        require(_newPrice > 0, \"Price is zero\");\r\n        require(msg.value > price, \"Not enough\"); // >, coz need to have at least something for deposit\r\n        address currentOwner = assetToken.ownerOf(42);\r\n\r\n        if (state == StewardState.Owned) {\r\n            uint256 totalToPayBack = price;\r\n            if(deposit > 0) {\r\n                totalToPayBack = totalToPayBack.add(deposit);\r\n            }  \r\n    \r\n            // pay previous owner their price + deposit back.\r\n            address payable payableCurrentOwner = address(uint160(currentOwner));\r\n            payableCurrentOwner.transfer(totalToPayBack);\r\n        } else if(state == StewardState.Foreclosed) {\r\n            state = StewardState.Owned;\r\n            timeLastCollected = now;\r\n        }\r\n        \r\n        deposit = msg.value.sub(price);\r\n        transferAssetTokenTo(currentOwner, msg.sender, _newPrice);\r\n        emit LogBuy(msg.sender, _newPrice);\r\n    }\r\n\r\n    function changePrice(uint256 _newPrice) public onlyPatron collectPatronage {\r\n        require(state != StewardState.Foreclosed, \"Foreclosed\");\r\n        require(_newPrice != 0, \"Incorrect Price\");\r\n        \r\n        price = _newPrice;\r\n        emit LogPriceChange(price);\r\n    }\r\n    \r\n    function withdrawDeposit(uint256 _wei) public onlyPatron collectPatronage returns (uint256) {\r\n        _withdrawDeposit(_wei);\r\n    }\r\n\r\n    function withdrawOrganizationFunds() public {\r\n        require(msg.sender == organization, \"Not organization\");\r\n        organization.transfer(organizationFund);\r\n        organizationFund = 0;\r\n    }\r\n\r\n    function exit() public onlyPatron collectPatronage {\r\n        _withdrawDeposit(deposit);\r\n    }\r\n\r\n    /* internal */\r\n\r\n    function _withdrawDeposit(uint256 _wei) internal {\r\n        // note: can withdraw whole deposit, which puts it in immediate to be foreclosed state.\r\n        require(deposit >= _wei, 'Withdrawing too much');\r\n\r\n        deposit = deposit.sub(_wei);\r\n        msg.sender.transfer(_wei); // msg.sender == patron\r\n\r\n        if(deposit == 0) {\r\n            _foreclose();\r\n        }\r\n    }\r\n\r\n    function _foreclose() internal {\r\n        // become steward of assetToken (aka foreclose)\r\n        address currentOwner = assetToken.ownerOf(42);\r\n        transferAssetTokenTo(currentOwner, address(this), 0);\r\n        state = StewardState.Foreclosed;\r\n        currentCollected = 0;\r\n\r\n        emit LogForeclosure(currentOwner);\r\n    }\r\n\r\n    function transferAssetTokenTo(address _currentOwner, address _newOwner, uint256 _newPrice) internal {\r\n        // note: it would also tabulate time held in stewardship by smart contract\r\n        timeHeld[_currentOwner] = timeHeld[_currentOwner].add((timeLastCollected.sub(timeAcquired)));\r\n        \r\n        assetToken.transferFrom(_currentOwner, _newOwner, 42);\r\n\r\n        price = _newPrice;\r\n        timeAcquired = now;\r\n        patrons[_newOwner] = true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"assetToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositWei\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"organization\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"patrons\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foreclosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"withdrawDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_collectPatronage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newReceivingOrganization\",\"type\":\"address\"}],\"name\":\"changeReceivingOrganization\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeAcquired\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawOrganizationFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foreclosureTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"patronageOwedWithTimestamp\",\"outputs\":[{\"name\":\"patronageDue\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"patronageOwed\",\"outputs\":[{\"name\":\"patronageDue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositAbleToWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"timeHeld\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"changePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"organizationFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeLastCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_organization\",\"type\":\"address\"},{\"name\":\"_assetToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"LogBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"LogPriceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prevOwner\",\"type\":\"address\"}],\"name\":\"LogForeclosure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"collected\",\"type\":\"uint256\"}],\"name\":\"LogCollection\",\"type\":\"event\"}]","ContractName":"VitalikSteward","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000003ea1ecb8775a37fb797bb79f6c419176f15e35d4000000000000000000000000231570f1ea43de41adb3ee04188ce18c8d10deed","Library":"","SwarmSource":"bzzr://3b20d297b6c6df5f2e8ebd8d96df59c6ffbb87b4b1dcb4ee70d72710c53a1b75"}]}