{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.4;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Contract for Rewards Token\r\n * Copyright 2018, Rewards Blockchain Systems (Rewards.com)\r\n */\r\n\r\ncontract RewardsToken is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    string public constant symbol = 'RWRD';\r\n    string public constant name = 'Rewards Cash';\r\n    uint8 public constant decimals = 18;\r\n\r\n    uint256 public constant hardCap = 5 * (10 ** (18 + 8)); //500MM tokens. Max amount of tokens which can be minte10\r\n    uint256 public totalSupply;\r\n\r\n    bool public mintingFinished = false;\r\n    bool public frozen = true;\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) internal allowed;\r\n\r\n    event NewToken(address indexed _token);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event Burned(address indexed _burner, uint _burnedAmount);\r\n    event Revoke(address indexed _from, uint256 _value);\r\n    event MintFinished();\r\n    event MintStarted();\r\n    event Freeze();\r\n    event Unfreeze();\r\n\r\n    modifier canMint() {\r\n        require(!mintingFinished, \"Minting was already finished\");\r\n        _;\r\n    }\r\n\r\n    modifier canTransfer() {\r\n        require(msg.sender == owner || !frozen, \"Tokens could not be transferred\");\r\n        _;\r\n    }\r\n\r\n    constructor () public {\r\n        emit NewToken(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param _to The address that will receive the minted tokens.\r\n     * @param _amount The amount of tokens to mint.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\r\n        require(_to != address(0), \"Address should not be zero\");\r\n        require(totalSupply.add(_amount) <= hardCap);\r\n\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to stop minting new tokens.\r\n     * @return True if the operation was successful.\r\n     */\r\n    function finishMinting() public onlyOwner returns (bool) {\r\n        require(!mintingFinished);\r\n        mintingFinished = true;\r\n        emit MintFinished();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to start minging new tokens.\r\n     * @return True if the operation was successful\r\n     */\r\n    function startMinting() public onlyOwner returns (bool) {\r\n        require(mintingFinished);\r\n        mintingFinished = false;\r\n        emit MintStarted();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public canTransfer returns (bool) {\r\n        require(_to != address(0), \"Address should not be zero\");\r\n        require(_value <= balances[msg.sender], \"Insufficient balance\");\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender] - _value;\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer returns (bool) {\r\n        require(_to != address(0), \"Address should not be zero\");\r\n        require(_value <= balances[_from], \"Insufficient Balance\");\r\n        require(_value <= allowed[_from][msg.sender], \"Insufficient Allowance\");\r\n\r\n        balances[_from] = balances[_from] - _value;\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param _owner The address to query the the balance of.\r\n     * @return An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /** \r\n     * @dev Burn tokens from an address\r\n     * @param _burnAmount The amount of tokens to burn\r\n     */\r\n    function burn(uint _burnAmount) public {\r\n        require(_burnAmount <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_burnAmount);\r\n        totalSupply = totalSupply.sub(_burnAmount);\r\n        emit Burned(msg.sender, _burnAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes minted tokens\r\n     * @param _from The address whose tokens are revoked\r\n     * @param _value The amount of token to revoke\r\n     */\r\n    function revoke(address _from, uint256 _value) public onlyOwner returns (bool) {\r\n        require(_value <= balances[_from]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n\r\n        emit Revoke(_from, _value);\r\n        emit Transfer(_from, address(0), _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Freeze tokens\r\n     */\r\n    function freeze() public onlyOwner {\r\n        require(!frozen);\r\n        frozen = true;\r\n        emit Freeze();\r\n    }\r\n\r\n    /**\r\n     * @dev Unfreeze tokens \r\n     */\r\n    function unfreeze() public onlyOwner {\r\n        require(frozen);\r\n        frozen = false;\r\n        emit Unfreeze();\r\n    }\r\n}\r\n\r\n/**\r\n * @title Contract that will hold vested tokens;\r\n * @notice Tokens for vested contributors will be hold in this contract and token holders\r\n * will claim their tokens according to their own vesting timelines.\r\n * Copyright 2018, Rewards Blockchain Systems (Rewards.com)\r\n */\r\ncontract VestingVault is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    struct Grant {\r\n        uint value;\r\n        uint vestingStart;\r\n        uint vestingCliff;\r\n        uint vestingDuration;\r\n        uint[] scheduleTimes;\r\n        uint[] scheduleValues;\r\n        uint level;              // 1: frequency, 2: schedules\r\n        uint transferred;\r\n    }\r\n\r\n    RewardsToken public token;\r\n\r\n    mapping(address => Grant) public grants;\r\n\r\n    uint public totalVestedTokens;\r\n    // array of vested users addresses\r\n    address[] public vestedAddresses;\r\n    bool public locked;\r\n\r\n    event NewGrant (address _to, uint _amount, uint _start, uint _duration, uint _cliff, uint[] _scheduleTimes,\r\n                    uint[] _scheduleAmounts, uint _level);\r\n    event NewRelease(address _holder, uint _amount);\r\n    event WithdrawAll(uint _amount);\r\n    event BurnTokens(uint _amount);\r\n    event LockedVault();\r\n\r\n    modifier isOpen() {\r\n        require(locked == false, \"Vault is already locked\");\r\n        _;\r\n    }\r\n\r\n    constructor (RewardsToken _token) public {\r\n        require(address(_token) != address(0), \"Token address should not be zero\");\r\n\r\n        token = _token;\r\n        locked = false;\r\n    }\r\n\r\n    /**\r\n     * @return address[] that represents vested addresses;\r\n     */\r\n    function returnVestedAddresses() public view returns (address[] memory) {\r\n        return vestedAddresses;\r\n    }\r\n\r\n    /**\r\n     * @return grant that represents vested info for specific user;\r\n     */\r\n    function returnGrantInfo(address _user)\r\n    public view returns (uint, uint, uint, uint, uint[] memory, uint[] memory, uint, uint) {\r\n        require(_user != address(0), \"Address should not be zero\");\r\n        Grant storage grant = grants[_user];\r\n\r\n        return (grant.value, grant.vestingStart, grant.vestingCliff, grant.vestingDuration, grant.scheduleTimes,\r\n        grant.scheduleValues, grant.level, grant.transferred);\r\n    }\r\n\r\n    /**\r\n     * @dev Add vested contributor information\r\n     * @param _to Withdraw address that tokens will be sent\r\n     * @param _value Amount to hold during vesting period\r\n     * @param _start Unix epoch time that vesting starts from\r\n     * @param _duration Seconds amount of vesting duration\r\n     * @param _cliff Seconds amount of vesting cliffHi\r\n     * @param _scheduleTimes Array of Unix epoch times for vesting schedules\r\n     * @param _scheduleValues Array of Amount for vesting schedules\r\n     * @param _level Indicator that will represent types of vesting\r\n     * @return Int value that represents granted token amount\r\n     */\r\n    function grant(\r\n        address _to, uint _value, uint _start, uint _duration, uint _cliff, uint[] memory _scheduleTimes,\r\n        uint[] memory _scheduleValues, uint _level) public onlyOwner isOpen returns (uint256) {\r\n        require(_to != address(0), \"Address should not be zero\");\r\n        require(_level == 1 || _level == 2, \"Invalid vesting level\");\r\n        // make sure a single address can be granted tokens only once.\r\n        require(grants[_to].value == 0, \"Already added to vesting vault\");\r\n\r\n        if (_level == 2) {\r\n            require(_scheduleTimes.length == _scheduleValues.length, \"Schedule Times and Values should be matched\");\r\n            _value = 0;\r\n            for (uint i = 0; i < _scheduleTimes.length; i++) {\r\n                require(_scheduleTimes[i] > 0, \"Seconds Amount of ScheduleTime should be greater than zero\");\r\n                require(_scheduleValues[i] > 0, \"Amount of ScheduleValue should be greater than zero\");\r\n                if (i > 0) {\r\n                    require(_scheduleTimes[i] > _scheduleTimes[i - 1], \"ScheduleTimes should be sorted by ASC\");\r\n                }\r\n                _value = _value.add(_scheduleValues[i]);\r\n            }\r\n        }\r\n\r\n        require(_value > 0, \"Vested amount should be greater than zero\");\r\n\r\n        grants[_to] = Grant({\r\n            value : _value,\r\n            vestingStart : _start,\r\n            vestingDuration : _duration,\r\n            vestingCliff : _cliff,\r\n            scheduleTimes : _scheduleTimes,\r\n            scheduleValues : _scheduleValues,\r\n            level : _level,\r\n            transferred : 0\r\n            });\r\n\r\n        vestedAddresses.push(_to);\r\n        totalVestedTokens = totalVestedTokens.add(_value);\r\n\r\n        emit NewGrant(_to, _value, _start, _duration, _cliff, _scheduleTimes, _scheduleValues, _level);\r\n        return _value;\r\n    }\r\n\r\n    /**\r\n     * @dev Get token amount for a token holder available to transfer at specific time\r\n     * @param _holder Address that represents holder's withdraw address\r\n     * @param _time Unix epoch time at the moment\r\n     * @return Int value that represents token amount that is available to release at the moment\r\n     */\r\n    function transferableTokens(address _holder, uint256 _time) public view returns (uint256) {\r\n        Grant storage grantInfo = grants[_holder];\r\n\r\n        if (grantInfo.value == 0) {\r\n            return 0;\r\n        }\r\n        return calculateTransferableTokens(grantInfo, _time);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to calculate available amount at specific time\r\n     * @param _grant Grant that represents holder's vesting info\r\n     * @param _time Unix epoch time at the moment\r\n     * @return Int value that represents available vested token amount\r\n     */\r\n    function calculateTransferableTokens(Grant memory _grant, uint256 _time) private pure returns (uint256) {\r\n        uint totalVestedAmount = _grant.value;\r\n        uint totalAvailableVestedAmount = 0;\r\n\r\n        if (_grant.level == 1) {\r\n            if (_time < _grant.vestingCliff.add(_grant.vestingStart)) {\r\n                return 0;\r\n            } else if (_time >= _grant.vestingStart.add(_grant.vestingDuration)) {\r\n                return _grant.value;\r\n            } else {\r\n                totalAvailableVestedAmount =\r\n                totalVestedAmount.mul(_time.sub(_grant.vestingStart)).div(_grant.vestingDuration);\r\n            }\r\n        } else {\r\n            if (_time < _grant.scheduleTimes[0]) {\r\n                return 0;\r\n            } else if (_time >= _grant.scheduleTimes[_grant.scheduleTimes.length - 1]) {\r\n                return _grant.value;\r\n            } else {\r\n                for (uint i = 0; i < _grant.scheduleTimes.length; i++) {\r\n                    if (_grant.scheduleTimes[i] <= _time) {\r\n                        totalAvailableVestedAmount = totalAvailableVestedAmount.add(_grant.scheduleValues[i]);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return totalAvailableVestedAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Claim vested token\r\n     * @notice this will be eligible after vesting start + cliff or schedule times\r\n     */\r\n    function claim() public {\r\n        address beneficiary = msg.sender;\r\n        Grant storage grantInfo = grants[beneficiary];\r\n        require(grantInfo.value > 0, \"Grant does not exist\");\r\n\r\n        uint256 vested = calculateTransferableTokens(grantInfo, now);\r\n        require(vested > 0, \"There is no vested tokens\");\r\n\r\n        uint256 transferable = vested.sub(grantInfo.transferred);\r\n        require(transferable > 0, \"There is no remaining balance for this address\");\r\n        require(token.balanceOf(address(this)) >= transferable, \"Contract Balance is insufficient\");\r\n\r\n        grantInfo.transferred = grantInfo.transferred.add(transferable);\r\n        totalVestedTokens = totalVestedTokens.sub(transferable);\r\n\r\n        token.transfer(beneficiary, transferable);\r\n        emit NewRelease(beneficiary, transferable);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to revoke tokens from an address\r\n     */\r\n    function revokeTokens(address _from, uint _amount) public onlyOwner {\r\n        // finally transfer all remaining tokens to owner\r\n        Grant storage grantInfo = grants[_from];\r\n        require(grantInfo.value > 0, \"Grant does not exist\");\r\n\r\n        uint256 revocable = grantInfo.value.sub(grantInfo.transferred);\r\n        require(revocable > 0, \"There is no remaining balance for this address\");\r\n        require(revocable >= _amount, \"Revocable balance is insufficient\");\r\n        require(token.balanceOf(address(this)) >= _amount, \"Contract Balance is insufficient\");\r\n\r\n        grantInfo.value = grantInfo.value.sub(_amount);\r\n        totalVestedTokens = totalVestedTokens.sub(_amount);\r\n\r\n        token.burn(_amount);\r\n        emit BurnTokens(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to burn remaining tokens\r\n     */\r\n    function burnRemainingTokens() public onlyOwner {\r\n        // finally burn all remaining tokens to owner\r\n        uint amount = token.balanceOf(address(this));\r\n\r\n        token.burn(amount);\r\n        emit BurnTokens(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to withdraw remaining tokens;\r\n     */\r\n    function withdraw() public onlyOwner {\r\n        // finally withdraw all remaining tokens to owner\r\n        uint amount = token.balanceOf(address(this));\r\n        token.transfer(owner, amount);\r\n\r\n        emit WithdrawAll(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to lock vault not to be able to alloc more\r\n     */\r\n    function lockVault() public onlyOwner {\r\n        // finally lock vault\r\n        require(!locked);\r\n        locked = true;\r\n        emit LockedVault();\r\n    }\r\n}\r\n\r\n/**\r\n * @title Contract for distribution of tokens\r\n * Copyright 2018, Rewards Blockchain Systems (Rewards.com)\r\n */\r\ncontract RewardsTokenDistribution is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    RewardsToken public token;\r\n    VestingVault public vestingVault;\r\n\r\n    bool public finished;\r\n\r\n    event TokenMinted(address indexed _to, uint _value, string _id);\r\n    event RevokeTokens(address indexed _from, uint _value);\r\n    event MintingFinished();\r\n   \r\n    modifier isAllowed() {\r\n        require(finished == false, \"Minting was already finished\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param _token Contract address of RewardsToken\r\n     * @param _vestingVault Contract address of VestingVault\r\n     */\r\n    constructor (\r\n        RewardsToken _token,\r\n        VestingVault _vestingVault\r\n    ) public {\r\n        require(address(_token) != address(0), \"Address should not be zero\");\r\n        require(address(_vestingVault) != address(0), \"Address should not be zero\");\r\n\r\n        token = _token;\r\n        vestingVault = _vestingVault;\r\n        finished = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to allocate tokens for normal contributor\r\n     * @param _to Address of a contributor\r\n     * @param _value Value that represents tokens amount allocated for a contributor\r\n     */\r\n    function allocNormalUser(address _to, uint _value) public onlyOwner isAllowed {\r\n        token.mint(_to, _value);\r\n        emit TokenMinted(_to, _value, \"Allocated Tokens To User\");\r\n    }\r\n\r\n    /**\r\n     * @dev Function to allocate tokens for vested contributor\r\n     * @param _to Withdraw address that tokens will be sent\r\n     * @param _value Amount to hold during vesting period\r\n     * @param _start Unix epoch time that vesting starts from\r\n     * @param _duration Seconds amount of vesting duration\r\n     * @param _cliff Seconds amount of vesting cliff\r\n     * @param _scheduleTimes Array of Unix epoch times for vesting schedules\r\n     * @param _scheduleValues Array of Amount for vesting schedules\r\n     * @param _level Indicator that will represent types of vesting\r\n     */\r\n    function allocVestedUser(\r\n        address _to, uint _value, uint _start, uint _duration, uint _cliff, uint[] memory _scheduleTimes,\r\n        uint[] memory _scheduleValues, uint _level) public onlyOwner isAllowed {\r\n        _value = vestingVault.grant(_to, _value, _start, _duration, _cliff, _scheduleTimes, _scheduleValues, _level);\r\n        token.mint(address(vestingVault), _value);\r\n        emit TokenMinted(_to, _value, \"Allocated Vested Tokens To User\");\r\n    }\r\n\r\n    /**\r\n     * @dev Function to allocate tokens for normal contributors\r\n     * @param _holders Address of a contributor\r\n     * @param _amounts Value that represents tokens amount allocated for a contributor\r\n     */\r\n    function allocNormalUsers(address[] memory _holders, uint[] memory _amounts) public onlyOwner isAllowed {\r\n        require(_holders.length > 0, \"Empty holder addresses\");\r\n        require(_holders.length == _amounts.length, \"Invalid arguments\");\r\n        for (uint i = 0; i < _holders.length; i++) {\r\n            token.mint(_holders[i], _amounts[i]);\r\n            emit TokenMinted(_holders[i], _amounts[i], \"Allocated Tokens To Users\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to revoke tokens from an address\r\n     */\r\n    function revokeTokensFromVestedUser(address _from, uint _amount) public onlyOwner {\r\n        vestingVault.revokeTokens(_from, _amount);\r\n        emit RevokeTokens(_from, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to get back Ownership of RewardToken Contract after minting finished\r\n     */\r\n    function transferBackTokenOwnership() public onlyOwner {\r\n        token.transferOwnership(owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to get back Ownership of VestingVault Contract after minting finished\r\n     */\r\n    function transferBackVestingVaultOwnership() public onlyOwner {\r\n        vestingVault.transferOwnership(owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to finish token distribution\r\n     */\r\n    function finalize() public onlyOwner {\r\n        token.finishMinting();\r\n        finished = true;\r\n        emit MintingFinished();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_holders\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"allocNormalUsers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferBackTokenOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"allocNormalUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_cliff\",\"type\":\"uint256\"},{\"name\":\"_scheduleTimes\",\"type\":\"uint256[]\"},{\"name\":\"_scheduleValues\",\"type\":\"uint256[]\"},{\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"allocVestedUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"revokeTokensFromVestedUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vestingVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferBackVestingVaultOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_vestingVault\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_id\",\"type\":\"string\"}],\"name\":\"TokenMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"RevokeTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintingFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"RewardsTokenDistribution","CompilerVersion":"v0.5.4+commit.9549d8ff","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f318875ae9c1eb745b895cc7a182f9a149e6325f0000000000000000000000006ae4e5aacb5711471d3765ddf2306ee0b184569a","Library":"","SwarmSource":"bzzr://8fbc6aae982a80a2b2b7b1f8ba6554f06af3aca1ac4b9999dc1527d455323326"}]}