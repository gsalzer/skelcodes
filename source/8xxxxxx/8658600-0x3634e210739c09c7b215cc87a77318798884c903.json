{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.11;\r\n\r\n/** @title A contract for issuing, redeeming and transfering SilaUSD StableCoin\r\n* \r\n* @author www.silamoney.com\r\n* Email: contact@silamoney.com\r\n*\r\n*/\r\n\r\n/**Run\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that revert on error\r\n*/\r\n \r\nlibrary SafeMath{\r\n    \r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  \r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  \r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n* @title Arrays\r\n* @dev  overload array operations\r\n*/\r\n\r\nlibrary Arrays{\r\n    \r\n  function arr(address _a) internal pure returns (address[] memory _arr) {\r\n    _arr = new address[](1);\r\n    _arr[0] = _a; \r\n  }\r\n\r\n  function arr(address _a, address _b) internal pure returns (address[] memory _arr) {\r\n    _arr = new address[](2);\r\n    _arr[0] = _a; \r\n    _arr[1] = _b;\r\n  }\r\n\r\n  function arr(address _a, address _b, address _c) internal pure returns (address[] memory _arr) {\r\n    _arr = new address[](3);\r\n    _arr[0] = _a; \r\n    _arr[1] = _b; \r\n    _arr[2] = _c; \r\n  }\r\n\r\n}\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract hotOwner and ColdOwner, and provides authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\n\r\ncontract Ownable{\r\n    \r\n    // hot and cold wallet addresses\r\n    \r\n    address public hotOwner = 0xCd39203A332Ff477a35dA3AD2AD7761cDBEAb7F0;\r\n\r\n    address public coldOwner = 0x1Ba688e70bb4F3CB266b8D721b5597bFbCCFF957;\r\n    \r\n    // event for ownership transfer\r\n    \r\n    event OwnershipTransferred(address indexed _newHotOwner, address indexed _newColdOwner, address indexed _oldColdOwner);\r\n\r\n   /**\r\n   * @dev Reverts if called by any account other than the hotOwner.\r\n   */\r\n   \r\n    modifier onlyHotOwner() {\r\n        require(msg.sender == hotOwner);\r\n        _;\r\n    }\r\n    \r\n   /**\r\n   * @dev Reverts if called by any account other than the coldOwner.\r\n   */\r\n    \r\n    modifier onlyColdOwner() {\r\n        require(msg.sender == coldOwner);\r\n        _;\r\n    }\r\n    \r\n   /**\r\n   * @dev Assigns new hotowner and coldOwner\r\n   * @param _newHotOwner address The address which is a new hot owner.\r\n   * @param _newColdOwner address The address which can change the hotOwner.\r\n   */\r\n    \r\n    function transferOwnership(address _newHotOwner, address _newColdOwner) public onlyColdOwner {\r\n        require(_newHotOwner != address(0));\r\n        require(_newColdOwner!= address(0));\r\n        hotOwner = _newHotOwner;\r\n        coldOwner = _newColdOwner;\r\n        emit OwnershipTransferred(_newHotOwner, _newColdOwner, msg.sender);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n* @title EmergencyToggle\r\n* @dev The EmergencyToggle contract provides a way to pause the contract in emergency\r\n*/\r\n\r\ncontract EmergencyToggle is Ownable{\r\n     \r\n    // pause the entire contract if true\r\n    bool public emergencyFlag; \r\n\r\n    // constructor\r\n    constructor () public{\r\n      emergencyFlag = false;                            \r\n    }\r\n  \r\n    /**\r\n    * @dev onlyHotOwner can can pause the usage of issue,redeem, transfer functions\r\n    */\r\n    \r\n    function emergencyToggle() external onlyHotOwner {\r\n      emergencyFlag = !emergencyFlag;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n* @title Authorizable\r\n* @dev The Authorizable contract can be used to authorize addresses to control silausd main\r\n* functions, this will provide more flexibility in terms of signing trasactions\r\n*/\r\n\r\ncontract Authorizable is Ownable, EmergencyToggle {\r\n    using SafeMath for uint256;\r\n      \r\n    // map to check if the address is authorized to issue, redeem and betalist sila\r\n    mapping(address => bool) authorized;\r\n\r\n    // events for when address is added or removed \r\n    event AuthorityAdded(address indexed _toAdd);\r\n    event AuthorityRemoved(address indexed _toRemove);\r\n    \r\n    // modifier allowing only authorized addresses and hotOwner to call certain functions\r\n    modifier onlyAuthorized() {\r\n        require(authorized[msg.sender] || hotOwner == msg.sender);\r\n        _;\r\n    }\r\n    \r\n   /**\r\n   * @dev Function addAuthorized adds addresses that can betalist, transfer, issue and redeem\r\n   * @param _toAdd address of the added authority\r\n   */\r\n\r\n    function addAuthorized(address _toAdd) public onlyHotOwner {\r\n        require (!emergencyFlag);\r\n        require(_toAdd != address(0));\r\n        require(!authorized[_toAdd]);\r\n        authorized[_toAdd] = true;\r\n        emit AuthorityAdded(_toAdd);\r\n    }\r\n    \r\n   /**\r\n   * @dev Function RemoveAuthorized removes addresses that can betalist and transfer \r\n   * @param _toRemove address of the added authority\r\n   */\r\n\r\n    function removeAuthorized(address _toRemove) public onlyHotOwner {\r\n        require (!emergencyFlag);\r\n        require(_toRemove != address(0));\r\n        require(authorized[_toRemove]);\r\n        authorized[_toRemove] = false;\r\n        emit AuthorityRemoved(_toRemove);\r\n    }\r\n    \r\n   /**\r\n   * @dev check the specified address is authorized to do sila transactions\r\n   * @param _authorized The address to be checked for authority\r\n   */\r\n   \r\n    function isAuthorized(address _authorized) external view returns(bool _isauthorized) {\r\n        return authorized[_authorized];\r\n    }\r\n    \r\n}\r\n\r\n/**\r\n* @title  Token is Betalist,Blacklist\r\n*/\r\n \r\n contract Betalist is Authorizable {\r\n\r\n    // maps for betalisted and blacklisted addresses\r\n    mapping(address => bool) betalisted;\r\n    mapping(address => bool) blacklisted;\r\n\r\n    // events for betalist and blacklist\r\n    event BetalistedAddress (address indexed _betalisted);\r\n    event BlacklistedAddress (address indexed _blacklisted);\r\n    event RemovedAddressFromBlacklist(address indexed _toRemoveBlacklist);\r\n    event RemovedAddressFromBetalist(address indexed _toRemoveBetalist);\r\n\r\n    // variable to check if betalist is required when calling several functions on smart contract\r\n    bool public requireBetalisted;\r\n \r\n    // constructor\r\n    constructor () public {\r\n        requireBetalisted = true;\r\n    }\r\n    \r\n    // modifier to check acceptableTransactor addresses\r\n    \r\n    modifier acceptableTransactors(address[] memory addresses) {\r\n        require(!emergencyFlag);\r\n        if (requireBetalisted){\r\n          for(uint i = 0; i < addresses.length; i++) require( betalisted[addresses[i]] );\r\n        }\r\n        for(uint i = 0; i < addresses.length; i++) {\r\n          address addr = addresses[i];\r\n          require(addr != address(0));\r\n          require(!blacklisted[addr]);\r\n        }\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * @dev betaList the specified address\r\n    * @param _toBetalist The address to betalist\r\n    */\r\n  \r\n    function betalistAddress(address _toBetalist) public onlyAuthorized returns(bool) {\r\n        require(!emergencyFlag);\r\n        require(_toBetalist != address(0));\r\n        require(!blacklisted[_toBetalist]);\r\n        require(!betalisted[_toBetalist]);\r\n        betalisted[_toBetalist] = true;\r\n        emit BetalistedAddress(_toBetalist);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev remove from betaList the specified address\r\n    * @param _toRemoveBetalist The address to be removed\r\n    */\r\n  \r\n    function removeAddressFromBetalist(address _toRemoveBetalist) public onlyAuthorized {\r\n        require(!emergencyFlag);\r\n        require(_toRemoveBetalist != address(0));\r\n        require(betalisted[_toRemoveBetalist]);\r\n        betalisted[_toRemoveBetalist] = false;\r\n        emit RemovedAddressFromBetalist(_toRemoveBetalist);\r\n    }\r\n    \r\n    /**\r\n    * @dev blackList the specified address\r\n    * @param _toBlacklist The address to blacklist\r\n    */\r\n\r\n    function blacklistAddress(address _toBlacklist) public onlyAuthorized returns(bool) {\r\n        require(!emergencyFlag);\r\n        require(_toBlacklist != address(0));\r\n        require(!blacklisted[_toBlacklist]);\r\n        blacklisted[_toBlacklist] = true;\r\n        emit BlacklistedAddress(_toBlacklist);\r\n        return true;\r\n    }\r\n        \r\n    /**\r\n    * @dev remove from blackList the specified address\r\n    * @param _toRemoveBlacklist The address to blacklist\r\n    */\r\n  \r\n    function removeAddressFromBlacklist(address _toRemoveBlacklist) public onlyAuthorized {\r\n        require(!emergencyFlag);\r\n        require(_toRemoveBlacklist != address(0));\r\n        require(blacklisted[_toRemoveBlacklist]);\r\n        blacklisted[_toRemoveBlacklist] = false;\r\n        emit RemovedAddressFromBlacklist(_toRemoveBlacklist);\r\n    }\r\n        \r\n    /**\r\n    * @dev    BlackList addresses in batches \r\n    * @param _toBlacklistAddresses array of addresses to be blacklisted\r\n    */\r\n\r\n    function batchBlacklistAddresses(address[] memory _toBlacklistAddresses) public onlyAuthorized returns(bool) {\r\n        for(uint i = 0; i < _toBlacklistAddresses.length; i++) {\r\n            bool check = blacklistAddress(_toBlacklistAddresses[i]);\r\n            require(check);\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev    Betalist addresses in batches \r\n    * @param _toBetalistAddresses array of addresses to be betalisted \r\n    */\r\n\r\n    function batchBetalistAddresses(address[] memory _toBetalistAddresses) public onlyAuthorized returns(bool) {\r\n        for(uint i = 0; i < _toBetalistAddresses.length; i++) {\r\n            bool check = betalistAddress(_toBetalistAddresses[i]);\r\n            require(check);\r\n        }\r\n        return true;\r\n    }\r\n        \r\n    /**\r\n    * @dev check the specified address if isBetaListed\r\n    * @param _betalisted The address to be checked for betalisting\r\n    */\r\n  \r\n    function isBetalisted(address _betalisted) external view returns(bool) {\r\n            return (betalisted[_betalisted]);\r\n    }\r\n    \r\n    /**\r\n    * @dev check the specified address isBlackListed\r\n    * @param _blacklisted The address to be checked for blacklisting\r\n    */\r\n\r\n    function isBlacklisted(address _blacklisted) external view returns(bool) {\r\n        return (blacklisted[_blacklisted]);\r\n    }\r\n    \r\n}\r\n\r\n/**\r\n* @title  Token is token Interface\r\n*/\r\n\r\ncontract Token{\r\n    \r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public  returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/**\r\n*@title StandardToken\r\n*@dev Implementation of the basic standard token.\r\n*/\r\n\r\ncontract StandardToken is Token, Betalist{\r\n  using SafeMath for uint256;\r\n\r\n    // maps to store balances and allowances\r\n    mapping (address => uint256)  balances;\r\n    \r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    uint256 public totalSupply;\r\n    \r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    \r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n  \r\n    function allowance(address _owner,address _spender)public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n\r\n    function transfer(address _to, uint256 _value) public acceptableTransactors(Arrays.arr(_to, msg.sender)) returns (bool) {\r\n        require(_value <= balances[msg.sender]);\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n  \r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    \r\n    function approve(address _spender, uint256 _value) public acceptableTransactors(Arrays.arr(_spender, msg.sender)) returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n  \r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) public acceptableTransactors(Arrays.arr(_from, _to, msg.sender)) returns (bool) {\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n*@title AuthroizeDeveloper\r\n*@dev Implementation of the authorize developer contract to authorize developers \r\n* to control the users sila balance registered under an app\r\n*/\r\n\r\ncontract AuthorizeDeveloper is StandardToken{\r\n    \r\n    // mapping to store authorization for DeveloperTransfer\r\n    mapping(address => mapping(address => bool)) isAuthorizedDeveloper;\r\n    \r\n    // Events\r\n    event SilaAuthorizedDeveloper (address indexed _developer, address indexed _user);\r\n    event DeveloperTransfer (address indexed _developer, address indexed _from, address indexed _to, uint _amount);\r\n    event SilaRemovedDeveloper (address indexed _developer, address indexed _user);\r\n    event UserAuthorizedDeveloper (address indexed _developer, address indexed _user);\r\n    event UserRemovedDeveloper (address indexed _developer, address indexed _user);\r\n\r\n   /**\r\n   * @dev silaAuthorizeDeveloper to transfer tokens on users behalf\r\n   * @param _developer address The address which is allowed to transfer tokens on users behalf\r\n   * @param _user address The address which developer want to transfer from\r\n   */\r\n    \r\n    function silaAuthorizeDeveloper(address _developer, address _user) public acceptableTransactors(Arrays.arr(_developer, _user)) onlyAuthorized {\r\n        require(!isAuthorizedDeveloper[_developer][_user]);\r\n        isAuthorizedDeveloper[_developer][_user] = true;\r\n        emit SilaAuthorizedDeveloper(_developer,_user);\r\n    }\r\n    \r\n   /**\r\n   * @dev user can Authorize Developer to transfer tokens on their behalf\r\n   * @param _developer address The address which is allowed to transfer tokens on users behalf\r\n   */\r\n    \r\n    function userAuthorizeDeveloper(address _developer) public acceptableTransactors(Arrays.arr(_developer, msg.sender)) {\r\n        require(!isAuthorizedDeveloper[_developer][msg.sender]);\r\n        isAuthorizedDeveloper[_developer][msg.sender] = true;\r\n        emit UserAuthorizedDeveloper(_developer, msg.sender);\r\n    }\r\n    \r\n   /**\r\n   * @dev RemoveDeveloper allowed to transfer tokens on users behalf\r\n   * @param _developer address The address which is allowed to transfer tokens on users behalf\r\n   * @param _user address The address which developer want to transfer from\r\n   */\r\n    \r\n    function silaRemoveDeveloper(address _developer, address _user) public onlyAuthorized {\r\n        require(!emergencyFlag);\r\n        require(_developer != address(0));\r\n        require(_user != address(0));\r\n        require(isAuthorizedDeveloper[_developer][_user]);\r\n        isAuthorizedDeveloper[_developer][_user] = false;\r\n        emit SilaRemovedDeveloper(_developer, _user);\r\n    }\r\n    \r\n   /**\r\n   * @dev userRemovDeveloper to remove the developer allowed to transfer sila\r\n   * @param _developer, The address which is allowed to transfer tokens on users behalf\r\n   */\r\n    \r\n    function userRemoveDeveloper(address _developer) public {\r\n        require(!emergencyFlag);\r\n        require(_developer != address(0));\r\n        require(isAuthorizedDeveloper[_developer][msg.sender]);\r\n        isAuthorizedDeveloper[_developer][msg.sender] = false;\r\n        emit UserRemovedDeveloper(_developer,msg.sender);\r\n    }\r\n    \r\n   /**\r\n   * @dev developerTransfer for developer to transfer tokens on users behalf without requiring ethers in managed  ethereum accounts\r\n   * @param _from address the address to transfer tokens from\r\n   * @param _to address The address which developer want to transfer to\r\n   * @param _amount the amount of tokens user wants to transfer\r\n   */\r\n    \r\n    function developerTransfer(address _from, address _to, uint _amount) public acceptableTransactors(Arrays.arr(_from, _to, msg.sender)) {\r\n        require(isAuthorizedDeveloper[msg.sender][_from]);\r\n        require(_amount <= balances[_from]);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit DeveloperTransfer(msg.sender, _from, _to, _amount);\r\n        emit Transfer(_from, _to, _amount);\r\n    }\r\n    \r\n   /**\r\n   * @dev check if developer is allowed to transfer tokens on users behalf\r\n   * @param _developer the address allowed to transfer tokens \r\n   * @param _for address The user address which developer want to transfer from\r\n   */\r\n    \r\n    function checkIsAuthorizedDeveloper(address _developer, address _for) external view returns (bool) {\r\n        return (isAuthorizedDeveloper[_developer][_for]);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n*@title SilaUsd\r\n*@dev Implementation for sila issue,redeem,protectedTransfer and batch functions\r\n*/\r\n\r\ncontract SilaUsd is AuthorizeDeveloper{\r\n    using SafeMath for uint256;\r\n    \r\n    // parameters for silatoken\r\n    string  public constant name = \"SILAUSD\";\r\n    string  public constant symbol = \"SILA\";\r\n    uint256 public constant decimals = 18;\r\n    string  public constant version = \"2.0\";\r\n    \r\n    // Events fired during successfull execution of main silatoken functions\r\n    event Issued(address indexed _to, uint256 _value);\r\n    event Redeemed(address indexed _from, uint256 _amount);\r\n    event ProtectedTransfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event GlobalLaunchSila(address indexed _launcher);\r\n    event DestroyedBlackFunds(address _blackListedUser, uint _dirtyFunds);\r\n\r\n   /**\r\n   * @dev issue tokens from sila  to _to address\r\n   * @dev only authorized addresses are allowed to call this function\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _amount uint256 the amount of tokens to be issued\r\n   */\r\n\r\n   function issue(address _to, uint256 _amount) public acceptableTransactors(Arrays.arr(_to)) onlyAuthorized returns (bool) {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);                 \r\n        emit Issued(_to, _amount);                     \r\n        return true;\r\n    }\r\n    \r\n   /**\r\n   * @dev redeem tokens from _from address\r\n   * @dev onlyAuthorized  addresses can call this function\r\n   * @param _from address is the address from which tokens are burnt\r\n   * @param _amount uint256 the amount of tokens to be burnt\r\n   */\r\n\r\n    function redeem(address _from, uint256 _amount) public acceptableTransactors(Arrays.arr(_from)) onlyAuthorized returns(bool) {\r\n        require(_amount <= balances[_from]);\r\n        balances[_from] = balances[_from].sub(_amount);   \r\n        totalSupply = totalSupply.sub(_amount);\r\n        emit Redeemed(_from, _amount);\r\n        return true;\r\n    }\r\n    \r\n   /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @dev onlyAuthorized  addresses can call this function\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _amount uint256 the amount of tokens to be transferred\r\n   */\r\n\r\n    function protectedTransfer(address _from, address _to, uint256 _amount) public acceptableTransactors(Arrays.arr(_from, _to)) onlyAuthorized returns(bool) {\r\n        require(_amount <= balances[_from]);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit ProtectedTransfer(_from, _to, _amount);\r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }    \r\n    \r\n    /**\r\n     * @dev destroy the funds of a blacklisted address\r\n     * @param _blackListedUser the blacklisted user address for which the funds need to be destroyed\r\n    */\r\n    \r\n    function destroyBlackFunds(address _blackListedUser) public onlyAuthorized {\r\n        require(blacklisted[_blackListedUser]);\r\n        uint dirtyFunds = balanceOf(_blackListedUser);\r\n        balances[_blackListedUser] = 0;\r\n        totalSupply = totalSupply.sub(dirtyFunds);\r\n        emit DestroyedBlackFunds(_blackListedUser, dirtyFunds);\r\n    }\r\n    \r\n    /**\r\n    * @dev Launch sila for global transfer function to work as standard\r\n    */\r\n    \r\n    function globalLaunchSila() public onlyHotOwner {\r\n        require(!emergencyFlag);\r\n        require(requireBetalisted);\r\n        requireBetalisted = false;\r\n        emit GlobalLaunchSila(msg.sender);\r\n    }\r\n    \r\n    /**\r\n    * @dev batchissue , isuue tokens in batches to multiple addresses at a time\r\n    * @param _amounts The amount of tokens to be issued.\r\n    * @param _toAddresses tokens to be issued to these addresses respectively\r\n    */\r\n    \r\n    function batchIssue(address[] memory _toAddresses, uint256[]  memory _amounts) public onlyAuthorized returns(bool) {\r\n        require(_toAddresses.length == _amounts.length);\r\n        for(uint i = 0; i < _toAddresses.length; i++) {\r\n            bool check = issue(_toAddresses[i],_amounts[i]);\r\n            require(check);\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev batchredeem , redeem tokens in batches from multiple addresses at a time\r\n    * @param _amounts array of amount of tokens to be redeemed.\r\n    * @param _fromAddresses array of addresses from which tokens to be redeemed respectively\r\n    */\r\n    \r\n    function batchRedeem(address[] memory  _fromAddresses, uint256[]  memory _amounts) public onlyAuthorized returns(bool) {\r\n        require(_fromAddresses.length == _amounts.length);\r\n        for(uint i = 0; i < _fromAddresses.length; i++) {\r\n            bool check = redeem(_fromAddresses[i],_amounts[i]);\r\n            require(check);\r\n        }  \r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev batchTransfer, transfer tokens in batches between multiple addresses at a time\r\n    * @param _fromAddresses tokens to be transfered to these addresses respectively\r\n    * @param _toAddresses tokens to be transfered to these addresses respectively\r\n    * @param _amounts The amount of tokens to be transfered\r\n    */\r\n    \r\n    function protectedBatchTransfer(address[] memory _fromAddresses, address[]  memory _toAddresses, uint256[] memory  _amounts) public onlyAuthorized returns(bool) {\r\n        require(_fromAddresses.length == _amounts.length);\r\n        require(_toAddresses.length == _amounts.length);\r\n        require(_fromAddresses.length == _toAddresses.length);\r\n        for(uint i = 0; i < _fromAddresses.length; i++) {\r\n            bool check = protectedTransfer(_fromAddresses[i], _toAddresses[i], _amounts[i]);\r\n            require(check);\r\n        }\r\n        return true;\r\n    } \r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"emergencyToggle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_developer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"silaRemoveDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toRemoveBlacklist\",\"type\":\"address\"}],\"name\":\"removeAddressFromBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"globalLaunchSila\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toRemove\",\"type\":\"address\"}],\"name\":\"removeAuthorized\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coldOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toRemoveBetalist\",\"type\":\"address\"}],\"name\":\"removeAddressFromBetalist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_fromAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchRedeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newHotOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newColdOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_developer\",\"type\":\"address\"}],\"name\":\"userAuthorizeDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_developer\",\"type\":\"address\"}],\"name\":\"userRemoveDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toBetalist\",\"type\":\"address\"}],\"name\":\"betalistAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_toAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchIssue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"developerTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hotOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_toBetalistAddresses\",\"type\":\"address[]\"}],\"name\":\"batchBetalistAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_developer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_for\",\"type\":\"address\"}],\"name\":\"checkIsAuthorizedDeveloper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_developer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"silaAuthorizeDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emergencyFlag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_toBlacklistAddresses\",\"type\":\"address[]\"}],\"name\":\"batchBlacklistAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requireBetalisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_fromAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_toAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"protectedBatchTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAdd\",\"type\":\"address\"}],\"name\":\"addAuthorized\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_betalisted\",\"type\":\"address\"}],\"name\":\"isBetalisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"protectedTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toBlacklist\",\"type\":\"address\"}],\"name\":\"blacklistAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blackListedUser\",\"type\":\"address\"}],\"name\":\"destroyBlackFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_blacklisted\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authorized\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isauthorized\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ProtectedTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_launcher\",\"type\":\"address\"}],\"name\":\"GlobalLaunchSila\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_blackListedUser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_dirtyFunds\",\"type\":\"uint256\"}],\"name\":\"DestroyedBlackFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_developer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"SilaAuthorizedDeveloper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_developer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"DeveloperTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_developer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"SilaRemovedDeveloper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_developer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"UserAuthorizedDeveloper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_developer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"UserRemovedDeveloper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_betalisted\",\"type\":\"address\"}],\"name\":\"BetalistedAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_blacklisted\",\"type\":\"address\"}],\"name\":\"BlacklistedAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_toRemoveBlacklist\",\"type\":\"address\"}],\"name\":\"RemovedAddressFromBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_toRemoveBetalist\",\"type\":\"address\"}],\"name\":\"RemovedAddressFromBetalist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_toAdd\",\"type\":\"address\"}],\"name\":\"AuthorityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_toRemove\",\"type\":\"address\"}],\"name\":\"AuthorityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newHotOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newColdOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldColdOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SilaUsd","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://e1ac84eb27a62e83dacbe1e173d6390d58b83e500c1e74c915ad83c3b95ae9b9"}]}