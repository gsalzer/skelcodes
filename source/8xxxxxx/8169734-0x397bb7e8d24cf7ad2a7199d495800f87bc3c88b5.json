{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IPoly {\r\n    function decimals() external view returns(uint8);\r\n    function totalSupply() external view returns(uint256);\r\n    function balanceOf(address _owner) external view returns(uint256);\r\n    function allowance(address _owner, address _spender) external view returns(uint256);\r\n    function transfer(address _to, uint256 _value) external returns(bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns(bool);\r\n    function approve(address _spender, uint256 _value) external returns(bool);\r\n    function decreaseApproval(address _spender, uint _subtractedValue) external returns(bool);\r\n    function increaseApproval(address _spender, uint _addedValue) external returns(bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary StatusCodes {\r\n\r\n    // ERC1400 status code inspired from ERC1066\r\n    enum Status {\r\n        TransferFailure,\r\n        TransferSuccess,\r\n        InsufficientBalance,\r\n        InsufficientAllowance,\r\n        TransfersHalted,\r\n        FundsLocked,\r\n        InvalidSender,\r\n        InvalidReceiver,\r\n        InvalidOperator\r\n    }\r\n\r\n    function code(Status _status) internal pure returns (byte) {\r\n        return byte(uint8(0x50) + (uint8(_status)));\r\n    }\r\n}\r\n\r\n/**\r\n * @title Helper library use to compare or validate the semantic versions\r\n */\r\n\r\nlibrary VersionUtils {\r\n\r\n    function lessThanOrEqual(uint8[] memory _current, uint8[] memory _new) internal pure returns(bool) {\r\n        require(_current.length == 3);\r\n        require(_new.length == 3);\r\n        uint8 i = 0;\r\n        for (i = 0; i < _current.length; i++) {\r\n            if (_current[i] == _new[i]) continue;\r\n            if (_current[i] < _new[i]) return true;\r\n            if (_current[i] > _new[i]) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function greaterThanOrEqual(uint8[] memory _current, uint8[] memory _new) internal pure returns(bool) {\r\n        require(_current.length == 3);\r\n        require(_new.length == 3);\r\n        uint8 i = 0;\r\n        for (i = 0; i < _current.length; i++) {\r\n            if (_current[i] == _new[i]) continue;\r\n            if (_current[i] > _new[i]) return true;\r\n            if (_current[i] < _new[i]) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to pack the uint8[] array data into uint24 value\r\n     * @param _major Major version\r\n     * @param _minor Minor version\r\n     * @param _patch Patch version\r\n     */\r\n    function pack(uint8 _major, uint8 _minor, uint8 _patch) internal pure returns(uint24) {\r\n        return (uint24(_major) << 16) | (uint24(_minor) << 8) | uint24(_patch);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to convert packed data into uint8 array\r\n     * @param _packedVersion Packed data\r\n     */\r\n    function unpack(uint24 _packedVersion) internal pure returns(uint8[] memory) {\r\n        uint8[] memory _unpackVersion = new uint8[](3);\r\n        _unpackVersion[0] = uint8(_packedVersion >> 16);\r\n        _unpackVersion[1] = uint8(_packedVersion >> 8);\r\n        _unpackVersion[2] = uint8(_packedVersion);\r\n        return _unpackVersion;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Used to packed the KYC data\r\n     */\r\n    function packKYC(uint64 _a, uint64 _b, uint64 _c, uint8 _d) internal pure returns(uint256) {\r\n        // this function packs 3 uint64 and a uint8 together in a uint256 to save storage cost\r\n        // a is rotated left by 136 bits, b is rotated left by 72 bits and c is rotated left by 8 bits.\r\n        // rotation pads empty bits with zeroes so now we can safely do a bitwise OR operation to pack\r\n        // all the variables together.\r\n        return (uint256(_a) << 136) | (uint256(_b) << 72) | (uint256(_c) << 8) | uint256(_d);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to convert packed data into KYC data\r\n     * @param _packedVersion Packed data\r\n     */\r\n    function unpackKYC(uint256 _packedVersion) internal pure returns(uint64 canSendAfter, uint64 canReceiveAfter, uint64 expiryTime, uint8 added) {\r\n        canSendAfter = uint64(_packedVersion >> 136);\r\n        canReceiveAfter = uint64(_packedVersion >> 72);\r\n        expiryTime = uint64(_packedVersion >> 8);\r\n        added = uint8(_packedVersion);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Utility contract for reusable code\r\n */\r\nlibrary Util {\r\n    /**\r\n    * @notice Changes a string to upper case\r\n    * @param _base String to change\r\n    */\r\n    function upper(string memory _base) internal pure returns(string memory) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        for (uint i = 0; i < _baseBytes.length; i++) {\r\n            bytes1 b1 = _baseBytes[i];\r\n            if (b1 >= 0x61 && b1 <= 0x7A) {\r\n                b1 = bytes1(uint8(b1) - 32);\r\n            }\r\n            _baseBytes[i] = b1;\r\n        }\r\n        return string(_baseBytes);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the string into bytes32\r\n     * @param _source String that need to convert into bytes32\r\n     */\r\n    /// Notice - Maximum Length for _source will be 32 chars otherwise returned bytes32 value will have lossy value.\r\n    function stringToBytes32(string memory _source) internal pure returns(bytes32) {\r\n        return bytesToBytes32(bytes(_source), 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Changes bytes into bytes32\r\n     * @param _b Bytes that need to convert into bytes32\r\n     * @param _offset Offset from which to begin conversion\r\n     */\r\n    /// Notice - Maximum length for _source will be 32 chars otherwise returned bytes32 value will have lossy value.\r\n    function bytesToBytes32(bytes memory _b, uint _offset) internal pure returns(bytes32) {\r\n        bytes32 result;\r\n\r\n        for (uint i = 0; i < _b.length; i++) {\r\n            result |= bytes32(_b[_offset + i] & 0xFF) >> (i * 8);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Changes the bytes32 into string\r\n     * @param _source that need to convert into string\r\n     */\r\n    function bytes32ToString(bytes32 _source) internal pure returns(string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        uint j = 0;\r\n        for (j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(_source) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets function signature from _data\r\n     * @param _data Passed data\r\n     * @return bytes4 sig\r\n     */\r\n    function getSig(bytes memory _data) internal pure returns(bytes4 sig) {\r\n        uint len = _data.length < 4 ? _data.length : 4;\r\n        for (uint256 i = 0; i < len; i++) {\r\n          sig |= bytes4(_data[i] & 0xFF) >> (i * 8);\r\n        }\r\n        return sig;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Interface that every module contract should implement\r\n */\r\ninterface IModule {\r\n    /**\r\n     * @notice This function returns the signature of configure function\r\n     */\r\n    function getInitFunction() external pure returns(bytes4 initFunction);\r\n\r\n    /**\r\n     * @notice Return the permission flags that are associated with a module\r\n     */\r\n    function getPermissions() external view returns(bytes32[] memory permissions);\r\n\r\n}\r\n\r\ninterface IOracle {\r\n    /**\r\n    * @notice Returns address of oracle currency (0x0 for ETH)\r\n    */\r\n    function getCurrencyAddress() external view returns(address currency);\r\n\r\n    /**\r\n    * @notice Returns symbol of oracle currency (0x0 for ETH)\r\n    */\r\n    function getCurrencySymbol() external view returns(bytes32 symbol);\r\n\r\n    /**\r\n    * @notice Returns denomination of price\r\n    */\r\n    function getCurrencyDenominated() external view returns(bytes32 denominatedCurrency);\r\n\r\n    /**\r\n    * @notice Returns price - should throw if not valid\r\n    */\r\n    function getPrice() external returns(uint256 price);\r\n\r\n}\r\n\r\ninterface IPolymathRegistry {\r\n\r\n    event ChangeAddress(string _nameKey, address indexed _oldAddress, address indexed _newAddress);\r\n    \r\n    /**\r\n     * @notice Returns the contract address\r\n     * @param _nameKey is the key for the contract address mapping\r\n     * @return address\r\n     */\r\n    function getAddress(string calldata _nameKey) external view returns(address registryAddress);\r\n\r\n    /**\r\n     * @notice Changes the contract address\r\n     * @param _nameKey is the key for the contract address mapping\r\n     * @param _newAddress is the new contract address\r\n     */\r\n    function changeAddress(string calldata _nameKey, address _newAddress) external;\r\n\r\n}\r\n\r\n/**\r\n * @title Interface that every module factory contract should implement\r\n */\r\ninterface IModuleFactory {\r\n    event ChangeSetupCost(uint256 _oldSetupCost, uint256 _newSetupCost);\r\n    event ChangeCostType(bool _isOldCostInPoly, bool _isNewCostInPoly);\r\n    event GenerateModuleFromFactory(\r\n        address _module,\r\n        bytes32 indexed _moduleName,\r\n        address indexed _moduleFactory,\r\n        address _creator,\r\n        uint256 _setupCost,\r\n        uint256 _setupCostInPoly\r\n    );\r\n    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);\r\n\r\n    //Should create an instance of the Module, or throw\r\n    function deploy(bytes calldata _data) external returns(address moduleAddress);\r\n\r\n    /**\r\n     * @notice Get the tags related to the module factory\r\n     */\r\n    function version() external view returns(string memory moduleVersion);\r\n\r\n    /**\r\n     * @notice Get the tags related to the module factory\r\n     */\r\n    function name() external view returns(bytes32 moduleName);\r\n\r\n    /**\r\n     * @notice Returns the title associated with the module\r\n     */\r\n    function title() external view returns(string memory moduleTitle);\r\n\r\n    /**\r\n     * @notice Returns the description associated with the module\r\n     */\r\n    function description() external view returns(string memory moduleDescription);\r\n\r\n    /**\r\n     * @notice Get the setup cost of the module in USD\r\n     */\r\n    function setupCost() external returns(uint256 usdSetupCost);\r\n\r\n    /**\r\n     * @notice Type of the Module factory\r\n     */\r\n    function getTypes() external view returns(uint8[] memory moduleTypes);\r\n\r\n    /**\r\n     * @notice Get the tags related to the module factory\r\n     */\r\n    function getTags() external view returns(bytes32[] memory moduleTags);\r\n\r\n    /**\r\n     * @notice Used to change the setup fee\r\n     * @param _newSetupCost New setup fee\r\n     */\r\n    function changeSetupCost(uint256 _newSetupCost) external;\r\n\r\n    /**\r\n     * @notice Used to change the currency and amount setup cost\r\n     * @param _setupCost new setup cost\r\n     * @param _isCostInPoly new setup cost currency. USD or POLY\r\n     */\r\n    function changeCostAndType(uint256 _setupCost, bool _isCostInPoly) external;\r\n\r\n    /**\r\n     * @notice Function use to change the lower and upper bound of the compatible version st\r\n     * @param _boundType Type of bound\r\n     * @param _newVersion New version array\r\n     */\r\n    function changeSTVersionBounds(string calldata _boundType, uint8[] calldata _newVersion) external;\r\n\r\n    /**\r\n     * @notice Get the setup cost of the module\r\n     */\r\n    function setupCostInPoly() external returns (uint256 polySetupCost);\r\n\r\n    /**\r\n     * @notice Used to get the lower bound\r\n     * @return Lower bound\r\n     */\r\n    function getLowerSTVersionBounds() external view returns(uint8[] memory lowerBounds);\r\n\r\n    /**\r\n     * @notice Used to get the upper bound\r\n     * @return Upper bound\r\n     */\r\n    function getUpperSTVersionBounds() external view returns(uint8[] memory upperBounds);\r\n\r\n    /**\r\n     * @notice Updates the tags of the ModuleFactory\r\n     * @param _tagsData New list of tags\r\n     */\r\n    function changeTags(bytes32[] calldata _tagsData) external;\r\n\r\n    /**\r\n     * @notice Updates the name of the ModuleFactory\r\n     * @param _name New name that will replace the old one.\r\n     */\r\n    function changeName(bytes32 _name) external;\r\n\r\n    /**\r\n     * @notice Updates the description of the ModuleFactory\r\n     * @param _description New description that will replace the old one.\r\n     */\r\n    function changeDescription(string calldata _description) external;\r\n\r\n    /**\r\n     * @notice Updates the title of the ModuleFactory\r\n     * @param _title New Title that will replace the old one.\r\n     */\r\n    function changeTitle(string calldata _title) external;\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary DecimalMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant e18 = uint256(10) ** uint256(18);\r\n\r\n    /**\r\n     * @notice This function multiplies two decimals represented as (decimal * 10**DECIMALS)\r\n     * @return uint256 Result of multiplication represented as (decimal * 10**DECIMALS)\r\n     */\r\n    function mul(uint256 x, uint256 y) internal pure returns(uint256 z) {\r\n        z = SafeMath.add(SafeMath.mul(x, y), (e18) / 2) / (e18);\r\n    }\r\n\r\n    /**\r\n     * @notice This function divides two decimals represented as (decimal * 10**DECIMALS)\r\n     * @return uint256 Result of division represented as (decimal * 10**DECIMALS)\r\n     */\r\n    function div(uint256 x, uint256 y) internal pure returns(uint256 z) {\r\n        z = SafeMath.add(SafeMath.mul(x, (e18)), y / 2) / y;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Interface that any module factory contract should implement\r\n * @notice Contract is abstract\r\n */\r\ncontract ModuleFactory is IModuleFactory, Ownable {\r\n\r\n    IPolymathRegistry public polymathRegistry;\r\n\r\n    string initialVersion;\r\n    bytes32 public name;\r\n    string public title;\r\n    string public description;\r\n\r\n    uint8[] typesData;\r\n    bytes32[] tagsData;\r\n\r\n    bool public isCostInPoly;\r\n    uint256 public setupCost;\r\n\r\n    string constant POLY_ORACLE = \"StablePolyUsdOracle\";\r\n\r\n    // @notice Allow only two variables to be stored\r\n    // 1. lowerBound\r\n    // 2. upperBound\r\n    // @dev (0.0.0 will act as the wildcard)\r\n    // @dev uint24 consists packed value of uint8 _major, uint8 _minor, uint8 _patch\r\n    mapping(string => uint24) compatibleSTVersionRange;\r\n\r\n    /**\r\n     * @notice Constructor\r\n     */\r\n    constructor(uint256 _setupCost, address _polymathRegistry, bool _isCostInPoly) public {\r\n        setupCost = _setupCost;\r\n        polymathRegistry = IPolymathRegistry(_polymathRegistry);\r\n        isCostInPoly = _isCostInPoly;\r\n    }\r\n\r\n    /**\r\n     * @notice Type of the Module factory\r\n     */\r\n    function getTypes() external view returns(uint8[] memory) {\r\n        return typesData;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the tags related to the module factory\r\n     */\r\n    function getTags() external view returns(bytes32[] memory) {\r\n        return tagsData;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the version related to the module factory\r\n     */\r\n    function version() external view returns(string memory) {\r\n        return initialVersion;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to change the fee of the setup cost\r\n     * @param _setupCost new setup cost\r\n     */\r\n    function changeSetupCost(uint256 _setupCost) public onlyOwner {\r\n        emit ChangeSetupCost(setupCost, _setupCost);\r\n        setupCost = _setupCost;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to change the currency and amount of setup cost\r\n     * @param _setupCost new setup cost\r\n     * @param _isCostInPoly new setup cost currency. USD or POLY\r\n     */\r\n    function changeCostAndType(uint256 _setupCost, bool _isCostInPoly) public onlyOwner {\r\n        emit ChangeSetupCost(setupCost, _setupCost);\r\n        emit ChangeCostType(isCostInPoly, _isCostInPoly);\r\n        setupCost = _setupCost;\r\n        isCostInPoly = _isCostInPoly;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the title of the ModuleFactory\r\n     * @param _title New Title that will replace the old one.\r\n     */\r\n    function changeTitle(string memory _title) public onlyOwner {\r\n        require(bytes(_title).length > 0, \"Invalid text\");\r\n        title = _title;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the description of the ModuleFactory\r\n     * @param _description New description that will replace the old one.\r\n     */\r\n    function changeDescription(string memory _description) public onlyOwner {\r\n        require(bytes(_description).length > 0, \"Invalid text\");\r\n        description = _description;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the name of the ModuleFactory\r\n     * @param _name New name that will replace the old one.\r\n     */\r\n    function changeName(bytes32 _name) public onlyOwner {\r\n        require(_name != bytes32(0), \"Invalid text\");\r\n        name = _name;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the tags of the ModuleFactory\r\n     * @param _tagsData New list of tags\r\n     */\r\n    function changeTags(bytes32[] memory _tagsData) public onlyOwner {\r\n        require(_tagsData.length > 0, \"Invalid text\");\r\n        tagsData = _tagsData;\r\n    }\r\n\r\n    /**\r\n     * @notice Function use to change the lower and upper bound of the compatible version st\r\n     * @param _boundType Type of bound\r\n     * @param _newVersion new version array\r\n     */\r\n    function changeSTVersionBounds(string calldata _boundType, uint8[] calldata _newVersion) external onlyOwner {\r\n        require(\r\n            keccak256(abi.encodePacked(_boundType)) == keccak256(abi.encodePacked(\"lowerBound\")) || keccak256(\r\n                abi.encodePacked(_boundType)\r\n            ) == keccak256(abi.encodePacked(\"upperBound\")),\r\n            \"Invalid bound type\"\r\n        );\r\n        require(_newVersion.length == 3, \"Invalid version\");\r\n        if (compatibleSTVersionRange[_boundType] != uint24(0)) {\r\n            uint8[] memory _currentVersion = VersionUtils.unpack(compatibleSTVersionRange[_boundType]);\r\n            if (keccak256(abi.encodePacked(_boundType)) == keccak256(abi.encodePacked(\"lowerBound\"))) {\r\n                require(VersionUtils.lessThanOrEqual(_newVersion, _currentVersion), \"Invalid version\");\r\n            } else {\r\n                require(VersionUtils.greaterThanOrEqual(_newVersion, _currentVersion), \"Invalid version\");\r\n            }\r\n        }\r\n        compatibleSTVersionRange[_boundType] = VersionUtils.pack(_newVersion[0], _newVersion[1], _newVersion[2]);\r\n        emit ChangeSTVersionBound(_boundType, _newVersion[0], _newVersion[1], _newVersion[2]);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to get the lower bound\r\n     * @return lower bound\r\n     */\r\n    function getLowerSTVersionBounds() external view returns(uint8[] memory) {\r\n        return VersionUtils.unpack(compatibleSTVersionRange[\"lowerBound\"]);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to get the upper bound\r\n     * @return upper bound\r\n     */\r\n    function getUpperSTVersionBounds() external view returns(uint8[] memory) {\r\n        return VersionUtils.unpack(compatibleSTVersionRange[\"upperBound\"]);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the setup cost of the module\r\n     */\r\n    function setupCostInPoly() public returns (uint256) {\r\n        if (isCostInPoly)\r\n            return setupCost;\r\n        uint256 polyRate = IOracle(polymathRegistry.getAddress(POLY_ORACLE)).getPrice();\r\n        return DecimalMath.div(setupCost, polyRate);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates fee in POLY\r\n     */\r\n    function _takeFee() internal returns(uint256) {\r\n        uint256 polySetupCost = setupCostInPoly();\r\n        address polyToken = polymathRegistry.getAddress(\"PolyToken\");\r\n        if (polySetupCost > 0) {\r\n            require(IERC20(polyToken).transferFrom(msg.sender, owner(), polySetupCost), \"Insufficient allowance for module fee\");\r\n        }\r\n        return polySetupCost;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to initialize the module\r\n     * @param _module Address of module\r\n     * @param _data Data used for the intialization of the module factory variables\r\n     */\r\n    function _initializeModule(address _module, bytes memory _data) internal {\r\n        uint256 polySetupCost = _takeFee();\r\n        bytes4 initFunction = IModule(_module).getInitFunction();\r\n        if (initFunction != bytes4(0)) {\r\n            require(Util.getSig(_data) == initFunction, \"Provided data is not valid\");\r\n            /*solium-disable-next-line security/no-low-level-calls*/\r\n            (bool success, ) = _module.call(_data);\r\n            require(success, \"Unsuccessful initialization\");\r\n        }\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit GenerateModuleFromFactory(_module, name, address(this), msg.sender, setupCost, polySetupCost);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for the Polymath Module Registry contract\r\n */\r\ninterface IModuleRegistry {\r\n\r\n    ///////////\r\n    // Events\r\n    //////////\r\n\r\n    // Emit when network becomes paused\r\n    event Pause(address account);\r\n    // Emit when network becomes unpaused\r\n    event Unpause(address account);\r\n    // Emit when Module is used by the SecurityToken\r\n    event ModuleUsed(address indexed _moduleFactory, address indexed _securityToken);\r\n    // Emit when the Module Factory gets registered on the ModuleRegistry contract\r\n    event ModuleRegistered(address indexed _moduleFactory, address indexed _owner);\r\n    // Emit when the module gets verified by Polymath\r\n    event ModuleVerified(address indexed _moduleFactory);\r\n    // Emit when the module gets unverified by Polymath or the factory owner\r\n    event ModuleUnverified(address indexed _moduleFactory);\r\n    // Emit when a ModuleFactory is removed by Polymath\r\n    event ModuleRemoved(address indexed _moduleFactory, address indexed _decisionMaker);\r\n    // Emit when ownership gets transferred\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @notice Called by a security token (2.x) to notify the registry it is using a module\r\n     * @param _moduleFactory is the address of the relevant module factory\r\n     */\r\n    function useModule(address _moduleFactory) external;\r\n\r\n    /**\r\n     * @notice Called by a security token to notify the registry it is using a module\r\n     * @param _moduleFactory is the address of the relevant module factory\r\n     * @param _isUpgrade whether the use is part of an existing module upgrade\r\n     */\r\n    function useModule(address _moduleFactory, bool _isUpgrade) external;\r\n\r\n    /**\r\n     * @notice Called by the ModuleFactory owner to register new modules for SecurityToken to use\r\n     * @param _moduleFactory is the address of the module factory to be registered\r\n     */\r\n    function registerModule(address _moduleFactory) external;\r\n\r\n    /**\r\n     * @notice Called by the ModuleFactory owner or registry curator to delete a ModuleFactory\r\n     * @param _moduleFactory is the address of the module factory to be deleted\r\n     */\r\n    function removeModule(address _moduleFactory) external;\r\n\r\n    /**\r\n     * @notice Check that a module and its factory are compatible\r\n     * @param _moduleFactory is the address of the relevant module factory\r\n     * @param _securityToken is the address of the relevant security token\r\n     * @return bool whether module and token are compatible\r\n     */\r\n    function isCompatibleModule(address _moduleFactory, address _securityToken) external view returns(bool isCompatible);\r\n\r\n    /**\r\n    * @notice Called by Polymath to verify modules for SecurityToken to use.\r\n    * @notice A module can not be used by an ST unless first approved/verified by Polymath\r\n    * @notice (The only exception to this is that the author of the module is the owner of the ST - Only if enabled by the FeatureRegistry)\r\n    * @param _moduleFactory is the address of the module factory to be registered\r\n    */\r\n    function verifyModule(address _moduleFactory) external;\r\n\r\n    /**\r\n    * @notice Called by Polymath to unverify modules for SecurityToken to use.\r\n    * @notice A module can not be used by an ST unless first approved/verified by Polymath\r\n    * @notice (The only exception to this is that the author of the module is the owner of the ST - Only if enabled by the FeatureRegistry)\r\n    * @param _moduleFactory is the address of the module factory to be registered\r\n    */\r\n    function unverifyModule(address _moduleFactory) external;\r\n\r\n    /**\r\n     * @notice Returns the verified status, and reputation of the entered Module Factory\r\n     * @param _factoryAddress is the address of the module factory\r\n     * @return bool indicating whether module factory is verified\r\n     * @return address of the factory owner\r\n     * @return address array which contains the list of securityTokens that use that module factory\r\n     */\r\n    function getFactoryDetails(address _factoryAddress) external view returns(bool isVerified, address factoryOwner, address[] memory usingTokens);\r\n\r\n    /**\r\n     * @notice Returns all the tags related to the a module type which are valid for the given token\r\n     * @param _moduleType is the module type\r\n     * @param _securityToken is the token\r\n     * @return list of tags\r\n     * @return corresponding list of module factories\r\n     */\r\n    function getTagsByTypeAndToken(uint8 _moduleType, address _securityToken) external view returns(bytes32[] memory tags, address[] memory factories);\r\n\r\n    /**\r\n     * @notice Returns all the tags related to the a module type which are valid for the given token\r\n     * @param _moduleType is the module type\r\n     * @return list of tags\r\n     * @return corresponding list of module factories\r\n     */\r\n    function getTagsByType(uint8 _moduleType) external view returns(bytes32[] memory tags, address[] memory factories);\r\n\r\n    /**\r\n     * @notice Returns the list of addresses of all Module Factory of a particular type\r\n     * @param _moduleType Type of Module\r\n     * @return address array that contains the list of addresses of module factory contracts.\r\n     */\r\n    function getAllModulesByType(uint8 _moduleType) external view returns(address[] memory factories);\r\n    /**\r\n     * @notice Returns the list of addresses of Module Factory of a particular type\r\n     * @param _moduleType Type of Module\r\n     * @return address array that contains the list of addresses of module factory contracts.\r\n     */\r\n    function getModulesByType(uint8 _moduleType) external view returns(address[] memory factories);\r\n\r\n    /**\r\n     * @notice Returns the list of available Module factory addresses of a particular type for a given token.\r\n     * @param _moduleType is the module type to look for\r\n     * @param _securityToken is the address of SecurityToken\r\n     * @return address array that contains the list of available addresses of module factory contracts.\r\n     */\r\n    function getModulesByTypeAndToken(uint8 _moduleType, address _securityToken) external view returns(address[] memory factories);\r\n\r\n    /**\r\n     * @notice Use to get the latest contract address of the regstries\r\n     */\r\n    function updateFromRegistry() external;\r\n\r\n    /**\r\n     * @notice Get the owner of the contract\r\n     * @return address owner\r\n     */\r\n    function owner() external view returns(address ownerAddress);\r\n\r\n    /**\r\n     * @notice Check whether the contract operations is paused or not\r\n     * @return bool\r\n     */\r\n    function isPaused() external view returns(bool paused);\r\n\r\n    /**\r\n     * @notice Reclaims all ERC20Basic compatible tokens\r\n     * @param _tokenContract The address of the token contract\r\n     */\r\n    function reclaimERC20(address _tokenContract) external;\r\n\r\n    /**\r\n     * @notice Called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() external;\r\n\r\n    /**\r\n     * @notice Called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() external;\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) external;\r\n\r\n}\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function _implementation() internal view returns(address);\r\n\r\n    /**\r\n    * @dev Fallback function.\r\n    * Implemented entirely in `_fallback`.\r\n    */\r\n    function _fallback() internal {\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function _delegate(address implementation) internal {\r\n        /*solium-disable-next-line security/no-inline-assembly*/\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize)\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize)\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize) }\r\n            default { return(0, returndatasize) }\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        _fallback();\r\n    }\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n    // Version name of the current implementation\r\n    string internal __version;\r\n\r\n    // Address of the current implementation\r\n    address internal __implementation;\r\n\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param _newVersion representing the version name of the upgraded implementation\r\n    * @param _newImplementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(string _newVersion, address indexed _newImplementation);\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param _newVersion representing the version name of the new implementation to be set\r\n    * @param _newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(string memory _newVersion, address _newImplementation) internal {\r\n        require(\r\n            __implementation != _newImplementation && _newImplementation != address(0),\r\n            \"Old address is not allowed and implementation address should not be 0x\"\r\n        );\r\n        require(Address.isContract(_newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\r\n        require(bytes(_newVersion).length > 0, \"Version should not be empty string\");\r\n        require(keccak256(abi.encodePacked(__version)) != keccak256(abi.encodePacked(_newVersion)), \"New version equals to current\");\r\n        __version = _newVersion;\r\n        __implementation = _newImplementation;\r\n        emit Upgraded(_newVersion, _newImplementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n    // Owner of the contract\r\n    address private __upgradeabilityOwner;\r\n\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param _previousOwner representing the address of the previous owner\r\n    * @param _newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address _previousOwner, address _newOwner);\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier ifOwner() {\r\n        if (msg.sender == _upgradeabilityOwner()) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor() public {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function _upgradeabilityOwner() internal view returns(address) {\r\n        return __upgradeabilityOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the owner\r\n    */\r\n    function _setUpgradeabilityOwner(address _newUpgradeabilityOwner) internal {\r\n        require(_newUpgradeabilityOwner != address(0), \"Address should not be 0x\");\r\n        __upgradeabilityOwner = _newUpgradeabilityOwner;\r\n    }\r\n\r\n    /**\r\n    * @notice Internal function to provide the address of the implementation contract\r\n    */\r\n    function _implementation() internal view returns(address) {\r\n        return __implementation;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the proxy owner\r\n    * @return the address of the proxy owner\r\n    */\r\n    function proxyOwner() external ifOwner returns(address) {\r\n        return _upgradeabilityOwner();\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the version name of the current implementation\r\n    * @return string representing the name of the current version\r\n    */\r\n    function version() external ifOwner returns(string memory) {\r\n        return __version;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() external ifOwner returns(address) {\r\n        return _implementation();\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address _newOwner) external ifOwner {\r\n        require(_newOwner != address(0), \"Address should not be 0x\");\r\n        emit ProxyOwnershipTransferred(_upgradeabilityOwner(), _newOwner);\r\n        _setUpgradeabilityOwner(_newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the upgradeability owner to upgrade the current version of the proxy.\r\n    * @param _newVersion representing the version name of the new implementation to be set.\r\n    * @param _newImplementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(string calldata _newVersion, address _newImplementation) external ifOwner {\r\n        _upgradeTo(_newVersion, _newImplementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the upgradeability owner to upgrade the current version of the proxy and call the new implementation\r\n    * to initialize whatever is needed through a low level call.\r\n    * @param _newVersion representing the version name of the new implementation to be set.\r\n    * @param _newImplementation representing the address of the new implementation to be set.\r\n    * @param _data represents the msg.data to bet sent in the low level call. This parameter may include the function\r\n    * signature of the implementation to be called with the needed payload\r\n    */\r\n    function upgradeToAndCall(string calldata _newVersion, address _newImplementation, bytes calldata _data) external payable ifOwner {\r\n        _upgradeToAndCall(_newVersion, _newImplementation, _data);\r\n    }\r\n\r\n    function _upgradeToAndCall(string memory _newVersion, address _newImplementation, bytes memory _data) internal {\r\n        _upgradeTo(_newVersion, _newImplementation);\r\n        bool success;\r\n        /*solium-disable-next-line security/no-call-value*/\r\n        (success, ) = address(this).call.value(msg.value)(_data);\r\n        require(success, \"Fail in executing the function of implementation contract\");\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Factory for deploying upgradable modules\r\n */\r\ncontract UpgradableModuleFactory is ModuleFactory {\r\n\r\n    event LogicContractSet(string _version, uint256 _upgrade, address _logicContract, bytes _upgradeData);\r\n\r\n    event ModuleUpgraded(\r\n        address indexed _module,\r\n        address indexed _securityToken,\r\n        uint256 indexed _version\r\n    );\r\n\r\n    struct LogicContract {\r\n        string version;\r\n        address logicContract;\r\n        bytes upgradeData;\r\n    }\r\n\r\n    // Mapping from version to logic contract\r\n    mapping (uint256 => LogicContract) public logicContracts;\r\n\r\n    // Mapping from Security Token address, to deployed proxy module address, to module version\r\n    mapping (address => mapping (address => uint256)) public modules;\r\n\r\n    // Mapping of which security token owns a given module\r\n    mapping (address => address) public moduleToSecurityToken;\r\n\r\n    // Current version\r\n    uint256 public latestUpgrade;\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _setupCost Setup cost of the module\r\n      * @param _logicContract Contract address that contains the logic related to `description`\r\n     * @param _polymathRegistry Address of the Polymath registry\r\n     * @param _isCostInPoly true = cost in Poly, false = USD\r\n     */\r\n    constructor(\r\n        string memory _version,\r\n        uint256 _setupCost,\r\n        address _logicContract,\r\n        address _polymathRegistry,\r\n        bool _isCostInPoly\r\n    )\r\n        public ModuleFactory(_setupCost, _polymathRegistry, _isCostInPoly)\r\n    {\r\n        require(_logicContract != address(0), \"Invalid address\");\r\n        logicContracts[latestUpgrade].logicContract = _logicContract;\r\n        logicContracts[latestUpgrade].version = _version;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to upgrade the module factory\r\n     * @param _version Version of upgraded module\r\n     * @param _logicContract Address of deployed module logic contract referenced from proxy\r\n     * @param _upgradeData Data to be passed in call to upgradeToAndCall when a token upgrades its module\r\n     */\r\n    function setLogicContract(string calldata _version, address _logicContract, bytes calldata _upgradeData) external onlyOwner {\r\n        require(keccak256(abi.encodePacked(_version)) != keccak256(abi.encodePacked(logicContracts[latestUpgrade].version)), \"Same version\");\r\n        require(_logicContract != logicContracts[latestUpgrade].logicContract, \"Same version\");\r\n        require(_logicContract != address(0), \"Invalid address\");\r\n        latestUpgrade++;\r\n        _modifyLogicContract(latestUpgrade, _version, _logicContract, _upgradeData);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to update an existing token logic contract\r\n     * @param _upgrade logic contract to upgrade\r\n     * @param _version Version of upgraded module\r\n     * @param _logicContract Address of deployed module logic contract referenced from proxy\r\n     * @param _upgradeData Data to be passed in call to upgradeToAndCall when a token upgrades its module\r\n     */\r\n    function updateLogicContract(uint256 _upgrade, string calldata _version, address _logicContract, bytes calldata _upgradeData) external onlyOwner {\r\n        require(_upgrade <= latestUpgrade, \"Invalid upgrade\");\r\n        // version & contract must differ from previous version, otherwise upgrade proxy will fail\r\n        if (_upgrade > 0) {\r\n          require(keccak256(abi.encodePacked(_version)) != keccak256(abi.encodePacked(logicContracts[_upgrade - 1].version)), \"Same version\");\r\n          require(_logicContract != logicContracts[_upgrade - 1].logicContract, \"Same version\");\r\n        }\r\n        require(_logicContract != address(0), \"Invalid address\");\r\n        require(_upgradeData.length > 4, \"Invalid Upgrade\");\r\n        _modifyLogicContract(_upgrade, _version, _logicContract, _upgradeData);\r\n    }\r\n\r\n    function _modifyLogicContract(uint256 _upgrade, string memory _version, address _logicContract, bytes memory _upgradeData) internal {\r\n        logicContracts[_upgrade].version = _version;\r\n        logicContracts[_upgrade].logicContract = _logicContract;\r\n        logicContracts[_upgrade].upgradeData = _upgradeData;\r\n        IModuleRegistry moduleRegistry = IModuleRegistry(polymathRegistry.getAddress(\"ModuleRegistry\"));\r\n        moduleRegistry.unverifyModule(address(this));\r\n        emit LogicContractSet(_version, _upgrade, _logicContract, _upgradeData);\r\n    }\r\n\r\n    /**\r\n     * @notice Used by a security token to upgrade a given module\r\n     * @param _module Address of (proxy) module to be upgraded\r\n     */\r\n    function upgrade(address _module) external {\r\n        // Only allow the owner of a module to upgrade it\r\n        require(moduleToSecurityToken[_module] == msg.sender, \"Incorrect caller\");\r\n        // Only allow issuers to upgrade in single step verisons to preserve upgradeToAndCall semantics\r\n        uint256 newVersion = modules[msg.sender][_module] + 1;\r\n        require(newVersion <= latestUpgrade, \"Incorrect version\");\r\n        OwnedUpgradeabilityProxy(address(uint160(_module))).upgradeToAndCall(logicContracts[newVersion].version, logicContracts[newVersion].logicContract, logicContracts[newVersion].upgradeData);\r\n        modules[msg.sender][_module] = newVersion;\r\n        emit ModuleUpgraded(\r\n            _module,\r\n            msg.sender,\r\n            newVersion\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Used to initialize the module\r\n     * @param _module Address of module\r\n     * @param _data Data used for the intialization of the module factory variables\r\n     */\r\n    function _initializeModule(address _module, bytes memory _data) internal {\r\n        super._initializeModule(_module, _data);\r\n        moduleToSecurityToken[_module] = msg.sender;\r\n        modules[msg.sender][_module] = latestUpgrade;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the version related to the module factory\r\n     */\r\n    function version() external view returns(string memory) {\r\n        return logicContracts[latestUpgrade].version;\r\n    }\r\n\r\n}\r\n\r\ninterface IDataStore {\r\n    /**\r\n     * @dev Changes security token atatched to this data store\r\n     * @param _securityToken address of the security token\r\n     */\r\n    function setSecurityToken(address _securityToken) external;\r\n\r\n    /**\r\n     * @dev Stores a uint256 data against a key\r\n     * @param _key Unique key to identify the data\r\n     * @param _data Data to be stored against the key\r\n     */\r\n    function setUint256(bytes32 _key, uint256 _data) external;\r\n\r\n    function setBytes32(bytes32 _key, bytes32 _data) external;\r\n\r\n    function setAddress(bytes32 _key, address _data) external;\r\n\r\n    function setString(bytes32 _key, string calldata _data) external;\r\n\r\n    function setBytes(bytes32 _key, bytes calldata _data) external;\r\n\r\n    function setBool(bytes32 _key, bool _data) external;\r\n\r\n    /**\r\n     * @dev Stores a uint256 array against a key\r\n     * @param _key Unique key to identify the array\r\n     * @param _data Array to be stored against the key\r\n     */\r\n    function setUint256Array(bytes32 _key, uint256[] calldata _data) external;\r\n\r\n    function setBytes32Array(bytes32 _key, bytes32[] calldata _data) external ;\r\n\r\n    function setAddressArray(bytes32 _key, address[] calldata _data) external;\r\n\r\n    function setBoolArray(bytes32 _key, bool[] calldata _data) external;\r\n\r\n    /**\r\n     * @dev Inserts a uint256 element to the array identified by the key\r\n     * @param _key Unique key to identify the array\r\n     * @param _data Element to push into the array\r\n     */\r\n    function insertUint256(bytes32 _key, uint256 _data) external;\r\n\r\n    function insertBytes32(bytes32 _key, bytes32 _data) external;\r\n\r\n    function insertAddress(bytes32 _key, address _data) external;\r\n\r\n    function insertBool(bytes32 _key, bool _data) external;\r\n\r\n    /**\r\n     * @dev Deletes an element from the array identified by the key.\r\n     * When an element is deleted from an Array, last element of that array is moved to the index of deleted element.\r\n     * @param _key Unique key to identify the array\r\n     * @param _index Index of the element to delete\r\n     */\r\n    function deleteUint256(bytes32 _key, uint256 _index) external;\r\n\r\n    function deleteBytes32(bytes32 _key, uint256 _index) external;\r\n\r\n    function deleteAddress(bytes32 _key, uint256 _index) external;\r\n\r\n    function deleteBool(bytes32 _key, uint256 _index) external;\r\n\r\n    /**\r\n     * @dev Stores multiple uint256 data against respective keys\r\n     * @param _keys Array of keys to identify the data\r\n     * @param _data Array of data to be stored against the respective keys\r\n     */\r\n    function setUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\r\n\r\n    function setBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\r\n\r\n    function setAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\r\n\r\n    function setBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\r\n\r\n    /**\r\n     * @dev Inserts multiple uint256 elements to the array identified by the respective keys\r\n     * @param _keys Array of keys to identify the data\r\n     * @param _data Array of data to be inserted in arrays of the respective keys\r\n     */\r\n    function insertUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\r\n\r\n    function insertBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\r\n\r\n    function insertAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\r\n\r\n    function insertBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\r\n\r\n    function getUint256(bytes32 _key) external view returns(uint256);\r\n\r\n    function getBytes32(bytes32 _key) external view returns(bytes32);\r\n\r\n    function getAddress(bytes32 _key) external view returns(address);\r\n\r\n    function getString(bytes32 _key) external view returns(string memory);\r\n\r\n    function getBytes(bytes32 _key) external view returns(bytes memory);\r\n\r\n    function getBool(bytes32 _key) external view returns(bool);\r\n\r\n    function getUint256Array(bytes32 _key) external view returns(uint256[] memory);\r\n\r\n    function getBytes32Array(bytes32 _key) external view returns(bytes32[] memory);\r\n\r\n    function getAddressArray(bytes32 _key) external view returns(address[] memory);\r\n\r\n    function getBoolArray(bytes32 _key) external view returns(bool[] memory);\r\n\r\n    function getUint256ArrayLength(bytes32 _key) external view returns(uint256);\r\n\r\n    function getBytes32ArrayLength(bytes32 _key) external view returns(uint256);\r\n\r\n    function getAddressArrayLength(bytes32 _key) external view returns(uint256);\r\n\r\n    function getBoolArrayLength(bytes32 _key) external view returns(uint256);\r\n\r\n    function getUint256ArrayElement(bytes32 _key, uint256 _index) external view returns(uint256);\r\n\r\n    function getBytes32ArrayElement(bytes32 _key, uint256 _index) external view returns(bytes32);\r\n\r\n    function getAddressArrayElement(bytes32 _key, uint256 _index) external view returns(address);\r\n\r\n    function getBoolArrayElement(bytes32 _key, uint256 _index) external view returns(bool);\r\n\r\n    function getUint256ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(uint256[] memory);\r\n\r\n    function getBytes32ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bytes32[] memory);\r\n\r\n    function getAddressArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(address[] memory);\r\n\r\n    function getBoolArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bool[] memory);\r\n}\r\n\r\n/**\r\n * @title Interface for the Polymath Security Token Registry contract\r\n */\r\ninterface ISecurityTokenRegistry {\r\n\r\n    // Emit when network becomes paused\r\n    event Pause(address account);\r\n    // Emit when network becomes unpaused\r\n    event Unpause(address account);\r\n    // Emit when the ticker is removed from the registry\r\n    event TickerRemoved(string _ticker, address _removedBy);\r\n    // Emit when the token ticker expiry is changed\r\n    event ChangeExpiryLimit(uint256 _oldExpiry, uint256 _newExpiry);\r\n    // Emit when changeSecurityLaunchFee is called\r\n    event ChangeSecurityLaunchFee(uint256 _oldFee, uint256 _newFee);\r\n    // Emit when changeTickerRegistrationFee is called\r\n    event ChangeTickerRegistrationFee(uint256 _oldFee, uint256 _newFee);\r\n    // Emit when Fee currency is changed\r\n    event ChangeFeeCurrency(bool _isFeeInPoly);\r\n    // Emit when ownership gets transferred\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    // Emit when ownership of the ticker gets changed\r\n    event ChangeTickerOwnership(string _ticker, address indexed _oldOwner, address indexed _newOwner);\r\n    // Emit at the time of launching a new security token of version 3.0+\r\n    event NewSecurityToken(\r\n        string _ticker,\r\n        string _name,\r\n        address indexed _securityTokenAddress,\r\n        address indexed _owner,\r\n        uint256 _addedAt,\r\n        address _registrant,\r\n        bool _fromAdmin,\r\n        uint256 _usdFee,\r\n        uint256 _polyFee,\r\n        uint256 _protocolVersion\r\n    );\r\n    // Emit at the time of launching a new security token v2.0.\r\n    // _registrationFee is in poly\r\n    event NewSecurityToken(\r\n        string _ticker,\r\n        string _name,\r\n        address indexed _securityTokenAddress,\r\n        address indexed _owner,\r\n        uint256 _addedAt,\r\n        address _registrant,\r\n        bool _fromAdmin,\r\n        uint256 _registrationFee\r\n    );\r\n    // Emit when new ticker get registers\r\n    event RegisterTicker(\r\n        address indexed _owner,\r\n        string _ticker,\r\n        uint256 indexed _registrationDate,\r\n        uint256 indexed _expiryDate,\r\n        bool _fromAdmin,\r\n        uint256 _registrationFeePoly,\r\n        uint256 _registrationFeeUsd\r\n    );\r\n    // Emit after ticker registration\r\n    // _registrationFee is in poly\r\n    // fee in usd is not being emitted to maintain backwards compatibility\r\n    event RegisterTicker(\r\n        address indexed _owner,\r\n        string _ticker,\r\n        string _name,\r\n        uint256 indexed _registrationDate,\r\n        uint256 indexed _expiryDate,\r\n        bool _fromAdmin,\r\n        uint256 _registrationFee\r\n    );\r\n    // Emit at when issuer refreshes exisiting token\r\n    event SecurityTokenRefreshed(\r\n        string _ticker,\r\n        string _name,\r\n        address indexed _securityTokenAddress,\r\n        address indexed _owner,\r\n        uint256 _addedAt,\r\n        address _registrant,\r\n        uint256 _protocolVersion\r\n    );\r\n    event ProtocolFactorySet(address indexed _STFactory, uint8 _major, uint8 _minor, uint8 _patch);\r\n    event LatestVersionSet(uint8 _major, uint8 _minor, uint8 _patch);\r\n    event ProtocolFactoryRemoved(address indexed _STFactory, uint8 _major, uint8 _minor, uint8 _patch);\r\n\r\n    /**\r\n     * @notice Deploys an instance of a new Security Token of version 2.0 and records it to the registry\r\n     * @dev this function is for backwards compatibilty with 2.0 dApp.\r\n     * @param _name is the name of the token\r\n     * @param _ticker is the ticker symbol of the security token\r\n     * @param _tokenDetails is the off-chain details of the token\r\n     * @param _divisible is whether or not the token is divisible\r\n     */\r\n    function generateSecurityToken(\r\n        string calldata _name,\r\n        string calldata _ticker,\r\n        string calldata _tokenDetails,\r\n        bool _divisible\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * @notice Deploys an instance of a new Security Token and records it to the registry\r\n     * @param _name is the name of the token\r\n     * @param _ticker is the ticker symbol of the security token\r\n     * @param _tokenDetails is the off-chain details of the token\r\n     * @param _divisible is whether or not the token is divisible\r\n     * @param _treasuryWallet Ethereum address which will holds the STs.\r\n     * @param _protocolVersion Version of securityToken contract\r\n     * - `_protocolVersion` is the packed value of uin8[3] array (it will be calculated offchain)\r\n     * - if _protocolVersion == 0 then latest version of securityToken will be generated\r\n     */\r\n    function generateNewSecurityToken(\r\n        string calldata _name,\r\n        string calldata _ticker,\r\n        string calldata _tokenDetails,\r\n        bool _divisible,\r\n        address _treasuryWallet,\r\n        uint256 _protocolVersion\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * @notice Deploys an instance of a new Security Token and replaces the old one in the registry\r\n     * This can be used to upgrade from version 2.0 of ST to 3.0 or in case something goes wrong with earlier ST\r\n     * @dev This function needs to be in STR 3.0. Defined public to avoid stack overflow\r\n     * @param _name is the name of the token\r\n     * @param _ticker is the ticker symbol of the security token\r\n     * @param _tokenDetails is the off-chain details of the token\r\n     * @param _divisible is whether or not the token is divisible\r\n     */\r\n    function refreshSecurityToken(\r\n        string calldata _name,\r\n        string calldata _ticker,\r\n        string calldata _tokenDetails,\r\n        bool _divisible,\r\n        address _treasuryWallet\r\n    )\r\n        external returns (address securityToken);\r\n\r\n    /**\r\n     * @notice Adds a new custom Security Token and saves it to the registry. (Token should follow the ISecurityToken interface)\r\n     * @param _name Name of the token\r\n     * @param _ticker Ticker of the security token\r\n     * @param _owner Owner of the token\r\n     * @param _securityToken Address of the securityToken\r\n     * @param _tokenDetails Off-chain details of the token\r\n     * @param _deployedAt Timestamp at which security token comes deployed on the ethereum blockchain\r\n     */\r\n    function modifySecurityToken(\r\n        string calldata _name,\r\n        string calldata _ticker,\r\n        address _owner,\r\n        address _securityToken,\r\n        string calldata _tokenDetails,\r\n        uint256 _deployedAt\r\n    )\r\n    external;\r\n\r\n    /**\r\n     * @notice Adds a new custom Security Token and saves it to the registry. (Token should follow the ISecurityToken interface)\r\n     * @param _ticker is the ticker symbol of the security token\r\n     * @param _owner is the owner of the token\r\n     * @param _securityToken is the address of the securityToken\r\n     * @param _tokenDetails is the off-chain details of the token\r\n     * @param _deployedAt is the timestamp at which the security token is deployed\r\n     */\r\n    function modifyExistingSecurityToken(\r\n        string calldata _ticker,\r\n        address _owner,\r\n        address _securityToken,\r\n        string calldata _tokenDetails,\r\n        uint256 _deployedAt\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * @notice Modifies the ticker details. Only Polymath has the ability to do so.\r\n     * @notice Only allowed to modify the tickers which are not yet deployed.\r\n     * @param _owner is the owner of the token\r\n     * @param _ticker is the token ticker\r\n     * @param _registrationDate is the date at which ticker is registered\r\n     * @param _expiryDate is the expiry date for the ticker\r\n     * @param _status is the token deployment status\r\n     */\r\n    function modifyExistingTicker(\r\n        address _owner,\r\n        string calldata _ticker,\r\n        uint256 _registrationDate,\r\n        uint256 _expiryDate,\r\n        bool _status\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * @notice Registers the token ticker for its particular owner\r\n     * @notice once the token ticker is registered to its owner then no other issuer can claim\r\n     * @notice its ownership. If the ticker expires and its issuer hasn't used it, then someone else can take it.\r\n     * @param _owner Address of the owner of the token\r\n     * @param _ticker Token ticker\r\n     * @param _tokenName Name of the token\r\n     */\r\n    function registerTicker(address _owner, string calldata _ticker, string calldata _tokenName) external;\r\n\r\n    /**\r\n     * @notice Registers the token ticker to the selected owner\r\n     * @notice Once the token ticker is registered to its owner then no other issuer can claim\r\n     * @notice its ownership. If the ticker expires and its issuer hasn't used it, then someone else can take it.\r\n     * @param _owner is address of the owner of the token\r\n     * @param _ticker is unique token ticker\r\n     */\r\n    function registerNewTicker(address _owner, string calldata _ticker) external;\r\n\r\n    /**\r\n    * @notice Check that Security Token is registered\r\n    * @param _securityToken Address of the Scurity token\r\n    * @return bool\r\n    */\r\n    function isSecurityToken(address _securityToken) external view returns(bool isValid);\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) external;\r\n\r\n    /**\r\n     * @notice Get security token address by ticker name\r\n     * @param _ticker Symbol of the Scurity token\r\n     * @return address\r\n     */\r\n    function getSecurityTokenAddress(string calldata _ticker) external view returns(address tokenAddress);\r\n\r\n    /**\r\n    * @notice Returns the security token data by address\r\n    * @param _securityToken is the address of the security token.\r\n    * @return string is the ticker of the security Token.\r\n    * @return address is the issuer of the security Token.\r\n    * @return string is the details of the security token.\r\n    * @return uint256 is the timestamp at which security Token was deployed.\r\n    */\r\n    function getSecurityTokenData(address _securityToken) external view returns (\r\n        string memory tokenSymbol,\r\n        address tokenAddress,\r\n        string memory tokenDetails,\r\n        uint256 tokenTime\r\n    );\r\n\r\n    /**\r\n     * @notice Get the current STFactory Address\r\n     */\r\n    function getSTFactoryAddress() external view returns(address stFactoryAddress);\r\n\r\n    /**\r\n     * @notice Returns the STFactory Address of a particular version\r\n     * @param _protocolVersion Packed protocol version\r\n     */\r\n    function getSTFactoryAddressOfVersion(uint256 _protocolVersion) external view returns(address stFactory);\r\n\r\n    /**\r\n     * @notice Get Protocol version\r\n     */\r\n    function getLatestProtocolVersion() external view returns(uint8[] memory protocolVersion);\r\n\r\n    /**\r\n     * @notice Used to get the ticker list as per the owner\r\n     * @param _owner Address which owns the list of tickers\r\n     */\r\n    function getTickersByOwner(address _owner) external view returns(bytes32[] memory tickers);\r\n\r\n    /**\r\n     * @notice Returns the list of tokens owned by the selected address\r\n     * @param _owner is the address which owns the list of tickers\r\n     * @dev Intention is that this is called off-chain so block gas limit is not relevant\r\n     */\r\n    function getTokensByOwner(address _owner) external view returns(address[] memory tokens);\r\n\r\n    /**\r\n     * @notice Returns the list of all tokens\r\n     * @dev Intention is that this is called off-chain so block gas limit is not relevant\r\n     */\r\n    function getTokens() external view returns(address[] memory tokens);\r\n\r\n    /**\r\n     * @notice Returns the owner and timestamp for a given ticker\r\n     * @param _ticker ticker\r\n     * @return address\r\n     * @return uint256\r\n     * @return uint256\r\n     * @return string\r\n     * @return bool\r\n     */\r\n    function getTickerDetails(string calldata _ticker) external view returns(address tickerOwner, uint256 tickerRegistration, uint256 tickerExpiry, string memory tokenName, bool tickerStatus);\r\n\r\n    /**\r\n     * @notice Modifies the ticker details. Only polymath account has the ability\r\n     * to do so. Only allowed to modify the tickers which are not yet deployed\r\n     * @param _owner Owner of the token\r\n     * @param _ticker Token ticker\r\n     * @param _tokenName Name of the token\r\n     * @param _registrationDate Date on which ticker get registered\r\n     * @param _expiryDate Expiry date of the ticker\r\n     * @param _status Token deployed status\r\n     */\r\n    function modifyTicker(\r\n        address _owner,\r\n        string calldata _ticker,\r\n        string calldata _tokenName,\r\n        uint256 _registrationDate,\r\n        uint256 _expiryDate,\r\n        bool _status\r\n    )\r\n    external;\r\n\r\n    /**\r\n     * @notice Removes the ticker details and associated ownership & security token mapping\r\n     * @param _ticker Token ticker\r\n     */\r\n    function removeTicker(string calldata _ticker) external;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of the ticker\r\n     * @dev _newOwner Address whom ownership to transfer\r\n     * @dev _ticker Ticker\r\n     */\r\n    function transferTickerOwnership(address _newOwner, string calldata _ticker) external;\r\n\r\n    /**\r\n     * @notice Changes the expiry time for the token ticker\r\n     * @param _newExpiry New time period for token ticker expiry\r\n     */\r\n    function changeExpiryLimit(uint256 _newExpiry) external;\r\n\r\n   /**\r\n    * @notice Sets the ticker registration fee in USD tokens. Only Polymath.\r\n    * @param _tickerRegFee is the registration fee in USD tokens (base 18 decimals)\r\n    */\r\n    function changeTickerRegistrationFee(uint256 _tickerRegFee) external;\r\n\r\n    /**\r\n    * @notice Sets the ticker registration fee in USD tokens. Only Polymath.\r\n    * @param _stLaunchFee is the registration fee in USD tokens (base 18 decimals)\r\n    */\r\n    function changeSecurityLaunchFee(uint256 _stLaunchFee) external;\r\n\r\n    /**\r\n    * @notice Sets the ticker registration and ST launch fee amount and currency\r\n    * @param _tickerRegFee is the ticker registration fee (base 18 decimals)\r\n    * @param _stLaunchFee is the st generation fee (base 18 decimals)\r\n    * @param _isFeeInPoly defines if the fee is in poly or usd\r\n    */\r\n    function changeFeesAmountAndCurrency(uint256 _tickerRegFee, uint256 _stLaunchFee, bool _isFeeInPoly) external;\r\n\r\n    /**\r\n    * @notice Changes the SecurityToken contract for a particular factory version\r\n    * @notice Used only by Polymath to upgrade the SecurityToken contract and add more functionalities to future versions\r\n    * @notice Changing versions does not affect existing tokens.\r\n    * @param _STFactoryAddress is the address of the proxy.\r\n    * @param _major Major version of the proxy.\r\n    * @param _minor Minor version of the proxy.\r\n    * @param _patch Patch version of the proxy\r\n    */\r\n    function setProtocolFactory(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) external;\r\n\r\n    /**\r\n    * @notice Removes a STFactory\r\n    * @param _major Major version of the proxy.\r\n    * @param _minor Minor version of the proxy.\r\n    * @param _patch Patch version of the proxy\r\n    */\r\n    function removeProtocolFactory(uint8 _major, uint8 _minor, uint8 _patch) external;\r\n\r\n    /**\r\n    * @notice Changes the default protocol version\r\n    * @notice Used only by Polymath to upgrade the SecurityToken contract and add more functionalities to future versions\r\n    * @notice Changing versions does not affect existing tokens.\r\n    * @param _major Major version of the proxy.\r\n    * @param _minor Minor version of the proxy.\r\n    * @param _patch Patch version of the proxy\r\n    */\r\n    function setLatestVersion(uint8 _major, uint8 _minor, uint8 _patch) external;\r\n\r\n    /**\r\n     * @notice Changes the PolyToken address. Only Polymath.\r\n     * @param _newAddress is the address of the polytoken.\r\n     */\r\n    function updatePolyTokenAddress(address _newAddress) external;\r\n\r\n    /**\r\n     * @notice Used to update the polyToken contract address\r\n     */\r\n    function updateFromRegistry() external;\r\n\r\n    /**\r\n     * @notice Gets the security token launch fee\r\n     * @return Fee amount\r\n     */\r\n    function getSecurityTokenLaunchFee() external returns(uint256 fee);\r\n\r\n    /**\r\n     * @notice Gets the ticker registration fee\r\n     * @return Fee amount\r\n     */\r\n    function getTickerRegistrationFee() external returns(uint256 fee);\r\n\r\n    /**\r\n     * @notice Set the getter contract address\r\n     * @param _getterContract Address of the contract\r\n     */\r\n    function setGetterRegistry(address _getterContract) external;\r\n\r\n    /**\r\n     * @notice Returns the usd & poly fee for a particular feetype\r\n     * @param _feeType Key corresponding to fee type\r\n     */\r\n    function getFees(bytes32 _feeType) external returns (uint256 usdFee, uint256 polyFee);\r\n\r\n    /**\r\n     * @notice Returns the list of tokens to which the delegate has some access\r\n     * @param _delegate is the address for the delegate\r\n     * @dev Intention is that this is called off-chain so block gas limit is not relevant\r\n     */\r\n    function getTokensByDelegate(address _delegate) external view returns(address[] memory tokens);\r\n\r\n    /**\r\n     * @notice Gets the expiry limit\r\n     * @return Expiry limit\r\n     */\r\n    function getExpiryLimit() external view returns(uint256 expiry);\r\n\r\n    /**\r\n     * @notice Gets the status of the ticker\r\n     * @param _ticker Ticker whose status need to determine\r\n     * @return bool\r\n     */\r\n    function getTickerStatus(string calldata _ticker) external view returns(bool status);\r\n\r\n    /**\r\n     * @notice Gets the fee currency\r\n     * @return true = poly, false = usd\r\n     */\r\n    function getIsFeeInPoly() external view returns(bool isInPoly);\r\n\r\n    /**\r\n     * @notice Gets the owner of the ticker\r\n     * @param _ticker Ticker whose owner need to determine\r\n     * @return address Address of the owner\r\n     */\r\n    function getTickerOwner(string calldata _ticker) external view returns(address owner);\r\n\r\n    /**\r\n     * @notice Checks whether the registry is paused or not\r\n     * @return bool\r\n     */\r\n    function isPaused() external view returns(bool paused);\r\n\r\n    /**\r\n    * @notice Called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() external;\r\n\r\n    /**\r\n     * @notice Called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() external;\r\n\r\n    /**\r\n     * @notice Reclaims all ERC20Basic compatible tokens\r\n     * @param _tokenContract is the address of the token contract\r\n     */\r\n    function reclaimERC20(address _tokenContract) external;\r\n\r\n    /**\r\n     * @notice Gets the owner of the contract\r\n     * @return address owner\r\n     */\r\n    function owner() external view returns(address ownerAddress);\r\n\r\n    /**\r\n     * @notice Checks if the entered ticker is registered and has not expired\r\n     * @param _ticker is the token ticker\r\n     * @return bool\r\n     */\r\n    function tickerAvailable(string calldata _ticker) external view returns(bool);\r\n\r\n}\r\n\r\ncontract SecurityTokenStorage {\r\n\r\n    uint8 internal constant PERMISSION_KEY = 1;\r\n    uint8 internal constant TRANSFER_KEY = 2;\r\n    uint8 internal constant MINT_KEY = 3;\r\n    uint8 internal constant CHECKPOINT_KEY = 4;\r\n    uint8 internal constant BURN_KEY = 5;\r\n    uint8 internal constant DATA_KEY = 6;\r\n    uint8 internal constant WALLET_KEY = 7;\r\n\r\n    bytes32 internal constant INVESTORSKEY = 0xdf3a8dd24acdd05addfc6aeffef7574d2de3f844535ec91e8e0f3e45dba96731; //keccak256(abi.encodePacked(\"INVESTORS\"))\r\n    bytes32 internal constant TREASURY = 0xaae8817359f3dcb67d050f44f3e49f982e0359d90ca4b5f18569926304aaece6; //keccak256(abi.encodePacked(\"TREASURY_WALLET\"))\r\n    bytes32 internal constant LOCKED = \"LOCKED\";\r\n    bytes32 internal constant UNLOCKED = \"UNLOCKED\";\r\n\r\n    //////////////////////////\r\n    /// Document datastructure\r\n    //////////////////////////\r\n\r\n    struct Document {\r\n        bytes32 docHash; // Hash of the document\r\n        uint256 lastModified; // Timestamp at which document details was last modified\r\n        string uri; // URI of the document that exist off-chain\r\n    }\r\n\r\n    // Used to hold the semantic version data\r\n    struct SemanticVersion {\r\n        uint8 major;\r\n        uint8 minor;\r\n        uint8 patch;\r\n    }\r\n\r\n    // Struct for module data\r\n    struct ModuleData {\r\n        bytes32 name;\r\n        address module;\r\n        address moduleFactory;\r\n        bool isArchived;\r\n        uint8[] moduleTypes;\r\n        uint256[] moduleIndexes;\r\n        uint256 nameIndex;\r\n        bytes32 label;\r\n    }\r\n\r\n    // Structures to maintain checkpoints of balances for governance / dividends\r\n    struct Checkpoint {\r\n        uint256 checkpointId;\r\n        uint256 value;\r\n    }\r\n\r\n    //Naming scheme to match Ownable\r\n    address internal _owner;\r\n    address public tokenFactory;\r\n    bool public initialized;\r\n\r\n    // ERC20 Details\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    // Address of the controller which is a delegated entity\r\n    // set by the issuer/owner of the token\r\n    address public controller;\r\n\r\n    IPolymathRegistry public polymathRegistry;\r\n    IModuleRegistry public moduleRegistry;\r\n    ISecurityTokenRegistry public securityTokenRegistry;\r\n    IERC20 public polyToken;\r\n    address public getterDelegate;\r\n    // Address of the data store used to store shared data\r\n    IDataStore public dataStore;\r\n\r\n    uint256 public granularity;\r\n\r\n    // Value of current checkpoint\r\n    uint256 public currentCheckpointId;\r\n\r\n    // off-chain data\r\n    string public tokenDetails;\r\n\r\n    // Used to permanently halt controller actions\r\n    bool public controllerDisabled = false;\r\n\r\n    // Used to temporarily halt all transactions\r\n    bool public transfersFrozen;\r\n\r\n    // Number of investors with non-zero balance\r\n    uint256 public holderCount;\r\n\r\n    // Variable which tells whether issuance is ON or OFF forever\r\n    // Implementers need to implement one more function to reset the value of `issuance` variable\r\n    // to false. That function is not a part of the standard (EIP-1594) as it is depend on the various factors\r\n    // issuer, followed compliance rules etc. So issuers have the choice how they want to close the issuance.\r\n    bool internal issuance = true;\r\n\r\n    // Array use to store all the document name present in the contracts\r\n    bytes32[] _docNames;\r\n\r\n    // Times at which each checkpoint was created\r\n    uint256[] checkpointTimes;\r\n\r\n    SemanticVersion securityTokenVersion;\r\n\r\n    // Records added modules - module list should be order agnostic!\r\n    mapping(uint8 => address[]) modules;\r\n\r\n    // Records information about the module\r\n    mapping(address => ModuleData) modulesToData;\r\n\r\n    // Records added module names - module list should be order agnostic!\r\n    mapping(bytes32 => address[]) names;\r\n\r\n    // Mapping of checkpoints that relate to total supply\r\n    mapping (uint256 => uint256) checkpointTotalSupply;\r\n\r\n    // Map each investor to a series of checkpoints\r\n    mapping(address => Checkpoint[]) checkpointBalances;\r\n\r\n    // mapping to store the documents details in the document\r\n    mapping(bytes32 => Document) internal _documents;\r\n    // mapping to store the document name indexes\r\n    mapping(bytes32 => uint256) internal _docIndexes;\r\n    // Mapping from (investor, partition, operator) to approved status\r\n    mapping (address => mapping (bytes32 => mapping (address => bool))) partitionApprovals;\r\n\r\n}\r\n\r\n/**\r\n * @title Interface to be implemented by all Transfer Manager modules\r\n */\r\ninterface ITransferManager {\r\n    //  If verifyTransfer returns:\r\n    //  FORCE_VALID, the transaction will always be valid, regardless of other TM results\r\n    //  INVALID, then the transfer should not be allowed regardless of other TM results\r\n    //  VALID, then the transfer is valid for this TM\r\n    //  NA, then the result from this TM is ignored\r\n    enum Result {INVALID, NA, VALID, FORCE_VALID}\r\n\r\n    /**\r\n     * @notice Determines if the transfer between these two accounts can happen\r\n     */\r\n    function executeTransfer(address _from, address _to, uint256 _amount, bytes calldata _data) external returns(Result result);\r\n\r\n    function verifyTransfer(address _from, address _to, uint256 _amount, bytes calldata _data) external view returns(Result result, bytes32 partition);\r\n\r\n    /**\r\n     * @notice return the amount of tokens for a given user as per the partition\r\n     * @param _partition Identifier\r\n     * @param _tokenHolder Whom token amount need to query\r\n     * @param _additionalBalance It is the `_value` that transfer during transfer/transferFrom function call\r\n     */\r\n    function getTokensByPartition(bytes32 _partition, address _tokenHolder, uint256 _additionalBalance) external view returns(uint256 amount);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface to be implemented by all permission manager modules\r\n */\r\ninterface IPermissionManager {\r\n    /**\r\n    * @notice Used to check the permission on delegate corresponds to module contract address\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _module Ethereum contract address of the module\r\n    * @param _perm Permission flag\r\n    * @return bool\r\n    */\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool);\r\n\r\n    /**\r\n    * @notice Used to add a delegate\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _details Details about the delegate i.e `Belongs to financial firm`\r\n    */\r\n    function addDelegate(address _delegate, bytes32 _details) external;\r\n\r\n    /**\r\n    * @notice Used to delete a delegate\r\n    * @param _delegate Ethereum address of the delegate\r\n    */\r\n    function deleteDelegate(address _delegate) external;\r\n\r\n    /**\r\n    * @notice Used to check if an address is a delegate or not\r\n    * @param _potentialDelegate the address of potential delegate\r\n    * @return bool\r\n    */\r\n    function checkDelegate(address _potentialDelegate) external view returns(bool);\r\n\r\n    /**\r\n    * @notice Used to provide/change the permission to the delegate corresponds to the module contract\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _module Ethereum contract address of the module\r\n    * @param _perm Permission flag\r\n    * @param _valid Bool flag use to switch on/off the permission\r\n    * @return bool\r\n    */\r\n    function changePermission(address _delegate, address _module, bytes32 _perm, bool _valid) external;\r\n\r\n    /**\r\n    * @notice Used to change one or more permissions for a single delegate at once\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _modules Multiple module matching the multiperms, needs to be same length\r\n    * @param _perms Multiple permission flag needs to be changed\r\n    * @param _valids Bool array consist the flag to switch on/off the permission\r\n    * @return nothing\r\n    */\r\n    function changePermissionMulti(\r\n        address _delegate,\r\n        address[] calldata _modules,\r\n        bytes32[] calldata _perms,\r\n        bool[] calldata _valids\r\n    ) external;\r\n\r\n    /**\r\n    * @notice Used to return all delegates with a given permission and module\r\n    * @param _module Ethereum contract address of the module\r\n    * @param _perm Permission flag\r\n    * @return address[]\r\n    */\r\n    function getAllDelegatesWithPerm(address _module, bytes32 _perm) external view returns(address[] memory);\r\n\r\n    /**\r\n    * @notice Used to return all permission of a single or multiple module\r\n    * @dev possible that function get out of gas is there are lot of modules and perm related to them\r\n    * @param _delegate Ethereum address of the delegate\r\n    * @param _types uint8[] of types\r\n    * @return address[] the address array of Modules this delegate has permission\r\n    * @return bytes32[] the permission array of the corresponding Modules\r\n    */\r\n    function getAllModulesAndPermsFromTypes(address _delegate, uint8[] calldata _types) external view returns(\r\n        address[] memory,\r\n        bytes32[] memory\r\n    );\r\n\r\n    /**\r\n    * @notice Used to get the Permission flag related the `this` contract\r\n    * @return Array of permission flags\r\n    */\r\n    function getPermissions() external view returns(bytes32[] memory);\r\n\r\n    /**\r\n    * @notice Used to get all delegates\r\n    * @return address[]\r\n    */\r\n    function getAllDelegates() external view returns(address[] memory);\r\n\r\n}\r\n\r\nlibrary TokenLib {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct EIP712Domain {\r\n        string  name;\r\n        uint256 chainId;\r\n        address verifyingContract;\r\n    }\r\n\r\n    struct Acknowledgment {\r\n        string text;\r\n    }\r\n\r\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\r\n    );\r\n\r\n    bytes32 constant ACK_TYPEHASH = keccak256(\r\n        \"Acknowledgment(string text)\"\r\n    );\r\n\r\n    bytes32 internal constant WHITELIST = \"WHITELIST\";\r\n    bytes32 internal constant INVESTORSKEY = 0xdf3a8dd24acdd05addfc6aeffef7574d2de3f844535ec91e8e0f3e45dba96731; //keccak256(abi.encodePacked(\"INVESTORS\"))\r\n\r\n    // Emit when Module get upgraded from the securityToken\r\n    event ModuleUpgraded(uint8[] _types, address _module);\r\n    // Emit when Module is archived from the SecurityToken\r\n    event ModuleArchived(uint8[] _types, address _module);\r\n    // Emit when Module is unarchived from the SecurityToken\r\n    event ModuleUnarchived(uint8[] _types, address _module);\r\n    // Emit when Module get removed from the securityToken\r\n    event ModuleRemoved(uint8[] _types, address _module);\r\n    // Emit when the budget allocated to a module is changed\r\n    event ModuleBudgetChanged(uint8[] _moduleTypes, address _module, uint256 _oldBudget, uint256 _budget);\r\n    // Emit when document is added/removed\r\n    event DocumentUpdated(bytes32 indexed _name, string _uri, bytes32 _documentHash);\r\n    event DocumentRemoved(bytes32 indexed _name, string _uri, bytes32 _documentHash);\r\n\r\n    function hash(EIP712Domain memory _eip712Domain) internal pure returns (bytes32) {\r\n        return keccak256(\r\n            abi.encode(\r\n                EIP712DOMAIN_TYPEHASH,\r\n                keccak256(bytes(_eip712Domain.name)),\r\n                _eip712Domain.chainId,\r\n                _eip712Domain.verifyingContract\r\n            )\r\n        );\r\n    }\r\n\r\n    function hash(Acknowledgment memory _ack) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(ACK_TYPEHASH, keccak256(bytes(_ack.text))));\r\n    }\r\n\r\n    function recoverFreezeIssuanceAckSigner(bytes calldata _signature) external view returns (address) {\r\n        Acknowledgment memory ack = Acknowledgment(\"I acknowledge that freezing Issuance is a permanent and irrevocable change\");\r\n        return extractSigner(ack, _signature);\r\n    }\r\n\r\n    function recoverDisableControllerAckSigner(bytes calldata _signature) external view returns (address) {\r\n        Acknowledgment memory ack = Acknowledgment(\"I acknowledge that disabling controller is a permanent and irrevocable change\");\r\n        return extractSigner(ack, _signature);\r\n    }\r\n\r\n    function extractSigner(Acknowledgment memory _ack, bytes memory _signature) internal view returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        if (_signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(_signature, 0x20))\r\n            s := mload(add(_signature, 0x40))\r\n            v := byte(0, mload(add(_signature, 0x60)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        }\r\n\r\n        bytes32 DOMAIN_SEPARATOR = hash(\r\n            EIP712Domain(\r\n                {\r\n                    name: \"Polymath\",\r\n                    chainId: 1,\r\n                    verifyingContract: address(this)\r\n                }\r\n            )\r\n        );\r\n\r\n        // Note: we need to use `encodePacked` here instead of `encode`.\r\n        bytes32 digest = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            hash(_ack)\r\n        ));\r\n        return ecrecover(digest, v, r, s);\r\n    }\r\n\r\n    /**\r\n    * @notice Archives a module attached to the SecurityToken\r\n    * @param _moduleData Storage data\r\n    */\r\n    function archiveModule(SecurityTokenStorage.ModuleData storage _moduleData) external {\r\n        require(!_moduleData.isArchived, \"Module archived\");\r\n        require(_moduleData.module != address(0), \"Module missing\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit ModuleArchived(_moduleData.moduleTypes, _moduleData.module);\r\n        _moduleData.isArchived = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Unarchives a module attached to the SecurityToken\r\n    * @param _moduleData Storage data\r\n    */\r\n    function unarchiveModule(IModuleRegistry _moduleRegistry, SecurityTokenStorage.ModuleData storage _moduleData) external {\r\n        require(_moduleData.isArchived, \"Module unarchived\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        // Check the version is still valid - can only be false if token was upgraded between unarchive / archive\r\n        _moduleRegistry.useModule(_moduleData.moduleFactory, true);\r\n        emit ModuleUnarchived(_moduleData.moduleTypes, _moduleData.module);\r\n        _moduleData.isArchived = false;\r\n    }\r\n\r\n    /**\r\n    * @notice Upgrades a module attached to the SecurityToken\r\n    * @param _moduleData Storage data\r\n    */\r\n    function upgradeModule(IModuleRegistry _moduleRegistry, SecurityTokenStorage.ModuleData storage _moduleData) external {\r\n        require(_moduleData.module != address(0), \"Module missing\");\r\n        //Check module is verified and within version bounds\r\n        _moduleRegistry.useModule(_moduleData.moduleFactory, true);\r\n        // Will revert if module isn't upgradable\r\n        UpgradableModuleFactory(_moduleData.moduleFactory).upgrade(_moduleData.module);\r\n        emit ModuleUpgraded(_moduleData.moduleTypes, _moduleData.module);\r\n    }\r\n\r\n    /**\r\n    * @notice Removes a module attached to the SecurityToken\r\n    * @param _module address of module to unarchive\r\n    */\r\n    function removeModule(\r\n        address _module,\r\n        mapping(uint8 => address[]) storage _modules,\r\n        mapping(address => SecurityTokenStorage.ModuleData) storage _modulesToData,\r\n        mapping(bytes32 => address[]) storage _names\r\n    )\r\n        external\r\n    {\r\n        require(_modulesToData[_module].isArchived, \"Not archived\");\r\n        require(_modulesToData[_module].module != address(0), \"Module missing\");\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit ModuleRemoved(_modulesToData[_module].moduleTypes, _module);\r\n        // Remove from module type list\r\n        uint8[] memory moduleTypes = _modulesToData[_module].moduleTypes;\r\n        for (uint256 i = 0; i < moduleTypes.length; i++) {\r\n            _removeModuleWithIndex(moduleTypes[i], _modulesToData[_module].moduleIndexes[i], _modules, _modulesToData);\r\n            /* modulesToData[_module].moduleType[moduleTypes[i]] = false; */\r\n        }\r\n        // Remove from module names list\r\n        uint256 index = _modulesToData[_module].nameIndex;\r\n        bytes32 name = _modulesToData[_module].name;\r\n        uint256 length = _names[name].length;\r\n        _names[name][index] = _names[name][length - 1];\r\n        _names[name].length = length - 1;\r\n        if ((length - 1) != index) {\r\n            _modulesToData[_names[name][index]].nameIndex = index;\r\n        }\r\n        // Remove from modulesToData\r\n        delete _modulesToData[_module];\r\n    }\r\n\r\n    /**\r\n    * @notice Internal - Removes a module attached to the SecurityToken by index\r\n    */\r\n    function _removeModuleWithIndex(\r\n        uint8 _type,\r\n        uint256 _index,\r\n        mapping(uint8 => address[]) storage _modules,\r\n        mapping(address => SecurityTokenStorage.ModuleData) storage _modulesToData\r\n    )\r\n        internal\r\n    {\r\n        uint256 length = _modules[_type].length;\r\n        _modules[_type][_index] = _modules[_type][length - 1];\r\n        _modules[_type].length = length - 1;\r\n\r\n        if ((length - 1) != _index) {\r\n            //Need to find index of _type in moduleTypes of module we are moving\r\n            uint8[] memory newTypes = _modulesToData[_modules[_type][_index]].moduleTypes;\r\n            for (uint256 i = 0; i < newTypes.length; i++) {\r\n                if (newTypes[i] == _type) {\r\n                    _modulesToData[_modules[_type][_index]].moduleIndexes[i] = _index;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice allows owner to increase/decrease POLY approval of one of the modules\r\n    * @param _module module address\r\n    * @param _change change in allowance\r\n    * @param _increase true if budget has to be increased, false if decrease\r\n    */\r\n    function changeModuleBudget(\r\n        address _module,\r\n        uint256 _change,\r\n        bool _increase,\r\n        IERC20 _polyToken,\r\n        mapping(address => SecurityTokenStorage.ModuleData) storage _modulesToData\r\n    )\r\n        external\r\n    {\r\n        require(_modulesToData[_module].module != address(0), \"Module missing\");\r\n        uint256 currentAllowance = _polyToken.allowance(address(this), _module);\r\n        uint256 newAllowance;\r\n        if (_increase) {\r\n            require(IPoly(address(_polyToken)).increaseApproval(_module, _change), \"IncreaseApproval fail\");\r\n            newAllowance = currentAllowance.add(_change);\r\n        } else {\r\n            require(IPoly(address(_polyToken)).decreaseApproval(_module, _change), \"Insufficient allowance\");\r\n            newAllowance = currentAllowance.sub(_change);\r\n        }\r\n        emit ModuleBudgetChanged(_modulesToData[_module].moduleTypes, _module, currentAllowance, newAllowance);\r\n    }\r\n\r\n    /**\r\n     * @notice Queries a value at a defined checkpoint\r\n     * @param _checkpoints is array of Checkpoint objects\r\n     * @param _checkpointId is the Checkpoint ID to query\r\n     * @param _currentValue is the Current value of checkpoint\r\n     * @return uint256\r\n     */\r\n    function getValueAt(SecurityTokenStorage.Checkpoint[] storage _checkpoints, uint256 _checkpointId, uint256 _currentValue) external view returns(uint256) {\r\n        //Checkpoint id 0 is when the token is first created - everyone has a zero balance\r\n        if (_checkpointId == 0) {\r\n            return 0;\r\n        }\r\n        if (_checkpoints.length == 0) {\r\n            return _currentValue;\r\n        }\r\n        if (_checkpoints[0].checkpointId >= _checkpointId) {\r\n            return _checkpoints[0].value;\r\n        }\r\n        if (_checkpoints[_checkpoints.length - 1].checkpointId < _checkpointId) {\r\n            return _currentValue;\r\n        }\r\n        if (_checkpoints[_checkpoints.length - 1].checkpointId == _checkpointId) {\r\n            return _checkpoints[_checkpoints.length - 1].value;\r\n        }\r\n        uint256 min = 0;\r\n        uint256 max = _checkpoints.length - 1;\r\n        while (max > min) {\r\n            uint256 mid = (max + min) / 2;\r\n            if (_checkpoints[mid].checkpointId == _checkpointId) {\r\n                max = mid;\r\n                break;\r\n            }\r\n            if (_checkpoints[mid].checkpointId < _checkpointId) {\r\n                min = mid + 1;\r\n            } else {\r\n                max = mid;\r\n            }\r\n        }\r\n        return _checkpoints[max].value;\r\n    }\r\n\r\n    /**\r\n     * @notice Stores the changes to the checkpoint objects\r\n     * @param _checkpoints is the affected checkpoint object array\r\n     * @param _newValue is the new value that needs to be stored\r\n     */\r\n    function adjustCheckpoints(SecurityTokenStorage.Checkpoint[] storage _checkpoints, uint256 _newValue, uint256 _currentCheckpointId) external {\r\n        //No checkpoints set yet\r\n        if (_currentCheckpointId == 0) {\r\n            return;\r\n        }\r\n        //No new checkpoints since last update\r\n        if ((_checkpoints.length > 0) && (_checkpoints[_checkpoints.length - 1].checkpointId == _currentCheckpointId)) {\r\n            return;\r\n        }\r\n        //New checkpoint, so record balance\r\n        _checkpoints.push(SecurityTokenStorage.Checkpoint({checkpointId: _currentCheckpointId, value: _newValue}));\r\n    }\r\n\r\n    /**\r\n    * @notice Keeps track of the number of non-zero token holders\r\n    * @param _holderCount Number of current token holders\r\n    * @param _from Sender of transfer\r\n    * @param _to Receiver of transfer\r\n    * @param _value Value of transfer\r\n    * @param _balanceTo Balance of the _to address\r\n    * @param _balanceFrom Balance of the _from address\r\n    * @param _dataStore address of data store\r\n    */\r\n    function adjustInvestorCount(\r\n        uint256 _holderCount,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        uint256 _balanceTo,\r\n        uint256 _balanceFrom,\r\n        IDataStore _dataStore\r\n    )\r\n        external\r\n        returns(uint256)\r\n    {\r\n        uint256 holderCount = _holderCount;\r\n        if ((_value == 0) || (_from == _to)) {\r\n            return holderCount;\r\n        }\r\n        // Check whether receiver is a new token holder\r\n        if ((_balanceTo == 0) && (_to != address(0))) {\r\n            holderCount = holderCount.add(1);\r\n            if (!_isExistingInvestor(_to, _dataStore)) {\r\n                _dataStore.insertAddress(INVESTORSKEY, _to);\r\n                //KYC data can not be present if added is false and hence we can set packed KYC as uint256(1) to set added as true\r\n                _dataStore.setUint256(_getKey(WHITELIST, _to), uint256(1));\r\n            }\r\n        }\r\n        // Check whether sender is moving all of their tokens\r\n        if (_value == _balanceFrom) {\r\n            holderCount = holderCount.sub(1);\r\n        }\r\n\r\n        return holderCount;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to attach a new document to the contract, or update the URI or hash of an existing attached document\r\n     * @param name Name of the document. It should be unique always\r\n     * @param uri Off-chain uri of the document from where it is accessible to investors/advisors to read.\r\n     * @param documentHash hash (of the contents) of the document.\r\n     */\r\n    function setDocument(\r\n        mapping(bytes32 => SecurityTokenStorage.Document) storage document,\r\n        bytes32[] storage docNames,\r\n        mapping(bytes32 => uint256) storage docIndexes,\r\n        bytes32 name,\r\n        string calldata uri,\r\n        bytes32 documentHash\r\n    )\r\n        external\r\n    {\r\n        require(name != bytes32(0), \"Bad name\");\r\n        require(bytes(uri).length > 0, \"Bad uri\");\r\n        if (document[name].lastModified == uint256(0)) {\r\n            docNames.push(name);\r\n            docIndexes[name] = docNames.length;\r\n        }\r\n        document[name] = SecurityTokenStorage.Document(documentHash, now, uri);\r\n        emit DocumentUpdated(name, uri, documentHash);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to remove an existing document from the contract by giving the name of the document.\r\n     * @dev Can only be executed by the owner of the contract.\r\n     * @param name Name of the document. It should be unique always\r\n     */\r\n    function removeDocument(\r\n        mapping(bytes32 => SecurityTokenStorage.Document) storage document,\r\n        bytes32[] storage docNames,\r\n        mapping(bytes32 => uint256) storage docIndexes,\r\n        bytes32 name\r\n    )\r\n        external\r\n    {\r\n        require(document[name].lastModified != uint256(0), \"Not existed\");\r\n        uint256 index = docIndexes[name] - 1;\r\n        if (index != docNames.length - 1) {\r\n            docNames[index] = docNames[docNames.length - 1];\r\n            docIndexes[docNames[index]] = index + 1;\r\n        }\r\n        docNames.length--;\r\n        emit DocumentRemoved(name, document[name].uri, document[name].docHash);\r\n        delete document[name];\r\n    }\r\n\r\n    /**\r\n     * @notice Validate transfer with TransferManager module if it exists\r\n     * @dev TransferManager module has a key of 2\r\n     * @param modules Array of addresses for transfer managers\r\n     * @param modulesToData Mapping of the modules details\r\n     * @param from sender of transfer\r\n     * @param to receiver of transfer\r\n     * @param value value of transfer\r\n     * @param data data to indicate validation\r\n     * @param transfersFrozen whether the transfer are frozen or not.\r\n     * @return bool\r\n     */\r\n    function verifyTransfer(\r\n        address[] storage modules,\r\n        mapping(address => SecurityTokenStorage.ModuleData) storage modulesToData,\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        bool transfersFrozen\r\n    )\r\n        public //Marked public to avoid stack too deep error\r\n        view\r\n        returns(bool, bytes32)\r\n    {\r\n        if (!transfersFrozen) {\r\n            bool isInvalid = false;\r\n            bool isValid = false;\r\n            bool isForceValid = false;\r\n            // Use the local variables to avoid the stack too deep error\r\n            bytes32 appCode;\r\n            for (uint256 i = 0; i < modules.length; i++) {\r\n                if (!modulesToData[modules[i]].isArchived) {\r\n                    (ITransferManager.Result valid, bytes32 reason) = ITransferManager(modules[i]).verifyTransfer(from, to, value, data);\r\n                    if (valid == ITransferManager.Result.INVALID) {\r\n                        isInvalid = true;\r\n                        appCode = reason;\r\n                    } else if (valid == ITransferManager.Result.VALID) {\r\n                        isValid = true;\r\n                    } else if (valid == ITransferManager.Result.FORCE_VALID) {\r\n                        isForceValid = true;\r\n                    }\r\n                }\r\n            }\r\n            // Use the local variables to avoid the stack too deep error\r\n            isValid = isForceValid ? true : (isInvalid ? false : isValid);\r\n            return (isValid, isValid ? bytes32(StatusCodes.code(StatusCodes.Status.TransferSuccess)): appCode);\r\n        }\r\n        return (false, bytes32(StatusCodes.code(StatusCodes.Status.TransfersHalted)));\r\n    }\r\n\r\n    function canTransfer(\r\n        bool success,\r\n        bytes32 appCode,\r\n        address to,\r\n        uint256 value,\r\n        uint256 balanceOfFrom\r\n    )\r\n        external\r\n        pure\r\n        returns (byte, bytes32)\r\n    {\r\n        if (!success)\r\n            return (StatusCodes.code(StatusCodes.Status.TransferFailure), appCode);\r\n\r\n        if (balanceOfFrom < value)\r\n            return (StatusCodes.code(StatusCodes.Status.InsufficientBalance), bytes32(0));\r\n\r\n        if (to == address(0))\r\n            return (StatusCodes.code(StatusCodes.Status.InvalidReceiver), bytes32(0));\r\n\r\n        // Balance overflow can never happen due to totalsupply being a uint256 as well\r\n        // else if (!KindMath.checkAdd(balanceOf(_to), _value))\r\n        //     return (0x50, bytes32(0));\r\n\r\n        return (StatusCodes.code(StatusCodes.Status.TransferSuccess), bytes32(0));\r\n    }\r\n\r\n    function _getKey(bytes32 _key1, address _key2) internal pure returns(bytes32) {\r\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\r\n    }\r\n\r\n    function _isExistingInvestor(address _investor, IDataStore dataStore) internal view returns(bool) {\r\n        uint256 data = dataStore.getUint256(_getKey(WHITELIST, _investor));\r\n        //extracts `added` from packed `whitelistData`\r\n        return uint8(data) == 0 ? false : true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"appCode\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"balanceOfFrom\",\"type\":\"uint256\"}],\"name\":\"canTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"recoverDisableControllerAckSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"recoverFreezeIssuanceAckSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_types\",\"type\":\"uint8[]\"},{\"indexed\":false,\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"ModuleUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_types\",\"type\":\"uint8[]\"},{\"indexed\":false,\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"ModuleArchived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_types\",\"type\":\"uint8[]\"},{\"indexed\":false,\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"ModuleUnarchived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_types\",\"type\":\"uint8[]\"},{\"indexed\":false,\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"ModuleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_moduleTypes\",\"type\":\"uint8[]\"},{\"indexed\":false,\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_oldBudget\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_budget\",\"type\":\"uint256\"}],\"name\":\"ModuleBudgetChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_uri\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_documentHash\",\"type\":\"bytes32\"}],\"name\":\"DocumentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_uri\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_documentHash\",\"type\":\"bytes32\"}],\"name\":\"DocumentRemoved\",\"type\":\"event\"}]","ContractName":"TokenLib","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://71f5e3ebb544ccfd89bd214c31805f6329bf909d4d5b07640c670c9be6a4dd50"}]}