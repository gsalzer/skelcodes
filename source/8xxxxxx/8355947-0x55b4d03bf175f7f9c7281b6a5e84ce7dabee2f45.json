{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n*\r\n*  Source code of DIB.ONE (https://dib.one) Interest Rate Swap product.\r\n*  Synthetic product contract for Opium Protocol (https://opium.network)\r\n*\r\n*/\r\n\r\npragma solidity ^0.5.4;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract LibDerivative {\r\n    struct Derivative {\r\n        uint256 margin;\r\n        uint256 endTime;\r\n        uint256[] params;\r\n        address oracleId;\r\n        address token;\r\n        address syntheticId;\r\n    }\r\n\r\n    function getDerivativeHash(Derivative memory _derivative) public pure returns (bytes32 derivativeHash) {\r\n        derivativeHash = keccak256(abi.encodePacked(\r\n            _derivative.margin,\r\n            _derivative.endTime,\r\n            _derivative.params,\r\n            _derivative.oracleId,\r\n            _derivative.token,\r\n            _derivative.syntheticId\r\n        ));\r\n    }\r\n}\r\n\r\n\r\ncontract IDerivativeLogic is LibDerivative {\r\n    // Validates input data and returns whether derivative could be created\r\n    function validateInput(Derivative memory _derivative) public view returns (bool);\r\n\r\n    // Returns margin needed for the derivative creation\r\n    function getMargin(Derivative memory _derivative) public view returns (uint256 buyerMargin, uint256 sellerMargin);\r\n\r\n    // Returns payouts for derivative's execution\r\n    function getExecutionPayout(Derivative memory _derivative, uint256 _result)\tpublic view returns (uint256 buyerPayout, uint256 sellerPayout);\r\n\r\n    // Returns author address\r\n    function getAuthorAddress() public view returns (address authorAddress);\r\n\r\n    // Returns author commission in base of COMMISSION_BASE\r\n    function getAuthorCommission() public view returns (uint256 comission);\r\n\r\n    // Returns whether thirdparty could execute on derivative's owner's behalf\r\n    function thirdpartyExecutionAllowed(address derivativeOwner) public view returns (bool);\r\n\r\n    // Returns whether synthetic implements pool logic\r\n    function isPool() public view returns (bool);\r\n\r\n    // Sets whether thirds parties are allowed or not to execute derivative's on msg.sender's behalf\r\n    function allowThirdpartyExecution(bool allow) public;\r\n\r\n    event MetadataSet(string metadata);\r\n}\r\n\r\ncontract ExecutableByThirdParty {\r\n    mapping (address => bool) thirdpartyExecutionAllowance;\r\n\r\n    function thirdpartyExecutionAllowed(address derivativeOwner) public view returns (bool) {\r\n        return thirdpartyExecutionAllowance[derivativeOwner];\r\n    }\r\n\r\n    function allowThirdpartyExecution(bool allow) public {\r\n        thirdpartyExecutionAllowance[msg.sender] = allow;\r\n    }\r\n}\r\n\r\ncontract HasCommission {\r\n    address public author;\r\n    // 0.25%\r\n    uint256 public commission = 25;\r\n\r\n    constructor() public {\r\n        author = msg.sender;\r\n    }\r\n\r\n    function getAuthorAddress() public view returns (address) {\r\n        return author;\r\n    }\r\n\r\n    function getAuthorCommission() public view returns (uint256) {\r\n        return commission;\r\n    }\r\n}\r\n\r\ncontract IRSLogic is IDerivativeLogic, ExecutableByThirdParty, HasCommission {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant YEAR_DAYS = 360 days;\r\n    \r\n    constructor() public {\r\n        /*\r\n        {\r\n            \"author\": \"DIB.ONE\",\r\n            \"type\": \"swap\",\r\n            \"subtype\": \"irs\",\r\n            \"description\": \"IRS logic contract\"\r\n        }\r\n        */\r\n        emit MetadataSet(\"{\\\"author\\\":\\\"DIB.ONE\\\",\\\"type\\\":\\\"swap\\\",\\\"subtype\\\":\\\"irs\\\",\\\"description\\\":\\\"IRS logic contract\\\"}\");\r\n    }\r\n\r\n    // params[0] - nominal\r\n    // params[1] - fixedRate\r\n    // params[2] - initialIndex\r\n    // params[3] - initialTimestamp\r\n    function validateInput(Derivative memory _derivative) public view returns (bool) {\r\n        if (_derivative.params.length < 3) {\r\n            return false;\r\n        }\r\n\r\n        uint256 nominal = _derivative.params[0];\r\n        uint256 fixedRate = _derivative.params[1];\r\n        uint256 initialIndex = _derivative.params[2];\r\n        uint256 initialTimestamp = _derivative.params[3];\r\n        return (\r\n            _derivative.margin > 0 &&\r\n            _derivative.endTime > now &&\r\n            nominal > 0 &&\r\n            fixedRate > 0 &&\r\n            initialIndex > 0 &&\r\n            initialTimestamp <= now\r\n        );\r\n    }\r\n\r\n    function getMargin(Derivative memory _derivative) public view returns (uint256 buyerMargin, uint256 sellerMargin) {\r\n        buyerMargin = _derivative.margin;\r\n        sellerMargin = _derivative.margin;\r\n    }\r\n\r\n    function getExecutionPayout(Derivative memory _derivative, uint256 _currentIndex) public view returns (uint256 buyerPayout, uint256 sellerPayout) {\r\n        uint256 nominal = _derivative.params[0];\r\n        uint256 fixedRate = _derivative.params[1];\r\n        uint256 initialIndex = _derivative.params[2];\r\n        uint256 initialTimestamp = _derivative.params[3];\r\n\r\n        // timeElapsed = now - initialTimestamp\r\n        uint256 timeElapsed = now.sub(initialTimestamp);\r\n\r\n        // accumulatedRate = _currentIndex * 1e18 / initialIndex - 1e18\r\n        uint256 accumulatedRate = _currentIndex.mul(10**18).div(initialIndex).sub(10**18);\r\n\r\n        // fixedAmount = fixedRate * nominal * timeElapsed / YEARLY_BLOKS / 1e18\r\n        uint256 fixedAmount = fixedRate.mul(nominal).mul(timeElapsed).div(YEAR_DAYS).div(10**18);\r\n        \r\n        // accumulatedAmount = accumulatedRate * nominal / 1e18\r\n        uint256 accumulatedAmount = accumulatedRate.mul(nominal).div(10**18);\r\n        \r\n        uint256 profit;\r\n        if (fixedAmount > accumulatedAmount) { // Buyer earns\r\n            profit = fixedAmount - accumulatedAmount;\r\n\r\n            if (profit > _derivative.margin) {\r\n                buyerPayout = uint256(2).mul(_derivative.margin);\r\n                sellerPayout = 0;\r\n            } else {\r\n                buyerPayout = _derivative.margin.add(profit);\r\n                sellerPayout = _derivative.margin.sub(profit);\r\n            }\r\n        } else { // Seller earns\r\n            profit = accumulatedAmount - fixedAmount;\r\n\r\n            if (profit > _derivative.margin) {\r\n                buyerPayout = 0;\r\n                sellerPayout = uint256(2).mul(_derivative.margin);\r\n            } else {\r\n                buyerPayout = _derivative.margin.sub(profit);\r\n                sellerPayout = _derivative.margin.add(profit);\r\n            }\r\n        }\r\n    }\r\n\r\n    function isPool() public view returns (bool) {\r\n        return false;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"margin\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"params\",\"type\":\"uint256[]\"},{\"name\":\"oracleId\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"syntheticId\",\"type\":\"address\"}],\"name\":\"_derivative\",\"type\":\"tuple\"}],\"name\":\"getMargin\",\"outputs\":[{\"name\":\"buyerMargin\",\"type\":\"uint256\"},{\"name\":\"sellerMargin\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"allow\",\"type\":\"bool\"}],\"name\":\"allowThirdpartyExecution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"margin\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"params\",\"type\":\"uint256[]\"},{\"name\":\"oracleId\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"syntheticId\",\"type\":\"address\"}],\"name\":\"_derivative\",\"type\":\"tuple\"}],\"name\":\"validateInput\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuthorCommission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuthorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"author\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"margin\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"params\",\"type\":\"uint256[]\"},{\"name\":\"oracleId\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"syntheticId\",\"type\":\"address\"}],\"name\":\"_derivative\",\"type\":\"tuple\"},{\"name\":\"_currentIndex\",\"type\":\"uint256\"}],\"name\":\"getExecutionPayout\",\"outputs\":[{\"name\":\"buyerPayout\",\"type\":\"uint256\"},{\"name\":\"sellerPayout\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPool\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"margin\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"params\",\"type\":\"uint256[]\"},{\"name\":\"oracleId\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"syntheticId\",\"type\":\"address\"}],\"name\":\"_derivative\",\"type\":\"tuple\"}],\"name\":\"getDerivativeHash\",\"outputs\":[{\"name\":\"derivativeHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"derivativeOwner\",\"type\":\"address\"}],\"name\":\"thirdpartyExecutionAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"metadata\",\"type\":\"string\"}],\"name\":\"MetadataSet\",\"type\":\"event\"}]","ContractName":"IRSLogic","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ead6e8c8452b0aabc27ed1399fb9061760c2e238347c002cf26ceb7742006bee"}]}