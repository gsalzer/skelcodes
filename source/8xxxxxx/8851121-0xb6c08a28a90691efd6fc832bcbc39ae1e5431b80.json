{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others (`ERC165Checker`).\r\n *\r\n * For an implementation, see `ERC165`.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * \r\n     *\r\n     * Requirements:\r\n     * - `from`, `to` cannot be zero.\r\n     * - `tokenId` must be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this\r\n     * NFT by either `approve` or `setApproveForAll`.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n    /**\r\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Requirements:\r\n     * - If the caller is not `from`, it must be approved to move this NFT by\r\n     * either `approve` or `setApproveForAll`.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n\r\ncontract ICards is IERC721 {\r\n\r\n    struct Batch {\r\n        uint48 userID;\r\n        uint16 size;\r\n    }\r\n\r\n    function batches(uint index) public view returns (uint48 userID, uint16 size);\r\n\r\n    function userIDToAddress(uint48 id) public view returns (address);\r\n\r\n    function getDetails(\r\n        uint tokenId\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n        uint16 proto,\r\n        uint8 quality\r\n    );\r\n\r\n    function setQuality(\r\n        uint tokenId,\r\n        uint8 quality\r\n    ) public;\r\n\r\n    function mintCards(\r\n        address to,\r\n        uint16[] memory _protos,\r\n        uint8[] memory _qualities\r\n    )\r\n        public\r\n        returns (uint);\r\n\r\n    function mintCard(\r\n        address to,\r\n        uint16 _proto,\r\n        uint8 _quality\r\n    )\r\n        public\r\n        returns (uint);\r\n\r\n    function burn(uint tokenId) public;\r\n\r\n    function batchSize()\r\n        public\r\n        view\r\n        returns (uint);\r\n}\r\n\r\ncontract MigrationMigration {\r\n\r\n    uint public batchIndex;\r\n    ICards public oldCards;\r\n    ICards public newCards;\r\n    uint public constant batchSize = 1251;\r\n\r\n    constructor(ICards _oldCards, ICards _newCards) public {\r\n        oldCards = _oldCards;\r\n        newCards = _newCards;\r\n\r\n    }\r\n\r\n    event Migrated(uint batchIndex, uint startID);\r\n\r\n    function migrate() public {\r\n\r\n        (uint48 userID, uint16 size) = oldCards.batches(batchIndex * batchSize);\r\n        require(size > 0, \"must be cards in this batch\");\r\n        uint16[] memory protos = new uint16[](size);\r\n        uint8[] memory qualities = new uint8[](size);\r\n        uint startID = batchIndex * batchSize;\r\n        for (uint i = 0; i < size; i++) {\r\n            (protos[i], qualities[i]) = oldCards.getDetails(startID + i);\r\n        }\r\n        address user = oldCards.userIDToAddress(userID);\r\n        newCards.mintCards(user, protos, qualities);\r\n        emit Migrated(batchIndex, startID);\r\n        batchIndex++;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"oldCards\",\"outputs\":[{\"internalType\":\"contract ICards\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newCards\",\"outputs\":[{\"internalType\":\"contract ICards\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"batchIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"batchSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICards\",\"name\":\"_oldCards\",\"type\":\"address\"},{\"internalType\":\"contract ICards\",\"name\":\"_newCards\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startID\",\"type\":\"uint256\"}],\"name\":\"Migrated\",\"type\":\"event\"}]","ContractName":"MigrationMigration","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000564cb55c655f727b61d9baf258b547ca04e9e548000000000000000000000000629cdec6acc980ebeebea9e5003bcd44db9fc5ce","Library":"","LicenseType":"None","SwarmSource":"bzzr://673d3dcdea5665c98f06573ab5dbbf07bb3fd9a5a313a2d862eacb63b612c62b"}]}