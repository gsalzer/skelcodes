{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/v5/Reversi.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\nlibrary Reversi {\r\n    // event DebugBool(bool boolean);\r\n    // event DebugBoard(bytes16 board);\r\n    // event DebugUint(uint u);\r\n    uint8 constant BLACK = 1; //0b01 //0x1\r\n    uint8 constant WHITE = 2; //0b10 //0x2\r\n    uint8 constant EMPTY = 3; //0b11 //0x3\r\n\r\n    struct Game {\r\n        bool error;\r\n        bool complete;\r\n        bool symmetrical;\r\n        bool RotSym;\r\n        bool Y0Sym;\r\n        bool X0Sym;\r\n        bool XYSym;\r\n        bool XnYSym;\r\n        bytes16 board;\r\n        bytes28 first32Moves;\r\n        bytes28 lastMoves;\r\n\r\n        uint8 currentPlayer;\r\n        uint8 moveKey;\r\n        uint8 blackScore;\r\n        uint8 whiteScore;\r\n        // string msg;\r\n    }\r\n\r\n\r\n    function isValid (bytes28[2] memory moves) public pure returns (bool) {\r\n        Game memory game = playGame(moves);\r\n        if (game.error) {\r\n            return false;\r\n        } else if (!game.complete) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function getGame (bytes28[2] memory moves) public pure returns (\r\n        bool error,\r\n        bool complete,\r\n        bool symmetrical,\r\n        bytes16 board,\r\n        uint8 currentPlayer,\r\n        uint8 moveKey\r\n    // , string memory msg\r\n    ) {\r\n      Game memory game = playGame(moves);\r\n        return (\r\n            game.error,\r\n            game.complete,\r\n            game.symmetrical,\r\n            game.board,\r\n            game.currentPlayer,\r\n            game.moveKey\r\n            // , game.msg\r\n        );\r\n    }\r\n\r\n    function showColors () public pure returns(uint8, uint8, uint8) {\r\n        return (EMPTY, BLACK, WHITE);\r\n    }\r\n\r\n    function emptyBoard() public pure returns (bytes16) {\r\n        // game.board = bytes16(10625432672847758622720); // completely empty board\r\n        return bytes16(uint128(340282366920938456379662753540715053055)); // empty board except for center pieces\r\n    }\r\n\r\n    function playGame (bytes28[2] memory moves) internal pure returns (Game memory)  {\r\n        Game memory game;\r\n\r\n        game.first32Moves = moves[0];\r\n        game.lastMoves = moves[1];\r\n        game.moveKey = 0;\r\n        game.blackScore = 2;\r\n        game.whiteScore = 2;\r\n\r\n        game.error = false;\r\n        game.complete = false;\r\n        game.currentPlayer = BLACK;\r\n\r\n        game.board = emptyBoard();\r\n\r\n        bool skip;\r\n        uint8 move;\r\n        uint8 col;\r\n        uint8 row;\r\n        uint8 i;\r\n        bytes28 currentMoves;\r\n\r\n        for (i = 0; i < 60 && !skip; i++) {\r\n            currentMoves = game.moveKey < 32 ? game.first32Moves : game.lastMoves;\r\n            move = readMove(currentMoves, game.moveKey % 32, 32);\r\n            (col, row) = convertMove(move);\r\n            skip = !validMove(move);\r\n            if (i == 0 && (col != 2 || row != 3)) {\r\n                skip = true; // this is to force the first move to always be C4 to avoid repeatable boards via mirroring translations\r\n                game.error = true;\r\n            }\r\n            if (!skip && col < 8 && row < 8 && col >= 0 && row >= 0) {\r\n                // game.msg = \"make a move\";\r\n                game = makeMove(game, col, row);\r\n                game.moveKey = game.moveKey + 1;\r\n                if (game.error) {\r\n                    if (!validMoveRemains(game)) {\r\n                        // player has no valid moves and must pass\r\n                        game.error = false;\r\n                        if (game.currentPlayer == BLACK) {\r\n                            game.currentPlayer = WHITE;\r\n                        } else {\r\n                            game.currentPlayer = BLACK;\r\n                        }\r\n                        game = makeMove(game, col, row);\r\n                        if (game.error) {\r\n                            game.error = true;\r\n                            skip = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!game.error) {\r\n            game = isComplete(game);\r\n            game = isSymmetrical(game);\r\n        }\r\n        return game;\r\n    }\r\n\r\n    function validMoveRemains (Game memory game) internal pure returns (bool) {\r\n        bool validMovesRemain = false;\r\n        bytes16 board = game.board;\r\n        uint8 i;\r\n        for (i = 0; i < 64 && !validMovesRemain; i++) {\r\n            uint8[2] memory move = [((i - (i % 8)) / 8), (i % 8)];\r\n            uint8 tile = returnTile(game.board, move[0], move[1]);\r\n            if (tile == EMPTY) {\r\n                game.error = false;\r\n                game.board = board;\r\n                game = makeMove(game, move[0], move[1]);\r\n                if (!game.error) {\r\n                    validMovesRemain = true;\r\n                }\r\n            }\r\n        }\r\n        return validMovesRemain;\r\n    }\r\n\r\n    function makeMove (Game memory game, uint8 col, uint8 row) internal pure returns (Game memory)  {\r\n        // square is already occupied\r\n        if (returnTile(game.board, col, row) != EMPTY){\r\n            game.error = true;\r\n            // game.msg = \"Invalid Game (square is already occupied)\";\r\n            return game;\r\n        }\r\n        int8[2][8] memory possibleDirections;\r\n        uint8  possibleDirectionsLength;\r\n        (possibleDirections, possibleDirectionsLength) = getPossibleDirections(game, col, row);\r\n        // no valid directions\r\n        if (possibleDirectionsLength == 0) {\r\n            game.error = true;\r\n            // game.msg = \"Invalid Game (doesnt border other tiles)\";\r\n            return game;\r\n        }\r\n\r\n        bytes28 newFlips;\r\n        uint8 newFlipsLength;\r\n        uint8 newFlipCol;\r\n        uint8 newFlipRow;\r\n        uint8 j;\r\n        bool valid = false;\r\n        for (uint8 i = 0; i < possibleDirectionsLength; i++) {\r\n            delete newFlips;\r\n            delete newFlipsLength;\r\n            (newFlips, newFlipsLength) = traverseDirection(game, possibleDirections[i], col, row);\r\n            for (j = 0; j < newFlipsLength; j++) {\r\n                if (!valid) valid = true;\r\n                (newFlipCol, newFlipRow) = convertMove(readMove(newFlips, j, newFlipsLength));\r\n                game.board = turnTile(game.board, game.currentPlayer, newFlipCol, newFlipRow);\r\n                if (game.currentPlayer == WHITE) {\r\n                    game.whiteScore += 1;\r\n                    game.blackScore -= 1;\r\n                } else {\r\n                    game.whiteScore -= 1;\r\n                    game.blackScore += 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        //no valid flips in directions\r\n        if (valid) {\r\n            game.board = turnTile(game.board, game.currentPlayer, col, row);\r\n            if (game.currentPlayer == WHITE) {\r\n                game.whiteScore += 1;\r\n            } else {\r\n                game.blackScore += 1;\r\n            }\r\n        } else {\r\n            game.error = true;\r\n            // game.msg = \"Invalid Game (doesnt flip any other tiles)\";\r\n            return game;\r\n        }\r\n\r\n        // switch players\r\n        if (game.currentPlayer == BLACK) {\r\n            game.currentPlayer = WHITE;\r\n        } else {\r\n            game.currentPlayer = BLACK;\r\n        }\r\n        return game;\r\n    }\r\n\r\n    function getPossibleDirections (Game memory game, uint8 col, uint8 row) internal pure returns(int8[2][8] memory, uint8){\r\n\r\n        int8[2][8] memory possibleDirections;\r\n        uint8 possibleDirectionsLength = 0;\r\n        int8[2][8] memory dirs = [\r\n            [int8(-1), int8(0)], // W\r\n            [int8(-1), int8(1)], // SW\r\n            [int8(0), int8(1)], // S\r\n            [int8(1), int8(1)], // SE\r\n            [int8(1), int8(0)], // E\r\n            [int8(1), int8(-1)], // NE\r\n            [int8(0), int8(-1)], // N\r\n            [int8(-1), int8(-1)] // NW\r\n        ];\r\n        int8 focusedRowPos;\r\n        int8 focusedColPos;\r\n        int8[2] memory dir;\r\n        uint8 testSquare;\r\n\r\n        for (uint8 i = 0; i < 8; i++) {\r\n            dir = dirs[i];\r\n            focusedColPos = int8(col) + dir[0];\r\n            focusedRowPos = int8(row) + dir[1];\r\n\r\n            // if tile is off the board it is not a valid move\r\n            if (!(focusedRowPos > 7 || focusedRowPos < 0 || focusedColPos > 7 || focusedColPos < 0)) {\r\n                testSquare = returnTile(game.board, uint8(focusedColPos), uint8(focusedRowPos));\r\n\r\n                // if the surrounding tile is current color or no color it can\"t be part of a capture\r\n                if (testSquare != game.currentPlayer) {\r\n                    if (testSquare != EMPTY) {\r\n                        possibleDirections[possibleDirectionsLength] = dir;\r\n                        possibleDirectionsLength++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return (possibleDirections, possibleDirectionsLength);\r\n    }\r\n\r\n    function traverseDirection (Game memory game, int8[2] memory dir, uint8 col, uint8 row) internal pure returns(bytes28, uint8) {\r\n        bytes28 potentialFlips;\r\n        uint8 potentialFlipsLength = 0;\r\n        uint8 opponentColor;\r\n        if (game.currentPlayer == BLACK) {\r\n            opponentColor = WHITE;\r\n        } else {\r\n            opponentColor = BLACK;\r\n        }\r\n\r\n        // take one step at a time in this direction\r\n        // ignoring the first step look for the same color as your tile\r\n        bool skip = false;\r\n        int8 testCol;\r\n        int8 testRow;\r\n        uint8 tile;\r\n        for (uint8 j = 1; j < 9; j++) {\r\n            if (!skip) {\r\n                testCol = (int8(j) * dir[0]) + int8(col);\r\n                testRow = (int8(j) * dir[1]) + int8(row);\r\n                // ran off the board before hitting your own tile\r\n                if (testCol > 7 || testCol < 0 || testRow > 7 || testRow < 0) {\r\n                    delete potentialFlips;\r\n                    potentialFlipsLength = 0;\r\n                    skip = true;\r\n                } else{\r\n\r\n                    tile = returnTile(game.board, uint8(testCol), uint8(testRow));\r\n\r\n                    if (tile == opponentColor) {\r\n                        // if tile is opposite color it could be flipped, so add to potential flip array\r\n                        (potentialFlips, potentialFlipsLength) = addMove(potentialFlips, potentialFlipsLength, uint8(testCol), uint8(testRow));\r\n                    } else if (tile == game.currentPlayer && j > 1) {\r\n                        // hit current players tile which means capture is complete\r\n                        skip = true;\r\n                    } else {\r\n                        // either hit current players own color before hitting an opponent\"s\r\n                        // or hit an empty space\r\n                        delete potentialFlips;\r\n                        delete potentialFlipsLength;\r\n                        skip = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return (potentialFlips, potentialFlipsLength);\r\n    }\r\n\r\n    function isComplete (Game memory game) internal pure returns (Game memory) {\r\n        if (game.moveKey == 60) {\r\n            // game.msg = \"good game\";\r\n            game.complete = true;\r\n            return game;\r\n        } else {\r\n            uint8 i;\r\n            bool validMovesRemains = false;\r\n            bytes16 board = game.board;\r\n            for (i = 0; i < 64 && !validMovesRemains; i++) {\r\n                uint8[2] memory move = [((i - (i % 8)) / 8), (i % 8)];\r\n                uint8 tile = returnTile(game.board, move[0], move[1]);\r\n                if (tile == EMPTY) {\r\n                    game.currentPlayer = BLACK;\r\n                    game.error = false;\r\n                    game.board = board;\r\n                    game = makeMove(game, move[0], move[1]);\r\n                    if (!game.error) {\r\n                        validMovesRemains = true;\r\n                    }\r\n                    game.currentPlayer = WHITE;\r\n                    game.error = false;\r\n                    game.board = board;\r\n                    game = makeMove(game, move[0], move[1]);\r\n                    if (!game.error) {\r\n                        validMovesRemains = true;\r\n                    }\r\n                }\r\n            }\r\n            if (validMovesRemains) {\r\n                game.error = true;\r\n                // game.msg = \"Invalid Game (moves still available)\";\r\n            } else {\r\n                // game.msg = \"good game\";\r\n                game.complete = true;\r\n                game.error = false;\r\n            }\r\n        }\r\n        return game;\r\n    }\r\n\r\n    function isSymmetrical (Game memory game) internal pure returns (Game memory) {\r\n        bool RotSym = true;\r\n        bool Y0Sym = true;\r\n        bool X0Sym = true;\r\n        bool XYSym = true;\r\n        bool XnYSym = true;\r\n        for (uint8 i = 0; i < 8 && (RotSym || Y0Sym || X0Sym || XYSym || XnYSym); i++) {\r\n            for (uint8 j = 0; j < 8 && (RotSym || Y0Sym || X0Sym || XYSym || XnYSym); j++) {\r\n\r\n                // rotational symmetry\r\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, (7 - i), (7 - j))) {\r\n                    RotSym = false;\r\n                }\r\n                // symmetry on y = 0\r\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, i, (7 - j))) {\r\n                    Y0Sym = false;\r\n                }\r\n                // symmetry on x = 0\r\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, (7 - i), j)) {\r\n                    X0Sym = false;\r\n                }\r\n                // symmetry on x = y\r\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, (7 - j), (7 - i))) {\r\n                    XYSym = false;\r\n                }\r\n                // symmetry on x = -y\r\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, j, i)) {\r\n                    XnYSym = false;\r\n                }\r\n            }\r\n        }\r\n        if (RotSym || Y0Sym || X0Sym || XYSym || XnYSym) {\r\n            game.symmetrical = true;\r\n            game.RotSym = RotSym;\r\n            game.Y0Sym = Y0Sym;\r\n            game.X0Sym = X0Sym;\r\n            game.XYSym = XYSym;\r\n            game.XnYSym = XnYSym;\r\n        }\r\n        return game;\r\n    }\r\n\r\n\r\n\r\n    // Utilities\r\n\r\n    function returnSymmetricals (bool RotSym, bool Y0Sym, bool X0Sym, bool XYSym, bool XnYSym) public pure returns (uint256) {\r\n        uint256 symmetries = (RotSym ? 1  : 0) << 1;\r\n        symmetries = (symmetries & (Y0Sym ? 1 : 0)) << 1;\r\n        symmetries = (symmetries & (X0Sym ? 1 : 0)) << 1;\r\n        symmetries = (symmetries & (XYSym ? 1 : 0)) << 1;\r\n        symmetries = symmetries & (XnYSym ? 1 : 0);\r\n        return symmetries;\r\n    }\r\n\r\n\r\n    function returnBytes (bytes16 board, uint8 col, uint8 row) internal pure returns (bytes16) {\r\n        uint128 push = posToPush(col, row);\r\n        return (board >> push) & bytes16(uint128(3));\r\n    }\r\n\r\n    function turnTile (bytes16 board, uint8 color, uint8 col, uint8 row) internal pure returns (bytes16){\r\n        if (col > 7) revert();\r\n        if (row > 7) revert();\r\n        uint128 push = posToPush(col, row);\r\n        bytes16 mask = bytes16(uint128(3)) << push;// 0b00000011 (ones)\r\n\r\n        board = ((board ^ mask) & board);\r\n\r\n        return board | (bytes16(uint128(color)) << push);\r\n    }\r\n\r\n    function returnTile (bytes16 board, uint8 col, uint8 row) public pure returns (uint8){\r\n        uint128 push = posToPush(col, row);\r\n        bytes16 tile = (board >> push ) & bytes16(uint128(3));\r\n        return uint8(uint128(tile)); // returns 2\r\n    }\r\n\r\n    function posToPush (uint8 col, uint8 row) internal pure returns (uint128){\r\n        return uint128(((64) - ((8 * col) + row + 1)) * 2);\r\n    }\r\n\r\n    function readMove (bytes28 moveSequence, uint8 moveKey, uint8 movesLength) public pure returns(uint8) {\r\n        bytes28 mask = bytes28(uint224(127));\r\n        uint8 push = (movesLength * 7) - (moveKey * 7) - 7;\r\n        return uint8(uint224((moveSequence >> push) & mask));\r\n    }\r\n\r\n    function addMove (bytes28 moveSequence, uint8 movesLength, uint8 col, uint8 row) internal pure returns (bytes28, uint8) {\r\n        uint256 foo = col + (row * 8) + 64;\r\n        bytes28 move = bytes28(uint224(foo));\r\n        moveSequence = moveSequence << 7;\r\n        moveSequence = moveSequence | move;\r\n        movesLength++;\r\n        return (moveSequence, movesLength);\r\n    }\r\n\r\n    function validMove (uint8 move) internal pure returns(bool) {\r\n        return move >= 64;\r\n    }\r\n\r\n    function convertMove (uint8 move) public pure returns(uint8, uint8) {\r\n        move = move - 64;\r\n        uint8 col = move % 8;\r\n        uint8 row = (move - col) / 8;\r\n        return (col, row);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/v5/IClovers.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract IClovers {\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function setCloverMoves(uint256 _tokenId, bytes28[2] memory moves) public;\r\n    function getCloverMoves(uint256 _tokenId) public view returns (bytes28[2] memory);\r\n    function getAllSymmetries() public view returns (uint256, uint256, uint256, uint256, uint256, uint256);\r\n    function exists(uint256 _tokenId) public view returns (bool _exists);\r\n    function getBlockMinted(uint256 _tokenId) public view returns (uint256);\r\n    function setBlockMinted(uint256 _tokenId, uint256 value) public;\r\n    function setKeep(uint256 _tokenId, bool value) public;\r\n    function setSymmetries(uint256 _tokenId, uint256 _symmetries) public;\r\n    function setReward(uint256 _tokenId, uint256 _amount) public;\r\n    function mint (address _to, uint256 _tokenId) public;\r\n    function getReward(uint256 _tokenId) public view returns (uint256);\r\n    function getKeep(uint256 _tokenId) public view returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function moveEth(address _to, uint256 _amount) public;\r\n    function getSymmetries(uint256 _tokenId) public view returns (uint256);\r\n    function deleteClover(uint256 _tokenId) public;\r\n    function setAllSymmetries(uint256 _totalSymmetries, uint256 RotSym, uint256 Y0Sym, uint256 X0Sym, uint256 XYSym, uint256 XnYSym) public;\r\n}\r\n\r\n// File: contracts/v5/IClubToken.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract IClubToken {\r\n    function balanceOf(address _owner) public view returns (uint256);\r\n    function burn(address _burner, uint256 _value) public;\r\n    function mint(address _to, uint256 _amount) public returns (bool);\r\n}\r\n\r\n// File: contracts/v5/IClubTokenController.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract IClubTokenController {\r\n    function buy(address buyer) public payable returns(bool);\r\n}\r\n\r\n// File: contracts/v5/ISimpleCloversMarket.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\ncontract ISimpleCloversMarket {\r\n    function sell(uint256 _tokenId, uint256 price) public;\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/cryptography/ECDSA.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * (.note) This call _does not revert_ if the signature is invalid, or\r\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\r\n     * the zero address is returned.\r\n     *\r\n     * (.warning) `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise)\r\n     * be too long), and then calling `toEthSignedMessageHash` on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * [`eth_sign`](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign)\r\n     * JSON-RPC method.\r\n     *\r\n     * See `recover`.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n// File: contracts/v5/CloversController.sol\r\n\r\npragma solidity ^0.5.9;\r\n\r\n/**\r\n * The CloversController is a replaceable endpoint for minting and unminting Clovers.sol and ClubToken.sol\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract CloversController is Ownable {\r\n    event cloverCommitted(bytes32 movesHash, address owner);\r\n    event cloverClaimed(uint256 tokenId, bytes28[2] moves, address sender, address recepient, uint reward, uint256 symmetries, bool keep);\r\n    event cloverChallenged(uint256 tokenId, bytes28[2] moves, address owner, address challenger);\r\n\r\n    using SafeMath for uint256;\r\n    using ECDSA for bytes32;\r\n\r\n    bool public paused;\r\n    address public oracle;\r\n    IClovers public clovers;\r\n    IClubToken public clubToken;\r\n    IClubTokenController public clubTokenController;\r\n    ISimpleCloversMarket public simpleCloversMarket;\r\n    // Reversi public reversi;\r\n\r\n    uint256 public gasLastUpdated_fastGasPrice_averageGasPrice_safeLowGasPrice;\r\n    uint256 public gasBlockMargin = 240; // ~1 hour at 15 second blocks\r\n\r\n    uint256 public basePrice;\r\n    uint256 public priceMultiplier;\r\n    uint256 public payMultiplier;\r\n\r\n    mapping(bytes32=>address) public commits;\r\n\r\n    modifier notPaused() {\r\n        require(!paused, \"Must not be paused\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        IClovers _clovers,\r\n        IClubToken _clubToken,\r\n        IClubTokenController _clubTokenController\r\n        // Reversi _reversi\r\n    ) public {\r\n        clovers = _clovers;\r\n        clubToken = _clubToken;\r\n        clubTokenController = _clubTokenController;\r\n        // reversi = _reversi;\r\n        paused = true;\r\n    }\r\n\r\n    function getMovesHash(bytes28[2] memory moves) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(moves));\r\n    }\r\n\r\n    function getMovesHashWithRecepient(bytes32 movesHash, address recepient) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(movesHash, recepient));\r\n    }\r\n\r\n    /**\r\n    * @dev Checks whether the game is valid.\r\n    * @param moves The moves needed to play validate the game.\r\n    * @return A boolean representing whether or not the game is valid.\r\n    */\r\n    function isValid(bytes28[2] memory moves) public pure returns (bool) {\r\n        Reversi.Game memory game = Reversi.playGame(moves);\r\n        return isValidGame(game.error, game.complete);\r\n    }\r\n\r\n    /**\r\n    * @dev Checks whether the game is valid.\r\n    * @param error The pre-played game error\r\n    * @param complete The pre-played game complete boolean\r\n    * @return A boolean representing whether or not the game is valid.\r\n    */\r\n    function isValidGame(bool error, bool complete) public pure returns (bool) {\r\n        if (error || !complete) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function getGame (bytes28[2] memory moves) public pure returns (bool error, bool complete, bool symmetrical, bytes16 board, uint8 currentPlayer, uint8 moveKey) {\r\n        // return Reversi.getGame(moves);\r\n        Reversi.Game memory game = Reversi.playGame(moves);\r\n        return (\r\n            game.error,\r\n            game.complete,\r\n            game.symmetrical,\r\n            game.board,\r\n            game.currentPlayer,\r\n            game.moveKey\r\n            // game.msg\r\n        );\r\n    }\r\n    /**\r\n    * @dev Calculates the reward of the board.\r\n    * @param symmetries symmetries saved as a uint256 value like 00010101 where bits represent symmetry types.\r\n    * @return A uint256 representing the reward that would be returned for claiming the board.\r\n    */\r\n    function calculateReward(uint256 symmetries) public view returns (uint256) {\r\n        uint256 Symmetricals;\r\n        uint256 RotSym;\r\n        uint256 Y0Sym;\r\n        uint256 X0Sym;\r\n        uint256 XYSym;\r\n        uint256 XnYSym;\r\n        (Symmetricals,\r\n        RotSym,\r\n        Y0Sym,\r\n        X0Sym,\r\n        XYSym,\r\n        XnYSym) = clovers.getAllSymmetries();\r\n        uint256 base = 0;\r\n        if (symmetries >> 4 & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(RotSym + 1));\r\n        if (symmetries >> 3 & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(Y0Sym + 1));\r\n        if (symmetries >> 2 & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(X0Sym + 1));\r\n        if (symmetries >> 1 & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(XYSym + 1));\r\n        if (symmetries & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(XnYSym + 1));\r\n        return base;\r\n    }\r\n\r\n    function getPrice(uint256 symmetries) public view returns(uint256) {\r\n        return basePrice.add(calculateReward(symmetries));\r\n    }\r\n\r\n    // In order to prevent commit reveal griefing the first commit is a combined hash of the moves and the recepient.\r\n    // In order to use the same commit mapping, we mark this hash simply as address(1) so it is no longer the equivalent of address(0)\r\n    function claimCloverSecurelyPartOne(bytes32 movesHashWithRecepient) public {\r\n        commits[movesHashWithRecepient] = address(1);\r\n        commits[keccak256(abi.encodePacked(msg.sender))] = address(block.number);\r\n    }\r\n\r\n    // Once a commit has been made to guarantee the move hash is associated with the recepient we can make a commit on the hash of the moves themselves\r\n    // If we were to make a claim on the moves in plaintext, the transaction could be front run on the claimCloverWithVerification or the claimCloverWithSignature\r\n    function claimCloverSecurelyPartTwo(bytes32 movesHash) public {\r\n        require(uint256(commits[keccak256(abi.encodePacked(msg.sender))]) < block.number, \"Can't combine step1 with step2\");\r\n        bytes32 commitHash = getMovesHashWithRecepient(movesHash, msg.sender);\r\n        address commitOfMovesHashWithRecepient = commits[commitHash];\r\n        require(\r\n            address(commitOfMovesHashWithRecepient) == address(1),\r\n            \"Invalid commitOfMovesHashWithRecepient, please do claimCloverSecurelyPartOne\"\r\n        );\r\n        delete(commits[commitHash]);\r\n        commits[movesHash] = msg.sender;\r\n    }\r\n\r\n    function claimCloverWithVerification(bytes28[2] memory moves, bool keep) public payable returns (bool) {\r\n        bytes32 movesHash = getMovesHash(moves);\r\n        address committedRecepient = commits[movesHash];\r\n        require(committedRecepient == address(0) || committedRecepient == msg.sender, \"Invalid committedRecepient\");\r\n\r\n        Reversi.Game memory game = Reversi.playGame(moves);\r\n        require(isValidGame(game.error, game.complete), \"Invalid game\");\r\n        uint256 tokenId = convertBytes16ToUint(game.board);\r\n        require(!clovers.exists(tokenId), \"Clover already exists\");\r\n\r\n        uint256 symmetries = Reversi.returnSymmetricals(game.RotSym, game.Y0Sym, game.X0Sym, game.XYSym, game.XnYSym);\r\n        require(_claimClover(tokenId, moves, symmetries, msg.sender, keep), \"Claim must succeed\");\r\n        delete(commits[movesHash]);\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n    * @dev Claim the Clover without a commit or reveal. Payable so you can buy tokens if needed.\r\n    * @param tokenId The board that results from the moves.\r\n    * @param moves The moves that make up the Clover reversi game.\r\n    * @param symmetries symmetries saved as a uint256 value like 00010101 where bits represent symmetry\r\n    * @param keep symmetries saved as a uint256 value like 00010101 where bits represent symmetry\r\n    * @param signature symmetries saved as a uint256 value like 00010101 where bits represent symmetry\r\n    * types.\r\n    * @return A boolean representing whether or not the claim was successful.\r\n    */\r\n    function claimCloverWithSignature(uint256 tokenId, bytes28[2] memory moves, uint256 symmetries, bool keep, bytes memory signature) public payable notPaused returns (bool) {\r\n        address committedRecepient = commits[getMovesHash(moves)];\r\n        require(committedRecepient == address(0) || committedRecepient == msg.sender, \"Invalid committedRecepient\");\r\n        require(!clovers.exists(tokenId), \"Clover already exists\");\r\n        require(checkSignature(tokenId, moves, symmetries, keep, msg.sender, signature, oracle), \"Invalid Signature\");\r\n        require(_claimClover(tokenId, moves, symmetries, msg.sender, keep), \"Claim must succeed\");\r\n        return true;\r\n    }\r\n\r\n    function _claimClover(uint256 tokenId, bytes28[2] memory moves, uint256 symmetries, address recepient, bool keep) internal returns (bool) {\r\n        clovers.setCloverMoves(tokenId, moves);\r\n        clovers.setKeep(tokenId, keep);\r\n\r\n        uint256 reward;\r\n        if (symmetries > 0) {\r\n            clovers.setSymmetries(tokenId, symmetries);\r\n            reward = calculateReward(symmetries);\r\n            clovers.setReward(tokenId, reward);\r\n        }\r\n        uint256 price = basePrice.add(reward);\r\n        if (keep && price > 0) {\r\n            // If the user decides to keep the Clover, they must\r\n            // pay for it in club tokens according to the reward price.\r\n            if (clubToken.balanceOf(msg.sender) < price) {\r\n                clubTokenController.buy.value(msg.value)(msg.sender);\r\n            }\r\n            clubToken.burn(msg.sender, price);\r\n        }\r\n\r\n        if (keep) {\r\n            // If the user decided to keep the Clover\r\n            clovers.mint(recepient, tokenId);\r\n        } else {\r\n            // If the user decided not to keep the Clover, they will\r\n            // receive the reward price in club tokens, and the clover will\r\n            // go for sale by the contract.\r\n            clovers.mint(address(clovers), tokenId);\r\n            simpleCloversMarket.sell(tokenId, basePrice.add(reward.mul(priceMultiplier)));\r\n            if (reward > 0) {\r\n                require(clubToken.mint(recepient, reward), \"mint must succeed\");\r\n            }\r\n        }\r\n        emit cloverClaimed(tokenId, moves, msg.sender, recepient, reward, symmetries, keep);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Convert a bytes16 board into a uint256.\r\n    * @param _board The board being converted.\r\n    * @return number the uint256 being converted.\r\n    */\r\n    function convertBytes16ToUint(bytes16 _board) public pure returns(uint256 number) {\r\n        for(uint i=0;i<_board.length;i++){\r\n            number = number + uint(uint8(_board[i]))*(2**(8*(_board.length-(i+1))));\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Challenge a Clover for being invalid.\r\n    * @param tokenId The board being challenged.\r\n    * @return A boolean representing whether or not the challenge was successful.\r\n    */\r\n    function challengeClover(uint256 tokenId) public returns (bool) {\r\n        require(clovers.exists(tokenId), \"Clover must exist to be challenged\");\r\n        bool valid = true;\r\n        bytes28[2] memory moves = clovers.getCloverMoves(tokenId);\r\n        address payable _owner = address(uint160(owner()));\r\n        if (msg.sender != _owner && msg.sender != oracle) {\r\n            Reversi.Game memory game = Reversi.playGame(moves);\r\n            if(convertBytes16ToUint(game.board) != tokenId) {\r\n                valid = false;\r\n            }\r\n            if(valid && isValidGame(game.error, game.complete)) {\r\n                uint256 symmetries = clovers.getSymmetries(tokenId);\r\n                valid = (symmetries >> 4 & 1) > 0 == game.RotSym ? valid : false;\r\n                valid = (symmetries >> 3 & 1) > 0 == game.Y0Sym ? valid : false;\r\n                valid = (symmetries >> 2 & 1) > 0 == game.X0Sym ? valid : false;\r\n                valid = (symmetries >> 1 & 1) > 0 == game.XYSym ? valid : false;\r\n                valid = (symmetries & 1) > 0 == game.XnYSym ? valid : false;\r\n            } else {\r\n                valid = false;\r\n            }\r\n            require(!valid, \"Must be invalid to challenge\");\r\n        }\r\n\r\n        removeSymmetries(tokenId);\r\n        address committer = clovers.ownerOf(tokenId);\r\n        emit cloverChallenged(tokenId, moves, committer, msg.sender);\r\n        clovers.deleteClover(tokenId);\r\n        return true;\r\n    }\r\n\r\n    function updateSalePrice(uint256 tokenId, uint256 _price) public onlyOwner {\r\n        simpleCloversMarket.sell(tokenId, _price);\r\n    }\r\n\r\n    /**\r\n    * @dev Moves clovers without explicit allow permission for use by simpleCloversMarket\r\n    * in order to avoid double transaction (allow, transferFrom)\r\n    * @param _from The current owner of the Clover\r\n    * @param _to The future owner of the Clover\r\n    * @param tokenId The Clover\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 tokenId) public {\r\n        require(msg.sender == address(simpleCloversMarket), \"transferFrom can only be done by simpleCloversMarket\");\r\n        clovers.transferFrom(_from, _to, tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Updates pause boolean.\r\n    * @param _paused The new puased boolean.\r\n    */\r\n    function updatePaused(bool _paused) public onlyOwner {\r\n        paused = _paused;\r\n    }\r\n\r\n    /**\r\n    * @dev Updates oracle Address.\r\n    * @param _oracle The new oracle Address.\r\n    */\r\n    function updateOracle(address _oracle) public onlyOwner {\r\n        oracle = _oracle;\r\n    }\r\n\r\n    /**\r\n    * @dev Updates simpleCloversMarket Address.\r\n    * @param _simpleCloversMarket The new simpleCloversMarket address.\r\n    */\r\n    function updateSimpleCloversMarket(ISimpleCloversMarket _simpleCloversMarket) public onlyOwner {\r\n        simpleCloversMarket = _simpleCloversMarket;\r\n    }\r\n\r\n    /**\r\n    * @dev Updates clubTokenController Address.\r\n    * @param _clubTokenController The new clubTokenController address.\r\n    */\r\n    function updateClubTokenController(IClubTokenController _clubTokenController) public onlyOwner {\r\n        clubTokenController = _clubTokenController;\r\n    }\r\n    /**\r\n    * @dev Updates the pay multiplier, used to calculate token reward.\r\n    * @param _payMultiplier The uint256 value of pay multiplier.\r\n    */\r\n    function updatePayMultipier(uint256 _payMultiplier) public onlyOwner {\r\n        payMultiplier = _payMultiplier;\r\n    }\r\n    /**\r\n    * @dev Updates the price multiplier, used to calculate the clover price (multiplied by the original reward).\r\n    * @param _priceMultiplier The uint256 value of the price multiplier.\r\n    */\r\n    function updatePriceMultipier(uint256 _priceMultiplier) public onlyOwner {\r\n        priceMultiplier = _priceMultiplier;\r\n    }\r\n    /**\r\n    * @dev Updates the base price, used to calculate the clover cost.\r\n    * @param _basePrice The uint256 value of the base price.\r\n    */\r\n    function updateBasePrice(uint256 _basePrice) public onlyOwner {\r\n        basePrice = _basePrice;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds new tallys of the totals numbers of clover symmetries.\r\n    * @param tokenId The token which needs to be examined.\r\n    */\r\n    function addSymmetries(uint256 tokenId) private {\r\n        uint256 Symmetricals;\r\n        uint256 RotSym;\r\n        uint256 Y0Sym;\r\n        uint256 X0Sym;\r\n        uint256 XYSym;\r\n        uint256 XnYSym;\r\n        (Symmetricals,\r\n        RotSym,\r\n        Y0Sym,\r\n        X0Sym,\r\n        XYSym,\r\n        XnYSym) = clovers.getAllSymmetries();\r\n        uint256 symmetries = clovers.getSymmetries(tokenId);\r\n        Symmetricals = Symmetricals.add(symmetries > 0 ? 1 : 0);\r\n        RotSym = RotSym.add(uint256(symmetries >> 4 & 1));\r\n        Y0Sym = Y0Sym.add(uint256(symmetries >> 3 & 1));\r\n        X0Sym = X0Sym.add(uint256(symmetries >> 2 & 1));\r\n        XYSym = XYSym.add(uint256(symmetries >> 1 & 1));\r\n        XnYSym = XnYSym.add(uint256(symmetries & 1));\r\n        clovers.setAllSymmetries(Symmetricals, RotSym, Y0Sym, X0Sym, XYSym, XnYSym);\r\n    }\r\n    /**\r\n    * @dev Remove false tallys of the totals numbers of clover symmetries.\r\n    * @param tokenId The token which needs to be examined.\r\n    */\r\n    function removeSymmetries(uint256 tokenId) private {\r\n        uint256 Symmetricals;\r\n        uint256 RotSym;\r\n        uint256 Y0Sym;\r\n        uint256 X0Sym;\r\n        uint256 XYSym;\r\n        uint256 XnYSym;\r\n        (Symmetricals,\r\n        RotSym,\r\n        Y0Sym,\r\n        X0Sym,\r\n        XYSym,\r\n        XnYSym) = clovers.getAllSymmetries();\r\n        uint256 symmetries = clovers.getSymmetries(tokenId);\r\n        Symmetricals = Symmetricals.sub(symmetries > 0 ? 1 : 0);\r\n        RotSym = RotSym.sub(uint256(symmetries >> 4 & 1));\r\n        Y0Sym = Y0Sym.sub(uint256(symmetries >> 3 & 1));\r\n        X0Sym = X0Sym.sub(uint256(symmetries >> 2 & 1));\r\n        XYSym = XYSym.sub(uint256(symmetries >> 1 & 1));\r\n        XnYSym = XnYSym.sub(uint256(symmetries & 1));\r\n        clovers.setAllSymmetries(Symmetricals, RotSym, Y0Sym, X0Sym, XYSym, XnYSym);\r\n    }\r\n\r\n    function checkSignature(\r\n        uint256 tokenId,\r\n        bytes28[2] memory moves,\r\n        uint256 symmetries,\r\n        bool keep,\r\n        address recepient,\r\n        bytes memory signature,\r\n        address signer\r\n    ) public pure returns (bool) {\r\n        bytes32 hash = toEthSignedMessageHash(getHash(tokenId, moves, symmetries, keep, recepient));\r\n        address result = recover(hash, signature);\r\n        return (result != address(0) && result == signer);\r\n    }\r\n\r\n    function getHash(uint256 tokenId, bytes28[2] memory moves, uint256 symmetries, bool keep, address recepient) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(tokenId, moves, symmetries, keep, recepient));\r\n    }\r\n    function recover(bytes32 hash, bytes memory signature) public pure returns (address) {\r\n        return hash.recover(signature);\r\n    }\r\n    function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) {\r\n        return hash.toEthSignedMessageHash();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"updatePaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"moves\",\"type\":\"bytes28[2]\"}],\"name\":\"getGame\",\"outputs\":[{\"name\":\"error\",\"type\":\"bool\"},{\"name\":\"complete\",\"type\":\"bool\"},{\"name\":\"symmetrical\",\"type\":\"bool\"},{\"name\":\"board\",\"type\":\"bytes16\"},{\"name\":\"currentPlayer\",\"type\":\"uint8\"},{\"name\":\"moveKey\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"clovers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"recover\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"moves\",\"type\":\"bytes28[2]\"},{\"name\":\"keep\",\"type\":\"bool\"}],\"name\":\"claimCloverWithVerification\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"updateOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"moves\",\"type\":\"bytes28[2]\"}],\"name\":\"getMovesHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"error\",\"type\":\"bool\"},{\"name\":\"complete\",\"type\":\"bool\"}],\"name\":\"isValidGame\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"moves\",\"type\":\"bytes28[2]\"}],\"name\":\"isValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commits\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"updateSalePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"moves\",\"type\":\"bytes28[2]\"},{\"name\":\"symmetries\",\"type\":\"uint256\"},{\"name\":\"keep\",\"type\":\"bool\"},{\"name\":\"recepient\",\"type\":\"address\"}],\"name\":\"getHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"movesHashWithRecepient\",\"type\":\"bytes32\"}],\"name\":\"claimCloverSecurelyPartOne\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"moves\",\"type\":\"bytes28[2]\"},{\"name\":\"symmetries\",\"type\":\"uint256\"},{\"name\":\"keep\",\"type\":\"bool\"},{\"name\":\"recepient\",\"type\":\"address\"},{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"checkSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"challengeClover\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasLastUpdated_fastGasPrice_averageGasPrice_safeLowGasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payMultiplier\",\"type\":\"uint256\"}],\"name\":\"updatePayMultipier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"toEthSignedMessageHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_clubTokenController\",\"type\":\"address\"}],\"name\":\"updateClubTokenController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"simpleCloversMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"moves\",\"type\":\"bytes28[2]\"},{\"name\":\"symmetries\",\"type\":\"uint256\"},{\"name\":\"keep\",\"type\":\"bool\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"claimCloverWithSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasBlockMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_board\",\"type\":\"bytes16\"}],\"name\":\"convertBytes16ToUint\",\"outputs\":[{\"name\":\"number\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_priceMultiplier\",\"type\":\"uint256\"}],\"name\":\"updatePriceMultipier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"clubTokenController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"movesHash\",\"type\":\"bytes32\"}],\"name\":\"claimCloverSecurelyPartTwo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"basePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_simpleCloversMarket\",\"type\":\"address\"}],\"name\":\"updateSimpleCloversMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"symmetries\",\"type\":\"uint256\"}],\"name\":\"calculateReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"clubToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"symmetries\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"movesHash\",\"type\":\"bytes32\"},{\"name\":\"recepient\",\"type\":\"address\"}],\"name\":\"getMovesHashWithRecepient\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_basePrice\",\"type\":\"uint256\"}],\"name\":\"updateBasePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_clovers\",\"type\":\"address\"},{\"name\":\"_clubToken\",\"type\":\"address\"},{\"name\":\"_clubTokenController\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"movesHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"cloverCommitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"moves\",\"type\":\"bytes28[2]\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"recepient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"symmetries\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keep\",\"type\":\"bool\"}],\"name\":\"cloverClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"moves\",\"type\":\"bytes28[2]\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"challenger\",\"type\":\"address\"}],\"name\":\"cloverChallenged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CloversController","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000b55c5cac5014c662fdbf21a2c59cd45403c482fd0000000000000000000000001a94656a6245379bc0d9c64c402197528edb2bd10000000000000000000000001754a612ca578f72d678196bcc16710f01db7655","Library":"Reversi:f640b022ab52a003466daaefb5e87bbee7ac1bdf","LicenseType":"None","SwarmSource":"bzzr://8a05769ec8c5039515ff4c31ce170a7d913c4a25c1d559c5a7b7f1da48ed8ba0"}]}