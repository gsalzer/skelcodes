{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.0 <0.6.0;\r\n\r\n/* taking ideas from FirstBlood token */\r\ncontract SafeMath {\r\n\r\n    /* function assert(bool assertion) internal { */\r\n    /*   if (!assertion) { */\r\n    /*     throw; */\r\n    /*   } */\r\n    /* }      // assert no longer needed once solidity is on 0.4.10 */\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal pure  returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal pure  returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }\r\n\r\n}\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) public view  returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/*  ERC 20 token */\r\ncontract StandardToken is Token {\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract ERC1132 {\r\n    /**\r\n     * @dev Reasons why a user's tokens have been locked\r\n     */\r\n    mapping(address => string[]) public lockReason;\r\n\r\n    /**\r\n     * @dev locked token structure\r\n     */\r\n    struct lockToken {\r\n        uint256 amount;\r\n        uint256 validity;\r\n        bool claimed;\r\n    }\r\n\r\n    /**\r\n     * @dev Holds number & validity of tokens locked for a given reason for\r\n     *      a specified address\r\n     */\r\n    mapping(address => mapping(string => lockToken)) public locked;\r\n\r\n    /**\r\n     * @dev Records data of all the tokens Locked\r\n     */\r\n    event Locked(\r\n        address indexed _of,\r\n        string indexed _reason,\r\n        uint256 _amount,\r\n        uint256 _validity\r\n    );\r\n\r\n    /**\r\n     * @dev Records data of all the tokens unlocked\r\n     */\r\n    event Unlocked(\r\n        address indexed _of,\r\n        string indexed _reason,\r\n        uint256 _amount\r\n    );\r\n\r\n    /**\r\n     * @dev Locks a specified amount of tokens against an address,\r\n     *      for a specified reason and time\r\n     * @param _reason The reason to lock tokens\r\n     * @param _amount Number of tokens to be locked\r\n     * @param _time Lock time in seconds\r\n     */\r\n    function lock(string memory _reason, uint256 _amount, uint256 _time)\r\n        public returns (bool);\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason\r\n     *\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     */\r\n    function tokensLocked(address _of, string memory _reason)\r\n        public view returns (uint256 amount);\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason at a specific time\r\n     *\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     * @param _time The timestamp to query the lock tokens for\r\n     */\r\n    function tokensLockedAtTime(address _of, string memory _reason, uint256 _time)\r\n        public view returns (uint256 amount);\r\n    /**\r\n     * @dev Returns total tokens held by an address (locked + transferable)\r\n     * @param _of The address to query the total balance of\r\n     */\r\n    function totalBalanceOf(address _of)\r\n        public view returns (uint256 amount);\r\n    /**\r\n     * @dev Extends lock for a specified reason and time\r\n     * @param _reason The reason to lock tokens\r\n     * @param _time Lock extension time in seconds\r\n     */\r\n    function extendLock(string memory _reason, uint256 _time)\r\n        public returns (bool);\r\n    /**\r\n     * @dev Increase number of tokens locked for a specified reason\r\n     * @param _reason The reason to lock tokens\r\n     * @param _amount Number of tokens to be increased\r\n     */\r\n    function increaseLockAmount(string memory _reason, uint256 _amount)\r\n        public returns (bool);\r\n\r\n    /**\r\n     * @dev Returns unlockable tokens for a specified address for a specified reason\r\n     * @param _of The address to query the the unlockable token count of\r\n     * @param _reason The reason to query the unlockable tokens for\r\n     */\r\n    function tokensUnlockable(address _of, string memory _reason)\r\n        public view returns (uint256 amount);\r\n    /**\r\n     * @dev Unlocks the unlockable tokens of a specified address\r\n     * @param _of Address of user, claiming back unlockable tokens\r\n     */\r\n    function unlock(address _of)\r\n        public returns (uint256 unlockableTokens);\r\n\r\n    /**\r\n     * @dev Gets the unlockable tokens of a specified address\r\n     * @param _of The address to query the the unlockable token count of\r\n     */\r\n    function getUnlockableTokens(address _of)\r\n        public view returns (uint256 unlockableTokens);\r\n\r\n}\r\n\r\ncontract Lockable is ERC1132,StandardToken {\r\n\r\n    string internal constant ALREADY_LOCKED = 'Tokens already locked';\r\n    string internal constant NOT_LOCKED = 'No tokens locked';\r\n    string internal constant AMOUNT_ZERO = 'Amount can not be 0';\r\n    /**\r\n     * @dev Locks a specified amount of tokens against an address,\r\n     *      for a specified reason and time\r\n     * @param _reason The reason to lock tokens\r\n     * @param _amount Number of tokens to be locked\r\n     * @param _time Lock time in days\r\n     */\r\n    function lock(string memory _reason, uint256 _amount, uint256 _time)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 validUntil = now + (_time * 1 days); //solhint-disable-line\r\n\r\n        // If tokens are already locked, then functions extendLock or\r\n        // increaseLockAmount should be used to make any changes\r\n        require(tokensLocked(msg.sender, _reason) == 0, ALREADY_LOCKED);\r\n        require(_amount != 0, AMOUNT_ZERO);\r\n\r\n        if (locked[msg.sender][_reason].amount == 0)\r\n            lockReason[msg.sender].push(_reason);\r\n\r\n        transfer(address(this), _amount);\r\n\r\n        locked[msg.sender][_reason] = lockToken(_amount, validUntil, false);\r\n\r\n        emit Locked(msg.sender, _reason, _amount, validUntil);\r\n        return true;\r\n    }\r\n    /**\r\n     * @dev Transfers and Locks a specified amount of tokens,\r\n     *      for a specified reason and time\r\n     * @param _to adress to which tokens are to be transfered\r\n     * @param _reason The reason to lock tokens\r\n     * @param _amount Number of tokens to be transfered and locked\r\n     * @param _time Lock time in seconds\r\n     */\r\n    function transferWithLock(address _to, string memory _reason, uint256 _amount, uint256 _time)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 validUntil = now + (_time * 1 days); //solhint-disable-line\r\n\r\n        require(tokensLocked(_to, _reason) == 0, ALREADY_LOCKED);\r\n        require(_amount != 0, AMOUNT_ZERO);\r\n\r\n        if (locked[_to][_reason].amount == 0)\r\n            lockReason[_to].push(_reason);\r\n\r\n        transfer(address(this), _amount);\r\n\r\n        locked[_to][_reason] = lockToken(_amount, validUntil, false);\r\n        emit Locked(_to, _reason, _amount, validUntil);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason\r\n     *\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     */\r\n    function tokensLocked(address _of, string memory _reason)\r\n        public\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        if (!locked[_of][_reason].claimed)\r\n            amount = locked[_of][_reason].amount;\r\n    }\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason at a specific time\r\n     *\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     * @param _time The timestamp to query the lock tokens for\r\n     */\r\n    function tokensLockedAtTime(address _of, string memory _reason, uint256 _time)\r\n        public\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        if (locked[_of][_reason].validity > _time)\r\n            amount = locked[_of][_reason].amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns total tokens held by an address (locked + transferable)\r\n     * @param _of The address to query the total balance of\r\n     */\r\n    function totalBalanceOf(address _of)\r\n        public\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        amount = balanceOf(_of);\r\n\r\n        for (uint256 i = 0; i < lockReason[_of].length; i++) {\r\n            amount = amount + (tokensLocked(_of, lockReason[_of][i]));\r\n        }\r\n    }\r\n    /**\r\n     * @dev Extends lock for a specified reason and time\r\n     * @param _reason The reason to lock tokens\r\n     * @param _time Lock extension time in seconds\r\n     */\r\n    function extendLock(string memory _reason, uint256 _time)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(tokensLocked(msg.sender, _reason) > 0, NOT_LOCKED);\r\n\r\n        locked[msg.sender][_reason].validity = locked[msg.sender][_reason].validity + (_time);\r\n\r\n        emit Locked(msg.sender, _reason, locked[msg.sender][_reason].amount, locked[msg.sender][_reason].validity);\r\n        return true;\r\n    }\r\n    /**\r\n     * @dev Increase number of tokens locked for a specified reason\r\n     * @param _reason The reason to lock tokens\r\n     * @param _amount Number of tokens to be increased\r\n     */\r\n    function increaseLockAmount(string memory _reason, uint256 _amount)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(tokensLocked(msg.sender, _reason) > 0, NOT_LOCKED);\r\n        transfer(address(this), _amount);\r\n\r\n        locked[msg.sender][_reason].amount = locked[msg.sender][_reason].amount + (_amount);\r\n\r\n        emit Locked(msg.sender, _reason, locked[msg.sender][_reason].amount, locked[msg.sender][_reason].validity);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns unlockable tokens for a specified address for a specified reason\r\n     * @param _of The address to query the the unlockable token count of\r\n     * @param _reason The reason to query the unlockable tokens for\r\n     */\r\n    function tokensUnlockable(address _of, string memory _reason)\r\n        public\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) //solhint-disable-line\r\n            amount = locked[_of][_reason].amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Unlocks the unlockable tokens of a specified address\r\n     * @param _of Address of user, claiming back unlockable tokens\r\n     */\r\n    function unlock(address _of)\r\n        public\r\n        returns (uint256 unlockableTokens)\r\n    {\r\n        uint256 lockedTokens;\r\n\r\n        for (uint256 i = 0; i < lockReason[_of].length; i++) {\r\n            lockedTokens = tokensUnlockable(_of, lockReason[_of][i]);\r\n            if (lockedTokens > 0) {\r\n                unlockableTokens = unlockableTokens + (lockedTokens);\r\n                locked[_of][lockReason[_of][i]].claimed = true;\r\n                emit Unlocked(_of, lockReason[_of][i], lockedTokens);\r\n            }\r\n        }\r\n\r\n        if (unlockableTokens > 0)\r\n            this.transfer(_of, unlockableTokens);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the unlockable tokens of a specified address\r\n     * @param _of The address to query the the unlockable token count of\r\n     */\r\n    function getUnlockableTokens(address _of)\r\n        public\r\n        view\r\n        returns (uint256 unlockableTokens)\r\n    {\r\n        for (uint256 i = 0; i < lockReason[_of].length; i++) {\r\n            unlockableTokens = unlockableTokens + (tokensUnlockable(_of, lockReason[_of][i]));\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract AGToken is Lockable, SafeMath {\r\n\r\n    // metadata\r\n    string public constant name = \"Agri10x Token\";\r\n    string public constant symbol = \"AG10\";\r\n    uint256 public constant decimals = 18;\r\n    string public version = \"1.0\";\r\n    string internal constant PUBLIC_LOCKED = 'Public sale of token is locked';\r\n    address owner;\r\n    // contracts\r\n    address payable ethFundDeposit;      // deposit address for ETH for Agri10x International\r\n    address payable agtFundDeposit;      // deposit address for Agri10x International use and AGT User Fund\r\n\r\n    // crowdsale parameters\r\n    bool public isFinalized;              // switched to true in operational state\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n    uint256 public constant agtFund = 45 * (10**6) * 10**decimals;   // 500m AGT reserved for Agri10x Intl use\r\n    uint256 public constant tokenExchangeRate = 1995; // 6400 AGT tokens per 1 ETH\r\n    uint256 public constant tokenCreationCap =  200 * (10**6) * 10**decimals;\r\n    uint256 public constant tokenCreationMin = 1 * (10**6) * 10**decimals;\r\n    uint256 public publicSaleDate;\r\n\r\n\r\n    // events\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n    event CreateAGT(address indexed _to, uint256 _value);\r\n    event SoldAGT(address indexed _to, uint256 _value);\r\n\r\n    modifier onlyOwner {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only owner can call this function.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // constructor\r\n    constructor(\r\n        address payable _ethFundDeposit,\r\n        address payable _agtFundDeposit,\r\n        uint256 _fundingStartBlock,\r\n        uint256 _fundingEndBlock) public\r\n    {\r\n      owner = msg.sender;\r\n      publicSaleDate = now + (120 * 1 days);\r\n      isFinalized = false;                   //controls pre through crowdsale state\r\n      ethFundDeposit = _ethFundDeposit;\r\n      agtFundDeposit = _agtFundDeposit;\r\n      fundingStartBlock = _fundingStartBlock;\r\n      fundingEndBlock = _fundingEndBlock;\r\n      totalSupply = agtFund;\r\n      balances[agtFundDeposit] = agtFund;    // Deposit Agri10x Intl share\r\n      emit CreateAGT(agtFundDeposit, agtFund);  // logs Agri10x Intl fund\r\n    }\r\n\r\n    /// @dev Accepts ether and creates new AGT tokens.\r\n    function customRatecreateTokens(uint256 customtokenExchangeRate) external payable  onlyOwner{\r\n      if (isFinalized) revert();\r\n      if (block.number < fundingStartBlock) revert();\r\n      if (block.number > fundingEndBlock) revert();\r\n      if (msg.value == 0) revert();\r\n\r\n      uint256 tokens = safeMult(msg.value, customtokenExchangeRate); // check that we're not over totals\r\n      uint256 checkedSupply = safeAdd(totalSupply, tokens);\r\n\r\n      // return money if something goes wrong\r\n      if (tokenCreationCap < checkedSupply) revert();  // odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n      emit CreateAGT(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n    function createTokens() external payable  onlyOwner{\r\n      if (isFinalized) revert();\r\n      if (block.number < fundingStartBlock) revert();\r\n      if (block.number > fundingEndBlock) revert();\r\n      if (msg.value == 0) revert();\r\n\r\n      uint256 tokens = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\r\n      uint256 checkedSupply = safeAdd(totalSupply, tokens);\r\n\r\n      // return money if something goes wrong\r\n      if (tokenCreationCap < checkedSupply) revert();  // odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n      emit CreateAGT(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n    function publicSale() external payable {\r\n      require(publicSaleDate < now, PUBLIC_LOCKED);\r\n      if (msg.value == 0) revert();\r\n      uint256 tokens = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\r\n      uint256 checkedSupply = safeAdd(totalSupply, tokens);\r\n\r\n      // return money if something goes wrong\r\n      if (tokenCreationCap < checkedSupply) revert();  // odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n      emit SoldAGT(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n    function changeSaleDate(uint256 _time) external onlyOwner{\r\n        publicSaleDate = now + (_time * 1 days);\r\n    }\r\n\r\n    function createFreeTokens(uint256 numberOfTokens) external payable  onlyOwner{\r\n      uint256 tokens = safeMult(1, numberOfTokens); // check that we're not over totals\r\n      uint256 checkedSupply = safeAdd(totalSupply, tokens);\r\n\r\n      // return money if something goes wrong\r\n      if (tokenCreationCap < checkedSupply) revert();  // odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\r\n      emit CreateAGT(msg.sender, tokens);  // logs token creation\r\n    }\r\n\r\n    /// @dev Ends the funding period and sends the ETH home\r\n    function finalize() external onlyOwner{\r\n      if (isFinalized) revert();\r\n      if (msg.sender != ethFundDeposit) revert(); // locks finalize to the ultimate ETH owner\r\n      if(totalSupply < tokenCreationMin) revert();      // have to sell minimum to move to operational\r\n      if(block.number <= fundingEndBlock && totalSupply != tokenCreationCap) revert();\r\n      // move to operational\r\n      isFinalized = true;\r\n      if(!ethFundDeposit.send(address(this).balance)) revert();  // send the eth to Agri10x International\r\n    }\r\n\r\n    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\r\n    function refund() external onlyOwner{\r\n      if(isFinalized) revert();                       // prevents refund if operational\r\n      if (block.number <= fundingEndBlock) revert(); // prevents refund until sale period is over\r\n      if(totalSupply >= tokenCreationMin) revert();  // no refunds if we sold enough\r\n      if(msg.sender == agtFundDeposit) revert();    // Agri10x Intl not entitled to a refund\r\n      uint256 agtVal = balances[msg.sender];\r\n      if (agtVal == 0) revert();\r\n      balances[msg.sender] = 0;\r\n      totalSupply = safeSubtract(totalSupply, agtVal); // extra safe\r\n      uint256 ethVal = agtVal / tokenExchangeRate;     // should be safe; previous throws covers edges\r\n      emit LogRefund(msg.sender, ethVal);               // log it\r\n      if (!msg.sender.send(ethVal)) revert();       // if you're using a contract; make sure it works with .send gas limits\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"createFreeTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"tokensUnlockable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_reason\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increaseLockAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"changeSaleDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"unlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unlockableTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"publicSale\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"totalBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validity\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockReason\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_reason\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"tokensLockedAtTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"getUnlockableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unlockableTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_reason\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"transferWithLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"customtokenExchangeRate\",\"type\":\"uint256\"}],\"name\":\"customRatecreateTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"agtFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_reason\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"extendLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"tokensLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_reason\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicSaleDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_ethFundDeposit\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_agtFundDeposit\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fundingStartBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fundingEndBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"CreateAGT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"SoldAGT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"_reason\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_validity\",\"type\":\"uint256\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"_reason\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Unlocked\",\"type\":\"event\"}]","ContractName":"AGToken","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000c32c34a91e782be1fe3908110015b7bff81461f1000000000000000000000000ff9461810de4bd809ab1e20b16c31fbede33510b000000000000000000000000000000000000000000000000000000000084ab2f0000000000000000000000000000000000000000000000000de0b6b3a763ffff","Library":"","LicenseType":"None","SwarmSource":"bzzr://23ce22b7c4e901d53faac2f9db2b7ae1c0e0951c35a581c114e8ff2cb4171f5e"}]}