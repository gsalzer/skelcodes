{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.9;\r\ncontract sproof {\r\n    event lockHashEvent(address indexed from, bytes32 indexed hash);\r\n    \r\n    address payable owner;\r\n\r\n\r\n    mapping(address => bool) sproofAccounts;\r\n\r\n    uint  costToLockHash = 0;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function addSproofAccount(address _addr) public{\r\n        require(msg.sender == owner);\r\n        sproofAccounts[_addr] = true;\r\n    }\r\n    \r\n      function updateOwner(address payable newOwner) public{\r\n        require(msg.sender == owner);\r\n        owner = newOwner;\r\n    }\r\n    \r\n     function removeSproofAccount(address _addr) public{\r\n        require(msg.sender == owner);\r\n        sproofAccounts[_addr] = false;\r\n    }\r\n\r\n\r\n    function setCost (uint newCostToLockHash) public {\r\n        require (msg.sender == owner);\r\n        costToLockHash = newCostToLockHash;\r\n    }\r\n    \r\n   function getCost() public view returns(uint)  {\r\n        return costToLockHash;\r\n    }\r\n\r\n    function lockHash(bytes32 hash) public payable{\r\n        if(sproofAccounts[msg.sender] != true)\r\n            require(msg.value >= costToLockHash);\r\n        emit lockHashEvent(msg.sender, hash);\r\n    }\r\n    \r\n    \r\n    function lockHashProxy(address _addr, bytes32 hash, uint8 v, bytes32 r, bytes32 s) public payable {\r\n        require(ecrecover(hash, v, r, s) == _addr);\r\n        if (sproofAccounts[msg.sender] != true)\r\n            require(msg.value >= costToLockHash);\r\n        emit lockHashEvent(_addr, hash);\r\n    }\r\n \r\n    function lockHashesProxy(address [] memory _addresses, bytes32 [] memory hashes, uint8[] memory vs, bytes32 [] memory rs, bytes32 [] memory ss) public payable {\r\n\r\n        if (sproofAccounts[msg.sender] != true)\r\n            require(msg.value >= _addresses.length*costToLockHash);\r\n\r\n        for (uint i=0; i < _addresses.length; i++) {\r\n            require(ecrecover(hashes[i], vs[i], rs[i], ss[i]) == _addresses[i]);\r\n            emit lockHashEvent(_addresses[i], hashes[i]);\r\n        }\r\n    }\r\n\r\n    function payout() public{\r\n        require (msg.sender == owner);\r\n        owner.transfer(address(this).balance);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"lockHashProxy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCostToLockHash\",\"type\":\"uint256\"}],\"name\":\"setCost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addSproofAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"lockHash\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"updateOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeSproofAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8[]\",\"name\":\"vs\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"rs\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"ss\",\"type\":\"bytes32[]\"}],\"name\":\"lockHashesProxy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"lockHashEvent\",\"type\":\"event\"}]","ContractName":"sproof","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv2","SwarmSource":"bzzr://89f4ae56f1150e394bb813b57d8593c363e0206e41732c2f029db66467b12b98"}]}