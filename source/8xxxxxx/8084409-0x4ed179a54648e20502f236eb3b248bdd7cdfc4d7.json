{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-02-14\r\n*/\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n/// @title Ownable\r\n/// @author Applicature\r\n/// @notice helper mixed to other contracts to link contract on an owner\r\n/// @dev Base class\r\ncontract Ownable {\r\n    //Variables\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    //    Modifiers\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0));\r\n        newOwner = _newOwner;\r\n\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n/// @title OpenZeppelinERC20\r\n/// @author Applicature\r\n/// @notice Open Zeppelin implementation of standart ERC20\r\n/// @dev Base class\r\ncontract OpenZeppelinERC20 is StandardToken, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint8 public decimals;\r\n    string public name;\r\n    string public symbol;\r\n    string public standard;\r\n\r\n    constructor(\r\n        uint256 _totalSupply,\r\n        string _tokenName,\r\n        uint8 _decimals,\r\n        string _tokenSymbol,\r\n        bool _transferAllSupplyToOwner\r\n    ) public {\r\n        standard = 'ERC20 0.1';\r\n        totalSupply_ = _totalSupply;\r\n\r\n        if (_transferAllSupplyToOwner) {\r\n            balances[msg.sender] = _totalSupply;\r\n        } else {\r\n            balances[this] = _totalSupply;\r\n        }\r\n\r\n        name = _tokenName;\r\n        // Set the name for display purposes\r\n        symbol = _tokenSymbol;\r\n        // Set the symbol for display purposes\r\n        decimals = _decimals;\r\n    }\r\n\r\n}\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   */\r\n  function burn(uint256 _value) public {\r\n    _burn(msg.sender, _value);\r\n  }\r\n\r\n  function _burn(address _who, uint256 _value) internal {\r\n    require(_value <= balances[_who]);\r\n    // no need to require value <= totalSupply, since that would imply the\r\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n    balances[_who] = balances[_who].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    emit Burn(_who, _value);\r\n    emit Transfer(_who, address(0), _value);\r\n  }\r\n}\r\n/// @title MintableToken\r\n/// @author Applicature\r\n/// @notice allow to mint tokens\r\n/// @dev Base class\r\ncontract MintableToken is BasicToken, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public maxSupply;\r\n    bool public allowedMinting;\r\n    mapping(address => bool) public mintingAgents;\r\n    mapping(address => bool) public stateChangeAgents;\r\n\r\n    event Mint(address indexed holder, uint256 tokens);\r\n\r\n    modifier onlyMintingAgents () {\r\n        require(mintingAgents[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyStateChangeAgents () {\r\n        require(stateChangeAgents[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    constructor(uint256 _maxSupply, uint256 _mintedSupply, bool _allowedMinting) public {\r\n        maxSupply = _maxSupply;\r\n        totalSupply_ = totalSupply_.add(_mintedSupply);\r\n        allowedMinting = _allowedMinting;\r\n        mintingAgents[msg.sender] = true;\r\n    }\r\n\r\n    /// @notice allow to mint tokens\r\n    function mint(address _holder, uint256 _tokens) public onlyMintingAgents() {\r\n        require(allowedMinting == true && totalSupply_.add(_tokens) <= maxSupply);\r\n\r\n        totalSupply_ = totalSupply_.add(_tokens);\r\n\r\n        balances[_holder] = balanceOf(_holder).add(_tokens);\r\n\r\n        if (totalSupply_ == maxSupply) {\r\n            allowedMinting = false;\r\n        }\r\n        emit Transfer(address(0), _holder, _tokens);\r\n        emit Mint(_holder, _tokens);\r\n    }\r\n\r\n    /// @notice update allowedMinting flat\r\n    function disableMinting() public onlyStateChangeAgents() {\r\n        allowedMinting = false;\r\n    }\r\n\r\n    /// @notice update minting agent\r\n    function updateMintingAgent(address _agent, bool _status) public onlyOwner {\r\n        mintingAgents[_agent] = _status;\r\n    }\r\n\r\n    /// @notice update state change agent\r\n    function updateStateChangeAgent(address _agent, bool _status) public onlyOwner {\r\n        stateChangeAgents[_agent] = _status;\r\n    }\r\n\r\n    /// @return available tokens\r\n    function availableTokens() public view returns (uint256 tokens) {\r\n        return maxSupply.sub(totalSupply_);\r\n    }\r\n}\r\n/// @title MintableBurnableToken\r\n/// @author Applicature\r\n/// @notice helper mixed to other contracts to burn tokens\r\n/// @dev implementation\r\ncontract MintableBurnableToken is MintableToken, BurnableToken {\r\n\r\n    mapping (address => bool) public burnAgents;\r\n\r\n    modifier onlyBurnAgents () {\r\n        require(burnAgents[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    constructor(\r\n        uint256 _maxSupply,\r\n        uint256 _mintedSupply,\r\n        bool _allowedMinting\r\n    ) public MintableToken(\r\n        _maxSupply,\r\n        _mintedSupply,\r\n        _allowedMinting\r\n    ) {\r\n\r\n    }\r\n\r\n    /// @notice update minting agent\r\n    function updateBurnAgent(address _agent, bool _status) public onlyOwner {\r\n        burnAgents[_agent] = _status;\r\n    }\r\n\r\n    function burnByAgent(address _holder, uint256 _tokensToBurn) public onlyBurnAgents() returns (uint256) {\r\n        if (_tokensToBurn == 0) {\r\n            _tokensToBurn = balanceOf(_holder);\r\n        }\r\n        _burn(_holder, _tokensToBurn);\r\n\r\n        return _tokensToBurn;\r\n    }\r\n\r\n    function _burn(address _who, uint256 _value) internal {\r\n        require(_value <= balances[_who]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        balances[_who] = balances[_who].sub(_value);\r\n        totalSupply_ = totalSupply_.sub(_value);\r\n        maxSupply = maxSupply.sub(_value);\r\n        emit Burn(_who, _value);\r\n        emit Transfer(_who, address(0), _value);\r\n    }\r\n}\r\n/// @title TimeLocked\r\n/// @author Applicature\r\n/// @notice helper mixed to other contracts to lock contract on a timestamp\r\n/// @dev Base class\r\ncontract TimeLocked {\r\n    uint256 public time;\r\n    mapping(address => bool) public excludedAddresses;\r\n\r\n    modifier isTimeLocked(address _holder, bool _timeLocked) {\r\n        bool locked = (block.timestamp < time);\r\n        require(excludedAddresses[_holder] == true || locked == _timeLocked);\r\n        _;\r\n    }\r\n\r\n    constructor(uint256 _time) public {\r\n        time = _time;\r\n    }\r\n\r\n    function updateExcludedAddress(address _address, bool _status) public;\r\n}\r\n/// @title TimeLockedToken\r\n/// @author Applicature\r\n/// @notice helper mixed to other contracts to lock contract on a timestamp\r\n/// @dev Base class\r\ncontract TimeLockedToken is TimeLocked, StandardToken {\r\n\r\n    constructor(uint256 _time) public TimeLocked(_time) {}\r\n\r\n    function transfer(address _to, uint256 _tokens) public isTimeLocked(msg.sender, false) returns (bool) {\r\n        return super.transfer(_to, _tokens);\r\n    }\r\n\r\n    function transferFrom(\r\n        address _holder,\r\n        address _to,\r\n        uint256 _tokens\r\n    ) public isTimeLocked(_holder, false) returns (bool) {\r\n        return super.transferFrom(_holder, _to, _tokens);\r\n    }\r\n}\r\ncontract CHLToken is OpenZeppelinERC20, MintableBurnableToken, TimeLockedToken {\r\n\r\n    CHLCrowdsale public crowdsale;\r\n\r\n    bool public isSoftCapAchieved;\r\n\r\n    //_unlockTokensTime - Lockup 0 months after end of the ICO\r\n    constructor(uint256 _unlockTokensTime) public\r\n    OpenZeppelinERC20(0, 'Shopereum', 8, 'SHM', false)\r\n    MintableBurnableToken(59500000e18, 0, true)\r\n    TimeLockedToken(_unlockTokensTime) {\r\n\r\n    }\r\n\r\n    function updateMaxSupply(uint256 _newMaxSupply) public onlyOwner {\r\n        require(_newMaxSupply > 0);\r\n        maxSupply = _newMaxSupply;\r\n    }\r\n\r\n    function updateExcludedAddress(address _address, bool _status) public onlyOwner {\r\n        excludedAddresses[_address] = _status;\r\n    }\r\n\r\n    function setCrowdSale(address _crowdsale) public onlyOwner {\r\n        require(_crowdsale != address(0));\r\n        crowdsale = CHLCrowdsale(_crowdsale);\r\n    }\r\n\r\n    function setUnlockTime(uint256 _unlockTokensTime) public onlyStateChangeAgents {\r\n        time = _unlockTokensTime;\r\n    }\r\n\r\n    function setIsSoftCapAchieved() public onlyStateChangeAgents {\r\n        isSoftCapAchieved = true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _tokens) public returns (bool) {\r\n        require(true == isTransferAllowed(msg.sender, _tokens));\r\n        return super.transfer(_to, _tokens);\r\n    }\r\n\r\n    function transferFrom(address _holder, address _to, uint256 _tokens) public returns (bool) {\r\n        require(true == isTransferAllowed(_holder, _tokens));\r\n        return super.transferFrom(_holder, _to, _tokens);\r\n    }\r\n\r\n    function isTransferAllowed(address _address, uint256 _value) public view returns (bool) {\r\n        if (excludedAddresses[_address] == true) {\r\n            return true;\r\n        }\r\n\r\n        if (!isSoftCapAchieved && (address(crowdsale) == address(0) || false == crowdsale.isSoftCapAchieved(0))) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function burnUnsoldTokens(uint256 _tokensToBurn) public onlyBurnAgents() returns (uint256) {\r\n        require(totalSupply_.add(_tokensToBurn) <= maxSupply);\r\n\r\n        maxSupply = maxSupply.sub(_tokensToBurn);\r\n\r\n        emit Burn(address(0), _tokensToBurn);\r\n\r\n        return _tokensToBurn;\r\n    }\r\n\r\n}\r\n/// @title Agent\r\n/// @author Applicature\r\n/// @notice Contract which takes actions on state change and contribution\r\n/// @dev Base class\r\ncontract Agent {\r\n    using SafeMath for uint256;\r\n\r\n    function isInitialized() public constant returns (bool) {\r\n        return false;\r\n    }\r\n}\r\n/// @title CrowdsaleAgent\r\n/// @author Applicature\r\n/// @notice Contract which takes actions on state change and contribution\r\n/// @dev Base class\r\ncontract CrowdsaleAgent is Agent {\r\n\r\n\r\n    Crowdsale public crowdsale;\r\n    bool public _isInitialized;\r\n\r\n    modifier onlyCrowdsale() {\r\n        require(msg.sender == address(crowdsale));\r\n        _;\r\n    }\r\n\r\n    constructor(Crowdsale _crowdsale) public {\r\n        crowdsale = _crowdsale;\r\n\r\n        if (address(0) != address(_crowdsale)) {\r\n            _isInitialized = true;\r\n        } else {\r\n            _isInitialized = false;\r\n        }\r\n    }\r\n\r\n    function isInitialized() public constant returns (bool) {\r\n        return _isInitialized;\r\n    }\r\n\r\n    function onContribution(address _contributor, uint256 _weiAmount, uint256 _tokens, uint256 _bonus)\r\n        public onlyCrowdsale();\r\n\r\n    function onStateChange(Crowdsale.State _state) public onlyCrowdsale();\r\n\r\n    function onRefund(address _contributor, uint256 _tokens) public onlyCrowdsale() returns (uint256 burned);\r\n}\r\n/// @title MintableCrowdsaleOnSuccessAgent\r\n/// @author Applicature\r\n/// @notice Contract which takes actions on state change and contribution\r\n/// un-pause tokens and disable minting on Crowdsale success\r\n/// @dev implementation\r\ncontract MintableCrowdsaleOnSuccessAgent is CrowdsaleAgent {\r\n\r\n    Crowdsale public crowdsale;\r\n    MintableToken public token;\r\n    bool public _isInitialized;\r\n\r\n    constructor(Crowdsale _crowdsale, MintableToken _token) public CrowdsaleAgent(_crowdsale) {\r\n        crowdsale = _crowdsale;\r\n        token = _token;\r\n\r\n        if (address(0) != address(_token) &&\r\n        address(0) != address(_crowdsale)) {\r\n            _isInitialized = true;\r\n        } else {\r\n            _isInitialized = false;\r\n        }\r\n    }\r\n\r\n    /// @notice Check whether contract is initialised\r\n    /// @return true if initialized\r\n    function isInitialized() public constant returns (bool) {\r\n        return _isInitialized;\r\n    }\r\n\r\n    /// @notice Takes actions on contribution\r\n    function onContribution(address _contributor, uint256 _weiAmount, uint256 _tokens, uint256 _bonus)\r\n    public onlyCrowdsale() {\r\n        _contributor = _contributor;\r\n        _weiAmount = _weiAmount;\r\n        _tokens = _tokens;\r\n        _bonus = _bonus;\r\n        // TODO: add impl\r\n    }\r\n\r\n    /// @notice Takes actions on state change,\r\n    /// un-pause tokens and disable minting on Crowdsale success\r\n    /// @param _state Crowdsale.State\r\n    function onStateChange(Crowdsale.State _state) public onlyCrowdsale() {\r\n        if (_state == Crowdsale.State.Success) {\r\n            token.disableMinting();\r\n        }\r\n    }\r\n\r\n    function onRefund(address _contributor, uint256 _tokens) public onlyCrowdsale() returns (uint256 burned) {\r\n        _contributor = _contributor;\r\n        _tokens = _tokens;\r\n    }\r\n}\r\ncontract CHLAgent is MintableCrowdsaleOnSuccessAgent, Ownable {\r\n\r\n    CHLPricingStrategy public strategy;\r\n    CHLCrowdsale public crowdsale;\r\n    CHLAllocation public allocation;\r\n\r\n    bool public isEndProcessed;\r\n\r\n    constructor(\r\n        CHLCrowdsale _crowdsale,\r\n        CHLToken _token,\r\n        CHLPricingStrategy _strategy,\r\n        CHLAllocation _allocation\r\n    ) public MintableCrowdsaleOnSuccessAgent(_crowdsale, _token) {\r\n        strategy = _strategy;\r\n        crowdsale = _crowdsale;\r\n        allocation = _allocation;\r\n    }\r\n\r\n    /// @notice update pricing strategy\r\n    function setPricingStrategy(CHLPricingStrategy _strategy) public onlyOwner {\r\n        strategy = _strategy;\r\n    }\r\n\r\n    /// @notice update allocation\r\n    function setAllocation(CHLAllocation _allocation) public onlyOwner {\r\n        allocation = _allocation;\r\n    }\r\n\r\n    function burnUnsoldTokens(uint256 _tierId) public onlyOwner {\r\n        uint256 tierUnsoldTokensAmount = strategy.getTierUnsoldTokens(_tierId);\r\n        require(tierUnsoldTokensAmount > 0);\r\n\r\n        CHLToken(token).burnUnsoldTokens(tierUnsoldTokensAmount);\r\n    }\r\n\r\n    /// @notice Takes actions on contribution\r\n    function onContribution(\r\n        address,\r\n        uint256 _tierId,\r\n        uint256 _tokens,\r\n        uint256 _bonus\r\n    ) public onlyCrowdsale() {\r\n        strategy.updateTierTokens(_tierId, _tokens, _bonus);\r\n    }\r\n\r\n    function onStateChange(Crowdsale.State _state) public onlyCrowdsale() {\r\n        CHLToken chlToken = CHLToken(token);\r\n        if (\r\n            chlToken.isSoftCapAchieved() == false\r\n            && (_state == Crowdsale.State.Success || _state == Crowdsale.State.Finalized)\r\n            && crowdsale.isSoftCapAchieved(0)\r\n        ) {\r\n            chlToken.setIsSoftCapAchieved();\r\n        }\r\n\r\n        if (_state > Crowdsale.State.InCrowdsale && isEndProcessed == false) {\r\n            allocation.allocateFoundersTokens(strategy.getSaleEndDate());\r\n        }\r\n    }\r\n\r\n    function onRefund(address _contributor, uint256 _tokens) public onlyCrowdsale() returns (uint256 burned) {\r\n        burned = CHLToken(token).burnByAgent(_contributor, _tokens);\r\n    }\r\n\r\n    function updateStateWithPrivateSale(\r\n        uint256 _tierId,\r\n        uint256 _tokensAmount,\r\n        uint256 _usdAmount\r\n    ) public {\r\n        require(msg.sender == address(allocation));\r\n\r\n        strategy.updateMaxTokensCollected(_tierId, _tokensAmount);\r\n        crowdsale.updateStatsVars(_usdAmount, _tokensAmount);\r\n    }\r\n\r\n    function updateLockPeriod(uint256 _time) public {\r\n        require(msg.sender == address(strategy));\r\n        CHLToken(token).setUnlockTime(_time.add(12 weeks));\r\n    }\r\n\r\n}\r\n/// @title TokenAllocator\r\n/// @author Applicature\r\n/// @notice Contract responsible for defining distribution logic of tokens.\r\n/// @dev Base class\r\ncontract TokenAllocator is Ownable {\r\n\r\n\r\n    mapping(address => bool) public crowdsales;\r\n\r\n    modifier onlyCrowdsale() {\r\n        require(crowdsales[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function addCrowdsales(address _address) public onlyOwner {\r\n        crowdsales[_address] = true;\r\n    }\r\n\r\n    function removeCrowdsales(address _address) public onlyOwner {\r\n        crowdsales[_address] = false;\r\n    }\r\n\r\n    function isInitialized() public constant returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    function allocate(address _holder, uint256 _tokens) public onlyCrowdsale() {\r\n        internalAllocate(_holder, _tokens);\r\n    }\r\n\r\n    function tokensAvailable() public constant returns (uint256);\r\n\r\n    function internalAllocate(address _holder, uint256 _tokens) internal onlyCrowdsale();\r\n}\r\n/// @title MintableTokenAllocator\r\n/// @author Applicature\r\n/// @notice Contract responsible for defining distribution logic of tokens.\r\n/// @dev implementation\r\ncontract MintableTokenAllocator is TokenAllocator {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    MintableToken public token;\r\n\r\n    constructor(MintableToken _token) public {\r\n        require(address(0) != address(_token));\r\n        token = _token;\r\n    }\r\n\r\n    /// @return available tokens\r\n    function tokensAvailable() public constant returns (uint256) {\r\n        return token.availableTokens();\r\n    }\r\n\r\n    /// @notice transfer tokens on holder account\r\n    function allocate(address _holder, uint256 _tokens) public onlyCrowdsale() {\r\n        internalAllocate(_holder, _tokens);\r\n    }\r\n\r\n    /// @notice Check whether contract is initialised\r\n    /// @return true if initialized\r\n    function isInitialized() public constant returns (bool) {\r\n        return token.mintingAgents(this);\r\n    }\r\n\r\n    /// @notice update instance of MintableToken\r\n    function setToken(MintableToken _token) public onlyOwner {\r\n        token = _token;\r\n    }\r\n\r\n    function internalAllocate(address _holder, uint256 _tokens) internal {\r\n        token.mint(_holder, _tokens);\r\n    }\r\n\r\n}\r\n/// @title ContributionForwarder\r\n/// @author Applicature\r\n/// @notice Contract is responsible for distributing collected ethers, that are received from CrowdSale.\r\n/// @dev Base class\r\ncontract ContributionForwarder {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public weiCollected;\r\n    uint256 public weiForwarded;\r\n\r\n    event ContributionForwarded(address receiver, uint256 weiAmount);\r\n\r\n    function isInitialized() public constant returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    /// @notice transfer wei to receiver\r\n    function forward() public payable {\r\n        require(msg.value > 0);\r\n\r\n        weiCollected += msg.value;\r\n\r\n        internalForward();\r\n    }\r\n\r\n    function internalForward() internal;\r\n}\r\n/// @title DistributedDirectContributionForwarder\r\n/// @author Applicature\r\n/// @notice Contract is responsible for distributing collected ethers, that are received from CrowdSale.\r\n/// @dev implementation\r\ncontract DistributedDirectContributionForwarder is ContributionForwarder {\r\n    Receiver[] public receivers;\r\n    uint256 public proportionAbsMax;\r\n    bool public isInitialized_;\r\n\r\n    struct Receiver {\r\n        address receiver;\r\n        uint256 proportion; // abslolute value in range of 0 - proportionAbsMax\r\n        uint256 forwardedWei;\r\n    }\r\n\r\n    // @TODO: should we use uint256 [] for receivers & proportions?\r\n    constructor(uint256 _proportionAbsMax, address[] _receivers, uint256[] _proportions) public {\r\n        proportionAbsMax = _proportionAbsMax;\r\n\r\n        require(_receivers.length == _proportions.length);\r\n\r\n        require(_receivers.length > 0);\r\n\r\n        uint256 totalProportion;\r\n\r\n        for (uint256 i = 0; i < _receivers.length; i++) {\r\n            uint256 proportion = _proportions[i];\r\n\r\n            totalProportion = totalProportion.add(proportion);\r\n\r\n            receivers.push(Receiver(_receivers[i], proportion, 0));\r\n        }\r\n\r\n        require(totalProportion == proportionAbsMax);\r\n        isInitialized_ = true;\r\n    }\r\n\r\n    /// @notice Check whether contract is initialised\r\n    /// @return true if initialized\r\n    function isInitialized() public constant returns (bool) {\r\n        return isInitialized_;\r\n    }\r\n\r\n    function internalForward() internal {\r\n        uint256 transferred;\r\n\r\n        for (uint256 i = 0; i < receivers.length; i++) {\r\n            Receiver storage receiver = receivers[i];\r\n\r\n            uint256 value = msg.value.mul(receiver.proportion).div(proportionAbsMax);\r\n\r\n            if (i == receivers.length - 1) {\r\n                value = msg.value.sub(transferred);\r\n            }\r\n\r\n            transferred = transferred.add(value);\r\n\r\n            receiver.receiver.transfer(value);\r\n\r\n            emit ContributionForwarded(receiver.receiver, value);\r\n        }\r\n\r\n        weiForwarded = weiForwarded.add(transferred);\r\n    }\r\n}\r\ncontract Crowdsale {\r\n\r\n    uint256 public tokensSold;\r\n\r\n    enum State {Unknown, Initializing, BeforeCrowdsale, InCrowdsale, Success, Finalized, Refunding}\r\n\r\n    function externalContribution(address _contributor, uint256 _wei) public payable;\r\n\r\n    function contribute(uint8 _v, bytes32 _r, bytes32 _s) public payable;\r\n\r\n    function updateState() public;\r\n\r\n    function internalContribution(address _contributor, uint256 _wei) internal;\r\n\r\n    function getState() public view returns (State);\r\n\r\n}\r\n/// @title Crowdsale\r\n/// @author Applicature\r\n/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\r\ncontract CrowdsaleImpl is Crowdsale, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    State public currentState;\r\n    TokenAllocator public allocator;\r\n    ContributionForwarder public contributionForwarder;\r\n    PricingStrategy public pricingStrategy;\r\n    CrowdsaleAgent public crowdsaleAgent;\r\n    bool public finalized;\r\n    uint256 public startDate;\r\n    uint256 public endDate;\r\n    bool public allowWhitelisted;\r\n    bool public allowSigned;\r\n    bool public allowAnonymous;\r\n    mapping(address => bool) public whitelisted;\r\n    mapping(address => bool) public signers;\r\n    mapping(address => bool) public externalContributionAgents;\r\n\r\n    event Contribution(address _contributor, uint256 _wei, uint256 _tokensExcludingBonus, uint256 _bonus);\r\n\r\n    constructor(\r\n        TokenAllocator _allocator,\r\n        ContributionForwarder _contributionForwarder,\r\n        PricingStrategy _pricingStrategy,\r\n        uint256 _startDate,\r\n        uint256 _endDate,\r\n        bool _allowWhitelisted,\r\n        bool _allowSigned,\r\n        bool _allowAnonymous\r\n    ) public {\r\n        allocator = _allocator;\r\n        contributionForwarder = _contributionForwarder;\r\n        pricingStrategy = _pricingStrategy;\r\n\r\n        startDate = _startDate;\r\n        endDate = _endDate;\r\n\r\n        allowWhitelisted = _allowWhitelisted;\r\n        allowSigned = _allowSigned;\r\n        allowAnonymous = _allowAnonymous;\r\n\r\n        currentState = State.Unknown;\r\n    }\r\n\r\n    /// @notice default payable function\r\n    function() public payable {\r\n        require(allowWhitelisted || allowAnonymous);\r\n\r\n        if (!allowAnonymous) {\r\n            if (allowWhitelisted) {\r\n                require(whitelisted[msg.sender]);\r\n            }\r\n        }\r\n\r\n        internalContribution(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @notice update crowdsale agent\r\n    function setCrowdsaleAgent(CrowdsaleAgent _crowdsaleAgent) public onlyOwner {\r\n        crowdsaleAgent = _crowdsaleAgent;\r\n    }\r\n\r\n    /// @notice allows external user to do contribution\r\n    function externalContribution(address _contributor, uint256 _wei) public payable {\r\n        require(externalContributionAgents[msg.sender]);\r\n        internalContribution(_contributor, _wei);\r\n    }\r\n\r\n    /// @notice update external contributor\r\n    function addExternalContributor(address _contributor) public onlyOwner {\r\n        externalContributionAgents[_contributor] = true;\r\n    }\r\n\r\n    /// @notice update external contributor\r\n    function removeExternalContributor(address _contributor) public onlyOwner {\r\n        externalContributionAgents[_contributor] = false;\r\n    }\r\n\r\n    /// @notice update whitelisting address\r\n    function updateWhitelist(address _address, bool _status) public onlyOwner {\r\n        whitelisted[_address] = _status;\r\n    }\r\n\r\n    /// @notice update signer\r\n    function addSigner(address _signer) public onlyOwner {\r\n        signers[_signer] = true;\r\n    }\r\n\r\n    /// @notice update signer\r\n    function removeSigner(address _signer) public onlyOwner {\r\n        signers[_signer] = false;\r\n    }\r\n\r\n    /// @notice allows to do signed contributions\r\n    function contribute(uint8 _v, bytes32 _r, bytes32 _s) public payable {\r\n        address recoveredAddress = verify(msg.sender, _v, _r, _s);\r\n        require(signers[recoveredAddress]);\r\n        internalContribution(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @notice Crowdsale state\r\n    function updateState() public {\r\n        State state = getState();\r\n\r\n        if (currentState != state) {\r\n            if (crowdsaleAgent != address(0)) {\r\n                crowdsaleAgent.onStateChange(state);\r\n            }\r\n\r\n            currentState = state;\r\n        }\r\n    }\r\n\r\n    function internalContribution(address _contributor, uint256 _wei) internal {\r\n        require(getState() == State.InCrowdsale);\r\n\r\n        uint256 tokensAvailable = allocator.tokensAvailable();\r\n        uint256 collectedWei = contributionForwarder.weiCollected();\r\n\r\n        uint256 tokens;\r\n        uint256 tokensExcludingBonus;\r\n        uint256 bonus;\r\n\r\n        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\r\n            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\r\n\r\n        require(tokens > 0 && tokens <= tokensAvailable);\r\n        tokensSold = tokensSold.add(tokens);\r\n\r\n        allocator.allocate(_contributor, tokens);\r\n\r\n        if (msg.value > 0) {\r\n            contributionForwarder.forward.value(msg.value)();\r\n        }\r\n\r\n        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\r\n    }\r\n\r\n    /// @notice check sign\r\n    function verify(address _sender, uint8 _v, bytes32 _r, bytes32 _s) public view returns (address) {\r\n        bytes32 hash = keccak256(abi.encodePacked(this, _sender));\r\n\r\n        bytes memory prefix = '\\x19Ethereum Signed Message:\\n32';\r\n\r\n        return ecrecover(keccak256(abi.encodePacked(prefix, hash)), _v, _r, _s);\r\n    }\r\n\r\n    /// @return Crowdsale state\r\n    function getState() public view returns (State) {\r\n        if (finalized) {\r\n            return State.Finalized;\r\n        } else if (allocator.isInitialized() == false) {\r\n            return State.Initializing;\r\n        } else if (contributionForwarder.isInitialized() == false) {\r\n            return State.Initializing;\r\n        } else if (pricingStrategy.isInitialized() == false) {\r\n            return State.Initializing;\r\n        } else if (block.timestamp < startDate) {\r\n            return State.BeforeCrowdsale;\r\n        } else if (block.timestamp >= startDate && block.timestamp <= endDate) {\r\n            return State.InCrowdsale;\r\n        } else if (block.timestamp > endDate) {\r\n            return State.Success;\r\n        }\r\n\r\n        return State.Unknown;\r\n    }\r\n}\r\n/// @title HardCappedCrowdsale\r\n/// @author Applicature\r\n/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\r\n/// with hard limit\r\ncontract HardCappedCrowdsale is CrowdsaleImpl {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public hardCap;\r\n\r\n    constructor(\r\n        TokenAllocator _allocator,\r\n        ContributionForwarder _contributionForwarder,\r\n        PricingStrategy _pricingStrategy,\r\n        uint256 _startDate,\r\n        uint256 _endDate,\r\n        bool _allowWhitelisted,\r\n        bool _allowSigned,\r\n        bool _allowAnonymous,\r\n        uint256 _hardCap\r\n    ) public CrowdsaleImpl(\r\n        _allocator,\r\n        _contributionForwarder,\r\n        _pricingStrategy,\r\n        _startDate,\r\n        _endDate,\r\n        _allowWhitelisted,\r\n        _allowSigned,\r\n        _allowAnonymous\r\n    ) {\r\n        hardCap = _hardCap;\r\n    }\r\n\r\n    /// @return Crowdsale state\r\n    function getState() public view returns (State) {\r\n        State state = super.getState();\r\n\r\n        if (state == State.InCrowdsale) {\r\n            if (isHardCapAchieved(0)) {\r\n                return State.Success;\r\n            }\r\n        }\r\n\r\n        return state;\r\n    }\r\n\r\n    function isHardCapAchieved(uint256 _value) public view returns (bool) {\r\n        if (hardCap <= tokensSold.add(_value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function internalContribution(address _contributor, uint256 _wei) internal {\r\n        require(getState() == State.InCrowdsale);\r\n\r\n        uint256 tokensAvailable = allocator.tokensAvailable();\r\n        uint256 collectedWei = contributionForwarder.weiCollected();\r\n\r\n        uint256 tokens;\r\n        uint256 tokensExcludingBonus;\r\n        uint256 bonus;\r\n\r\n        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\r\n            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\r\n\r\n        require(tokens <= tokensAvailable && tokens > 0 && false == isHardCapAchieved(tokens.sub(1)));\r\n\r\n        tokensSold = tokensSold.add(tokens);\r\n\r\n        allocator.allocate(_contributor, tokens);\r\n\r\n        if (msg.value > 0) {\r\n            contributionForwarder.forward.value(msg.value)();\r\n        }\r\n        crowdsaleAgent.onContribution(_contributor, _wei, tokensExcludingBonus, bonus);\r\n        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\r\n    }\r\n}\r\n/// @title RefundableCrowdsale\r\n/// @author Applicature\r\n/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\r\n/// with hard and soft limits\r\ncontract RefundableCrowdsale is HardCappedCrowdsale {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public softCap;\r\n    mapping(address => uint256) public contributorsWei;\r\n    address[] public contributors;\r\n\r\n    event Refund(address _holder, uint256 _wei, uint256 _tokens);\r\n\r\n    constructor(\r\n        TokenAllocator _allocator,\r\n        ContributionForwarder _contributionForwarder,\r\n        PricingStrategy _pricingStrategy,\r\n        uint256 _startDate,\r\n        uint256 _endDate,\r\n        bool _allowWhitelisted,\r\n        bool _allowSigned,\r\n        bool _allowAnonymous,\r\n        uint256 _softCap,\r\n        uint256 _hardCap\r\n\r\n    ) public HardCappedCrowdsale(\r\n        _allocator, _contributionForwarder, _pricingStrategy,\r\n        _startDate, _endDate,\r\n        _allowWhitelisted, _allowSigned, _allowAnonymous, _hardCap\r\n    ) {\r\n        softCap = _softCap;\r\n    }\r\n\r\n    /// @notice refund ethers to contributor\r\n    function refund() public {\r\n        internalRefund(msg.sender);\r\n    }\r\n\r\n    /// @notice refund ethers to delegate\r\n    function delegatedRefund(address _address) public {\r\n        internalRefund(_address);\r\n    }\r\n\r\n    function internalContribution(address _contributor, uint256 _wei) internal {\r\n        require(block.timestamp >= startDate && block.timestamp <= endDate);\r\n\r\n        uint256 tokensAvailable = allocator.tokensAvailable();\r\n        uint256 collectedWei = contributionForwarder.weiCollected();\r\n\r\n        uint256 tokens;\r\n        uint256 tokensExcludingBonus;\r\n        uint256 bonus;\r\n\r\n        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\r\n            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\r\n\r\n        require(tokens <= tokensAvailable && tokens > 0 && hardCap > tokensSold.add(tokens));\r\n\r\n        tokensSold = tokensSold.add(tokens);\r\n\r\n        allocator.allocate(_contributor, tokens);\r\n\r\n        // transfer only if softcap is reached\r\n        if (isSoftCapAchieved(0)) {\r\n            if (msg.value > 0) {\r\n                contributionForwarder.forward.value(address(this).balance)();\r\n            }\r\n        } else {\r\n            // store contributor if it is not stored before\r\n            if (contributorsWei[_contributor] == 0) {\r\n                contributors.push(_contributor);\r\n            }\r\n            contributorsWei[_contributor] = contributorsWei[_contributor].add(msg.value);\r\n        }\r\n        crowdsaleAgent.onContribution(_contributor, _wei, tokensExcludingBonus, bonus);\r\n        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\r\n    }\r\n\r\n    function internalRefund(address _holder) internal {\r\n        updateState();\r\n        require(block.timestamp > endDate);\r\n        require(!isSoftCapAchieved(0));\r\n        require(crowdsaleAgent != address(0));\r\n\r\n        uint256 value = contributorsWei[_holder];\r\n\r\n        require(value > 0);\r\n\r\n        contributorsWei[_holder] = 0;\r\n        uint256 burnedTokens = crowdsaleAgent.onRefund(_holder, 0);\r\n\r\n        _holder.transfer(value);\r\n\r\n        emit Refund(_holder, value, burnedTokens);\r\n    }\r\n\r\n    /// @return Crowdsale state\r\n    function getState() public view returns (State) {\r\n        State state = super.getState();\r\n\r\n        if (state == State.Success) {\r\n            if (!isSoftCapAchieved(0)) {\r\n                return State.Refunding;\r\n            }\r\n        }\r\n\r\n        return state;\r\n    }\r\n\r\n    function isSoftCapAchieved(uint256 _value) public view returns (bool) {\r\n        if (softCap <= tokensSold.add(_value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\ncontract CHLCrowdsale is RefundableCrowdsale {\r\n\r\n    uint256 public maxSaleSupply = 38972500e18;\r\n\r\n    uint256 public usdCollected;\r\n\r\n    address public processingFeeAddress;\r\n    uint256 public percentageAbsMax = 1000;\r\n    uint256 public processingFeePercentage = 25;\r\n\r\n    event ProcessingFeeAllocation(address _contributor, uint256 _feeAmount);\r\n\r\n    event Contribution(address _contributor, uint256 _usdAmount, uint256 _tokensExcludingBonus, uint256 _bonus);\r\n\r\n    constructor(\r\n        MintableTokenAllocator _allocator,\r\n        DistributedDirectContributionForwarder _contributionForwarder,\r\n        CHLPricingStrategy _pricingStrategy,\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        address _processingFeeAddress\r\n    ) public RefundableCrowdsale(\r\n        _allocator,\r\n        _contributionForwarder,\r\n        _pricingStrategy,\r\n        _startTime,\r\n        _endTime,\r\n        true,\r\n        true,\r\n        false,\r\n        10000000e5,//softCap\r\n        102860625e5//hardCap\r\n    ) {\r\n        require(_processingFeeAddress != address(0));\r\n        processingFeeAddress = _processingFeeAddress;\r\n    }\r\n\r\n    function() public payable {\r\n        require(allowWhitelisted || allowAnonymous);\r\n\r\n        if (!allowAnonymous) {\r\n            if (allowWhitelisted) {\r\n                require(whitelisted[msg.sender]);\r\n            }\r\n        }\r\n\r\n        internalContribution(\r\n            msg.sender,\r\n            CHLPricingStrategy(pricingStrategy).getUSDAmountByWeis(msg.value)\r\n        );\r\n    }\r\n\r\n    /// @notice allows to do signed contributions\r\n    function contribute(uint8 _v, bytes32 _r, bytes32 _s) public payable {\r\n        address recoveredAddress = verify(msg.sender, _v, _r, _s);\r\n        require(signers[recoveredAddress]);\r\n        internalContribution(\r\n            msg.sender,\r\n            CHLPricingStrategy(pricingStrategy).getUSDAmountByWeis(msg.value)\r\n        );\r\n    }\r\n\r\n    /// @notice allows external user to do contribution\r\n    function externalContribution(address _contributor, uint256 _usdAmount) public payable {\r\n        require(externalContributionAgents[msg.sender]);\r\n        internalContribution(_contributor, _usdAmount);\r\n    }\r\n\r\n    function updateState() public {\r\n        (startDate, endDate) = CHLPricingStrategy(pricingStrategy).getActualDates();\r\n        super.updateState();\r\n    }\r\n\r\n    function isHardCapAchieved(uint256 _value) public view returns (bool) {\r\n        if (hardCap <= usdCollected.add(_value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function isSoftCapAchieved(uint256 _value) public view returns (bool) {\r\n        if (softCap <= usdCollected.add(_value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getUnsoldTokensAmount() public view returns (uint256) {\r\n        return maxSaleSupply.sub(tokensSold);\r\n    }\r\n\r\n    function updateStatsVars(uint256 _usdAmount, uint256 _tokensAmount) public {\r\n        require(msg.sender == address(crowdsaleAgent) && _tokensAmount > 0);\r\n\r\n        tokensSold = tokensSold.add(_tokensAmount);\r\n        usdCollected = usdCollected.add(_usdAmount);\r\n    }\r\n\r\n    function internalContribution(address _contributor, uint256 _usdAmount) internal {\r\n        updateState();\r\n\r\n        require(currentState == State.InCrowdsale);\r\n\r\n        CHLPricingStrategy pricing = CHLPricingStrategy(pricingStrategy);\r\n\r\n        require(!isHardCapAchieved(_usdAmount.sub(1)));\r\n\r\n        uint256 tokensAvailable = allocator.tokensAvailable();\r\n        uint256 collectedWei = contributionForwarder.weiCollected();\r\n        uint256 tierIndex = pricing.getTierIndex();\r\n        uint256 tokens;\r\n        uint256 tokensExcludingBonus;\r\n        uint256 bonus;\r\n\r\n        (tokens, tokensExcludingBonus, bonus) = pricing.getTokens(\r\n            _contributor, tokensAvailable, tokensSold, _usdAmount, collectedWei);\r\n\r\n        require(tokens > 0);\r\n\r\n        tokensSold = tokensSold.add(tokens);\r\n\r\n        allocator.allocate(_contributor, tokens);\r\n\r\n        //allocate Processing fee\r\n        uint256 processingFeeAmount = tokens.mul(processingFeePercentage).div(percentageAbsMax);\r\n        allocator.allocate(processingFeeAddress, processingFeeAmount);\r\n\r\n        if (isSoftCapAchieved(_usdAmount)) {\r\n            if (msg.value > 0) {\r\n                contributionForwarder.forward.value(address(this).balance)();\r\n            }\r\n        } else {\r\n            // store contributor if it is not stored before\r\n            if (contributorsWei[_contributor] == 0) {\r\n                contributors.push(_contributor);\r\n            }\r\n            if (msg.value > 0) {\r\n                contributorsWei[_contributor] = contributorsWei[_contributor].add(msg.value);\r\n            }\r\n        }\r\n\r\n        usdCollected = usdCollected.add(_usdAmount);\r\n\r\n        crowdsaleAgent.onContribution(_contributor, tierIndex, tokensExcludingBonus, bonus);\r\n\r\n        emit Contribution(_contributor, _usdAmount, tokensExcludingBonus, bonus);\r\n        emit ProcessingFeeAllocation(_contributor, processingFeeAmount);\r\n    }\r\n\r\n}\r\ncontract Shopereum is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public etherPriceInUSD;\r\n    uint256 public priceUpdateAt;\r\n    mapping(address => bool) public trustedAddresses;\r\n\r\n    event NewPriceTicker(string _price);\r\n\r\n    modifier onlyTursted() {\r\n        require(trustedAddresses[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    constructor(uint256 _etherPriceInUSD) public {\r\n        etherPriceInUSD = _etherPriceInUSD;\r\n        priceUpdateAt = block.timestamp;\r\n        trustedAddresses[msg.sender] = true;\r\n    }\r\n\r\n    function setTrustedAddress(address _address, bool _status) public onlyOwner {\r\n        trustedAddresses[_address] = _status;\r\n    }\r\n\r\n    // set ether price in USD with 5 digits after the decimal point\r\n    //ex. 308.75000\r\n    //for updating the price through  multivest\r\n    function setEtherInUSD(string _price) public onlyTursted {\r\n        bytes memory bytePrice = bytes(_price);\r\n        uint256 dot = bytePrice.length.sub(uint256(6));\r\n\r\n        // check if dot is in 6 position  from  the last\r\n        require(0x2e == uint(bytePrice[dot]));\r\n\r\n        uint256 newPrice = uint256(10 ** 23).div(parseInt(_price, 5));\r\n\r\n        require(newPrice > 0);\r\n\r\n        etherPriceInUSD = parseInt(_price, 5);\r\n\r\n        priceUpdateAt = block.timestamp;\r\n\r\n        emit NewPriceTicker(_price);\r\n    }\r\n\r\n    function parseInt(string _a, uint _b) internal pure returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint res = 0;\r\n        bool decimals = false;\r\n        for (uint i = 0; i < bresult.length; i++) {\r\n            if ((bresult[i] >= 48) && (bresult[i] <= 57)) {\r\n                if (decimals) {\r\n                    if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                res *= 10;\r\n                res += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) res *= 10 ** _b;\r\n        return res;\r\n    }\r\n}\r\n/// @title PricingStrategy\r\n/// @author Applicature\r\n/// @notice Contract is responsible for calculating tokens amount depending on different criterias\r\n/// @dev Base class\r\ncontract PricingStrategy {\r\n\r\n    function isInitialized() public view returns (bool);\r\n\r\n    function getTokens(\r\n        address _contributor,\r\n        uint256 _tokensAvailable,\r\n        uint256 _tokensSold,\r\n        uint256 _weiAmount,\r\n        uint256 _collectedWei\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 tokens, uint256 tokensExcludingBonus, uint256 bonus);\r\n\r\n    function getWeis(\r\n        uint256 _collectedWei,\r\n        uint256 _tokensSold,\r\n        uint256 _tokens\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 weiAmount, uint256 tokensBonus);\r\n\r\n}\r\n/// @title USDDateTiersPricingStrategy\r\n/// @author Applicature\r\n/// @notice Contract is responsible for calculating tokens amount depending on price in USD\r\n/// @dev implementation\r\ncontract USDDateTiersPricingStrategy is PricingStrategy, Shopereum {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    //tokenInUSD token price in usd * 10 ^ 5\r\n    //maxTokensCollected max tokens amount that can be distributed\r\n    //bonusCap tokens amount cap; while sold tokens < bonus cap - contributors will receive bonus % tokens\r\n    //soldTierTokens tokens that already been sold\r\n    //bonusTierTokens bonus tokens that already been allocated\r\n    //bonusPercents bonus percentage\r\n    //minInvestInUSD min investment in usd * 10 * 5\r\n    //startDate tier start time\r\n    //endDate tier end time\r\n    struct Tier {\r\n        uint256 tokenInUSD;\r\n        uint256 maxTokensCollected;\r\n        uint256 bonusCap;\r\n        uint256 soldTierTokens;\r\n        uint256 bonusTierTokens;\r\n        uint256 bonusPercents;\r\n        uint256 minInvestInUSD;\r\n        uint256 startDate;\r\n        uint256 endDate;\r\n    }\r\n\r\n    Tier[] public tiers;\r\n    uint256 public decimals;\r\n\r\n    constructor(uint256[] _tiers, uint256 _decimals, uint256 _etherPriceInUSD) public Shopereum(_etherPriceInUSD) {\r\n        decimals = _decimals;\r\n        trustedAddresses[msg.sender] = true;\r\n        require(_tiers.length % 9 == 0);\r\n\r\n        uint256 length = _tiers.length / 9;\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            tiers.push(\r\n                Tier(\r\n                    _tiers[i * 9],\r\n                    _tiers[i * 9 + 1],\r\n                    _tiers[i * 9 + 2],\r\n                    _tiers[i * 9 + 3],\r\n                    _tiers[i * 9 + 4],\r\n                    _tiers[i * 9 + 5],\r\n                    _tiers[i * 9 + 6],\r\n                    _tiers[i * 9 + 7],\r\n                    _tiers[i * 9 + 8]\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @return tier index\r\n    function getTierIndex() public view returns (uint256) {\r\n        for (uint256 i = 0; i < tiers.length; i++) {\r\n            if (\r\n                block.timestamp >= tiers[i].startDate &&\r\n                block.timestamp < tiers[i].endDate &&\r\n                tiers[i].maxTokensCollected > tiers[i].soldTierTokens\r\n            ) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return tiers.length;\r\n    }\r\n\r\n    function getActualTierIndex() public view returns (uint256) {\r\n        for (uint256 i = 0; i < tiers.length; i++) {\r\n            if (\r\n                block.timestamp >= tiers[i].startDate\r\n                && block.timestamp < tiers[i].endDate\r\n                && tiers[i].maxTokensCollected > tiers[i].soldTierTokens\r\n                || block.timestamp < tiers[i].startDate\r\n            ) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return tiers.length.sub(1);\r\n    }\r\n\r\n    /// @return actual dates\r\n    function getActualDates() public view returns (uint256 startDate, uint256 endDate) {\r\n        uint256 tierIndex = getActualTierIndex();\r\n        startDate = tiers[tierIndex].startDate;\r\n        endDate = tiers[tierIndex].endDate;\r\n    }\r\n\r\n    /// @return tokens based on sold tokens and wei amount\r\n    function getTokens(\r\n        address,\r\n        uint256 _tokensAvailable,\r\n        uint256,\r\n        uint256 _usdAmount,\r\n        uint256\r\n    ) public view returns (uint256 tokens, uint256 tokensExcludingBonus, uint256 bonus) {\r\n        if (_usdAmount == 0) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        uint256 tierIndex = getTierIndex();\r\n\r\n        if (tierIndex < tiers.length && _usdAmount < tiers[tierIndex].minInvestInUSD) {\r\n            return (0, 0, 0);\r\n        }\r\n        if (tierIndex == tiers.length) {\r\n            return (0, 0, 0);\r\n        }\r\n        tokensExcludingBonus = _usdAmount.mul(1e18).div(getTokensInUSD(tierIndex));\r\n        if (tiers[tierIndex].maxTokensCollected < tiers[tierIndex].soldTierTokens.add(tokensExcludingBonus)) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        bonus = calculateBonusAmount(tierIndex, tokensExcludingBonus);\r\n\r\n        tokens = tokensExcludingBonus.add(bonus);\r\n\r\n        if (tokens > _tokensAvailable) {\r\n            return (0, 0, 0);\r\n        }\r\n    }\r\n\r\n    /// @return usd amount based on required tokens\r\n    function getUSDAmountByTokens(\r\n        uint256 _tokens\r\n    ) public view returns (uint256 totalUSDAmount, uint256 tokensBonus) {\r\n        if (_tokens == 0) {\r\n            return (0, 0);\r\n        }\r\n\r\n        uint256 tierIndex = getTierIndex();\r\n        if (tierIndex == tiers.length) {\r\n            return (0, 0);\r\n        }\r\n        if (tiers[tierIndex].maxTokensCollected < tiers[tierIndex].soldTierTokens.add(_tokens)) {\r\n            return (0, 0);\r\n        }\r\n\r\n        totalUSDAmount = _tokens.mul(getTokensInUSD(tierIndex)).div(1e18);\r\n\r\n        if (totalUSDAmount < tiers[tierIndex].minInvestInUSD) {\r\n            return (0, 0);\r\n        }\r\n\r\n        tokensBonus = calculateBonusAmount(tierIndex, _tokens);\r\n    }\r\n\r\n    /// @return weis based on sold and required tokens\r\n    function getWeis(\r\n        uint256,\r\n        uint256,\r\n        uint256 _tokens\r\n    ) public view returns (uint256 totalWeiAmount, uint256 tokensBonus) {\r\n        uint256 usdAmount;\r\n        (usdAmount, tokensBonus) = getUSDAmountByTokens(_tokens);\r\n\r\n        if (usdAmount == 0) {\r\n            return (0, 0);\r\n        }\r\n\r\n        totalWeiAmount = usdAmount.mul(1e18).div(etherPriceInUSD);\r\n    }\r\n\r\n    /// calculates bonus tokens amount by bonusPercents in case if bonusCap is not reached;\r\n    /// if reached returns 0\r\n    /// @return bonus tokens amount\r\n    function calculateBonusAmount(uint256 _tierIndex, uint256 _tokens) public view returns (uint256 bonus) {\r\n        if (tiers[_tierIndex].soldTierTokens < tiers[_tierIndex].bonusCap) {\r\n            if (tiers[_tierIndex].soldTierTokens.add(_tokens) <= tiers[_tierIndex].bonusCap) {\r\n                bonus = _tokens.mul(tiers[_tierIndex].bonusPercents).div(100);\r\n            } else {\r\n                bonus = (tiers[_tierIndex].bonusCap.sub(tiers[_tierIndex].soldTierTokens))\r\n                    .mul(tiers[_tierIndex].bonusPercents).div(100);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getTokensInUSD(uint256 _tierIndex) public view returns (uint256) {\r\n        if (_tierIndex < uint256(tiers.length)) {\r\n            return tiers[_tierIndex].tokenInUSD;\r\n        }\r\n    }\r\n\r\n    function getMinEtherInvest(uint256 _tierIndex) public view returns (uint256) {\r\n        if (_tierIndex < uint256(tiers.length)) {\r\n            return tiers[_tierIndex].minInvestInUSD.mul(1 ether).div(etherPriceInUSD);\r\n        }\r\n    }\r\n\r\n    function getUSDAmountByWeis(uint256 _weiAmount) public view returns (uint256) {\r\n        return _weiAmount.mul(etherPriceInUSD).div(1 ether);\r\n    }\r\n\r\n    /// @notice Check whether contract is initialised\r\n    /// @return true if initialized\r\n    function isInitialized() public view returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /// @notice updates tier start/end dates by id\r\n    function updateDates(uint8 _tierId, uint256 _start, uint256 _end) public onlyOwner() {\r\n        if (_start != 0 && _start < _end && _tierId < tiers.length) {\r\n            Tier storage tier = tiers[_tierId];\r\n            tier.startDate = _start;\r\n            tier.endDate = _end;\r\n        }\r\n    }\r\n}\r\ncontract CHLPricingStrategy is USDDateTiersPricingStrategy {\r\n\r\n    CHLAgent public agent;\r\n\r\n    modifier onlyAgent() {\r\n        require(msg.sender == address(agent));\r\n        _;\r\n    }\r\n\r\n    event MaxTokensCollectedDecreased(uint256 tierId, uint256 oldValue, uint256 amount);\r\n\r\n    constructor(\r\n        uint256[] _emptyArray,\r\n        uint256[4] _periods,\r\n        uint256 _etherPriceInUSD\r\n    ) public USDDateTiersPricingStrategy(_emptyArray, 18, _etherPriceInUSD) {\r\n        //pre-ico\r\n        tiers.push(Tier(0.75e5, 6247500e8, 0, 0, 0, 0, 100e5, _periods[0], _periods[1]));\r\n        //public ico\r\n        tiers.push(Tier(3e5, 32725000e8, 0, 0, 0, 0, 100e5, _periods[2], _periods[3]));\r\n    }\r\n\r\n    function getArrayOfTiers() public view returns (uint256[12] tiersData) {\r\n        uint256 j = 0;\r\n        for (uint256 i = 0; i < tiers.length; i++) {\r\n            tiersData[j++] = uint256(tiers[i].tokenInUSD);\r\n            tiersData[j++] = uint256(tiers[i].maxTokensCollected);\r\n            tiersData[j++] = uint256(tiers[i].soldTierTokens);\r\n            tiersData[j++] = uint256(tiers[i].minInvestInUSD);\r\n            tiersData[j++] = uint256(tiers[i].startDate);\r\n            tiersData[j++] = uint256(tiers[i].endDate);\r\n        }\r\n    }\r\n\r\n    function updateTier(\r\n        uint256 _tierId,\r\n        uint256 _start,\r\n        uint256 _end,\r\n        uint256 _minInvest,\r\n        uint256 _price,\r\n        uint256 _bonusCap,\r\n        uint256 _bonus,\r\n        bool _updateLockNeeded\r\n    ) public onlyOwner() {\r\n        require(\r\n            _start != 0 &&\r\n            _price != 0 &&\r\n            _start < _end &&\r\n            _tierId < tiers.length\r\n        );\r\n\r\n        if (_updateLockNeeded) {\r\n            agent.updateLockPeriod(_end);\r\n        }\r\n\r\n        Tier storage tier = tiers[_tierId];\r\n        tier.tokenInUSD = _price;\r\n        tier.minInvestInUSD = _minInvest;\r\n        tier.startDate = _start;\r\n        tier.endDate = _end;\r\n        tier.bonusCap = _bonusCap;\r\n        tier.bonusPercents = _bonus;\r\n    }\r\n\r\n    function setCrowdsaleAgent(CHLAgent _crowdsaleAgent) public onlyOwner {\r\n        agent = _crowdsaleAgent;\r\n    }\r\n\r\n    function updateTierTokens(uint256 _tierId, uint256 _soldTokens, uint256 _bonusTokens) public onlyAgent {\r\n        require(_tierId < tiers.length && _soldTokens > 0);\r\n\r\n        Tier storage tier = tiers[_tierId];\r\n        tier.soldTierTokens = tier.soldTierTokens.add(_soldTokens);\r\n        tier.bonusTierTokens = tier.bonusTierTokens.add(_bonusTokens);\r\n    }\r\n\r\n    function updateMaxTokensCollected(uint256 _tierId, uint256 _amount) public onlyAgent {\r\n        require(_tierId < tiers.length && _amount > 0);\r\n\r\n        Tier storage tier = tiers[_tierId];\r\n\r\n        require(tier.maxTokensCollected.sub(_amount) >= tier.soldTierTokens.add(tier.bonusTierTokens));\r\n\r\n        emit MaxTokensCollectedDecreased(_tierId, tier.maxTokensCollected, _amount);\r\n\r\n        tier.maxTokensCollected = tier.maxTokensCollected.sub(_amount);\r\n    }\r\n\r\n    function getTokensWithoutRestrictions(uint256 _usdAmount) public view returns (\r\n        uint256 tokens,\r\n        uint256 tokensExcludingBonus,\r\n        uint256 bonus\r\n    ) {\r\n        if (_usdAmount == 0) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        uint256 tierIndex = getActualTierIndex();\r\n\r\n        tokensExcludingBonus = _usdAmount.mul(1e18).div(getTokensInUSD(tierIndex));\r\n        bonus = calculateBonusAmount(tierIndex, tokensExcludingBonus);\r\n        tokens = tokensExcludingBonus.add(bonus);\r\n    }\r\n\r\n    function getTierUnsoldTokens(uint256 _tierId) public view returns (uint256) {\r\n        if (_tierId >= tiers.length) {\r\n            return 0;\r\n        }\r\n\r\n        return tiers[_tierId].maxTokensCollected.sub(tiers[_tierId].soldTierTokens);\r\n    }\r\n\r\n    function getSaleEndDate() public view returns (uint256) {\r\n        return tiers[tiers.length.sub(1)].endDate;\r\n    }\r\n\r\n}\r\ncontract Referral is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    MintableTokenAllocator public allocator;\r\n    CrowdsaleImpl public crowdsale;\r\n\r\n    uint256 public constant DECIMALS = 18;\r\n\r\n    uint256 public totalSupply;\r\n    bool public unLimited;\r\n    bool public sentOnce;\r\n\r\n    mapping(address => bool) public claimed;\r\n    mapping(address => uint256) public claimedBalances;\r\n\r\n    constructor(\r\n        uint256 _totalSupply,\r\n        address _allocator,\r\n        address _crowdsale,\r\n        bool _sentOnce\r\n    ) public {\r\n        require(_allocator != address(0) && _crowdsale != address(0));\r\n        totalSupply = _totalSupply;\r\n        if (totalSupply == 0) {\r\n            unLimited = true;\r\n        }\r\n        allocator = MintableTokenAllocator(_allocator);\r\n        crowdsale = CrowdsaleImpl(_crowdsale);\r\n        sentOnce = _sentOnce;\r\n    }\r\n\r\n    function setAllocator(address _allocator) public onlyOwner {\r\n        if (_allocator != address(0)) {\r\n            allocator = MintableTokenAllocator(_allocator);\r\n        }\r\n    }\r\n\r\n    function setCrowdsale(address _crowdsale) public onlyOwner {\r\n        require(_crowdsale != address(0));\r\n        crowdsale = CrowdsaleImpl(_crowdsale);\r\n    }\r\n\r\n    function multivestMint(\r\n        address _address,\r\n        uint256 _amount,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) public {\r\n        require(true == crowdsale.signers(verify(msg.sender, _amount, _v, _r, _s)));\r\n        if (true == sentOnce) {\r\n            require(claimed[_address] == false);\r\n            claimed[_address] = true;\r\n        }\r\n        require(\r\n            _address == msg.sender &&\r\n            _amount > 0 &&\r\n            (true == unLimited || _amount <= totalSupply)\r\n        );\r\n        claimedBalances[_address] = claimedBalances[_address].add(_amount);\r\n        if (false == unLimited) {\r\n            totalSupply = totalSupply.sub(_amount);\r\n        }\r\n        allocator.allocate(_address, _amount);\r\n    }\r\n\r\n    /// @notice check sign\r\n    function verify(address _sender, uint256 _amount, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\r\n        bytes32 hash = keccak256(abi.encodePacked(_sender, _amount));\r\n\r\n        bytes memory prefix = '\\x19Ethereum Signed Message:\\n32';\r\n\r\n        return ecrecover(keccak256(abi.encodePacked(prefix, hash)), _v, _r, _s);\r\n    }\r\n\r\n}\r\ncontract CHLReferral is Referral {\r\n\r\n    CHLPricingStrategy public pricingStrategy;\r\n\r\n    constructor(\r\n        address _allocator,\r\n        address _crowdsale,\r\n        CHLPricingStrategy _strategy\r\n    ) public Referral(1190000e8, _allocator, _crowdsale, true) {\r\n        require(_strategy != address(0));\r\n        pricingStrategy = _strategy;\r\n    }\r\n\r\n    function multivestMint(\r\n        address _address,\r\n        uint256 _amount,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) public {\r\n        require(pricingStrategy.getSaleEndDate() <= block.timestamp);\r\n        super.multivestMint(_address, _amount, _v, _r, _s);\r\n    }\r\n}\r\ncontract CHLAllocation is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    MintableTokenAllocator public allocator;\r\n\r\n    CHLAgent public agent;\r\n    //manualMintingSupply = Advisors 2975000 + Bounty 1785000 + LWL (Non Profit Initiative) 1190000\r\n    uint256 public manualMintingSupply = 5950000e8;\r\n\r\n    uint256 public foundersVestingAmountPeriodOne = 7140000e8;\r\n    uint256 public foundersVestingAmountPeriodTwo = 2975000e8;\r\n    uint256 public foundersVestingAmountPeriodThree = 1785000e8;\r\n\r\n    address[] public vestings;\r\n\r\n    address public foundersAddress;\r\n\r\n    bool public isFoundersTokensSent;\r\n\r\n    event VestingCreated(\r\n        address _vesting,\r\n        address _beneficiary,\r\n        uint256 _start,\r\n        uint256 _cliff,\r\n        uint256 _duration,\r\n        uint256 _periods,\r\n        bool _revocable\r\n    );\r\n\r\n    event VestingRevoked(address _vesting);\r\n\r\n    constructor(MintableTokenAllocator _allocator, address _foundersAddress) public {\r\n        require(_foundersAddress != address(0));\r\n        foundersAddress = _foundersAddress;\r\n        allocator = _allocator;\r\n    }\r\n\r\n    function setAllocator(MintableTokenAllocator _allocator) public onlyOwner {\r\n        require(_allocator != address(0));\r\n        allocator = _allocator;\r\n    }\r\n\r\n    function setAgent(CHLAgent _agent) public onlyOwner {\r\n        require(_agent != address(0));\r\n        agent = _agent;\r\n    }\r\n\r\n    function allocateManualMintingTokens(address[] _addresses, uint256[] _tokens) public onlyOwner {\r\n        require(_addresses.length == _tokens.length);\r\n        for (uint256 i = 0; i < _addresses.length; i++) {\r\n            require(_addresses[i] != address(0) && _tokens[i] > 0 && _tokens[i] <= manualMintingSupply);\r\n            manualMintingSupply -= _tokens[i];\r\n\r\n            allocator.allocate(_addresses[i], _tokens[i]);\r\n        }\r\n    }\r\n\r\n    function allocatePrivateSaleTokens(\r\n        uint256 _tierId,\r\n        uint256 _totalTokensSupply,\r\n        uint256 _tokenPriceInUsd,\r\n        address[] _addresses,\r\n        uint256[] _tokens\r\n    ) public onlyOwner {\r\n        require(\r\n            _addresses.length == _tokens.length &&\r\n            _totalTokensSupply > 0\r\n        );\r\n\r\n        agent.updateStateWithPrivateSale(_tierId, _totalTokensSupply, _totalTokensSupply.mul(_tokenPriceInUsd).div(1e18));\r\n\r\n        for (uint256 i = 0; i < _addresses.length; i++) {\r\n            require(_addresses[i] != address(0) && _tokens[i] > 0 && _tokens[i] <= _totalTokensSupply);\r\n            _totalTokensSupply = _totalTokensSupply.sub(_tokens[i]);\r\n\r\n            allocator.allocate(_addresses[i], _tokens[i]);\r\n        }\r\n\r\n        require(_totalTokensSupply == 0);\r\n    }\r\n\r\n    function allocateFoundersTokens(uint256 _start) public {\r\n        require(!isFoundersTokensSent && msg.sender == address(agent));\r\n\r\n        isFoundersTokensSent = true;\r\n\r\n        allocator.allocate(foundersAddress, foundersVestingAmountPeriodOne);\r\n\r\n        createVestingInternal(\r\n            foundersAddress,\r\n            _start,\r\n            0,\r\n            365 days,\r\n            1,\r\n            true,\r\n            owner,\r\n            foundersVestingAmountPeriodTwo\r\n        );\r\n\r\n        createVestingInternal(\r\n            foundersAddress,\r\n            _start,\r\n            0,\r\n            730 days,\r\n            1,\r\n            true,\r\n            owner,\r\n            foundersVestingAmountPeriodThree\r\n        );\r\n    }\r\n\r\n    function createVesting(\r\n        address _beneficiary,\r\n        uint256 _start,\r\n        uint256 _cliff,\r\n        uint256 _duration,\r\n        uint256 _periods,\r\n        bool _revocable,\r\n        address _unreleasedHolder,\r\n        uint256 _amount\r\n    ) public onlyOwner returns (PeriodicTokenVesting vesting) {\r\n\r\n        vesting = createVestingInternal(\r\n            _beneficiary,\r\n            _start,\r\n            _cliff,\r\n            _duration,\r\n            _periods,\r\n            _revocable,\r\n            _unreleasedHolder,\r\n            _amount\r\n        );\r\n    }\r\n\r\n    function revokeVesting(PeriodicTokenVesting _vesting, ERC20Basic token) public onlyOwner() {\r\n        _vesting.revoke(token);\r\n\r\n        emit VestingRevoked(_vesting);\r\n    }\r\n\r\n    function createVestingInternal(\r\n        address _beneficiary,\r\n        uint256 _start,\r\n        uint256 _cliff,\r\n        uint256 _duration,\r\n        uint256 _periods,\r\n        bool _revocable,\r\n        address _unreleasedHolder,\r\n        uint256 _amount\r\n    ) internal returns (PeriodicTokenVesting) {\r\n        PeriodicTokenVesting vesting = new PeriodicTokenVesting(\r\n            _beneficiary, _start, _cliff, _duration, _periods, _revocable, _unreleasedHolder\r\n        );\r\n\r\n        vestings.push(vesting);\r\n\r\n        emit VestingCreated(vesting, _beneficiary, _start, _cliff, _duration, _periods, _revocable);\r\n\r\n        allocator.allocate(address(vesting), _amount);\r\n\r\n        return vesting;\r\n    }\r\n\r\n}\r\n/**\r\n * @title TokenVesting\r\n * @dev A token holder contract that can release its token balance gradually like a\r\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\r\n * owner.\r\n */\r\ncontract TokenVesting is Ownable {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  event Released(uint256 amount);\r\n  event Revoked();\r\n\r\n  // beneficiary of tokens after they are released\r\n  address public beneficiary;\r\n\r\n  uint256 public cliff;\r\n  uint256 public start;\r\n  uint256 public duration;\r\n\r\n  bool public revocable;\r\n\r\n  mapping (address => uint256) public released;\r\n  mapping (address => bool) public revoked;\r\n\r\n  /**\r\n   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\r\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\r\n   * of the balance will have vested.\r\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\r\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\r\n   * @param _start the time (as Unix time) at which point vesting starts \r\n   * @param _duration duration in seconds of the period in which the tokens will vest\r\n   * @param _revocable whether the vesting is revocable or not\r\n   */\r\n  constructor(\r\n    address _beneficiary,\r\n    uint256 _start,\r\n    uint256 _cliff,\r\n    uint256 _duration,\r\n    bool _revocable\r\n  )\r\n    public\r\n  {\r\n    require(_beneficiary != address(0));\r\n    require(_cliff <= _duration);\r\n\r\n    beneficiary = _beneficiary;\r\n    revocable = _revocable;\r\n    duration = _duration;\r\n    cliff = _start.add(_cliff);\r\n    start = _start;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers vested tokens to beneficiary.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function release(ERC20Basic token) public {\r\n    uint256 unreleased = releasableAmount(token);\r\n\r\n    require(unreleased > 0);\r\n\r\n    released[token] = released[token].add(unreleased);\r\n\r\n    token.safeTransfer(beneficiary, unreleased);\r\n\r\n    emit Released(unreleased);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the owner to revoke the vesting. Tokens already vested\r\n   * remain in the contract, the rest are returned to the owner.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function revoke(ERC20Basic token) public onlyOwner {\r\n    require(revocable);\r\n    require(!revoked[token]);\r\n\r\n    uint256 balance = token.balanceOf(this);\r\n\r\n    uint256 unreleased = releasableAmount(token);\r\n    uint256 refund = balance.sub(unreleased);\r\n\r\n    revoked[token] = true;\r\n\r\n    token.safeTransfer(owner, refund);\r\n\r\n    emit Revoked();\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function releasableAmount(ERC20Basic token) public view returns (uint256) {\r\n    return vestedAmount(token).sub(released[token]);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the amount that has already vested.\r\n   * @param token ERC20 token which is being vested\r\n   */\r\n  function vestedAmount(ERC20Basic token) public view returns (uint256) {\r\n    uint256 currentBalance = token.balanceOf(this);\r\n    uint256 totalBalance = currentBalance.add(released[token]);\r\n\r\n    if (block.timestamp < cliff) {\r\n      return 0;\r\n    } else if (block.timestamp >= start.add(duration) || revoked[token]) {\r\n      return totalBalance;\r\n    } else {\r\n      return totalBalance.mul(block.timestamp.sub(start)).div(duration);\r\n    }\r\n  }\r\n}\r\ncontract PeriodicTokenVesting is TokenVesting {\r\n    address public unreleasedHolder;\r\n    uint256 public periods;\r\n\r\n    constructor(\r\n        address _beneficiary,\r\n        uint256 _start,\r\n        uint256 _cliff,\r\n        uint256 _periodDuration,\r\n        uint256 _periods,\r\n        bool _revocable,\r\n        address _unreleasedHolder\r\n    ) public TokenVesting(_beneficiary, _start, _cliff, _periodDuration, _revocable) {\r\n        require(_revocable == false || _unreleasedHolder != address(0));\r\n        periods = _periods;\r\n        unreleasedHolder = _unreleasedHolder;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the amount that has already vested.\r\n    * @param token ERC20 token which is being vested\r\n    */\r\n    function vestedAmount(ERC20Basic token) public view returns (uint256) {\r\n        uint256 currentBalance = token.balanceOf(this);\r\n        uint256 totalBalance = currentBalance.add(released[token]);\r\n\r\n        if (now < cliff) {\r\n            return 0;\r\n        } else if (now >= start.add(duration * periods) || revoked[token]) {\r\n            return totalBalance;\r\n        } else {\r\n\r\n            uint256 periodTokens = totalBalance.div(periods);\r\n\r\n            uint256 periodsOver = now.sub(start).div(duration);\r\n\r\n            if (periodsOver >= periods) {\r\n                return totalBalance;\r\n            }\r\n\r\n            return periodTokens.mul(periodsOver);\r\n        }\r\n    }\r\n\r\n    /**\r\n * @notice Allows the owner to revoke the vesting. Tokens already vested\r\n * remain in the contract, the rest are returned to the owner.\r\n * @param token ERC20 token which is being vested\r\n */\r\n    function revoke(ERC20Basic token) public onlyOwner {\r\n        require(revocable);\r\n        require(!revoked[token]);\r\n\r\n        uint256 balance = token.balanceOf(this);\r\n\r\n        uint256 unreleased = releasableAmount(token);\r\n        uint256 refund = balance.sub(unreleased);\r\n\r\n        revoked[token] = true;\r\n\r\n        token.safeTransfer(unreleasedHolder, refund);\r\n\r\n        emit Revoked();\r\n    }\r\n}\r\ncontract Stats {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    MintableToken public token;\r\n    MintableTokenAllocator public allocator;\r\n    CHLCrowdsale public crowdsale;\r\n    CHLPricingStrategy public pricing;\r\n\r\n    constructor(\r\n        MintableToken _token,\r\n        MintableTokenAllocator _allocator,\r\n        CHLCrowdsale _crowdsale,\r\n        CHLPricingStrategy _pricing\r\n    ) public {\r\n        token = _token;\r\n        allocator = _allocator;\r\n        crowdsale = _crowdsale;\r\n        pricing = _pricing;\r\n    }\r\n\r\n    function getTokens(\r\n        uint256 _type,\r\n        uint256 _usdAmount\r\n    ) public view returns (uint256 tokens, uint256 tokensExcludingBonus, uint256 bonus) {\r\n        _type = _type;\r\n\r\n        return pricing.getTokensWithoutRestrictions(_usdAmount);\r\n    }\r\n\r\n    function getWeis(\r\n        uint256 _type,\r\n        uint256 _tokenAmount\r\n    ) public view returns (uint256 totalWeiAmount, uint256 tokensBonus) {\r\n        _type = _type;\r\n\r\n        return pricing.getWeis(0, 0, _tokenAmount);\r\n    }\r\n\r\n    function getUSDAmount(\r\n        uint256 _type,\r\n        uint256 _tokenAmount\r\n    ) public view returns (uint256 totalUSDAmount, uint256 tokensBonus) {\r\n        _type = _type;\r\n\r\n        return pricing.getUSDAmountByTokens(_tokenAmount);\r\n    }\r\n\r\n    function getStats(uint256 _userType, uint256[7] _ethPerCurrency) public view returns (\r\n        uint256[8] stats,\r\n        uint256[26] tiersData,\r\n        uint256[21] currencyContr //tokensPerEachCurrency,\r\n    ) {\r\n        stats = getStatsData(_userType);\r\n        tiersData = getTiersData(_userType);\r\n        currencyContr = getCurrencyContrData(_userType, _ethPerCurrency);\r\n    }\r\n\r\n    function getTiersData(uint256 _type) public view returns (\r\n        uint256[26] tiersData\r\n    ) {\r\n        _type = _type;\r\n        uint256[12] memory tiers = pricing.getArrayOfTiers();\r\n        uint256 length = tiers.length / 6;\r\n\r\n        uint256 j = 0;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            tiersData[j++] = uint256(1e23).div(tiers[i.mul(6)]);// tokenInUSD;\r\n            tiersData[j++] = 0;// tokenInWei;\r\n            tiersData[j++] = uint256(tiers[i.mul(6).add(1)]);// maxTokensCollected;\r\n            tiersData[j++] = uint256(tiers[i.mul(6).add(2)]);// soldTierTokens;\r\n            tiersData[j++] = 0;// discountPercents;\r\n            tiersData[j++] = 0;// bonusPercents;\r\n            tiersData[j++] = uint256(tiers[i.mul(6).add(3)]);// minInvestInUSD;\r\n            tiersData[j++] = 0;// minInvestInWei;\r\n            tiersData[j++] = 0;// maxInvestInUSD;\r\n            tiersData[j++] = 0;// maxInvestInWei;\r\n            tiersData[j++] = uint256(tiers[i.mul(6).add(4)]); // startDate;\r\n            tiersData[j++] = uint256(tiers[i.mul(6).add(5)]); // endDate;\r\n            tiersData[j++] = 1;\r\n        }\r\n\r\n        tiersData[25] = 2;\r\n\r\n    }\r\n\r\n    function getStatsData(uint256 _type) public view returns (\r\n        uint256[8] stats\r\n    ) {\r\n        _type = _type;\r\n        stats[0] = token.maxSupply();\r\n        stats[1] = token.totalSupply();\r\n        stats[2] = crowdsale.maxSaleSupply();\r\n        stats[3] = crowdsale.tokensSold();\r\n        stats[4] = uint256(crowdsale.currentState());\r\n        stats[5] = pricing.getActualTierIndex();\r\n        stats[6] = pricing.getTierUnsoldTokens(stats[5]);\r\n        stats[7] = pricing.getMinEtherInvest(stats[5]);\r\n    }\r\n\r\n    function getCurrencyContrData(uint256 _type, uint256[7] _usdPerCurrency) public view returns (\r\n        uint256[21] currencyContr\r\n    ) {\r\n        _type = _type;\r\n        uint256 j = 0;\r\n        for (uint256 i = 0; i < _usdPerCurrency.length; i++) {\r\n            (currencyContr[j++], currencyContr[j++], currencyContr[j++]) = pricing.getTokensWithoutRestrictions(\r\n                _usdPerCurrency[i]\r\n            );\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"trustedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherPriceInUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceUpdateAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setTrustedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"string\"}],\"name\":\"setEtherInUSD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_etherPriceInUSD\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_price\",\"type\":\"string\"}],\"name\":\"NewPriceTicker\",\"type\":\"event\"}]","ContractName":"Shopereum","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://985f9cbd8b7c85f316bb342a174a563361daeaaa07cac56df2d212fad4ee16a5"}]}