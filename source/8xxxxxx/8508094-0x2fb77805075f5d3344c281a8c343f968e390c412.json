{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity^0.5.11;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/*\r\n  Lock and Hold is a contract for people with terrible self control.  \r\n  \r\n*/\r\n\r\ncontract LockAndHold {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    address public initializer;\r\n    \r\n    /*\r\n      All times are approximations since human time is a silly construct.\r\n    */\r\n    \r\n    uint256 constant ONE_MONTH    = 2629746;\r\n    uint256 constant THREE_MONTHS = 7889238;\r\n    uint256 constant SIX_MONTHS   = 15778476;\r\n    uint256 constant YEAR         = 31556952;\r\n    \r\n    string public padding = \"0x0909090909\";\r\n    \r\n    mapping (int256 => uint256) Times;\r\n    \r\n    struct Lock {\r\n        bytes32 id;\r\n        uint256 value;\r\n        uint256 withdrawl_time;\r\n    }\r\n    \r\n    mapping (address => Lock) locks;\r\n    mapping (address => bool) lock_registry;\r\n    //mapping (bytes32 => Lock) lookupLockByID;\r\n    \r\n    \r\n    modifier requireNotAlreadyLocked(){\r\n        require(!lock_registry[msg.sender], \"Sending Address already has locked funds\");\r\n        _;\r\n    }\r\n    \r\n    modifier requireIsAlreadyLocked(){\r\n        require(lock_registry[msg.sender], \"Sending Address has no locked funds\");\r\n        _;\r\n    }\r\n    \r\n    \r\n    constructor () public {\r\n      initializer = msg.sender;\r\n      \r\n      // Setting at Construction\r\n      Times[1] = THREE_MONTHS;\r\n      Times[2] = SIX_MONTHS;\r\n      Times[3] = YEAR;\r\n    }\r\n    \r\n    /*\r\n      View Functions\r\n    */\r\n    \r\n    function isAddressLocking(address _address) public view returns (bool) {\r\n        return lock_registry[_address];\r\n    }\r\n    \r\n    function getLockReceiptBySender(address _address) public view returns (bytes memory) {\r\n        Lock storage t = locks[_address];\r\n        return abi.encode(t.id, padding, t.value, padding, t.withdrawl_time);\r\n    }\r\n    \r\n    function getLockAmountBySender(address _address) public view returns (uint256) {\r\n        return locks[_address].value;\r\n    }\r\n    \r\n    function getLockupUntilTimeBySender(address _address) public view returns (uint256) {\r\n        return locks[_address].withdrawl_time;\r\n    }\r\n    \r\n    function getCurrentBlockTime() public view returns (uint256){\r\n        return block.timestamp;\r\n    }\r\n    \r\n    /*\r\n      Internal Function that creates lock ID's for receipts\r\n    */\r\n    \r\n    function __generateId(address _sender, uint256 _now, uint _salt) private pure returns (bytes32 id){\r\n        return keccak256(abi.encode(_sender, _now, _salt));\r\n    }\r\n    \r\n    /*\r\n      Lock on Specific time outlined in Contract (Recommended way to use)\r\n    */\r\n    \r\n    function lockOnTime(int8 _timeIDX) requireNotAlreadyLocked external payable {\r\n        uint256 until = block.timestamp.add(Times[_timeIDX]);\r\n        bytes32 id = __generateId(msg.sender, block.timestamp, block.number);\r\n        \r\n        locks[msg.sender] = Lock(id, msg.value, until);\r\n        lock_registry[msg.sender] = true;\r\n        \r\n        emit Receipt(id, msg.value, block.timestamp, until);\r\n    }\r\n    \r\n    /*\r\n      Lock on a number of months.  Minimum is 1 month.  If you need to lock up for less than that\r\n      ...what the fuck is wrong with you?\r\n    */\r\n    \r\n    function customLockByMonth(uint256 _number_of_months) requireNotAlreadyLocked external payable {\r\n        uint256 time_to_lock = _number_of_months.mul(ONE_MONTH);\r\n        uint256 until = block.timestamp.add(time_to_lock);\r\n        bytes32 id = __generateId(msg.sender, block.timestamp, block.number);\r\n        \r\n        locks[msg.sender] = Lock(id, msg.value, until);\r\n        \r\n        lock_registry[msg.sender] = true;\r\n        \r\n        emit Receipt(id, msg.value, block.timestamp, until);\r\n    }\r\n    \r\n    /*\r\n      Witthdrawl function for getting stuff out.\r\n    */\r\n    \r\n    function withdrawl() requireIsAlreadyLocked external {\r\n        require(locks[msg.sender].withdrawl_time <= block.timestamp, \"Lockup period is still in effect\");\r\n        \r\n        msg.sender.transfer(locks[msg.sender].value);\r\n        locks[msg.sender].value = 0; // Just in case...\r\n        lock_registry[msg.sender] = false;\r\n        \r\n        emit Withdrawl(msg.sender, block.timestamp);\r\n    }\r\n\r\n    /*\r\n      If user sends funds directly without function will revert\r\n    */\r\n    \r\n    function () external {\r\n      revert();\r\n    }\r\n    \r\n    event Receipt(bytes32 id, uint256 amount, uint256 locked_on, uint256 until);\r\n    event Message(bytes16 status, bytes32 msg);\r\n    event Withdrawl(address to, uint256 on);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"padding\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getLockupUntilTimeBySender\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"int8\",\"name\":\"_timeIDX\",\"type\":\"int8\"}],\"name\":\"lockOnTime\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getLockReceiptBySender\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentBlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initializer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isAddressLocking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_number_of_months\",\"type\":\"uint256\"}],\"name\":\"customLockByMonth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getLockAmountBySender\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"locked_on\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"until\",\"type\":\"uint256\"}],\"name\":\"Receipt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"status\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"msg\",\"type\":\"bytes32\"}],\"name\":\"Message\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"on\",\"type\":\"uint256\"}],\"name\":\"Withdrawl\",\"type\":\"event\"}]","ContractName":"LockAndHold","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"Unlicense","SwarmSource":"bzzr://4ba8a6d215a8a081ff4c73e6ecbb19fe26143c98b651e3f7b78f52bc3bfd4cb0"}]}