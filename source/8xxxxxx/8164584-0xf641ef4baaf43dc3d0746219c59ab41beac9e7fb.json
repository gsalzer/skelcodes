{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n    function mint(address account, uint256 amount) public returns(bool);\r\n    function burn(address account, uint256 amount) public;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n/**\r\n@notice contract for staking ETF tokens\r\n */\r\ncontract KryptoinETFTokenStakeRewards is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    enum Status { INACTIVE, ACTIVE }\r\n\r\n    ERC20Interface public token; // token interface to interact with ETF token\r\n\r\n    /**\r\n    @notice Stake struct */\r\n    struct Stake {\r\n        uint256 amount;         // amount of stakee\r\n        address user;           // address of staking user\r\n        uint256 timeAtStake;    // time at the time of stake\r\n        Status stakeStatus;   // activate th\r\n        uint256 reward;\r\n    }\r\n\r\n    uint256[] public stakesList;                            // list of all the stakes\r\n    mapping(uint256 => Stake) private stakes;                // mapping from stakeID to stake struct\r\n    mapping(address => uint256[]) public userToStakeIDs;    // mapping from user and its stake IDs\r\n    mapping(address => uint256) private rewards;             // mapping from user and its reward\r\n\r\n    uint256 public stakesCount = 0;             // total count of stakes\r\n    uint256 tokenDecimals = 18;                 // decimals of the ETF token\r\n\r\n    uint256 minimumNoOfDaysForStake;\r\n\r\n    uint256 INVALID_INDEX = 999999999999; // invalid index\r\n\r\n    uint256 public poolOne_percent = 6;\r\n    uint256 public poolTwo_percent = 8;\r\n    uint256 public poolThree_percent = 10;\r\n    uint256 public poolFour_percent = 12;\r\n    uint256 public poolFive_percent = 15;\r\n\r\n    uint256 public poolOne_rate = 164;\r\n    uint256 public poolTwo_rate = 219;\r\n    uint256 public poolThree_rate = 273;\r\n    uint256 public poolFour_rate = 328;\r\n    uint256 public poolFive_rate = 410;\r\n\r\n    /**\r\n    @notice constructor of stake contract\r\n    @param _token the address of ETF token contract\r\n    */\r\n    constructor(ERC20Interface _token) public {\r\n        token = _token;\r\n        minimumNoOfDaysForStake = 10;\r\n    }\r\n\r\n    /**\r\n    @notice fired when tokens are staked by a user\r\n     */\r\n    event TokenStaked(address user, uint256 amount, uint256 timeAtStake, uint256 stakeID);\r\n\r\n    /**\r\n    @notice this function is called when a user stakes tokens\r\n    @param tokensAmount the amount of tokens user wants to stake\r\n     */\r\n    function stakeTokens(uint256 tokensAmount) public {\r\n        require(tokensAmount > 0, \"tokens must be greater than zero.\");\r\n\r\n        // burn the tokens of user\r\n        token.burn(msg.sender, tokensAmount);\r\n\r\n        // create a new stake entity\r\n        Stake memory newStake = Stake(tokensAmount, msg.sender, now, Status.INACTIVE, 0);\r\n\r\n        stakesCount = stakesCount + 1;\r\n        uint256 stakeID = stakesCount;\r\n\r\n        // store this new stake in the stakes mapping\r\n        stakes[stakeID] = newStake;\r\n\r\n        // add ID of the stake to the list of all stakes\r\n        stakesList.push(stakeID);\r\n\r\n        // add ID of the stake to existing stakes of the user\r\n        userToStakeIDs[msg.sender].push(stakeID);\r\n\r\n        emit TokenStaked(msg.sender, tokensAmount, now, stakeID);\r\n    }\r\n\r\n    /**\r\n    @notice fired when reward is set by the user\r\n     */\r\n    event RewardSet(uint256 from, uint256 to);\r\n\r\n    /**\r\n    @dev only owner can call this function to set rewards\r\n    @param from the starting index of stake in the stakesList\r\n    @param to the ending index of stake in the stakesList\r\n     */\r\n    function setReward(uint256 from, uint256 to) public onlyOwner {\r\n        \r\n        for(uint256 i = from; i < to; i++) {\r\n            Stake storage stake = stakes[stakesList[i]];\r\n            \r\n            if(stake.stakeStatus == Status.INACTIVE){\r\n                // check if the stake has passed eligibility period of 10 days\r\n                // if((stake.timeAtStake + minimumNoOfDaysForStake * 1 days) <= now) {\r\n                    // calculate reward for the user\r\n                    uint256 reward = calculateReward(stake.amount).mul(10);\r\n\r\n                    // add reward for the user to existing reward amount ( roll-over )\r\n                    rewards[stake.user] = rewards[stake.user].add(reward);\r\n                    stake.reward = stake.reward.add(reward);\r\n                    \r\n                    stake.stakeStatus = Status.ACTIVE;\r\n\r\n                // }\r\n            } else if(stake.stakeStatus == Status.ACTIVE){\r\n                // calculate reward for the user\r\n                uint256 reward = calculateReward(stake.amount);\r\n\r\n                // add reward for the user to existing reward amount ( roll-over )\r\n                rewards[stake.user] = rewards[stake.user].add(reward);\r\n                stake.reward = stake.reward.add(reward);\r\n            }\r\n        }\r\n\r\n        emit RewardSet(from, to);\r\n    }\r\n\r\n    /**\r\n    @notice fired when tokens are unstaked by the user\r\n     */\r\n    event TokensUnstaked(address user, uint256 amount, uint256 stakeID);\r\n\r\n    /**\r\n    @notice this is function is called by the user to unstake tokens\r\n    @param stakeID the ID of the stake\r\n     */\r\n    function unstakeTokens(uint256 stakeID) public {\r\n        require(stakeID > 0, \"please provide a valid stakeID\");\r\n\r\n        Stake memory stake_to_unstake = stakes[stakeID];\r\n        address user = stake_to_unstake.user;\r\n        uint256 tokenAmount = stake_to_unstake.amount;\r\n\r\n        require(msg.sender == user, \"sender is not the valid staker\");\r\n\r\n        // remove stake from stakesList\r\n        uint256 stakeIndexInStakesList = findStakeIndexInStakesList(stakeID);\r\n        if(stakeIndexInStakesList != INVALID_INDEX) {\r\n            stakesList[stakeIndexInStakesList] = stakesList[stakesList.length - 1];\r\n            stakesList.pop();\r\n        }\r\n        \r\n        // remove stake from the user's list of stakes\r\n        uint256[] storage userStakes = userToStakeIDs[msg.sender];\r\n        uint256 stakeIndexInUserToStakeIDs = findStakeIndexInUserToStakeIDs(msg.sender, stakeID);\r\n        if(stakeIndexInUserToStakeIDs != INVALID_INDEX) {\r\n            userStakes[stakeIndexInUserToStakeIDs] = userStakes[userStakes.length - 1];\r\n            userStakes.pop();\r\n        }\r\n\r\n        // mint the unstaked tokens for the user\r\n        require(token.mint(user, tokenAmount), \"unstake mint failed\");\r\n        emit TokensUnstaked(msg.sender, tokenAmount, stakeID);\r\n    }\r\n\r\n    /**\r\n    @notice fired when reward is withdrawn by the user\r\n     */\r\n    event RewardWithdrawn(address withdrawer, uint256 amount);\r\n\r\n    /**\r\n    @notice called by the user to withdraw rewards\r\n     */\r\n    function withdrawReward() public {\r\n        require(rewards[msg.sender] > 0, \"sender has zero reward\");\r\n        \r\n        uint256 reward = rewards[msg.sender];\r\n        rewards[msg.sender] = 0;\r\n\r\n        // mint the reward for the user\r\n        require(token.mint(msg.sender, reward), \"unstake mint failed\");\r\n        emit RewardWithdrawn(msg.sender, reward);\r\n    }\r\n\r\n    /**\r\n    @notice fired when minimum number of stake days changed\r\n     */\r\n    event MinimumNumberOfDaysOfStakeChanged(uint256 min_days);\r\n\r\n    /**\r\n    @notice called to change minimum number of stake days\r\n    @param min_days minimum number of days\r\n     */\r\n    function changeMinimumNumberOfDaysOfStake(uint256 min_days) public onlyOwner {\r\n        require(min_days > 0, \"min_days should be greater than zero\");\r\n        minimumNoOfDaysForStake = min_days;\r\n\r\n        emit MinimumNumberOfDaysOfStakeChanged(minimumNoOfDaysForStake);\r\n    }\r\n\r\n    event PoolsNewRates(uint256 one, uint256 two, uint256 three, uint256 four, uint256 five);\r\n\r\n    function changeDailyRewardRateOfPools(uint256 one, uint256 two, uint256 three, uint256 four, uint256 five) public onlyOwner {\r\n        poolOne_rate = one;\r\n        poolTwo_rate = two;\r\n        poolThree_rate = three;\r\n        poolFour_rate = four;\r\n        poolFive_rate = five;\r\n\r\n        emit PoolsNewRates(one, two, three, four, five);\r\n    }\r\n\r\n    event PoolsNewPerAnnumPercents(uint256 one, uint256 two, uint256 three, uint256 four, uint256 five);\r\n\r\n    function changePerAnnumPercentOfPools(uint256 one, uint256 two, uint256 three, uint256 four, uint256 five) public onlyOwner {\r\n        poolOne_percent = one;\r\n        poolTwo_percent = two;\r\n        poolThree_percent = three;\r\n        poolFour_percent = four;\r\n        poolFive_percent = five;\r\n\r\n        emit PoolsNewPerAnnumPercents(one, two, three, four, five);\r\n    }\r\n\r\n    /**\r\n    @notice call to this function returns the valid stakes' IDs in the contract\r\n     */\r\n    function getAllStakes() public view returns(uint256[] memory) {\r\n        return stakesList;\r\n    }\r\n\r\n    /**\r\n    @notice  call to this function returns stakeIDs by a user\r\n    @param user address of the staking individual*/\r\n    function getStakeIDsByUser(address user) public view returns(uint256[] memory) {\r\n        return userToStakeIDs[user];\r\n    }\r\n\r\n    /**\r\n    @notice this function returns percentage of rewards per annum based on the provided amount of tokens\r\n    @param tokens_without_decimals amount of tokens without decimals\r\n     */\r\n    function percentageOfRewardPerAnnum(uint256 tokens_without_decimals) public view returns(uint256) {\r\n        uint256 tokens = tokens_without_decimals;\r\n        uint256 reward_percent;\r\n\r\n        if(tokens >= 1000 && tokens <= 9999) { // 1000-9999\r\n            reward_percent = poolOne_percent;\r\n        } else if(tokens >= 10000 && tokens <= 99999) { // 10,000-99,999\r\n            reward_percent = poolTwo_percent;\r\n        } else if(tokens >= 100000 && tokens <= 999999) { // 100,000-999,999\r\n            reward_percent = poolThree_percent;\r\n        } else if(tokens >= 1000000 && tokens <= 9999999) { // 1,000,000-9,999,999\r\n            reward_percent = poolFour_percent;\r\n        } else if(tokens >= 10000000) { //  10,000,000+\r\n            reward_percent = poolFive_percent;\r\n        }\r\n\r\n        return reward_percent;\r\n    }\r\n\r\n    function getRewardByUser(address user) public view returns(uint256 reward) {\r\n        reward = rewards[user];\r\n    }\r\n\r\n    function stakeIDInfo(uint256 stakeID) public view returns(uint256 amount_staked, address user, uint256 timeOfStake, uint256 reward) {\r\n        Stake memory stake = stakes[stakeID];\r\n        amount_staked = stake.amount;\r\n        user = stake.user;\r\n        timeOfStake = stake.timeAtStake;\r\n        reward = stake.reward;\r\n    }\r\n\r\n\r\n    /**\r\n    @notice calculate reward for the user\r\n    @param amount amount of the stake\r\n    */\r\n    function calculateReward(uint256 amount) private view returns(uint256) {\r\n        uint256 tokens = amount;\r\n        uint256 reward;\r\n\r\n        // calculate reward per day\r\n        if(tokens >= 1000 * (10 ** tokenDecimals) && tokens <= 9999 * (10 ** tokenDecimals)) { // 1000-9999\r\n            reward = tokens.mul(poolOne_rate).div(1000000); // caculate 0.0.0164% reward\r\n        } else if(tokens >= 10000 * (10 ** tokenDecimals) && tokens <= 99999 * (10 ** tokenDecimals)) { // 10,000-99,999\r\n            reward = tokens.mul(poolTwo_rate).div(1000000); // calculate 0.0.0219% reward\r\n        } else if(tokens >= 100000 * (10 ** tokenDecimals) && tokens <= 999999 * (10 ** tokenDecimals)) { // 100,000-999,999\r\n            reward = tokens.mul(poolThree_rate).div(1000000); // calculate 0.0.0273% reward\r\n        } else if(tokens >= 1000000 * (10 ** tokenDecimals) && tokens <= 9999999 * (10 ** tokenDecimals)) { // 1,000,000-9,999,999\r\n            reward = tokens.mul(poolFour_rate).div(1000000); // calculate 0.0.0328% reward\r\n        } else if(tokens >= 10000000 * (10 ** tokenDecimals)) { //  10,000,000+\r\n            reward = tokens.mul(poolFive_rate).div(1000000); // calculate 0.0.0410% reward\r\n        }\r\n\r\n        return reward;\r\n    }\r\n\r\n     /**\r\n    @dev only called privately to calculate index of stake in the stakesList by its ID\r\n    @param stakeID ID of the stake\r\n     */\r\n    function findStakeIndexInStakesList(uint256 stakeID) private view returns(uint256) {\r\n        for(uint256 i = 0; i < stakesList.length; i++) {\r\n            if(stakesList[i] == stakeID) {\r\n                return i;\r\n            }\r\n        }\r\n        return INVALID_INDEX;\r\n    }\r\n\r\n    /**\r\n    @dev only called privately to calculate index of stake in the userToStakeIDs by its user and stakeID\r\n    @param user address of the user\r\n    @param stakeID ID of the stake\r\n     */\r\n    function findStakeIndexInUserToStakeIDs(address user, uint256 stakeID) private view returns(uint256) {\r\n        uint256[] memory userStakes = userToStakeIDs[user];\r\n\r\n        for(uint256 i = 0; i < userStakes.length; i++) {\r\n            if(userStakes[i] == stakeID) {\r\n                return i;\r\n            }\r\n        }\r\n        return INVALID_INDEX;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"poolFive_percent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolThree_rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"stakeID\",\"type\":\"uint256\"}],\"name\":\"stakeIDInfo\",\"outputs\":[{\"name\":\"amount_staked\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"timeOfStake\",\"type\":\"uint256\"},{\"name\":\"reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"min_days\",\"type\":\"uint256\"}],\"name\":\"changeMinimumNumberOfDaysOfStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolThree_percent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolOne_percent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getStakeIDsByUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokens_without_decimals\",\"type\":\"uint256\"}],\"name\":\"percentageOfRewardPerAnnum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolTwo_percent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakesList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"stakeID\",\"type\":\"uint256\"}],\"name\":\"unstakeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolOne_rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolFive_rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"stakeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolTwo_rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"one\",\"type\":\"uint256\"},{\"name\":\"two\",\"type\":\"uint256\"},{\"name\":\"three\",\"type\":\"uint256\"},{\"name\":\"four\",\"type\":\"uint256\"},{\"name\":\"five\",\"type\":\"uint256\"}],\"name\":\"changePerAnnumPercentOfPools\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolFour_rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"setReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"one\",\"type\":\"uint256\"},{\"name\":\"two\",\"type\":\"uint256\"},{\"name\":\"three\",\"type\":\"uint256\"},{\"name\":\"four\",\"type\":\"uint256\"},{\"name\":\"five\",\"type\":\"uint256\"}],\"name\":\"changeDailyRewardRateOfPools\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getRewardByUser\",\"outputs\":[{\"name\":\"reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userToStakeIDs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolFour_percent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeAtStake\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakeID\",\"type\":\"uint256\"}],\"name\":\"TokenStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"RewardSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakeID\",\"type\":\"uint256\"}],\"name\":\"TokensUnstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"min_days\",\"type\":\"uint256\"}],\"name\":\"MinimumNumberOfDaysOfStakeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"one\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"two\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"three\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"four\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"five\",\"type\":\"uint256\"}],\"name\":\"PoolsNewRates\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"one\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"two\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"three\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"four\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"five\",\"type\":\"uint256\"}],\"name\":\"PoolsNewPerAnnumPercents\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"KryptoinETFTokenStakeRewards","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000233148c349b66777357ff46dd0bd77987e346015","Library":"","SwarmSource":"bzzr://4e662b7fd8eadb1dde39860ecd8e551021475e9503035a6239d9665a370b7371"}]}