{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.5.1;\r\ncontract PoWHr{\r\n\t// scaleFactor is used to convert Ether into bonds and vice-versa: they're of different\r\n\t// orders of magnitude, hence the need to bridge between the two.\r\n\tuint256 constant scaleFactor = 0x10000000000000000;\r\n\r\n\tint constant crr_n = 1;\r\n\tint constant crr_d = 2;\r\n\r\n\tint constant public price_coeff = -0x1337FA66607BADA55;\r\n\r\n\t// Typical values that we have to declare.\r\n\tstring constant public name = \"Bond\";\r\n\tstring constant public symbol = \"BOND\";\r\n\tuint8 constant public decimals = 12;\r\n\r\n\t// Array between each address and their number of bonds.\r\n\tmapping(address => uint256) public hodlBonds;\r\n\t// For calculating resolves minted\r\n\tmapping(address => uint256) public avgFactor_ethSpent;\r\n\t// For calculating hodl multiplier that factors into resolves minted\r\n\tmapping(address => uint256) public avgFactor_buyInTimeSum;\r\n\t// Array between each address and their number of resolves being staked.\r\n\tmapping(address => uint256) public resolveWeight;\r\n\r\n\t// Array between each address and how much Ether has been paid out to it.\r\n\t// Note that this is scaled by the scaleFactor variable.\r\n\tmapping(address => int256) public payouts;\r\n\r\n\t// Variable tracking how many bonds are in existence overall.\r\n\tuint256 public _totalSupply;\r\n\r\n\t// The total number of resolves being staked in this contract\r\n\tuint256 public dissolvingResolves;\r\n\t// The total number of resolves burned for a return of ETH(withdraw) or Bonds(reinvest)\r\n\tuint256 public dissolved;\r\n\r\n\t// For Current contract balance\r\n\tuint public contractBalance;\r\n\r\n\t// Easing in the fee. Make the fee reasonable as the contract is scaling to the size of the ecosystem\r\n\tuint256 public buySum;\r\n\tuint256 public sellSum;\r\n\r\n\t// For calculating the hodl multiplier. Weighted average release time\r\n\tuint public avgFactor_releaseWeight;\r\n\tuint public avgFactor_releaseTimeSum;\r\n\t// base time on when the contract was created\r\n\tuint public genesis;\r\n\r\n\t// Aggregate sum of all payouts.\r\n\t// Note that this is scaled by the scaleFactor variable.\r\n\tint256 totalPayouts;\r\n\r\n\t// Variable tracking how much Ether each token is currently worth.\r\n\t// Note that this is scaled by the scaleFactor variable.\r\n\tuint256 earningsPerResolve;\r\n\r\n\t//The resolve token contract\r\n\tResolveToken public resolveToken;\r\n\r\n\tconstructor() public{\r\n\t\tgenesis = now;\r\n\t\tresolveToken = new ResolveToken( address(this) );\r\n\t}\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\tfunction getResolveContract() public view returns(address){ return address(resolveToken); }\r\n\t// Returns the number of bonds currently held by _owner.\r\n\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\r\n\t\treturn hodlBonds[_owner];\r\n\t}\r\n\r\n\tfunction fluxFee(uint paidAmount) public view returns (uint fee) {\r\n\t\tif (dissolvingResolves == 0)\r\n\t\t\treturn 0;\r\n\t\t\r\n\t\tuint totalResolveSupply = resolveToken.totalSupply() - dissolved;\r\n\t\treturn paidAmount * dissolvingResolves / totalResolveSupply * sellSum / buySum;\r\n\t}\r\n\r\n\t// Converts the Ether accrued as resolveEarnings back into bonds without having to\r\n\t// withdraw it first. Saves on gas and potential price spike loss.\r\n\tevent Reinvest( address indexed addr, uint256 reinvested, uint256 dissolved, uint256 bonds, uint256 resolveTax);\r\n\tfunction reinvestEarnings(uint amountFromEarnings) public returns(uint,uint){\r\n\t\t// Retrieve the resolveEarnings associated with the address the request came from.\t\t\r\n\t\tuint totalEarnings = resolveEarnings(msg.sender);\r\n\t\trequire(amountFromEarnings <= totalEarnings, \"the amount exceeds total earnings\");\r\n\t\tuint oldWeight = resolveWeight[msg.sender];\r\n\t\tresolveWeight[msg.sender] = oldWeight *  (totalEarnings - amountFromEarnings) / totalEarnings;\r\n\t\tuint weightDiff = oldWeight - resolveWeight[msg.sender];\r\n\t\tdissolved += weightDiff;\r\n\t\tdissolvingResolves -= weightDiff;\r\n\r\n\t\t// For maintaing payout invariance\r\n\t\tint resolvePayoutDiff  = (int256) (earningsPerResolve * weightDiff);\r\n\r\n\t\tpayouts[msg.sender] += (int256) (amountFromEarnings * scaleFactor) - resolvePayoutDiff;\r\n\r\n\t\ttotalPayouts += (int256) (amountFromEarnings * scaleFactor) - resolvePayoutDiff;\r\n\r\n\t\t// Assign balance to a new variable.\r\n\t\tuint value_ = (uint) (amountFromEarnings);\r\n\r\n\t\t// If your resolveEarnings are worth less than 1 szabo, abort.\r\n\t\tif (value_ < 0.000001 ether)\r\n\t\t\trevert();\r\n\r\n\t\t// msg.sender is the address of the caller.\r\n\t\taddress sender = msg.sender;\r\n\r\n\t\t// Calculate the fee\r\n\t\tuint fee = fluxFee(value_);\r\n\r\n\t\t// The amount of Ether used to purchase new bonds for the caller\r\n\t\tuint numEther = value_ - fee;\r\n\t\tbuySum += numEther;\r\n\r\n\t\t//resolve reward tracking stuff\r\n\t\tuint currentTime = NOW();\r\n\t\tavgFactor_ethSpent[msg.sender] += numEther;\r\n\t\tavgFactor_buyInTimeSum[msg.sender] += currentTime * scaleFactor * numEther;\r\n\r\n\t\t// The number of bonds which can be purchased for numEther.\r\n\t\tuint createdBonds = calculateBondsFromReinvest(numEther, amountFromEarnings);\r\n\r\n\t\t// the variable storing the amount to be paid to stakers\r\n\t\tuint resolveFee;\r\n\r\n\t\t// Check if we have bonds in existence\r\n\t\tif (_totalSupply > 0 && fee > 0) {\r\n\t\t\tresolveFee = fee * scaleFactor;\r\n\r\n\t\t\t// Fee is distributed to all existing resolve stakers before the new bonds are purchased.\r\n\t\t\t// rewardPerResolve is the amount(ETH) gained per resolve token from this purchase.\r\n\t\t\tuint rewardPerResolve = resolveFee / dissolvingResolves;\r\n\r\n\t\t\t// The Ether value per token is increased proportionally.\r\n\t\t\tearningsPerResolve += rewardPerResolve;\r\n\t\t}\r\n\r\n\t\t// Add the createdBonds to the total supply.\r\n\t\t_totalSupply += createdBonds;\r\n\r\n\t\t// Assign the bonds to the balance of the buyer.\r\n\t\thodlBonds[sender] += createdBonds;\r\n\r\n\t\temit Reinvest(msg.sender, value_, weightDiff, createdBonds, resolveFee);\r\n\t\treturn (createdBonds, weightDiff);\r\n\t}\r\n\r\n\t// Sells your bonds for Ether\r\n\tfunction sellAllBonds() public {\r\n\t\tsell( balanceOf(msg.sender) );\r\n\t}\r\n\tfunction sellBonds(uint amount) public returns(uint,uint){\r\n\t\tuint balance = balanceOf(msg.sender);\r\n\t\trequire(balance >= amount, \"Amount is more than balance\");\r\n\t\tuint returned_eth;\r\n\t\tuint returned_resolves;\r\n\t\t(returned_eth, returned_resolves) = sell(amount);\r\n\t\treturn (returned_eth, returned_resolves);\r\n\t}\r\n\r\n\t// Big red exit button to pull all of a holder's Ethereum value from the contract\r\n\tfunction getMeOutOfHere() public {\r\n\t\tsellAllBonds();\r\n\t\twithdraw( resolveEarnings(msg.sender) );\r\n\t}\r\n\r\n\t// Gatekeeper function to check if the amount of Ether being sent isn't too small\r\n\tfunction fund() payable public returns(uint){\r\n\t\tuint bought;\r\n\t\tif (msg.value > 0.000001 ether) {\r\n\t\t  \tcontractBalance += msg.value;\r\n\t\t\tbought = buy();\r\n\t\t} else {\r\n\t\t\trevert();\r\n\t\t}\r\n\t\treturn bought;\r\n  \t}\r\n\r\n    // Function that returns the (dynamic) pricing for buys, sells and fee\r\n\tfunction pricing(uint scale) public view returns (uint buyPrice, uint sellPrice, uint fee) {\r\n\t\tuint buy_eth = scaleFactor * getPriceForBonds( scale, true) / ( scaleFactor - fluxFee(scaleFactor) ) ;\r\n        uint sell_eth = getPriceForBonds(scale, false);\r\n        sell_eth -= fluxFee(sell_eth);\r\n        return ( buy_eth, sell_eth, fluxFee(scale) );\r\n    }\r\n\r\n    // For calculating the price \r\n\tfunction getPriceForBonds(uint256 bonds, bool upDown) public view returns (uint256 price) {\r\n\t\tuint reserveAmount = reserve();\r\n\r\n\t\tif(upDown){\r\n\t\t\tuint x = fixedExp((fixedLog(_totalSupply + bonds) - price_coeff) * crr_d/crr_n);\r\n\t\t\treturn x - reserveAmount;\r\n\t\t}else{\r\n\t\t\tuint x = fixedExp((fixedLog(_totalSupply - bonds) - price_coeff) * crr_d/crr_n);\r\n\t\t\treturn reserveAmount - x;\r\n\t\t}\r\n\t}\r\n\r\n\t// Calculate the current resolveEarnings associated with the caller address. This is the net result\r\n\t// of multiplying the number of resolves held by their current value in Ether and subtracting the\r\n\t// Ether that has already been paid out.\r\n\tfunction resolveEarnings(address _owner) public view returns (uint256 amount) {\r\n\t\treturn (uint256) ((int256)(earningsPerResolve * resolveWeight[_owner]) - payouts[_owner]) / scaleFactor;\r\n\t}\r\n\r\n\t// Internal balance function, used to calculate the dynamic reserve value.\r\n\tfunction balance() internal view returns (uint256 amount) {\r\n\t\t// msg.value is the amount of Ether sent by the transaction.\r\n\t\treturn contractBalance - msg.value;\r\n\t}\r\n\tevent Buy( address indexed addr, uint256 spent, uint256 bonds, uint256 resolveTax);\r\n\tfunction buy() internal returns(uint){\r\n\t\t// Any transaction of less than 1 szabo is likely to be worth less than the gas used to send it.\r\n\t\tif ( msg.value < 0.000001 ether )\r\n\t\t\trevert();\r\n\r\n\t\t// Calculate the fee\r\n\t\tuint fee = fluxFee(msg.value);\r\n\r\n\t\t// The amount of Ether used to purchase new bonds for the caller.\r\n\t\tuint numEther = msg.value - fee;\r\n\t\tbuySum += numEther;\r\n\r\n\t\t//resolve reward tracking stuff\r\n\t\tuint currentTime = NOW();\r\n\t\tavgFactor_ethSpent[msg.sender] += numEther;\r\n\t\tavgFactor_buyInTimeSum[msg.sender] += currentTime * scaleFactor * numEther;\r\n\r\n\t\t// The number of bonds which can be purchased for numEther.\r\n\t\tuint createdBonds = getBondsForEther(numEther);\r\n\r\n\t\t// Add the createdBonds to the total supply.\r\n\t\t_totalSupply += createdBonds;\r\n\r\n\t\t// Assign the bonds to the balance of the buyer.\r\n\t\thodlBonds[msg.sender] += createdBonds;\r\n\r\n\t\t// Check if we have bonds in existence\r\n\t\tuint resolveFee;\r\n\t\tif (_totalSupply > 0 && fee > 0) {\r\n\t\t\tresolveFee = fee * scaleFactor;\r\n\r\n\t\t\t// Fee is distributed to all existing resolve holders before the new bonds are purchased.\r\n\t\t\t// rewardPerResolve is the amount gained per resolve token from this purchase.\r\n\t\t\tuint rewardPerResolve = resolveFee / dissolvingResolves;\r\n\r\n\t\t\t// The Ether value per resolve is increased proportionally.\r\n\t\t\tearningsPerResolve += rewardPerResolve;\r\n\t\t}\r\n\t\temit Buy( msg.sender, msg.value, createdBonds, resolveFee);\r\n\t\treturn createdBonds;\r\n\t}\r\n\tfunction NOW() public view returns(uint time){\r\n\t\treturn now - genesis;\r\n\t}\r\n\tfunction avgHodl() public view returns(uint hodlTime){\r\n\t\treturn avgFactor_releaseTimeSum / avgFactor_releaseWeight / scaleFactor;\r\n\t}\r\n\tfunction getReturnsForBonds(address addr, uint bondsReleased) public view returns(uint etherValue, uint mintedResolves, uint new_releaseTimeSum, uint new_releaseWeight, uint initialInput_ETH){\r\n\t\tuint output_ETH = getEtherForBonds(bondsReleased);\r\n\t\tuint input_ETH = avgFactor_ethSpent[addr] * bondsReleased / hodlBonds[addr];\r\n\t\t// hodl multiplier. because if you don't hodl at all, you shouldn't be rewarded resolves.\r\n\t\t// and the multiplier you get for hodling needs to be relative to the average hodl\r\n\t\tuint buyInTime = avgFactor_buyInTimeSum[addr] / avgFactor_ethSpent[addr];\r\n\t\tuint cashoutTime = NOW()*scaleFactor - buyInTime;\r\n\t\tuint releaseTimeSum = avgFactor_releaseTimeSum + cashoutTime*input_ETH/scaleFactor*buyInTime;\r\n\t\tuint releaseWeight = avgFactor_releaseWeight + input_ETH*buyInTime/scaleFactor;\r\n\t\tuint avgCashoutTime = releaseTimeSum/releaseWeight;\r\n\t\treturn (output_ETH, input_ETH * cashoutTime / avgCashoutTime * input_ETH / output_ETH, releaseTimeSum, releaseWeight, input_ETH);\r\n\t}\r\n\tevent Sell( address indexed addr, uint256 bondsSold, uint256 cashout, uint256 resolves, uint256 resolveTax, uint256 initialCash);\r\n\tfunction sell(uint256 amount) internal returns(uint eth, uint resolves){\r\n\t  \t// Calculate the amount of Ether & Resolves that the holder's bonds sell for at the current sell price.\r\n\t\tuint numEthersBeforeFee;\r\n\t\tuint mintedResolves;\r\n\t\tuint releaseTimeSum;\r\n\t\tuint releaseWeight;\r\n\t\tuint initialInput_ETH;\r\n\t\t(numEthersBeforeFee,mintedResolves,releaseTimeSum,releaseWeight,initialInput_ETH) = getReturnsForBonds(msg.sender, amount);\r\n\r\n\t\t// magic distribution\r\n\t\tresolveToken.mint(msg.sender, mintedResolves);\r\n\r\n\t\t// update weighted average cashout time\r\n\t\tavgFactor_releaseTimeSum = releaseTimeSum;\r\n\t\tavgFactor_releaseWeight = releaseWeight;\r\n\r\n\t\t// reduce the amount of \"eth spent\" based on the percentage of bonds being sold back into the contract\r\n\t\tavgFactor_ethSpent[msg.sender] -= initialInput_ETH;\r\n\t\t// reduce the \"buyInTime\" sum that's used for average buy in time\r\n\t\tavgFactor_buyInTimeSum[msg.sender] = avgFactor_buyInTimeSum[msg.sender] * (hodlBonds[msg.sender] - amount) / hodlBonds[msg.sender];\r\n\t\t\r\n\t\t// calculate the fee\r\n\t    uint fee = fluxFee(numEthersBeforeFee);\r\n\r\n\t\t// Net Ether for the seller after the fee has been subtracted.\r\n\t    uint numEthers = numEthersBeforeFee - fee;\r\n\r\n\t    //updating the numerator of the fee-easing factor\r\n\t    sellSum += initialInput_ETH;\r\n\r\n\t\t// Burn the bonds which were just sold from the total supply.\r\n\t\t_totalSupply -= amount;\r\n\r\n\t    // Remove the bonds from the balance of the buyer.\r\n\t    hodlBonds[msg.sender] -= amount;\r\n\r\n\r\n\t\t// Check if we have bonds in existence\r\n\t\tuint resolveFee;\r\n\t\tif (_totalSupply > 0 && dissolvingResolves > 0){\r\n\t\t\t// Scale the Ether taken as the selling fee by the scaleFactor variable.\r\n\t\t\tresolveFee = fee * scaleFactor;\r\n\r\n\t\t\t// Fee is distributed to all remaining resolve holders.\r\n\t\t\t// rewardPerResolve is the amount gained per resolve thanks to this sell.\r\n\t\t\tuint rewardPerResolve = resolveFee / dissolvingResolves;\r\n\r\n\t\t\t// The Ether value per resolve is increased proportionally.\r\n\t\t\tearningsPerResolve += rewardPerResolve;\r\n\t\t}\r\n\t\t\r\n\t\t// Send the ethereum to the address that requested the sell.\r\n\t\tcontractBalance -= numEthers;\r\n\t\tmsg.sender.transfer(numEthers);\r\n\t\temit Sell( msg.sender, amount, numEthers, mintedResolves, resolveFee, initialInput_ETH);\r\n\t\treturn (numEthers, mintedResolves);\r\n\t}\r\n\r\n\t// Dynamic value of Ether in reserve, according to the CRR requirement.\r\n\tfunction reserve() public view returns (uint256 amount) {\r\n\t\treturn balance() -\r\n\t\t\t ((uint256) ((int256) (earningsPerResolve * dissolvingResolves) - totalPayouts) / scaleFactor);\r\n\t}\r\n\r\n\t// Calculates the number of bonds that can be bought for a given amount of Ether, according to the\r\n\t// dynamic reserve and _totalSupply values (derived from the buy and sell prices).\r\n\tfunction getBondsForEther(uint256 ethervalue) public view returns (uint256 bonds) {\r\n\t\tuint new_totalSupply = fixedExp( fixedLog(reserve() + ethervalue ) * crr_n/crr_d + price_coeff);\r\n\t\tif (new_totalSupply < _totalSupply)\r\n\t\t\treturn 0;\r\n\t\telse\r\n\t\t\treturn new_totalSupply - _totalSupply;\r\n\t}\r\n\r\n\t// Semantically similar to getBondsForEther, but subtracts the callers balance from the amount of Ether returned for conversion.\r\n\tfunction calculateBondsFromReinvest(uint256 ethervalue, uint256 subvalue) public view returns (uint256 bondTokens) {\r\n\t\treturn fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff)- _totalSupply;\r\n\t}\r\n\r\n\t// Converts a number bonds into an Ether value.\r\n\tfunction getEtherForBonds(uint256 bondTokens) public view returns (uint256 ethervalue) {\r\n\t\t// How much reserve Ether do we have left in the contract?\r\n\t\tuint reserveAmount = reserve();\r\n\r\n\t\t// If you're the Highlander (or bagholder), you get The Prize. Everything left in the vault.\r\n\t\tif (bondTokens == _totalSupply)\r\n\t\t\treturn reserveAmount;\r\n\r\n\t\t// If there would be excess Ether left after the transaction this is called within, return the Ether\r\n\t\t// corresponding to the equation in Dr Jochen Hoenicke's original Ponzi paper, which can be found\r\n\t\t// at https://test.jochen-hoenicke.de/eth/ponzitoken/ in the third equation, with the CRR numerator\r\n\t\t// and denominator altered to 1 and 2 respectively.\r\n\t\tuint x = fixedExp((fixedLog(_totalSupply - bondTokens) - price_coeff) * crr_d/crr_n);\r\n\t\tif (x > reserveAmount)\r\n\t\t\treturn 0;\r\n\r\n\t\treturn reserveAmount - x;\r\n\t}\r\n\r\n\t// You don't care about these, but if you really do they're hex values for\r\n\t// co-efficients used to simulate approximations of the log and exp functions.\r\n\t\tint256  constant one        = 0x10000000000000000;\r\n\t\tuint256 constant sqrt2      = 0x16a09e667f3bcc908;\r\n\t\tuint256 constant sqrtdot5   = 0x0b504f333f9de6484;\r\n\t\tint256  constant ln2        = 0x0b17217f7d1cf79ac;\r\n\t\tint256  constant ln2_64dot5 = 0x2cb53f09f05cc627c8;\r\n\t\tint256  constant c1         = 0x1ffffffffff9dac9b;\r\n\t\tint256  constant c3         = 0x0aaaaaaac16877908;\r\n\t\tint256  constant c5         = 0x0666664e5e9fa0c99;\r\n\t\tint256  constant c7         = 0x049254026a7630acf;\r\n\t\tint256  constant c9         = 0x038bd75ed37753d68;\r\n\t\tint256  constant c11        = 0x03284a0c14610924f;\r\n\r\n\t// The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11\r\n\t// approximates the function log(1+x)-log(1-x)\r\n\t// Hence R(s) = log((1+s)/(1-s)) = log(a)\r\n\tfunction fixedLog(uint256 a) internal pure returns (int256 log) {\r\n\t\tint32 scale = 0;\r\n\t\twhile (a > sqrt2) {\r\n\t\t\ta /= 2;\r\n\t\t\tscale++;\r\n\t\t}\r\n\t\twhile (a <= sqrtdot5) {\r\n\t\t\ta *= 2;\r\n\t\t\tscale--;\r\n\t\t}\r\n\t\tint256 s = (((int256)(a) - one) * one) / ((int256)(a) + one);\r\n\t\tint z = (s*s) / one;\r\n\t\treturn scale * ln2 +\r\n\t\t\t(s*(c1 + (z*(c3 + (z*(c5 + (z*(c7 + (z*(c9 + (z*c11/one))\r\n\t\t\t\t/one))/one))/one))/one))/one);\r\n\t}\r\n\r\n\tint256 constant c2 =  0x02aaaaaaaaa015db0;\r\n\tint256 constant c4 = -0x000b60b60808399d1;\r\n\tint256 constant c6 =  0x0000455956bccdd06;\r\n\tint256 constant c8 = -0x000001b893ad04b3a;\r\n\r\n\t// The polynomial R = 2 + c2*x^2 + c4*x^4 + ...\r\n\t// approximates the function x*(exp(x)+1)/(exp(x)-1)\r\n\t// Hence exp(x) = (R(x)+x)/(R(x)-x)\r\n\tfunction fixedExp(int256 a) internal pure returns (uint256 exp) {\r\n\t\tint256 scale = (a + (ln2_64dot5)) / ln2 - 64;\r\n\t\ta -= scale*ln2;\r\n\t\tint256 z = (a*a) / one;\r\n\t\tint256 R = ((int256)(2) * one) +\r\n\t\t\t(z*(c2 + (z*(c4 + (z*(c6 + (z*c8/one))/one))/one))/one);\r\n\t\texp = (uint256) (((R + a) * one) / (R - a));\r\n\t\tif (scale >= 0)\r\n\t\t\texp <<= scale;\r\n\t\telse\r\n\t\t\texp >>= -scale;\r\n\t\treturn exp;\r\n\t}\r\n\r\n\t// This allows you to buy bonds by sending Ether directly to the smart contract\r\n\t// without including any transaction data (useful for, say, mobile wallet apps).\r\n\tfunction () payable external {\r\n\t\t// msg.value is the amount of Ether sent by the transaction.\r\n\t\tif (msg.value > 0) {\r\n\t\t\tfund();\r\n\t\t} else {\r\n\t\t\twithdraw( resolveEarnings(msg.sender) );\r\n\t\t}\r\n\t}\r\n\r\n\t// Allow contract to accept resolve tokens\r\n\tevent StakeResolves( address indexed addr, uint256 amountStaked, bytes _data );\r\n\tfunction tokenFallback(address from, uint value, bytes calldata _data) external{\r\n\t\tif(msg.sender == address(resolveToken) ){\r\n\t\t\tresolveWeight[from] += value;\r\n\t\t\tdissolvingResolves += value;\r\n\r\n\t\t\t// Update the payout array so that the \"resolve shareholder\" cannot claim resolveEarnings on previous staked resolves.\r\n\t\t\tint payoutDiff  = (int256) (earningsPerResolve * value);\r\n\r\n\t\t\t// Then we update the payouts array for the \"resolve shareholder\" with this amount\r\n\t\t\tpayouts[from] += payoutDiff;\r\n\r\n\t\t\t// And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\n\t\t\ttotalPayouts += payoutDiff;\r\n\t\t\temit StakeResolves(from, value, _data);\r\n\t\t}else{\r\n\t\t\trevert(\"no want\");\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Withdraws resolveEarnings held by the caller sending the transaction, updates\r\n\t// the requisite global variables, and transfers Ether back to the caller.\r\n\tevent Withdraw( address indexed addr, uint256 earnings, uint256 dissolve );\r\n\tfunction withdraw(uint amount) public returns(uint){\r\n\t\t// Retrieve the resolveEarnings associated with the address the request came from.\r\n\t\tuint totalEarnings = resolveEarnings(msg.sender);\r\n\t\trequire(amount <= totalEarnings, \"the amount exceeds total earnings\");\r\n\t\tuint oldWeight = resolveWeight[msg.sender];\r\n\t\tresolveWeight[msg.sender] = oldWeight * (totalEarnings - amount) / totalEarnings;\r\n\t\tuint weightDiff = oldWeight - resolveWeight[msg.sender];\r\n\t\tdissolved += weightDiff;\r\n\t\tdissolvingResolves -= weightDiff;\r\n\r\n\t\t//something about invariance\r\n\t\tint resolvePayoutDiff  = (int256) (earningsPerResolve * weightDiff);\r\n\r\n\t\tpayouts[msg.sender] += (int256) (amount * scaleFactor) - resolvePayoutDiff;\r\n\r\n\t\t// Increase the total amount that's been paid out to maintain invariance.\r\n\t\ttotalPayouts += (int256) (amount * scaleFactor) - resolvePayoutDiff;\r\n\r\n\t\t// Send the resolveEarnings to the address that requested the withdraw.\r\n\t\tcontractBalance -= amount;\r\n\t\tmsg.sender.transfer(amount);\r\n\t\temit Withdraw( msg.sender, amount, weightDiff);\r\n\t\treturn weightDiff;\r\n\t}\r\n\tevent PullResolves( address indexed addr, uint256 pulledResolves, uint256 forfeiture);\r\n\tfunction pullResolves(uint amount) public{\r\n\t\trequire(amount <= resolveWeight[msg.sender], \"that amount is too large\");\r\n\t\t//something about invariance\r\n\r\n\t\tuint forfeitedEarnings  =  resolveEarnings(msg.sender)  * amount / resolveWeight[msg.sender] * scaleFactor;\r\n\t\tresolveWeight[msg.sender] -= amount;\r\n\t\tdissolvingResolves -= amount;\r\n\t\t// The Ether value per token is increased proportionally.\r\n\t\tearningsPerResolve += forfeitedEarnings / dissolvingResolves;\r\n\t\tresolveToken.transfer(msg.sender, amount);\r\n\t\temit PullResolves( msg.sender, amount, forfeitedEarnings / scaleFactor);\r\n\t}\r\n\r\n\tevent BondTransfer(address from, address to, uint amount);\r\n\tfunction bondTransfer( address to, uint amount ) public{\r\n\t\t//attack someone's resolve potential by sending them some love\r\n\t\taddress sender = msg.sender;\r\n\t\tuint totalBonds = hodlBonds[sender];\r\n\t\trequire(amount <= totalBonds, \"amount exceeds hodlBonds\");\r\n\t\tuint ethSpent = avgFactor_ethSpent[sender] * amount / totalBonds;\r\n\t\tuint buyInTimeSum = avgFactor_buyInTimeSum[sender] * amount / totalBonds;\r\n\t\tavgFactor_ethSpent[sender] -= ethSpent;\r\n\t\tavgFactor_buyInTimeSum[sender] -= buyInTimeSum;\r\n\t\thodlBonds[sender] -= amount;\r\n\t\tavgFactor_ethSpent[to] += ethSpent;\r\n\t\tavgFactor_buyInTimeSum[to] += buyInTimeSum;\r\n\t\thodlBonds[to] += amount;\r\n\t\temit BondTransfer(sender, to, amount);\r\n\t}\r\n}\r\n\r\ncontract ERC223ReceivingContract{\r\n    function tokenFallback(address _from, uint _value, bytes calldata _data) external;\r\n}\r\n\r\ncontract ResolveToken{\r\n\taddress pyramid;\r\n\r\n\tconstructor(address _pyramid) public{\r\n\t\tpyramid = _pyramid;\r\n\t}\r\n\r\n\tmodifier pyramidOnly{\r\n\t  require(msg.sender == pyramid);\r\n\t  _;\r\n    }\r\n\r\n\tevent Transfer(\r\n\t\taddress indexed from,\r\n\t\taddress indexed to,\r\n\t\tuint256 amount,\r\n\t\tbytes data\r\n\t);\r\n\r\n\tevent Mint(\r\n\t\taddress indexed addr,\r\n\t\tuint256 amount\r\n\t);\r\n\r\n\tmapping(address => uint) balances;\r\n\tmapping(address => mapping(address => uint)) approvals;\r\n\r\n\tstring public name = \"Resolve\";\r\n    string public symbol = \"PoWHr\";\r\n    uint8 constant public decimals = 18;\r\n\tuint256 private _totalSupply;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\tfunction mint(address _address, uint _value) public pyramidOnly(){\r\n\t\tbalances[_address] += _value;\r\n\t\t_totalSupply += _value;\r\n\t\temit Mint(_address, _value);\r\n\t}\r\n\r\n\t// Function that is called when a user or another contract wants to transfer funds .\r\n\tfunction transfer(address _to, uint _value, bytes memory _data) public returns (bool success) {\r\n\t\tif (balanceOf(msg.sender) < _value) revert();\r\n\t\tif(isContract(_to)) {\r\n\t\t\treturn transferToContract(_to, _value, _data);\r\n\t\t}else{\r\n\t\t\treturn transferToAddress(_to, _value, _data);\r\n\t\t}\r\n\t}\r\n\r\n\t// Standard function transfer similar to ERC20 transfer with no _data .\r\n\t// Added due to backwards compatibility reasons .\r\n\tfunction transfer(address _to, uint _value) public returns (bool success) {\r\n\t\tif (balanceOf(msg.sender) < _value) revert();\r\n\t\t//standard function transfer similar to ERC20 transfer with no _data\r\n\t\t//added due to backwards compatibility reasons\r\n\t\tbytes memory empty;\r\n\t\tif(isContract(_to)){\r\n\t\t\treturn transferToContract(_to, _value, empty);\r\n\t\t}else{\r\n\t\t\treturn transferToAddress(_to, _value, empty);\r\n\t\t}\r\n\t}\r\n\r\n\t//assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n\tfunction isContract(address _addr) public view returns (bool is_contract) {\r\n\t\tuint length;\r\n\t\tassembly {\r\n\t\t\t//retrieve the size of the code on target address, this needs assembly\r\n\t\t\tlength := extcodesize(_addr)\r\n\t\t}\r\n\t\tif(length>0) {\r\n\t\t\treturn true;\r\n\t\t}else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t//function that is called when transaction target is an address\r\n\tfunction transferToAddress(address _to, uint _value, bytes memory _data) private returns (bool success) {\r\n\t\tmoveTokens(msg.sender,_to,_value);\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//function that is called when transaction target is a contract\r\n\tfunction transferToContract(address _to, uint _value, bytes memory _data) private returns (bool success) {\r\n\t\tmoveTokens(msg.sender, _to, _value);\r\n\t\tERC223ReceivingContract reciever = ERC223ReceivingContract(_to);\r\n\t\treciever.tokenFallback(msg.sender, _value, _data);\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction moveTokens(address _from, address _to, uint _amount) private{\r\n\t\tbalances[_from] -= _amount;\r\n\t\tbalances[_to] += _amount;\r\n\t}\r\n\r\n    function balanceOf(address _owner) public view returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(address src, address guy) public view returns (uint) {\r\n        return approvals[src][guy];\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad) public returns (bool){\r\n        require(approvals[src][msg.sender] >=  wad, \"That amount is not approved\");\r\n        require(balances[src] >=  wad, \"That amount is not available from this wallet\");\r\n        if (src != msg.sender) {\r\n            approvals[src][msg.sender] -=  wad;\r\n        }\r\n\t\tmoveTokens(src,dst,wad);\r\n\r\n        bytes memory empty;\r\n        emit Transfer(src, dst, wad, empty);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        approvals[msg.sender][guy] = wad;\r\n\r\n        emit Approval(msg.sender, guy, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bondTokens\",\"type\":\"uint256\"}],\"name\":\"getEtherForBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethervalue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"}],\"name\":\"fluxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"avgFactor_ethSpent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pullResolves\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dissolvingResolves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethervalue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subvalue\",\"type\":\"uint256\"}],\"name\":\"calculateBondsFromReinvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bondTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"resolveEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"avgFactor_buyInTimeSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"payouts\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"scale\",\"type\":\"uint256\"}],\"name\":\"pricing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"buyPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bondsReleased\",\"type\":\"uint256\"}],\"name\":\"getReturnsForBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"etherValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintedResolves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_releaseTimeSum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_releaseWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialInput_ETH\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buySum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getResolveContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NOW\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hodlBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethervalue\",\"type\":\"uint256\"}],\"name\":\"getBondsForEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bonds\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolveToken\",\"outputs\":[{\"internalType\":\"contract ResolveToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"genesis\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sellAllBonds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price_coeff\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMeOutOfHere\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bonds\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"upDown\",\"type\":\"bool\"}],\"name\":\"getPriceForBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"avgFactor_releaseWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountFromEarnings\",\"type\":\"uint256\"}],\"name\":\"reinvestEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"avgHodl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hodlTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dissolved\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"resolveWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"avgFactor_releaseTimeSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sellBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bondTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dissolved\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolveTax\",\"type\":\"uint256\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolveTax\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondsSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cashout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolves\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolveTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialCash\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"StakeResolves\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earnings\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dissolve\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pulledResolves\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"forfeiture\",\"type\":\"uint256\"}],\"name\":\"PullResolves\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BondTransfer\",\"type\":\"event\"}]","ContractName":"PoWHr","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://5628d58443cf0a52b58a2aa34cfba85383e349201d6049bfd273f9c36a20bdc4"}]}