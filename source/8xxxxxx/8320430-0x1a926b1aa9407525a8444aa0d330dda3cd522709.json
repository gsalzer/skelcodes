{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.6.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ncontract NSTTeamLock{\r\n    address public owner;\r\n    modifier onlyOwner() {\r\n      require(msg.sender == owner);\r\n     _;\r\n    }\r\n    function transferOwnership(address newOwner) onlyOwner public{\r\n        if (newOwner != address(0)) {\r\n         owner = newOwner;\r\n        }\r\n    }\r\n    using SafeMath for uint256;\r\n    IERC20 token ;\r\n    uint256 public TeamLockTime = 365 days;\r\n    uint256 public TotalLock;\r\n    uint256 private mouth = 30 days;\r\n    address public TeamOwner;\r\n    \r\n    \r\n    struct lockBody{\r\n        uint8 lockType;\r\n        uint256 unlockTime;\r\n        uint256 value;\r\n        uint256 getValue;\r\n        uint256 getTime;\r\n        uint256 firstRelease;\r\n        uint256 release;\r\n        bool isFirst;\r\n        address tokenAddr;\r\n    }\r\n\r\n    mapping (address => lockBody) public addressOf;\r\n    mapping (address => uint256) public totalLockOf;\r\n    \r\n    constructor(address _token,address _TeamOwner) public {\r\n        token = IERC20(_token);\r\n        owner = msg.sender;\r\n        TeamOwner = _TeamOwner;\r\n    }\r\n    \r\n    function allotTeamToken() public onlyOwner {\r\n        uint256 _value = 400000000*10**18;\r\n        uint256 _eyValue = 40000000*10**18;\r\n        uint256 balanceOfthis = token.balanceOf(address(this));\r\n        require(balanceOfthis.sub(TotalLock)>=_value,\"代币余额不足\");\r\n        require(TeamOwner!=address(0),\"权限地址不够\");\r\n        uint256 nowLockTime = uint256(now).add(TeamLockTime);\r\n        addressOf[TeamOwner] = lockBody(1,nowLockTime,_value,0,nowLockTime,_eyValue,_eyValue,true,address(token));\r\n        TotalLock = TotalLock.add(_value);\r\n        totalLockOf[TeamOwner] = totalLockOf[TeamOwner].add(_value);\r\n    }\r\n    \r\n    function setToken(address _token) public onlyOwner {\r\n        token = IERC20(_token);\r\n    }\r\n    \r\n    function changeOwner(address _addr) public onlyOwner {\r\n            TeamOwner = _addr;\r\n    }\r\n    \r\n    function releaseToken() public onlyOwner returns(bool success){\r\n        require(TeamOwner!=address(0));\r\n        lockBody memory _body = addressOf[TeamOwner];\r\n        require(now>=_body.unlockTime);\r\n        require(_body.value>0);\r\n        require(_body.value>_body.getValue);\r\n        uint256 _reValue = _body.value.sub(_body.getValue) ;\r\n        uint256 _day = (now.sub(_body.getTime)).div(mouth);\r\n        uint256 _value;\r\n        if(_body.isFirst){\r\n            _value = _value.add(_body.firstRelease) ;\r\n            addressOf[TeamOwner].isFirst=false;\r\n            _value = _value.add(_body.release.mul(_day));\r\n        }else{\r\n            _value = _value.add(_body.release.mul(_day));\r\n        }\r\n        if(_reValue<=_value){\r\n            _value=_reValue;\r\n        }\r\n        addressOf[TeamOwner].getTime = addressOf[TeamOwner].getTime.add(_day.mul(mouth)) ;\r\n        addressOf[TeamOwner].getValue = addressOf[TeamOwner].getValue.add(_value);\r\n        TotalLock = TotalLock.sub(_value);\r\n        totalLockOf[TeamOwner] = totalLockOf[TeamOwner].sub(_value);\r\n        IERC20 _token = IERC20(_body.tokenAddr);\r\n        _token.transfer(TeamOwner,_value);\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TeamOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressOf\",\"outputs\":[{\"name\":\"lockType\",\"type\":\"uint8\"},{\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"getValue\",\"type\":\"uint256\"},{\"name\":\"getTime\",\"type\":\"uint256\"},{\"name\":\"firstRelease\",\"type\":\"uint256\"},{\"name\":\"release\",\"type\":\"uint256\"},{\"name\":\"isFirst\",\"type\":\"bool\"},{\"name\":\"tokenAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TotalLock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TeamLockTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allotTeamToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalLockOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseToken\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_TeamOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"NSTTeamLock","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002fad4056b86990f2045c2963f65abf7b74d50ef200000000000000000000000054f173532b8a366f597d8e4a188ba67a531e323d","Library":"","SwarmSource":"bzzr://fdc664f9408d2ad915bd5483b0c229e77e07c80defc0a7b5dbcc06770263df89"}]}