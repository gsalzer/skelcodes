{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/// @title A Queue for Players\r\n/// @author Jason Fabrit @bugbytesinc\r\n/// @notice Implements a helper contract for first-in-first-out\r\n/// queue of players having identical moves.  Tracks the address\r\n/// of the player and their bet.  Pvoides helper methods to the\r\n/// parent contract for reporting the number of players in the\r\n/// queue and the amount of value they have claim of (this is\r\n/// necessary in the computation of the payout.)\r\ncontract BetQueue {\r\n    /// @title Associates addresses with amounts\r\n    /// @notice Links an account with their bet, does not need\r\n    /// to contain the `Move` which is managed by the parent \r\n    /// contract.\r\n    struct Bet {\r\n        address payable player;\r\n        uint amount;\r\n    }\r\n    /// @title Map of indicies to entries\r\n    /// @dev we use a mapping with indices instead\r\n    /// of pushing/popping an array of structs.\r\n    mapping(uint256 => Bet) private queue;\r\n    /// @title The index of the next player to dequeue.\r\n    uint256 private first = 1;\r\n    /// @title The index of the last player ot dequeue.\r\n    uint256 private last = 0;\r\n    /// @title The owner of the contract (parent `RockPaperScissors` contract).\r\n    /// @notice Only the owner of the contract is allowed to change state.\r\n    address owner;\r\n    /// @title Queue Constructor\r\n    /// @notice Captures the owner of the contract, only the owner can change state.\r\n    constructor() public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n    /// @title Enqueue a Play\r\n    /// @notice Adds a player's play to the end of the queue.\r\n    /// @dev only the owner may call this method.\r\n    /// @param player address of the player\r\n    /// @param amount value of the player's bet\r\n    function enqueue(address payable player, uint amount) public {\r\n        require(msg.sender == owner, 'Access Denied');\r\n        last += 1;\r\n        queue[last] = Bet(player,amount);\r\n    }\r\n    /// @title Dequeus a Play\r\n    /// @notice Removes the oldest play from the queue.\r\n    /// @dev reverts if an attempt is made to deueue when the queue is empty.\r\n    /// Only the owner may call this method.\r\n    /// @return player address fo the player\r\n    /// @return amount the original value of hte player's bet.\r\n    function dequeue() public returns (address payable player, uint amount) {\r\n        require(msg.sender == owner, 'Access Denied');\r\n        require(!isEmpty(),'Queue is empty');\r\n        (player,amount) = (queue[first].player,queue[first].amount);\r\n        delete queue[first];\r\n        first += 1;\r\n        if(last < first) {\r\n            first = 1;\r\n            last = 0;\r\n        }\r\n    }\r\n    /// @title Number of records in the queue.\r\n    /// @dev only the owner may call this method.\r\n    /// @return the number of records in the queue.\r\n    function count() public view returns (uint total) {\r\n        require(msg.sender == owner, 'Access Denied');\r\n        return last - first + 1;\r\n    }\r\n    /// @title Total value of bets from players in queue.\r\n    /// @notice Enumerates the players in the queu and returns the\r\n    /// sum of the value of all the bets associated with the players.\r\n    /// @dev only the owner may call this method.\r\n    /// @return total the total value of the bets for the players contained\r\n    /// within this queue.\r\n    function totalAmount() public view returns (uint total)\r\n    {\r\n        require(msg.sender == owner, 'Access Denied');\r\n        total = 0;\r\n        for(uint i = first; i <= last; i ++ ) {\r\n            total = total + queue[i].amount;\r\n        }\r\n    }\r\n    /// @title Is Empty\r\n    /// @notice Returns `true` if the queue is empty, has no players.\r\n    /// @dev only the owner may call this method.\r\n    /// @return `true` if there are no players in the queue, `false` if\r\n    /// there are one or more.\r\n    function isEmpty() public view returns (bool) {\r\n        require(msg.sender == owner, 'Access Denied');\r\n        return last < first;\r\n    }\r\n}\r\n\r\n\r\n/// @title Rock Paper Scissors DApp Game for fun silliness.\r\n/// @author Jason Fabritz @bugbytesinc\r\n/// @notice Part of the game is to game the system, there\r\n/// is behavior in this contract that would generally be\r\n/// considered a security hole.  (You can't submarine for\r\n/// example, and there are paths that result in transfer\r\n/// failues when actors are deliberately malicous.)\r\ncontract RockPaperScissors\r\n{\r\n    /// @title Enumerates the potential play moves.\r\n    /// @dev the 0 value is None which makes a convenient dfault\r\n    enum Move\r\n    {\r\n        None,\r\n        Rock,\r\n        Paper,\r\n        Scissors\r\n    }\r\n    /// @title Winner Payout Event\r\n    /// @notice Emitted when a play resolves with a winner and loser\r\n    /// @param winner the address of the winner\r\n    /// @param move the winning move\r\n    /// @param loser the address of the losing address\r\n    /// @param payout the total ethere paid to the winer, includes their original bet\r\n    event WinnerPayout(address winner, Move move, address loser, uint payout);\r\n    /// @title Winner Forefit Event\r\n    /// @notice Emitted when an attempt to pay a winer fails for whatever reason\r\n    /// @dev This can happen due to a deliberate attack by the winner with a\r\n    /// from a bad acting contract, or it could be from out-of-gas attack.\r\n    /// @param winner the address of the winner\r\n    /// @param move the winning move\r\n    /// @param loser the address of the losing address\r\n    /// @param payout the total ethere paid to the winer, which will always be zero.\r\n    event WinnerForefit(address winner, Move move, address loser, uint payout);\r\n    /// @title Opening Move Event\r\n    /// @notice Emitted when a player makes an opening move (there are no other\r\n    /// moves stored in the contract), or the player makes the same move that is\r\n    /// already been played, in which case the play 'gets in line' for resolution.\r\n    /// The contract will have a limit at which only so many duplicate moves can\r\n    /// be made before the contract reverts further attempts.  The limit will be\r\n    /// indicated by turning the `maxReached` value `true`.  Without plays\r\n    /// resolving, any more duplicate plays will be reverted by the contract.\r\n    /// @dev when `maxReached` returns `false`, the UI can allow additional duplicate\r\n    /// plays.  When it reads `true` the UI should prevent duplicate plays as this\r\n    /// will just waste gas.\r\n    /// @param move The move that was made\r\n    /// @param maxReached a flag indicating the contract will no longer accept\r\n    /// plays with this type of move until pending plays resolve.\r\n    event OpeningMove(Move move, bool maxReached);\r\n    /// @title Refund Failure Occurred\r\n    /// @notice Emitted when the contract is being closed and an attempt to refund\r\n    /// a pending players bet failed.  This can happen if the player is a contract\r\n    /// and ran out of gas, or for other reasons.  Either way, the ether is lost to\r\n    /// the player at that point and must be refunded manually if desired.\r\n    /// @param player address of the player that had the refund reverted.\r\n    /// @param bet the value of the attempted refund.\r\n    event RefundFailure(address player, uint bet);\r\n    /// @title Game is closed for playing, calling `play` will revert.\r\n    /// @notice Emitted when the owner of the contract closes the game and attempts\r\n    /// to refund any unresolved plays.  This effectively shuts down the game.\r\n    /// After the game is closed, the owner my withdraw any remaining funds from the\r\n    /// contract.\r\n    event GameClosed();\r\n    /// @title Owner of the contract.\r\n    /// @notice A number of functions on the contract require authorization from the owner\r\n    address payable private owner;\r\n    /// @title Que of opening moves, first-in-first-out, of unresolved (duplicate) plays.\r\n    /// @dev This is implemented by a child contract for convenience.\r\n    BetQueue private openingMovers;\r\n    /// @title The minimum allowed bet.\r\n    /// @notice All bets must be at least this value for the `play` method to accept the move.\r\n    uint public minimumBet;\r\n    /// @title The current opening move\r\n    /// @notice This represents the opening move of a round.\r\n    /// @dev this is public knowledge, anyone can see what the opening move is.\r\n    Move public openingMove;\r\n    /// @title The contract is open and accepting moves.\r\n    /// @notice when `true` the contract allows playing, once set to `false` no other\r\n    /// plays can be made.\r\n    bool public open;\r\n    /// @title The maximum number of duplicate plays.\r\n    /// @notice The maximum number of duplicate plays that are allowed to queue up\r\n    /// at one time, after which a circuit breaker kicks in and disallows that particular\r\n    /// move until such time as plays have been resolved.\r\n    uint private maxQueueCount;\r\n    /// @title Rock Paper Scissors Contract Constructor\r\n    /// @notice Constructs the contract and initializes the queue.\r\n    /// @param minBet the minimum bet required when making a move by calling `play`.\r\n    constructor(uint minBet) public\r\n    {\r\n        require(minBet>0,'Minimum Bet must be greater than zero.');\r\n        owner = msg.sender;\r\n        openingMove = Move.None;\r\n        openingMovers = new BetQueue();\r\n        minimumBet = minBet;\r\n        open = true;\r\n        maxQueueCount = 20;\r\n    }\r\n    /// @title Payable default function allowing deposits.\r\n    /// @notice Allows anyone to add value to the running balance of the\r\n    /// contract, thus temporarily boosting payouts from wins.\r\n    function() external payable { }\r\n    /// @title Play a move or Rock, Paper or Scissors.\r\n    /// @notice Makes a move of Rock, Paper or Scissors.  The method\r\n    /// is payable and requires a minimum bet indicated by `minimmumBet`.\r\n    /// If the play resolves, a `WinnerPayout` event is emitted, if it\r\n    /// is the first play in a round an `OpeningMove` event will be emitted.\r\n    /// @dev if the queue of unresolved plays equals or exceeds the\r\n    /// `maxQueueCount` the contract call will be reverted.  Also, if the\r\n    /// game is closed, the call will be reverted.  If the bet is lower\r\n    /// than the minimum, the play will be reverted.\r\n    /// @param move The player's move, Rock, Paper, or Scissors.\r\n    /// @return a boolean value, `true` if this play wins, `false` if the\r\n    /// play does not win, or is an opening move.\r\n    function play(Move move) public payable returns (bool isWinner)\r\n    {\r\n        require(open, 'Game is finished.');\r\n        require(msg.value >= minimumBet,'Bet is too low.');\r\n        require(move == Move.Rock || move == Move.Paper || move == Move.Scissors,'Move is invalid.');\r\n        isWinner = false;\r\n        if(openingMove == Move.None)\r\n        {\r\n            openingMove = move;\r\n            openingMovers.enqueue(msg.sender,msg.value);\r\n            emit OpeningMove(openingMove, false);\r\n        }\r\n        else if(move == openingMove)\r\n        {\r\n            require(openingMovers.count() < maxQueueCount, \"Too Many Bets of the same type.\");\r\n            openingMovers.enqueue(msg.sender,msg.value);\r\n            emit OpeningMove(openingMove, openingMovers.count() >= maxQueueCount);\r\n        }\r\n        else\r\n        {\r\n            (address payable otherPlayer, uint otherBet) = openingMovers.dequeue();\r\n            Move otherMove = openingMove;\r\n            if(openingMovers.isEmpty()) {\r\n                openingMove = Move.None;\r\n            }\r\n            uint payout = (address(this).balance - msg.value - otherBet - openingMovers.totalAmount())/2;\r\n            if((move == Move.Rock && otherMove == Move.Scissors) || (move == Move.Paper && otherMove == Move.Rock) || (move == Move.Scissors && otherMove == Move.Paper))\r\n            {\r\n                isWinner = true;\r\n                payout = payout + msg.value + otherBet / 2;\r\n                emit WinnerPayout(msg.sender, move, otherPlayer, payout);\r\n                // If transfer fails, whole play reverts.\r\n                msg.sender.transfer(payout);\r\n            }\r\n            else\r\n            {\r\n                payout = payout + msg.value/2 + otherBet;\r\n                if(otherPlayer.send(payout)) {\r\n                    emit WinnerPayout(otherPlayer, otherMove, msg.sender, payout);\r\n                } else {\r\n                    // Winner Bad Actor? Loser Out of Gas? Money kept in\r\n                    // running total.  Yes, the loser could be a bad actor\r\n                    // not send enough gas to cause this to happen.\r\n                    // Leave it as part of the skullduggery nature of the game.\r\n                    emit WinnerForefit(otherPlayer, otherMove, msg.sender, payout);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /// @title Set Maximum Number of Allowed Unresolved Plays\r\n    /// @notice Allows the owner to specifiy the number of unresolved\r\n    /// plays the contract will allow to be held at one time.  Acts as\r\n    /// a circuit breaker against one or many players loading up on one\r\n    /// particular move.\r\n    /// @dev only the owner of the contract may call this function.\r\n    /// @param maxSize the maximum number of plays allowed in the queue.\r\n    function setMaxQueueSize(uint maxSize) external {\r\n        require(owner == msg.sender, 'Access Denied');\r\n        require(maxSize > 0, 'Size must be greater than zero.');\r\n        maxQueueCount = maxSize;\r\n    }\r\n    /// @title Ends the Game\r\n    /// @notice Ends the game, returning any unresolved plays to their\r\n    /// originating addresses, if possible.  If transfers fail, a\r\n    /// `RefundFailure` event will be raised and it will be up to the\r\n    /// owner of the contract to manually resolve any issues.\r\n    /// @dev Only the owner of the contract may call this method.\r\n    function end() external\r\n    {\r\n        require(owner == msg.sender, 'Access Denied');\r\n        require(open, 'Game is already finished.');\r\n        open = false;\r\n        openingMove = Move.None;\r\n        while(!openingMovers.isEmpty())\r\n        {\r\n            (address payable player, uint bet) = openingMovers.dequeue();\r\n            if(!player.send(bet))\r\n            {\r\n                emit RefundFailure(player,bet);\r\n            }\r\n        }\r\n        emit GameClosed();\r\n    }\r\n    /// @title Withdraws any remaining contract ballance.\r\n    /// @notice Sends any remaining contract value to the owner of the\r\n    /// contract.  May only be called after play has been suspened by\r\n    /// calling teh `end()` method.\r\n    /// @dev Only the owner of the contract may call this method, after\r\n    /// the game has been ended.\r\n    function withdraw() external\r\n    {\r\n        require(owner == msg.sender, 'Access Denied');\r\n        require(!open, 'Game is still running.');\r\n        uint balance = address(this).balance;\r\n        if(balance > 0) {\r\n            owner.transfer(balance);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingMove\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"move\",\"type\":\"uint8\"}],\"name\":\"play\",\"outputs\":[{\"name\":\"isWinner\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maxSize\",\"type\":\"uint256\"}],\"name\":\"setMaxQueueSize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"end\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"open\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"minBet\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"move\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"loser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payout\",\"type\":\"uint256\"}],\"name\":\"WinnerPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"move\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"loser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payout\",\"type\":\"uint256\"}],\"name\":\"WinnerForefit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"move\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"maxReached\",\"type\":\"bool\"}],\"name\":\"OpeningMove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bet\",\"type\":\"uint256\"}],\"name\":\"RefundFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"GameClosed\",\"type\":\"event\"}]","ContractName":"RockPaperScissors","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000e8d4a51000","Library":"","SwarmSource":"bzzr://0374a2f9948affdfb9ec419c614d2f86203a3eeb1734f6a252a453fadc11f691"}]}