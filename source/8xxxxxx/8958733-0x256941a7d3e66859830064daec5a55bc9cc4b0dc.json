{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.13;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title Interface for SoloMargin contract\r\n * @author Igor Sobolev\r\n */\r\ninterface ISoloMargin {\r\n    function operate(Account.Info[] calldata accounts, Actions.ActionArgs[] calldata actions) external;\r\n}\r\n\r\n\r\nlibrary Account {\r\n    // ============ Enums ============\r\n\r\n    /*\r\n     * Most-recently-cached account status.\r\n     *\r\n     * Normal: Can only be liquidated if the account values are violating the global margin-ratio.\r\n     * Liquid: Can be liquidated no matter the account values.\r\n     *         Can be vaporized if there are no more positive account values.\r\n     * Vapor:  Has only negative (or zeroed) account values. Can be vaporized.\r\n     *\r\n     */\r\n    enum Status {\r\n        Normal,\r\n        Liquid,\r\n        Vapor\r\n    }\r\n\r\n    // ============ Structs ============\r\n\r\n    // Represents the unique key that specifies an account\r\n    struct Info {\r\n        address owner;  // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n\r\n    // The complete storage for any account\r\n    struct Storage {\r\n        mapping (uint256 => Types.Par) balances; // Mapping from marketId to principal\r\n        Status status;\r\n    }\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function equals(\r\n        Info memory a,\r\n        Info memory b\r\n    )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return a.owner == b.owner && a.number == b.number;\r\n    }\r\n}\r\n\r\n\r\nlibrary Actions {\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \"Actions\";\r\n\r\n    // ============ Enums ============\r\n\r\n    enum ActionType {\r\n        Deposit,   // supply tokens\r\n        Withdraw,  // borrow tokens\r\n        Transfer,  // transfer balance between accounts\r\n        Buy,       // buy an amount of some token (externally)\r\n        Sell,      // sell an amount of some token (externally)\r\n        Trade,     // trade tokens against another account\r\n        Liquidate, // liquidate an undercollateralized or expiring account\r\n        Vaporize,  // use excess tokens to zero-out a completely negative account\r\n        Call       // send arbitrary data to an address\r\n    }\r\n\r\n    enum AccountLayout {\r\n        OnePrimary,\r\n        TwoPrimary,\r\n        PrimaryAndSecondary\r\n    }\r\n\r\n    enum MarketLayout {\r\n        ZeroMarkets,\r\n        OneMarket,\r\n        TwoMarkets\r\n    }\r\n\r\n    // ============ Structs ============\r\n\r\n    /*\r\n     * Arguments that are passed to Solo in an ordered list as part of a single operation.\r\n     * Each ActionArgs has an actionType which specifies which action struct that this data will be\r\n     * parsed into before being processed.\r\n     */\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        Types.AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n\r\n    // ============ Action Types ============\r\n\r\n    /*\r\n     * Moves tokens from an address to Solo. Can either repay a borrow or provide additional supply.\r\n     */\r\n    struct DepositArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 market;\r\n        address from;\r\n    }\r\n\r\n    /*\r\n     * Moves tokens from Solo to another address. Can either borrow tokens or reduce the amount\r\n     * previously supplied.\r\n     */\r\n    struct WithdrawArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 market;\r\n        address to;\r\n    }\r\n\r\n    /*\r\n     * Transfers balance between two accounts. The msg.sender must be an operator for both accounts.\r\n     * The amount field applies to accountOne.\r\n     * This action does not require any token movement since the trade is done internally to Solo.\r\n     */\r\n    struct TransferArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info accountOne;\r\n        Account.Info accountTwo;\r\n        uint256 market;\r\n    }\r\n\r\n    /*\r\n     * Acquires a certain amount of tokens by spending other tokens. Sends takerMarket tokens to the\r\n     * specified exchangeWrapper contract and expects makerMarket tokens in return. The amount field\r\n     * applies to the makerMarket.\r\n     */\r\n    struct BuyArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 makerMarket;\r\n        uint256 takerMarket;\r\n        address exchangeWrapper;\r\n        bytes orderData;\r\n    }\r\n\r\n    /*\r\n     * Spends a certain amount of tokens to acquire other tokens. Sends takerMarket tokens to the\r\n     * specified exchangeWrapper and expects makerMarket tokens in return. The amount field applies\r\n     * to the takerMarket.\r\n     */\r\n    struct SellArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 takerMarket;\r\n        uint256 makerMarket;\r\n        address exchangeWrapper;\r\n        bytes orderData;\r\n    }\r\n\r\n    /*\r\n     * Trades balances between two accounts using any external contract that implements the\r\n     * AutoTrader interface. The AutoTrader contract must be an operator for the makerAccount (for\r\n     * which it is trading on-behalf-of). The amount field applies to the makerAccount and the\r\n     * inputMarket. This proposed change to the makerAccount is passed to the AutoTrader which will\r\n     * quote a change for the makerAccount in the outputMarket (or will disallow the trade).\r\n     * This action does not require any token movement since the trade is done internally to Solo.\r\n     */\r\n    struct TradeArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info takerAccount;\r\n        Account.Info makerAccount;\r\n        uint256 inputMarket;\r\n        uint256 outputMarket;\r\n        address autoTrader;\r\n        bytes tradeData;\r\n    }\r\n\r\n    /*\r\n     * Each account must maintain a certain margin-ratio (specified globally). If the account falls\r\n     * below this margin-ratio, it can be liquidated by any other account. This allows anyone else\r\n     * (arbitrageurs) to repay any borrowed asset (owedMarket) of the liquidating account in\r\n     * exchange for any collateral asset (heldMarket) of the liquidAccount. The ratio is determined\r\n     * by the price ratio (given by the oracles) plus a spread (specified globally). Liquidating an\r\n     * account also sets a flag on the account that the account is being liquidated. This allows\r\n     * anyone to continue liquidating the account until there are no more borrows being taken by the\r\n     * liquidating account. Liquidators do not have to liquidate the entire account all at once but\r\n     * can liquidate as much as they choose. The liquidating flag allows liquidators to continue\r\n     * liquidating the account even if it becomes collateralized through partial liquidation or\r\n     * price movement.\r\n     */\r\n    struct LiquidateArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info solidAccount;\r\n        Account.Info liquidAccount;\r\n        uint256 owedMarket;\r\n        uint256 heldMarket;\r\n    }\r\n\r\n    /*\r\n     * Similar to liquidate, but vaporAccounts are accounts that have only negative balances\r\n     * remaining. The arbitrageur pays back the negative asset (owedMarket) of the vaporAccount in\r\n     * exchange for a collateral asset (heldMarket) at a favorable spread. However, since the\r\n     * liquidAccount has no collateral assets, the collateral must come from Solo's excess tokens.\r\n     */\r\n    struct VaporizeArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info solidAccount;\r\n        Account.Info vaporAccount;\r\n        uint256 owedMarket;\r\n        uint256 heldMarket;\r\n    }\r\n\r\n    /*\r\n     * Passes arbitrary bytes of data to an external contract that implements the Callee interface.\r\n     * Does not change any asset amounts. This function may be useful for setting certain variables\r\n     * on layer-two contracts for certain accounts without having to make a separate Ethereum\r\n     * transaction for doing so. Also, the second-layer contracts can ensure that the call is coming\r\n     * from an operator of the particular account.\r\n     */\r\n    struct CallArgs {\r\n        Account.Info account;\r\n        address callee;\r\n        bytes data;\r\n    }\r\n\r\n    // ============ Helper Functions ============\r\n\r\n    function getMarketLayout(\r\n        ActionType actionType\r\n    )\r\n    internal\r\n    pure\r\n    returns (MarketLayout)\r\n    {\r\n        if (\r\n            actionType == Actions.ActionType.Deposit\r\n            || actionType == Actions.ActionType.Withdraw\r\n            || actionType == Actions.ActionType.Transfer\r\n        ) {\r\n            return MarketLayout.OneMarket;\r\n        }\r\n        else if (actionType == Actions.ActionType.Call) {\r\n            return MarketLayout.ZeroMarkets;\r\n        }\r\n        return MarketLayout.TwoMarkets;\r\n    }\r\n\r\n    function getAccountLayout(\r\n        ActionType actionType\r\n    )\r\n    internal\r\n    pure\r\n    returns (AccountLayout)\r\n    {\r\n        if (\r\n            actionType == Actions.ActionType.Transfer\r\n            || actionType == Actions.ActionType.Trade\r\n        ) {\r\n            return AccountLayout.TwoPrimary;\r\n        } else if (\r\n            actionType == Actions.ActionType.Liquidate\r\n            || actionType == Actions.ActionType.Vaporize\r\n        ) {\r\n            return AccountLayout.PrimaryAndSecondary;\r\n        }\r\n        return AccountLayout.OnePrimary;\r\n    }\r\n\r\n    // ============ Parsing Functions ============\r\n\r\n    function parseDepositArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n    internal\r\n    pure\r\n    returns (DepositArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Deposit);\r\n        return DepositArgs({\r\n            amount: args.amount,\r\n            account: accounts[args.accountId],\r\n            market: args.primaryMarketId,\r\n            from: args.otherAddress\r\n            });\r\n    }\r\n\r\n    function parseWithdrawArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n    internal\r\n    pure\r\n    returns (WithdrawArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Withdraw);\r\n        return WithdrawArgs({\r\n            amount: args.amount,\r\n            account: accounts[args.accountId],\r\n            market: args.primaryMarketId,\r\n            to: args.otherAddress\r\n            });\r\n    }\r\n\r\n    function parseTransferArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n    internal\r\n    pure\r\n    returns (TransferArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Transfer);\r\n        return TransferArgs({\r\n            amount: args.amount,\r\n            accountOne: accounts[args.accountId],\r\n            accountTwo: accounts[args.otherAccountId],\r\n            market: args.primaryMarketId\r\n            });\r\n    }\r\n\r\n    function parseBuyArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n    internal\r\n    pure\r\n    returns (BuyArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Buy);\r\n        return BuyArgs({\r\n            amount: args.amount,\r\n            account: accounts[args.accountId],\r\n            makerMarket: args.primaryMarketId,\r\n            takerMarket: args.secondaryMarketId,\r\n            exchangeWrapper: args.otherAddress,\r\n            orderData: args.data\r\n            });\r\n    }\r\n\r\n    function parseSellArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n    internal\r\n    pure\r\n    returns (SellArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Sell);\r\n        return SellArgs({\r\n            amount: args.amount,\r\n            account: accounts[args.accountId],\r\n            takerMarket: args.primaryMarketId,\r\n            makerMarket: args.secondaryMarketId,\r\n            exchangeWrapper: args.otherAddress,\r\n            orderData: args.data\r\n            });\r\n    }\r\n\r\n    function parseTradeArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n    internal\r\n    pure\r\n    returns (TradeArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Trade);\r\n        return TradeArgs({\r\n            amount: args.amount,\r\n            takerAccount: accounts[args.accountId],\r\n            makerAccount: accounts[args.otherAccountId],\r\n            inputMarket: args.primaryMarketId,\r\n            outputMarket: args.secondaryMarketId,\r\n            autoTrader: args.otherAddress,\r\n            tradeData: args.data\r\n            });\r\n    }\r\n\r\n    function parseLiquidateArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n    internal\r\n    pure\r\n    returns (LiquidateArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Liquidate);\r\n        return LiquidateArgs({\r\n            amount: args.amount,\r\n            solidAccount: accounts[args.accountId],\r\n            liquidAccount: accounts[args.otherAccountId],\r\n            owedMarket: args.primaryMarketId,\r\n            heldMarket: args.secondaryMarketId\r\n            });\r\n    }\r\n\r\n    function parseVaporizeArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n    internal\r\n    pure\r\n    returns (VaporizeArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Vaporize);\r\n        return VaporizeArgs({\r\n            amount: args.amount,\r\n            solidAccount: accounts[args.accountId],\r\n            vaporAccount: accounts[args.otherAccountId],\r\n            owedMarket: args.primaryMarketId,\r\n            heldMarket: args.secondaryMarketId\r\n            });\r\n    }\r\n\r\n    function parseCallArgs(\r\n        Account.Info[] memory accounts,\r\n        ActionArgs memory args\r\n    )\r\n    internal\r\n    pure\r\n    returns (CallArgs memory)\r\n    {\r\n        assert(args.actionType == ActionType.Call);\r\n        return CallArgs({\r\n            account: accounts[args.accountId],\r\n            callee: args.otherAddress,\r\n            data: args.data\r\n            });\r\n    }\r\n}\r\n\r\n\r\n/// @title Interface for Module Manager - A contract that manages modules that can execute transactions via this contract\r\n/// @author Igor Sobolev\r\ninterface ModuleManager {\r\n    function execTransactionFromModule(address to, uint256 value, bytes calldata data, Enum.Operation operation) external returns (bool success);\r\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes calldata data, Enum.Operation operation) external returns (bool success, bytes memory returnData);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\nlibrary Require {\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant ASCII_ZERO = 48; // '0'\r\n    uint256 constant ASCII_RELATIVE_ZERO = 87; // 'a' - 10\r\n    uint256 constant ASCII_LOWER_EX = 120; // 'x'\r\n    bytes2 constant COLON = 0x3a20; // ': '\r\n    bytes2 constant COMMA = 0x2c20; // ', '\r\n    bytes2 constant LPAREN = 0x203c; // ' <'\r\n    byte constant RPAREN = 0x3e; // '>'\r\n    uint256 constant FOUR_BIT_MASK = 0xf;\r\n\r\n    // ============ Library Functions ============\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason\r\n    )\r\n    internal\r\n    pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA\r\n    )\r\n    internal\r\n    pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        uint256 payloadA,\r\n        uint256 payloadB\r\n    )\r\n    internal\r\n    pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA\r\n    )\r\n    internal\r\n    pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB\r\n    )\r\n    internal\r\n    pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        address payloadA,\r\n        uint256 payloadB,\r\n        uint256 payloadC\r\n    )\r\n    internal\r\n    pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        COMMA,\r\n                        stringify(payloadC),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        bytes32 payloadA\r\n    )\r\n    internal\r\n    pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function that(\r\n        bool must,\r\n        bytes32 file,\r\n        bytes32 reason,\r\n        bytes32 payloadA,\r\n        uint256 payloadB,\r\n        uint256 payloadC\r\n    )\r\n    internal\r\n    pure\r\n    {\r\n        if (!must) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        stringifyTruncated(file),\r\n                        COLON,\r\n                        stringifyTruncated(reason),\r\n                        LPAREN,\r\n                        stringify(payloadA),\r\n                        COMMA,\r\n                        stringify(payloadB),\r\n                        COMMA,\r\n                        stringify(payloadC),\r\n                        RPAREN\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    // ============ Private Functions ============\r\n\r\n    function stringifyTruncated(\r\n        bytes32 input\r\n    )\r\n    private\r\n    pure\r\n    returns (bytes memory)\r\n    {\r\n        // put the input bytes into the result\r\n        bytes memory result = abi.encodePacked(input);\r\n\r\n        // determine the length of the input by finding the location of the last non-zero byte\r\n        for (uint256 i = 32; i > 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // find the last non-zero byte in order to determine the length\r\n            if (result[i] != 0) {\r\n                uint256 length = i + 1;\r\n\r\n                /* solium-disable-next-line security/no-inline-assembly */\r\n                assembly {\r\n                    mstore(result, length) // r.length = length;\r\n                }\r\n\r\n                return result;\r\n            }\r\n        }\r\n\r\n        // all bytes are zero\r\n        return new bytes(0);\r\n    }\r\n\r\n    function stringify(\r\n        uint256 input\r\n    )\r\n    private\r\n    pure\r\n    returns (bytes memory)\r\n    {\r\n        if (input == 0) {\r\n            return \"0\";\r\n        }\r\n\r\n        // get the final string length\r\n        uint256 j = input;\r\n        uint256 length;\r\n        while (j != 0) {\r\n            length++;\r\n            j /= 10;\r\n        }\r\n\r\n        // allocate the string\r\n        bytes memory bstr = new bytes(length);\r\n\r\n        // populate the string starting with the least-significant character\r\n        j = input;\r\n        for (uint256 i = length; i > 0; ) {\r\n            // reverse-for-loops with unsigned integer\r\n            /* solium-disable-next-line security/no-modify-for-iter-var */\r\n            i--;\r\n\r\n            // take last decimal digit\r\n            bstr[i] = byte(uint8(ASCII_ZERO + (j % 10)));\r\n\r\n            // remove the last decimal digit\r\n            j /= 10;\r\n        }\r\n\r\n        return bstr;\r\n    }\r\n\r\n    function stringify(\r\n        address input\r\n    )\r\n    private\r\n    pure\r\n    returns (bytes memory)\r\n    {\r\n        uint256 z = uint256(input);\r\n\r\n        // addresses are \"0x\" followed by 20 bytes of data which take up 2 characters each\r\n        bytes memory result = new bytes(42);\r\n\r\n        // populate the result with \"0x\"\r\n        result[0] = byte(uint8(ASCII_ZERO));\r\n        result[1] = byte(uint8(ASCII_LOWER_EX));\r\n\r\n        // for each byte (starting from the lowest byte), populate the result with two characters\r\n        for (uint256 i = 0; i < 20; i++) {\r\n            // each byte takes two characters\r\n            uint256 shift = i * 2;\r\n\r\n            // populate the least-significant character\r\n            result[41 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n\r\n            // populate the most-significant character\r\n            result[40 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function stringify(\r\n        bytes32 input\r\n    )\r\n    private\r\n    pure\r\n    returns (bytes memory)\r\n    {\r\n        uint256 z = uint256(input);\r\n\r\n        // bytes32 are \"0x\" followed by 32 bytes of data which take up 2 characters each\r\n        bytes memory result = new bytes(66);\r\n\r\n        // populate the result with \"0x\"\r\n        result[0] = byte(uint8(ASCII_ZERO));\r\n        result[1] = byte(uint8(ASCII_LOWER_EX));\r\n\r\n        // for each byte (starting from the lowest byte), populate the result with two characters\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            // each byte takes two characters\r\n            uint256 shift = i * 2;\r\n\r\n            // populate the least-significant character\r\n            result[65 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n\r\n            // populate the most-significant character\r\n            result[64 - shift] = char(z & FOUR_BIT_MASK);\r\n            z = z >> 4;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function char(\r\n        uint256 input\r\n    )\r\n    private\r\n    pure\r\n    returns (byte)\r\n    {\r\n        // return ASCII digit (0-9)\r\n        if (input < 10) {\r\n            return byte(uint8(input + ASCII_ZERO));\r\n        }\r\n\r\n        // return ASCII letter (a-f)\r\n        return byte(uint8(input + ASCII_RELATIVE_ZERO));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Math\r\n * @author dYdX\r\n *\r\n * Library for non-standard Math functions\r\n */\r\nlibrary Math {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    bytes32 constant FILE = \"Math\";\r\n\r\n    // ============ Library Functions ============\r\n\r\n    /*\r\n     * Return target * (numerator / denominator).\r\n     */\r\n    function getPartial(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return target.mul(numerator).div(denominator);\r\n    }\r\n\r\n    /*\r\n     * Return target * (numerator / denominator), but rounded up.\r\n     */\r\n    function getPartialRoundUp(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        if (target == 0 || numerator == 0) {\r\n            // SafeMath will check for zero denominator\r\n            return SafeMath.div(0, denominator);\r\n        }\r\n        return target.mul(numerator).sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    function to128(\r\n        uint256 number\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint128)\r\n    {\r\n        uint128 result = uint128(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint128\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to96(\r\n        uint256 number\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint96)\r\n    {\r\n        uint96 result = uint96(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint96\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function to32(\r\n        uint256 number\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint32)\r\n    {\r\n        uint32 result = uint32(number);\r\n        Require.that(\r\n            result == number,\r\n            FILE,\r\n            \"Unsafe cast to uint32\"\r\n        );\r\n        return result;\r\n    }\r\n\r\n    function min(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Types\r\n * @author dYdX\r\n *\r\n * Library for interacting with the basic structs used in Solo\r\n */\r\nlibrary Types {\r\n    using Math for uint256;\r\n\r\n    // ============ AssetAmount ============\r\n\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par  // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    // ============ Par (Principal Amount) ============\r\n\r\n    // Total borrow and supply values for a market\r\n    struct TotalPar {\r\n        uint128 borrow;\r\n        uint128 supply;\r\n    }\r\n\r\n    // Individual principal amount for an account\r\n    struct Par {\r\n        bool sign; // true if positive\r\n        uint128 value;\r\n    }\r\n\r\n    function zeroPar()\r\n    internal\r\n    pure\r\n    returns (Par memory)\r\n    {\r\n        return Par({\r\n            sign: false,\r\n            value: 0\r\n            });\r\n    }\r\n\r\n    function sub(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n    internal\r\n    pure\r\n    returns (Par memory)\r\n    {\r\n        return add(a, negative(b));\r\n    }\r\n\r\n    function add(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n    internal\r\n    pure\r\n    returns (Par memory)\r\n    {\r\n        Par memory result;\r\n        if (a.sign == b.sign) {\r\n            result.sign = a.sign;\r\n            result.value = SafeMath.add(a.value, b.value).to128();\r\n        } else {\r\n            if (a.value >= b.value) {\r\n                result.sign = a.sign;\r\n                result.value = SafeMath.sub(a.value, b.value).to128();\r\n            } else {\r\n                result.sign = b.sign;\r\n                result.value = SafeMath.sub(b.value, a.value).to128();\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function equals(\r\n        Par memory a,\r\n        Par memory b\r\n    )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        if (a.value == b.value) {\r\n            if (a.value == 0) {\r\n                return true;\r\n            }\r\n            return a.sign == b.sign;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function negative(\r\n        Par memory a\r\n    )\r\n    internal\r\n    pure\r\n    returns (Par memory)\r\n    {\r\n        return Par({\r\n            sign: !a.sign,\r\n            value: a.value\r\n            });\r\n    }\r\n\r\n    function isNegative(\r\n        Par memory a\r\n    )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return !a.sign && a.value > 0;\r\n    }\r\n\r\n    function isPositive(\r\n        Par memory a\r\n    )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return a.sign && a.value > 0;\r\n    }\r\n\r\n    function isZero(\r\n        Par memory a\r\n    )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return a.value == 0;\r\n    }\r\n\r\n    // ============ Wei (Token Amount) ============\r\n\r\n    // Individual token amount for an account\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n\r\n    function zeroWei()\r\n    internal\r\n    pure\r\n    returns (Wei memory)\r\n    {\r\n        return Wei({\r\n            sign: false,\r\n            value: 0\r\n            });\r\n    }\r\n\r\n    function sub(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n    internal\r\n    pure\r\n    returns (Wei memory)\r\n    {\r\n        return add(a, negative(b));\r\n    }\r\n\r\n    function add(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n    internal\r\n    pure\r\n    returns (Wei memory)\r\n    {\r\n        Wei memory result;\r\n        if (a.sign == b.sign) {\r\n            result.sign = a.sign;\r\n            result.value = SafeMath.add(a.value, b.value);\r\n        } else {\r\n            if (a.value >= b.value) {\r\n                result.sign = a.sign;\r\n                result.value = SafeMath.sub(a.value, b.value);\r\n            } else {\r\n                result.sign = b.sign;\r\n                result.value = SafeMath.sub(b.value, a.value);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function equals(\r\n        Wei memory a,\r\n        Wei memory b\r\n    )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        if (a.value == b.value) {\r\n            if (a.value == 0) {\r\n                return true;\r\n            }\r\n            return a.sign == b.sign;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function negative(\r\n        Wei memory a\r\n    )\r\n    internal\r\n    pure\r\n    returns (Wei memory)\r\n    {\r\n        return Wei({\r\n            sign: !a.sign,\r\n            value: a.value\r\n            });\r\n    }\r\n\r\n    function isNegative(\r\n        Wei memory a\r\n    )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return !a.sign && a.value > 0;\r\n    }\r\n\r\n    function isPositive(\r\n        Wei memory a\r\n    )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return a.sign && a.value > 0;\r\n    }\r\n\r\n    function isZero(\r\n        Wei memory a\r\n    )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return a.value == 0;\r\n    }\r\n}\r\n\r\n\r\ncontract Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall\r\n    }\r\n}\r\n\r\n\r\ninterface ICErc20 {\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract SelfAuthorized {\r\n    modifier authorized() {\r\n        require(msg.sender == address(this), \"Method can only be called from this contract\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\ncontract MasterCopy is SelfAuthorized {\r\n\r\n    event ChangedMasterCopy(address masterCopy);\r\n\r\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\r\n    // It should also always be ensured that the address is stored alone (uses a full word)\r\n    address masterCopy;\r\n\r\n    /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\r\n    /// @param _masterCopy New contract address.\r\n    function changeMasterCopy(address _masterCopy)\r\n    public\r\n    authorized\r\n    {\r\n        // Master copy address cannot be null.\r\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n        emit ChangedMasterCopy(_masterCopy);\r\n    }\r\n}\r\n\r\n\r\ncontract Module is MasterCopy {\r\n\r\n    ModuleManager public manager;\r\n\r\n    modifier authorized() {\r\n        require(msg.sender == address(manager), \"Method can only be called from manager\");\r\n        _;\r\n    }\r\n\r\n    function setManager()\r\n    internal\r\n    {\r\n        // manager can only be 0 at initalization of contract.\r\n        // Check ensures that setup function can only be called once.\r\n        require(address(manager) == address(0), \"Manager has already been set\");\r\n        manager = ModuleManager(msg.sender);\r\n    }\r\n}\r\n\r\n\r\n/// @title Compound DyDx Module - Allows to transfer DAI and USDC from Compound lending to dYdX lending and vise versa.\r\n/// @author Igor Sobolev - <sobolev.igor@me.com>\r\ncontract CompoundDyDxModule is Module {\r\n\r\n    string public constant NAME = \"Compound dYdX Module\";\r\n    string public constant VERSION = \"0.1.0\";\r\n\r\n    ISoloMargin public soloMargin;\r\n    IERC20 public DAI;\r\n    IERC20 public USDC;\r\n    ICErc20 public cDAI;\r\n    ICErc20 public cUSDC;\r\n\r\n    enum SupportedToken {None, DAI, USDC}\r\n    enum SupportedProtocol {DyDx, Compound}\r\n\r\n    /// @dev Setup function sets initial storage of contract.\r\n    /// @param _soloMargin Address of SoloMargin contract.\r\n    /// @param _cDAI Address of cDAI contract.\r\n    /// @param _cUSDC Address of cUSDC contract.\r\n    function setup(\r\n        ISoloMargin _soloMargin,\r\n        IERC20 _DAI,\r\n        ICErc20 _cDAI,\r\n        IERC20 _USDC,\r\n        ICErc20 _cUSDC\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            address(_soloMargin) != address(0),\r\n            \"CompoundDyDxModule: wrong soloMargin address!\");\r\n        require(\r\n            address(_cDAI) != address(0),\r\n            \"CompoundDyDxModule: wrong cDAI address!\");\r\n        require(\r\n            address(_DAI) != address(0),\r\n            \"CompoundDyDxModule: wrong DAI address!\");\r\n        require(\r\n            address(_cUSDC) != address(0),\r\n            \"CompoundDyDxModule: wrong cUSDC address!\");\r\n        require(\r\n            address(_USDC) != address(0),\r\n            \"CompoundDyDxModule: wrong USDC address!\");\r\n\r\n        soloMargin = _soloMargin;\r\n        cDAI = _cDAI;\r\n        DAI = _DAI;\r\n        cUSDC = _cUSDC;\r\n        USDC = _USDC;\r\n\r\n        setManager();\r\n    }\r\n\r\n    /// @dev Allows to transfer funds from one lending to another. This can only be done via a Safe transaction.\r\n    /// @param token One of two currently supported tokens.\r\n    /// @param protocolFrom Protocol to withdraw funds from.\r\n    /// @param protocolFrom Protocol to deposit funds to.\r\n    /// @param amount Amount of tokens to transfer (in wei).\r\n    function executeMove(\r\n        SupportedToken token,\r\n        SupportedProtocol protocolFrom,\r\n        SupportedProtocol protocolTo,\r\n        uint256 amount\r\n    )\r\n        external\r\n        authorized\r\n    {\r\n        require(\r\n            token != SupportedToken.None,\r\n            \"CompoundDyDxModule: incorrect input!\");\r\n        require(\r\n            protocolFrom != protocolTo,\r\n            \"CompoundDyDxModule: dummy move to the same protocol!\");\r\n        require(\r\n            amount > 0,\r\n            \"CompoundDyDxModule: dummy move without tokens!\");\r\n\r\n        if (protocolFrom == SupportedProtocol.Compound) {\r\n            withdrawFromCompound(token, amount);\r\n        } else if (protocolFrom == SupportedProtocol.DyDx) {\r\n            withdrawFromDyDx(token, amount);\r\n        }\r\n\r\n        if (protocolTo == SupportedProtocol.DyDx) {\r\n            depositToDyDx(token, amount);\r\n        } else if (protocolTo == SupportedProtocol.Compound) {\r\n            depositToCompound(token, amount);\r\n        }\r\n    }\r\n\r\n    function withdrawFromCompound(\r\n        SupportedToken token,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        (ICErc20 activeCToken,) = getTokensAddresses(token);\r\n\r\n        (, bytes memory returnData) = manager.execTransactionFromModuleReturnData({\r\n            to: address(activeCToken),\r\n            value: 0,\r\n            data: abi.encodeWithSelector(activeCToken.redeem.selector, amount),\r\n            operation: Enum.Operation.Call\r\n        });\r\n        require(\r\n            abi.decode(returnData, (uint256)) == 0,\r\n            \"Could not withdraw from Compound!\");\r\n    }\r\n\r\n    function depositToCompound(\r\n        SupportedToken token,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        (ICErc20 activeCToken, IERC20 activeToken) = getTokensAddresses(token);\r\n\r\n        require(\r\n            manager.execTransactionFromModule({\r\n                to: address(activeToken),\r\n                value: 0,\r\n                data: abi.encodeWithSelector(activeToken.approve.selector, address(activeCToken), amount),\r\n                operation: Enum.Operation.Call\r\n            }),\r\n            \"Could not approve to Compound!\");\r\n\r\n\r\n        (, bytes memory returnData) = manager.execTransactionFromModuleReturnData({\r\n            to: address(activeCToken),\r\n            value: 0,\r\n            data: abi.encodeWithSelector(activeCToken.mint.selector, amount),\r\n            operation: Enum.Operation.Call\r\n        });\r\n        require(\r\n            abi.decode(returnData, (uint256)) == 0,\r\n            \"Could not deposit to Compound!\");\r\n    }\r\n\r\n    function withdrawFromDyDx(\r\n        SupportedToken token,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        Account.Info[] memory accountInfo = new Account.Info[](1);\r\n        accountInfo[0] = Account.Info({\r\n            owner: address(this),\r\n            number: 0\r\n        });\r\n\r\n        Types.AssetAmount memory assetAmount = Types.AssetAmount({\r\n            sign: true, // true if positive\r\n            denomination: Types.AssetDenomination.Wei, // (casted to 0) / or Par (casted to 1)\r\n            ref: Types.AssetReference.Delta, // (casted to 0) / or Target (casted to 1)\r\n            value: amount\r\n        });\r\n        Actions.ActionArgs[] memory actionArgs = new Actions.ActionArgs[](1);\r\n        actionArgs[0] = Actions.ActionArgs({\r\n            actionType: Actions.ActionType.Withdraw,\r\n            accountId: 0,\r\n            amount: assetAmount,\r\n            primaryMarketId: uint256(token),\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: new bytes(0)\r\n        });\r\n\r\n        require(\r\n            manager.execTransactionFromModule({\r\n                to: address(soloMargin),\r\n                value: 0,\r\n                data: abi.encodeWithSelector(soloMargin.operate.selector, accountInfo, actionArgs),\r\n                operation: Enum.Operation.Call\r\n            }),\r\n            \"Could not withdraw from dYdX!\");\r\n    }\r\n\r\n    function depositToDyDx(\r\n        SupportedToken token,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        (, IERC20 activeToken) = getTokensAddresses(token);\r\n\r\n        Account.Info[] memory accountInfo = new Account.Info[](1);\r\n        accountInfo[0] = Account.Info({\r\n            owner: address(this),\r\n            number: 0\r\n        });\r\n        Types.AssetAmount memory assetAmount = Types.AssetAmount({\r\n            sign: true, // true if positive\r\n            denomination: Types.AssetDenomination.Wei, // (casted to 0) / or Par (casted to 1)\r\n            ref: Types.AssetReference.Delta, // (casted to 0) / or Target (casted to 1)\r\n            value: amount\r\n        });\r\n        Actions.ActionArgs[] memory actionArgs = new Actions.ActionArgs[](1);\r\n        actionArgs[0] = Actions.ActionArgs({\r\n            actionType: Actions.ActionType.Deposit,\r\n            accountId: 0,\r\n            amount: assetAmount,\r\n            primaryMarketId: uint256(token),\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: new bytes(0)\r\n        });\r\n\r\n        require(\r\n            manager.execTransactionFromModule({\r\n                to: address(activeToken),\r\n                value: 0,\r\n                data: abi.encodeWithSelector(activeToken.approve.selector, address(soloMargin), amount),\r\n                operation: Enum.Operation.Call\r\n            }),\r\n            \"Could not approve to dYdX!\");\r\n        require(\r\n            manager.execTransactionFromModule({\r\n                to: address(soloMargin),\r\n                value: 0,\r\n                data: abi.encodeWithSelector(soloMargin.operate.selector, accountInfo, actionArgs),\r\n                operation: Enum.Operation.Call\r\n            }),\r\n            \"Could not deposit to dYdX!\");\r\n\r\n    }\r\n\r\n    function getTokensAddresses(\r\n        SupportedToken token\r\n    )\r\n        internal\r\n        view\r\n        returns (ICErc20 activeCToken, IERC20 activeToken)\r\n    {\r\n        if (token == SupportedToken.DAI) {\r\n            activeCToken = cDAI;\r\n            activeToken = DAI;\r\n        } else if (token == SupportedToken.USDC) {\r\n            activeCToken = cUSDC;\r\n            activeToken = USDC;\r\n        }\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"masterCopy\",\"type\":\"address\"}],\"name\":\"ChangedMasterCopy\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAI\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cDAI\",\"outputs\":[{\"internalType\":\"contract ICErc20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cUSDC\",\"outputs\":[{\"internalType\":\"contract ICErc20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterCopy\",\"type\":\"address\"}],\"name\":\"changeMasterCopy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum CompoundDyDxModule.SupportedToken\",\"name\":\"token\",\"type\":\"uint8\"},{\"internalType\":\"enum CompoundDyDxModule.SupportedProtocol\",\"name\":\"protocolFrom\",\"type\":\"uint8\"},{\"internalType\":\"enum CompoundDyDxModule.SupportedProtocol\",\"name\":\"protocolTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"executeMove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"contract ModuleManager\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ISoloMargin\",\"name\":\"_soloMargin\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_DAI\",\"type\":\"address\"},{\"internalType\":\"contract ICErc20\",\"name\":\"_cDAI\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_USDC\",\"type\":\"address\"},{\"internalType\":\"contract ICErc20\",\"name\":\"_cUSDC\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soloMargin\",\"outputs\":[{\"internalType\":\"contract ISoloMargin\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CompoundDyDxModule","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://49987f9c72406c0e376d7a56a54b92e6b5ea78867bb6b7bd71ce919ed7d90db4"}]}