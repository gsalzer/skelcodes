{"status":"1","message":"OK","result":[{"SourceCode":"/**\nAuthor: Loopring Foundation (Loopring Project Ltd)\n*/\n\npragma solidity ^0.5.11;\n\n\nlibrary MathUint {\n    function mul(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint c)\n    {\n        c = a * b;\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\n    }\n\n    function sub(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint)\n    {\n        require(b <= a, \"SUB_UNDERFLOW\");\n        return a - b;\n    }\n\n    function add(\n        uint a,\n        uint b\n        )\n        internal\n        pure\n        returns (uint c)\n    {\n        c = a + b;\n        require(c >= a, \"ADD_OVERFLOW\");\n    }\n\n    function decodeFloat(\n        uint f\n        )\n        internal\n        pure\n        returns (uint value)\n    {\n        uint numBitsMantissa = 23;\n        uint exponent = f >> numBitsMantissa;\n        uint mantissa = f & ((1 << numBitsMantissa) - 1);\n        value = mantissa * (10 ** exponent);\n    }\n}\n\ncontract IAddressWhitelist {\n    \n    \n    \n    \n    function isAddressWhitelisted(\n        address addr,\n        bytes   memory permission\n        )\n        public\n        view\n        returns (bool);\n}\n\nlibrary Poseidon {\n    function hash_t5f6p52(\n        uint t0,\n        uint t1,\n        uint t2,\n        uint t3,\n        uint t4\n        )\n        internal\n        pure\n        returns (uint)\n    {\n        uint q = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n        \n        require(t0 < q, \"INVALID_INPUT\");\n        require(t1 < q, \"INVALID_INPUT\");\n        require(t2 < q, \"INVALID_INPUT\");\n        require(t3 < q, \"INVALID_INPUT\");\n        require(t4 < q, \"INVALID_INPUT\");\n\n        assembly {\n            function mix(t0, t1, t2, t3, t4, q) -> nt0, nt1, nt2, nt3, nt4 {\n                nt0 := mulmod(t0, 4977258759536702998522229302103997878600602264560359702680165243908162277980, q)\n                nt0 := addmod(nt0, mulmod(t1, 19167410339349846567561662441069598364702008768579734801591448511131028229281, q), q)\n                nt0 := addmod(nt0, mulmod(t2, 14183033936038168803360723133013092560869148726790180682363054735190196956789, q), q)\n                nt0 := addmod(nt0, mulmod(t3, 9067734253445064890734144122526450279189023719890032859456830213166173619761, q), q)\n                nt0 := addmod(nt0, mulmod(t4, 16378664841697311562845443097199265623838619398287411428110917414833007677155, q), q)\n                nt1 := mulmod(t0, 107933704346764130067829474107909495889716688591997879426350582457782826785, q)\n                nt1 := addmod(nt1, mulmod(t1, 17034139127218860091985397764514160131253018178110701196935786874261236172431, q), q)\n                nt1 := addmod(nt1, mulmod(t2, 2799255644797227968811798608332314218966179365168250111693473252876996230317, q), q)\n                nt1 := addmod(nt1, mulmod(t3, 2482058150180648511543788012634934806465808146786082148795902594096349483974, q), q)\n                nt1 := addmod(nt1, mulmod(t4, 16563522740626180338295201738437974404892092704059676533096069531044355099628, q), q)\n                nt2 := mulmod(t0, 13596762909635538739079656925495736900379091964739248298531655823337482778123, q)\n                nt2 := addmod(nt2, mulmod(t1, 18985203040268814769637347880759846911264240088034262814847924884273017355969, q), q)\n                nt2 := addmod(nt2, mulmod(t2, 8652975463545710606098548415650457376967119951977109072274595329619335974180, q), q)\n                nt2 := addmod(nt2, mulmod(t3, 970943815872417895015626519859542525373809485973005165410533315057253476903, q), q)\n                nt2 := addmod(nt2, mulmod(t4, 19406667490568134101658669326517700199745817783746545889094238643063688871948, q), q)\n                nt3 := mulmod(t0, 2953507793609469112222895633455544691298656192015062835263784675891831794974, q)\n                nt3 := addmod(nt3, mulmod(t1, 19025623051770008118343718096455821045904242602531062247152770448380880817517, q), q)\n                nt3 := addmod(nt3, mulmod(t2, 9077319817220936628089890431129759976815127354480867310384708941479362824016, q), q)\n                nt3 := addmod(nt3, mulmod(t3, 4770370314098695913091200576539533727214143013236894216582648993741910829490, q), q)\n                nt3 := addmod(nt3, mulmod(t4, 4298564056297802123194408918029088169104276109138370115401819933600955259473, q), q)\n                nt4 := mulmod(t0, 8336710468787894148066071988103915091676109272951895469087957569358494947747, q)\n                nt4 := addmod(nt4, mulmod(t1, 16205238342129310687768799056463408647672389183328001070715567975181364448609, q), q)\n                nt4 := addmod(nt4, mulmod(t2, 8303849270045876854140023508764676765932043944545416856530551331270859502246, q), q)\n                nt4 := addmod(nt4, mulmod(t3, 20218246699596954048529384569730026273241102596326201163062133863539137060414, q), q)\n                nt4 := addmod(nt4, mulmod(t4, 1712845821388089905746651754894206522004527237615042226559791118162382909269, q), q)\n            }\n\n            function ark(t0, t1, t2, t3, t4, q, c) -> nt0, nt1, nt2, nt3, nt4 {\n                nt0 := addmod(t0, c, q)\n                nt1 := addmod(t1, c, q)\n                nt2 := addmod(t2, c, q)\n                nt3 := addmod(t3, c, q)\n                nt4 := addmod(t4, c, q)\n            }\n\n            function sbox_full(t0, t1, t2, t3, t4, q) -> nt0, nt1, nt2, nt3, nt4 {\n                nt0 := mulmod(t0, t0, q)\n                nt0 := mulmod(nt0, nt0, q)\n                nt0 := mulmod(t0, nt0, q)\n                nt1 := mulmod(t1, t1, q)\n                nt1 := mulmod(nt1, nt1, q)\n                nt1 := mulmod(t1, nt1, q)\n                nt2 := mulmod(t2, t2, q)\n                nt2 := mulmod(nt2, nt2, q)\n                nt2 := mulmod(t2, nt2, q)\n                nt3 := mulmod(t3, t3, q)\n                nt3 := mulmod(nt3, nt3, q)\n                nt3 := mulmod(t3, nt3, q)\n                nt4 := mulmod(t4, t4, q)\n                nt4 := mulmod(nt4, nt4, q)\n                nt4 := mulmod(t4, nt4, q)\n            }\n\n            function sbox_partial(t, q) -> nt {\n                nt := mulmod(t, t, q)\n                nt := mulmod(nt, nt, q)\n                nt := mulmod(t, nt, q)\n            }\n\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14397397413755236225575615486459253198602422701513067526754101844196324375522)\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10405129301473404666785234951972711717481302463898292859783056520670200613128)\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 5179144822360023508491245509308555580251733042407187134628755730783052214509)\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9132640374240188374542843306219594180154739721841249568925550236430986592615)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20360807315276763881209958738450444293273549928693737723235350358403012458514)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17933600965499023212689924809448543050840131883187652471064418452962948061619)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3636213416533737411392076250708419981662897009810345015164671602334517041153)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2008540005368330234524962342006691994500273283000229509835662097352946198608)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16018407964853379535338740313053768402596521780991140819786560130595652651567)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20653139667070586705378398435856186172195806027708437373983929336015162186471)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17887713874711369695406927657694993484804203950786446055999405564652412116765)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4852706232225925756777361208698488277369799648067343227630786518486608711772)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8969172011633935669771678412400911310465619639756845342775631896478908389850)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20570199545627577691240476121888846460936245025392381957866134167601058684375)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16442329894745639881165035015179028112772410105963688121820543219662832524136)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20060625627350485876280451423010593928172611031611836167979515653463693899374)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16637282689940520290130302519163090147511023430395200895953984829546679599107)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15599196921909732993082127725908821049411366914683565306060493533569088698214)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16894591341213863947423904025624185991098788054337051624251730868231322135455)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 1197934381747032348421303489683932612752526046745577259575778515005162320212)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6172482022646932735745595886795230725225293469762393889050804649558459236626)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21004037394166516054140386756510609698837211370585899203851827276330669555417)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15262034989144652068456967541137853724140836132717012646544737680069032573006)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15017690682054366744270630371095785995296470601172793770224691982518041139766)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15159744167842240513848638419303545693472533086570469712794583342699782519832)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11178069035565459212220861899558526502477231302924961773582350246646450941231)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21154888769130549957415912997229564077486639529994598560737238811887296922114)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20162517328110570500010831422938033120419484532231241180224283481905744633719)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2777362604871784250419758188173029886707024739806641263170345377816177052018)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15732290486829619144634131656503993123618032247178179298922551820261215487562)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6024433414579583476444635447152826813568595303270846875177844482142230009826)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17677827682004946431939402157761289497221048154630238117709539216286149983245)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10716307389353583413755237303156291454109852751296156900963208377067748518748)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14925386988604173087143546225719076187055229908444910452781922028996524347508)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8940878636401797005293482068100797531020505636124892198091491586778667442523)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 18911747154199663060505302806894425160044925686870165583944475880789706164410)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8821532432394939099312235292271438180996556457308429936910969094255825456935)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20632576502437623790366878538516326728436616723089049415538037018093616927643)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 71447649211767888770311304010816315780740050029903404046389165015534756512)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2781996465394730190470582631099299305677291329609718650018200531245670229393)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 12441376330954323535872906380510501637773629931719508864016287320488688345525)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2558302139544901035700544058046419714227464650146159803703499681139469546006)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10087036781939179132584550273563255199577525914374285705149349445480649057058)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4267692623754666261749551533667592242661271409704769363166965280715887854739)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4945579503584457514844595640661884835097077318604083061152997449742124905548)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17742335354489274412669987990603079185096280484072783973732137326144230832311)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6266270088302506215402996795500854910256503071464802875821837403486057988208)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2716062168542520412498610856550519519760063668165561277991771577403400784706)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 19118392018538203167410421493487769944462015419023083813301166096764262134232)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9386595745626044000666050847309903206827901310677406022353307960932745699524)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9121640807890366356465620448383131419933298563527245687958865317869840082266)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3078975275808111706229899605611544294904276390490742680006005661017864583210)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 7157404299437167354719786626667769956233708887934477609633504801472827442743)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14056248655941725362944552761799461694550787028230120190862133165195793034373)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14124396743304355958915937804966111851843703158171757752158388556919187839849)\n            t0 := sbox_partial(t0, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11851254356749068692552943732920045260402277343008629727465773766468466181076)\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9799099446406796696742256539758943483211846559715874347178722060519817626047)\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n            \n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10156146186214948683880719664738535455146137901666656566575307300522957959544)\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n        }\n        return t0;\n    }\n}\n\nlibrary ExchangeBalances {\n    using MathUint  for uint;\n\n    function verifyAccountBalance(\n        uint     merkleRoot,\n        uint24   accountID,\n        uint16   tokenID,\n        uint     pubKeyX,\n        uint     pubKeyY,\n        uint32   nonce,\n        uint96   balance,\n        uint     tradeHistoryRoot,\n        uint[30] calldata accountMerkleProof,\n        uint[12] calldata balanceMerkleProof\n        )\n        external\n        pure\n    {\n        bool isCorrect = isAccountBalanceCorrect(\n            merkleRoot,\n            accountID,\n            tokenID,\n            pubKeyX,\n            pubKeyY,\n            nonce,\n            balance,\n            tradeHistoryRoot,\n            accountMerkleProof,\n            balanceMerkleProof\n        );\n        require(isCorrect, \"INVALID_MERKLE_TREE_DATA\");\n    }\n\n    function isAccountBalanceCorrect(\n        uint     merkleRoot,\n        uint24   accountID,\n        uint16   tokenID,\n        uint     pubKeyX,\n        uint     pubKeyY,\n        uint32   nonce,\n        uint96   balance,\n        uint     tradeHistoryRoot,\n        uint[30] memory accountMerkleProof,\n        uint[12] memory balanceMerkleProof\n        )\n        public\n        pure\n        returns (bool isCorrect)\n    {\n        \n        uint calculatedRoot = getBalancesRoot(\n            tokenID,\n            balance,\n            tradeHistoryRoot,\n            balanceMerkleProof\n        );\n        calculatedRoot = getAccountInternalsRoot(\n            accountID,\n            pubKeyX,\n            pubKeyY,\n            nonce,\n            calculatedRoot,\n            accountMerkleProof\n        );\n        isCorrect = (calculatedRoot == merkleRoot);\n    }\n\n    function getBalancesRoot(\n        uint16   tokenID,\n        uint     balance,\n        uint     tradeHistoryRoot,\n        uint[12] memory balanceMerkleProof\n        )\n        private\n        pure\n        returns (uint)\n    {\n        uint balanceItem = hashImpl(balance, tradeHistoryRoot, 0, 0);\n        uint _id = tokenID;\n        for (uint depth = 0; depth < 4; depth++) {\n            if (_id & 3 == 0) {\n                balanceItem = hashImpl(\n                    balanceItem,\n                    balanceMerkleProof[depth * 3],\n                    balanceMerkleProof[depth * 3 + 1],\n                    balanceMerkleProof[depth * 3 + 2]\n                );\n            } else if (_id & 3 == 1) {\n                balanceItem = hashImpl(\n                    balanceMerkleProof[depth * 3],\n                    balanceItem,\n                    balanceMerkleProof[depth * 3 + 1],\n                    balanceMerkleProof[depth * 3 + 2]\n                );\n            } else if (_id & 3 == 2) {\n                balanceItem = hashImpl(\n                    balanceMerkleProof[depth * 3],\n                    balanceMerkleProof[depth * 3 + 1],\n                    balanceItem,\n                    balanceMerkleProof[depth * 3 + 2]\n                );\n            } else if (_id & 3 == 3) {\n                balanceItem = hashImpl(\n                    balanceMerkleProof[depth * 3],\n                    balanceMerkleProof[depth * 3 + 1],\n                    balanceMerkleProof[depth * 3 + 2],\n                    balanceItem\n                );\n            }\n            _id = _id >> 2;\n        }\n        return balanceItem;\n    }\n\n    function getAccountInternalsRoot(\n        uint24   accountID,\n        uint     pubKeyX,\n        uint     pubKeyY,\n        uint     nonce,\n        uint     balancesRoot,\n        uint[30] memory accountMerkleProof\n        )\n        private\n        pure\n        returns (uint)\n    {\n        uint accountItem = hashImpl(pubKeyX, pubKeyY, nonce, balancesRoot);\n        uint _id = accountID;\n        for (uint depth = 0; depth < 10; depth++) {\n            if (_id & 3 == 0) {\n                accountItem = hashImpl(\n                    accountItem,\n                    accountMerkleProof[depth * 3],\n                    accountMerkleProof[depth * 3 + 1],\n                    accountMerkleProof[depth * 3 + 2]\n                );\n            } else if (_id & 3 == 1) {\n                accountItem = hashImpl(\n                    accountMerkleProof[depth * 3],\n                    accountItem,\n                    accountMerkleProof[depth * 3 + 1],\n                    accountMerkleProof[depth * 3 + 2]\n                );\n            } else if (_id & 3 == 2) {\n                accountItem = hashImpl(\n                    accountMerkleProof[depth * 3],\n                    accountMerkleProof[depth * 3 + 1],\n                    accountItem,\n                    accountMerkleProof[depth * 3 + 2]\n                );\n            } else if (_id & 3 == 3) {\n                accountItem = hashImpl(\n                    accountMerkleProof[depth * 3],\n                    accountMerkleProof[depth * 3 + 1],\n                    accountMerkleProof[depth * 3 + 2],\n                    accountItem\n                );\n            }\n            _id = _id >> 2;\n        }\n        return accountItem;\n    }\n\n    function hashImpl(\n        uint t0,\n        uint t1,\n        uint t2,\n        uint t3\n        )\n        private\n        pure\n        returns (uint)\n    {\n        return Poseidon.hash_t5f6p52(t0, t1, t2, t3, 0);\n    }\n}\n\ncontract IBlockVerifier {\n    \n\n    event CircuitRegistered(\n        uint8  indexed blockType,\n        bool           onchainDataAvailability,\n        uint16         blockSize,\n        uint8          blockVersion\n    );\n\n    event CircuitDisabled(\n        uint8  indexed blockType,\n        bool           onchainDataAvailability,\n        uint16         blockSize,\n        uint8          blockVersion\n    );\n\n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function registerCircuit(\n        uint8    blockType,\n        bool     onchainDataAvailability,\n        uint16   blockSize,\n        uint8    blockVersion,\n        uint[18] calldata vk\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function disableCircuit(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function verifyProofs(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion,\n        uint[] calldata publicInputs,\n        uint[] calldata proofs\n        )\n        external\n        view\n        returns (bool);\n\n    \n    \n    \n    \n    \n    \n    \n    function isCircuitRegistered(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion\n        )\n        external\n        view\n        returns (bool);\n\n    \n    \n    \n    \n    \n    \n    \n    function isCircuitEnabled(\n        uint8  blockType,\n        bool   onchainDataAvailability,\n        uint16 blockSize,\n        uint8  blockVersion\n        )\n        external\n        view\n        returns (bool);\n}\n\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    \n    \n    constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    \n    modifier onlyOwner()\n    {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        onlyOwner\n    {\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function renounceOwnership()\n        public\n        onlyOwner\n    {\n        emit OwnershipTransferred(owner, address(0));\n        owner = address(0);\n    }\n}\n\ncontract Claimable is Ownable\n{\n    address public pendingOwner;\n\n    \n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    \n    \n    function transferOwnership(\n        address newOwner\n        )\n        public\n        onlyOwner\n    {\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\n        pendingOwner = newOwner;\n    }\n\n    \n    function claimOwnership()\n        public\n        onlyPendingOwner\n    {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\ncontract ReentrancyGuard {\n    \n    uint private _guardValue;\n\n    \n    modifier nonReentrant()\n    {\n        \n        require(_guardValue == 0, \"REENTRANCY\");\n\n        \n        _guardValue = 1;\n\n        \n        _;\n\n        \n        _guardValue = 0;\n    }\n}\n\ncontract ILoopring is Claimable, ReentrancyGuard\n{\n    string  constant public version = \"\"; \n\n    uint    public exchangeCreationCostLRC;\n    address public universalRegistry;\n    address public lrcAddress;\n\n    event ExchangeInitialized(\n        uint    indexed exchangeId,\n        address indexed exchangeAddress,\n        address indexed owner,\n        address         operator,\n        bool            onchainDataAvailability\n    );\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function initializeExchange(\n        address exchangeAddress,\n        uint    exchangeId,\n        address owner,\n        address payable operator,\n        bool    onchainDataAvailability\n        )\n        external;\n}\n\ncontract ILoopringV3 is ILoopring\n{\n    \n\n    event ExchangeStakeDeposited(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ExchangeStakeWithdrawn(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ExchangeStakeBurned(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ProtocolFeeStakeDeposited(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event ProtocolFeeStakeWithdrawn(\n        uint    indexed exchangeId,\n        uint            amount\n    );\n\n    event SettingsUpdated(\n        uint            time\n    );\n\n    \n    struct Exchange\n    {\n        address exchangeAddress;\n        uint    exchangeStake;\n        uint    protocolFeeStake;\n    }\n\n    mapping (uint => Exchange) internal exchanges;\n\n    string  constant public version = \"3.0\";\n\n    address public wethAddress;\n    uint    public totalStake;\n    address public blockVerifierAddress;\n    address public downtimeCostCalculator;\n    uint    public maxWithdrawalFee;\n    uint    public withdrawalFineLRC;\n    uint    public tokenRegistrationFeeLRCBase;\n    uint    public tokenRegistrationFeeLRCDelta;\n    uint    public minExchangeStakeWithDataAvailability;\n    uint    public minExchangeStakeWithoutDataAvailability;\n    uint    public revertFineLRC;\n    uint8   public minProtocolTakerFeeBips;\n    uint8   public maxProtocolTakerFeeBips;\n    uint8   public minProtocolMakerFeeBips;\n    uint8   public maxProtocolMakerFeeBips;\n    uint    public targetProtocolTakerFeeStake;\n    uint    public targetProtocolMakerFeeStake;\n\n    address payable public protocolFeeVault;\n\n    \n    \n    \n    \n    \n    \n    function updateSettings(\n        address payable _protocolFeeVault,   \n        address _blockVerifierAddress,       \n        address _downtimeCostCalculator,     \n        uint    _exchangeCreationCostLRC,\n        uint    _maxWithdrawalFee,\n        uint    _tokenRegistrationFeeLRCBase,\n        uint    _tokenRegistrationFeeLRCDelta,\n        uint    _minExchangeStakeWithDataAvailability,\n        uint    _minExchangeStakeWithoutDataAvailability,\n        uint    _revertFineLRC,\n        uint    _withdrawalFineLRC\n        )\n        external;\n\n    \n    \n    \n    \n    \n    function updateProtocolFeeSettings(\n        uint8 _minProtocolTakerFeeBips,\n        uint8 _maxProtocolTakerFeeBips,\n        uint8 _minProtocolMakerFeeBips,\n        uint8 _maxProtocolMakerFeeBips,\n        uint  _targetProtocolTakerFeeStake,\n        uint  _targetProtocolMakerFeeStake\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function canExchangeCommitBlocks(\n        uint exchangeId,\n        bool onchainDataAvailability\n        )\n        external\n        view\n        returns (bool);\n\n    \n    \n    \n    function getExchangeStake(\n        uint exchangeId\n        )\n        public\n        view\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    function burnExchangeStake(\n        uint exchangeId,\n        uint amount\n        )\n        external\n        returns (uint burnedLRC);\n\n    \n    \n    \n    \n    function depositExchangeStake(\n        uint exchangeId,\n        uint amountLRC\n        )\n        external\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    \n    function withdrawExchangeStake(\n        uint    exchangeId,\n        address recipient,\n        uint    requestedAmount\n        )\n        external\n        returns (uint amount);\n\n    \n    \n    \n    \n    function depositProtocolFeeStake(\n        uint exchangeId,\n        uint amountLRC\n        )\n        external\n        returns (uint stakedLRC);\n\n    \n    \n    \n    \n    \n    function withdrawProtocolFeeStake(\n        uint    exchangeId,\n        address recipient,\n        uint    amount\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    function getProtocolFeeValues(\n        uint exchangeId,\n        bool onchainDataAvailability\n        )\n        external\n        view\n        returns (\n            uint8 takerFeeBips,\n            uint8 makerFeeBips\n        );\n\n    \n    \n    \n    function getProtocolFeeStake(\n        uint exchangeId\n        )\n        external\n        view\n        returns (uint protocolFeeStake);\n}\n\nlibrary ExchangeData {\n    \n    enum BlockType\n    {\n        RING_SETTLEMENT,\n        DEPOSIT,\n        ONCHAIN_WITHDRAWAL,\n        OFFCHAIN_WITHDRAWAL,\n        ORDER_CANCELLATION,\n        TRANSFER\n    }\n\n    enum BlockState\n    {\n        \n        \n        NEW,            \n\n        \n        COMMITTED,      \n\n        \n        \n        VERIFIED        \n    }\n\n    \n    struct Account\n    {\n        address owner;\n\n        \n        \n        \n        \n        \n        \n        \n        \n        uint    pubKeyX;\n        uint    pubKeyY;\n    }\n\n    struct Token\n    {\n        address token;\n        bool    depositDisabled;\n    }\n\n    struct ProtocolFeeData\n    {\n        uint32 timestamp;\n        uint8 takerFeeBips;\n        uint8 makerFeeBips;\n        uint8 previousTakerFeeBips;\n        uint8 previousMakerFeeBips;\n    }\n\n    \n    \n    struct Block\n    {\n        \n        \n        bytes32 merkleRoot;\n\n        \n        \n        \n        \n        \n        \n        bytes32 publicDataHash;\n\n        \n        BlockState state;\n\n        \n        \n        BlockType blockType;\n\n        \n        \n        \n        \n        uint16 blockSize;\n\n        \n        uint8  blockVersion;\n\n        \n        uint32 timestamp;\n\n        \n        \n        uint32 numDepositRequestsCommitted;\n\n        \n        \n        uint32 numWithdrawalRequestsCommitted;\n\n        \n        \n        bool   blockFeeWithdrawn;\n\n        \n        uint16 numWithdrawalsDistributed;\n\n        \n        \n        \n        \n        \n        \n        \n        \n        bytes  withdrawals;\n    }\n\n    \n    \n    \n    struct Request\n    {\n        bytes32 accumulatedHash;\n        uint    accumulatedFee;\n        uint32  timestamp;\n    }\n\n    \n    struct Deposit\n    {\n        uint24 accountID;\n        uint16 tokenID;\n        uint96 amount;\n    }\n\n    function SNARK_SCALAR_FIELD() internal pure returns (uint) {\n        \n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    }\n\n    function MAX_PROOF_GENERATION_TIME_IN_SECONDS() internal pure returns (uint32) { return 14 days; }\n    function MAX_GAP_BETWEEN_FINALIZED_AND_VERIFIED_BLOCKS() internal pure returns (uint32) { return 1000; }\n    function MAX_OPEN_DEPOSIT_REQUESTS() internal pure returns (uint16) { return 1024; }\n    function MAX_OPEN_WITHDRAWAL_REQUESTS() internal pure returns (uint16) { return 1024; }\n    function MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 21 days; }\n    function MAX_AGE_REQUEST_UNTIL_FORCED() internal pure returns (uint32) { return 14 days; }\n    function MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 15 days; }\n    function MAX_TIME_IN_SHUTDOWN_BASE() internal pure returns (uint32) { return 30 days; }\n    function MAX_TIME_IN_SHUTDOWN_DELTA() internal pure returns (uint32) { return 1 seconds; }\n    function TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() internal pure returns (uint32) { return 7 days; }\n    function MAX_NUM_TOKENS() internal pure returns (uint) { return 2 ** 8; }\n    function MAX_NUM_ACCOUNTS() internal pure returns (uint) { return 2 ** 20 - 1; }\n    function MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 14 days; }\n    function MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS_SHUTDOWN_MODE() internal pure returns (uint32) {\n        return MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS() * 10;\n    }\n    function FEE_BLOCK_FINE_START_TIME() internal pure returns (uint32) { return 6 hours; }\n    function FEE_BLOCK_FINE_MAX_DURATION() internal pure returns (uint32) { return 6 hours; }\n    function MIN_GAS_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 150000; }\n    function MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED() internal pure returns (uint32) { return 1 days; }\n    function GAS_LIMIT_SEND_TOKENS() internal pure returns (uint32) { return 60000; }\n\n    \n    struct State\n    {\n        uint    id;\n        uint    exchangeCreationTimestamp;\n        address payable operator; \n        bool    onchainDataAvailability;\n\n        ILoopringV3    loopring;\n        IBlockVerifier blockVerifier;\n\n        address lrcAddress;\n\n        uint    totalTimeInMaintenanceSeconds;\n        uint    numDowntimeMinutes;\n        uint    downtimeStart;\n\n        address addressWhitelist;\n        uint    accountCreationFeeETH;\n        uint    accountUpdateFeeETH;\n        uint    depositFeeETH;\n        uint    withdrawalFeeETH;\n\n        Block[]     blocks;\n        Token[]     tokens;\n        Account[]   accounts;\n        Deposit[]   deposits;\n        Request[]   depositChain;\n        Request[]   withdrawalChain;\n\n        \n        mapping (address => uint24) ownerToAccountId;\n        mapping (address => uint16) tokenToTokenId;\n\n        \n        mapping (address => mapping (address => bool)) withdrawnInWithdrawMode;\n\n        \n        mapping (address => uint) tokenBalances;\n\n        \n        \n        \n        uint numBlocksFinalized;\n\n        \n        ProtocolFeeData protocolFeeData;\n\n        \n        uint shutdownStartTime;\n    }\n}\n\nlibrary ExchangeAccounts {\n    using MathUint          for uint;\n    using ExchangeBalances  for ExchangeData.State;\n\n    event AccountCreated(\n        address indexed owner,\n        uint24  indexed id,\n        uint            pubKeyX,\n        uint            pubKeyY\n    );\n\n    event AccountUpdated(\n        address indexed owner,\n        uint24  indexed id,\n        uint            pubKeyX,\n        uint            pubKeyY\n    );\n\n    \n    function getAccount(\n        ExchangeData.State storage S,\n        address owner\n        )\n        external\n        view\n        returns (\n            uint24 accountID,\n            uint   pubKeyX,\n            uint   pubKeyY\n        )\n    {\n        accountID = getAccountID(S, owner);\n        ExchangeData.Account storage account = S.accounts[accountID];\n        pubKeyX = account.pubKeyX;\n        pubKeyY = account.pubKeyY;\n    }\n\n    function createOrUpdateAccount(\n        ExchangeData.State storage S,\n        uint  pubKeyX,\n        uint  pubKeyY,\n        bytes calldata permission\n        )\n        external\n        returns (\n            uint24 accountID,\n            bool   isAccountNew,\n            bool   isAccountUpdated\n        )\n    {\n        isAccountNew = (S.ownerToAccountId[msg.sender] == 0);\n        if (isAccountNew) {\n            if (S.addressWhitelist != address(0)) {\n                require(\n                    IAddressWhitelist(S.addressWhitelist)\n                        .isAddressWhitelisted(msg.sender, permission),\n                    \"ADDRESS_NOT_WHITELISTED\"\n                );\n            }\n            accountID = createAccount(S, pubKeyX, pubKeyY);\n            isAccountUpdated = false;\n        } else {\n            (accountID, isAccountUpdated) = updateAccount(S, pubKeyX, pubKeyY);\n        }\n    }\n\n    function getAccountID(\n        ExchangeData.State storage S,\n        address owner\n        )\n        public\n        view\n        returns (uint24 accountID)\n    {\n        accountID = S.ownerToAccountId[owner];\n        require(accountID != 0, \"ADDRESS_HAS_NO_ACCOUNT\");\n\n        accountID = accountID - 1;\n    }\n\n    function createAccount(\n        ExchangeData.State storage S,\n        uint pubKeyX,\n        uint pubKeyY\n        )\n        private\n        returns (uint24 accountID)\n    {\n        require(S.accounts.length < ExchangeData.MAX_NUM_ACCOUNTS(), \"ACCOUNTS_FULL\");\n        require(S.ownerToAccountId[msg.sender] == 0, \"ACCOUNT_EXISTS\");\n\n        accountID = uint24(S.accounts.length);\n        ExchangeData.Account memory account = ExchangeData.Account(\n            msg.sender,\n            pubKeyX,\n            pubKeyY\n        );\n\n        S.accounts.push(account);\n        S.ownerToAccountId[msg.sender] = accountID + 1;\n\n        emit AccountCreated(\n            msg.sender,\n            accountID,\n            pubKeyX,\n            pubKeyY\n        );\n    }\n\n    function updateAccount(\n        ExchangeData.State storage S,\n        uint pubKeyX,\n        uint pubKeyY\n        )\n        private\n        returns (\n            uint24 accountID,\n            bool   isAccountUpdated\n        )\n    {\n        require(S.ownerToAccountId[msg.sender] != 0, \"ACCOUNT_NOT_EXIST\");\n\n        accountID = S.ownerToAccountId[msg.sender] - 1;\n        ExchangeData.Account storage account = S.accounts[accountID];\n\n        isAccountUpdated = (account.pubKeyX != pubKeyX || account.pubKeyY != pubKeyY);\n        if (isAccountUpdated) {\n            account.pubKeyX = pubKeyX;\n            account.pubKeyY = pubKeyY;\n\n            emit AccountUpdated(\n                msg.sender,\n                accountID,\n                pubKeyX,\n                pubKeyY\n            );\n        }\n    }\n}\n\ncontract ERC20 {\n    function totalSupply()\n        public\n        view\n        returns (uint);\n\n    function balanceOf(\n        address who\n        )\n        public\n        view\n        returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n        )\n        public\n        view\n        returns (uint);\n\n    function transfer(\n        address to,\n        uint value\n        )\n        public\n        returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint    value\n        )\n        public\n        returns (bool);\n\n    function approve(\n        address spender,\n        uint    value\n        )\n        public\n        returns (bool);\n}\n\ncontract BurnableERC20 is ERC20\n{\n    function burn(\n        uint value\n        )\n        public\n        returns (bool);\n\n    function burnFrom(\n        address from,\n        uint value\n        )\n        public\n        returns (bool);\n}\n\nlibrary ERC20SafeTransfer {\n    function safeTransferAndVerify(\n        address token,\n        address to,\n        uint    value\n        )\n        internal\n    {\n        safeTransferWithGasLimitAndVerify(\n            token,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint    value\n        )\n        internal\n        returns (bool)\n    {\n        return safeTransferWithGasLimit(\n            token,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferWithGasLimitAndVerify(\n        address token,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n    {\n        require(\n            safeTransferWithGasLimit(token, to, value, gasLimit),\n            \"TRANSFER_FAILURE\"\n        );\n    }\n\n    function safeTransferWithGasLimit(\n        address token,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n        returns (bool)\n    {\n        \n        \n        \n\n        \n        bytes memory callData = abi.encodeWithSelector(\n            bytes4(0xa9059cbb),\n            to,\n            value\n        );\n        (bool success, ) = token.call.gas(gasLimit)(callData);\n        return checkReturnValue(success);\n    }\n\n    function safeTransferFromAndVerify(\n        address token,\n        address from,\n        address to,\n        uint    value\n        )\n        internal\n    {\n        safeTransferFromWithGasLimitAndVerify(\n            token,\n            from,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint    value\n        )\n        internal\n        returns (bool)\n    {\n        return safeTransferFromWithGasLimit(\n            token,\n            from,\n            to,\n            value,\n            gasleft()\n        );\n    }\n\n    function safeTransferFromWithGasLimitAndVerify(\n        address token,\n        address from,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n    {\n        bool result = safeTransferFromWithGasLimit(\n            token,\n            from,\n            to,\n            value,\n            gasLimit\n        );\n        require(result, \"TRANSFER_FAILURE\");\n    }\n\n    function safeTransferFromWithGasLimit(\n        address token,\n        address from,\n        address to,\n        uint    value,\n        uint    gasLimit\n        )\n        internal\n        returns (bool)\n    {\n        \n        \n        \n\n        \n        bytes memory callData = abi.encodeWithSelector(\n            bytes4(0x23b872dd),\n            from,\n            to,\n            value\n        );\n        (bool success, ) = token.call.gas(gasLimit)(callData);\n        return checkReturnValue(success);\n    }\n\n    function checkReturnValue(\n        bool success\n        )\n        internal\n        pure\n        returns (bool)\n    {\n        \n        \n        \n        if (success) {\n            assembly {\n                switch returndatasize()\n                \n                case 0 {\n                    success := 1\n                }\n                \n                case 32 {\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)\n                }\n                \n                default {\n                    success := 0\n                }\n            }\n        }\n        return success;\n    }\n}\n\ncontract IDowntimeCostCalculator {\n    \n    \n    \n    \n    \n    \n    \n    function getDowntimeCostLRC(\n        uint  totalTimeInMaintenanceSeconds,\n        uint  totalDEXLifeTimeSeconds,\n        uint  numDowntimeMinutes,\n        uint  exchangeStakedLRC,\n        uint  durationToPurchaseMinutes\n        )\n        external\n        view\n        returns (uint cost);\n}\n\nlibrary ExchangeMode {\n    using MathUint  for uint;\n\n    function isInWithdrawalMode(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool result)\n    {\n        result = false;\n        ExchangeData.Block storage currentBlock = S.blocks[S.blocks.length - 1];\n\n        \n        if (currentBlock.numDepositRequestsCommitted < S.depositChain.length) {\n            uint32 requestTimestamp = S.depositChain[currentBlock.numDepositRequestsCommitted].timestamp;\n            result = requestTimestamp < now.sub(ExchangeData.MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE());\n        }\n\n        \n        if (result == false && currentBlock.numWithdrawalRequestsCommitted < S.withdrawalChain.length) {\n            uint32 requestTimestamp = S.withdrawalChain[currentBlock.numWithdrawalRequestsCommitted].timestamp;\n            result = requestTimestamp < now.sub(ExchangeData.MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE());\n        }\n\n        \n        if (result == false) {\n            result = isAnyUnfinalizedBlockTooOld(S);\n        }\n\n        \n        if (result == false && isShutdown(S) && !isInInitialState(S)) {\n            \n            \n            uint maxTimeInShutdown = ExchangeData.MAX_TIME_IN_SHUTDOWN_BASE();\n            maxTimeInShutdown = maxTimeInShutdown.add(S.accounts.length.mul(ExchangeData.MAX_TIME_IN_SHUTDOWN_DELTA()));\n            result = now > S.shutdownStartTime.add(maxTimeInShutdown);\n        }\n    }\n\n    function isShutdown(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        return S.shutdownStartTime > 0;\n    }\n\n    function isInMaintenance(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        return S.downtimeStart != 0 && getNumDowntimeMinutesLeft(S) > 0;\n    }\n\n    function isInInitialState(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        ExchangeData.Block storage firstBlock = S.blocks[0];\n        ExchangeData.Block storage lastBlock = S.blocks[S.blocks.length - 1];\n        return (S.blocks.length == S.numBlocksFinalized) &&\n            (lastBlock.numDepositRequestsCommitted == S.depositChain.length) &&\n            (lastBlock.merkleRoot == firstBlock.merkleRoot);\n    }\n\n    function areUserRequestsEnabled(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        \n        \n        return !isInMaintenance(S) && !isShutdown(S) && !isInWithdrawalMode(S);\n    }\n\n    function isAnyUnfinalizedBlockTooOld(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (bool)\n    {\n        if (S.numBlocksFinalized < S.blocks.length) {\n            uint32 blockTimestamp = S.blocks[S.numBlocksFinalized].timestamp;\n            return blockTimestamp < now.sub(ExchangeData.MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE());\n        } else {\n            return false;\n        }\n    }\n\n    function getNumDowntimeMinutesLeft(\n        ExchangeData.State storage S\n        )\n        internal \n        view\n        returns (uint)\n    {\n        if (S.downtimeStart == 0) {\n            return S.numDowntimeMinutes;\n        } else {\n            \n            uint numDowntimeMinutesUsed = now.sub(S.downtimeStart) / 60;\n            if (S.numDowntimeMinutes > numDowntimeMinutesUsed) {\n                return S.numDowntimeMinutes.sub(numDowntimeMinutesUsed);\n            } else {\n                return 0;\n            }\n        }\n    }\n}\n\nlibrary ExchangeAdmins {\n    using MathUint          for uint;\n    using ERC20SafeTransfer for address;\n    using ExchangeMode      for ExchangeData.State;\n\n    event OperatorChanged(\n        uint    indexed exchangeId,\n        address         oldOperator,\n        address         newOperator\n    );\n\n    event AddressWhitelistChanged(\n        uint    indexed exchangeId,\n        address         oldAddressWhitelist,\n        address         newAddressWhitelist\n    );\n\n    event FeesUpdated(\n        uint    indexed exchangeId,\n        uint            accountCreationFeeETH,\n        uint            accountUpdateFeeETH,\n        uint            depositFeeETH,\n        uint            withdrawalFeeETH\n    );\n\n    function setOperator(\n        ExchangeData.State storage S,\n        address payable _operator\n        )\n        external\n        returns (address payable oldOperator)\n    {\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n        require(address(0) != _operator, \"ZERO_ADDRESS\");\n        oldOperator = S.operator;\n        S.operator = _operator;\n\n        emit OperatorChanged(\n            S.id,\n            oldOperator,\n            _operator\n        );\n    }\n\n    function setAddressWhitelist(\n        ExchangeData.State storage S,\n        address _addressWhitelist\n        )\n        external\n        returns (address oldAddressWhitelist)\n    {\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n        require(S.addressWhitelist != _addressWhitelist, \"SAME_ADDRESS\");\n\n        oldAddressWhitelist = S.addressWhitelist;\n        S.addressWhitelist = _addressWhitelist;\n\n        emit AddressWhitelistChanged(\n            S.id,\n            oldAddressWhitelist,\n            _addressWhitelist\n        );\n    }\n\n    function setFees(\n        ExchangeData.State storage S,\n        uint _accountCreationFeeETH,\n        uint _accountUpdateFeeETH,\n        uint _depositFeeETH,\n        uint _withdrawalFeeETH\n        )\n        external\n    {\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n        require(\n            _withdrawalFeeETH <= S.loopring.maxWithdrawalFee(),\n            \"AMOUNT_TOO_LARGE\"\n        );\n\n        S.accountCreationFeeETH = _accountCreationFeeETH;\n        S.accountUpdateFeeETH = _accountUpdateFeeETH;\n        S.depositFeeETH = _depositFeeETH;\n        S.withdrawalFeeETH = _withdrawalFeeETH;\n\n        emit FeesUpdated(\n            S.id,\n            _accountCreationFeeETH,\n            _accountUpdateFeeETH,\n            _depositFeeETH,\n            _withdrawalFeeETH\n        );\n    }\n\n    function startOrContinueMaintenanceMode(\n        ExchangeData.State storage S,\n        uint durationMinutes\n        )\n        external\n    {\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n        require(!S.isShutdown(), \"INVALID_MODE\");\n        require(durationMinutes > 0, \"INVALID_DURATION\");\n\n        uint numMinutesLeft = S.getNumDowntimeMinutesLeft();\n\n        \n        if (S.downtimeStart != 0 && numMinutesLeft == 0) {\n            stopMaintenanceMode(S);\n        }\n\n        \n        \n        \n        if (numMinutesLeft < durationMinutes) {\n            uint numMinutesToPurchase = durationMinutes.sub(numMinutesLeft);\n            uint costLRC = getDowntimeCostLRC(S, numMinutesToPurchase);\n            if (costLRC > 0) {\n                require(\n                    BurnableERC20(S.lrcAddress).burnFrom(msg.sender, costLRC),\n                    \"BURN_FAILURE\"\n                );\n            }\n            S.numDowntimeMinutes = S.numDowntimeMinutes.add(numMinutesToPurchase);\n        }\n\n        \n        if (S.downtimeStart == 0) {\n            S.downtimeStart = now;\n        }\n    }\n\n    function getRemainingDowntime(\n        ExchangeData.State storage S\n        )\n        external\n        view\n        returns (uint duration)\n    {\n        return S.getNumDowntimeMinutesLeft();\n    }\n\n    function withdrawExchangeStake(\n        ExchangeData.State storage S,\n        address recipient\n        )\n        external\n        returns (uint)\n    {\n        ExchangeData.Block storage lastBlock = S.blocks[S.blocks.length - 1];\n\n        \n        require(S.isShutdown(), \"EXCHANGE_NOT_SHUTDOWN\");\n        \n        require(S.blocks.length == S.numBlocksFinalized, \"BLOCK_NOT_FINALIZED\");\n        \n        require(\n            lastBlock.numDepositRequestsCommitted == S.depositChain.length,\n            \"DEPOSITS_NOT_PROCESSED\"\n        );\n        \n        \n        require(S.isInInitialState(), \"MERKLE_ROOT_NOT_REVERTED\");\n\n        \n        \n        \n        require(\n            now > lastBlock.timestamp + ExchangeData.MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS_SHUTDOWN_MODE(),\n            \"TOO_EARLY\"\n        );\n\n        \n        uint amount = S.loopring.getExchangeStake(S.id);\n        return S.loopring.withdrawExchangeStake(S.id, recipient, amount);\n    }\n\n    function withdrawTokenNotOwnedByUsers(\n        ExchangeData.State storage S,\n        address token,\n        address payable recipient\n        )\n        external\n        returns (uint amount)\n    {\n        require(token != address(0), \"ZERO_ADDRESS\");\n        require(recipient != address(0), \"ZERO_VALUE\");\n\n        uint totalBalance = ERC20(token).balanceOf(address(this));\n        uint userBalance = S.tokenBalances[token];\n\n        assert(totalBalance >= userBalance);\n        amount = totalBalance - userBalance;\n\n        if (amount > 0) {\n            token.safeTransferAndVerify(recipient, amount);\n        }\n    }\n\n    function stopMaintenanceMode(\n        ExchangeData.State storage S\n        )\n        public\n    {\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n        require(!S.isShutdown(), \"INVALID_MODE\");\n        require(S.downtimeStart != 0, \"NOT_IN_MAINTENANCE_MODE\");\n\n        \n        S.totalTimeInMaintenanceSeconds = getTotalTimeInMaintenanceSeconds(S);\n\n        \n        S.numDowntimeMinutes = S.getNumDowntimeMinutesLeft();\n\n        \n        \n        \n        if (S.numDowntimeMinutes > 0) {\n            S.numDowntimeMinutes -= 1;\n        }\n\n        \n        S.downtimeStart = 0;\n    }\n\n    function getDowntimeCostLRC(\n        ExchangeData.State storage S,\n        uint durationMinutes\n        )\n        public\n        view\n        returns (uint)\n    {\n        if (durationMinutes == 0) {\n            return 0;\n        }\n\n        address costCalculatorAddr = S.loopring.downtimeCostCalculator();\n        if (costCalculatorAddr == address(0)) {\n            return 0;\n        }\n\n        return IDowntimeCostCalculator(costCalculatorAddr).getDowntimeCostLRC(\n            S.totalTimeInMaintenanceSeconds,\n            now - S.exchangeCreationTimestamp,\n            S.numDowntimeMinutes,\n            S.loopring.getExchangeStake(S.id),\n            durationMinutes\n        );\n    }\n\n    function getTotalTimeInMaintenanceSeconds(\n        ExchangeData.State storage S\n        )\n        public\n        view\n        returns (uint time)\n    {\n        time = S.totalTimeInMaintenanceSeconds;\n        if (S.downtimeStart != 0) {\n            if (S.getNumDowntimeMinutesLeft() > 0) {\n                time = time.add(now.sub(S.downtimeStart));\n            } else {\n                time = time.add(S.numDowntimeMinutes.mul(60));\n            }\n        }\n    }\n}\n\nlibrary BytesUtil {\n    function bytesToBytes32(\n        bytes memory b,\n        uint  offset\n        )\n        internal\n        pure\n        returns (bytes32)\n    {\n        return bytes32(bytesToUintX(b, offset, 32));\n    }\n\n    function bytesToUint(\n        bytes memory b,\n        uint  offset\n        )\n        internal\n        pure\n        returns (uint)\n    {\n        return bytesToUintX(b, offset, 32);\n    }\n\n    function bytesToAddress(\n        bytes memory b,\n        uint  offset\n        )\n        internal\n        pure\n        returns (address)\n    {\n        return address(bytesToUintX(b, offset, 20) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n    }\n\n    function bytesToUint16(\n        bytes memory b,\n        uint  offset\n        )\n        internal\n        pure\n        returns (uint16)\n    {\n        return uint16(bytesToUintX(b, offset, 2) & 0xFFFF);\n    }\n\n    function bytesToUintX(\n        bytes memory b,\n        uint  offset,\n        uint  numBytes\n        )\n        private\n        pure\n        returns (uint data)\n    {\n        require(b.length >= offset + numBytes, \"INVALID_SIZE\");\n        assembly {\n            data := mload(add(add(b, numBytes), offset))\n        }\n    }\n\n    function subBytes(\n        bytes memory b,\n        uint  offset\n        )\n        internal\n        pure\n        returns (bytes memory data)\n    {\n        require(b.length >= offset + 32, \"INVALID_SIZE\");\n        assembly {\n            data := add(add(b, 32), offset)\n        }\n    }\n\n    function fastSHA256(\n        bytes memory data\n        )\n        internal\n        view\n        returns (bytes32)\n    {\n        bytes32[] memory result = new bytes32[](1);\n        bool success;\n        assembly {\n             let ptr := add(data, 32)\n             success := staticcall(sub(gas, 2000), 2, ptr, mload(data), add(result, 32), 32)\n        }\n        require(success, \"SHA256_FAILED\");\n        return result[0];\n    }\n}\n\ncontract IDecompressor {\n    \n    \n    \n    function decompress(\n        bytes calldata data\n        )\n        external\n        pure\n        returns (bytes memory decompressedData);\n}\n\nlibrary ExchangeBlocks {\n    using BytesUtil         for bytes;\n    using MathUint          for uint;\n    using ExchangeMode      for ExchangeData.State;\n\n    event BlockCommitted(\n        uint    indexed blockIdx,\n        bytes32 indexed publicDataHash\n    );\n\n    event BlockFinalized(\n        uint    indexed blockIdx\n    );\n\n    event BlockVerified(\n        uint    indexed blockIdx\n    );\n\n    event Revert(\n        uint    indexed blockIdx\n    );\n\n    event ProtocolFeesUpdated(\n        uint8 takerFeeBips,\n        uint8 makerFeeBips,\n        uint8 previousTakerFeeBips,\n        uint8 previousMakerFeeBips\n    );\n\n    function commitBlock(\n        ExchangeData.State storage S,\n        uint8  blockType,\n        uint16 blockSize,\n        uint8  blockVersion,\n        bytes  calldata data,\n        bytes  calldata \n        )\n        external\n    {\n        commitBlockInternal(\n            S,\n            ExchangeData.BlockType(blockType),\n            blockSize,\n            blockVersion,\n            data\n        );\n    }\n\n    function verifyBlocks(\n        ExchangeData.State storage S,\n        uint[] calldata blockIndices,\n        uint[] calldata proofs\n        )\n        external\n    {\n        \n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n\n        \n        require(blockIndices.length > 0, \"INVALID_INPUT_ARRAYS\");\n        require(proofs.length % 8 == 0, \"INVALID_PROOF_ARRAY\");\n        require(proofs.length / 8 == blockIndices.length, \"INVALID_INPUT_ARRAYS\");\n\n        uint[] memory publicInputs = new uint[](blockIndices.length);\n        uint16 blockSize;\n        ExchangeData.BlockType blockType;\n        uint8 blockVersion;\n\n        for (uint i = 0; i < blockIndices.length; i++) {\n            uint blockIdx = blockIndices[i];\n\n            require(blockIdx < S.blocks.length, \"INVALID_BLOCK_IDX\");\n            ExchangeData.Block storage specifiedBlock = S.blocks[blockIdx];\n            require(\n                specifiedBlock.state == ExchangeData.BlockState.COMMITTED,\n                \"BLOCK_VERIFIED_ALREADY\"\n            );\n\n            \n            \n            \n            require(\n                blockIdx < S.numBlocksFinalized + ExchangeData.MAX_GAP_BETWEEN_FINALIZED_AND_VERIFIED_BLOCKS(),\n                \"PROOF_TOO_EARLY\"\n            );\n\n            \n            require(\n                now <= specifiedBlock.timestamp + ExchangeData.MAX_PROOF_GENERATION_TIME_IN_SECONDS(),\n                \"PROOF_TOO_LATE\"\n            );\n\n            \n            \n            publicInputs[i] = uint(specifiedBlock.publicDataHash) >> 3;\n            if (i == 0) {\n                blockSize = specifiedBlock.blockSize;\n                blockType = specifiedBlock.blockType;\n                blockVersion = specifiedBlock.blockVersion;\n            } else {\n                \n                require(blockType == specifiedBlock.blockType, \"INVALID_BATCH_BLOCK_TYPE\");\n                require(blockSize == specifiedBlock.blockSize, \"INVALID_BATCH_BLOCK_SIZE\");\n                require(blockVersion == specifiedBlock.blockVersion, \"INVALID_BATCH_BLOCK_VERSION\");\n            }\n        }\n\n        \n        require(\n            S.blockVerifier.verifyProofs(\n                uint8(blockType),\n                S.onchainDataAvailability,\n                blockSize,\n                blockVersion,\n                publicInputs,\n                proofs\n            ),\n            \"INVALID_PROOF\"\n        );\n\n        \n        for (uint i = 0; i < blockIndices.length; i++) {\n            uint blockIdx = blockIndices[i];\n            ExchangeData.Block storage specifiedBlock = S.blocks[blockIdx];\n            \n            require(\n                specifiedBlock.state == ExchangeData.BlockState.COMMITTED,\n                \"BLOCK_VERIFIED_ALREADY\"\n            );\n            specifiedBlock.state = ExchangeData.BlockState.VERIFIED;\n            emit BlockVerified(blockIdx);\n        }\n\n        \n        \n        \n        \n        uint idx = S.numBlocksFinalized;\n        while (idx < S.blocks.length &&\n            S.blocks[idx].state == ExchangeData.BlockState.VERIFIED) {\n            emit BlockFinalized(idx);\n            idx++;\n        }\n        S.numBlocksFinalized = idx;\n    }\n\n    function revertBlock(\n        ExchangeData.State storage S,\n        uint blockIdx\n        )\n        external\n    {\n        \n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n\n        require(blockIdx < S.blocks.length, \"INVALID_BLOCK_IDX\");\n        ExchangeData.Block storage specifiedBlock = S.blocks[blockIdx];\n        require(specifiedBlock.state == ExchangeData.BlockState.COMMITTED, \"INVALID_BLOCK_STATE\");\n\n        \n        require(blockIdx >= S.numBlocksFinalized, \"FINALIZED_BLOCK_REVERT_PROHIBITED\");\n\n        \n        uint fine = S.loopring.revertFineLRC();\n        S.loopring.burnExchangeStake(S.id, fine);\n\n        \n        S.blocks.length = blockIdx;\n\n        emit Revert(blockIdx);\n    }\n\n    \n    function commitBlockInternal(\n        ExchangeData.State storage S,\n        ExchangeData.BlockType blockType,\n        uint16 blockSize,\n        uint8  blockVersion,\n        bytes  memory data  \n                            \n                            \n                            \n        )\n        private\n    {\n        \n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n\n        \n        require(\n            S.loopring.canExchangeCommitBlocks(S.id, S.onchainDataAvailability),\n            \"INSUFFICIENT_EXCHANGE_STAKE\"\n        );\n\n        \n        require(\n            S.blockVerifier.isCircuitEnabled(\n                uint8(blockType),\n                S.onchainDataAvailability,\n                blockSize,\n                blockVersion\n            ),\n            \"CANNOT_VERIFY_BLOCK\"\n        );\n\n        \n        uint32 exchangeIdInData = 0;\n        assembly {\n            exchangeIdInData := and(mload(add(data, 4)), 0xFFFFFFFF)\n        }\n        require(exchangeIdInData == S.id, \"INVALID_EXCHANGE_ID\");\n\n        \n        ExchangeData.Block storage prevBlock = S.blocks[S.blocks.length - 1];\n\n        \n        bytes32 merkleRootBefore;\n        bytes32 merkleRootAfter;\n        assembly {\n            merkleRootBefore := mload(add(data, 36))\n            merkleRootAfter := mload(add(data, 68))\n        }\n        require(merkleRootBefore == prevBlock.merkleRoot, \"INVALID_MERKLE_ROOT\");\n        require(uint256(merkleRootAfter) < ExchangeData.SNARK_SCALAR_FIELD(), \"INVALID_MERKLE_ROOT\");\n\n        uint32 numDepositRequestsCommitted = uint32(prevBlock.numDepositRequestsCommitted);\n        uint32 numWithdrawalRequestsCommitted = uint32(prevBlock.numWithdrawalRequestsCommitted);\n\n        \n        \n        \n        \n        if (S.isShutdown()) {\n            if (numDepositRequestsCommitted < S.depositChain.length) {\n                require(blockType == ExchangeData.BlockType.DEPOSIT, \"SHUTDOWN_DEPOSIT_BLOCK_FORCED\");\n            } else {\n                require(blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL, \"SHUTDOWN_WITHDRAWAL_BLOCK_FORCED\");\n            }\n        }\n\n        \n        \n        \n        if (isWithdrawalRequestForced(S, numWithdrawalRequestsCommitted)) {\n            require(blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL, \"WITHDRAWAL_BLOCK_FORCED\");\n        } else if (isDepositRequestForced(S, numDepositRequestsCommitted)) {\n            require(blockType == ExchangeData.BlockType.DEPOSIT, \"DEPOSIT_BLOCK_FORCED\");\n        }\n\n        if (blockType == ExchangeData.BlockType.RING_SETTLEMENT) {\n            require(S.areUserRequestsEnabled(), \"SETTLEMENT_SUSPENDED\");\n            uint32 inputTimestamp;\n            uint8 protocolTakerFeeBips;\n            uint8 protocolMakerFeeBips;\n            assembly {\n                inputTimestamp := and(mload(add(data, 72)), 0xFFFFFFFF)\n                protocolTakerFeeBips := and(mload(add(data, 73)), 0xFF)\n                protocolMakerFeeBips := and(mload(add(data, 74)), 0xFF)\n            }\n            require(\n                inputTimestamp > now - ExchangeData.TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() &&\n                inputTimestamp < now + ExchangeData.TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS(),\n                \"INVALID_TIMESTAMP\"\n            );\n            require(\n                validateAndUpdateProtocolFeeValues(S, protocolTakerFeeBips, protocolMakerFeeBips),\n                \"INVALID_PROTOCOL_FEES\"\n            );\n        } else if (blockType == ExchangeData.BlockType.DEPOSIT) {\n            uint startIdx = 0;\n            uint count = 0;\n            assembly {\n                startIdx := and(mload(add(data, 136)), 0xFFFFFFFF)\n                count := and(mload(add(data, 140)), 0xFFFFFFFF)\n            }\n            require (startIdx == numDepositRequestsCommitted, \"INVALID_REQUEST_RANGE\");\n            require (count <= blockSize, \"INVALID_REQUEST_RANGE\");\n            require (startIdx + count <= S.depositChain.length, \"INVALID_REQUEST_RANGE\");\n\n            bytes32 startingHash = S.depositChain[startIdx - 1].accumulatedHash;\n            bytes32 endingHash = S.depositChain[startIdx + count - 1].accumulatedHash;\n            \n            for (uint i = count; i < blockSize; i++) {\n                endingHash = sha256(\n                    abi.encodePacked(\n                        endingHash,\n                        uint24(0),\n                        uint(0),\n                        uint(0),\n                        uint8(0),\n                        uint96(0)\n                    )\n                );\n            }\n            bytes32 inputStartingHash = 0x0;\n            bytes32 inputEndingHash = 0x0;\n            assembly {\n                inputStartingHash := mload(add(data, 100))\n                inputEndingHash := mload(add(data, 132))\n            }\n            require(inputStartingHash == startingHash, \"INVALID_STARTING_HASH\");\n            require(inputEndingHash == endingHash, \"INVALID_ENDING_HASH\");\n\n            numDepositRequestsCommitted += uint32(count);\n        } else if (blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL) {\n            uint startIdx = 0;\n            uint count = 0;\n            assembly {\n                startIdx := and(mload(add(data, 136)), 0xFFFFFFFF)\n                count := and(mload(add(data, 140)), 0xFFFFFFFF)\n            }\n            require (startIdx == numWithdrawalRequestsCommitted, \"INVALID_REQUEST_RANGE\");\n            require (count <= blockSize, \"INVALID_REQUEST_RANGE\");\n            require (startIdx + count <= S.withdrawalChain.length, \"INVALID_REQUEST_RANGE\");\n\n            if (S.isShutdown()) {\n                require (count == 0, \"INVALID_WITHDRAWAL_COUNT\");\n                \n                \n            } else {\n                require (count > 0, \"INVALID_WITHDRAWAL_COUNT\");\n                bytes32 startingHash = S.withdrawalChain[startIdx - 1].accumulatedHash;\n                bytes32 endingHash = S.withdrawalChain[startIdx + count - 1].accumulatedHash;\n                \n                for (uint i = count; i < blockSize; i++) {\n                    endingHash = sha256(\n                        abi.encodePacked(\n                            endingHash,\n                            uint24(0),\n                            uint8(0),\n                            uint96(0)\n                        )\n                    );\n                }\n                bytes32 inputStartingHash = 0x0;\n                bytes32 inputEndingHash = 0x0;\n                assembly {\n                    inputStartingHash := mload(add(data, 100))\n                    inputEndingHash := mload(add(data, 132))\n                }\n                require(inputStartingHash == startingHash, \"INVALID_STARTING_HASH\");\n                require(inputEndingHash == endingHash, \"INVALID_ENDING_HASH\");\n                numWithdrawalRequestsCommitted += uint32(count);\n            }\n        } else if (\n            blockType != ExchangeData.BlockType.OFFCHAIN_WITHDRAWAL &&\n            blockType != ExchangeData.BlockType.ORDER_CANCELLATION &&\n            blockType != ExchangeData.BlockType.TRANSFER) {\n            revert(\"UNSUPPORTED_BLOCK_TYPE\");\n        }\n\n        \n        bytes32 publicDataHash = data.fastSHA256();\n\n        \n        bytes memory withdrawals = new bytes(0);\n        if (blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL ||\n            blockType == ExchangeData.BlockType.OFFCHAIN_WITHDRAWAL) {\n            uint start = 4 + 32 + 32;\n            if (blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL) {\n                start += 32 + 32 + 4 + 4;\n            }\n            uint length = 7 * blockSize;\n            assembly {\n                withdrawals := add(data, start)\n                mstore(withdrawals, length)\n            }\n        }\n\n        \n        ExchangeData.Block memory newBlock = ExchangeData.Block(\n            merkleRootAfter,\n            publicDataHash,\n            ExchangeData.BlockState.COMMITTED,\n            blockType,\n            blockSize,\n            blockVersion,\n            uint32(now),\n            numDepositRequestsCommitted,\n            numWithdrawalRequestsCommitted,\n            false,\n            0,\n            withdrawals\n        );\n\n        S.blocks.push(newBlock);\n\n        emit BlockCommitted(S.blocks.length - 1, publicDataHash);\n    }\n\n    function validateAndUpdateProtocolFeeValues(\n        ExchangeData.State storage S,\n        uint8 takerFeeBips,\n        uint8 makerFeeBips\n        )\n        private\n        returns (bool)\n    {\n        ExchangeData.ProtocolFeeData storage data = S.protocolFeeData;\n        if (now > data.timestamp + ExchangeData.MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED()) {\n            \n            data.previousTakerFeeBips = data.takerFeeBips;\n            data.previousMakerFeeBips = data.makerFeeBips;\n            \n            (data.takerFeeBips, data.makerFeeBips) = S.loopring.getProtocolFeeValues(\n                S.id,\n                S.onchainDataAvailability\n            );\n            data.timestamp = uint32(now);\n\n            bool feeUpdated = (data.takerFeeBips != data.previousTakerFeeBips) ||\n                (data.makerFeeBips != data.previousMakerFeeBips);\n\n            if (feeUpdated) {\n                emit ProtocolFeesUpdated(\n                    data.takerFeeBips,\n                    data.makerFeeBips,\n                    data.previousTakerFeeBips,\n                    data.previousMakerFeeBips\n                );\n            }\n        }\n        \n        return (takerFeeBips == data.takerFeeBips && makerFeeBips == data.makerFeeBips) ||\n            (takerFeeBips == data.previousTakerFeeBips && makerFeeBips == data.previousMakerFeeBips);\n    }\n\n    function isDepositRequestForced(\n        ExchangeData.State storage S,\n        uint numRequestsCommitted\n        )\n        private\n        view\n        returns (bool)\n    {\n        if (numRequestsCommitted == S.depositChain.length) {\n            return false;\n        } else {\n            return S.depositChain[numRequestsCommitted].timestamp < now.sub(\n                ExchangeData.MAX_AGE_REQUEST_UNTIL_FORCED());\n        }\n    }\n\n    function isWithdrawalRequestForced(\n        ExchangeData.State storage S,\n        uint numRequestsCommitted\n        )\n        private\n        view\n        returns (bool)\n    {\n        if (numRequestsCommitted == S.withdrawalChain.length) {\n            return false;\n        } else {\n            return S.withdrawalChain[numRequestsCommitted].timestamp < now.sub(\n                ExchangeData.MAX_AGE_REQUEST_UNTIL_FORCED());\n        }\n    }\n}\n\nlibrary AddressUtil {\n    using AddressUtil for *;\n\n    function isContract(\n        address addr\n        )\n        internal\n        view\n        returns (bool)\n    {\n        uint32 size;\n        assembly { size := extcodesize(addr) }\n        return (size > 0);\n    }\n\n    function toPayable(\n        address addr\n        )\n        internal\n        pure\n        returns (address payable)\n    {\n        return address(uint160(addr));\n    }\n\n    \n    \n    function sendETH(\n        address to,\n        uint    amount,\n        uint    gasLimit\n        )\n        internal\n        returns (bool success)\n    {\n        if (amount == 0) {\n            return true;\n        }\n        address payable recipient = to.toPayable();\n        \n        (success, ) = recipient.call.value(amount).gas(gasLimit)(\"\");\n    }\n\n    \n    \n    function sendETHAndVerify(\n        address to,\n        uint    amount,\n        uint    gasLimit\n        )\n        internal\n        returns (bool success)\n    {\n        success = to.sendETH(amount, gasLimit);\n        require(success, \"TRANSFER_FAILURE\");\n    }\n}\n\nlibrary ExchangeTokens {\n    using MathUint          for uint;\n    using ExchangeMode      for ExchangeData.State;\n\n    event TokenRegistered(\n        address indexed token,\n        uint16  indexed tokenId\n    );\n\n    function registerToken(\n        ExchangeData.State storage S,\n        address tokenAddress\n        )\n        external\n        returns (uint16 tokenID)\n    {\n        tokenID = registerToken(\n            S,\n            tokenAddress,\n            getLRCFeeForRegisteringOneMoreToken(S)\n        );\n    }\n\n    function getTokenAddress(\n        ExchangeData.State storage S,\n        uint16 tokenID\n        )\n        external\n        view\n        returns (address)\n    {\n        require(tokenID < S.tokens.length, \"INVALID_TOKEN_ID\");\n        return S.tokens[tokenID].token;\n    }\n\n    function getLRCFeeForRegisteringOneMoreToken(\n        ExchangeData.State storage S\n        )\n        public\n        view\n        returns (uint feeLRC)\n    {\n        return S.loopring.tokenRegistrationFeeLRCBase().add(\n            S.loopring.tokenRegistrationFeeLRCDelta().mul(S.tokens.length)\n        );\n    }\n\n    function registerToken(\n        ExchangeData.State storage S,\n        address tokenAddress,\n        uint    amountToBurn\n        )\n        public\n        returns (uint16 tokenID)\n    {\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n        require(S.tokenToTokenId[tokenAddress] == 0, \"TOKEN_ALREADY_EXIST\");\n        require(S.tokens.length < ExchangeData.MAX_NUM_TOKENS(), \"TOKEN_REGISTRY_FULL\");\n\n        if (amountToBurn > 0) {\n            require(BurnableERC20(S.lrcAddress).burnFrom(msg.sender, amountToBurn), \"BURN_FAILURE\");\n        }\n\n        ExchangeData.Token memory token = ExchangeData.Token(tokenAddress, false);\n        S.tokens.push(token);\n        tokenID = uint16(S.tokens.length - 1);\n        S.tokenToTokenId[tokenAddress] = tokenID + 1;\n\n        emit TokenRegistered(tokenAddress, tokenID);\n    }\n\n    function getTokenID(\n        ExchangeData.State storage S,\n        address tokenAddress\n        )\n        public\n        view\n        returns (uint16 tokenID)\n    {\n        tokenID = S.tokenToTokenId[tokenAddress];\n        require(tokenID != 0, \"TOKEN_NOT_FOUND\");\n        tokenID = tokenID - 1;\n    }\n\n    function disableTokenDeposit(\n        ExchangeData.State storage S,\n        address tokenAddress\n        )\n        external\n    {\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n\n        require(tokenAddress != address(0), \"ETHER_CANNOT_BE_DISABLED\");\n        require(tokenAddress != S.loopring.wethAddress(), \"WETH_CANNOT_BE_DISABLED\");\n        require(tokenAddress != S.loopring.lrcAddress(), \"LRC_CANNOT_BE_DISABLED\");\n\n        uint16 tokenID = getTokenID(S, tokenAddress);\n        ExchangeData.Token storage token = S.tokens[tokenID];\n        require(!token.depositDisabled, \"TOKEN_DEPOSIT_ALREADY_DISABLED\");\n        token.depositDisabled = true;\n    }\n\n    function enableTokenDeposit(\n        ExchangeData.State storage S,\n        address tokenAddress\n        )\n        external\n    {\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n        uint16 tokenID = getTokenID(S, tokenAddress);\n        ExchangeData.Token storage token = S.tokens[tokenID];\n        require(token.depositDisabled, \"TOKEN_DEPOSIT_ALREADY_ENABLED\");\n        token.depositDisabled = false;\n    }\n}\n\nlibrary ExchangeDeposits {\n    using AddressUtil       for address payable;\n    using MathUint          for uint;\n    using ERC20SafeTransfer for address;\n    using ExchangeAccounts  for ExchangeData.State;\n    using ExchangeMode      for ExchangeData.State;\n    using ExchangeTokens    for ExchangeData.State;\n\n    event DepositRequested(\n        uint    indexed depositIdx,\n        uint24  indexed accountID,\n        uint16  indexed tokenID,\n        uint96          amount,\n        uint            pubKeyX,\n        uint            pubKeyY\n    );\n\n    function getDepositRequest(\n        ExchangeData.State storage S,\n        uint index\n        )\n        external\n        view\n        returns (\n          bytes32 accumulatedHash,\n          uint    accumulatedFee,\n          uint32  timestamp\n        )\n    {\n        require(index < S.depositChain.length, \"INVALID_INDEX\");\n        ExchangeData.Request storage request = S.depositChain[index];\n        accumulatedHash = request.accumulatedHash;\n        accumulatedFee = request.accumulatedFee;\n        timestamp = request.timestamp;\n    }\n\n    function depositTo(\n        ExchangeData.State storage S,\n        address recipient,\n        address tokenAddress,\n        uint96  amount,  \n        uint    additionalFeeETH\n        )\n        external\n    {\n        require(recipient != address(0), \"ZERO_ADDRESS\");\n        require(S.areUserRequestsEnabled(), \"USER_REQUEST_SUSPENDED\");\n        require(getNumAvailableDepositSlots(S) > 0, \"TOO_MANY_REQUESTS_OPEN\");\n\n        uint16 tokenID = S.getTokenID(tokenAddress);\n        require(!S.tokens[tokenID].depositDisabled, \"TOKEN_DEPOSIT_DISABLED\");\n\n        uint24 accountID = S.getAccountID(recipient);\n        ExchangeData.Account storage account = S.accounts[accountID];\n\n        \n        \n        \n        \n        require(account.pubKeyX > 0, \"INVALID_PUBKEY\");\n        \n        require(account.pubKeyX < ExchangeData.SNARK_SCALAR_FIELD(), \"INVALID_PUBKEY\");\n        require(account.pubKeyY < ExchangeData.SNARK_SCALAR_FIELD(), \"INVALID_PUBKEY\");\n\n        \n        uint feeETH = additionalFeeETH.add(S.depositFeeETH);\n\n        \n        transferDeposit(\n            msg.sender,\n            tokenAddress,\n            amount,\n            feeETH\n        );\n\n        \n        ExchangeData.Request storage prevRequest = S.depositChain[S.depositChain.length - 1];\n        ExchangeData.Request memory request = ExchangeData.Request(\n            sha256(\n                abi.encodePacked(\n                    prevRequest.accumulatedHash,\n                    accountID,\n                    account.pubKeyX,  \n                                      \n                                      \n                                      \n                    account.pubKeyY,\n                    uint8(tokenID),\n                    amount\n                )\n            ),\n            prevRequest.accumulatedFee.add(feeETH),\n            uint32(now)\n        );\n        S.depositChain.push(request);\n\n        \n        ExchangeData.Deposit memory _deposit = ExchangeData.Deposit(\n            accountID,\n            tokenID,\n            amount\n        );\n        S.deposits.push(_deposit);\n\n        S.tokenBalances[tokenAddress] = S.tokenBalances[tokenAddress].add(amount);\n\n        emit DepositRequested(\n            uint32(S.depositChain.length - 1),\n            accountID,\n            tokenID,\n            amount,\n            account.pubKeyX,\n            account.pubKeyY\n        );\n    }\n\n    function getNumDepositRequestsProcessed(\n        ExchangeData.State storage S\n        )\n        public\n        view\n        returns (uint)\n    {\n        ExchangeData.Block storage currentBlock = S.blocks[S.blocks.length - 1];\n        return currentBlock.numDepositRequestsCommitted;\n    }\n\n    function getNumAvailableDepositSlots(\n        ExchangeData.State storage S\n        )\n        public\n        view\n        returns (uint)\n    {\n        uint numOpenRequests = S.depositChain.length - getNumDepositRequestsProcessed(S);\n        return ExchangeData.MAX_OPEN_DEPOSIT_REQUESTS() - numOpenRequests;\n    }\n\n    function transferDeposit(\n        address source,\n        address tokenAddress,\n        uint    amount,\n        uint    feeETH\n        )\n        private\n    {\n        uint totalRequiredETH = feeETH;\n        if (tokenAddress == address(0)) {\n            totalRequiredETH = totalRequiredETH.add(amount);\n        }\n\n        require(msg.value >= totalRequiredETH, \"INSUFFICIENT_FEE\");\n        uint feeSurplus = msg.value.sub(totalRequiredETH);\n        if (feeSurplus > 0) {\n            msg.sender.sendETHAndVerify(feeSurplus, gasleft());\n        }\n\n        \n        if (amount > 0 && tokenAddress != address(0)) {\n            tokenAddress.safeTransferFromAndVerify(\n                source,\n                address(this),\n                amount\n            );\n        }\n    }\n}\n\nlibrary ExchangeGenesis {\n    using ExchangeAccounts  for ExchangeData.State;\n    using ExchangeTokens    for ExchangeData.State;\n\n    function initializeGenesisBlock(\n        ExchangeData.State storage S,\n        uint    _id,\n        address _loopringAddress,\n        address payable _operator,\n        bool    _onchainDataAvailability,\n        bytes32 _genesisBlockHash\n        )\n        external\n    {\n        require(0 != _id, \"INVALID_ID\");\n        require(address(0) != _loopringAddress, \"ZERO_ADDRESS\");\n        require(address(0) != _operator, \"ZERO_ADDRESS\");\n        require(_genesisBlockHash != 0, \"ZERO_GENESIS_BLOCK_HASH\");\n        require(S.id == 0, \"INITIALIZED_ALREADY\");\n\n        S.id = _id;\n        S.exchangeCreationTimestamp = now;\n        S.loopring = ILoopringV3(_loopringAddress);\n        S.operator = _operator;\n        S.onchainDataAvailability = _onchainDataAvailability;\n\n        ILoopringV3 loopring = ILoopringV3(_loopringAddress);\n        S.blockVerifier = IBlockVerifier(loopring.blockVerifierAddress());\n        S.lrcAddress = loopring.lrcAddress();\n\n        ExchangeData.Block memory genesisBlock = ExchangeData.Block(\n            _genesisBlockHash,\n            0x0,\n            ExchangeData.BlockState.VERIFIED,\n            ExchangeData.BlockType(0),\n            0,\n            0,\n            uint32(now),\n            1,\n            1,\n            true,\n            0,\n            new bytes(0)\n        );\n        S.blocks.push(genesisBlock);\n        S.numBlocksFinalized = 1;\n\n        ExchangeData.Request memory genesisRequest = ExchangeData.Request(\n            0,\n            0,\n            0xFFFFFFFF\n        );\n        S.depositChain.push(genesisRequest);\n        S.withdrawalChain.push(genesisRequest);\n\n        \n        \n        ExchangeData.Account memory protocolFeePoolAccount = ExchangeData.Account(\n            address(0),\n            uint(0),\n            uint(0)\n        );\n\n        S.accounts.push(protocolFeePoolAccount);\n        S.ownerToAccountId[protocolFeePoolAccount.owner] = uint24(S.accounts.length);\n\n        \n        S.protocolFeeData.timestamp = uint32(0);\n        S.protocolFeeData.takerFeeBips = S.loopring.maxProtocolTakerFeeBips();\n        S.protocolFeeData.makerFeeBips = S.loopring.maxProtocolMakerFeeBips();\n        S.protocolFeeData.previousTakerFeeBips = S.protocolFeeData.takerFeeBips;\n        S.protocolFeeData.previousMakerFeeBips = S.protocolFeeData.makerFeeBips;\n\n        \n        S.registerToken(address(0), 0);\n        S.registerToken(loopring.wethAddress(), 0);\n        S.registerToken(S.lrcAddress, 0);\n    }\n}\n\nlibrary ExchangeWithdrawals {\n    using AddressUtil       for address;\n    using AddressUtil       for address payable;\n    using MathUint          for uint;\n    using ERC20SafeTransfer for address;\n    using ExchangeAccounts  for ExchangeData.State;\n    using ExchangeBalances  for ExchangeData.State;\n    using ExchangeMode      for ExchangeData.State;\n    using ExchangeTokens    for ExchangeData.State;\n\n    event BlockFeeWithdrawn(\n        uint    indexed blockIdx,\n        uint            amount\n    );\n\n    event WithdrawalRequested(\n        uint    indexed withdrawalIdx,\n        uint24  indexed accountID,\n        uint16  indexed tokenID,\n        uint96          amount\n    );\n\n    event WithdrawalCompleted(\n        uint24  indexed accountID,\n        uint16  indexed tokenID,\n        address         to,\n        uint96          amount\n    );\n\n    event WithdrawalFailed(\n        uint24  indexed accountID,\n        uint16  indexed tokenID,\n        address         to,\n        uint96          amount\n    );\n\n    function getWithdrawRequest(\n        ExchangeData.State storage S,\n        uint index\n        )\n        external\n        view\n        returns (\n            bytes32 accumulatedHash,\n            uint    accumulatedFee,\n            uint32  timestamp\n        )\n    {\n        require(index < S.withdrawalChain.length, \"INVALID_INDEX\");\n        ExchangeData.Request storage request = S.withdrawalChain[index];\n        accumulatedHash = request.accumulatedHash;\n        accumulatedFee = request.accumulatedFee;\n        timestamp = request.timestamp;\n    }\n\n    function withdraw(\n        ExchangeData.State storage S,\n        uint24  accountID,\n        address token,\n        uint96  amount\n        )\n        external\n    {\n        require(amount > 0, \"ZERO_VALUE\");\n        require(!S.isInWithdrawalMode(), \"INVALID_MODE\");\n        require(S.areUserRequestsEnabled(), \"USER_REQUEST_SUSPENDED\");\n        require(getNumAvailableWithdrawalSlots(S) > 0, \"TOO_MANY_REQUESTS_OPEN\");\n\n        uint16 tokenID = S.getTokenID(token);\n\n        \n        require(msg.value >= S.withdrawalFeeETH, \"INSUFFICIENT_FEE\");\n\n        \n        uint feeSurplus = msg.value.sub(S.withdrawalFeeETH);\n        if (feeSurplus > 0) {\n            msg.sender.sendETHAndVerify(feeSurplus, gasleft());\n        }\n\n        \n        ExchangeData.Request storage prevRequest = S.withdrawalChain[S.withdrawalChain.length - 1];\n        ExchangeData.Request memory request = ExchangeData.Request(\n            sha256(\n                abi.encodePacked(\n                    prevRequest.accumulatedHash,\n                    accountID,\n                    uint8(tokenID),\n                    amount\n                )\n            ),\n            prevRequest.accumulatedFee.add(S.withdrawalFeeETH),\n            uint32(now)\n        );\n        S.withdrawalChain.push(request);\n\n        emit WithdrawalRequested(\n            uint32(S.withdrawalChain.length - 1),\n            accountID,\n            tokenID,\n            amount\n        );\n    }\n\n    \n    function withdrawFromMerkleTreeFor(\n        ExchangeData.State storage S,\n        address  owner,\n        address  token,\n        uint     pubKeyX,\n        uint     pubKeyY,\n        uint32   nonce,\n        uint96   balance,\n        uint     tradeHistoryRoot,\n        uint[30] calldata accountMerkleProof,\n        uint[12] calldata balanceMerkleProof\n        )\n        external\n    {\n        require(S.isInWithdrawalMode(), \"NOT_IN_WITHDRAW_MODE\");\n\n        ExchangeData.Block storage lastFinalizedBlock = S.blocks[S.numBlocksFinalized - 1];\n\n        uint24 accountID = S.getAccountID(owner);\n        uint16 tokenID = S.getTokenID(token);\n        require(S.withdrawnInWithdrawMode[owner][token] == false, \"WITHDRAWN_ALREADY\");\n\n        ExchangeBalances.verifyAccountBalance(\n            uint(lastFinalizedBlock.merkleRoot),\n            accountID,\n            tokenID,\n            pubKeyX,\n            pubKeyY,\n            nonce,\n            balance,\n            tradeHistoryRoot,\n            accountMerkleProof,\n            balanceMerkleProof\n        );\n\n        \n        S.withdrawnInWithdrawMode[owner][token] = true;\n\n        \n        transferTokens(\n            S,\n            accountID,\n            tokenID,\n            balance,\n            false\n        );\n    }\n\n    function getNumWithdrawalRequestsProcessed(\n        ExchangeData.State storage S\n        )\n        public\n        view\n        returns (uint)\n    {\n        ExchangeData.Block storage currentBlock = S.blocks[S.blocks.length - 1];\n        return currentBlock.numWithdrawalRequestsCommitted;\n    }\n\n    function getNumAvailableWithdrawalSlots(\n        ExchangeData.State storage S\n        )\n        public\n        view\n        returns (uint)\n    {\n        uint numOpenRequests = S.withdrawalChain.length - getNumWithdrawalRequestsProcessed(S);\n        return ExchangeData.MAX_OPEN_WITHDRAWAL_REQUESTS() - numOpenRequests;\n    }\n\n    function withdrawFromDepositRequest(\n        ExchangeData.State storage S,\n        uint depositIdx\n        )\n        external\n    {\n        require(S.isInWithdrawalMode(), \"NOT_IN_WITHDRAW_MODE\");\n\n        ExchangeData.Block storage lastFinalizedBlock = S.blocks[S.numBlocksFinalized - 1];\n        require(depositIdx >= lastFinalizedBlock.numDepositRequestsCommitted, \"REQUEST_INCLUDED_IN_FINALIZED_BLOCK\");\n\n        \n        ExchangeData.Deposit storage _deposit = S.deposits[depositIdx.sub(1)];\n\n        uint amount = _deposit.amount;\n        require(amount > 0, \"WITHDRAWN_ALREADY\");\n\n        \n        _deposit.amount = 0;\n\n        \n        transferTokens(\n            S,\n            _deposit.accountID,\n            _deposit.tokenID,\n            amount,\n            false\n        );\n    }\n\n    function withdrawFromApprovedWithdrawal(\n        ExchangeData.State storage S,\n        uint blockIdx,\n        ExchangeData.Block storage withdrawBlock,\n        uint slotIdx,\n        bool allowFailure\n        )\n        public\n        returns (bool success)\n    {\n        require(slotIdx < withdrawBlock.blockSize, \"INVALID_SLOT_IDX\");\n        \n        require(blockIdx < S.numBlocksFinalized, \"BLOCK_NOT_FINALIZED\");\n\n        \n        uint[] memory slice = new uint[](2);\n        uint slot = (7 * slotIdx) / 32;\n        uint offset = (7 * (slotIdx + 1)) - (slot * 32);\n        uint sc = 0;\n        uint data = 0;\n        \n        if (withdrawBlock.withdrawals.length >= 32) {\n            bytes storage withdrawals = withdrawBlock.withdrawals;\n            uint dataSlot1 = 0;\n            uint dataSlot2 = 0;\n            assembly {\n                \n                mstore(0x0, withdrawals_slot)\n                sc := keccak256(0x0, 0x20)\n                dataSlot1 := sload(add(sc, slot))\n                dataSlot2 := sload(add(sc, add(slot, 1)))\n            }\n            \n            \n            slice[0] = dataSlot1;\n            slice[1] = dataSlot2;\n            assembly {\n                data := mload(add(slice, offset))\n            }\n        } else {\n            bytes memory mWithdrawals = withdrawBlock.withdrawals;\n            assembly {\n                data := mload(add(mWithdrawals, offset))\n            }\n        }\n\n        \n        uint16 tokenID = uint16((data >> 48) & 0xFF);\n        uint24 accountID = uint24((data >> 28) & 0xFFFFF);\n        uint amount = (data & 0xFFFFFFF).decodeFloat();\n\n        \n        success = transferTokens(\n            S,\n            accountID,\n            tokenID,\n            amount,\n            allowFailure\n        );\n\n        if (success && amount > 0) {\n            \n            data = data & uint(~((1 << (7 * 8)) - 1));\n\n            \n            if (withdrawBlock.withdrawals.length >= 32) {\n                assembly {\n                    mstore(add(slice, offset), data)\n                }\n                uint dataSlot1 = slice[0];\n                uint dataSlot2 = slice[1];\n                assembly {\n                    sstore(add(sc, slot), dataSlot1)\n                    sstore(add(sc, add(slot, 1)), dataSlot2)\n                }\n            } else {\n                bytes memory mWithdrawals = withdrawBlock.withdrawals;\n                assembly {\n                    mstore(add(mWithdrawals, offset), data)\n                }\n                withdrawBlock.withdrawals = mWithdrawals;\n            }\n        }\n    }\n\n    function withdrawBlockFee(\n        ExchangeData.State storage S,\n        uint blockIdx,\n        address payable feeRecipient\n        )\n        external\n        returns (uint feeAmountToOperator)\n    {\n        require(blockIdx > 0 && blockIdx < S.blocks.length, \"INVALID_BLOCK_IDX\");\n        ExchangeData.Block storage requestedBlock = S.blocks[blockIdx];\n        ExchangeData.Block storage previousBlock = S.blocks[blockIdx - 1];\n\n        require(blockIdx < S.numBlocksFinalized, \"BLOCK_NOT_FINALIZED\");\n        require(requestedBlock.blockFeeWithdrawn == false, \"FEE_WITHDRAWN_ALREADY\");\n\n        uint feeAmount = 0;\n        uint32 lastRequestTimestamp = 0;\n        {\n        uint startIndex = previousBlock.numDepositRequestsCommitted;\n        uint endIndex = requestedBlock.numDepositRequestsCommitted;\n        if(endIndex > startIndex) {\n            feeAmount = S.depositChain[endIndex - 1].accumulatedFee.sub(\n                S.depositChain[startIndex - 1].accumulatedFee\n            );\n            lastRequestTimestamp = S.depositChain[endIndex - 1].timestamp;\n        } else {\n            startIndex = previousBlock.numWithdrawalRequestsCommitted;\n            endIndex = requestedBlock.numWithdrawalRequestsCommitted;\n\n            if(endIndex > startIndex) {\n                feeAmount = S.withdrawalChain[endIndex - 1].accumulatedFee.sub(\n                    S.withdrawalChain[startIndex - 1].accumulatedFee\n                );\n                lastRequestTimestamp = S.withdrawalChain[endIndex - 1].timestamp;\n            } else {\n                revert(\"BLOCK_HAS_NO_OPERATOR_FEE\");\n            }\n        }\n        }\n\n        \n        \n        \n        \n        \n        \n        uint32 blockTimestamp = requestedBlock.timestamp;\n        uint32 startTime = lastRequestTimestamp + ExchangeData.FEE_BLOCK_FINE_START_TIME();\n        uint fine = 0;\n        if (blockTimestamp > startTime) {\n            fine = feeAmount.mul(blockTimestamp - startTime) / ExchangeData.FEE_BLOCK_FINE_MAX_DURATION();\n        }\n        uint feeAmountToBurn = (fine > feeAmount) ? feeAmount : fine;\n        feeAmountToOperator = feeAmount - feeAmountToBurn;\n\n        \n        requestedBlock.blockFeeWithdrawn = true;\n\n        \n        S.loopring.protocolFeeVault().sendETHAndVerify(feeAmountToBurn, gasleft());\n        \n        feeRecipient.sendETHAndVerify(feeAmountToOperator, gasleft());\n\n        emit BlockFeeWithdrawn(blockIdx, feeAmount);\n    }\n\n    function distributeWithdrawals(\n        ExchangeData.State storage S,\n        uint blockIdx,\n        uint maxNumWithdrawals\n        )\n        external\n    {\n        require(blockIdx < S.blocks.length, \"INVALID_BLOCK_IDX\");\n        require(maxNumWithdrawals > 0, \"INVALID_MAX_NUM_WITHDRAWALS\");\n        ExchangeData.Block storage withdrawBlock = S.blocks[blockIdx];\n\n        \n        require(\n            withdrawBlock.blockType == ExchangeData.BlockType.ONCHAIN_WITHDRAWAL ||\n            withdrawBlock.blockType == ExchangeData.BlockType.OFFCHAIN_WITHDRAWAL,\n            \"INVALID_BLOCK_TYPE\"\n        );\n\n        \n        require(blockIdx < S.numBlocksFinalized, \"BLOCK_NOT_FINALIZED\");\n        \n        require(withdrawBlock.numWithdrawalsDistributed < withdrawBlock.blockSize, \"WITHDRAWALS_ALREADY_DISTRIBUTED\");\n\n        \n        \n        bool bOnlyOperator = now < withdrawBlock.timestamp + ExchangeData.MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS();\n        if (bOnlyOperator) {\n            require(msg.sender == S.operator, \"UNAUTHORIZED\");\n        }\n\n        \n        uint start = withdrawBlock.numWithdrawalsDistributed;\n        uint end = start.add(maxNumWithdrawals);\n        if (end > withdrawBlock.blockSize) {\n            end = withdrawBlock.blockSize;\n        }\n\n        \n        uint gasLimit = ExchangeData.MIN_GAS_TO_DISTRIBUTE_WITHDRAWALS();\n        uint totalNumWithdrawn = start;\n        while (totalNumWithdrawn < end && gasleft() >= gasLimit) {\n            \n            \n            \n            withdrawFromApprovedWithdrawal(\n                S,\n                blockIdx,\n                withdrawBlock,\n                totalNumWithdrawn,\n                true\n            );\n            totalNumWithdrawn++;\n        }\n        withdrawBlock.numWithdrawalsDistributed = uint16(totalNumWithdrawn);\n\n        \n        if (!bOnlyOperator) {\n            \n            uint numWithdrawn = totalNumWithdrawn.sub(start);\n            uint totalFine = S.loopring.withdrawalFineLRC().mul(numWithdrawn);\n            \n            uint amountToBurn = totalFine / 2;\n            uint amountToDistributer = totalFine - amountToBurn;\n            S.loopring.burnExchangeStake(S.id, amountToBurn);\n            S.loopring.withdrawExchangeStake(S.id, msg.sender, amountToDistributer);\n        }\n    }\n\n\n    \n\n    \n    \n    \n    \n    \n    function transferTokens(\n        ExchangeData.State storage S,\n        uint24  accountID,\n        uint16  tokenID,\n        uint    amount,\n        bool    allowFailure\n        )\n        private\n        returns (bool success)\n    {\n        \n        \n        \n        \n        address to;\n        if (accountID == 0 || accountID >= S.accounts.length) {\n            to = S.loopring.protocolFeeVault();\n        } else {\n            to = S.accounts[accountID].owner;\n        }\n\n        address token = S.getTokenAddress(tokenID);\n        \n        uint gasLimit = allowFailure ? ExchangeData.GAS_LIMIT_SEND_TOKENS() : gasleft();\n\n        \n        if (amount > 0) {\n            if (token == address(0)) {\n                \n                success = to.sendETH(amount, gasLimit);\n            } else {\n                \n                success = token.safeTransferWithGasLimit(to, amount, gasLimit);\n            }\n        } else {\n            success = true;\n        }\n\n        if (!allowFailure) {\n            require(success, \"TRANSFER_FAILURE\");\n        }\n\n        if (success) {\n            if (amount > 0) {\n                S.tokenBalances[token] = S.tokenBalances[token].sub(amount);\n            }\n\n            if (accountID > 0 || tokenID > 0 || amount > 0) {\n                \n                \n                emit WithdrawalCompleted(\n                    accountID,\n                    tokenID,\n                    to,\n                    uint96(amount)\n                );\n            }\n        } else {\n            emit WithdrawalFailed(\n                accountID,\n                tokenID,\n                to,\n                uint96(amount)\n            );\n        }\n    }\n}\n\nlibrary Cloneable {\n    function clone(address a)\n        external\n        returns (address)\n    {\n\n    \n        address retval;\n        assembly{\n            mstore(0x0, or (0x5880730000000000000000000000000000000000000000803b80938091923cF3 ,mul(a,0x1000000000000000000)))\n            retval := create(0,0, 32)\n        }\n        return retval;\n    }\n}\n\ncontract IExchange is Claimable, ReentrancyGuard\n{\n    string constant public version = \"\"; \n\n    event Cloned (address indexed clone);\n\n    \n    \n    function clone()\n        external\n        nonReentrant\n        returns (address cloneAddress)\n    {\n        address origin = address(this);\n        cloneAddress = Cloneable.clone(origin);\n\n        assert(cloneAddress != origin);\n        assert(cloneAddress != address(0));\n\n        emit Cloned(cloneAddress);\n    }\n}\n\ncontract IExchangeV3 is IExchange\n{\n    \n    \n    \n    event AccountCreated(\n        address indexed owner,\n        uint24  indexed id,\n        uint            pubKeyX,\n        uint            pubKeyY\n    );\n\n    event AccountUpdated(\n        address indexed owner,\n        uint24  indexed id,\n        uint            pubKeyX,\n        uint            pubKeyY\n    );\n\n    event TokenRegistered(\n        address indexed token,\n        uint16  indexed tokenId\n    );\n\n    event OperatorChanged(\n        uint    indexed exchangeId,\n        address         oldOperator,\n        address         newOperator\n    );\n\n    event AddressWhitelistChanged(\n        uint    indexed exchangeId,\n        address         oldAddressWhitelist,\n        address         newAddressWhitelist\n    );\n\n    event FeesUpdated(\n        uint    indexed exchangeId,\n        uint            accountCreationFeeETH,\n        uint            accountUpdateFeeETH,\n        uint            depositFeeETH,\n        uint            withdrawalFeeETH\n    );\n\n    event Shutdown(\n        uint            timestamp\n    );\n\n    event BlockCommitted(\n        uint    indexed blockIdx,\n        bytes32 indexed publicDataHash\n    );\n\n    event BlockVerified(\n        uint    indexed blockIdx\n    );\n\n    event BlockFinalized(\n        uint    indexed blockIdx\n    );\n\n    event Revert(\n        uint    indexed blockIdx\n    );\n\n    event DepositRequested(\n        uint    indexed depositIdx,\n        uint24  indexed accountID,\n        uint16  indexed tokenID,\n        uint96          amount,\n        uint            pubKeyX,\n        uint            pubKeyY\n    );\n\n    event BlockFeeWithdrawn(\n        uint    indexed blockIdx,\n        uint            amount\n    );\n\n    event WithdrawalRequested(\n        uint    indexed withdrawalIdx,\n        uint24  indexed accountID,\n        uint16  indexed tokenID,\n        uint96          amount\n    );\n\n    event WithdrawalCompleted(\n        uint24  indexed accountID,\n        uint16  indexed tokenID,\n        address         to,\n        uint96          amount\n    );\n\n    event WithdrawalFailed(\n        uint24  indexed accountID,\n        uint16  indexed tokenID,\n        address         to,\n        uint96          amount\n    );\n\n    event ProtocolFeesUpdated(\n        uint8 takerFeeBips,\n        uint8 makerFeeBips,\n        uint8 previousTakerFeeBips,\n        uint8 previousMakerFeeBips\n    );\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function initialize(\n        address loopringAddress,\n        address owner,\n        uint    exchangeId,\n        address payable operator,\n        bool    onchainDataAvailability\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function getConstants()\n        external\n        pure\n        returns(uint[20] memory);\n\n    \n    \n    \n    function isInWithdrawalMode()\n        external\n        view\n        returns (bool);\n\n    \n    \n    function isShutdown()\n        external\n        view\n        returns (bool);\n\n    \n    \n    function isInMaintenance()\n        external\n        view\n        returns (bool);\n\n    \n\n    \n    \n    function getNumAccounts()\n        external\n        view\n        returns (uint);\n\n    \n    \n    \n    \n    \n    function getAccount(\n        address owner\n        )\n        external\n        view\n        returns (\n            uint24 accountID,\n            uint   pubKeyX,\n            uint   pubKeyY\n        );\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function createOrUpdateAccount(\n        uint  pubKeyX,\n        uint  pubKeyY,\n        bytes calldata permission\n        )\n        external\n        payable\n        returns (\n            uint24 accountID,\n            bool   isAccountNew,\n            bool   isAccountUpdated\n        );\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function isAccountBalanceCorrect(\n        uint     merkleRoot,\n        uint24   accountID,\n        uint16   tokenID,\n        uint     pubKeyX,\n        uint     pubKeyY,\n        uint32   nonce,\n        uint96   balance,\n        uint     tradeHistoryRoot,\n        uint[30] calldata accountMerkleProof,\n        uint[12] calldata balanceMerkleProof\n        )\n        external\n        pure\n        returns (bool);\n\n    \n\n    \n    \n    function getLRCFeeForRegisteringOneMoreToken()\n        external\n        view\n        returns (uint feeLRC);\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function registerToken(\n        address tokenAddress\n        )\n        external\n        returns (uint16 tokenID);\n\n    \n    \n    \n    function getTokenID(\n        address tokenAddress\n        )\n        external\n        view\n        returns (uint16 tokenID);\n\n    \n    \n    \n    function getTokenAddress(\n        uint16 tokenID\n        )\n        external\n        view\n        returns (address tokenAddress);\n\n    \n    \n    \n    function disableTokenDeposit(\n        address tokenAddress\n        )\n        external;\n\n    \n    \n    \n    function enableTokenDeposit(\n        address tokenAddress\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    function getExchangeStake()\n        external\n        view\n        returns (uint);\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function withdrawExchangeStake(\n        address recipient\n        )\n        external\n        returns (uint);\n\n    \n    \n    \n    \n    \n    \n    function withdrawTokenNotOwnedByUsers(\n        address tokenAddress,\n        address payable recipient\n        )\n        external\n        returns (uint);\n\n    \n    \n    \n    \n    \n    function withdrawProtocolFeeStake(\n        address recipient,\n        uint    amount\n        )\n        external;\n\n    \n    \n    \n    \n    \n    function burnExchangeStake()\n        external;\n\n    \n    \n    \n    \n    function getBlockHeight()\n        external\n        view\n        returns (uint);\n\n    \n    \n    function getNumBlocksFinalized()\n        external\n        view\n        returns (uint);\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function getBlock(\n        uint blockIdx\n        )\n        external\n        view\n        returns (\n            bytes32 merkleRoot,\n            bytes32 publicDataHash,\n            uint8   blockState,\n            uint8   blockType,\n            uint16  blockSize,\n            uint32  timestamp,\n            uint32  numDepositRequestsCommitted,\n            uint32  numWithdrawalRequestsCommitted,\n            bool    blockFeeWithdrawn,\n            uint16  numWithdrawalsDistributed\n        );\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function commitBlock(\n        uint8  blockType,\n        uint16 blockSize,\n        uint8  blockVersion,\n        bytes  calldata data,\n        bytes  calldata offchainData\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function verifyBlocks(\n        uint[] calldata blockIndices,\n        uint[] calldata proofs\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function revertBlock(\n        uint blockIdx\n        )\n        external;\n\n    \n    \n    \n    \n    \n    function getNumDepositRequestsProcessed()\n        external\n        view\n        returns (uint);\n\n    \n    \n    function getNumAvailableDepositSlots()\n        external\n        view\n        returns (uint);\n\n    \n    \n    \n    \n    \n    function getDepositRequest(\n        uint index\n        )\n        external\n        view\n        returns (\n          bytes32 accumulatedHash,\n          uint    accumulatedFee,\n          uint32  timestamp\n        );\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function updateAccountAndDeposit(\n        uint    pubKeyX,\n        uint    pubKeyY,\n        address tokenAddress,\n        uint96  amount,\n        bytes   calldata permission\n        )\n        external\n        payable\n        returns (\n            uint24 accountID,\n            bool   isAccountNew,\n            bool   isAccountUpdated\n        );\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function deposit(\n        address tokenAddress,\n        uint96  amount\n        )\n        external\n        payable;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function depositTo(\n        address recipient,\n        address tokenAddress,\n        uint96  amount\n        )\n        external\n        payable;\n\n    \n\n    \n    \n    \n    \n    function getNumWithdrawalRequestsProcessed()\n        external\n        view\n        returns (uint);\n\n    \n    \n    function getNumAvailableWithdrawalSlots(\n        )\n        external\n        view\n        returns (uint);\n\n    \n    \n    \n    \n    \n    function getWithdrawRequest(\n        uint index\n        )\n        external\n        view\n        returns (\n            bytes32 accumulatedHash,\n            uint    accumulatedFee,\n            uint32  timestamp\n        );\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function withdraw(\n        address tokenAddress,\n        uint96  amount\n        )\n        external\n        payable;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function withdrawProtocolFees(\n        address tokenAddress\n        )\n        external\n        payable;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function withdrawFromMerkleTree(\n        address  token,\n        uint     pubKeyX,\n        uint     pubKeyY,\n        uint32   nonce,\n        uint96   balance,\n        uint     tradeHistoryRoot,\n        uint[30] calldata accountMerkleProof,\n        uint[12] calldata balanceMerkleProof\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function withdrawFromMerkleTreeFor(\n        address  owner,\n        address  token,\n        uint     pubKeyX,\n        uint     pubKeyY,\n        uint32   nonce,\n        uint96   balance,\n        uint     tradeHistoryRoot,\n        uint[30] calldata accountMerkleProof,\n        uint[12] calldata balanceMerkleProof\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function withdrawFromDepositRequest(\n        uint depositIdx\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function withdrawFromApprovedWithdrawal(\n        uint blockIdx,\n        uint slotIdx\n        )\n        external;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function withdrawBlockFee(\n        uint    blockIdx,\n        address payable feeRecipient\n        )\n        external\n        returns (uint feeAmount);\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function distributeWithdrawals(\n        uint blockIdx,\n        uint maxNumWithdrawals\n        )\n        external;\n\n    \n\n    \n    \n    \n    function setOperator(\n        address payable _operator\n        )\n        external\n        returns (address payable oldOperator);\n\n    \n    \n    \n    \n    function setAddressWhitelist(\n        address _addressWhitelist\n        )\n        external\n        returns (address oldAddressWhitelist);\n\n    \n    \n    \n    \n    \n    \n    function setFees(\n        uint _accountCreationFeeETH,\n        uint _accountUpdateFeeETH,\n        uint _depositFeeETH,\n        uint _withdrawalFeeETH\n        )\n        external;\n\n    \n    \n    \n    \n    \n    function getFees()\n        external\n        view\n        returns (\n            uint _accountCreationFeeETH,\n            uint _accountUpdateFeeETH,\n            uint _depositFeeETH,\n            uint _withdrawalFeeETH\n        );\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function startOrContinueMaintenanceMode(\n        uint durationMinutes\n        )\n        external;\n\n    \n    \n    \n    function stopMaintenanceMode()\n        external;\n\n    \n    \n    function getRemainingDowntime()\n        external\n        view\n        returns (uint durationMinutes);\n\n    \n    \n    function getDowntimeCostLRC(\n        uint durationMinutes\n        )\n        external\n        view\n        returns (uint costLRC);\n\n    \n    \n    function getTotalTimeInMaintenanceSeconds()\n        external\n        view\n        returns (uint timeInSeconds);\n\n    \n    \n    function getExchangeCreationTimestamp()\n        external\n        view\n        returns (uint timestamp);\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function shutdown()\n        external\n        returns (bool success);\n\n    \n    \n    \n    \n    \n    function getRequestStats()\n        external\n        view\n        returns(\n            uint numDepositRequestsProcessed,\n            uint numAvailableDepositSlots,\n            uint numWithdrawalRequestsProcessed,\n            uint numAvailableWithdrawalSlots\n        );\n\n    \n    \n    \n    \n    \n    \n    function getProtocolFeeValues()\n        external\n        view\n        returns (\n            uint32 timestamp,\n            uint8 takerFeeBips,\n            uint8 makerFeeBips,\n            uint8 previousTakerFeeBips,\n            uint8 previousMakerFeeBips\n        );\n}\n\ncontract ExchangeV3 is IExchangeV3\n{\n    string  constant public version = \"3.0-beta3\";\n    bytes32 constant public genesisBlockHash = 0x2b4827daf74c0ab30deb68b1c337dec40579bb3ff45ce9478288e1a2b83a3a01;\n\n    using ExchangeAdmins        for ExchangeData.State;\n    using ExchangeAccounts      for ExchangeData.State;\n    using ExchangeBalances      for ExchangeData.State;\n    using ExchangeBlocks        for ExchangeData.State;\n    using ExchangeDeposits      for ExchangeData.State;\n    using ExchangeGenesis       for ExchangeData.State;\n    using ExchangeMode          for ExchangeData.State;\n    using ExchangeTokens        for ExchangeData.State;\n    using ExchangeWithdrawals   for ExchangeData.State;\n\n    ExchangeData.State private state;\n\n    modifier onlyOperator()\n    {\n        require(msg.sender == state.operator, \"UNAUTHORIZED\");\n        _;\n    }\n\n    modifier onlyWhenUninitialized()\n    {\n        require(owner == address(0) && state.id == 0, \"INITIALIZED\");\n        _;\n    }\n\n    \n    constructor() public {}\n\n    \n    function initialize(\n        address _loopringAddress,\n        address _owner,\n        uint    _id,\n        address payable _operator,\n        bool    _onchainDataAvailability\n        )\n        external\n        nonReentrant\n        onlyWhenUninitialized\n    {\n        require(address(0) != _owner, \"ZERO_ADDRESS\");\n        owner = _owner;\n\n        state.initializeGenesisBlock(\n            _id,\n            _loopringAddress,\n            _operator,\n            _onchainDataAvailability,\n            genesisBlockHash\n        );\n    }\n\n    \n    function getConstants()\n        external\n        pure\n        returns(uint[20] memory)\n    {\n        return [\n            uint(ExchangeData.SNARK_SCALAR_FIELD()),\n            uint(ExchangeData.MAX_PROOF_GENERATION_TIME_IN_SECONDS()),\n            uint(ExchangeData.MAX_GAP_BETWEEN_FINALIZED_AND_VERIFIED_BLOCKS()),\n            uint(ExchangeData.MAX_OPEN_DEPOSIT_REQUESTS()),\n            uint(ExchangeData.MAX_OPEN_WITHDRAWAL_REQUESTS()),\n            uint(ExchangeData.MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE()),\n            uint(ExchangeData.MAX_AGE_REQUEST_UNTIL_FORCED()),\n            uint(ExchangeData.MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE()),\n            uint(ExchangeData.MAX_TIME_IN_SHUTDOWN_BASE()),\n            uint(ExchangeData.MAX_TIME_IN_SHUTDOWN_DELTA()),\n            uint(ExchangeData.TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS()),\n            uint(ExchangeData.MAX_NUM_TOKENS()),\n            uint(ExchangeData.MAX_NUM_ACCOUNTS()),\n            uint(ExchangeData.MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS()),\n            uint(ExchangeData.MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS_SHUTDOWN_MODE()),\n            uint(ExchangeData.FEE_BLOCK_FINE_START_TIME()),\n            uint(ExchangeData.FEE_BLOCK_FINE_MAX_DURATION()),\n            uint(ExchangeData.MIN_GAS_TO_DISTRIBUTE_WITHDRAWALS()),\n            uint(ExchangeData.MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED()),\n            uint(ExchangeData.GAS_LIMIT_SEND_TOKENS())\n        ];\n    }\n\n    \n    function isInWithdrawalMode()\n        external\n        view\n        returns (bool)\n    {\n        return state.isInWithdrawalMode();\n    }\n\n    function isShutdown()\n        external\n        view\n        returns (bool)\n    {\n        return state.isShutdown();\n    }\n\n    function isInMaintenance()\n        external\n        view\n        returns (bool)\n    {\n        return state.isInMaintenance();\n    }\n\n    \n    function getNumAccounts()\n        external\n        view\n        returns (uint)\n    {\n        return state.accounts.length;\n    }\n\n    function getAccount(\n        address owner\n        )\n        external\n        view\n        returns (\n            uint24 accountID,\n            uint   pubKeyX,\n            uint   pubKeyY\n        )\n    {\n        return state.getAccount(owner);\n    }\n\n    function createOrUpdateAccount(\n        uint  pubKeyX,\n        uint  pubKeyY,\n        bytes calldata permission\n        )\n        external\n        payable\n        nonReentrant\n        returns (\n            uint24 accountID,\n            bool   isAccountNew,\n            bool   isAccountUpdated\n        )\n    {\n        return updateAccountAndDepositInternal(\n            pubKeyX,\n            pubKeyY,\n            address(0),\n            0,\n            permission\n        );\n    }\n\n    \n    function isAccountBalanceCorrect(\n        uint     merkleRoot,\n        uint24   accountID,\n        uint16   tokenID,\n        uint     pubKeyX,\n        uint     pubKeyY,\n        uint32   nonce,\n        uint96   balance,\n        uint     tradeHistoryRoot,\n        uint[30] calldata accountPath,\n        uint[12] calldata balancePath\n        )\n        external\n        pure\n        returns (bool)\n    {\n        return ExchangeBalances.isAccountBalanceCorrect(\n            merkleRoot,\n            accountID,\n            tokenID,\n            pubKeyX,\n            pubKeyY,\n            nonce,\n            balance,\n            tradeHistoryRoot,\n            accountPath,\n            balancePath\n        );\n    }\n\n    \n    function getLRCFeeForRegisteringOneMoreToken()\n        external\n        view\n        returns (uint)\n    {\n        return state.getLRCFeeForRegisteringOneMoreToken();\n    }\n\n    function registerToken(\n        address tokenAddress\n        )\n        external\n        nonReentrant\n        onlyOwner\n        returns (uint16)\n    {\n        return state.registerToken(tokenAddress);\n    }\n\n    function getTokenID(\n        address tokenAddress\n        )\n        external\n        view\n        returns (uint16)\n    {\n        return state.getTokenID(tokenAddress);\n    }\n\n    function getTokenAddress(\n        uint16 tokenID\n        )\n        external\n        view\n        returns (address)\n    {\n        return state.getTokenAddress(tokenID);\n    }\n\n    function disableTokenDeposit(\n        address tokenAddress\n        )\n        external\n        nonReentrant\n        onlyOwner\n    {\n        state.disableTokenDeposit(tokenAddress);\n    }\n\n    function enableTokenDeposit(\n        address tokenAddress\n        )\n        external\n        nonReentrant\n        onlyOwner\n    {\n        state.enableTokenDeposit(tokenAddress);\n    }\n\n    \n    function getExchangeStake()\n        external\n        view\n        returns (uint)\n    {\n        return state.loopring.getExchangeStake(state.id);\n    }\n\n    function withdrawExchangeStake(\n        address recipient\n        )\n        external\n        nonReentrant\n        onlyOwner\n        returns (uint)\n    {\n        return state.withdrawExchangeStake(recipient);\n    }\n\n    function withdrawTokenNotOwnedByUsers(\n        address tokenAddress,\n        address payable recipient\n        )\n        external\n        nonReentrant\n        onlyOwner\n        returns(uint)\n    {\n        return state.withdrawTokenNotOwnedByUsers(tokenAddress, recipient);\n    }\n\n    function withdrawProtocolFeeStake(\n        address recipient,\n        uint amount\n        )\n        external\n        nonReentrant\n        onlyOwner\n    {\n        state.loopring.withdrawProtocolFeeStake(state.id, recipient, amount);\n    }\n\n    function burnExchangeStake()\n        external\n        nonReentrant\n    {\n        \n        if(state.isInWithdrawalMode()) {\n            \n            uint stake = state.loopring.getExchangeStake(state.id);\n            state.loopring.burnExchangeStake(state.id, stake);\n        }\n    }\n\n    \n    function getBlockHeight()\n        external\n        view\n        returns (uint)\n    {\n        return state.blocks.length - 1;\n    }\n\n    function getNumBlocksFinalized()\n        external\n        view\n        returns (uint)\n    {\n        return state.numBlocksFinalized - 1;\n    }\n\n    function getBlock(\n        uint blockIdx\n        )\n        external\n        view\n        returns (\n            bytes32 merkleRoot,\n            bytes32 publicDataHash,\n            uint8   blockState,\n            uint8   blockType,\n            uint16  blockSize,\n            uint32  timestamp,\n            uint32  numDepositRequestsCommitted,\n            uint32  numWithdrawalRequestsCommitted,\n            bool    blockFeeWithdrawn,\n            uint16  numWithdrawalsDistributed\n        )\n    {\n        require(blockIdx < state.blocks.length, \"INVALID_BLOCK_IDX\");\n        ExchangeData.Block storage specifiedBlock = state.blocks[blockIdx];\n\n        merkleRoot = specifiedBlock.merkleRoot;\n        publicDataHash = specifiedBlock.publicDataHash;\n        blockState = uint8(specifiedBlock.state);\n        blockType = uint8(specifiedBlock.blockType);\n        blockSize = specifiedBlock.blockSize;\n        timestamp = specifiedBlock.timestamp;\n        numDepositRequestsCommitted = specifiedBlock.numDepositRequestsCommitted;\n        numWithdrawalRequestsCommitted = specifiedBlock.numWithdrawalRequestsCommitted;\n        blockFeeWithdrawn = specifiedBlock.blockFeeWithdrawn;\n        numWithdrawalsDistributed = specifiedBlock.numWithdrawalsDistributed;\n    }\n\n    function commitBlock(\n        uint8  blockType,\n        uint16 blockSize,\n        uint8  blockVersion,\n        bytes  calldata ,\n        bytes  calldata offchainData\n        )\n        external\n        nonReentrant\n        onlyOperator\n    {\n        \n        bytes4 selector = IDecompressor(0x0).decompress.selector;\n        bytes memory decompressed;\n        assembly {\n          \n          \n          \n          \n          \n          \n          \n          let dataOffset := add(calldataload(100), 4)\n          let mode := and(calldataload(add(dataOffset, 1)), 0xFF)\n          switch mode\n          case 0 {\n              \n              let length := sub(calldataload(dataOffset), 1)\n\n              let data := mload(0x40)\n              calldatacopy(add(data, 32), add(dataOffset, 33), length)\n              mstore(data, length)\n              decompressed := data\n              mstore(0x40, add(add(decompressed, length), 32))\n          }\n          case 1 {\n              \n              let contractAddress := and(\n                calldataload(add(dataOffset, 21)),\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n              let length := sub(calldataload(dataOffset), 21)\n\n              let data := mload(0x40)\n              mstore(data, selector)\n              mstore(add(data,  4), 32)\n              mstore(add(data, 36), length)\n              calldatacopy(add(data, 68), add(dataOffset, 53), length)\n\n              let success := call(gas, contractAddress, 0, data, add(68, length), 0x0, 0)\n              if eq(success, 0) {\n                revert(0, 0)\n              }\n\n              returndatacopy(data, 32, sub(returndatasize(), 32))\n              decompressed := data\n              mstore(0x40, add(add(decompressed, mload(decompressed)), 32))\n          }\n          default {\n              revert(0, 0)\n          }\n        }\n        state.commitBlock(blockType, blockSize, blockVersion, decompressed, offchainData);\n    }\n\n    function verifyBlocks(\n        uint[] calldata blockIndices,\n        uint[] calldata proofs\n        )\n        external\n        nonReentrant\n        onlyOperator\n    {\n        state.verifyBlocks(blockIndices, proofs);\n    }\n\n    function revertBlock(\n        uint blockIdx\n        )\n        external\n        nonReentrant\n        onlyOperator\n    {\n        state.revertBlock(blockIdx);\n    }\n\n    \n    function getNumDepositRequestsProcessed()\n        external\n        view\n        returns (uint)\n    {\n        return state.getNumDepositRequestsProcessed();\n    }\n\n    function getNumAvailableDepositSlots()\n        external\n        view\n        returns (uint)\n    {\n        return state.getNumAvailableDepositSlots();\n    }\n\n    function getDepositRequest(\n        uint index\n        )\n        external\n        view\n        returns (\n          bytes32 accumulatedHash,\n          uint    accumulatedFee,\n          uint32  timestamp\n        )\n    {\n        return state.getDepositRequest(index);\n    }\n\n    function updateAccountAndDeposit(\n        uint    pubKeyX,\n        uint    pubKeyY,\n        address token,\n        uint96  amount,\n        bytes   calldata permission\n        )\n        external\n        payable\n        nonReentrant\n        returns (\n            uint24 accountID,\n            bool   isAccountNew,\n            bool   isAccountUpdated\n        )\n    {\n        return updateAccountAndDepositInternal(\n            pubKeyX,\n            pubKeyY,\n            token,\n            amount,\n            permission\n        );\n    }\n\n    function deposit(\n        address token,\n        uint96  amount\n        )\n        external\n        payable\n        nonReentrant\n    {\n        state.depositTo(msg.sender, token, amount, 0);\n    }\n\n    function depositTo(\n        address recipient,\n        address tokenAddress,\n        uint96  amount\n        )\n        external\n        payable\n        nonReentrant\n    {\n        state.depositTo(recipient, tokenAddress, amount, 0);\n    }\n\n    \n    function getNumWithdrawalRequestsProcessed()\n        external\n        view\n        returns (uint)\n    {\n        return state.getNumWithdrawalRequestsProcessed();\n    }\n\n    function getNumAvailableWithdrawalSlots()\n        external\n        view\n        returns (uint)\n    {\n        return state.getNumAvailableWithdrawalSlots();\n    }\n\n    function getWithdrawRequest(\n        uint index\n        )\n        external\n        view\n        returns (\n            bytes32 accumulatedHash,\n            uint    accumulatedFee,\n            uint32  timestamp\n        )\n    {\n        return state.getWithdrawRequest(index);\n    }\n\n    function withdraw(\n        address token,\n        uint96 amount\n        )\n        external\n        payable\n        nonReentrant\n    {\n        uint24 accountID = state.getAccountID(msg.sender);\n        state.withdraw(accountID, token, amount);\n    }\n\n    function withdrawProtocolFees(\n        address token\n        )\n        external\n        payable\n        nonReentrant\n    {\n        \n        state.withdraw(0, token, ~uint96(0));\n    }\n\n    function withdrawFromMerkleTree(\n        address  token,\n        uint     pubKeyX,\n        uint     pubKeyY,\n        uint32   nonce,\n        uint96   balance,\n        uint     tradeHistoryRoot,\n        uint[30] calldata accountPath,\n        uint[12] calldata balancePath\n        )\n        external\n        nonReentrant\n    {\n        state.withdrawFromMerkleTreeFor(\n            msg.sender,\n            token,\n            pubKeyX,\n            pubKeyY,\n            nonce,\n            balance,\n            tradeHistoryRoot,\n            accountPath,\n            balancePath\n        );\n    }\n\n    \n    function withdrawFromMerkleTreeFor(\n        address  owner,\n        address  token,\n        uint     pubKeyX,\n        uint     pubKeyY,\n        uint32   nonce,\n        uint96   balance,\n        uint     tradeHistoryRoot,\n        uint[30] calldata accountPath,\n        uint[12] calldata balancePath\n        )\n        external\n        nonReentrant\n    {\n        state.withdrawFromMerkleTreeFor(\n            owner,\n            token,\n            pubKeyX,\n            pubKeyY,\n            nonce,\n            balance,\n            tradeHistoryRoot,\n            accountPath,\n            balancePath\n        );\n    }\n\n    function withdrawFromDepositRequest(\n        uint depositIdx\n        )\n        external\n        nonReentrant\n    {\n        state.withdrawFromDepositRequest(depositIdx);\n    }\n\n    function withdrawFromApprovedWithdrawal(\n        uint blockIdx,\n        uint slotIdx\n        )\n        external\n        nonReentrant\n    {\n        require(blockIdx < state.blocks.length, \"INVALID_BLOCK_IDX\");\n        ExchangeData.Block storage withdrawBlock = state.blocks[blockIdx];\n        state.withdrawFromApprovedWithdrawal(\n            blockIdx,\n            withdrawBlock,\n            slotIdx,\n            false\n        );\n    }\n\n    function withdrawBlockFee(\n        uint blockIdx,\n        address payable feeRecipient\n        )\n        external\n        nonReentrant\n        onlyOperator\n        returns (uint)\n    {\n        return state.withdrawBlockFee(blockIdx, feeRecipient);\n    }\n\n    function distributeWithdrawals(\n        uint blockIdx,\n        uint maxNumWithdrawals\n        )\n        external\n        nonReentrant\n    {\n        state.distributeWithdrawals(blockIdx, maxNumWithdrawals);\n    }\n\n    \n    function setOperator(\n        address payable _operator\n        )\n        external\n        nonReentrant\n        onlyOwner\n        returns (address payable)\n    {\n        return state.setOperator(_operator);\n    }\n\n    function setAddressWhitelist(\n        address _addressWhitelist\n        )\n        external\n        nonReentrant\n        onlyOwner\n        returns (address)\n    {\n        return state.setAddressWhitelist(_addressWhitelist);\n    }\n\n    function setFees(\n        uint _accountCreationFeeETH,\n        uint _accountUpdateFeeETH,\n        uint _depositFeeETH,\n        uint _withdrawalFeeETH\n        )\n        external\n        nonReentrant\n        onlyOwner\n    {\n        state.setFees(\n            _accountCreationFeeETH,\n            _accountUpdateFeeETH,\n            _depositFeeETH,\n            _withdrawalFeeETH\n        );\n    }\n\n    function getFees()\n        external\n        view\n        returns (\n            uint _accountCreationFeeETH,\n            uint _accountUpdateFeeETH,\n            uint _depositFeeETH,\n            uint _withdrawalFeeETH\n        )\n    {\n        _accountCreationFeeETH = state.accountCreationFeeETH;\n        _accountUpdateFeeETH = state.accountUpdateFeeETH;\n        _depositFeeETH = state.depositFeeETH;\n        _withdrawalFeeETH = state.withdrawalFeeETH;\n    }\n\n    function startOrContinueMaintenanceMode(\n        uint durationMinutes\n        )\n        external\n        nonReentrant\n        onlyOwner\n    {\n        state.startOrContinueMaintenanceMode(durationMinutes);\n    }\n\n    function stopMaintenanceMode()\n        external\n        nonReentrant\n        onlyOwner\n    {\n        state.stopMaintenanceMode();\n    }\n\n    function getRemainingDowntime()\n        external\n        view\n        returns (uint)\n    {\n        return state.getRemainingDowntime();\n    }\n\n    function getDowntimeCostLRC(\n        uint durationMinutes\n        )\n        external\n        view\n        returns (uint costLRC)\n    {\n        return state.getDowntimeCostLRC(durationMinutes);\n    }\n\n    function getTotalTimeInMaintenanceSeconds()\n        external\n        view\n        returns (uint)\n    {\n        return state.getTotalTimeInMaintenanceSeconds();\n    }\n\n    function getExchangeCreationTimestamp()\n        external\n        view\n        returns (uint)\n    {\n        return state.exchangeCreationTimestamp;\n    }\n\n    function shutdown()\n        external\n        nonReentrant\n        onlyOwner\n        returns (bool success)\n    {\n        require(!state.isInWithdrawalMode(), \"INVALID_MODE\");\n        require(!state.isShutdown(), \"ALREADY_SHUTDOWN\");\n        state.shutdownStartTime = now;\n        emit Shutdown(state.shutdownStartTime);\n        return true;\n    }\n\n    function getRequestStats()\n        external\n        view\n        returns(\n            uint numDepositRequestsProcessed,\n            uint numAvailableDepositSlots,\n            uint numWithdrawalRequestsProcessed,\n            uint numAvailableWithdrawalSlots\n        )\n    {\n        numDepositRequestsProcessed = state.getNumDepositRequestsProcessed();\n        numAvailableDepositSlots = state.getNumAvailableDepositSlots();\n        numWithdrawalRequestsProcessed = state.getNumWithdrawalRequestsProcessed();\n        numAvailableWithdrawalSlots = state.getNumAvailableWithdrawalSlots();\n    }\n\n    function getProtocolFeeValues()\n        external\n        view\n        returns (\n            uint32 timestamp,\n            uint8  takerFeeBips,\n            uint8  makerFeeBips,\n            uint8  previousTakerFeeBips,\n            uint8  previousMakerFeeBips\n        )\n    {\n        timestamp = state.protocolFeeData.timestamp;\n        takerFeeBips = state.protocolFeeData.takerFeeBips;\n        makerFeeBips = state.protocolFeeData.makerFeeBips;\n        previousTakerFeeBips = state.protocolFeeData.previousTakerFeeBips;\n        previousMakerFeeBips = state.protocolFeeData.previousMakerFeeBips;\n    }\n\n    \n    function updateAccountAndDepositInternal(\n        uint    pubKeyX,\n        uint    pubKeyY,\n        address token,\n        uint96  amount,\n        bytes   memory permission\n        )\n        internal\n        returns (\n            uint24 accountID,\n            bool   isAccountNew,\n            bool   isAccountUpdated\n        )\n    {\n        (accountID, isAccountNew, isAccountUpdated) = state.createOrUpdateAccount(\n            pubKeyX,\n            pubKeyY,\n            permission\n        );\n        uint additionalFeeETH = 0;\n        if (isAccountNew) {\n            additionalFeeETH = state.accountCreationFeeETH;\n        } else if (isAccountUpdated) {\n            additionalFeeETH = state.accountUpdateFeeETH;\n        }\n        state.depositTo(msg.sender, token, amount, additionalFeeETH);\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getLRCFeeForRegisteringOneMoreToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"}],\"name\":\"getBlock\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"publicDataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"blockState\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numDepositRequestsCommitted\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numWithdrawalRequestsCommitted\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"blockFeeWithdrawn\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"numWithdrawalsDistributed\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"registerToken\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"cloneAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"durationMinutes\",\"type\":\"uint256\"}],\"name\":\"getDowntimeCostLRC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"costLRC\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressWhitelist\",\"type\":\"address\"}],\"name\":\"setAddressWhitelist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"blockIndices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"proofs\",\"type\":\"uint256[]\"}],\"name\":\"verifyBlocks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumBlocksFinalized\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInMaintenance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"disableTokenDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"}],\"name\":\"revertBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"genesisBlockHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawProtocolFees\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"tradeHistoryRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256[30]\",\"name\":\"accountPath\",\"type\":\"uint256[30]\"},{\"internalType\":\"uint256[12]\",\"name\":\"balancePath\",\"type\":\"uint256[12]\"}],\"name\":\"withdrawFromMerkleTree\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"offchainData\",\"type\":\"bytes\"}],\"name\":\"commitBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"tradeHistoryRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256[30]\",\"name\":\"accountPath\",\"type\":\"uint256[30]\"},{\"internalType\":\"uint256[12]\",\"name\":\"balancePath\",\"type\":\"uint256[12]\"}],\"name\":\"withdrawFromMerkleTreeFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProtocolFeeValues\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"takerFeeBips\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"makerFeeBips\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"previousTakerFeeBips\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"previousMakerFeeBips\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalTimeInMaintenanceSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokenID\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getDepositRequest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"accumulatedHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"accumulatedFee\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"permission\",\"type\":\"bytes\"}],\"name\":\"updateAccountAndDeposit\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isAccountNew\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAccountUpdated\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountCreationFeeETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_accountUpdateFeeETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_depositFeeETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawalFeeETH\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"enableTokenDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumDepositRequestsProcessed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExchangeCreationTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRemainingDowntime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInWithdrawalMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"durationMinutes\",\"type\":\"uint256\"}],\"name\":\"startOrContinueMaintenanceMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnExchangeStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getConstants\",\"outputs\":[{\"internalType\":\"uint256[20]\",\"name\":\"\",\"type\":\"uint256[20]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawProtocolFeeStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawTokenNotOwnedByUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"depositTo\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositIdx\",\"type\":\"uint256\"}],\"name\":\"withdrawFromDepositRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumAvailableDepositSlots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"name\":\"withdrawBlockFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isShutdown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRequestStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numDepositRequestsProcessed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numAvailableDepositSlots\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numWithdrawalRequestsProcessed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numAvailableWithdrawalSlots\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loopringAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_onchainDataAvailability\",\"type\":\"bool\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getWithdrawRequest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"accumulatedHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"accumulatedFee\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawExchangeStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopMaintenanceMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_accountCreationFeeETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_accountUpdateFeeETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_depositFeeETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawalFeeETH\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumAvailableWithdrawalSlots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumWithdrawalRequestsProcessed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxNumWithdrawals\",\"type\":\"uint256\"}],\"name\":\"distributeWithdrawals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permission\",\"type\":\"bytes\"}],\"name\":\"createOrUpdateAccount\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isAccountNew\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAccountUpdated\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenID\",\"type\":\"uint16\"}],\"name\":\"getTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotIdx\",\"type\":\"uint256\"}],\"name\":\"withdrawFromApprovedWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExchangeStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"tokenID\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"tradeHistoryRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256[30]\",\"name\":\"accountPath\",\"type\":\"uint256[30]\"},{\"internalType\":\"uint256[12]\",\"name\":\"balancePath\",\"type\":\"uint256[12]\"}],\"name\":\"isAccountBalanceCorrect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getAccount\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"id\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"}],\"name\":\"AccountCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"id\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"}],\"name\":\"AccountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"TokenRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"exchangeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"OperatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"exchangeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddressWhitelist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddressWhitelist\",\"type\":\"address\"}],\"name\":\"AddressWhitelistChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"exchangeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountCreationFeeETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountUpdateFeeETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositFeeETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawalFeeETH\",\"type\":\"uint256\"}],\"name\":\"FeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Shutdown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"publicDataHash\",\"type\":\"bytes32\"}],\"name\":\"BlockCommitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"}],\"name\":\"BlockVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"}],\"name\":\"BlockFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"}],\"name\":\"Revert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"depositIdx\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenID\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"}],\"name\":\"DepositRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BlockFeeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"withdrawalIdx\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenID\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"WithdrawalRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenID\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"WithdrawalCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"accountID\",\"type\":\"uint24\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"tokenID\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"WithdrawalFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"takerFeeBips\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"makerFeeBips\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"previousTakerFeeBips\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"previousMakerFeeBips\",\"type\":\"uint8\"}],\"name\":\"ProtocolFeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"}],\"name\":\"Cloned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ExchangeV3","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"ExchangeBalances:3a9c3e54231689dffaf9e05c265c10d7716fe38d;ExchangeAccounts:c9a437be55ffbcd64aa6f0596d2906fac2591c94;ExchangeAdmins:d06824818cc35445cf1593729b892f80f2f04eff;ExchangeBlocks:571d92144d96bcf1a76ec47ee1464a552673b67d;ExchangeTokens:a3ac9be46eb0f39b772908b5a5b16eae188fc765;ExchangeGenesis:013aa50dc4a1b11c6a1b37c2961895c9dc826069;ExchangeDeposits:7e185c0233d4f5473e540fb2c72ff0e994d4359c;ExchangeWithdrawals:0e77d9716e3f6a6ee4763fcc59ed164cf74a691c;Cloneable:59d0e7ac20094d2c1813c23372b1a8ca4f4cc22a","LicenseType":"","SwarmSource":"bzzr://c0c6aaff593dc716796761704900d319d3b221901f2fe1b7e660d4d4797611c9"}]}