{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.2;\r\npragma experimental \"ABIEncoderV2\";\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/meta-oracles/lib/LinkedListLibraryV2.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title LinkedListLibraryV2\r\n * @author Set Protocol\r\n *\r\n * Library for creating and altering uni-directional circularly linked lists, optimized for sequential updating\r\n * Version two of this contract is a library vs. a contract.\r\n *\r\n *\r\n * CHANGELOG\r\n * - LinkedListLibraryV2 is declared as library vs. contract\r\n */\r\nlibrary LinkedListLibraryV2 {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /* ============ Structs ============ */\r\n\r\n    struct LinkedList{\r\n        uint256 dataSizeLimit;\r\n        uint256 lastUpdatedIndex;\r\n        uint256[] dataArray;\r\n    }\r\n\r\n    /*\r\n     * Initialize LinkedList by setting limit on amount of nodes and inital value of node 0\r\n     *\r\n     * @param  _self                        LinkedList to operate on\r\n     * @param  _dataSizeLimit               Max amount of nodes allowed in LinkedList\r\n     * @param  _initialValue                Initial value of node 0 in LinkedList\r\n     */\r\n    function initialize(\r\n        LinkedList storage _self,\r\n        uint256 _dataSizeLimit,\r\n        uint256 _initialValue\r\n    )\r\n        internal\r\n    {\r\n        require(\r\n            _self.dataArray.length == 0,\r\n            \"LinkedListLibrary: Initialized LinkedList must be empty\"\r\n        );\r\n\r\n        // Initialize Linked list by defining upper limit of data points in the list and setting\r\n        // initial value\r\n        _self.dataSizeLimit = _dataSizeLimit;\r\n        _self.dataArray.push(_initialValue);\r\n        _self.lastUpdatedIndex = 0;\r\n    }\r\n\r\n    /*\r\n     * Add new value to list by either creating new node if node limit not reached or updating\r\n     * existing node value\r\n     *\r\n     * @param  _self                        LinkedList to operate on\r\n     * @param  _addedValue                  Value to add to list\r\n     */\r\n    function editList(\r\n        LinkedList storage _self,\r\n        uint256 _addedValue\r\n    )\r\n        internal\r\n    {\r\n        // Add node if data hasn't reached size limit, otherwise update next node\r\n        _self.dataArray.length < _self.dataSizeLimit ? addNode(_self, _addedValue)\r\n            : updateNode(_self, _addedValue);\r\n    }\r\n\r\n    /*\r\n     * Add new value to list by either creating new node. Node limit must not be reached.\r\n     *\r\n     * @param  _self                        LinkedList to operate on\r\n     * @param  _addedValue                  Value to add to list\r\n     */\r\n    function addNode(\r\n        LinkedList storage _self,\r\n        uint256 _addedValue\r\n    )\r\n        internal\r\n    {\r\n        uint256 newNodeIndex = _self.lastUpdatedIndex.add(1);\r\n\r\n        require(\r\n            newNodeIndex == _self.dataArray.length,\r\n            \"LinkedListLibrary: Node must be added at next expected index in list\"\r\n        );\r\n\r\n        require(\r\n            newNodeIndex < _self.dataSizeLimit,\r\n            \"LinkedListLibrary: Attempting to add node that exceeds data size limit\"\r\n        );\r\n\r\n        // Add node value\r\n        _self.dataArray.push(_addedValue);\r\n\r\n        // Update lastUpdatedIndex value\r\n        _self.lastUpdatedIndex = newNodeIndex;\r\n    }\r\n\r\n    /*\r\n     * Add new value to list by updating existing node. Updates only happen if node limit has been\r\n     * reached.\r\n     *\r\n     * @param  _self                        LinkedList to operate on\r\n     * @param  _addedValue                  Value to add to list\r\n     */\r\n    function updateNode(\r\n        LinkedList storage _self,\r\n        uint256 _addedValue\r\n    )\r\n        internal\r\n    {\r\n        // Determine the next node in list to be updated\r\n        uint256 updateNodeIndex = _self.lastUpdatedIndex.add(1) % _self.dataSizeLimit;\r\n\r\n        // Require that updated node has been previously added\r\n        require(\r\n            updateNodeIndex < _self.dataArray.length,\r\n            \"LinkedListLibrary: Attempting to update non-existent node\"\r\n        );\r\n\r\n        // Update node value and last updated index\r\n        _self.dataArray[updateNodeIndex] = _addedValue;\r\n        _self.lastUpdatedIndex = updateNodeIndex;\r\n    }\r\n\r\n    /*\r\n     * Read list from the lastUpdatedIndex back the passed amount of data points.\r\n     *\r\n     * @param  _self                        LinkedList to operate on\r\n     * @param  _dataPoints                  Number of data points to return\r\n     */\r\n    function readList(\r\n        LinkedList storage _self,\r\n        uint256 _dataPoints\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        LinkedList memory linkedListMemory = _self;\r\n\r\n        return readListMemory(\r\n            linkedListMemory,\r\n            _dataPoints\r\n        );\r\n    }\r\n\r\n    function readListMemory(\r\n        LinkedList memory _self,\r\n        uint256 _dataPoints\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        // Make sure query isn't for more data than collected\r\n        require(\r\n            _dataPoints <= _self.dataArray.length,\r\n            \"LinkedListLibrary: Querying more data than available\"\r\n        );\r\n\r\n        // Instantiate output array in memory\r\n        uint256[] memory outputArray = new uint256[](_dataPoints);\r\n\r\n        // Find head of list\r\n        uint256 linkedListIndex = _self.lastUpdatedIndex;\r\n        for (uint256 i = 0; i < _dataPoints; i++) {\r\n            // Get value at index in linkedList\r\n            outputArray[i] = _self.dataArray[linkedListIndex];\r\n\r\n            // Find next linked index\r\n            linkedListIndex = linkedListIndex == 0 ? _self.dataSizeLimit.sub(1) : linkedListIndex.sub(1);\r\n        }\r\n\r\n        return outputArray;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/meta-oracles/lib/TimeSeriesStateLibrary.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title TimeSeriesStateLibrary\r\n * @author Set Protocol\r\n *\r\n * Library defining TimeSeries state struct\r\n */\r\nlibrary TimeSeriesStateLibrary {\r\n    struct State {\r\n        uint256 nextEarliestUpdate;\r\n        uint256 updateInterval;\r\n        LinkedListLibraryV2.LinkedList timeSeriesData;\r\n    }\r\n}\r\n\r\n// File: contracts/meta-oracles/interfaces/IDataSource.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title IDataSource\r\n * @author Set Protocol\r\n *\r\n * Interface for interacting with DataSource contracts\r\n */\r\ninterface IDataSource {\r\n\r\n    function read(\r\n        TimeSeriesStateLibrary.State calldata _timeSeriesState\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n}\r\n\r\n// File: contracts/meta-oracles/TimeSeriesFeed.sol\r\n\r\n/*\r\n    Copyright 2019 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n*/\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TimeSeriesFeed\r\n * @author Set Protocol\r\n *\r\n * Contract used to store time-series data from a specified DataSource. Intended time-series data\r\n * is stored in a circular Linked List data structure with a maximum number of data points. Its\r\n * enforces a minimum duration between each update. New data is appended by calling the poke function,\r\n * which reads data from a specified data source.\r\n */\r\ncontract TimeSeriesFeed is\r\n    ReentrancyGuard\r\n{\r\n    using SafeMath for uint256;\r\n    using LinkedListLibraryV2 for LinkedListLibraryV2.LinkedList;\r\n\r\n    /* ============ State Variables ============ */\r\n    uint256 public updateInterval;\r\n    uint256 public maxDataPoints;\r\n    // Unix Timestamp in seconds of next earliest update time\r\n    uint256 public nextEarliestUpdate;\r\n    string public dataDescription;\r\n    IDataSource public dataSourceInstance;\r\n\r\n    LinkedListLibraryV2.LinkedList private timeSeriesData;\r\n\r\n    /* ============ Constructor ============ */\r\n\r\n    /*\r\n     * Stores time-series values in a LinkedList and updated using data from a specific data source.\r\n     * Updates must be triggered off chain to be stored in this smart contract.\r\n     *\r\n     * @param  _updateInterval            Cadence at which data is optimally logged. Optimal schedule is based\r\n                                          off deployment timestamp. A certain data point can't be logged before\r\n                                          it's expected timestamp but can be logged after.\r\n     * @param  _maxDataPoints             The maximum amount of data points the linkedList will hold\r\n     * @param  _dataSourceAddress         The address to read current data from\r\n     * @param  _dataDescription           Description of time-series data for Etherscan / other applications\r\n     * @param  _seededValues              Array of previous timeseries values to seed\r\n     *                                    initial values in list. The last value should contain\r\n     *                                    the most current piece of data\r\n     */\r\n    constructor(\r\n        uint256 _updateInterval,\r\n        uint256 _maxDataPoints,\r\n        IDataSource _dataSourceAddress,\r\n        string memory _dataDescription,\r\n        uint256[] memory _seededValues\r\n    )\r\n        public\r\n    {\r\n        // Set updateInterval, maxDataPoints, data description, dataSourceInstance\r\n        updateInterval = _updateInterval;\r\n        maxDataPoints = _maxDataPoints;\r\n        dataDescription = _dataDescription;\r\n        dataSourceInstance = _dataSourceAddress;\r\n\r\n        require(\r\n            _seededValues.length > 0,\r\n            \"TimeSeriesFeed.constructor: Must include at least one seeded value.\"\r\n        );\r\n\r\n        // Define upper data size limit for linked list and input initial value\r\n        timeSeriesData.initialize(_maxDataPoints, _seededValues[0]);\r\n\r\n        // Cycle through input values array (skipping first value used to initialize LinkedList)\r\n        // and add to timeSeriesData\r\n        for (uint256 i = 1; i < _seededValues.length; i++) {\r\n            timeSeriesData.editList(_seededValues[i]);\r\n        }\r\n\r\n        // Set nextEarliestUpdate\r\n        nextEarliestUpdate = block.timestamp.add(updateInterval);\r\n    }\r\n\r\n    /* ============ External ============ */\r\n\r\n    /*\r\n     * Updates linked list with newest data point by querying the dataSource.\r\n     */\r\n    function poke()\r\n        external\r\n        nonReentrant\r\n    {\r\n        // Make sure block timestamp exceeds nextEarliestUpdate\r\n        require(\r\n            block.timestamp >= nextEarliestUpdate,\r\n            \"TimeSeriesFeed.poke: Not enough time elapsed since last update\"\r\n        );\r\n\r\n        TimeSeriesStateLibrary.State memory timeSeriesState = getTimeSeriesFeedState();\r\n\r\n        // Get the most current data point\r\n        uint256 newValue = dataSourceInstance.read(timeSeriesState);\r\n\r\n        // Update the nextEarliestUpdate to previous nextEarliestUpdate plus updateInterval\r\n        nextEarliestUpdate = nextEarliestUpdate.add(updateInterval);\r\n\r\n        // Update linkedList with new price\r\n        timeSeriesData.editList(newValue);\r\n    }\r\n\r\n    /*\r\n     * Query linked list for specified days of data. Will revert if number of days\r\n     * passed exceeds amount of days collected. Will revert if not enough days of\r\n     * data logged.\r\n     *\r\n     * @param  _numDataPoints  Number of datapoints to query\r\n     * @returns                Array of datapoints of length _numDataPoints from most recent to oldest\r\n     */\r\n    function read(\r\n        uint256 _numDataPoints\r\n    )\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return timeSeriesData.readList(_numDataPoints);\r\n    }\r\n\r\n    /* ============ Public ============ */\r\n\r\n    /*\r\n     * Generate struct that holds TimeSeriesFeed's current nextAvailableUpdate, updateInterval,\r\n     * and the LinkedList struct\r\n     *\r\n     * @returns                Struct containing the above params\r\n     */\r\n    function getTimeSeriesFeedState()\r\n        public\r\n        view\r\n        returns (TimeSeriesStateLibrary.State memory)\r\n    {\r\n        return TimeSeriesStateLibrary.State({\r\n            nextEarliestUpdate: nextEarliestUpdate,\r\n            updateInterval: updateInterval,\r\n            timeSeriesData: timeSeriesData\r\n        });\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"poke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dataSourceInstance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeSeriesFeedState\",\"outputs\":[{\"components\":[{\"name\":\"nextEarliestUpdate\",\"type\":\"uint256\"},{\"name\":\"updateInterval\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"dataSizeLimit\",\"type\":\"uint256\"},{\"name\":\"lastUpdatedIndex\",\"type\":\"uint256\"},{\"name\":\"dataArray\",\"type\":\"uint256[]\"}],\"name\":\"timeSeriesData\",\"type\":\"tuple\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dataDescription\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextEarliestUpdate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDataPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_numDataPoints\",\"type\":\"uint256\"}],\"name\":\"read\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"updateInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_updateInterval\",\"type\":\"uint256\"},{\"name\":\"_maxDataPoints\",\"type\":\"uint256\"},{\"name\":\"_dataSourceAddress\",\"type\":\"address\"},{\"name\":\"_dataDescription\",\"type\":\"string\"},{\"name\":\"_seededValues\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"TimeSeriesFeed","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000002a3000000000000000000000000000000000000000000000000000000000000000c80000000000000000000000005c3dab2cee1534541f7c72214d15d87286f90afa00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000103230304461696c79455448507269636500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003600000000000000000000000000000000000000000000000fde573ad6f848400000000000000000000000000000000000000000000000000f84f7c0f5d6c4400000000000000000000000000000000000000000000000000fc29eaf2c45708000000000000000000000000000000000000000000000000010b470b859f09f0000000000000000000000000000000000000000000000000010e4b3482d3f0ac0000000000000000000000000000000000000000000000000109754e736e03d400000000000000000000000000000000000000000000000000fa1cc843407a4000000000000000000000000000000000000000000000000000e7cb3341a0f64000000000000000000000000000000000000000000000000000eee885664a188400000000000000000000000000000000000000000000000000e7328b67e8c4f400000000000000000000000000000000000000000000000000cd4f1176216d6800000000000000000000000000000000000000000000000000c915b602f7eaf800000000000000000000000000000000000000000000000000abc2620518eba800000000000000000000000000000000000000000000000000b83c7e99a84b9000000000000000000000000000000000000000000000000000c3979d0fc8e86400000000000000000000000000000000000000000000000000be2b4795d1c65000000000000000000000000000000000000000000000000000ca557488e5b3f800000000000000000000000000000000000000000000000000c37388018f686000000000000000000000000000000000000000000000000000bb0896a044d5b800000000000000000000000000000000000000000000000000b1f3c807d3f04800000000000000000000000000000000000000000000000000c2a7400f8cd2a000000000000000000000000000000000000000000000000000b916192694c9b000000000000000000000000000000000000000000000000000c1514d3219310000000000000000000000000000000000000000000000000000b35fef3ccd6a8800000000000000000000000000000000000000000000000000b91efae330b9f000000000000000000000000000000000000000000000000000b24db59d7ed0d000000000000000000000000000000000000000000000000000b6e9e062ef240800000000000000000000000000000000000000000000000000bb0acf0f6bd1c800000000000000000000000000000000000000000000000000bc1bec7726ed7800000000000000000000000000000000000000000000000000c1fd62d8667fd800000000000000000000000000000000000000000000000000c140a5f074ce8800000000000000000000000000000000000000000000000000c56078655dfe4000000000000000000000000000000000000000000000000000c92424d575516000000000000000000000000000000000000000000000000000c3a4618ee911c000000000000000000000000000000000000000000000000000c337944872d2b000000000000000000000000000000000000000000000000000bdfedee6c6151000000000000000000000000000000000000000000000000000b7eb72c0995b4800000000000000000000000000000000000000000000000000b751209383ecf000000000000000000000000000000000000000000000000000ba2a8b350a5f7800000000000000000000000000000000000000000000000000b6255df5f5008000000000000000000000000000000000000000000000000000b450da58d33f5000000000000000000000000000000000000000000000000000a2f64ba4e4c54400000000000000000000000000000000000000000000000000a2b3ae9e533b6400000000000000000000000000000000000000000000000000a0b234365c09f000000000000000000000000000000000000000000000000000a0b6a514aa021000000000000000000000000000000000000000000000000000a8a65a5d00ef4000000000000000000000000000000000000000000000000000ae2e71445f601c00000000000000000000000000000000000000000000000000a73e15ea8bae1c00000000000000000000000000000000000000000000000000a08fc97b7fc6f800000000000000000000000000000000000000000000000000a5f192e57dbbc000000000000000000000000000000000000000000000000000a42a61e345e2f000000000000000000000000000000000000000000000000000a2b8ad986af28800000000000000000000000000000000000000000000000000a184093e4015d800000000000000000000000000000000000000000000000000a2f9122fd58058000","Library":"","SwarmSource":"bzzr://d2847820a8eae9902e7e70886d191897a79d06b8abd518d5cac0c54cba01cb57"}]}