{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\r\n\r\n\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor () internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\nlibrary ECDSA {\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaKeyRegistryV1\r\n * @author 0age\r\n * @notice The Dharma Key Registry is an owned contract that holds the public\r\n * user signing keys that will be used by the Dharma Smart Wallet. Each time a\r\n * particular Dharma Smart Wallet instance needs to validate a signature, it\r\n * will first retrieve the public address for the secondary signing key\r\n * associated with that wallet from the Dharma Key Registry. If a specific key\r\n * has not been set for that smart wallet, it will return the global public key.\r\n * Otherwise, it will return the specific signing key. Additional view functions\r\n * are also provided for retrieving public keys directly. Only the owner may\r\n * update these keys.\r\n */\r\ncontract DharmaKeyRegistryV1 is Ownable {\r\n  using ECDSA for bytes32;\r\n\r\n  // The global public key serves as the default signing key.\r\n  address private _globalKey;\r\n\r\n  // Specific keys may also be set on a per-caller basis.\r\n  mapping (address => address) private _specificKeys;\r\n\r\n  /**\r\n   * @notice In the constructor, set the initial global key and the initial\r\n   * owner to tx.origin.\r\n   */\r\n  constructor() public {\r\n    // Initially set the global key to the account of the transaction submitter.\r\n    _globalKey = tx.origin;\r\n\r\n    // Also set the initial owner to the account of the transaction submitter.\r\n    _transferOwnership(tx.origin);\r\n  }\r\n\r\n  /**\r\n   * @notice Set a new global key. This method may only be called by the owner,\r\n   * and a signature must also be provided in order to verify that the provided\r\n   * global public key has a corresponding private key that can be used to sign\r\n   * messages.\r\n   * @param globalKey address The new global public key.\r\n   * @param signature bytes A signature of a message hash containing the address\r\n   * of this contract, the new global key, and a specific message, that must\r\n   * resolve to the supplied global key.\r\n   */\r\n  function setGlobalKey(\r\n    address globalKey,\r\n    bytes calldata signature\r\n  ) external onlyOwner {\r\n    // Ensure that the provided global key is not the null address.\r\n    require(globalKey != address(0), \"A global key must be supplied.\");\r\n\r\n    // Message hash constructed according to EIP-191-0x45 to prevent replays.\r\n    bytes32 messageHash = keccak256(\r\n      abi.encodePacked(\r\n        address(this),\r\n        globalKey,\r\n        \"This signature demonstrates that the supplied signing key is valid.\"\r\n      )\r\n    );\r\n\r\n    // Recover the signer of the message hash using the provided signature.\r\n    address signer = messageHash.toEthSignedMessageHash().recover(signature);\r\n\r\n    // Ensure that the provided signature resolves to the provided global key.\r\n    require(globalKey == signer, \"Invalid signature for supplied global key.\");\r\n\r\n    // Update the global key to the provided global key.\r\n    _globalKey = globalKey;\r\n  }\r\n\r\n  /**\r\n   * @notice Set a new specific key for a particular account. This method may\r\n   * only be called by the owner. Signatures are not required in order to make\r\n   * setting specific keys more efficient at scale. Providing the null address\r\n   * for the specific key will remove a specific key from the given account.\r\n   * @param account address The account to set the new specific public key for.\r\n   * @param specificKey address The new specific public key.\r\n   */\r\n  function setSpecificKey(\r\n    address account,\r\n    address specificKey\r\n  ) external onlyOwner {\r\n    // Update specific key for provided account to the provided specific key.\r\n    _specificKeys[account] = specificKey;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the public key associated with the caller of this function. If\r\n   * a specific key is set for the caller, it will be returned; otherwise, the\r\n   * global key will be returned.\r\n   * @return The public key to use for the caller.\r\n   */\r\n  function getKey() external view returns (address key) {\r\n    // Retrieve the specific key, if any, for the caller.\r\n    key = _specificKeys[msg.sender];\r\n\r\n    // Fall back to the global key in the event that no specific key is set.\r\n    if (key == address(0)) {\r\n      key = _globalKey;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Get the public key associated with a particular account. If a\r\n   * specific key is set for the account, it will be returned; otherwise, the\r\n   * global key will be returned.\r\n   * @param account address The account to find the public key for.\r\n   * @return The public key to use for the provided account.\r\n   */\r\n  function getKeyForUser(address account) external view returns (address key) {\r\n    // Retrieve the specific key, if any, for the specified account.\r\n    key = _specificKeys[account];\r\n\r\n    // Fall back to the global key in the event that no specific key is set.\r\n    if (key == address(0)) {\r\n      key = _globalKey;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Get the global public key.\r\n   * @return The global public key.\r\n   */\r\n  function getGlobalKey() external view returns (address globalKey) {\r\n    // Retrieve and return the global key.\r\n    globalKey = _globalKey;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the specific public key associated with the supplied account.\r\n   * The call will revert if a specific public key is not set for the account.\r\n   * @param account address The account to find the specific public key for.\r\n   * @return The specific public key set on the provided account, if one exists.\r\n   */\r\n  function getSpecificKey(\r\n    address account\r\n  ) external view returns (address specificKey) {\r\n    // Retrieve the specific key, if any, for the account.\r\n    specificKey = _specificKeys[account];\r\n    \r\n    // Revert in the event that there is no specific key set.\r\n    require(\r\n      specificKey != address(0),\r\n      \"No specific key set for the provided account.\"\r\n    );\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getSpecificKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"specificKey\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"globalKey\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"setGlobalKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"key\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGlobalKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"globalKey\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getKeyForUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"key\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"specificKey\",\"type\":\"address\"}],\"name\":\"setSpecificKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DharmaKeyRegistryV1","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://202020202020446861726d614b65795265676973747279563120202020202020"}]}