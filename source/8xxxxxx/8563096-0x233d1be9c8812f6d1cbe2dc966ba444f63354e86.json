{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: openzeppelin-solidity/contracts/introspection/ERC165Checker.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Library used to query support of an interface declared via `IERC165`.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Returns true if `account` supports the `IERC165` interface,\n     */\n    function _supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return _supportsERC165Interface(account, _INTERFACE_ID_ERC165) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for `IERC165` itself is queried automatically.\n     *\n     * See `IERC165.supportsInterface`.\n     */\n    function _supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return _supportsERC165(account) &&\n            _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for `IERC165` itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * `IERC165` support.\n     *\n     * See `IERC165.supportsInterface`.\n     */\n    function _supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!_supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with the `supportsERC165` method in this library.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        // success determines whether the staticcall succeeded and result determines\n        // whether the contract at account indicates support of _interfaceId\n        (bool success, bool result) = _callERC165SupportsInterface(account, interfaceId);\n\n        return (success && result);\n    }\n\n    /**\n     * @notice Calls the function with selector 0x01ffc9a7 (ERC165) and suppresses throw\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return success true if the STATICCALL succeeded, false otherwise\n     * @return result true if the STATICCALL succeeded and the contract at account\n     * indicates support of the interface with identifier interfaceId, false otherwise\n     */\n    function _callERC165SupportsInterface(address account, bytes4 interfaceId)\n        private\n        view\n        returns (bool success, bool result)\n    {\n        bytes memory encodedParams = abi.encodeWithSelector(_INTERFACE_ID_ERC165, interfaceId);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encodedParams_data := add(0x20, encodedParams)\n            let encodedParams_size := mload(encodedParams)\n\n            let output := mload(0x40)    // Find empty storage location using \"free memory pointer\"\n            mstore(output, 0x0)\n\n            success := staticcall(\n                30000,                   // 30k gas\n                account,                 // To addr\n                encodedParams_data,\n                encodedParams_size,\n                output,\n                0x20                     // Outputs are 32 bytes long\n            )\n\n            result := mload(output)      // Load the result\n        }\n    }\n}\n\n// File: @ensdomains/ens/contracts/ENS.sol\n\npragma solidity >=0.4.24;\n\ninterface ENS {\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n    function setResolver(bytes32 node, address resolver) external;\n    function setOwner(bytes32 node, address owner) external;\n    function setTTL(bytes32 node, uint64 ttl) external;\n    function owner(bytes32 node) external view returns (address);\n    function resolver(bytes32 node) external view returns (address);\n    function ttl(bytes32 node) external view returns (uint64);\n\n}\n\n// File: @ensdomains/resolver/contracts/Resolver.sol\n\npragma solidity >=0.4.25;\n\n/**\n * A generic resolver interface which includes all the functions including the ones deprecated\n */\ninterface Resolver{\n    event AddrChanged(bytes32 indexed node, address a);\n    event NameChanged(bytes32 indexed node, string name);\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\n    function addr(bytes32 node) external view returns (address);\n    function contenthash(bytes32 node) external view returns (bytes memory);\n    function dnsrr(bytes32 node) external view returns (bytes memory);\n    function name(bytes32 node) external view returns (string memory);\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n    function text(bytes32 node, string calldata key) external view returns (string memory);\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\n\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\n    function setAddr(bytes32 node, address addr) external;\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n    function setName(bytes32 node, string calldata _name) external;\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n    function setText(bytes32 node, string calldata key, string calldata value) external;\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n    function multihash(bytes32 node) external view returns (bytes memory);\n    function setContent(bytes32 node, bytes32 hash) external;\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}\n\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others (`ERC165Checker`).\n *\n * For an implementation, see `ERC165`.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: contracts/OrganizationInterface.sol\n\npragma solidity ^0.5.6;\n\n\n/**\n * @title Minimal 0xORG interface\n * \n * @dev If you are creating your own implementation of Winding\n * Tree Organization, this is the minimal interface that you must\n * fullfill. Without it, the Organization won't be added into the\n * SegmentDirectory. For checked interface ID, head over to the\n * implementation of `addOrganization` in `SegmentDirectory`.\n *\n * This is not meant to be used by libraries that try to operate\n * with the organization as any data manipulation methods are\n * intentionally omitted. It can be used only for reading data.\n */\ncontract OrganizationInterface is IERC165 {\n    /**\n     * @dev Returns the address of the current owner.\n     * @return {\" \": \"Current owner address.\"}\n     */\n    function owner() public view returns (address);\n\n    /**\n     * @dev Returns the URI of ORG.JSON file stored off-chain.\n     * @return {\" \": \"Current ORG.JSON URI.\"}\n     */\n    function getOrgJsonUri() external view returns (string memory);\n\n    /**\n     * @dev Returns keccak256 hash of raw ORG.JSON contents. This should\n     * be used to verify that the contents of ORG.JSON has not been tampered\n     * with. It is a responsibility of the Organization owner to keep this\n     * hash up to date.\n     * @return {\" \": \"Current ORG.JSON hash.\"}\n     */\n    function getOrgJsonHash() external view returns (bytes32);\n\n    /**\n     * @dev Returns if an `address` is associated with the Organization.\n     * Associated keys can be used on behalf of the organization,\n     * typically to sign messages.\n     *\n     * @param addr Associated Ethereum address\n     * @return {\" \": \"true if associated, false otherwise\"}\n     */\n    function hasAssociatedKey(address addr) external view returns (bool);\n\n    /**\n     * @dev Returns all associatedKeys belonging to this organization.\n     * @return {\" \": \"List of associatedKeys\"}\n     */\n    function getAssociatedKeys() external view returns (address[] memory);\n}\n\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Implementation of the `IERC165` interface.\n *\n * Contracts may inherit from this and call `_registerInterface` to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See `IERC165.supportsInterface`.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See `IERC165.supportsInterface`.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n// File: contracts/Organization.sol\n\npragma solidity ^0.5.6;\n\n\n\n\n/**\n * @title Organization\n * @dev A contract that represents an Organization in the Winding Tree platform,\n * commonly referred to as 0xORG. This is a reference implementation that is\n * created by the OrganizationFactory. You cn implement your own logic if it\n * adheres to the `OrganizationInterface`.\n */\ncontract Organization is OrganizationInterface, ERC165, Initializable {\n    // Address of the contract owner\n    address _owner;\n\n    // Arbitrary locator of the off-chain stored Organization data\n    // This might be an HTTPS resource, IPFS hash, Swarm address...\n    // This is intentionally generic.\n    string public orgJsonUri;\n\n    // Number of a block when the Organization was created\n    uint public created;\n\n    // Index of associated addresses. These can be used\n    // to operate on behalf of this organization, typically sign messages.\n    mapping(address => uint) public associatedKeysIndex;\n\n    // List of associatedKeys. These addresses (i. e. public key\n    // fingerprints) can be used to associate signed content with this\n    // organization.\n    address[] public associatedKeys;\n\n    // keccak256 hash of the ORG.JSON file contents. This should\n    // be used to verify that the contents of ORG.JSON has not been tampered\n    // with. It is a responsibility of the Organization owner to keep this\n    // hash up to date.\n    bytes32 public orgJsonHash;\n\n    /**\n     * @dev Event triggered when owner of the organization is changed.\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Event triggered when orgJsonUri of the organization is changed.\n     */\n    event OrgJsonUriChanged(string previousOrgJsonUri, string newOrgJsonUri);\n\n    /**\n     * @dev Event triggered when orgJsonHash of the organization is changed.\n     */\n    event OrgJsonHashChanged(bytes32 indexed previousOrgJsonHash, bytes32 indexed newOrgJsonHash);\n\n    /**\n     * @dev Event triggered when new associatedKey is added.\n     */\n    event AssociatedKeyAdded(address indexed associatedKey, uint index);\n\n    /**\n     * @dev Event triggered when a associatedKey is removed.\n     */    \n    event AssociatedKeyRemoved(address indexed associatedKey);\n\n    /**\n     * @dev Initializer for upgradeable contracts.\n     * @param __owner The address of the contract owner\n     * @param _orgJsonUri pointer to Organization data\n     * @param  _orgJsonHash keccak256 hash of the new ORG.JSON contents.\n     */\n    function initialize(address payable __owner, string memory _orgJsonUri, bytes32 _orgJsonHash) public initializer {\n        require(__owner != address(0), 'Organization: Cannot set owner to 0x0 address');\n        require(bytes(_orgJsonUri).length != 0, 'Organization: orgJsonUri cannot be an empty string');\n        require(_orgJsonHash != 0, 'Organization: orgJsonHash cannot be empty');\n        emit OwnershipTransferred(_owner, __owner);\n        _owner = __owner;        \n        orgJsonUri = _orgJsonUri;\n        orgJsonHash = _orgJsonHash;\n        created = block.number;\n        associatedKeys.length++;\n        OrganizationInterface i;\n        _registerInterface(0x01ffc9a7);//_INTERFACE_ID_ERC165\n        bytes4 associatedKeysInterface = i.hasAssociatedKey.selector ^ i.getAssociatedKeys.selector; // 0xfed71811\n        bytes4 orgJsonInterface = i.getOrgJsonUri.selector ^ i.getOrgJsonHash.selector; // 0x6f4826be\n        _registerInterface(orgJsonInterface);\n        _registerInterface(associatedKeysInterface);\n        _registerInterface(i.owner.selector); // 0x8da5cb5b\n        _registerInterface(\n            i.owner.selector ^\n            orgJsonInterface ^\n            associatedKeysInterface\n        ); // 0x1c3af5f4\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == _owner, 'Organization: Only owner can call this method');\n        _;\n    }\n\n    /**\n     * @dev `changeOrgJsonUri` Allows owner to change Organization's orgJsonUri.\n     * @param  _orgJsonUri New orgJsonUri pointer of this Organization\n     */\n    function changeOrgJsonUri(string memory _orgJsonUri) public onlyOwner {\n        require(bytes(_orgJsonUri).length != 0, 'Organization: orgJsonUri cannot be an empty string');\n        emit OrgJsonUriChanged(orgJsonUri, _orgJsonUri);\n        orgJsonUri = _orgJsonUri;\n    }\n\n    /**\n     * @dev Returns current orgJsonUri\n     * @return {\" \": \"Current orgJsonUri.\"}\n     */\n    function getOrgJsonUri() external view returns (string memory) {\n        return orgJsonUri;\n    }\n\n    /**\n     * @dev `changeOrgJsonHash` Allows owner to change Organization's orgJsonHash.\n     * @param  _orgJsonHash keccak256 hash of the new ORG.JSON contents.\n     */\n    function changeOrgJsonHash(bytes32 _orgJsonHash) public onlyOwner {\n        require(_orgJsonHash != 0, 'Organization: orgJsonHash cannot be empty');\n        emit OrgJsonHashChanged(orgJsonHash, _orgJsonHash);\n        orgJsonHash = _orgJsonHash;\n    }\n\n    /**\n     * @dev Returns keccak256 hash of raw ORG.JSON contents. This should\n     * be used to verify that the contents of ORG.JSON has not been tampered\n     * with. It is a responsibility of the Organization owner to keep this\n     * hash up to date.\n     * @return {\" \": \"Current ORG.JSON hash.\"}\n     */\n    function getOrgJsonHash() external view returns (bytes32) {\n        return orgJsonHash;\n    }\n\n    /**\n     * @dev Shorthand method to change ORG.JSON uri and hash at the same time\n     * @param  _orgJsonUri New orgJsonUri pointer of this Organization\n     * @param  _orgJsonHash keccak256 hash of the new ORG.JSON contents.\n     */\n    function changeOrgJsonUriAndHash(string memory _orgJsonUri, bytes32 _orgJsonHash) public onlyOwner {\n        changeOrgJsonUri(_orgJsonUri);\n        changeOrgJsonHash(_orgJsonHash);\n    }\n\n    /**\n     * @dev Adds another associated key. Only owner can call this.\n     * @param addr Associated Ethereum address\n     * @return {\" \": \"Address of the added associatedKey\"}\n     */\n    function addAssociatedKey(address addr) public onlyOwner returns(address) {\n        require(addr != address(0), 'Organization: Cannot add associatedKey with 0x0 address');\n        require(associatedKeysIndex[addr] == 0, 'Organization: Cannot add associatedKey twice');\n        associatedKeysIndex[addr] = associatedKeys.length;\n        associatedKeys.push(addr);\n        emit AssociatedKeyAdded(addr, associatedKeysIndex[addr]);\n        return addr;\n    }\n\n    /**\n     * @dev Removes an associated key. Only owner can call this.\n     * @param addr Associated Ethereum address\n     */\n    function removeAssociatedKey(address addr) public onlyOwner {\n        require(addr != address(0), 'Organization: Cannot remove associatedKey with 0x0 address');\n        require(associatedKeysIndex[addr] != uint(0), 'Organization: Cannot remove unknown organization');\n        delete associatedKeys[associatedKeysIndex[addr]];\n        delete associatedKeysIndex[addr];\n        emit AssociatedKeyRemoved(addr);\n    }\n\n    /**\n     * @dev Is an address considered as associated for this organization?\n     * @return {\" \": \"True if address is considered as associatedKey, false otherwise\"}\n     */\n    function hasAssociatedKey(address addr) external view returns(bool) {\n        return associatedKeys[associatedKeysIndex[addr]] != address(0);\n    }\n\n    /**\n     * @dev Returns all addresses associated with this organization.\n     * @return {\" \": \"List of associated keys\"}\n     */\n    function getAssociatedKeys() external view returns (address[] memory) {\n        return associatedKeys;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        require(newOwner != address(0), 'Organization: Cannot transfer to 0x0 address');\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n\n    /**\n     * @dev A synchronization method that should be kept up to date with \n     * the list of interfaces set during initialization. It should also be called\n     * everytime the implementation gets updated. If the interface list gets out of\n     * sync with the implementation at anytime, it is possible that some integrations\n     * will stop working. Since this method is not destructive, no access restriction\n     * is in place. It's supposed to be called by the proxy admin anyway.\n     */\n    function setInterfaces() public {\n        // OrganizationInterface i;\n        bytes4[5] memory interfaceIds = [\n            bytes4(0x01ffc9a7), // _INTERFACE_ID_ERC165\n            bytes4(0x8da5cb5b), // i.owner.selector\n            bytes4(0xfed71811), // i.hasAssociatedKey.selector ^ i.getAssociatedKeys.selector\n            bytes4(0x6f4826be), // i.getOrgJsonUri.selector ^ i.getOrgJsonHash.selector\n            bytes4(0x1c3af5f4)  // 0x8da5cb5b ^ 0xfed71811 ^ 0x6f4826be\n        ];\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!this.supportsInterface(interfaceIds[i])) {\n                _registerInterface(interfaceIds[i]);\n            }\n        }\n    }\n}\n\n// File: contracts/AbstractSegmentDirectory.sol\n\npragma solidity ^0.5.6;\n\n/**\n * @title AbstractSegmentDirectory\n * \n * @dev Usable in libraries. Segment Directory is essentially a list\n * of 0xORG smart contracts that share a common segment - hotels, airlines, otas.\n */\ncontract AbstractSegmentDirectory {\n\n    /**\n     * @dev Event triggered every time organization is added.\n     */\n    event OrganizationAdded(address indexed organization, uint index);\n\n    /**\n     * @dev Event triggered every time organization is removed.\n     */\n    event OrganizationRemoved(address indexed organization);\n\n    /**\n     * @dev Event triggered when owner of the directory is changed.\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address);\n\n    /**\n     * @dev Returns the segment name\n     */\n    function getSegment() public view returns (string memory);\n\n    /**\n     * @dev Returns the address of the associated lif token\n     */\n    function getLifToken() public view returns (address);\n\n    /**\n     * @dev Adds an organization to the list\n     */\n    function add(address organization) external returns (address);\n\n    /**\n     * @dev Removes an organization from the list\n     */\n    function remove(address organization) external;\n\n    /**\n     * @dev Returns the number of added organizations. Might contain zero\n     * addresses (these remain after removing an organization).\n     */\n    function getOrganizationsLength() public view returns (uint);\n\n    /**\n     * @dev Returns a list of added organizations. Might contain zero addresses.\n     */\n    function getOrganizations() public view returns (address[] memory);\n\n    /**\n     * @dev Returns index of `organization`\n     */\n    function organizationsIndex(address organization) public view returns (uint);\n\n    /**\n     * @dev Returns organization address on `index` position.\n     */\n    function organizations(uint index) public view returns (address);\n}\n\n// File: contracts/SegmentDirectory.sol\n\npragma solidity ^0.5.6;\n\n\n\n\n\n\n\n\n/**\n * A SegmentDirectory that can handle a list of organizations sharing a \n * common segment such as hotels, airlines etc.\n */\ncontract SegmentDirectory is Initializable, AbstractSegmentDirectory {\n    // Address of the contract owner\n    address _owner;\n\n    // Segment name, i. e. hotel, airline\n    string _segment;\n\n    // Array of addresses of `Organization` contracts\n    address[] _organizations;\n\n    // Mapping of organizations position in the general organization index\n    mapping(address => uint) _organizationsIndex;\n\n    // Address of the LifToken contract\n    address _lifToken;\n\n    // hashed 'token.windingtree.eth' using eth-ens-namehash\n    bytes32 private constant tokenNamehash = 0x30151473c3396a0cfca504fc0f1ebc0fe92c65542ad3aaf70126c087458deb85;\n\n    /**\n     * @dev `addOrganization` Add new organization in the directory.\n     * Only organizations that conform to OrganizationInterface can be added.\n     * ERC165 method of interface checking is used.\n     * \n     * Emits `OrganizationAdded` on success.\n     * @param  organization Organization's address\n     * @return {\" \": \"Address of the organization.\"}\n     */\n    function addOrganization(address organization) internal returns (address) {\n        require(_organizationsIndex[organization] == 0, 'SegmentDirectory: Cannot add organization twice');\n        // This is intentionally not part of the state variables as we expect it to change in time.\n        // It should always be the latest xor of *all* methods in the OrganizationInterface.\n        bytes4 _INTERFACE_ID_ORGANIZATION = 0x1c3af5f4;\n        require(\n            ERC165Checker._supportsInterface(organization, _INTERFACE_ID_ORGANIZATION),\n            'SegmentDirectory: Organization has to support _INTERFACE_ID_ORGANIZATION'\n        );\n        OrganizationInterface org = OrganizationInterface(organization);\n        require(org.owner() == msg.sender, 'SegmentDirectory: Only organization owner can add the organization');\n        _organizationsIndex[organization] = _organizations.length;\n        _organizations.push(organization);\n        emit OrganizationAdded(\n            organization,\n            _organizationsIndex[organization]\n        );\n        return organization;\n    }\n\n    /**\n     * @dev `removeOrganization` Allows a owner to remove an organization\n     * from the directory. Does not destroy the organization contract.\n     * Emits `OrganizationRemoved` on success.\n     * @param  organization  Organization's address\n     */\n    function removeOrganization(address organization) internal {\n        // Ensure organization address is valid\n        require(organization != address(0), 'SegmentDirectory: Cannot remove organization on 0x0 address');\n        // Ensure we know about the organization at all\n        require(_organizationsIndex[organization] != uint(0), 'SegmentDirectory: Cannot remove unknown organization');\n        // Ensure that the caller is the organization's rightful owner\n        // Organization might have changed hands without the index taking notice\n        OrganizationInterface org = OrganizationInterface(organization);\n        require(org.owner() == msg.sender, 'SegmentDirectory: Only organization owner can remove the organization');\n        uint allIndex = _organizationsIndex[organization];\n        delete _organizations[allIndex];\n        delete _organizationsIndex[organization];\n        emit OrganizationRemoved(organization);\n    }\n\n    /**\n     * @dev `add` proxies and externalizes addOrganization\n     * @param  organization Organization's address\n     * @return {\" \": \"Address of the organization.\"}\n     */\n    function add(address organization) external returns (address) {\n        return addOrganization(organization);\n    }\n\n    /**\n     * @dev `remove` proxies and externalizes removeOrganization\n     * @param  organization  Organization's address\n     */\n    function remove(address organization) external {\n        removeOrganization(organization);\n    }\n\n    /**\n     * @dev Initializer for upgradeable contracts.\n     * @param __owner The address of the contract owner\n     * @param __segment The segment name\n     * @param __lifToken The Lif Token contract address\n     */\n    function initialize(\n        address payable __owner,\n        string memory __segment,\n        address __lifToken)\n    public initializer {\n        require(__owner != address(0), 'SegmentDirectory: Cannot set owner to 0x0 address');\n        require(bytes(__segment).length != 0, 'SegmentDirectory: Segment cannot be empty');\n        _owner = __owner;\n        _lifToken = __lifToken;\n        _organizations.length++;\n        _segment = __segment;\n    }\n\n    function resolveLifTokenFromENS(address _ENS) public onlyOwner {\n        ENS registry = ENS(_ENS);\n        address resolverAddress = registry.resolver(tokenNamehash);\n        require(resolverAddress != address(0), 'SegmentDirectory: Resolver not found');\n        Resolver resolver = Resolver(resolverAddress);\n        address tokenAddress = resolver.addr(tokenNamehash);\n        require(tokenAddress != address(0), 'SegmentDirectory: Token not found');\n        _lifToken = tokenAddress;\n    }\n\n    /**\n     * @dev `getOrganizationsLength` get the length of the `organizations` array\n     * @return {\" \": \"Length of the organizations array. Might contain zero addresses.\"}\n     */\n    function getOrganizationsLength() public view returns (uint) {\n        return _organizations.length;\n    }\n\n    /**\n     * @dev `getOrganizations` get `organizations` array\n     * @return {\" \": \"Array of organization addresses. Might contain zero addresses.\"}\n     */\n    function getOrganizations() public view returns (address[] memory) {\n        return _organizations;\n    }\n\n    /**\n     * @dev `organizationsIndex` get index of Organization\n     * @return {\" \": \"Organization index.\"}\n     */\n    function organizationsIndex(address organization) public view returns (uint) {\n        return _organizationsIndex[organization];\n    }\n\n    /**\n     * @dev `organizations` get Organization address on an index\n     * @return {\" \": \"Organization address.\"}\n     */\n    function organizations(uint index) public view returns (address) {\n        return _organizations[index];\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == _owner, 'SegmentDirectory: Only owner can call this method');\n        _;\n    }\n\n    /**\n     * @dev `getLifToken` Returns address of set Lif token\n     * @return {\" \": \"LifToken address.\"}\n     */\n    function getLifToken() public view returns (address) {\n        return _lifToken;\n    }\n\n    /**\n     * @dev `setSegment` allows the owner of the contract to change the\n     * segment name.\n     * @param __segment The new segment name\n     */\n    function setSegment(string memory __segment) public onlyOwner {\n        require(bytes(__segment).length != 0, 'SegmentDirectory: Segment cannot be empty');\n        _segment = __segment;\n    }\n\n    /**\n     * @dev `getSegment` Returns segment name\n     * @return {\" \": \"Segment name.\"}\n     */\n    function getSegment() public view returns (string memory) {\n        return _segment;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address payable newOwner) internal {\n        require(newOwner != address(0), 'SegmentDirectory: Cannot transfer to 0x0 address');\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n}\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"organization\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSegment\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"organization\",\"type\":\"address\"}],\"name\":\"remove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ENS\",\"type\":\"address\"}],\"name\":\"resolveLifTokenFromENS\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"organization\",\"type\":\"address\"}],\"name\":\"organizationsIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"__owner\",\"type\":\"address\"},{\"name\":\"__segment\",\"type\":\"string\"},{\"name\":\"__lifToken\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLifToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOrganizations\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"__segment\",\"type\":\"string\"}],\"name\":\"setSegment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOrganizationsLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"organizations\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"organization\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"OrganizationAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"organization\",\"type\":\"address\"}],\"name\":\"OrganizationRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SegmentDirectory","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://a09ec6de0e46fdc47668b0334a5d20073af1470779bce2310e663177a69b4f9c"}]}