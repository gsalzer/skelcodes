{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >= 0.4.5<0.60;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Multiplies two unsigned integers, reverts on overflow.\r\n  * @notice source:\r\n  * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero,\r\n    // but the benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two unsigned integers truncating the quotient,\r\n   * reverts on division by zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two unsigned integers, reverts on overflow\r\n   * (i.e. if subtrahend is greater than minuend).\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint256 c = a - b;\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two unsigned integers, reverts on overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two unsigned integers and returns the remainder\r\n   *(unsigned integer modulo), reverts when dividing by zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/*\r\nERC-20 token\r\nEIP-1132 locking functions\r\nBurn function\r\n*/\r\ncontract InBitToken {\r\n\r\n  using SafeMath for uint;\r\n\r\n  string public name = 'InBit Token';\r\n  string public symbol = 'InBit';\r\n  string public standard = 'InBit Token v1.0';\r\n  uint256 public totalSupply;\r\n  uint8 public decimals;\r\n\r\n  // @dev Records data of all the tokens transferred\r\n  // @param _from Address that sends tokens\r\n  // @param _to Address that receives tokens\r\n  // @param _value the amount that _spender can spend on behalf of _owner\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 _value\r\n  );\r\n\r\n  // @dev Records data of an Approval to spend the tokens on behalf of\r\n  // @param _owner address that approves to pay on its behalf\r\n  // @param _spender address to whom the approval is issued\r\n  // @param _value the amount that _spender can spend on behalf of _owner\r\n\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _spender,\r\n    uint256 _value\r\n  );\r\n\r\n  //@dev Records the burn of tokens from a specific address\r\n  // @param _from address that burns the tokens from its balance\r\n  // @param _value the number of tokens that are being burned\r\n  event Burn(\r\n    address indexed _from,\r\n    uint256 _value\r\n  );\r\n\r\n  //@dev Records data of all the tokens locked\r\n  //@param _of address that has tokens locked\r\n  //@param _reason the reason explaining why these tokens are locked\r\n  //@param _amount the number of tokens being locked\r\n  //@param _validity time in seconds tokens will be locked for\r\n  event Locked(\r\n    address indexed _of,\r\n    bytes32 indexed _reason,\r\n    uint256 _amount,\r\n    uint256 _validity\r\n  );\r\n\r\n  //@dev Records data of all the tokens unlocked\r\n  //@param _of address for whom the tokens are unlocked\r\n  //@param _reason the reason explaining why these tokens were locked\r\n  //@param _amount the number of tokens being unlocked\r\n  event Unlocked(\r\n    address indexed _of,\r\n    bytes32 indexed _reason,\r\n    uint256 _amount\r\n  );\r\n\r\n  //@dev mapping array for keeping the balances of all the accounts\r\n  mapping(address => uint256) public balanceOf;\r\n\r\n  //@dev amping array that keeps the allowance that is still allowed to withdraw from _owner\r\n  mapping(address => mapping(address => uint256)) public allowance;\r\n  //@notice account A approved account B to send C tokens (amount C is actually left )\r\n\r\n  //@dev reasons why tokens have been locked\r\n  mapping(address => bytes32[]) public lockReason;\r\n\r\n  //@dev holds number & validity of tokens locked for a given reason for a specified address\r\n  //@notice tokens locked for A account with B reason and C data: structure {ammount, valididty, claimed}\r\n  mapping(address => mapping(bytes32 => lockToken)) public locked;\r\n\r\n  // @dev locked token structure\r\n  // @param amount - the amount of tokens lockedToken\r\n  // @param validity - timestamp until when the tokes are locked\r\n  // @param claimed - where the locked tokens already claimed\r\n  // (unlocked and transferred to the address)\r\n  struct lockToken {\r\n    uint256 amount;\r\n    uint256 validity;\r\n    bool claimed;\r\n  }\r\n\r\n  constructor(uint256 _intialSupply, uint8 _intialDecimals)\r\n    public\r\n  {\r\n    balanceOf[msg.sender] = _intialSupply;\r\n    totalSupply = _intialSupply;\r\n    decimals = _intialDecimals;\r\n  }\r\n\r\n\r\n  // @dev Transfers tokens from sender account to\r\n  // @param _from Address that sends tokens\r\n  // @param _to Address that receives tokens\r\n  // @param _value the amount that _spender can spend on behalf of _owner\r\n  function transfer(address _to, uint256 _value)\r\n    public\r\n    returns(bool success)\r\n  {\r\n    require(balanceOf[msg.sender] >= _value);\r\n    balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\r\n    balanceOf[_to] = balanceOf[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  // @dev Allows _spender to withdraw from [msg.sender] account multiple times,\r\n  // up to the _value amount.\r\n  // @param _spender address to whom the approval is issued\r\n  // @param _value the amount that _spender can spend on behalf of _owner\r\n  // @notice If this function is called again it overwrites the current allowance\r\n  // with _value.\r\n  function approve(address _spender, uint256 _value)\r\n    public\r\n    returns(bool success)\r\n  {\r\n    allowance[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  // @dev Transfers tokens on behalf of _form account to _to account. [msg.sender]\r\n  // should have an allowance from _from account to transfer the number of tokens.\r\n  // @param _from address tokens are transferred from\r\n  // @param _to address tokens are transferred to\r\n  // @parram _value the number of tokens transferred\r\n  // @notice _from account should have enough tokens and allowance should be equal\r\n  // or greater than the amount transferred\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public\r\n    returns(bool success)\r\n  {\r\n    require(balanceOf[_from] >= _value);\r\n    require(allowance[_from][msg.sender] >= _value);\r\n    balanceOf[_from] = balanceOf[_from].sub(_value);\r\n    balanceOf[_to] = balanceOf[_to].add(_value);\r\n    allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  // @notice Functions used for locking the tokens go next\r\n  // @dev Locks a specified amount of tokens against an [msg.sender] address,\r\n  // for a specified reason and time\r\n  // @param _reason The reason to lock tokens\r\n  // @param _amount Number of tokens to be locked\r\n  // @param _time Lock time in seconds\r\n  function lock(bytes32 _reason, uint256 _amount, uint256 _time)\r\n  public\r\n  returns (bool)\r\n  {\r\n    uint256 validUntil = now.add(_time);\r\n    require(tokensLocked(msg.sender, _reason) == 0, 'Tokens already locked');\r\n    // If tokens are already locked, then functions extendLock or\r\n    // increaseLockAmount should be used to make any changes\r\n    require(_amount != 0, 'Amount can not be 0');\r\n    if (locked[msg.sender][_reason].amount == 0)\r\n      lockReason[msg.sender].push(_reason);\r\n    transfer(address(this), _amount);\r\n    locked[msg.sender][_reason] = lockToken(_amount, validUntil, false);\r\n    emit Locked(msg.sender, _reason, _amount, validUntil);\r\n    return true;\r\n  }\r\n\r\n  // @dev Transfers from [msg.sender] account and locks against specified address\r\n  // a specified amount of tokens, for a specified reason and time\r\n  // @param _to Address against which tokens have to be locked (to which address\r\n  // should be transferred after unlocking and claiming)\r\n  // @param _reason The reason to lock tokens\r\n  // @param _amount Number of tokens to be transferred and locked\r\n  // @param _time Lock time in seconds\r\n  function transferWithLock(\r\n    address _to,\r\n    bytes32 _reason,\r\n    uint256 _amount,\r\n    uint256 _time\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 validUntil = now.add(_time);\r\n    require(tokensLocked(_to, _reason) == 0, 'Tokens already locked');\r\n    require(_amount != 0, 'Amount can not be 0');\r\n    if (locked[_to][_reason].amount == 0)\r\n      lockReason[_to].push(_reason);\r\n    transfer(address(this), _amount);\r\n    locked[_to][_reason] = lockToken(_amount, validUntil, false);\r\n    emit Locked(_to, _reason, _amount, validUntil);\r\n    return true;\r\n  }\r\n\r\n  // @notice Functions used for increasing the number or time of locked tokens go next\r\n  // @dev Extends the time of lock for tokens already locked for a specific reason\r\n  // @param _reason The reason tokens are locked for.\r\n  // @param _time Desirable lock extension time in seconds\r\n  function extendLock(bytes32 _reason, uint256 _time)\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(tokensLocked(msg.sender, _reason) > 0, 'There are no tokens locked for specified reason');\r\n    locked[msg.sender][_reason].validity = locked[msg.sender][_reason].validity.add(_time);\r\n    emit Locked(msg.sender, _reason, locked[msg.sender][_reason].amount, locked[msg.sender][_reason].validity);\r\n    return true;\r\n  }\r\n\r\n  // @dev Increase number of tokens already locked for a specified reason\r\n  // @param _reason The reason tokens are locked for.\r\n  // @param _amount Number of tokens to be increased\r\n  function increaseLockAmount(bytes32 _reason, uint256 _amount) public returns (bool)\r\n  {\r\n    require(tokensLocked(msg.sender, _reason) > 0, 'There are no tokens locked for specified reason');\r\n    transfer(address(this), _amount);\r\n    locked[msg.sender][_reason].amount = locked[msg.sender][_reason].amount.add(_amount);\r\n    emit Locked(msg.sender, _reason, locked[msg.sender][_reason].amount, locked[msg.sender][_reason].validity);\r\n    return true;\r\n  }\r\n\r\n  // @notice Function used for unlocking tokens goes next\r\n  // @dev Unlocks the unlockable tokens of a specified address\r\n  // @param _of Address of user, claiming back unlockable tokens\r\n  function unlock(address _of) public returns (uint256 unlockableTokens) {\r\n    uint256 lockedTokens;\r\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\r\n      lockedTokens = tokensUnlockable(_of, lockReason[_of][i]);\r\n      if (lockedTokens > 0) {\r\n        unlockableTokens = unlockableTokens.add(lockedTokens);\r\n        locked[_of][lockReason[_of][i]].claimed = true;\r\n        emit Unlocked(_of, lockReason[_of][i], lockedTokens);\r\n      }\r\n    }\r\n    if (unlockableTokens > 0)\r\n      this.transfer(_of, unlockableTokens);\r\n  }\r\n\r\n  // @dev Burns the tokens form the [msg.sender] account and reduces the TotalSupply\r\n  // @parram _value the number of tokens to be burned\r\n  function burn(uint256 _value) public returns (bool success)\r\n  {\r\n    require(balanceOf[msg.sender] >= _value);\r\n    require(_value >= 0);\r\n    balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\r\n    totalSupply = totalSupply.sub(_value);\r\n    emit Burn(msg.sender, _value);\r\n    return true;\r\n  }\r\n\r\n  //@notice The end of standard ERC-20 functions\r\n  //@noitce Further goes additional function from ERC1132 and burn function\r\n  //@dev Returns tokens locked for a specified address for a specified reason\r\n  //@param _of the address being checked\r\n  //@param _reason the reason balance of locked tokens is checked for (how many tokens are locked for a specified reason)\r\n  //@noitce this function shows the number of unclaimed tokens for the _of address at the moment. It shows as locked as well as unlockable but not yet claimed tokens\r\n  function tokensLocked(address _of, bytes32 _reason)\r\n    public\r\n    view\r\n    returns (uint256 amount)\r\n  {\r\n    if (!locked[_of][_reason].claimed)\r\n    amount = locked[_of][_reason].amount;\r\n  }\r\n\r\n  // @dev Returns tokens locked for a specified address for a specified reason at a specific time\r\n  // @param _of the address being checked\r\n  // @param _reason the reason balance of locked tokens is checked for (how many tokens will be locked for a specified reason)\r\n  // @param _time the future timestamp balance of locked tokens is checked for (how many tokens will be locked for a specified reason at a specified timestamp)\r\n  // @noitce this function shows the number of unclaimed tokens for the _of address at the moment in future defined in a _time parameter. It shows only locked tokens.\r\n  // The difference with tokensLocked is because of tokensLocked shows the amount at the current moment and calculates both locked and unlockable but not yet claimed tokes at the moment.\r\n  // In the future, we cannot predict the behavior of the user and can show only locked ones.\r\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n    public\r\n    view\r\n    returns (uint256 amount)\r\n  {\r\n    if (locked[_of][_reason].validity > _time)\r\n    amount = locked[_of][_reason].amount;\r\n  }\r\n\r\n  // @dev Returns total number of tokens held by an address (locked + unlockable but not yet claimed + transferable)\r\n  // @param _of The address to query the total balance of\r\n  function totalBalanceOf(address _of)\r\n    public\r\n    view\r\n    returns (uint256 amount)\r\n  {\r\n    amount = balanceOf[_of];\r\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\r\n      amount = amount.add(tokensLocked(_of, lockReason[_of][i]));\r\n    }\r\n  }\r\n\r\n  // @dev Returns the amount of unlockable tokens for a specified address for a specified reason\r\n  // @param _of The address being checked\r\n  // @param _reason The reason number of unlockable tokens is checked for\r\n  // @notice How many tokens are unlockable for a specified reason for a specified address\r\n  function tokensUnlockable(address _of, bytes32 _reason)\r\n    public\r\n    view\r\n    returns (uint256 amount)\r\n  {\r\n    if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed){\r\n      amount = locked[_of][_reason].amount;\r\n    }\r\n  }\r\n\r\n  // @dev Returns the total amount of all unlockable tokens for a specified address.\r\n  // @param _of The address to query the unlockable token count of\r\n  function getUnlockableTokens(address _of)\r\n    public\r\n    view\r\n    returns (uint256 unlockableTokens)\r\n  {\r\n    for (uint256 i = 0; i < lockReason[_of].length; i++) {\r\n      unlockableTokens = unlockableTokens.add(tokensUnlockable(_of, lockReason[_of][i]));\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"tokensLockedAtTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"unlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unlockableTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"totalBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"transferWithLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"}],\"name\":\"tokensUnlockable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"}],\"name\":\"tokensLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockReason\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increaseLockAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"extendLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"getUnlockableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unlockableTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validity\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_intialSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_intialDecimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_validity\",\"type\":\"uint256\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_reason\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Unlocked\",\"type\":\"event\"}]","ContractName":"InBitToken","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000041fc8834c2407a15dec00000000000000000000000000000000000000000000000000000000000000000012","Library":"","LicenseType":"None","SwarmSource":"bzzr://e4972ffb7a6f61359d7e28fda71cf3b889a9afd8ea28e39fbab01811f36c7679"}]}