{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity 0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface LoopringProtocol {\r\n  function submitRings(bytes calldata data) external;\r\n  function lrcTokenAddress() external returns (address);\r\n  function delegateAddress() external returns (address);\r\n}\r\n\r\ninterface ERC20 {\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external;\r\n  function transferFrom(address from, address to, uint256 value) external;\r\n  function approve(address spender, uint256 value) external;\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) return 0;\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0);\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n    return c;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\nlibrary Types {\r\n\r\n  struct RelayerInfo {\r\n    uint marginOrderIndex;\r\n    uint marketIdS;\r\n    uint marketIdB;\r\n    uint fillAmountS;\r\n    uint fillAmountB;\r\n  }\r\n\r\n  enum MarginOrderType { OPEN_LONG, OPEN_SHORT, CLOSE_LONG, CLOSE_SHORT }\r\n  \r\n  struct MarginOrderDetails {\r\n    uint positionId;\r\n    MarginOrderType positionType;\r\n    uint depositAmount;\r\n    uint depositMarketId;\r\n    uint expiration;\r\n\r\n    // calculated\r\n    address owner;\r\n    address depositToken;\r\n    uint withdrawalMarketId;\r\n    bool isOpen;\r\n    bool isLong;\r\n  }\r\n\r\n  enum OrderDataSide { BUY, SELL }\r\n\r\n  struct OrderData {\r\n    OrderDataSide side;\r\n    uint fillAmountS;\r\n    uint fillAmountB;\r\n    bytes ringData;\r\n    uint marginOrderIndex;\r\n    address trader;\r\n\r\n    // Helper (not encoded/decoded)\r\n    bool bringToZero; // should bring the account balance to zero\r\n  }\r\n\r\n  struct MarginLimitOrderDetails {\r\n    uint positionId;\r\n    uint marketIdS;\r\n    uint marketIdB;\r\n    uint depositMarketId;\r\n    uint depositAmount;\r\n    address broker;\r\n    uint expiration;\r\n\r\n    // calculated\r\n    address depositToken;\r\n    address trader;\r\n  }\r\n}\r\n\r\nlibrary DydxTypes {\r\n  enum AssetDenomination { Wei, Par }\r\n  enum AssetReference { Delta, Target }\r\n\r\n  struct AssetAmount {\r\n    bool sign;\r\n    AssetDenomination denomination;\r\n    AssetReference ref;\r\n    uint256 value;\r\n  }\r\n}\r\n\r\nlibrary DydxPosition {\r\n  struct Info {\r\n    address owner;\r\n    uint256 number;\r\n  }\r\n}\r\n\r\nlibrary DydxActions {\r\n  enum ActionType { Deposit, Withdraw, Transfer, Buy, Sell,\r\n    Trade, Liquidate, Vaporize, Call }\r\n\r\n  struct ActionArgs {\r\n    ActionType actionType;\r\n    uint256 accountId;\r\n    DydxTypes.AssetAmount amount;\r\n    uint256 primaryMarketId;\r\n    uint256 secondaryMarketId;\r\n    address otherAddress;\r\n    uint256 otherAccountId;\r\n    bytes data;\r\n  }\r\n}\r\n\r\ninterface IDolomiteMarginTradingBroker {\r\n  function brokerMarginRequestApproval(address owner, address token, uint amount) external;\r\n  function brokerMarginGetTrader(address owner, bytes calldata orderData) external view returns (address);\r\n}\r\n\r\n// Abstract contract for the DyDx Solo Margin contract. Only contains\r\n// function/struct used by Dolomite's liquidator integration\r\ncontract DydxProtocol {\r\n  struct OperatorArg {\r\n    address operator;\r\n    bool trusted;\r\n  }\r\n\r\n  function operate(\r\n      DydxPosition.Info[] calldata accounts,\r\n      DydxActions.ActionArgs[] calldata actions\r\n  ) external;\r\n\r\n  function getMarketTokenAddress(uint256 marketId) external view returns (address);\r\n}\r\n\r\n// Interface for exchanging tokens through Dydx\r\ninterface IDydxExchangeWrapper {\r\n  function exchange(\r\n    address tradeOriginator,\r\n    address receiver,\r\n    address makerToken,\r\n    address takerToken,\r\n    uint256 requestedFillAmount,\r\n    bytes calldata orderData\r\n  ) external returns (uint256);\r\n\r\n  function getExchangeCost(\r\n    address makerToken,\r\n    address takerToken,\r\n    uint256 desiredMakerToken,\r\n    bytes calldata orderData\r\n  ) external view returns (uint256);\r\n}\r\n\r\nlibrary LoopringTypes {\r\n  struct BrokerApprovalRequest {\r\n    BrokerOrder[] orders;\r\n    address tokenS;\r\n    address tokenB;\r\n    address feeToken;\r\n    uint totalFillAmountB;\r\n    uint totalRequestedAmountS;\r\n    uint totalRequestedFeeAmount;\r\n  }\r\n\r\n  struct BrokerOrder {\r\n    address owner;\r\n    bytes32 orderHash;\r\n    uint fillAmountB;\r\n    uint requestedAmountS;\r\n    uint requestedFeeAmount;\r\n    address tokenRecipient;\r\n    bytes extraData;\r\n  }\r\n\r\n  struct BrokerInterceptorReport {\r\n    address owner;\r\n    address broker;\r\n    bytes32 orderHash;\r\n    address tokenB;\r\n    address tokenS;\r\n    address feeToken;\r\n    uint fillAmountB;\r\n    uint spentAmountS;\r\n    uint spentFeeAmount;\r\n    address tokenRecipient;\r\n    bytes extraData;\r\n  }\r\n\r\n  enum TokenType { ERC20 }\r\n\r\n  struct Spendable {\r\n    bool initialized;\r\n    uint amount;\r\n    uint reserved;\r\n  }\r\n\r\n  struct Order {\r\n    uint      version;\r\n\r\n    // required fields\r\n    address   owner;\r\n    address   tokenS;\r\n    address   tokenB;\r\n    uint      amountS;\r\n    uint      amountB;\r\n    uint      validSince;\r\n    Spendable tokenSpendableS;\r\n    Spendable tokenSpendableFee;\r\n\r\n    // optional fields\r\n    address   dualAuthAddr;\r\n    address   broker;\r\n    Spendable brokerSpendableS;\r\n    Spendable brokerSpendableFee;\r\n    address   orderInterceptor;\r\n    address   wallet;\r\n    uint      validUntil;\r\n    bytes     sig;\r\n    bytes     dualAuthSig;\r\n    bool      allOrNone;\r\n    address   feeToken;\r\n    uint      feeAmount;\r\n    int16     waiveFeePercentage;\r\n    uint16    tokenSFeePercentage;    // Pre-trading\r\n    uint16    tokenBFeePercentage;   // Post-trading\r\n    address   tokenRecipient;\r\n    uint16    walletSplitPercentage;\r\n\r\n    // computed fields\r\n    bool    P2P;\r\n    bytes32 hash;\r\n    address brokerInterceptor;\r\n    uint    filledAmountS;\r\n    uint    initialFilledAmountS;\r\n    bool    valid;\r\n\r\n    TokenType tokenTypeS;\r\n    TokenType tokenTypeB;\r\n    TokenType tokenTypeFee;\r\n    bytes32 trancheS;\r\n    bytes32 trancheB;\r\n    uint    maxPrimaryFillAmount;\r\n    bool    transferFirstAsMaker;\r\n    bytes   transferDataS;\r\n  }\r\n}\r\n\r\ninterface IBrokerDelegate {\r\n  function brokerRequestAllowance(LoopringTypes.BrokerApprovalRequest calldata request) external returns (bool);\r\n  function onOrderFillReport(LoopringTypes.BrokerInterceptorReport calldata fillReport) external;\r\n  function brokerBalanceOf(address owner, address token) external view returns (uint);\r\n}\r\n\r\nlibrary ERC20SafeTransfer {\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // A transfer is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n\r\n        // bytes4(keccak256(\"transfer(address,uint256)\")) = 0xa9059cbb\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            bytes4(0xa9059cbb),\r\n            to,\r\n            value\r\n        );\r\n        (success, ) = token.call(callData);\r\n        return checkReturnValue(success);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // A transferFrom is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n\r\n        // bytes4(keccak256(\"transferFrom(address,address,uint256)\")) = 0x23b872dd\r\n        bytes memory callData = abi.encodeWithSelector(\r\n            bytes4(0x23b872dd),\r\n            from,\r\n            to,\r\n            value\r\n        );\r\n        (success, ) = token.call(callData);\r\n        return checkReturnValue(success);\r\n    }\r\n\r\n    function checkReturnValue(\r\n        bool success\r\n        )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // A transfer/transferFrom is successful when 'call' is successful and depending on the token:\r\n        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\r\n        // - A single boolean is returned: this boolean needs to be true (non-zero)\r\n        if (success) {\r\n            assembly {\r\n                switch returndatasize()\r\n                // Non-standard ERC20: nothing is returned so if 'call' was successful we assume the transfer succeeded\r\n                case 0 {\r\n                    success := 1\r\n                }\r\n                // Standard ERC20: a single boolean value is returned which needs to be true\r\n                case 32 {\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)\r\n                }\r\n                // None of the above: not successful\r\n                default {\r\n                    success := 0\r\n                }\r\n            }\r\n        }\r\n        return success;\r\n    }\r\n\r\n}\r\n\r\nlibrary LoopringBytesUtil {\r\n    function bytesToBytes32(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return bytes32(bytesToUintX(b, offset, 32));\r\n    }\r\n\r\n    function bytesToUint(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        return bytesToUintX(b, offset, 32);\r\n    }\r\n\r\n    function bytesToAddress(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        return address(bytesToUintX(b, offset, 20) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    }\r\n\r\n    function bytesToUint16(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint16)\r\n    {\r\n        return uint16(bytesToUintX(b, offset, 2) & 0xFFFF);\r\n    }\r\n\r\n    function bytesToUintX(\r\n        bytes memory b,\r\n        uint offset,\r\n        uint numBytes\r\n        )\r\n        private\r\n        pure\r\n        returns (uint data)\r\n    {\r\n        require(b.length >= offset + numBytes, \"INVALID_SIZE\");\r\n        assembly {\r\n            data := mload(add(add(b, numBytes), offset))\r\n        }\r\n    }\r\n\r\n    function subBytes(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes memory data)\r\n    {\r\n        require(b.length >= offset + 32, \"INVALID_SIZE\");\r\n        assembly {\r\n            data := add(add(b, 32), offset)\r\n        }\r\n    }\r\n}\r\n\r\nlibrary DecodeHelper {\r\n  using LoopringBytesUtil for bytes;\r\n\r\n  function decodeRelayerInfo(bytes memory self) internal pure returns (Types.RelayerInfo memory relayerInfo) {\r\n    (\r\n      relayerInfo.marginOrderIndex,\r\n      relayerInfo.marketIdS,\r\n      relayerInfo.marketIdB,\r\n      relayerInfo.fillAmountS,\r\n      relayerInfo.fillAmountB\r\n    ) = abi.decode(self, (uint, uint, uint, uint, uint));\r\n  }\r\n\r\n  function decodeMarginTradeDetails(bytes memory self, bytes4 requiredOrderSelector) \r\n    internal \r\n    pure \r\n    returns (Types.MarginOrderDetails memory details) \r\n  {\r\n    uint typeRaw;\r\n    bytes4 orderSelector;\r\n\r\n    (\r\n      orderSelector,\r\n      details.positionId,\r\n      typeRaw,\r\n      details.depositAmount,\r\n      details.depositMarketId,\r\n      details.expiration\r\n    ) = abi.decode(self, (bytes4, uint, uint, uint, uint, uint));\r\n\r\n    require(orderSelector == requiredOrderSelector, \"Margin order must have proper selector header in transferDataS\");\r\n\r\n    if (typeRaw == 0) details.positionType = Types.MarginOrderType.OPEN_LONG;\r\n    else if (typeRaw == 1) details.positionType = Types.MarginOrderType.OPEN_SHORT;\r\n    else if (typeRaw == 2) details.positionType = Types.MarginOrderType.CLOSE_LONG;\r\n    else if (typeRaw == 3) details.positionType = Types.MarginOrderType.CLOSE_SHORT;\r\n    else revert(\"Invalid margin order type\");\r\n\r\n    details.isOpen = typeRaw < 2;\r\n    details.isLong = typeRaw == 0 || typeRaw == 2;\r\n  }\r\n\r\n  function decodeMarginLimitOrderDetails(bytes memory self)\r\n    internal\r\n    pure\r\n    returns (Types.MarginLimitOrderDetails memory details)\r\n  {\r\n    (\r\n      details.positionId,\r\n      details.marketIdS,\r\n      details.marketIdB,\r\n      details.depositMarketId,\r\n      details.depositAmount,\r\n      details.broker,\r\n      details.expiration   \r\n    ) = abi.decode(self, (uint, uint, uint, uint, uint, address, uint));\r\n  }\r\n\r\n  function decodeOrderData(bytes memory self) internal pure returns (Types.OrderData memory orderData) {\r\n    uint sideRaw;\r\n\r\n    (\r\n      sideRaw,\r\n      orderData.fillAmountS,\r\n      orderData.fillAmountB,\r\n      orderData.ringData,\r\n      orderData.marginOrderIndex,\r\n      orderData.trader\r\n    ) = abi.decode(self, (uint, uint, uint, bytes, uint, address));\r\n\r\n    orderData.side = sideRaw == 0 ? Types.OrderDataSide.BUY : Types.OrderDataSide.SELL;\r\n  }\r\n\r\n  /**\r\n   * Find the location of the specified order in the given bytes and\r\n   * decode it into a Loopring Order struct\r\n   */\r\n  uint private constant ORDER_STRUCT_SIZE = 38 * 32;\r\n\r\n  function decodeMinimalOrderAtIndex(\r\n    bytes memory self, \r\n    uint orderIndex, \r\n    address lrcTokenAddress\r\n  ) \r\n    internal \r\n    pure \r\n    returns (LoopringTypes.Order memory order) \r\n  {\r\n    \r\n    // Read the header\r\n    uint numOrders = self.bytesToUint16(2);\r\n    uint numRings = self.bytesToUint16(4);\r\n\r\n    // Calculate data pointers\r\n    uint dataPtr;\r\n    assembly { dataPtr := self }\r\n    uint tablesPtr = dataPtr + 8 + (3 * 2);\r\n    uint data = (tablesPtr + (32 * numOrders) * 2) + (numRings * 9) + 32;\r\n    \r\n    // Decode single order \r\n    bytes memory emptyBytes = new bytes(0);\r\n    uint offset = orderIndex * ORDER_STRUCT_SIZE; // start offset at specified order index\r\n    tablesPtr += 2;\r\n\r\n    assembly {\r\n      \r\n      // order.owner\r\n      offset := mul(and(mload(add(tablesPtr,  2)), 0xFFFF), 4)\r\n      mstore(\r\n        add(order,  32),\r\n        and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      )\r\n\r\n      // order.tokenS\r\n      offset := mul(and(mload(add(tablesPtr,  4)), 0xFFFF), 4)\r\n      mstore(\r\n        add(order,  64),\r\n        and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      )\r\n\r\n      // order.tokenB\r\n      offset := mul(and(mload(add(tablesPtr,  6)), 0xFFFF), 4)\r\n      mstore(\r\n        add(order,  96),\r\n        and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      )\r\n\r\n      // order.amountS\r\n      offset := mul(and(mload(add(tablesPtr,  8)), 0xFFFF), 4)\r\n      mstore(\r\n        add(order, 128),\r\n        mload(add(add(data, 32), offset))\r\n      )\r\n\r\n      // order.amountB\r\n      offset := mul(and(mload(add(tablesPtr, 10)), 0xFFFF), 4)\r\n      mstore(\r\n        add(order, 160),\r\n        mload(add(add(data, 32), offset))\r\n      )\r\n\r\n      // order.broker\r\n      offset := mul(and(mload(add(tablesPtr, 20)), 0xFFFF), 4)\r\n      mstore(\r\n          add(order, 320),\r\n          and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      )\r\n\r\n      // lrcTokenAddress is the default value for feeToken\r\n      mstore(add(data, 20), lrcTokenAddress)\r\n\r\n      // order.feeToken\r\n      offset := mul(and(mload(add(tablesPtr, 34)), 0xFFFF), 4)\r\n      mstore(\r\n          add(order, 608),\r\n          and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      )\r\n\r\n      // Restore default to 0\r\n      mstore(add(data, 20), 0)\r\n\r\n      // order.feeAmount\r\n      offset := mul(and(mload(add(tablesPtr, 36)), 0xFFFF), 4)\r\n      mstore(\r\n          add(order, 640),\r\n          mload(add(add(data, 32), offset))\r\n      )\r\n\r\n      // order.waiveFeePercentage\r\n      offset := and(mload(add(tablesPtr, 38)), 0xFFFF)\r\n      mstore(\r\n          add(order, 672),\r\n          offset\r\n      )\r\n\r\n      // The owner is the default value of tokenRecipient\r\n      mstore(add(data, 20), mload(add(order, 32))) // order.owner\r\n\r\n      // order.tokenRecipient\r\n      offset := mul(and(mload(add(tablesPtr, 44)), 0xFFFF), 4)\r\n      mstore(\r\n          add(order, 768),\r\n          and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      )\r\n\r\n      // Restore default to 0\r\n      mstore(add(data, 20), 0)\r\n\r\n      // Default to empty bytes array for transferDataS\r\n      mstore(add(data, 32), emptyBytes)\r\n\r\n      // order.transferDataS\r\n      offset := mul(and(mload(add(tablesPtr, 62)), 0xFFFF), 4)\r\n      mstore(\r\n          add(order, 1248),\r\n          add(data, add(offset, 32))\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\nlibrary MarginOrderHelper {\r\n  using DecodeHelper for bytes;\r\n  using SafeMath for uint;\r\n\r\n  function getAmountB(LoopringTypes.Order memory self) internal pure returns (uint) {\r\n    return calculateActualAmount(self, self.amountB, self.tokenB);\r\n  }\r\n\r\n  function getAmountS(LoopringTypes.Order memory self) internal pure returns (uint) {\r\n    return calculateActualAmount(self, self.amountS, self.tokenS);\r\n  }\r\n\r\n  /**\r\n   * Calculate actual amount by matching feeToken with the given token\r\n   * and then adding/subtracting the feeAmount from the given amount\r\n   */\r\n  function calculateActualAmount(\r\n    LoopringTypes.Order memory self, \r\n    uint fillAmount, \r\n    address token\r\n  ) \r\n    internal \r\n    pure \r\n    returns (uint) \r\n  {\r\n    uint feeMultiple = self.waiveFeePercentage < 0 ? 1000 : 1000 - uint(self.waiveFeePercentage);\r\n    if (token == self.tokenS && token == self.feeToken) return fillAmount.add(self.feeAmount.mul(feeMultiple) / 1000);\r\n    if (token == self.tokenB && token == self.feeToken) return fillAmount.sub(self.feeAmount.mul(feeMultiple) / 1000);\r\n    return fillAmount;\r\n  }\r\n\r\n  /**\r\n   * Decode the fields necessary to open/close a long/short position from the Order.\r\n   * These fields are encoded in the `bytes transferDataS` field of an order.\r\n   */\r\n  function getMarginOrderDetails(LoopringTypes.Order memory self, bytes4 requiredOrderSelector) \r\n    internal \r\n    view \r\n    returns (Types.MarginOrderDetails memory details) \r\n  {\r\n    details = self.transferDataS.decodeMarginTradeDetails(requiredOrderSelector);\r\n    details.owner = self.owner;\r\n    details.depositToken = self.tokenB;\r\n  }\r\n\r\n  /**\r\n   * Check the validity of the provided Loopring order and the \r\n   * margin order details encoded in it's transferDataS field\r\n   * as well as confirming the validity of the information provided\r\n   * by the relayer.\r\n   */\r\n  string constant INVALID_MARKET_S = \"marketIdS provided by relayer must have address equal to tokenS\";\r\n  string constant INVALID_MARKET_B = \"marketIdB provided by relayer must have address equal to tokenB\";\r\n  string constant INVALID_DEPOSIT_MARKET = \"depositMarketId must have an address equal to tokenB\";\r\n  string constant INVALID_TOKEN_RECIPIENT = \"Invalid tokenRecipient - must be set correctly\";\r\n\r\n  function checkValidity(\r\n    LoopringTypes.Order memory self, \r\n    Types.RelayerInfo memory relayerInfo,\r\n    Types.MarginOrderDetails memory marginDetails,\r\n    DydxProtocol dydxProtocol\r\n  ) \r\n    internal\r\n    view \r\n  {\r\n    // Set withdrawal market id\r\n    marginDetails.withdrawalMarketId = relayerInfo.marketIdS;\r\n\r\n    // Check that marketIdS from relayer matches order's tokenS\r\n    address marketAddressS = dydxProtocol.getMarketTokenAddress(relayerInfo.marketIdS);\r\n    require(self.tokenS == marketAddressS, INVALID_MARKET_S);\r\n\r\n    // Check that marketIdB from relayer matches order's tokenB\r\n    address marketAddressB = dydxProtocol.getMarketTokenAddress(relayerInfo.marketIdB);\r\n    require(self.tokenB == marketAddressB, INVALID_MARKET_B);\r\n\r\n    // Check that depositMarketId is equal to the order's tokenB\r\n    if (marginDetails.isOpen) {\r\n      require(marginDetails.depositMarketId == relayerInfo.marketIdB, INVALID_DEPOSIT_MARKET);\r\n    }\r\n\r\n    // Token recipient must be this contract\r\n    require(self.tokenRecipient == address(this), INVALID_TOKEN_RECIPIENT);\r\n  }\r\n}\r\n\r\nlibrary OrderDataHelper {\r\n\r\n  /**\r\n   * Encode exchange action helper\r\n   */\r\n  function encodeWithRingData(Types.OrderData memory self, bytes memory ringData) \r\n    internal \r\n    returns (bytes memory) \r\n  {\r\n    self.ringData = ringData;\r\n    return abi.encode(\r\n      uint(self.side), \r\n      self.fillAmountS, \r\n      self.fillAmountB, \r\n      self.ringData,\r\n      self.marginOrderIndex,\r\n      self.trader\r\n    );\r\n  }\r\n}\r\n\r\n\r\ncontract TradeDelegate {\r\n  function batchTransfer(bytes32[] calldata batch) external;\r\n}\r\n\r\nlibrary MiscHelper {\r\n  using MiscHelper for *;\r\n  using ERC20SafeTransfer for address;\r\n\r\n  // ----------------------------------------------\r\n  // TradeDelegate\r\n\r\n  /**\r\n   * Transfers tokens on behalf of a user. Transfers are done through \r\n   * Loopring's TradeDelegate which has a `batchTransfer` method that takes in encoded bytes\r\n   */\r\n  function transferTokenFrom(\r\n    TradeDelegate self, \r\n    address token,\r\n    address from, \r\n    address to, \r\n    uint256 amount\r\n  ) internal {\r\n    bytes32[] memory transferData = new bytes32[](4);\r\n    transferData[0] = token.toBytes32();\r\n    transferData[1] = from.toBytes32();\r\n    transferData[2] = to.toBytes32();\r\n    transferData[3] = bytes32(amount);\r\n\r\n    self.batchTransfer(transferData);\r\n  }\r\n\r\n  // ----------------------------------------------\r\n  // ERC20\r\n\r\n  function safeTransfer(ERC20 self, address to, uint amount) internal {\r\n    require(address(self).safeTransfer(to, amount), \"Transfer failed\");\r\n  }\r\n\r\n  function safeTransferFrom(ERC20 self, address from, address to, uint amount) internal {\r\n    require(address(self).safeTransferFrom(from, to, amount), \"TransferFrom failed\");\r\n  }\r\n\r\n  // ----------------------------------------------\r\n  // Address\r\n\r\n  function toPayable(address self) internal pure returns (address payable) {\r\n    return address(uint160(self));\r\n  }\r\n\r\n  function toBytes32(address self) internal pure returns (bytes32) {\r\n    return bytes32(uint256(self));\r\n  }\r\n}\r\n\r\n\r\ncontract Globals {\r\n  using MiscHelper for *;\r\n\r\n  string constant public ORDER_SIGNATURE = \"dolomiteMarginOrder(version 1.0.0)\";\r\n  bytes4 constant public ORDER_SELECTOR = bytes4(keccak256(bytes(ORDER_SIGNATURE)));\r\n\r\n  address internal LRC_TOKEN_ADDRESS;\r\n  LoopringProtocol internal LOOPRING_PROTOCOL;\r\n  TradeDelegate internal TRADE_DELEGATE;\r\n  DydxProtocol internal DYDX_PROTOCOL;\r\n  address internal DYDX_EXPIRATION_CONTRACT;\r\n\r\n  // Key: keccak(abi.encodePacked(ownerAddress, positionId))\r\n  // Value: flag for whether or not it was created by the DolomiteMarginTrading contract\r\n  mapping(bytes32 => bool) positionRegistered;\r\n\r\n  constructor(\r\n    address payable loopringRingSubmitterAddress, \r\n    address dydxProtocolAddress,\r\n    address dydxExpirationContractAddress\r\n  ) public {\r\n\r\n    LOOPRING_PROTOCOL = LoopringProtocol(loopringRingSubmitterAddress);\r\n    LRC_TOKEN_ADDRESS = LOOPRING_PROTOCOL.lrcTokenAddress();\r\n\r\n    address payable tradeDelegateAddress = LOOPRING_PROTOCOL.delegateAddress().toPayable();\r\n    TRADE_DELEGATE = TradeDelegate(tradeDelegateAddress);\r\n    \r\n    DYDX_PROTOCOL = DydxProtocol(dydxProtocolAddress);\r\n    DYDX_EXPIRATION_CONTRACT = dydxExpirationContractAddress;\r\n  }\r\n\r\n  function registerPosition(address owner, uint positionId) internal {\r\n    if (isPositionRegistered(owner, positionId)) return;\r\n    bytes32 positionKey = keccak256(abi.encodePacked(owner, positionId));\r\n    positionRegistered[positionKey] = true;\r\n  }\r\n\r\n  function isPositionRegistered(address owner, uint positionId) internal returns (bool) {\r\n    bytes32 positionKey = keccak256(abi.encodePacked(owner, positionId));\r\n    return positionRegistered[positionKey];\r\n  }\r\n}\r\n\r\n/**\r\n * @title LoopringV2ExchangeWrapper\r\n *\r\n * Dydx compatible `ExchangeWrapper` implementation to enable\r\n * Loopring ring settlement to be performed through Dydx to settle\r\n * trades for performing margin trading with Dydx and Loopring\r\n */\r\ncontract LoopringV2ExchangeWrapper is IDydxExchangeWrapper, Globals {\r\n  using MiscHelper for *;\r\n  using DecodeHelper for bytes;\r\n  using SafeMath for uint;\r\n\r\n  address constant ZERO_ADDRESS = address(0x0);\r\n\r\n  string constant INVALID_MSG_SENDER = \"The msg.sender must be Dydx protocol\";\r\n  string constant INVALID_RECEIVER = \"Bought token receiver must be Dydx protocol\";\r\n  string constant INVALID_TOKEN_RECIPIENT = \"Invalid tokenRecipient in Loopring order\";\r\n  string constant INVALID_TRADE_ORIGINATOR = \"Loopring order owner must be originator\";\r\n  string constant NOTHING_RECEIVED = \"Amount received is zero. Ring submission most likely failed\";\r\n\r\n  /**\r\n   * Exchange some amount of takerToken for makerToken.\r\n   *\r\n   * @param  tradeOriginator      Address of the initiator of the trade (however, this value\r\n   *                              cannot always be trusted as it is set at the discretion of the\r\n   *                              msg.sender)\r\n   * @param  receiver             Address to set allowance on once the trade has completed\r\n   * @param  makerToken           Address of makerToken, the token to receive\r\n   * @param  takerToken           Address of takerToken, the token to pay\r\n   * @param  requestedFillAmount  Amount of takerToken being paid\r\n   * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\r\n   * @return                      The amount of makerToken received\r\n   */\r\n  function exchange(\r\n    address tradeOriginator,\r\n    address receiver,\r\n    address makerToken,\r\n    address takerToken,\r\n    uint256 requestedFillAmount,\r\n    bytes calldata orderData\r\n  ) external returns (uint256) {\r\n    require(msg.sender == address(DYDX_PROTOCOL), INVALID_MSG_SENDER);\r\n    require(receiver == address(DYDX_PROTOCOL), INVALID_RECEIVER);\r\n\r\n    Types.OrderData memory orderInfo = orderData.decodeOrderData();\r\n    LoopringTypes.Order memory order = orderInfo.ringData.decodeMinimalOrderAtIndex(\r\n      orderInfo.marginOrderIndex,\r\n      ZERO_ADDRESS\r\n    );\r\n\r\n    require(order.tokenRecipient == address(this), INVALID_TOKEN_RECIPIENT);\r\n    require(order.broker == address(0x0)\r\n      ? tradeOriginator == order.owner\r\n      : tradeOriginator == orderInfo.trader\r\n    , INVALID_TRADE_ORIGINATOR);\r\n\r\n    // Transfer sell tokens to order owner\r\n    ERC20(takerToken).safeTransfer(orderInfo.trader, requestedFillAmount);\r\n\r\n    // Record balance of buy tokens prior to ring submission\r\n    uint balanceBeforeSubmission = ERC20(makerToken).balanceOf(address(this));\r\n\r\n    // Submit & settle rings\r\n    LOOPRING_PROTOCOL.submitRings(orderInfo.ringData);\r\n\r\n    // Get actual amount of tokens received\r\n    uint amountReceived = ERC20(makerToken).balanceOf(address(this)).sub(balanceBeforeSubmission);\r\n    require(amountReceived > 0, NOTHING_RECEIVED);\r\n    require(amountReceived.div(1e10) == orderInfo.fillAmountB.div(1e10), \r\n      unexpectedReceivedError(orderInfo.fillAmountB, amountReceived));\r\n\r\n    return amountReceived;\r\n  }\r\n\r\n  /**\r\n   * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\r\n   * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\r\n   * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\r\n   * than desiredMakerToken\r\n   *\r\n   * @param  makerToken         Address of makerToken, the token to receive\r\n   * @param  takerToken         Address of takerToken, the token to pay\r\n   * @param  desiredMakerToken  Amount of makerToken requested\r\n   * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\r\n   * @return                    Amount of takerToken the needed to complete the exchange\r\n   */\r\n  function getExchangeCost(\r\n    address makerToken,\r\n    address takerToken,\r\n    uint256 desiredMakerToken,\r\n    bytes calldata orderData\r\n  ) external view returns (uint256) {\r\n    return orderData.decodeOrderData().fillAmountS;\r\n  }\r\n\r\n\r\n  // =====================================\r\n\r\n  function unexpectedReceivedError(uint expected, uint actual) private pure returns (string memory) {\r\n    return string(abi.encodePacked(\r\n      \"Amount received (\",\r\n      uintToString(expected),\r\n      \") must be exactly equal to expected amountB (\",\r\n      uintToString(actual),\r\n      \") provided by either relayer or order\"\r\n    ));\r\n  }\r\n\r\n  function uintToString(uint num) private pure returns (string memory) {\r\n    if (num == 0) {\r\n      return \"0\";\r\n    }\r\n    uint j = num;\r\n    uint len;\r\n    while (j != 0) {\r\n      len++;\r\n      j /= 10;\r\n    }\r\n    bytes memory bstr = new bytes(len);\r\n    uint k = len - 1;\r\n    while (num != 0) {\r\n      bstr[k--] = byte(uint8(48 + num % 10));\r\n      num /= 10;\r\n    }\r\n    return string(bstr);\r\n  }\r\n}\r\n\r\n/*\r\n * @title MarginLimitBroker\r\n *\r\n * Implements IBrokerDelegate to be used as a broker for the Loopring \r\n * protocol to enable limit orders (makers) to be used to open leveraged \r\n * long/short positions in Dydx.\r\n */\r\ncontract MarginLimitBroker is Globals, IBrokerDelegate {\r\n  using DecodeHelper for bytes;\r\n  using SafeMath for uint;\r\n\r\n  event FilledPosition(address indexed trader, uint indexed id, uint fillAmountB, uint fillAmountS, uint depositAmount);\r\n\r\n  mapping(bytes32 => bool) public hasExecutedDeposit;\r\n\r\n  function brokerRequestAllowance(LoopringTypes.BrokerApprovalRequest memory request) public returns (bool) {\r\n    require(msg.sender == address(LOOPRING_PROTOCOL), \"The msg.sender must be the Loopring protocol\");\r\n\r\n    DydxActions.ActionArgs[] memory actionsQueue = new DydxActions.ActionArgs[](request.orders.length * 3);\r\n    DydxPosition.Info[] memory positionsQueue = new DydxPosition.Info[](request.orders.length);\r\n\r\n    uint numActions;\r\n    uint numPositions;\r\n\r\n    for (uint i = 0; i < request.orders.length; i++) {\r\n      (\r\n        LoopringTypes.BrokerOrder memory order,\r\n        Types.MarginLimitOrderDetails memory limitOrder\r\n      ) = _marginLimitOrderAtIndex(request, i);\r\n\r\n      uint positionIndex;\r\n      uint totalDepositAmount = order.fillAmountB;\r\n      uint depositedCollateralAmount = 0;\r\n\r\n      (\r\n        numPositions,\r\n        positionIndex\r\n      ) = _generatePositionIndex(positionsQueue, numPositions, limitOrder.trader, limitOrder.positionId);\r\n\r\n      // Move funds for collateral into this contract for deposit into dydx if it hasn't already been done\r\n      if (!hasExecutedDeposit[order.orderHash]) {\r\n        hasExecutedDeposit[order.orderHash] = true;\r\n        totalDepositAmount += limitOrder.depositAmount;\r\n        depositedCollateralAmount = limitOrder.depositAmount;\r\n\r\n        if (limitOrder.broker == address(0x0)) {\r\n          TRADE_DELEGATE.transferTokenFrom(limitOrder.depositToken, order.owner, address(this), limitOrder.depositAmount);\r\n        } else {\r\n          IDolomiteMarginTradingBroker(limitOrder.broker)\r\n            .brokerMarginRequestApproval(order.owner, limitOrder.depositToken, limitOrder.depositAmount);\r\n          ERC20(limitOrder.depositToken).transferFrom(limitOrder.broker, address(this), limitOrder.depositAmount);\r\n        }\r\n      }\r\n\r\n      // Deposit the collateral and fillAmountB (received at this point from Loopring settlement)\r\n      actionsQueue[numActions] = _constructDydxTokenAction({\r\n        positionIndex: positionIndex,\r\n        isDeposit: true,\r\n        amount: totalDepositAmount,\r\n        marketId: limitOrder.marketIdB,\r\n        targetAddress: address(this)\r\n      });\r\n\r\n      // Withdraw the requestedAmountS needed by Loopring to complete ring settlement\r\n      actionsQueue[numActions + 1] = _constructDydxTokenAction({\r\n        positionIndex: positionIndex,\r\n        isDeposit: false,\r\n        amount: order.requestedAmountS,\r\n        marketId: limitOrder.marketIdS,\r\n        targetAddress: address(this)\r\n      });\r\n\r\n      numActions += 2;\r\n\r\n      // Set position expiration if needed and if it has not already been done\r\n      if (limitOrder.expiration > 0 && !isPositionRegistered(limitOrder.trader, limitOrder.positionId)) {\r\n        actionsQueue[numActions] = _constructDydxExpirationAction(\r\n          positionIndex, \r\n          limitOrder.marketIdS, \r\n          limitOrder.expiration\r\n        );\r\n\r\n        numActions++;\r\n      }\r\n\r\n      registerPosition(limitOrder.trader, limitOrder.positionId);\r\n      emit FilledPosition(limitOrder.trader, limitOrder.positionId, order.fillAmountB, order.requestedAmountS, depositedCollateralAmount);\r\n    }\r\n\r\n    // Consolidate action and position queues & execute them with DyDx\r\n    DydxActions.ActionArgs[] memory actions = new DydxActions.ActionArgs[](numActions);\r\n    DydxPosition.Info[] memory positions = new DydxPosition.Info[](numPositions);\r\n\r\n    for (uint b = 0; b < numActions; b++) {\r\n      actions[b] = actionsQueue[b];\r\n      if (b < numPositions) positions[b] = positionsQueue[b];\r\n    }\r\n\r\n    DYDX_PROTOCOL.operate(positions, actions);\r\n\r\n    // Does not use onOrderFillReport\r\n    return false; \r\n  }\r\n\r\n  function onOrderFillReport(LoopringTypes.BrokerInterceptorReport memory fillReport) public {\r\n    // Do nothing, this function is not used\r\n  }\r\n\r\n  function brokerBalanceOf(address owner, address tokenAddress) public view returns (uint) {\r\n    return 10**70; // Balance is unknown, return very large number\r\n  }\r\n\r\n  // ================================\r\n  // Private helpers\r\n\r\n  function _constructDydxTokenAction(uint positionIndex, bool isDeposit, uint amount, uint marketId, address targetAddress)\r\n    private\r\n    pure\r\n    returns (DydxActions.ActionArgs memory action)\r\n  {\r\n    action.actionType = isDeposit ? DydxActions.ActionType.Deposit : DydxActions.ActionType.Withdraw;\r\n    action.accountId = positionIndex;\r\n    action.primaryMarketId = marketId;\r\n    action.otherAddress = targetAddress;\r\n    action.amount = DydxTypes.AssetAmount({\r\n      sign: isDeposit,\r\n      denomination: DydxTypes.AssetDenomination.Wei,\r\n      ref: DydxTypes.AssetReference.Delta,\r\n      value: amount\r\n    });\r\n  }\r\n\r\n  function _constructDydxExpirationAction(uint positionIndex, uint marketId, uint expiration) \r\n    private \r\n    view \r\n    returns (DydxActions.ActionArgs memory action) \r\n  {\r\n    action.actionType = DydxActions.ActionType.Call;\r\n    action.accountId = positionIndex;\r\n    action.otherAddress = DYDX_EXPIRATION_CONTRACT;\r\n    action.data = abi.encode(marketId, block.timestamp + expiration);\r\n  }\r\n\r\n  function _generatePositionIndex(\r\n    DydxPosition.Info[] memory positions, \r\n    uint numPositions, \r\n    address trader, \r\n    uint positionId\r\n  ) \r\n    private \r\n    returns (uint, uint) // (total positions, position index)\r\n  {\r\n    for (uint i = 0; i < numPositions; i++) {\r\n      if (positions[i].owner == trader && positions[i].number == positionId) {\r\n        return (numPositions, i);\r\n      }\r\n    }\r\n\r\n    positions[numPositions] = DydxPosition.Info(trader, positionId);\r\n    return (numPositions + 1, numPositions);\r\n  }\r\n\r\n  function _marginLimitOrderAtIndex(LoopringTypes.BrokerApprovalRequest memory request, uint index)\r\n    private\r\n    view\r\n    returns (\r\n      LoopringTypes.BrokerOrder memory order,\r\n      Types.MarginLimitOrderDetails memory limitOrder\r\n    )\r\n  {\r\n    order = request.orders[index];\r\n    limitOrder = order.extraData.decodeMarginLimitOrderDetails();\r\n\r\n    address marketAddressS = DYDX_PROTOCOL.getMarketTokenAddress(limitOrder.marketIdS);\r\n    require(request.tokenS == marketAddressS, \"marketIdS must have address equal to tokenS\");\r\n\r\n    address marketAddressB = DYDX_PROTOCOL.getMarketTokenAddress(limitOrder.marketIdB);\r\n    require(request.tokenB == marketAddressB, \"marketIdB must have address equal to tokenB\");\r\n\r\n    limitOrder.depositToken = DYDX_PROTOCOL.getMarketTokenAddress(limitOrder.depositMarketId);\r\n    require(request.tokenB == limitOrder.depositToken, \"depositMarketId must have an address equal to tokenB\");\r\n\r\n    require(order.tokenRecipient == address(this), \"Invalid tokenRecipient - must be set correctly\");\r\n\r\n    if (limitOrder.broker != address(0x0)) {\r\n      limitOrder.trader = IDolomiteMarginTradingBroker(limitOrder.broker)\r\n        .brokerMarginGetTrader(order.owner, order.extraData);\r\n    } else {\r\n      limitOrder.trader = order.owner;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @title MarginRingSubmitterWrapper\r\n *\r\n * Entry point for margin trading though Dydx and Loopring. Dolomite\r\n * relay calls `submitRingsWithMarginOrder` passing the same ringData \r\n * that would be passed to Loopring's `submitRings` plus some additional\r\n * info about the margin order being filled in the rings.\r\n */\r\ncontract MarginRingSubmitterWrapper is Globals {\r\n  using MiscHelper for *;\r\n  using DecodeHelper for bytes;\r\n  using MarginOrderHelper for LoopringTypes.Order;\r\n  using OrderDataHelper for Types.OrderData;\r\n\r\n  event OpenPosition(address indexed trader, uint indexed id);\r\n  event ClosePosition(address indexed trader, uint indexed id);\r\n\r\n  /**\r\n   * Loopring protocol middleman that opens/closes a margin position with Dy/dx using\r\n   * Loopring as the medium of exchange\r\n   */\r\n  function submitRingsWithMarginOrder(\r\n    bytes calldata ringData, \r\n    bytes calldata relayData\r\n  ) external {\r\n\r\n    (\r\n      Types.RelayerInfo memory relayerInfo,\r\n      LoopringTypes.Order memory order,\r\n      Types.MarginOrderDetails memory marginDetails\r\n    ) = decodeParams(ringData, relayData);\r\n\r\n    // ----------------------\r\n    // Construct order data\r\n\r\n    Types.OrderData memory orderData;\r\n\r\n    if (order.broker == address(0x0)) {\r\n      orderData.trader = order.owner;\r\n    } else {\r\n      orderData.trader = IDolomiteMarginTradingBroker(order.broker).brokerMarginGetTrader(\r\n        order.owner, \r\n        order.transferDataS\r\n      );\r\n    }\r\n\r\n    if (marginDetails.isOpen && marginDetails.isLong) {\r\n      // Open Long\r\n      orderData.side = Types.OrderDataSide.BUY;\r\n      orderData.fillAmountS = order.calculateActualAmount(relayerInfo.fillAmountS, order.tokenS);\r\n      orderData.fillAmountB = order.getAmountB();\r\n\r\n    } else if (marginDetails.isOpen && !marginDetails.isLong) {\r\n      // Open Short\r\n      orderData.side = Types.OrderDataSide.SELL;\r\n      orderData.fillAmountS = order.getAmountS();\r\n      orderData.fillAmountB = order.calculateActualAmount(relayerInfo.fillAmountB, order.tokenB);\r\n\r\n    } else if (!marginDetails.isOpen && marginDetails.isLong) {\r\n      // Close Long\r\n      orderData.side = Types.OrderDataSide.BUY;\r\n      orderData.fillAmountS = order.getAmountS();\r\n      orderData.fillAmountB = order.calculateActualAmount(relayerInfo.fillAmountB, order.tokenB);\r\n      orderData.bringToZero = true;\r\n\r\n    } else if (!marginDetails.isOpen && !marginDetails.isLong) {\r\n      // Close Short\r\n      orderData.side = Types.OrderDataSide.BUY;\r\n      orderData.fillAmountS = order.calculateActualAmount(relayerInfo.fillAmountS, order.tokenS);\r\n      orderData.fillAmountB = order.getAmountB();\r\n      orderData.bringToZero = true;\r\n    }\r\n\r\n    bytes memory encodedOrderData = orderData.encodeWithRingData(ringData);\r\n\r\n    // ----------------------\r\n    // Construct dydx actions\r\n\r\n    DydxActions.ActionArgs[] memory actions;\r\n    DydxPosition.Info[] memory positions = new DydxPosition.Info[](1);\r\n    \r\n    // Add dydx position (account) that actions will operate on\r\n    positions[0] = DydxPosition.Info({\r\n      owner: orderData.trader,\r\n      number: marginDetails.positionId\r\n    });\r\n\r\n    // Construct exchange action (buy or sell)\r\n    DydxActions.ActionArgs memory exchangeAction;\r\n    exchangeAction.otherAddress = address(this);\r\n    exchangeAction.data = encodedOrderData;\r\n\r\n    if (orderData.side == Types.OrderDataSide.BUY) {\r\n      // Buy Order\r\n      exchangeAction.actionType = DydxActions.ActionType.Buy;\r\n      exchangeAction.primaryMarketId = relayerInfo.marketIdB;\r\n      exchangeAction.secondaryMarketId = relayerInfo.marketIdS;\r\n\r\n      if (orderData.bringToZero) {\r\n        // Buy enough to repay the loan (end balance will be 0)\r\n        exchangeAction.amount = DydxTypes.AssetAmount({\r\n          sign: true,\r\n          denomination: DydxTypes.AssetDenomination.Wei,\r\n          ref: DydxTypes.AssetReference.Target,\r\n          value: 0\r\n        });\r\n\r\n      } else {\r\n        exchangeAction.amount = DydxTypes.AssetAmount({\r\n          sign: true,\r\n          denomination: DydxTypes.AssetDenomination.Wei,\r\n          ref: DydxTypes.AssetReference.Delta,\r\n          value: orderData.fillAmountB\r\n        });\r\n      }\r\n      \r\n    } else if (orderData.side == Types.OrderDataSide.SELL) {\r\n      // Sell Order\r\n      exchangeAction.actionType = DydxActions.ActionType.Sell;\r\n      exchangeAction.primaryMarketId = relayerInfo.marketIdS;\r\n      exchangeAction.secondaryMarketId = relayerInfo.marketIdB;\r\n      exchangeAction.amount = DydxTypes.AssetAmount({\r\n        sign: false,\r\n        denomination: DydxTypes.AssetDenomination.Wei,\r\n        ref: DydxTypes.AssetReference.Delta,\r\n        value: orderData.fillAmountS\r\n      });\r\n    }\r\n\r\n    if (marginDetails.isOpen) {\r\n      \r\n      if (order.broker == address(0x0)) {\r\n        // Pull deposit funds from owner to this contract\r\n        TRADE_DELEGATE.transferTokenFrom(\r\n          marginDetails.depositToken, \r\n          marginDetails.owner,\r\n          address(this), \r\n          marginDetails.depositAmount\r\n        );\r\n      } else {\r\n\r\n        // Request approval for deposit funds from the broker\r\n        IDolomiteMarginTradingBroker(order.broker).brokerMarginRequestApproval(\r\n          marginDetails.owner, \r\n          marginDetails.depositToken, \r\n          marginDetails.depositAmount\r\n        );\r\n\r\n        // Pull deposit funds from the broker into this contract\r\n        ERC20(marginDetails.depositToken).transferFrom(\r\n          order.broker,\r\n          address(this),\r\n          marginDetails.depositAmount\r\n        );\r\n      }\r\n\r\n      // Construct action to deposit funds from this contract into a dydx position\r\n      DydxActions.ActionArgs memory depositAction;\r\n      depositAction.actionType = DydxActions.ActionType.Deposit;\r\n      depositAction.primaryMarketId = marginDetails.depositMarketId;\r\n      depositAction.otherAddress = address(this);\r\n      depositAction.amount = DydxTypes.AssetAmount({\r\n        sign: true,\r\n        denomination: DydxTypes.AssetDenomination.Wei,\r\n        ref: DydxTypes.AssetReference.Delta,\r\n        value: marginDetails.depositAmount\r\n      });\r\n\r\n      if (marginDetails.expiration == 0) {\r\n        actions = new DydxActions.ActionArgs[](2);\r\n      } else {\r\n        // Construct action to set the expiration of the dydx position\r\n        DydxActions.ActionArgs memory expirationAction;\r\n        expirationAction.actionType = DydxActions.ActionType.Call;\r\n        expirationAction.otherAddress = DYDX_EXPIRATION_CONTRACT;\r\n        expirationAction.data = encodeExpiration(relayerInfo.marketIdS, marginDetails.expiration);\r\n\r\n        actions = new DydxActions.ActionArgs[](3);\r\n        actions[2] = expirationAction;\r\n      }\r\n\r\n      // Build deposit and exchange actions in correct order\r\n      actions[0] = depositAction;\r\n      actions[1] = exchangeAction;\r\n      \r\n    } else {\r\n      // Construct action to withdraw funds to order owner or order broker trader (orderData.trader)\r\n      DydxActions.ActionArgs memory withdrawAction;\r\n      withdrawAction.actionType = DydxActions.ActionType.Withdraw;\r\n      withdrawAction.primaryMarketId = marginDetails.withdrawalMarketId;\r\n      withdrawAction.otherAddress = orderData.trader;\r\n      withdrawAction.amount = DydxTypes.AssetAmount({\r\n        sign: true,\r\n        denomination: DydxTypes.AssetDenomination.Wei,\r\n        ref: DydxTypes.AssetReference.Target,\r\n        value: 0\r\n      });\r\n\r\n      DydxActions.ActionArgs memory withdrawDustAction;\r\n      withdrawDustAction.actionType = DydxActions.ActionType.Withdraw;\r\n      withdrawDustAction.primaryMarketId = relayerInfo.marketIdB;\r\n      withdrawDustAction.otherAddress = orderData.trader;\r\n      withdrawDustAction.amount = DydxTypes.AssetAmount({\r\n        sign: true,\r\n        denomination: DydxTypes.AssetDenomination.Wei,\r\n        ref: DydxTypes.AssetReference.Target,\r\n        value: 0\r\n      });\r\n\r\n      // Build actions in correct order\r\n      actions = new DydxActions.ActionArgs[](3);\r\n      actions[0] = exchangeAction;\r\n      actions[1] = withdrawAction;\r\n      actions[2] = withdrawDustAction;\r\n    }\r\n\r\n    // ----------------------\r\n    // Perform operation with dydx\r\n\r\n    DYDX_PROTOCOL.operate(positions, actions);\r\n\r\n    // ----------------------\r\n    // Finalize margin order \r\n\r\n    if (marginDetails.isOpen) {\r\n      registerPosition(positions[0].owner, positions[0].number);\r\n      emit OpenPosition(positions[0].owner, positions[0].number);\r\n    } else emit ClosePosition(positions[0].owner, positions[0].number);\r\n  }\r\n\r\n  // ============================================\r\n  // Helpers\r\n\r\n  function decodeParams(bytes memory ringData, bytes memory relayData)\r\n    private\r\n    view\r\n    returns (\r\n      Types.RelayerInfo memory relayerInfo,\r\n      LoopringTypes.Order memory order,\r\n      Types.MarginOrderDetails memory marginDetails\r\n    ) \r\n  {\r\n    relayerInfo = relayData.decodeRelayerInfo();\r\n    order = ringData.decodeMinimalOrderAtIndex(\r\n      relayerInfo.marginOrderIndex, \r\n      LRC_TOKEN_ADDRESS\r\n    );\r\n    marginDetails = order.getMarginOrderDetails(ORDER_SELECTOR);\r\n    order.checkValidity(relayerInfo, marginDetails, DYDX_PROTOCOL);\r\n  }\r\n\r\n  function encodeExpiration(uint marketId, uint expiration) private pure returns (bytes memory) {\r\n    return abi.encode(marketId, expiration);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DolomiteMarginTrading\r\n *\r\n * Combines `MarginRingSubmitterWrapper` and `LoopringV2ExchangeWrapper` into one\r\n * contract. Takes in the address to Loopring's `RingSubmitter` contract and\r\n * Dy/Dx's `SoloMargin` contract to intialize the wrappers that integrate the two.\r\n */\r\ncontract DolomiteMarginTrading is Globals, MarginRingSubmitterWrapper, LoopringV2ExchangeWrapper, MarginLimitBroker {\r\n\r\n  constructor(\r\n    address payable loopringRingSubmitterAddress, \r\n    address dydxProtocolAddress,\r\n    address dydxExpirationContractAddress\r\n  ) \r\n    public \r\n    Globals(loopringRingSubmitterAddress, dydxProtocolAddress, dydxExpirationContractAddress) { }\r\n\r\n  // ---------------------------\r\n  // Administrative\r\n\r\n  function enableToken(address token) external returns (bool) {\r\n    ERC20(token).approve(address(LOOPRING_PROTOCOL), 10**70);\r\n    ERC20(token).approve(address(TRADE_DELEGATE), 10**70);\r\n    ERC20(token).approve(address(DYDX_PROTOCOL), 10**70);\r\n    return true;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ORDER_SIGNATURE\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"desiredMakerToken\",\"type\":\"uint256\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"getExchangeCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ORDER_SELECTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"broker\",\"type\":\"address\"},{\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"name\":\"tokenB\",\"type\":\"address\"},{\"name\":\"tokenS\",\"type\":\"address\"},{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"fillAmountB\",\"type\":\"uint256\"},{\"name\":\"spentAmountS\",\"type\":\"uint256\"},{\"name\":\"spentFeeAmount\",\"type\":\"uint256\"},{\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"fillReport\",\"type\":\"tuple\"}],\"name\":\"onOrderFillReport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"brokerBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeOriginator\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"requestedFillAmount\",\"type\":\"uint256\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"exchange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hasExecutedDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"enableToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"components\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"name\":\"fillAmountB\",\"type\":\"uint256\"},{\"name\":\"requestedAmountS\",\"type\":\"uint256\"},{\"name\":\"requestedFeeAmount\",\"type\":\"uint256\"},{\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"orders\",\"type\":\"tuple[]\"},{\"name\":\"tokenS\",\"type\":\"address\"},{\"name\":\"tokenB\",\"type\":\"address\"},{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"totalFillAmountB\",\"type\":\"uint256\"},{\"name\":\"totalRequestedAmountS\",\"type\":\"uint256\"},{\"name\":\"totalRequestedFeeAmount\",\"type\":\"uint256\"}],\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"brokerRequestAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ringData\",\"type\":\"bytes\"},{\"name\":\"relayData\",\"type\":\"bytes\"}],\"name\":\"submitRingsWithMarginOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"loopringRingSubmitterAddress\",\"type\":\"address\"},{\"name\":\"dydxProtocolAddress\",\"type\":\"address\"},{\"name\":\"dydxExpirationContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fillAmountB\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fillAmountS\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"FilledPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OpenPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ClosePosition\",\"type\":\"event\"}]","ContractName":"DolomiteMarginTrading","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000610c5e1eb8e97a38c1706af02b0caa778f74127c0000000000000000000000001e0447b19bb6ecfdae1e4ae1694b0c3659614e4e0000000000000000000000000ece224fbc24d40b446c6a94a142dc41fae76f2d","Library":"","LicenseType":"Apache-2.0","SwarmSource":"bzzr://2cbc29477305b9836c72e1db4a034f4065998b66324176d71e3f8a13962be9f6"}]}