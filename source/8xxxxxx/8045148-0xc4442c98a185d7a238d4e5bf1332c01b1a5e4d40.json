{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface PrimaryStorage {\r\n    function getDisputeVotePeriod(uint256 did) external view returns (uint256);\r\n    function getResultCountPeriod(uint256 did) external view returns (uint256);\r\n    function getDisputeLotteryPrize(uint256 did) external view returns (uint256 votingPrize);\r\n    function getNumberOfVotesForRefundState(uint256 did) external view returns (uint256);\r\n    function getEntryFee(uint256 did) external view returns (uint256);\r\n    function getDisputeCreator(uint256 did) external view returns (address payable);\r\n    function getRandomNumberBaseLength(uint256 did) external view returns (uint256);\r\n    function getDisputeNumberOfVoters(uint256 did) external view returns (uint256);\r\n    function getFirstPublicDisputeURL(uint256 did) external view returns (bytes memory);\r\n    function getDisputeVoter(uint256 did, uint256 voterId) external view returns (address payable);\r\n    function getHiddenVote(uint256 did, address voter) external view returns (bytes32);\r\n    function getRevealedVote(uint256 did, address voter) external view  returns (bool);\r\n    function getNumberOfVotesAgainstRefundState(uint256 did) external view returns (uint256);\r\n    function setPayment(address participant, uint256 disputeId, uint256 paymentAmount) external;\r\n    function getPayment(address payee, uint256 disputeId) external view returns (uint256);\r\n    function addDispute() external returns (uint256 disputeId);\r\n    function addDisputeIds(uint256 disputeId, uint256 pid) external;\r\n    function setDisputeVotePeriod(uint256 disputeId, uint256 numberOfBlock) external;\r\n    function setResultCountPeriod(uint256 disputeId, uint256 numberOfBlock) external;\r\n    function setPublicDisputeURL(uint256 disputeId, bytes calldata disputeUrl) external;\r\n    function setDisputeControllerOfProject(uint256 disputeId, address disputeCtrlAddr) external;\r\n    function setNumberOfVotesForRefundState(uint256 disputeId) external;\r\n    function setNumberOfVotesAgainstRefundState(uint256 disputeId) external;\r\n    function setDisputeLotteryPrize(uint256 disputeId, uint256 amount) external;\r\n    function setEntryFee(uint256 disputeId, uint256 amount) external;\r\n    function setDisputeCreator(uint256 disputeId, address payable creator) external;\r\n    function addToRandomNumberBase(uint256 disputeId, uint256 number) external;\r\n    function getDisputeProjectId(uint256 disputeId) external view returns (uint256);\r\n    function addHiddenVote(uint256 disputeId, address voter, bytes32 voteHash) external;\r\n    function addDisputeVoter(uint256 disputeId, address voterAddress) external returns (uint256 voterId);\r\n    function addRevealedVote(uint256 disputeId, address voter, bool vote) external;\r\n    function randomNumberGenerator(uint256 disputeId) external view returns (uint256 rng);\r\n    function isPlatformModerator(address who) external view returns (bool);\r\n    function isCommunityModerator(address who) external view returns (bool);\r\n    function isInvestor(address who) external view returns (bool);\r\n    function isProjectOwner(address who) external view returns (bool);\r\n    function getInsuranceOwner(uint256 insId) external view returns (address);\r\n    function removeDisputeVoter(uint256 disputeId, uint256 voterIndex) external;\r\n    function getValidationToken(address verificatedUser) external view returns (uint256);\r\n    function getModerationResources() external view returns (address payable);\r\n}\r\n\r\n\r\ninterface SecondaryStorage {\r\n    function setIsDisputed(uint256 pid) external;\r\n    function setIsInvestorsVoteFailed(uint256 pid, bool failedOrNot) external;\r\n    function getIsDisputed(uint256 pid) external view returns (bool);\r\n    function setIsRefundInProgress(uint256 pid, bool status) external;\r\n    function getIsRefundInProgress(uint256 pid) external view returns(bool);\r\n    function getIsInvestorsVoteFailed(uint256 pid) external view returns(bool);\r\n    function getRefundStatePeriod(uint256 pid) external view returns (uint256);\r\n    function getFreezeStatePeriod(uint256 pid) external view returns (uint256);\r\n    function getAlreadyProtected(uint256 pid, address investor) external view returns(bool isProtected);\r\n    function setFreezeStatePeriod(uint256 pid, uint256 numberInBlocks) external;\r\n    function setOwnerContribution(uint256 pid, uint256 amount) external;\r\n    function setOwnerFunds(uint256 pid, address ownerAddr, uint256 amount) external;\r\n    function getProjectCurrentState(uint256 pid) external view returns (uint8);\r\n    function getOwnerFunds(uint256 pid, address ownerAddr) external view returns (uint256);\r\n    function getOwnerContribution(uint256 pid) external view returns (uint256);\r\n    function setProjectCurrentState(uint256 pid, uint8 currentState) external;\r\n    function setRefundStatePeriod(uint256 pid, uint256 numberInBlocks) external;\r\n    function getPolicyEndDate(uint256 pid) external view returns (uint256);\r\n    function setReturnedRefundTokens(uint256 pid, uint256 amount) external;\r\n    function setVotesForRefundState(uint256 pid, uint256 numberOfVotes) external;\r\n    function getUtilityControllerOfProject(uint256 pid) external view returns (address payable);\r\n    function isRefundStateForced(uint256 pid) external view returns (uint8);\r\n    function setForcedRefundState(uint256 pid, uint8 value) external;\r\n    function getAmountOfFundsContributed(uint256 pid) external view returns (uint256);\r\n    function getDisputeControllerOfProject(uint256 pid) external view returns (address payable);\r\n}\r\n\r\n\r\ninterface RefundPool {\r\n    function deposit(uint256 pid) external payable;\r\n    function insuranceDeposit(uint256 pid) external payable;\r\n    function getProjectFunds (uint256 pid) external view returns (uint256);\r\n    function withdraw(uint256 pid, address payable to, uint256 amount) external;\r\n    function withdrawInsuranceFee(uint256 pid, address payable to, uint256 amount) external;\r\n    function cleanIfNoProjects() external;\r\n}\r\n\r\n\r\n\r\ninterface Logger {\r\n    function emitNewDispute(address caller, uint256 did, uint256 pid, bytes calldata publicDisputeUrl) external;\r\n    function emitDisputeFinished(uint256 did, uint256 pid, uint256 votesAgainstFailure, uint256 votesFor, address prizeWinner) external;\r\n}\r\n\r\n\r\ncontract DisputeController {\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint64;\r\n\r\n    PrimaryStorage   masterStorage;\r\n    SecondaryStorage secondStorage;\r\n    RefundPool       refundPool;\r\n    Logger           eventLogger;\r\n\r\n    address private main;\r\n\r\n    constructor(\r\n        address dAppMainContractAddr,\r\n        address storageAddr,\r\n        address secStorageAddr,\r\n        address eventLoggerAddr,\r\n        address payable refundPoolAddr\r\n    )\r\n        public\r\n    {\r\n        masterStorage = PrimaryStorage(storageAddr);\r\n        secondStorage = SecondaryStorage(secStorageAddr);\r\n        refundPool = RefundPool(refundPoolAddr);\r\n        eventLogger = Logger(eventLoggerAddr);\r\n        main = dAppMainContractAddr;\r\n    }\r\n\r\n    modifier onlyMain {\r\n        if(msg.sender == main) {\r\n            _;\r\n        }\r\n        else {\r\n            revert(\"Only main contract is allowed\");\r\n        }\r\n    }\r\n\r\n    function createNewDispute (\r\n        address payable caller,\r\n        uint256 pid,\r\n        bytes calldata publicDisputeUrl\r\n    )\r\n        external\r\n        payable\r\n        onlyMain\r\n        returns (bool)\r\n    {\r\n        uint256 did;\r\n        require(secondStorage.getProjectCurrentState(pid) == 1, \"Vote not allowed in the current project state\");\r\n        bool isInv = masterStorage.isInvestor(caller);\r\n        bool isMod = masterStorage.isPlatformModerator(caller) || masterStorage.isCommunityModerator(caller);\r\n        bool isOwn = masterStorage.isProjectOwner(caller);\r\n        bool isRefundInProgress = secondStorage.getIsRefundInProgress(pid);\r\n        if (!isInv && !isMod && !isOwn) revert(\"Only investors, supporters and moderators can invoke a dispute\");\r\n        if (isInv && isOwn) revert(\"Not allowed for accounts that are both investors and supporters to a project\");\r\n\r\n        uint256 cuf = secondStorage.getOwnerFunds(pid, caller);\r\n        if (isOwn && !isMod && cuf > 1) {\r\n            require(isRefundInProgress, \"Not allowed - not in a refund state\");\r\n            uint256 opc = secondStorage.getOwnerContribution(pid).add(msg.value);\r\n            uint256 poolContributions = secondStorage.getAmountOfFundsContributed(pid);\r\n\r\n            if (opc < poolContributions.mul(5).div(100)) {\r\n                revert(\"The owner funds + the ether sent with this call is less than the dispute lottery prize\");\r\n            } else {\r\n                did = _addDispute(caller, pid, publicDisputeUrl, isRefundInProgress);\r\n                secondStorage.setOwnerContribution(pid, opc);\r\n                secondStorage.setOwnerFunds(pid, caller, cuf.add(msg.value));\r\n                if (msg.value > 0) refundPool.deposit.value(msg.value)(pid);\r\n            }\r\n            return true;\r\n        }\r\n        if (isMod) {\r\n            require(isRefundInProgress, \"The project is not in a refund state set by an internal vote\");\r\n            did = _addDispute(caller, pid, publicDisputeUrl, isRefundInProgress);\r\n            return true;\r\n        }\r\n        if (isInv && !isMod && !isOwn && !secondStorage.getIsDisputed(pid)) {\r\n            require(\r\n                secondStorage.getAlreadyProtected(pid, caller) &&\r\n                secondStorage.getIsInvestorsVoteFailed(pid), \"Not allowed\"\r\n            );\r\n            require(msg.value >= 1 ether, \"Not enough collateral amount\");\r\n            did = _addDispute(caller, pid, publicDisputeUrl, isRefundInProgress);\r\n            masterStorage.setPayment(caller, did, msg.value);\r\n            refundPool.deposit.value(msg.value)(pid);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function addPublicVote(address payable voter, uint256 did, bytes32 hiddenVote)\r\n        external\r\n        payable\r\n        onlyMain\r\n        returns (bool)\r\n    {\r\n        uint256 votingPeriod = masterStorage.getDisputeVotePeriod(did);\r\n        uint256 pid = masterStorage.getDisputeProjectId(did);\r\n        if (masterStorage.isProjectOwner(voter) ||\r\n            masterStorage.isPlatformModerator(voter) ||\r\n            secondStorage.getAlreadyProtected(pid, voter)) {\r\n            revert(\"Not allowed\");\r\n        }\r\n\r\n        if (secondStorage.getProjectCurrentState(pid) != 3 ||\r\n            votingPeriod < block.number ||\r\n            masterStorage.getHiddenVote(did, voter) != bytes32(0)) {\r\n            revert (\"Not allowed\");\r\n        }\r\n\r\n        uint256 validationGasCost;\r\n        address payable modResources = masterStorage.getModerationResources();\r\n\r\n        if (masterStorage.getValidationToken(voter) == 0) {\r\n            validationGasCost = 1100000000000000;\r\n            require(msg.value >= masterStorage.getEntryFee(did).add(validationGasCost), \"Insufficient voting collateral amount\");\r\n            modResources.transfer(validationGasCost);\r\n        } else {\r\n            require(msg.value >= masterStorage.getEntryFee(did), \"Insufficient voting collateral amount\");\r\n        }\r\n\r\n        bytes32 encryptedVote = keccak256(abi.encodePacked(did, voter, hiddenVote));\r\n        masterStorage.addHiddenVote(did, voter, encryptedVote);\r\n        masterStorage.setPayment(voter, did, msg.value.sub(validationGasCost));\r\n        refundPool.deposit.value(msg.value.sub(validationGasCost))(pid);\r\n    }\r\n\r\n    function decryptVote(address voter, uint256 did, bool isProjectFailed, uint64 pin)\r\n        external\r\n        onlyMain\r\n        returns (bool)\r\n    {\r\n        uint256 pid = masterStorage.getDisputeProjectId(did);\r\n        uint256 revealPeriod = masterStorage.getResultCountPeriod(did);\r\n        require(secondStorage.getProjectCurrentState(pid) == 3, \"Not in a dispute\");\r\n        require(block.number > masterStorage.getDisputeVotePeriod(did), \"Voting period is not over\");\r\n        require(masterStorage.getValidationToken(voter) != 0, \"Your account is not verified\");\r\n\r\n        if (revealPeriod < block.number) {\r\n            finalizeDispute(did);\r\n            return false;\r\n        }\r\n\r\n        bytes32 voteHash = keccak256(abi.encodePacked(pin, isProjectFailed));\r\n        bytes32 encryptedVote = keccak256(abi.encodePacked(did, voter, voteHash));\r\n\r\n        if (masterStorage.getHiddenVote(did, voter) != encryptedVote) {\r\n            revert(\"Revealed vote doesn't match with the encrypted one\");\r\n        } else {\r\n            uint256 rpb = uint64(address(refundPool).balance);\r\n            if (isProjectFailed) {\r\n                masterStorage.setNumberOfVotesForRefundState(did);\r\n            } else {\r\n                masterStorage.setNumberOfVotesAgainstRefundState(did);\r\n            }\r\n            if (masterStorage.getRandomNumberBaseLength(did) < 112) {\r\n                masterStorage.addToRandomNumberBase(did, pin ^ rpb);\r\n            }\r\n            masterStorage.addRevealedVote(did, voter, isProjectFailed);\r\n            masterStorage.addDisputeVoter(did, voter);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function finalizeDispute(uint256 did) public onlyMain returns (bool) {\r\n        uint256 pid = masterStorage.getDisputeProjectId(did);\r\n        require(secondStorage.getProjectCurrentState(pid) == 3, \"Not in a dispute\");\r\n        require(block.number > masterStorage.getResultCountPeriod(did), \"Vote counting is not finished\");\r\n        uint256 nov = masterStorage.getDisputeNumberOfVoters(did);\r\n\r\n        if (!_extendDispute(did, pid, nov)) return false;\r\n        uint256 votesAgainstFailure = masterStorage.getNumberOfVotesAgainstRefundState(did);\r\n        uint256 votesForFailure = masterStorage.getNumberOfVotesForRefundState(did);\r\n        bool forcedRefundState = (secondStorage.isRefundStateForced(pid) == 1);\r\n        if (votesAgainstFailure >= votesForFailure ) {\r\n            if (secondStorage.getIsRefundInProgress(pid) && secondStorage.getIsInvestorsVoteFailed(pid) && !forcedRefundState) {\r\n                secondStorage.setProjectCurrentState(pid, 5);\r\n                secondStorage.setRefundStatePeriod(pid, block.number);\r\n            }\r\n            if (secondStorage.getIsInvestorsVoteFailed(pid) && !secondStorage.getIsRefundInProgress(pid)) {\r\n                secondStorage.setFreezeStatePeriod(pid, 1);\r\n                secondStorage.setProjectCurrentState(pid, 1);\r\n                secondStorage.setIsDisputed(pid);\r\n            }\r\n            if (secondStorage.getIsRefundInProgress(pid) && forcedRefundState) {\r\n                secondStorage.setRefundStatePeriod(pid, block.number);\r\n                secondStorage.setProjectCurrentState(pid, 1);\r\n            }\r\n            if (!secondStorage.getIsInvestorsVoteFailed(pid) && !forcedRefundState) {\r\n                secondStorage.setIsInvestorsVoteFailed(pid, true);\r\n                secondStorage.setReturnedRefundTokens(pid, 1);\r\n                secondStorage.setVotesForRefundState(pid, 1);\r\n            }\r\n            if (secondStorage.getIsRefundInProgress(pid)) {\r\n                secondStorage.setIsRefundInProgress(pid, false);\r\n            }\r\n            if (forcedRefundState) {\r\n                secondStorage.setForcedRefundState(pid, 2);\r\n            }\r\n            eventLogger.emitDisputeFinished(did, pid, votesAgainstFailure, votesForFailure, _pickPrizeWinner(did, false, nov));\r\n            return true;\r\n        } else {\r\n            if (!secondStorage.getIsRefundInProgress(pid) &&\r\n                secondStorage.getIsInvestorsVoteFailed(pid) && !forcedRefundState) {\r\n                secondStorage.setIsInvestorsVoteFailed(pid, false);\r\n            }\r\n            if (!secondStorage.getIsRefundInProgress(pid)) {\r\n                secondStorage.setIsRefundInProgress(pid, true);\r\n                secondStorage.setRefundStatePeriod(pid, block.number.add(233894));\r\n            }\r\n\r\n            secondStorage.setFreezeStatePeriod(pid, 1);\r\n            secondStorage.setIsDisputed(pid);\r\n            secondStorage.setProjectCurrentState(pid, 1);\r\n            eventLogger.emitDisputeFinished(did, pid, votesAgainstFailure, votesForFailure, _pickPrizeWinner(did, true, nov));\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function _pickPrizeWinner(\r\n        uint256 did,\r\n        bool disputeConsensus,\r\n        uint256 numberOfVoters\r\n    )\r\n        internal\r\n        returns (address payable)\r\n    {\r\n        uint256 nov = numberOfVoters;\r\n        uint256 ewi = masterStorage.randomNumberGenerator(did).mod(nov);\r\n        address payable ewa = masterStorage.getDisputeVoter(did, ewi);\r\n\r\n        if (masterStorage.getRevealedVote(did, ewa) == disputeConsensus) {\r\n            _setPrizeAmount(did, ewa);\r\n        }\r\n\r\n        if (masterStorage.getRevealedVote(did, ewa) == !disputeConsensus) {\r\n            if (nov > ewi.add(1)) {\r\n                ewi++;\r\n                ewa = masterStorage.getDisputeVoter(did, ewi);\r\n                while (masterStorage.getRevealedVote(did, ewa) == !disputeConsensus && ewi.add(1) < nov) {\r\n                    ewi++;\r\n                    ewa = masterStorage.getDisputeVoter(did, ewi);\r\n                }\r\n                if (masterStorage.getRevealedVote(did, ewa) == !disputeConsensus) {\r\n                    ewi = 0;\r\n\r\n                    while (masterStorage.getRevealedVote(did, ewa) == !disputeConsensus && ewi.add(1) < nov) {\r\n                        ewi++;\r\n                        ewa = masterStorage.getDisputeVoter(did, ewi);\r\n                    }\r\n                    _setPrizeAmount(did, ewa);\r\n                } else {\r\n                    _setPrizeAmount(did, ewa);\r\n                }\r\n            } else {\r\n                ewi = 0;\r\n                while (masterStorage.getRevealedVote(did, ewa) == !disputeConsensus && ewi.add(1) < nov) {\r\n                    ewi++;\r\n                    ewa = masterStorage.getDisputeVoter(did, ewi);\r\n                }\r\n                _setPrizeAmount(did, ewa);\r\n            }\r\n        }\r\n        return ewa;\r\n    }\r\n\r\n    function _addDispute(\r\n        address payable caller,\r\n        uint256 pid,\r\n        bytes memory publicDisputeUrl,\r\n        bool isRefundInProgress\r\n    )\r\n        internal\r\n        returns (uint256 did)\r\n    {\r\n        uint256 fsp = secondStorage.getFreezeStatePeriod(pid);\r\n        require (block.number < fsp, \"Not allowed, not in a freezetime\");\r\n\r\n        did = masterStorage.addDispute();\r\n        masterStorage.setDisputeControllerOfProject(did, secondStorage.getDisputeControllerOfProject(pid));\r\n        masterStorage.addDisputeIds(did, pid);\r\n        masterStorage.setDisputeVotePeriod(did, block.number.add(70169));\r\n        masterStorage.setResultCountPeriod(did, block.number.add(98888));\r\n        masterStorage.setPublicDisputeURL(did, publicDisputeUrl);\r\n\r\n        masterStorage.setNumberOfVotesForRefundState(did);\r\n        masterStorage.setNumberOfVotesAgainstRefundState(did);\r\n\r\n        uint256 poolContributions = secondStorage.getAmountOfFundsContributed(pid);\r\n        uint256 disputePrize = poolContributions.mul(5).div(100);\r\n        masterStorage.setDisputeLotteryPrize(did, disputePrize);\r\n        masterStorage.setEntryFee(did, 24 finney);\r\n\r\n        secondStorage.setFreezeStatePeriod(pid, fsp.add(98888));\r\n        secondStorage.setProjectCurrentState(pid, 3);\r\n        masterStorage.setDisputeCreator(did, caller);\r\n\r\n        if (isRefundInProgress) {\r\n            uint256 rsp = secondStorage.getRefundStatePeriod(pid);\r\n            secondStorage.setRefundStatePeriod(pid,rsp.add(98888));\r\n        }\r\n        eventLogger.emitNewDispute(caller, did, pid, publicDisputeUrl);\r\n        return did;\r\n    }\r\n\r\n    function _setPrizeAmount(uint256 did, address payable prizeWinner) internal {\r\n        uint256 amount = masterStorage.getDisputeLotteryPrize(did);\r\n        masterStorage.setDisputeLotteryPrize(did, 0);\r\n        require(amount > 1, \"Not allowed\");\r\n        masterStorage.setPayment(prizeWinner, did, masterStorage.getPayment(prizeWinner, did).add(amount));\r\n    }\r\n\r\n    function _extendDispute(uint256 did, uint256 pid, uint256 numberOfVotes) internal returns (bool) {\r\n        if (numberOfVotes < 112) {\r\n            _setExtendedTimers(did, pid);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _setExtendedTimers(uint256 did, uint256 pid) internal {\r\n        if (secondStorage.getPolicyEndDate(pid) > block.number) {\r\n            if (secondStorage.getIsRefundInProgress(pid)) {\r\n                secondStorage.setRefundStatePeriod(pid, secondStorage.getRefundStatePeriod(pid).add(98888));\r\n            }\r\n            secondStorage.setFreezeStatePeriod(pid, secondStorage.getFreezeStatePeriod(pid).add(98888));\r\n            masterStorage.setDisputeVotePeriod(did, block.number.add(70169));\r\n            masterStorage.setResultCountPeriod(did, block.number.add(98888));\r\n        } else {\r\n            secondStorage.setProjectCurrentState(pid, 6);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"caller\",\"type\":\"address\"},{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"publicDisputeUrl\",\"type\":\"bytes\"}],\"name\":\"createNewDispute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"did\",\"type\":\"uint256\"}],\"name\":\"finalizeDispute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"voter\",\"type\":\"address\"},{\"name\":\"did\",\"type\":\"uint256\"},{\"name\":\"isProjectFailed\",\"type\":\"bool\"},{\"name\":\"pin\",\"type\":\"uint64\"}],\"name\":\"decryptVote\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"voter\",\"type\":\"address\"},{\"name\":\"did\",\"type\":\"uint256\"},{\"name\":\"hiddenVote\",\"type\":\"bytes32\"}],\"name\":\"addPublicVote\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"dAppMainContractAddr\",\"type\":\"address\"},{\"name\":\"storageAddr\",\"type\":\"address\"},{\"name\":\"secStorageAddr\",\"type\":\"address\"},{\"name\":\"eventLoggerAddr\",\"type\":\"address\"},{\"name\":\"refundPoolAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"DisputeController","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"500000","ConstructorArguments":"0000000000000000000000004f62e6629e4f1cd8b72e7db8ff097f055a6ed4c000000000000000000000000057d504f3ebcc43b8a894a7933676eb17236cc35d000000000000000000000000ac5ae06a85b710c1c68708bb04b80f2d81c00617000000000000000000000000358994ca3f907b689c4177790a2cb424a3d2bcdf000000000000000000000000df4fdbf83329be988491b047140b37bba12bc4c1","Library":"","SwarmSource":"bzzr://708b40f750e47caeb6a762c5285a4d1b50d0238127d99849c07723ee992fe839"}]}