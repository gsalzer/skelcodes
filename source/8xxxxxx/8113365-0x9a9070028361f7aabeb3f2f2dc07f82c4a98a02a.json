{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\n/**\r\n * @title CheckpointOracle\r\n * @author Gary Rong<garyrong@ethereum.org>, Martin Swende <martin.swende@ethereum.org>\r\n * @dev Implementation of the blockchain checkpoint registrar.\r\n */\r\ncontract CheckpointOracle {\r\n    /*\r\n        Events\r\n    */\r\n\r\n    // NewCheckpointVote is emitted when a new checkpoint proposal receives a vote.\r\n    event NewCheckpointVote(uint64 indexed index, bytes32 checkpointHash, uint8 v, bytes32 r, bytes32 s);\r\n\r\n    /*\r\n        Public Functions\r\n    */\r\n    constructor(address[] memory _adminlist, uint _sectionSize, uint _processConfirms, uint _threshold) public {\r\n        for (uint i = 0; i < _adminlist.length; i++) {\r\n            admins[_adminlist[i]] = true;\r\n            adminList.push(_adminlist[i]);\r\n        }\r\n        sectionSize = _sectionSize;\r\n        processConfirms = _processConfirms;\r\n        threshold = _threshold;\r\n    }\r\n\r\n    /**\r\n     * @dev Get latest stable checkpoint information.\r\n     * @return section index\r\n     * @return checkpoint hash\r\n     * @return block height associated with checkpoint\r\n     */\r\n    function GetLatestCheckpoint()\r\n    view\r\n    public\r\n    returns(uint64, bytes32, uint) {\r\n        return (sectionIndex, hash, height);\r\n    }\r\n\r\n    // SetCheckpoint sets  a new checkpoint. It accepts a list of signatures\r\n    // @_recentNumber: a recent blocknumber, for replay protection\r\n    // @_recentHash : the hash of `_recentNumber`\r\n    // @_hash : the hash to set at _sectionIndex\r\n    // @_sectionIndex : the section index to set\r\n    // @v : the list of v-values\r\n    // @r : the list or r-values\r\n    // @s : the list of s-values\r\n    function SetCheckpoint(\r\n        uint _recentNumber,\r\n        bytes32 _recentHash,\r\n        bytes32 _hash,\r\n        uint64 _sectionIndex,\r\n        uint8[] memory v,\r\n        bytes32[] memory r,\r\n        bytes32[] memory s)\r\n        public\r\n        returns (bool)\r\n    {\r\n        // Ensure the sender is authorized.\r\n        require(admins[msg.sender]);\r\n\r\n        // These checks replay protection, so it cannot be replayed on forks,\r\n        // accidentally or intentionally\r\n        require(blockhash(_recentNumber) == _recentHash);\r\n\r\n        // Ensure the batch of signatures are valid.\r\n        require(v.length == r.length);\r\n        require(v.length == s.length);\r\n\r\n        // Filter out \"future\" checkpoint.\r\n        if (block.number < (_sectionIndex+1)*sectionSize+processConfirms) {\r\n            return false;\r\n        }\r\n        // Filter out \"old\" announcement\r\n        if (_sectionIndex < sectionIndex) {\r\n            return false;\r\n        }\r\n        // Filter out \"stale\" announcement\r\n        if (_sectionIndex == sectionIndex && (_sectionIndex != 0 || height != 0)) {\r\n            return false;\r\n        }\r\n        // Filter out \"invalid\" announcement\r\n        if (_hash == \"\"){\r\n            return false;\r\n        }\r\n\r\n        // EIP 191 style signatures\r\n        //\r\n        // Arguments when calculating hash to validate\r\n        // 1: byte(0x19) - the initial 0x19 byte\r\n        // 2: byte(0) - the version byte (data with intended validator)\r\n        // 3: this - the validator address\r\n        // --  Application specific data\r\n        // 4 : checkpoint section_index(uint64)\r\n        // 5 : checkpoint hash (bytes32)\r\n        //     hash = keccak256(checkpoint_index, section_head, cht_root, bloom_root)\r\n        bytes32 signedHash = keccak256(abi.encodePacked(byte(0x19), byte(0), this, _sectionIndex, _hash));\r\n\r\n        address lastVoter = address(0);\r\n\r\n        // In order for us not to have to maintain a mapping of who has already\r\n        // voted, and we don't want to count a vote twice, the signatures must\r\n        // be submitted in strict ordering.\r\n        for (uint idx = 0; idx < v.length; idx++){\r\n            address signer = ecrecover(signedHash, v[idx], r[idx], s[idx]);\r\n            require(admins[signer]);\r\n            require(uint256(signer) > uint256(lastVoter));\r\n            lastVoter = signer;\r\n            emit NewCheckpointVote(_sectionIndex, _hash, v[idx], r[idx], s[idx]);\r\n\r\n            // Sufficient signatures present, update latest checkpoint.\r\n            if (idx+1 >= threshold){\r\n                hash = _hash;\r\n                height = block.number;\r\n                sectionIndex = _sectionIndex;\r\n                return true;\r\n            }\r\n        }\r\n        // We shouldn't wind up here, reverting un-emits the events\r\n        revert();\r\n    }\r\n\r\n    /**\r\n     * @dev Get all admin addresses\r\n     * @return address list\r\n     */\r\n    function GetAllAdmin()\r\n    public\r\n    view\r\n    returns(address[] memory)\r\n    {\r\n        address[] memory ret = new address[](adminList.length);\r\n        for (uint i = 0; i < adminList.length; i++) {\r\n            ret[i] = adminList[i];\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n        Fields\r\n    */\r\n    // A map of admin users who have the permission to update CHT and bloom Trie root\r\n    mapping(address => bool) admins;\r\n\r\n    // A list of admin users so that we can obtain all admin users.\r\n    address[] adminList;\r\n\r\n    // Latest stored section id\r\n    uint64 sectionIndex;\r\n\r\n    // The block height associated with latest registered checkpoint.\r\n    uint height;\r\n\r\n    // The hash of latest registered checkpoint.\r\n    bytes32 hash;\r\n\r\n    // The frequency for creating a checkpoint\r\n    //\r\n    // The default value should be the same as the checkpoint size(32768) in the ethereum.\r\n    uint sectionSize;\r\n\r\n    // The number of confirmations needed before a checkpoint can be registered.\r\n    // We have to make sure the checkpoint registered will not be invalid due to\r\n    // chain reorg.\r\n    //\r\n    // The default value should be the same as the checkpoint process confirmations(256)\r\n    // in the ethereum.\r\n    uint processConfirms;\r\n\r\n    // The required signatures to finalize a stable checkpoint.\r\n    uint threshold;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"GetAllAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetLatestCheckpoint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recentNumber\",\"type\":\"uint256\"},{\"name\":\"_recentHash\",\"type\":\"bytes32\"},{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_sectionIndex\",\"type\":\"uint64\"},{\"name\":\"v\",\"type\":\"uint8[]\"},{\"name\":\"r\",\"type\":\"bytes32[]\"},{\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"SetCheckpoint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_adminlist\",\"type\":\"address[]\"},{\"name\":\"_sectionSize\",\"type\":\"uint256\"},{\"name\":\"_processConfirms\",\"type\":\"uint256\"},{\"name\":\"_threshold\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"index\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"checkpointHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"v\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"r\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"NewCheckpointVote\",\"type\":\"event\"}]","ContractName":"CheckpointOracle","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000050000000000000000000000001b2c260efc720be89101890e4db589b44e95052700000000000000000000000078d1ad571a1a09d60d9bbf25894b44e4c8859595000000000000000000000000286834935f4a8cfb4ff4c77d5770c2775ae2b0e7000000000000000000000000b86e2b0ab5a4b1373e40c51a7c712c70ba2f9f8e000000000000000000000000b86e2b0ab5a4b1373e40c51a7c712c70ba2f9f8e","Library":"","SwarmSource":"bzzr://7f6a191ce575596a2f1e907c8c0a01003d16b69fb2c4f432d10878e8c0a99a02"}]}