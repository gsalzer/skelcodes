{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11; // optimization disabled, evm version: petersburg\r\n\r\n\r\n/**\r\n * @title DharmaKeyRegistryMultisig\r\n * @author 0age (derived from Christian Lundkvist's Simple Multisig)\r\n * @notice This contract is a multisig that will control key registration on the\r\n * Dharma Key Registry, based on Christian Lundkvist's Simple Multisig (found at\r\n * https://github.com/christianlundkvist/simple-multisig). Version 2 of the\r\n * Dharma Key Registry is hard-coded as the only allowable call destination, and\r\n * any changes in ownership or signature threshold will require deploying a new\r\n * multisig and transferring ownership of the registry.\r\n */\r\ncontract DharmaKeyRegistryMultisig {\r\n  // The nonce is the only mutable state, and is incremented on every call.\r\n  uint256 private _nonce;\r\n\r\n  // Maintain a mapping and a convenience array of owners.\r\n  mapping(address => bool) private _isOwner;\r\n  address[] private _owners;\r\n\r\n  // V2 of the Dharma Key Registry is the only account the multisig can call.\r\n  address private constant _DESTINATION = address(\r\n    0x000000000D38df53b45C5733c7b34000dE0BDF52\r\n  );\r\n\r\n  // The threshold is an exact number of valid signatures that must be supplied.\r\n  uint256 private constant _THRESHOLD = 3;\r\n\r\n  // Note: Owners must be strictly increasing in order to prevent duplicates.\r\n  constructor(address[] memory owners) public {\r\n    require(owners.length <= 10, \"Cannot have more than 10 owners.\");\r\n    require(_THRESHOLD <= owners.length, \"Threshold cannot exceed total owners.\");\r\n\r\n    address lastAddress = address(0);\r\n    for (uint256 i = 0; i < owners.length; i++) {\r\n      require(\r\n        owners[i] > lastAddress, \"Owner addresses must be strictly increasing.\"\r\n      );\r\n      _isOwner[owners[i]] = true;\r\n      lastAddress = owners[i];\r\n    }\r\n    _owners = owners;\r\n  }\r\n\r\n  function getNextHash(\r\n    bytes calldata data,\r\n    address executor,\r\n    uint256 gasLimit\r\n  ) external view returns (bytes32 hash) {\r\n    hash = _getHash(data, executor, gasLimit, _nonce);\r\n  }\r\n\r\n  function getHash(\r\n    bytes calldata data,\r\n    address executor,\r\n    uint256 gasLimit,\r\n    uint256 nonce\r\n  ) external view returns (bytes32 hash) {\r\n    hash = _getHash(data, executor, gasLimit, nonce);\r\n  }\r\n\r\n  function getNonce() external view returns (uint256 nonce) {\r\n    nonce = _nonce;\r\n  }\r\n\r\n  function getOwners() external view returns (address[] memory owners) {\r\n    owners = _owners;\r\n  }\r\n\r\n  function isOwner(address account) external view returns (bool owner) {\r\n    owner = _isOwner[account];\r\n  }\r\n\r\n  function getThreshold() external pure returns (uint256 threshold) {\r\n    threshold = _THRESHOLD;\r\n  }\r\n\r\n  function getDestination() external pure returns (address destination) {\r\n    destination = _DESTINATION;\r\n  }\r\n\r\n  // Note: addresses recovered from signatures must be strictly increasing.\r\n  function execute(\r\n    bytes calldata data,\r\n    address executor,\r\n    uint256 gasLimit,\r\n    bytes calldata signatures\r\n  ) external returns (bool success, bytes memory returnData) {\r\n    require(\r\n      executor == msg.sender || executor == address(0),\r\n      \"Must call from the executor account if one is specified.\"\r\n    );\r\n\r\n    // Derive the message hash and wrap in the eth signed messsage hash.\r\n    bytes32 hash = _toEthSignedMessageHash(\r\n      _getHash(data, executor, gasLimit, _nonce)\r\n    );\r\n\r\n    // Recover each signer from the provided signatures.\r\n    address[] memory signers = _recoverGroup(hash, signatures);\r\n\r\n    require(signers.length == _THRESHOLD, \"Total signers must equal threshold.\");\r\n\r\n    // Verify that each signatory is an owner and is strictly increasing.\r\n    address lastAddress = address(0); // cannot have address(0) as an owner\r\n    for (uint256 i = 0; i < signers.length; i++) {\r\n      require(\r\n        _isOwner[signers[i]], \"Signature does not correspond to an owner.\"\r\n      );\r\n      require(\r\n        signers[i] > lastAddress, \"Signer addresses must be strictly increasing.\"\r\n      );\r\n      lastAddress = signers[i];\r\n    }\r\n\r\n    // Increment the nonce and execute the transaction.\r\n    _nonce++;\r\n    (success, returnData) = _DESTINATION.call.gas(gasLimit)(data);\r\n  }\r\n\r\n  function _getHash(\r\n    bytes memory data,\r\n    address executor,\r\n    uint256 gasLimit,\r\n    uint256 nonce\r\n  ) internal view returns (bytes32 hash) {\r\n    // Note: this is the data used to create a personal signed message hash.\r\n    hash = keccak256(\r\n      abi.encodePacked(address(this), nonce, executor, gasLimit, data)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns each address that signed a hashed message (`hash`) from a\r\n   * collection of `signatures`.\r\n   *\r\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n   * this function rejects them by requiring the `s` value to be in the lower\r\n   * half order, and the `v` value to be either 27 or 28.\r\n   *\r\n   * NOTE: This call _does not revert_ if a signature is invalid, or if the\r\n   * signer is otherwise unable to be retrieved. In those scenarios, the zero\r\n   * address is returned for that signature.\r\n   *\r\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n   * verification to be secure: it is possible to craft signatures that recover\r\n   * to arbitrary addresses for non-hashed data.\r\n   */\r\n  function _recoverGroup(\r\n    bytes32 hash,\r\n    bytes memory signatures\r\n  ) internal pure returns (address[] memory signers) {\r\n    // Ensure that the signatures length is a multiple of 65.\r\n    if (signatures.length % 65 != 0) {\r\n      return new address[](0);\r\n    }\r\n\r\n    // Create an appropriately-sized array of addresses for each signer.\r\n    signers = new address[](signatures.length / 65);\r\n\r\n    // Get each signature location and divide into r, s and v variables.\r\n    bytes32 signatureLocation;\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    for (uint256 i = 0; i < signers.length; i++) {\r\n      assembly {\r\n        signatureLocation := add(signatures, mul(i, 65))\r\n        r := mload(add(signatureLocation, 32))\r\n        s := mload(add(signatureLocation, 64))\r\n        v := byte(0, mload(add(signatureLocation, 96)))\r\n      }\r\n\r\n      // EIP-2 still allows signature malleability for ecrecover(). Remove\r\n      // this possibility and make the signature unique.\r\n      if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n        continue;\r\n      }\r\n\r\n      if (v != 27 && v != 28) {\r\n        continue;\r\n      }\r\n\r\n      // If signature is valid & not malleable, add signer address.\r\n      signers[i] = ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n  function _toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"getHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDestination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"owner\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"getNextHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"DharmaKeyRegistryMultisig","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000050000000000000000000000000562193523c9467474dc310519dbcf6247eb49ed0000000000000000000000000fd7818f9a405cce0c4f686523b19e77a48f4c0b0000000000000000000000003ae4a263c095c4a7ec9bfc35addc18678c1a3b4100000000000000000000000074bf7e4a74cfa8a71faa32f4c0fb4aa045c0f799000000000000000000000000d581bc6c532c0ef0df98c95e95a9081dd65535af","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://8eff12138b6ebc14214452f35d7801acb0b89b7c6ae608b93bf6e0866845bae6"}]}