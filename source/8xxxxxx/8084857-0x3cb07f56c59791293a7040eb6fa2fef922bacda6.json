{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20.sol\":{\"content\":\"/**\\r\\n * Source Code first verified at https://etherscan.io on Wednesday, March 13, 2019\\r\\n (UTC) */\\r\\n\\r\\npragma solidity 0.5.7;\\r\\n\\r\\ncontract ERC20 {\\r\\n  function totalSupply()public view returns (uint256 total_Supply);\\r\\n  function balanceOf(address who)public view returns (uint256);\\r\\n  function allowance(address owner, address spender)public view returns (uint256);\\r\\n  function transferFrom(address from, address to, uint256 value)public returns (bool ok);\\r\\n  function approve(address spender, uint256 value)public returns (bool ok);\\r\\n  function transfer(address to, uint256 value)public returns (bool ok);\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"OHiWE.sol\":{\"content\":\"/**\\r\\n * Source Code first verified at https://etherscan.io on Wednesday, March 13, 2019\\r\\n (UTC) */\\r\\n\\r\\npragma solidity 0.5.7;\\r\\n\\r\\nimport \\\"./ERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract OHiWE is ERC20 { \\r\\n    using SafeMath for uint256;\\r\\n    //--- Token configurations ----// \\r\\n    string private constant _name = \\\"OHiWE\\\";\\r\\n    string private constant _symbol = \\\"OHC\\\";\\r\\n    uint8 private constant _decimals = 18;\\r\\n    uint256 private constant _maxCap = 3300000000 ether;\\r\\n    \\r\\n    //--- Token allocations -------//\\r\\n    uint256 private _totalsupply;\\r\\n\\r\\n    //--- Address -----------------//\\r\\n    address private _owner;\\r\\n    address payable private _ethFundMain;\\r\\n    \\r\\n    //--- Variables ---------------//\\r\\n    bool private _lockToken = false;\\r\\n    \\r\\n    mapping(address =\\u003e uint256) private balances;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private allowed;\\r\\n    mapping(address =\\u003e bool) private locked;\\r\\n    \\r\\n    event Mint(address indexed from, address indexed to, uint256 amount);\\r\\n    event Burn(address indexed from, uint256 amount);\\r\\n    event ChangeReceiveWallet(address indexed newAddress);\\r\\n    event ChangeOwnerShip(address indexed newOwner);\\r\\n    event ChangeLockStatusFrom(address indexed investor, bool locked);\\r\\n    event ChangeTokenLockStatus(bool locked);\\r\\n    event ChangeAllowICOStatus(bool allow);\\r\\n    \\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == _owner, \\\"Only owner is allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    modifier onlyUnlockToken() {\\r\\n        require(!_lockToken, \\\"Token locked\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor() public\\r\\n    {\\r\\n        _owner = msg.sender;\\r\\n    }\\r\\n    \\r\\n    function name() public pure returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n    \\r\\n    function symbol() public pure returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n    \\r\\n    function decimals() public pure returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n    \\r\\n    function maxCap() public pure returns (uint256) {\\r\\n        return _maxCap;\\r\\n    }\\r\\n    \\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    function ethFundMain() public view returns (address) {\\r\\n        return _ethFundMain;\\r\\n    }\\r\\n   \\r\\n    function lockToken() public view returns (bool) {\\r\\n        return _lockToken;\\r\\n    }\\r\\n   \\r\\n    function lockStatusOf(address investor) public view returns (bool) {\\r\\n        return locked[investor];\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalsupply;\\r\\n    }\\r\\n    \\r\\n    function balanceOf(address investor) public view returns (uint256) {\\r\\n        return balances[investor];\\r\\n    }\\r\\n    \\r\\n    function approve(address _spender, uint256 _amount) public onlyUnlockToken returns (bool)  {\\r\\n        require( _spender != address(0), \\\"Address can not be 0x0\\\");\\r\\n        require(balances[msg.sender] \\u003e _amount, \\\"Balance does not have enough tokens\\\");\\r\\n        require(!locked[msg.sender], \\\"Sender address is locked\\\");\\r\\n        allowed[msg.sender][_spender] = _amount;\\r\\n        emit Approval(msg.sender, _spender, _amount);\\r\\n        return true;\\r\\n    }\\r\\n  \\r\\n    function allowance(address _from, address _spender) public view returns (uint256) {\\r\\n        return allowed[_from][_spender];\\r\\n    }\\r\\n\\r\\n    function transfer(address _to, uint256 _amount) public onlyUnlockToken returns (bool) {\\r\\n        require( _to != address(0), \\\"Receiver can not be 0x0\\\");\\r\\n        require(balances[msg.sender] \\u003e _amount, \\\"Balance does not have enough tokens\\\");\\r\\n        require(!locked[msg.sender], \\\"Sender address is locked\\\");\\r\\n        balances[msg.sender] = (balances[msg.sender]).sub(_amount);\\r\\n        balances[_to] = (balances[_to]).add(_amount);\\r\\n        emit Transfer(msg.sender, _to, _amount);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function transferFrom( address _from, address _to, uint256 _amount ) public onlyUnlockToken returns (bool)  {\\r\\n        require( _to != address(0), \\\"Receiver can not be 0x0\\\");\\r\\n        require(balances[_from] \\u003e _amount, \\\"Source\\u0027s balance is not enough\\\");\\r\\n        require(allowed[_from][msg.sender] \\u003e _amount, \\\"Allowance is not enough\\\");\\r\\n        require(!locked[_from], \\\"From address is locked\\\");\\r\\n        balances[_from] = (balances[_from]).sub(_amount);\\r\\n        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\\r\\n        balances[_to] = (balances[_to]).add(_amount);\\r\\n        emit Transfer(_from, _to, _amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function burn(uint256 _value) public onlyOwner returns (bool) {\\r\\n        require(balances[msg.sender] \\u003e _value, \\\"Balance does not have enough tokens\\\");   \\r\\n        balances[msg.sender] = (balances[msg.sender]).sub(_value);            \\r\\n        _totalsupply = _totalsupply.sub(_value);                     \\r\\n        emit Burn(msg.sender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function stopTransferToken() external onlyOwner {\\r\\n        _lockToken = true;\\r\\n        emit ChangeTokenLockStatus(true);\\r\\n    }\\r\\n\\r\\n    function startTransferToken() external onlyOwner {\\r\\n        _lockToken = false;\\r\\n        emit ChangeTokenLockStatus(false);\\r\\n    }\\r\\n\\r\\n    function () external payable {\\r\\n\\r\\n    }\\r\\n\\r\\n    function manualMint(address receiver, uint256 _value) public onlyOwner{\\r\\n        mint(_owner, receiver, _value);\\r\\n    }\\r\\n\\r\\n    function mint(address from, address receiver, uint256 value) internal {\\r\\n        require(receiver != address(0), \\\"Address can not be 0x0\\\");\\r\\n        require(value \\u003e 0, \\\"Value should larger than 0\\\");\\r\\n        balances[receiver] = balances[receiver].add(value);\\r\\n        _totalsupply = _totalsupply.add(value);\\r\\n        require(_totalsupply \\u003c= _maxCap, \\\"CrowdSale hit max cap\\\");\\r\\n        emit Mint(from, receiver, value);\\r\\n        emit Transfer(address(0), receiver, value);\\r\\n    }\\r\\n \\r\\n\\tfunction assignOwnership(address newOwner) external onlyOwner {\\r\\n\\t    require(newOwner != address(0), \\\"Address can not be 0x0\\\");\\r\\n\\t    _owner = newOwner;\\r\\n\\t    emit ChangeOwnerShip(newOwner);\\r\\n\\t}\\r\\n\\r\\n    function changeReceiveWallet(address payable newAddress) external onlyOwner {\\r\\n        require(newAddress != address(0), \\\"Address can not be 0x0\\\");\\r\\n        _ethFundMain = newAddress;\\r\\n        emit ChangeReceiveWallet(newAddress);\\r\\n    }\\r\\n\\r\\n    function forwardFunds() external onlyOwner {\\r\\n        require(_ethFundMain != address(0));\\r\\n        _ethFundMain.transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function haltTokenTransferFromAddress(address investor) external onlyOwner {\\r\\n        locked[investor] = true;\\r\\n        emit ChangeLockStatusFrom(investor, true);\\r\\n    }\\r\\n\\r\\n    function resumeTokenTransferFromAddress(address investor) external onlyOwner {\\r\\n        locked[investor] = false;\\r\\n        emit ChangeLockStatusFrom(investor, false);\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity \\u003e= 0.5.7;\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Unsigned math operations with safety checks that revert on error.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds two unsigned integers, reverts on overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\r\\n     * reverts when dividing by zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"lockStatusOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"haltTokenTransferFromAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFundMain\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startTransferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"resumeTokenTransferFromAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"forwardFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeReceiveWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopTransferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"assignOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"manualMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"ChangeReceiveWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ChangeOwnerShip\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"locked\",\"type\":\"bool\"}],\"name\":\"ChangeLockStatusFrom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"locked\",\"type\":\"bool\"}],\"name\":\"ChangeTokenLockStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"allow\",\"type\":\"bool\"}],\"name\":\"ChangeAllowICOStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"OHiWE","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1e44dc1987738721af1ec2bf83ff22e12b0892e62602f897904e2909252287a1"}]}