{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\n\n/**\n * @title Interface that every module contract should implement\n */\ninterface IModule {\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() external pure returns(bytes4 initFunction);\n\n    /**\n     * @notice Return the permission flags that are associated with a module\n     */\n    function getPermissions() external view returns(bytes32[] memory permissions);\n\n}\n\n/**\n * @title Utility contract to allow pausing and unpausing of certain functions\n */\ncontract Pausable {\n    event Pause(address account);\n    event Unpause(address account);\n\n    bool public paused = false;\n\n    /**\n    * @notice Modifier to make a function callable only when the contract is not paused.\n    */\n    modifier whenNotPaused() {\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n\n    /**\n    * @notice Modifier to make a function callable only when the contract is paused.\n    */\n    modifier whenPaused() {\n        require(paused, \"Contract is not paused\");\n        _;\n    }\n\n    /**\n    * @notice Called by the owner to pause, triggers stopped state\n    */\n    function _pause() internal whenNotPaused {\n        paused = true;\n        /*solium-disable-next-line security/no-block-members*/\n        emit Pause(msg.sender);\n    }\n\n    /**\n    * @notice Called by the owner to unpause, returns to normal state\n    */\n    function _unpause() internal whenPaused {\n        paused = false;\n        /*solium-disable-next-line security/no-block-members*/\n        emit Unpause(msg.sender);\n    }\n\n}\n\n/**\n * @title Interface that every module factory contract should implement\n */\ninterface IModuleFactory {\n    event ChangeSetupCost(uint256 _oldSetupCost, uint256 _newSetupCost);\n    event ChangeCostType(bool _isOldCostInPoly, bool _isNewCostInPoly);\n    event GenerateModuleFromFactory(\n        address _module,\n        bytes32 indexed _moduleName,\n        address indexed _moduleFactory,\n        address _creator,\n        uint256 _setupCost,\n        uint256 _setupCostInPoly\n    );\n    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);\n\n    //Should create an instance of the Module, or throw\n    function deploy(bytes calldata _data) external returns(address moduleAddress);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function version() external view returns(string memory moduleVersion);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function name() external view returns(bytes32 moduleName);\n\n    /**\n     * @notice Returns the title associated with the module\n     */\n    function title() external view returns(string memory moduleTitle);\n\n    /**\n     * @notice Returns the description associated with the module\n     */\n    function description() external view returns(string memory moduleDescription);\n\n    /**\n     * @notice Get the setup cost of the module in USD\n     */\n    function setupCost() external returns(uint256 usdSetupCost);\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external view returns(uint8[] memory moduleTypes);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external view returns(bytes32[] memory moduleTags);\n\n    /**\n     * @notice Used to change the setup fee\n     * @param _newSetupCost New setup fee\n     */\n    function changeSetupCost(uint256 _newSetupCost) external;\n\n    /**\n     * @notice Used to change the currency and amount setup cost\n     * @param _setupCost new setup cost\n     * @param _isCostInPoly new setup cost currency. USD or POLY\n     */\n    function changeCostAndType(uint256 _setupCost, bool _isCostInPoly) external;\n\n    /**\n     * @notice Function use to change the lower and upper bound of the compatible version st\n     * @param _boundType Type of bound\n     * @param _newVersion New version array\n     */\n    function changeSTVersionBounds(string calldata _boundType, uint8[] calldata _newVersion) external;\n\n    /**\n     * @notice Get the setup cost of the module\n     */\n    function setupCostInPoly() external returns (uint256 polySetupCost);\n\n    /**\n     * @notice Used to get the lower bound\n     * @return Lower bound\n     */\n    function getLowerSTVersionBounds() external view returns(uint8[] memory lowerBounds);\n\n    /**\n     * @notice Used to get the upper bound\n     * @return Upper bound\n     */\n    function getUpperSTVersionBounds() external view returns(uint8[] memory upperBounds);\n\n    /**\n     * @notice Updates the tags of the ModuleFactory\n     * @param _tagsData New list of tags\n     */\n    function changeTags(bytes32[] calldata _tagsData) external;\n\n    /**\n     * @notice Updates the name of the ModuleFactory\n     * @param _name New name that will replace the old one.\n     */\n    function changeName(bytes32 _name) external;\n\n    /**\n     * @notice Updates the description of the ModuleFactory\n     * @param _description New description that will replace the old one.\n     */\n    function changeDescription(string calldata _description) external;\n\n    /**\n     * @notice Updates the title of the ModuleFactory\n     * @param _title New Title that will replace the old one.\n     */\n    function changeTitle(string calldata _title) external;\n\n}\n\ninterface IDataStore {\n    /**\n     * @dev Changes security token atatched to this data store\n     * @param _securityToken address of the security token\n     */\n    function setSecurityToken(address _securityToken) external;\n\n    /**\n     * @dev Stores a uint256 data against a key\n     * @param _key Unique key to identify the data\n     * @param _data Data to be stored against the key\n     */\n    function setUint256(bytes32 _key, uint256 _data) external;\n\n    function setBytes32(bytes32 _key, bytes32 _data) external;\n\n    function setAddress(bytes32 _key, address _data) external;\n\n    function setString(bytes32 _key, string calldata _data) external;\n\n    function setBytes(bytes32 _key, bytes calldata _data) external;\n\n    function setBool(bytes32 _key, bool _data) external;\n\n    /**\n     * @dev Stores a uint256 array against a key\n     * @param _key Unique key to identify the array\n     * @param _data Array to be stored against the key\n     */\n    function setUint256Array(bytes32 _key, uint256[] calldata _data) external;\n\n    function setBytes32Array(bytes32 _key, bytes32[] calldata _data) external ;\n\n    function setAddressArray(bytes32 _key, address[] calldata _data) external;\n\n    function setBoolArray(bytes32 _key, bool[] calldata _data) external;\n\n    /**\n     * @dev Inserts a uint256 element to the array identified by the key\n     * @param _key Unique key to identify the array\n     * @param _data Element to push into the array\n     */\n    function insertUint256(bytes32 _key, uint256 _data) external;\n\n    function insertBytes32(bytes32 _key, bytes32 _data) external;\n\n    function insertAddress(bytes32 _key, address _data) external;\n\n    function insertBool(bytes32 _key, bool _data) external;\n\n    /**\n     * @dev Deletes an element from the array identified by the key.\n     * When an element is deleted from an Array, last element of that array is moved to the index of deleted element.\n     * @param _key Unique key to identify the array\n     * @param _index Index of the element to delete\n     */\n    function deleteUint256(bytes32 _key, uint256 _index) external;\n\n    function deleteBytes32(bytes32 _key, uint256 _index) external;\n\n    function deleteAddress(bytes32 _key, uint256 _index) external;\n\n    function deleteBool(bytes32 _key, uint256 _index) external;\n\n    /**\n     * @dev Stores multiple uint256 data against respective keys\n     * @param _keys Array of keys to identify the data\n     * @param _data Array of data to be stored against the respective keys\n     */\n    function setUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\n\n    function setBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\n\n    function setAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\n\n    function setBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\n\n    /**\n     * @dev Inserts multiple uint256 elements to the array identified by the respective keys\n     * @param _keys Array of keys to identify the data\n     * @param _data Array of data to be inserted in arrays of the respective keys\n     */\n    function insertUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\n\n    function insertBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\n\n    function insertAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\n\n    function insertBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\n\n    function getUint256(bytes32 _key) external view returns(uint256);\n\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    function getAddress(bytes32 _key) external view returns(address);\n\n    function getString(bytes32 _key) external view returns(string memory);\n\n    function getBytes(bytes32 _key) external view returns(bytes memory);\n\n    function getBool(bytes32 _key) external view returns(bool);\n\n    function getUint256Array(bytes32 _key) external view returns(uint256[] memory);\n\n    function getBytes32Array(bytes32 _key) external view returns(bytes32[] memory);\n\n    function getAddressArray(bytes32 _key) external view returns(address[] memory);\n\n    function getBoolArray(bytes32 _key) external view returns(bool[] memory);\n\n    function getUint256ArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getBytes32ArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getAddressArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getBoolArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getUint256ArrayElement(bytes32 _key, uint256 _index) external view returns(uint256);\n\n    function getBytes32ArrayElement(bytes32 _key, uint256 _index) external view returns(bytes32);\n\n    function getAddressArrayElement(bytes32 _key, uint256 _index) external view returns(address);\n\n    function getBoolArrayElement(bytes32 _key, uint256 _index) external view returns(bool);\n\n    function getUint256ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(uint256[] memory);\n\n    function getBytes32ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bytes32[] memory);\n\n    function getAddressArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(address[] memory);\n\n    function getBoolArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bool[] memory);\n}\n\n/**\n * @title Interface for all security tokens\n */\ninterface ISecurityToken {\n    // Standard ERC20 interface\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function decimals() external view returns(uint8);\n    function totalSupply() external view returns(uint256);\n    function balanceOf(address owner) external view returns(uint256);\n    function allowance(address owner, address spender) external view returns(uint256);\n    function transfer(address to, uint256 value) external returns(bool);\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\n    function approve(address spender, uint256 value) external returns(bool);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     * @return byte Ethereum status code (ESC)\n     * @return bytes32 Application specific reason code\n     */\n    function canTransfer(address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\n\n    // Emit at the time when module get added\n    event ModuleAdded(\n        uint8[] _types,\n        bytes32 indexed _name,\n        address indexed _moduleFactory,\n        address _module,\n        uint256 _moduleCost,\n        uint256 _budget,\n        bytes32 _label,\n        bool _archived\n    );\n\n    // Emit when the token details get updated\n    event UpdateTokenDetails(string _oldDetails, string _newDetails);\n    // Emit when the token name get updated\n    event UpdateTokenName(string _oldName, string _newName);\n    // Emit when the granularity get changed\n    event GranularityChanged(uint256 _oldGranularity, uint256 _newGranularity);\n    // Emit when is permanently frozen by the issuer\n    event FreezeIssuance();\n    // Emit when transfers are frozen or unfrozen\n    event FreezeTransfers(bool _status);\n    // Emit when new checkpoint created\n    event CheckpointCreated(uint256 indexed _checkpointId, uint256 _investorLength);\n    // Events to log controller actions\n    event SetController(address indexed _oldController, address indexed _newController);\n    //Event emit when the global treasury wallet address get changed\n    event TreasuryWalletChanged(address _oldTreasuryWallet, address _newTreasuryWallet);\n    event DisableController();\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event TokenUpgraded(uint8 _major, uint8 _minor, uint8 _patch);\n\n    // Emit when Module get archived from the securityToken\n    event ModuleArchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when Module get unarchived from the securityToken\n    event ModuleUnarchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when Module get removed from the securityToken\n    event ModuleRemoved(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when the budget allocated to a module is changed\n    event ModuleBudgetChanged(uint8[] _moduleTypes, address _module, uint256 _oldBudget, uint256 _budget); //Event emitted by the tokenLib.\n\n    // Transfer Events\n    event TransferByPartition(\n        bytes32 indexed _fromPartition,\n        address _operator,\n        address indexed _from,\n        address indexed _to,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    // Operator Events\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n\n    // Issuance / Redemption Events\n    event IssuedByPartition(bytes32 indexed partition, address indexed to, uint256 value, bytes data);\n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\n\n    // Document Events\n    event DocumentRemoved(bytes32 indexed _name, string _uri, bytes32 _documentHash);\n    event DocumentUpdated(bytes32 indexed _name, string _uri, bytes32 _documentHash);\n\n    // Controller Events\n    event ControllerTransfer(\n        address _controller,\n        address indexed _from,\n        address indexed _to,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    event ControllerRedemption(\n        address _controller,\n        address indexed _tokenHolder,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    // Issuance / Redemption Events\n    event Issued(address indexed _operator, address indexed _to, uint256 _value, bytes _data);\n    event Redeemed(address indexed _operator, address indexed _from, uint256 _value, bytes _data);\n\n    /**\n     * @notice Initialization function\n     * @dev Expected to be called atomically with the proxy being created, by the owner of the token\n     * @dev Can only be called once\n     */\n    function initialize(address _getterDelegate) external;\n\n    /**\n     * @notice The standard provides an on-chain function to determine whether a transfer will succeed,\n     * and return details indicating the reason if the transfer is not valid.\n     * @param _from The address from whom the tokens get transferred.\n     * @param _to The address to which to transfer tokens to.\n     * @param _partition The partition from which to transfer tokens\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @return ESC (Ethereum Status Code) following the EIP-1066 standard\n     * @return Application specific reason codes with additional details\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function canTransferByPartition(\n        address _from,\n        address _to,\n        bytes32 _partition,\n        uint256 _value,\n        bytes calldata _data\n    )\n        external\n        view\n        returns (byte statusCode, bytes32 reasonCode, bytes32 partition);\n\n    /**\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     * @return byte Ethereum status code (ESC)\n     * @return bytes32 Application specific reason code\n     */\n    function canTransferFrom(address _from, address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\n\n    /**\n     * @notice Used to attach a new document to the contract, or update the URI or hash of an existing attached document\n     * @dev Can only be executed by the owner of the contract.\n     * @param _name Name of the document. It should be unique always\n     * @param _uri Off-chain uri of the document from where it is accessible to investors/advisors to read.\n     * @param _documentHash hash (of the contents) of the document.\n     */\n    function setDocument(bytes32 _name, string calldata _uri, bytes32 _documentHash) external;\n\n    /**\n     * @notice Used to remove an existing document from the contract by giving the name of the document.\n     * @dev Can only be executed by the owner of the contract.\n     * @param _name Name of the document. It should be unique always\n     */\n    function removeDocument(bytes32 _name) external;\n\n    /**\n     * @notice Used to return the details of a document with a known name (`bytes32`).\n     * @param _name Name of the document\n     * @return string The URI associated with the document.\n     * @return bytes32 The hash (of the contents) of the document.\n     * @return uint256 the timestamp at which the document was last modified.\n     */\n    function getDocument(bytes32 _name) external view returns (string memory documentUri, bytes32 documentHash, uint256 documentTime);\n\n    /**\n     * @notice Used to retrieve a full list of documents attached to the smart contract.\n     * @return bytes32 List of all documents names present in the contract.\n     */\n    function getAllDocuments() external view returns (bytes32[] memory documentNames);\n\n    /**\n     * @notice In order to provide transparency over whether `controllerTransfer` / `controllerRedeem` are useable\n     * or not `isControllable` function will be used.\n     * @dev If `isControllable` returns `false` then it always return `false` and\n     * `controllerTransfer` / `controllerRedeem` will always revert.\n     * @return bool `true` when controller address is non-zero otherwise return `false`.\n     */\n    function isControllable() external view returns (bool controlled);\n\n    /**\n     * @notice Checks if an address is a module of certain type\n     * @param _module Address to check\n     * @param _type type to check against\n     */\n    function isModule(address _module, uint8 _type) external view returns(bool isValid);\n\n    /**\n     * @notice This function must be called to increase the total supply (Corresponds to mint function of ERC20).\n     * @dev It only be called by the token issuer or the operator defined by the issuer. ERC1594 doesn't have\n     * have the any logic related to operator but its superset ERC1400 have the operator logic and this function\n     * is allowed to call by the operator.\n     * @param _tokenHolder The account that will receive the created tokens (account should be whitelisted or KYCed).\n     * @param _value The amount of tokens need to be issued\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     */\n    function issue(address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice issue new tokens and assigns them to the target _tokenHolder.\n     * @dev Can only be called by the issuer or STO attached to the token.\n     * @param _tokenHolders A list of addresses to whom the minted tokens will be dilivered\n     * @param _values A list of number of tokens get minted and transfer to corresponding address of the investor from _tokenHolders[] list\n     * @return success\n     */\n    function issueMulti(address[] calldata _tokenHolders, uint256[] calldata _values) external;\n\n    /**\n     * @notice Increases totalSupply and the corresponding amount of the specified owners partition\n     * @param _partition The partition to allocate the increase in balance\n     * @param _tokenHolder The token holder whose balance should be increased\n     * @param _value The amount by which to increase the balance\n     * @param _data Additional data attached to the minting of tokens\n     */\n    function issueByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of msg.sender\n     * @param _partition The partition to allocate the decrease in balance\n     * @param _value The amount by which to decrease the balance\n     * @param _data Additional data attached to the burning of tokens\n     */\n    function redeemByPartition(bytes32 _partition, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\n     * are out of the scope of the ERC1594.\n     * @param _value The amount of tokens need to be redeemed\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\n     */\n    function redeem(uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\n     * are out of the scope of the ERC1594.\n     * @dev It is analogy to `transferFrom`\n     * @param _tokenHolder The account whose tokens gets redeemed.\n     * @param _value The amount of tokens need to be redeemed\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\n     */\n    function redeemFrom(address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of tokenHolder\n     * @dev This function can only be called by the authorised operator.\n     * @param _partition The partition to allocate the decrease in balance.\n     * @param _tokenHolder The token holder whose balance should be decreased\n     * @param _value The amount by which to decrease the balance\n     * @param _data Additional data attached to the burning of tokens\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\n     */\n    function operatorRedeemByPartition(\n        bytes32 _partition,\n        address _tokenHolder,\n        uint256 _value,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    ) external;\n\n    /**\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n     * @param _delegate address of delegate\n     * @param _module address of PermissionManager module\n     * @param _perm the permissions\n     * @return success\n     */\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPermission);\n\n    /**\n     * @notice Returns module list for a module type\n     * @param _module Address of the module\n     * @return bytes32 Name\n     * @return address Module address\n     * @return address Module factory address\n     * @return bool Module archived\n     * @return uint8 Array of module types\n     * @return bytes32 Module label\n     */\n    function getModule(address _module) external view returns (bytes32 moduleName, address moduleAddress, address factoryAddress, bool isArchived, uint8[] memory moduleTypes, bytes32 moduleLabel);\n\n    /**\n     * @notice Returns module list for a module name\n     * @param _name Name of the module\n     * @return address[] List of modules with this name\n     */\n    function getModulesByName(bytes32 _name) external view returns(address[] memory modules);\n\n    /**\n     * @notice Returns module list for a module type\n     * @param _type Type of the module\n     * @return address[] List of modules with this type\n     */\n    function getModulesByType(uint8 _type) external view returns(address[] memory modules);\n\n    /**\n     * @notice use to return the global treasury wallet\n     */\n    function getTreasuryWallet() external view returns(address treasuryWallet);\n\n    /**\n     * @notice Queries totalSupply at a specified checkpoint\n     * @param _checkpointId Checkpoint ID to query as of\n     */\n    function totalSupplyAt(uint256 _checkpointId) external view returns(uint256 supply);\n\n    /**\n     * @notice Queries balance at a specified checkpoint\n     * @param _investor Investor to query balance for\n     * @param _checkpointId Checkpoint ID to query as of\n     */\n    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns(uint256 balance);\n\n    /**\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\n     */\n    function createCheckpoint() external returns(uint256 checkpointId);\n\n    /**\n     * @notice Gets list of times that checkpoints were created\n     * @return List of checkpoint times\n     */\n    function getCheckpointTimes() external view returns(uint256[] memory checkpointTimes);\n\n    /**\n     * @notice returns an array of investors\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\n     * @return list of addresses\n     */\n    function getInvestors() external view returns(address[] memory investors);\n\n    /**\n     * @notice returns an array of investors at a given checkpoint\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\n     * @return list of investors\n     */\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[] memory investors);\n\n    /**\n     * @notice returns an array of investors with non zero balance at a given checkpoint\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\n     * @param _start Position of investor to start iteration from\n     * @param _end Position of investor to stop iteration at\n     * @return list of investors\n     */\n    function getInvestorsSubsetAt(uint256 _checkpointId, uint256 _start, uint256 _end) external view returns(address[] memory investors);\n\n    /**\n     * @notice generates subset of investors\n     * NB - can be used in batches if investor list is large\n     * @param _start Position of investor to start iteration from\n     * @param _end Position of investor to stop iteration at\n     * @return list of investors\n     */\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[] memory investors);\n\n    /**\n     * @notice Gets current checkpoint ID\n     * @return Id\n     */\n    function currentCheckpointId() external view returns(uint256 checkpointId);\n\n    /**\n     * @notice Determines whether `_operator` is an operator for all partitions of `_tokenHolder`\n     * @param _operator The operator to check\n     * @param _tokenHolder The token holder to check\n     * @return Whether the `_operator` is an operator for all partitions of `_tokenHolder`\n     */\n    function isOperator(address _operator, address _tokenHolder) external view returns (bool isValid);\n\n    /**\n     * @notice Determines whether `_operator` is an operator for a specified partition of `_tokenHolder`\n     * @param _partition The partition to check\n     * @param _operator The operator to check\n     * @param _tokenHolder The token holder to check\n     * @return Whether the `_operator` is an operator for a specified partition of `_tokenHolder`\n     */\n    function isOperatorForPartition(bytes32 _partition, address _operator, address _tokenHolder) external view returns (bool isValid);\n\n    /**\n     * @notice Return all partitions\n     * @param _tokenHolder Whom balance need to queried\n     * @return List of partitions\n     */\n    function partitionsOf(address _tokenHolder) external view returns (bytes32[] memory partitions);\n\n    /**\n     * @notice Gets data store address\n     * @return data store address\n     */\n    function dataStore() external view returns (address dataStoreAddress);\n\n    /**\n    * @notice Allows owner to change data store\n    * @param _dataStore Address of the token data store\n    */\n    function changeDataStore(address _dataStore) external;\n\n\n    /**\n     * @notice Allows to change the treasury wallet address\n     * @param _wallet Ethereum address of the treasury wallet\n     */\n    function changeTreasuryWallet(address _wallet) external;\n\n    /**\n     * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\n     * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\n     * @param _tokenContract Address of the ERC20Basic compliance token\n     * @param _value Amount of POLY to withdraw\n     */\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\n\n    /**\n    * @notice Allows owner to increase/decrease POLY approval of one of the modules\n    * @param _module Module address\n    * @param _change Change in allowance\n    * @param _increase True if budget has to be increased, false if decrease\n    */\n    function changeModuleBudget(address _module, uint256 _change, bool _increase) external;\n\n    /**\n     * @notice Changes the tokenDetails\n     * @param _newTokenDetails New token details\n     */\n    function updateTokenDetails(string calldata _newTokenDetails) external;\n\n    /**\n    * @notice Allows owner to change token name\n    * @param _name new name of the token\n    */\n    function changeName(string calldata _name) external;\n\n    /**\n    * @notice Allows the owner to change token granularity\n    * @param _granularity Granularity level of the token\n    */\n    function changeGranularity(uint256 _granularity) external;\n\n    /**\n     * @notice Freezes all the transfers\n     */\n    function freezeTransfers() external;\n\n    /**\n     * @notice Un-freezes all the transfers\n     */\n    function unfreezeTransfers() external;\n\n    /**\n     * @notice Permanently freeze issuance of this security token.\n     * @dev It MUST NOT be possible to increase `totalSuppy` after this function is called.\n     */\n    function freezeIssuance(bytes calldata _signature) external;\n\n    /**\n      * @notice Attachs a module to the SecurityToken\n      * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\n      * @dev to control restrictions on transfers.\n      * @param _moduleFactory is the address of the module factory to be added\n      * @param _data is data packed into bytes used to further configure the module (See STO usage)\n      * @param _maxCost max amount of POLY willing to pay to the module.\n      * @param _budget max amount of ongoing POLY willing to assign to the module.\n      * @param _label custom module label.\n      * @param _archived whether to add the module as an archived module\n      */\n    function addModuleWithLabel(\n        address _moduleFactory,\n        bytes calldata _data,\n        uint256 _maxCost,\n        uint256 _budget,\n        bytes32 _label,\n        bool _archived\n    ) external;\n\n    /**\n     * @notice Function used to attach a module to the security token\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\n     * @dev to control restrictions on transfers.\n     * @dev You are allowed to add a new moduleType if:\n     * @dev - there is no existing module of that type yet added\n     * @dev - the last member of the module list is replacable\n     * @param _moduleFactory is the address of the module factory to be added\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\n     * @param _budget max amount of ongoing POLY willing to assign to the module.\n     * @param _archived whether to add the module as an archived module\n     */\n    function addModule(address _moduleFactory, bytes calldata _data, uint256 _maxCost, uint256 _budget, bool _archived) external;\n\n    /**\n    * @notice Archives a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function archiveModule(address _module) external;\n\n    /**\n    * @notice Unarchives a module attached to the SecurityToken\n    * @param _module address of module to unarchive\n    */\n    function unarchiveModule(address _module) external;\n\n    /**\n    * @notice Removes a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function removeModule(address _module) external;\n\n    /**\n     * @notice Used by the issuer to set the controller addresses\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) external;\n\n    /**\n     * @notice This function allows an authorised address to transfer tokens between any two token holders.\n     * The transfer must still respect the balances of the token holders (so the transfer must be for at most\n     * `balanceOf(_from)` tokens) and potentially also need to respect other transfer restrictions.\n     * @dev This function can only be executed by the `controller` address.\n     * @param _from Address The address which you want to send tokens from\n     * @param _to Address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\n     * because use of `_data` parameter is implementation specific).\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\n     */\n    function controllerTransfer(address _from, address _to, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\n\n    /**\n     * @notice This function allows an authorised address to redeem tokens for any token holder.\n     * The redemption must still respect the balances of the token holder (so the redemption must be for at most\n     * `balanceOf(_tokenHolder)` tokens) and potentially also need to respect other transfer restrictions.\n     * @dev This function can only be executed by the `controller` address.\n     * @param _tokenHolder The account whose tokens will be redeemed.\n     * @param _value uint256 the amount of tokens need to be redeemed.\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\n     * because use of `_data` parameter is implementation specific).\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\n     */\n    function controllerRedeem(address _tokenHolder, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\n\n    /**\n     * @notice Used by the issuer to permanently disable controller functionality\n     * @dev enabled via feature switch \"disableControllerAllowed\"\n     */\n    function disableController(bytes calldata _signature) external;\n\n    /**\n     * @notice Used to get the version of the securityToken\n     */\n    function getVersion() external view returns(uint8[] memory version);\n\n    /**\n     * @notice Gets the investor count\n     */\n    function getInvestorCount() external view returns(uint256 investorCount);\n\n    /**\n     * @notice Gets the holder count (investors with non zero balance)\n     */\n    function holderCount() external view returns(uint256 count);\n\n    /**\n      * @notice Overloaded version of the transfer function\n      * @param _to receiver of transfer\n      * @param _value value of transfer\n      * @param _data data to indicate validation\n      * @return bool success\n      */\n    function transferWithData(address _to, uint256 _value, bytes calldata _data) external;\n\n    /**\n      * @notice Overloaded version of the transferFrom function\n      * @param _from sender of transfer\n      * @param _to receiver of transfer\n      * @param _value value of transfer\n      * @param _data data to indicate validation\n      * @return bool success\n      */\n    function transferFromWithData(address _from, address _to, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\n     * @param _partition The partition from which to transfer tokens\n     * @param _to The address to which to transfer tokens to\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function transferByPartition(bytes32 _partition, address _to, uint256 _value, bytes calldata _data) external returns (bytes32 partition);\n\n    /**\n     * @notice Get the balance according to the provided partitions\n     * @param _partition Partition which differentiate the tokens.\n     * @param _tokenHolder Whom balance need to queried\n     * @return Amount of tokens as per the given partitions\n     */\n    function balanceOfByPartition(bytes32 _partition, address _tokenHolder) external view returns(uint256 balance);\n\n    /**\n      * @notice Provides the granularity of the token\n      * @return uint256\n      */\n    function granularity() external view returns(uint256 granularityAmount);\n\n    /**\n      * @notice Provides the address of the polymathRegistry\n      * @return address\n      */\n    function polymathRegistry() external view returns(address registryAddress);\n\n    /**\n    * @notice Upgrades a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function upgradeModule(address _module) external;\n\n    /**\n    * @notice Upgrades security token\n    */\n    function upgradeToken() external;\n\n    /**\n     * @notice A security token issuer can specify that issuance has finished for the token\n     * (i.e. no new tokens can be minted or issued).\n     * @dev If a token returns FALSE for `isIssuable()` then it MUST always return FALSE in the future.\n     * If a token returns FALSE for `isIssuable()` then it MUST never allow additional tokens to be issued.\n     * @return bool `true` signifies the minting is allowed. While `false` denotes the end of minting\n     */\n    function isIssuable() external view returns (bool issuable);\n\n    /**\n     * @notice Authorises an operator for all partitions of `msg.sender`.\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\n     * @param _operator An address which is being authorised.\n     */\n    function authorizeOperator(address _operator) external;\n\n    /**\n     * @notice Revokes authorisation of an operator previously given for all partitions of `msg.sender`.\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\n     * @param _operator An address which is being de-authorised\n     */\n    function revokeOperator(address _operator) external;\n\n    /**\n     * @notice Authorises an operator for a given partition of `msg.sender`\n     * @param _partition The partition to which the operator is authorised\n     * @param _operator An address which is being authorised\n     */\n    function authorizeOperatorByPartition(bytes32 _partition, address _operator) external;\n\n    /**\n     * @notice Revokes authorisation of an operator previously given for a specified partition of `msg.sender`\n     * @param _partition The partition to which the operator is de-authorised\n     * @param _operator An address which is being de-authorised\n     */\n    function revokeOperatorByPartition(bytes32 _partition, address _operator) external;\n\n    /**\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\n     * @param _partition The partition from which to transfer tokens.\n     * @param _from The address from which to transfer tokens from\n     * @param _to The address to which to transfer tokens to\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function operatorTransferByPartition(\n        bytes32 _partition,\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    )\n        external\n        returns (bytes32 partition);\n\n    /*\n    * @notice Returns if transfers are currently frozen or not\n    */\n    function transfersFrozen() external view returns (bool isFrozen);\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) external;\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() external view returns (bool);\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() external view returns (address ownerAddress);\n\n    function controller() external view returns(address controllerAddress);\n\n    function moduleRegistry() external view returns(address moduleRegistryAddress);\n\n    function securityTokenRegistry() external view returns(address securityTokenRegistryAddress);\n\n    function polyToken() external view returns(address polyTokenAddress);\n\n    function tokenFactory() external view returns(address tokenFactoryAddress);\n\n    function getterDelegate() external view returns(address delegate);\n\n    function controllerDisabled() external view returns(bool isDisabled);\n\n    function initialized() external view returns(bool isInitialized);\n\n    function tokenDetails() external view returns(string memory details);\n\n    function updateFromRegistry() external;\n\n}\n\ninterface ICheckPermission {\n    /**\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n     * @param _delegate address of delegate\n     * @param _module address of PermissionManager module\n     * @param _perm the permissions\n     * @return success\n     */\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPerm);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Storage for Module contract\n * @notice Contract is abstract\n */\ncontract ModuleStorage {\n    address public factory;\n\n    ISecurityToken public securityToken;\n\n    // Permission flag\n    bytes32 public constant ADMIN = \"ADMIN\";\n    bytes32 public constant OPERATOR = \"OPERATOR\";\n\n    bytes32 internal constant TREASURY = 0xaae8817359f3dcb67d050f44f3e49f982e0359d90ca4b5f18569926304aaece6; // keccak256(abi.encodePacked(\"TREASURY_WALLET\"))\n\n    IERC20 public polyToken;\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor(address _securityToken, address _polyAddress) public {\n        securityToken = ISecurityToken(_securityToken);\n        factory = msg.sender;\n        polyToken = IERC20(_polyAddress);\n    }\n\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     * @notice Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @title Interface that any module contract should implement\n * @notice Contract is abstract\n */\ncontract Module is IModule, ModuleStorage, Pausable {\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     */\n    constructor (address _securityToken, address _polyAddress) public\n    ModuleStorage(_securityToken, _polyAddress)\n    {\n    }\n\n    //Allows owner, factory or permissioned delegate\n    modifier withPerm(bytes32 _perm) {\n        require(_checkPerm(_perm, msg.sender), \"Invalid permission\");\n        _;\n    }\n\n    function _checkPerm(bytes32 _perm, address _caller) internal view returns (bool) {\n        bool isOwner = _caller == Ownable(address(securityToken)).owner();\n        bool isFactory = _caller == factory;\n        return isOwner || isFactory || ICheckPermission(address(securityToken)).checkPermission(_caller, address(this), _perm);\n    }\n\n    function _onlySecurityTokenOwner() internal view {\n        require(msg.sender == Ownable(address(securityToken)).owner(), \"Sender is not owner\");\n    }\n\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Sender is not factory\");\n        _;\n    }\n\n    /**\n     * @notice Pause (overridden function)\n     */\n    function pause() public {\n        _onlySecurityTokenOwner();\n        super._pause();\n    }\n\n    /**\n     * @notice Unpause (overridden function)\n     */\n    function unpause() public {\n        _onlySecurityTokenOwner();\n        super._unpause();\n    }\n\n    /**\n     * @notice used to return the data store address of securityToken\n     */\n    function getDataStore() public view returns(IDataStore) {\n        return IDataStore(securityToken.dataStore());\n    }\n\n    /**\n    * @notice Reclaims ERC20Basic compatible tokens\n    * @dev We duplicate here due to the overriden owner & onlyOwner\n    * @param _tokenContract The address of the token contract\n    */\n    function reclaimERC20(address _tokenContract) external {\n        _onlySecurityTokenOwner();\n        require(_tokenContract != address(0), \"Invalid address\");\n        IERC20 token = IERC20(_tokenContract);\n        uint256 balance = token.balanceOf(address(this));\n        require(token.transfer(msg.sender, balance), \"Transfer failed\");\n    }\n\n   /**\n    * @notice Reclaims ETH\n    * @dev We duplicate here due to the overriden owner & onlyOwner\n    */\n    function reclaimETH() external {\n        _onlySecurityTokenOwner();\n        msg.sender.transfer(address(this).balance);\n    }\n}\n\n/**\n * @title Storage layout for the STO contract\n */\n\ncontract STOStorage {\n    bytes32 internal constant INVESTORFLAGS = \"INVESTORFLAGS\";\n\n    mapping (uint8 => bool) public fundRaiseTypes;\n    mapping (uint8 => uint256) public fundsRaised;\n\n    // Start time of the STO\n    uint256 public startTime;\n    // End time of the STO\n    uint256 public endTime;\n    // Time STO was paused\n    uint256 public pausedTime;\n    // Number of individual investors\n    uint256 public investorCount;\n    // Address where ETH & POLY funds are delivered\n    address payable public wallet;\n    // Final amount of tokens sold\n    uint256 public totalTokensSold;\n\n}\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n/**\n * @title Interface to be implemented by all STO modules\n */\ninterface ISTO {\n\n    enum FundRaiseType {ETH, POLY, SC}\n\n    // Event\n    event SetFundRaiseTypes(FundRaiseType[] _fundRaiseTypes);\n\n    /**\n     * @notice Returns the total no. of tokens sold\n     */\n    function getTokensSold() external view returns(uint256 soldTokens);\n\n    /**\n     * @notice Returns funds raised by the STO\n     */\n    function getRaised(FundRaiseType _fundRaiseType) external view returns(uint256 raisedAmount);\n\n    /**\n     * @notice Pause (overridden function)\n     * @dev Only securityToken owner restriction applied on the super function\n     */\n    function pause() external;\n\n}\n\n/**\n * @title Base abstract contract to be extended by all STO modules\n */\ncontract STO is ISTO, STOStorage, Module {\n    using SafeMath for uint256;\n\n    /**\n     * @notice Returns funds raised by the STO\n     */\n    function getRaised(FundRaiseType _fundRaiseType) public view returns(uint256) {\n        return fundsRaised[uint8(_fundRaiseType)];\n    }\n\n    /**\n     * @notice Returns the total no. of tokens sold\n     */\n    function getTokensSold() external view returns (uint256);\n\n    /**\n     * @notice Pause (overridden function)\n     * @dev Only securityToken owner restriction applied on the super function\n     */\n    function pause() public {\n        /*solium-disable-next-line security/no-block-members*/\n        require(now < endTime, \"STO has been finalized\");\n        super.pause();\n    }\n\n    function _setFundRaiseType(FundRaiseType[] memory _fundRaiseTypes) internal {\n        // FundRaiseType[] parameter type ensures only valid values for _fundRaiseTypes\n        require(_fundRaiseTypes.length > 0 && _fundRaiseTypes.length <= 3, \"Raise type is not specified\");\n        fundRaiseTypes[uint8(FundRaiseType.ETH)] = false;\n        fundRaiseTypes[uint8(FundRaiseType.POLY)] = false;\n        fundRaiseTypes[uint8(FundRaiseType.SC)] = false;\n        for (uint8 j = 0; j < _fundRaiseTypes.length; j++) {\n            fundRaiseTypes[uint8(_fundRaiseTypes[j])] = true;\n        }\n        emit SetFundRaiseTypes(_fundRaiseTypes);\n    }\n\n    function _canBuy(address _investor) internal view returns(bool) {\n        IDataStore dataStore = getDataStore();\n        uint256 flags = dataStore.getUint256(_getKey(INVESTORFLAGS, _investor));\n        return(flags & (uint256(1) << 1) == 0);\n    }\n\n    function _getKey(bytes32 _key1, address _key2) internal pure returns(bytes32) {\n        return bytes32(keccak256(abi.encodePacked(_key1, _key2)));\n    }\n}\n\ninterface IPolymathRegistry {\n\n    event ChangeAddress(string _nameKey, address indexed _oldAddress, address indexed _newAddress);\n    \n    /**\n     * @notice Returns the contract address\n     * @param _nameKey is the key for the contract address mapping\n     * @return address\n     */\n    function getAddress(string calldata _nameKey) external view returns(address registryAddress);\n\n    /**\n     * @notice Changes the contract address\n     * @param _nameKey is the key for the contract address mapping\n     * @param _newAddress is the new contract address\n     */\n    function changeAddress(string calldata _nameKey, address _newAddress) external;\n\n}\n\ninterface IOracle {\n    /**\n    * @notice Returns address of oracle currency (0x0 for ETH)\n    */\n    function getCurrencyAddress() external view returns(address currency);\n\n    /**\n    * @notice Returns symbol of oracle currency (0x0 for ETH)\n    */\n    function getCurrencySymbol() external view returns(bytes32 symbol);\n\n    /**\n    * @notice Returns denomination of price\n    */\n    function getCurrencyDenominated() external view returns(bytes32 denominatedCurrency);\n\n    /**\n    * @notice Returns price - should throw if not valid\n    */\n    function getPrice() external returns(uint256 price);\n\n}\n\nlibrary DecimalMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant e18 = uint256(10) ** uint256(18);\n\n    /**\n     * @notice This function multiplies two decimals represented as (decimal * 10**DECIMALS)\n     * @return uint256 Result of multiplication represented as (decimal * 10**DECIMALS)\n     */\n    function mul(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        z = SafeMath.add(SafeMath.mul(x, y), (e18) / 2) / (e18);\n    }\n\n    /**\n     * @notice This function divides two decimals represented as (decimal * 10**DECIMALS)\n     * @return uint256 Result of division represented as (decimal * 10**DECIMALS)\n     */\n    function div(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        z = SafeMath.add(SafeMath.mul(x, (e18)), y / 2) / y;\n    }\n\n}\n\n/**\n * @title Contract used to store layout for the USDTieredSTO storage\n */\ncontract USDTieredSTOStorage {\n\n    bytes32 internal constant INVESTORSKEY = 0xdf3a8dd24acdd05addfc6aeffef7574d2de3f844535ec91e8e0f3e45dba96731; //keccak256(abi.encodePacked(\"INVESTORS\"))\n    \n    /////////////\n    // Storage //\n    /////////////\n    struct Tier {\n        // NB rates mentioned below are actually price and are used like price in the logic.\n        // How many token units a buyer gets per USD in this tier (multiplied by 10**18)\n        uint256 rate;\n        // How many token units a buyer gets per USD in this tier (multiplied by 10**18) when investing in POLY up to tokensDiscountPoly\n        uint256 rateDiscountPoly;\n        // How many tokens are available in this tier (relative to totalSupply)\n        uint256 tokenTotal;\n        // How many token units are available in this tier (relative to totalSupply) at the ratePerTierDiscountPoly rate\n        uint256 tokensDiscountPoly;\n        // How many tokens have been minted in this tier (relative to totalSupply)\n        uint256 mintedTotal;\n        // How many tokens have been minted in this tier (relative to totalSupply) for each fund raise type\n        mapping(uint8 => uint256) minted;\n        // How many tokens have been minted in this tier (relative to totalSupply) at discounted POLY rate\n        uint256 mintedDiscountPoly;\n    }\n\n    mapping(address => uint256) public nonAccreditedLimitUSDOverride;\n\n    mapping(bytes32 => mapping(bytes32 => string)) oracleKeys;\n\n    // Determine whether users can invest on behalf of a beneficiary\n    bool public allowBeneficialInvestments;\n\n    // Whether or not the STO has been finalized\n    bool public isFinalized;\n\n    // Address of issuer treasury wallet for unsold tokens\n    address public treasuryWallet;\n\n    // List of stable coin addresses\n    IERC20[] internal usdTokens;\n\n    // Current tier\n    uint256 public currentTier;\n\n    // Amount of USD funds raised\n    uint256 public fundsRaisedUSD;\n\n    // Amount of stable coins raised\n    mapping (address => uint256) public stableCoinsRaised;\n\n    // Amount in USD invested by each address\n    mapping(address => uint256) public investorInvestedUSD;\n\n    // Amount in fund raise type invested by each investor\n    mapping(address => mapping(uint8 => uint256)) public investorInvested;\n\n    // List of active stable coin addresses\n    mapping (address => bool) internal usdTokenEnabled;\n\n    // Default limit in USD for non-accredited investors multiplied by 10**18\n    uint256 public nonAccreditedLimitUSD;\n\n    // Minimum investable amount in USD\n    uint256 public minimumInvestmentUSD;\n\n    // Final amount of tokens returned to issuer\n    uint256 public finalAmountReturned;\n\n    // Array of Tiers\n    Tier[] public tiers;\n\n    // Optional custom Oracles.\n    mapping(bytes32 => mapping(bytes32 => address)) customOracles;\n}\n\n/**\n * @title STO module for standard capped crowdsale\n */\ncontract USDTieredSTO is USDTieredSTOStorage, STO {\n    using SafeMath for uint256;\n\n    string internal constant POLY_ORACLE = \"PolyUsdOracle\";\n    string internal constant ETH_ORACLE = \"EthUsdOracle\";\n\n    ////////////\n    // Events //\n    ////////////\n\n    event SetAllowBeneficialInvestments(bool _allowed);\n    event SetNonAccreditedLimit(address _investor, uint256 _limit);\n    event TokenPurchase(\n        address indexed _purchaser,\n        address indexed _beneficiary,\n        uint256 _tokens,\n        uint256 _usdAmount,\n        uint256 _tierPrice,\n        uint256 _tier\n    );\n    event FundsReceived(\n        address indexed _purchaser,\n        address indexed _beneficiary,\n        uint256 _usdAmount,\n        FundRaiseType _fundRaiseType,\n        uint256 _receivedValue,\n        uint256 _spentValue,\n        uint256 _rate\n    );\n    event ReserveTokenMint(address indexed _owner, address indexed _wallet, uint256 _tokens, uint256 _latestTier);\n    event SetAddresses(address indexed _wallet, IERC20[] _usdTokens);\n    event SetLimits(uint256 _nonAccreditedLimitUSD, uint256 _minimumInvestmentUSD);\n    event SetTimes(uint256 _startTime, uint256 _endTime);\n    event SetTiers(\n        uint256[] _ratePerTier,\n        uint256[] _ratePerTierDiscountPoly,\n        uint256[] _tokensPerTierTotal,\n        uint256[] _tokensPerTierDiscountPoly\n    );\n    event SetTreasuryWallet(address _oldWallet, address _newWallet);\n\n    ///////////////\n    // Modifiers //\n    ///////////////\n\n    modifier validETH() {\n        require(_getOracle(bytes32(\"ETH\"), bytes32(\"USD\")) != address(0), \"Invalid Oracle\");\n        require(fundRaiseTypes[uint8(FundRaiseType.ETH)], \"ETH not allowed\");\n        _;\n    }\n\n    modifier validPOLY() {\n        require(_getOracle(bytes32(\"POLY\"), bytes32(\"USD\")) != address(0), \"Invalid Oracle\");\n        require(fundRaiseTypes[uint8(FundRaiseType.POLY)], \"POLY not allowed\");\n        _;\n    }\n\n    modifier validSC(address _usdToken) {\n        require(fundRaiseTypes[uint8(FundRaiseType.SC)] && usdTokenEnabled[_usdToken], \"USD not allowed\");\n        _;\n    }\n\n    ///////////////////////\n    // STO Configuration //\n    ///////////////////////\n\n    constructor(address _securityToken, address _polyAddress) public Module(_securityToken, _polyAddress) {\n\n    }\n\n    /**\n     * @notice Function used to intialize the contract variables\n     * @param _startTime Unix timestamp at which offering get started\n     * @param _endTime Unix timestamp at which offering get ended\n     * @param _ratePerTier Rate (in USD) per tier (* 10**18)\n     * @param _tokensPerTierTotal Tokens available in each tier\n     * @param _nonAccreditedLimitUSD Limit in USD (* 10**18) for non-accredited investors\n     * @param _minimumInvestmentUSD Minimun investment in USD (* 10**18)\n     * @param _fundRaiseTypes Types of currency used to collect the funds\n     * @param _wallet Ethereum account address to hold the funds\n     * @param _treasuryWallet Ethereum account address to receive unsold tokens\n     * @param _usdTokens Contract address of the stable coins\n     */\n    function configure(\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256[] memory _ratePerTier,\n        uint256[] memory _ratePerTierDiscountPoly,\n        uint256[] memory _tokensPerTierTotal,\n        uint256[] memory _tokensPerTierDiscountPoly,\n        uint256 _nonAccreditedLimitUSD,\n        uint256 _minimumInvestmentUSD,\n        FundRaiseType[] memory _fundRaiseTypes,\n        address payable _wallet,\n        address _treasuryWallet,\n        IERC20[] memory _usdTokens\n    )\n        public\n        onlyFactory\n    {\n        oracleKeys[bytes32(\"ETH\")][bytes32(\"USD\")] = ETH_ORACLE;\n        oracleKeys[bytes32(\"POLY\")][bytes32(\"USD\")] = POLY_ORACLE;\n        require(endTime == 0, \"Already configured\");\n        _modifyTimes(_startTime, _endTime);\n        _modifyTiers(_ratePerTier, _ratePerTierDiscountPoly, _tokensPerTierTotal, _tokensPerTierDiscountPoly);\n        // NB - _setFundRaiseType must come before modifyAddresses\n        _setFundRaiseType(_fundRaiseTypes);\n        _modifyAddresses(_wallet, _treasuryWallet, _usdTokens);\n        _modifyLimits(_nonAccreditedLimitUSD, _minimumInvestmentUSD);\n    }\n\n    /**\n     * @dev Modifies fund raise types\n     * @param _fundRaiseTypes Array of fund raise types to allow\n     */\n    function modifyFunding(FundRaiseType[] calldata _fundRaiseTypes) external withPerm(OPERATOR) {\n        _isSTOStarted();\n        _setFundRaiseType(_fundRaiseTypes);\n    }\n\n    /**\n     * @dev modifies max non accredited invets limit and overall minimum investment limit\n     * @param _nonAccreditedLimitUSD max non accredited invets limit\n     * @param _minimumInvestmentUSD overall minimum investment limit\n     */\n    function modifyLimits(uint256 _nonAccreditedLimitUSD, uint256 _minimumInvestmentUSD) external withPerm(OPERATOR) {\n        _isSTOStarted();\n        _modifyLimits(_nonAccreditedLimitUSD, _minimumInvestmentUSD);\n    }\n\n    /**\n     * @dev modifiers STO tiers. All tiers must be passed, can not edit specific tiers.\n     * @param _ratePerTier Array of rates per tier\n     * @param _ratePerTierDiscountPoly Array of discounted poly rates per tier\n     * @param _tokensPerTierTotal Array of total tokens per tier\n     * @param _tokensPerTierDiscountPoly Array of discounted tokens per tier\n     */\n    function modifyTiers(\n        uint256[] calldata _ratePerTier,\n        uint256[] calldata _ratePerTierDiscountPoly,\n        uint256[] calldata _tokensPerTierTotal,\n        uint256[] calldata _tokensPerTierDiscountPoly\n    )\n        external\n        withPerm(OPERATOR)\n    {\n        _isSTOStarted();\n        _modifyTiers(_ratePerTier, _ratePerTierDiscountPoly, _tokensPerTierTotal, _tokensPerTierDiscountPoly);\n    }\n\n    /**\n     * @dev Modifies STO start and end times\n     * @param _startTime start time of sto\n     * @param _endTime end time of sto\n     */\n    function modifyTimes(uint256 _startTime, uint256 _endTime) external withPerm(OPERATOR) {\n        _isSTOStarted();\n        _modifyTimes(_startTime, _endTime);\n    }\n\n    function _isSTOStarted() internal view {\n        /*solium-disable-next-line security/no-block-members*/\n        require(now < startTime, \"Already started\");\n    }\n\n    /**\n     * @dev Modifies addresses used as wallet, reserve wallet and usd token\n     * @param _wallet Address of wallet where funds are sent\n     * @param _treasuryWallet Address of wallet where unsold tokens are sent\n     * @param _usdTokens Address of usd tokens\n     */\n    function modifyAddresses(address payable _wallet, address _treasuryWallet, IERC20[] calldata _usdTokens) external {\n        _onlySecurityTokenOwner();\n        _modifyAddresses(_wallet, _treasuryWallet, _usdTokens);\n    }\n\n    /**\n     * @dev Modifies Oracle address.\n     *      By default, Polymath oracles are used but issuer can overide them using this function\n     *      Set _oracleAddress to 0x0 to fallback to using Polymath oracles\n     * @param _fundRaiseType Actual currency\n     * @param _oracleAddress address of the oracle\n     */\n    function modifyOracle(FundRaiseType _fundRaiseType, address _oracleAddress) external {\n        _onlySecurityTokenOwner();\n        if (_fundRaiseType == FundRaiseType.ETH) {\n            customOracles[bytes32(\"ETH\")][bytes32(\"USD\")] = _oracleAddress;\n        } else {\n            require(_fundRaiseType == FundRaiseType.POLY, \"Invalid currency\");\n            customOracles[bytes32(\"POLY\")][bytes32(\"USD\")] = _oracleAddress;\n        }\n    }\n\n    function _modifyLimits(uint256 _nonAccreditedLimitUSD, uint256 _minimumInvestmentUSD) internal {\n        minimumInvestmentUSD = _minimumInvestmentUSD;\n        nonAccreditedLimitUSD = _nonAccreditedLimitUSD;\n        emit SetLimits(minimumInvestmentUSD, nonAccreditedLimitUSD);\n    }\n\n    function _modifyTiers(\n        uint256[] memory _ratePerTier,\n        uint256[] memory _ratePerTierDiscountPoly,\n        uint256[] memory _tokensPerTierTotal,\n        uint256[] memory _tokensPerTierDiscountPoly\n    )\n        internal\n    {\n        require(\n            _tokensPerTierTotal.length > 0 &&\n            _ratePerTier.length == _tokensPerTierTotal.length &&\n            _ratePerTierDiscountPoly.length == _tokensPerTierTotal.length &&\n            _tokensPerTierDiscountPoly.length == _tokensPerTierTotal.length,\n            \"Invalid Input\"\n        );\n        delete tiers;\n        for (uint256 i = 0; i < _ratePerTier.length; i++) {\n            require(_ratePerTier[i] > 0 && _tokensPerTierTotal[i] > 0, \"Invalid value\");\n            require(_tokensPerTierDiscountPoly[i] <= _tokensPerTierTotal[i], \"Too many discounted tokens\");\n            require(_ratePerTierDiscountPoly[i] <= _ratePerTier[i], \"Invalid discount\");\n            tiers.push(Tier(_ratePerTier[i], _ratePerTierDiscountPoly[i], _tokensPerTierTotal[i], _tokensPerTierDiscountPoly[i], 0, 0));\n        }\n        emit SetTiers(_ratePerTier, _ratePerTierDiscountPoly, _tokensPerTierTotal, _tokensPerTierDiscountPoly);\n    }\n\n    function _modifyTimes(uint256 _startTime, uint256 _endTime) internal {\n        /*solium-disable-next-line security/no-block-members*/\n        require((_endTime > _startTime) && (_startTime > now), \"Invalid times\");\n        startTime = _startTime;\n        endTime = _endTime;\n        emit SetTimes(_startTime, _endTime);\n    }\n\n    function _modifyAddresses(address payable _wallet, address _treasuryWallet, IERC20[] memory _usdTokens) internal {\n        require(_wallet != address(0), \"Invalid wallet\");\n        wallet = _wallet;\n        emit SetTreasuryWallet(treasuryWallet, _treasuryWallet);\n        treasuryWallet = _treasuryWallet;\n        _modifyUSDTokens(_usdTokens);\n    }\n\n    function _modifyUSDTokens(IERC20[] memory _usdTokens) internal {\n        uint256 i;\n        for(i = 0; i < usdTokens.length; i++) {\n            usdTokenEnabled[address(usdTokens[i])] = false;\n        }\n        usdTokens = _usdTokens;\n        for(i = 0; i < _usdTokens.length; i++) {\n            require(address(_usdTokens[i]) != address(0) && _usdTokens[i] != polyToken, \"Invalid USD token\");\n            usdTokenEnabled[address(_usdTokens[i])] = true;\n        }\n        emit SetAddresses(wallet, _usdTokens);\n    }\n\n    ////////////////////\n    // STO Management //\n    ////////////////////\n\n    /**\n     * @notice Finalizes the STO and mint remaining tokens to treasury address\n     * @notice Treasury wallet address must be whitelisted to successfully finalize\n     */\n    function finalize() external withPerm(ADMIN) {\n        require(!isFinalized, \"STO is finalized\");\n        isFinalized = true;\n        uint256 tempReturned;\n        uint256 tempSold;\n        uint256 remainingTokens;\n        for (uint256 i = 0; i < tiers.length; i++) {\n            remainingTokens = tiers[i].tokenTotal.sub(tiers[i].mintedTotal);\n            tempReturned = tempReturned.add(remainingTokens);\n            tempSold = tempSold.add(tiers[i].mintedTotal);\n            if (remainingTokens > 0) {\n                tiers[i].mintedTotal = tiers[i].tokenTotal;\n            }\n        }\n        address walletAddress = (treasuryWallet == address(0) ? IDataStore(getDataStore()).getAddress(TREASURY) : treasuryWallet);\n        require(walletAddress != address(0), \"Invalid address\");\n        uint256 granularity = securityToken.granularity();\n        tempReturned = tempReturned.div(granularity);\n        tempReturned = tempReturned.mul(granularity);\n        securityToken.issue(walletAddress, tempReturned, \"\");\n        emit ReserveTokenMint(msg.sender, walletAddress, tempReturned, currentTier);\n        finalAmountReturned = tempReturned;\n        totalTokensSold = tempSold;\n    }\n\n    /**\n     * @notice Modifies the list of overrides for non-accredited limits in USD\n     * @param _investors Array of investor addresses to modify\n     * @param _nonAccreditedLimit Array of uints specifying non-accredited limits\n     */\n    function changeNonAccreditedLimit(address[] calldata _investors, uint256[] calldata _nonAccreditedLimit) external withPerm(OPERATOR) {\n        //nonAccreditedLimitUSDOverride\n        require(_investors.length == _nonAccreditedLimit.length, \"Length mismatch\");\n        for (uint256 i = 0; i < _investors.length; i++) {\n            nonAccreditedLimitUSDOverride[_investors[i]] = _nonAccreditedLimit[i];\n            emit SetNonAccreditedLimit(_investors[i], _nonAccreditedLimit[i]);\n        }\n    }\n\n    /**\n     * @notice Returns investor accredited & non-accredited override informatiomn\n     * @return investors list of all configured investors\n     * @return accredited whether investor is accredited\n     * @return override any USD overrides for non-accredited limits for the investor\n     */\n    function getAccreditedData() external view returns (address[] memory investors, bool[] memory accredited, uint256[] memory overrides) {\n        IDataStore dataStore = getDataStore();\n        investors = dataStore.getAddressArray(INVESTORSKEY);\n        accredited = new bool[](investors.length);\n        overrides = new uint256[](investors.length);\n        for (uint256 i = 0; i < investors.length; i++) {\n            accredited[i] = _getIsAccredited(investors[i], dataStore);\n            overrides[i] = nonAccreditedLimitUSDOverride[investors[i]];\n        }\n    }\n\n    /**\n     * @notice Function to set allowBeneficialInvestments (allow beneficiary to be different to funder)\n     * @param _allowBeneficialInvestments Boolean to allow or disallow beneficial investments\n     */\n    function changeAllowBeneficialInvestments(bool _allowBeneficialInvestments) external withPerm(OPERATOR) {\n        require(_allowBeneficialInvestments != allowBeneficialInvestments);\n        allowBeneficialInvestments = _allowBeneficialInvestments;\n        emit SetAllowBeneficialInvestments(allowBeneficialInvestments);\n    }\n\n    //////////////////////////\n    // Investment Functions //\n    //////////////////////////\n\n    /**\n    * @notice fallback function - assumes ETH being invested\n    */\n    function() external payable {\n        buyWithETHRateLimited(msg.sender, 0);\n    }\n\n    // Buy functions without rate restriction\n    function buyWithETH(address _beneficiary) external payable returns (uint256, uint256, uint256) {\n        return buyWithETHRateLimited(_beneficiary, 0);\n    }\n\n    function buyWithPOLY(address _beneficiary, uint256 _investedPOLY) external returns (uint256, uint256, uint256) {\n        return buyWithPOLYRateLimited(_beneficiary, _investedPOLY, 0);\n    }\n\n    function buyWithUSD(address _beneficiary, uint256 _investedSC, IERC20 _usdToken) external returns (uint256, uint256, uint256) {\n        return buyWithUSDRateLimited(_beneficiary, _investedSC, 0, _usdToken);\n    }\n\n    /**\n      * @notice Purchase tokens using ETH\n      * @param _beneficiary Address where security tokens will be sent\n      * @param _minTokens Minumum number of tokens to buy or else revert\n      */\n    function buyWithETHRateLimited(address _beneficiary, uint256 _minTokens) public payable validETH returns (uint256, uint256, uint256) {\n        (uint256 rate, uint256 spentUSD, uint256 spentValue, uint256 initialMinted) = _getSpentvalues(_beneficiary,  msg.value, FundRaiseType.ETH, _minTokens);\n        // Modify storage\n        investorInvested[_beneficiary][uint8(FundRaiseType.ETH)] = investorInvested[_beneficiary][uint8(FundRaiseType.ETH)].add(spentValue);\n        fundsRaised[uint8(FundRaiseType.ETH)] = fundsRaised[uint8(FundRaiseType.ETH)].add(spentValue);\n        // Forward ETH to issuer wallet\n        wallet.transfer(spentValue);\n        // Refund excess ETH to investor wallet\n        msg.sender.transfer(msg.value.sub(spentValue));\n        emit FundsReceived(msg.sender, _beneficiary, spentUSD, FundRaiseType.ETH, msg.value, spentValue, rate);\n        return (spentUSD, spentValue, getTokensMinted().sub(initialMinted));\n    }\n\n    /**\n      * @notice Purchase tokens using POLY\n      * @param _beneficiary Address where security tokens will be sent\n      * @param _investedPOLY Amount of POLY invested\n      * @param _minTokens Minumum number of tokens to buy or else revert\n      */\n    function buyWithPOLYRateLimited(address _beneficiary, uint256 _investedPOLY, uint256 _minTokens) public validPOLY returns (uint256, uint256, uint256) {\n        return _buyWithTokens(_beneficiary, _investedPOLY, FundRaiseType.POLY, _minTokens, polyToken);\n    }\n\n    /**\n      * @notice Purchase tokens using Stable coins\n      * @param _beneficiary Address where security tokens will be sent\n      * @param _investedSC Amount of Stable coins invested\n      * @param _minTokens Minumum number of tokens to buy or else revert\n      * @param _usdToken Address of USD stable coin to buy tokens with\n      */\n    function buyWithUSDRateLimited(address _beneficiary, uint256 _investedSC, uint256 _minTokens, IERC20 _usdToken)\n        public validSC(address(_usdToken)) returns (uint256, uint256, uint256)\n    {\n        return _buyWithTokens(_beneficiary, _investedSC, FundRaiseType.SC, _minTokens, _usdToken);\n    }\n\n    function _buyWithTokens(address _beneficiary, uint256 _tokenAmount, FundRaiseType _fundRaiseType, uint256 _minTokens, IERC20 _token) internal returns (uint256, uint256, uint256) {\n        (uint256 rate, uint256 spentUSD, uint256 spentValue, uint256 initialMinted) = _getSpentvalues(_beneficiary, _tokenAmount, _fundRaiseType, _minTokens);\n        // Modify storage\n        investorInvested[_beneficiary][uint8(_fundRaiseType)] = investorInvested[_beneficiary][uint8(_fundRaiseType)].add(spentValue);\n        fundsRaised[uint8(_fundRaiseType)] = fundsRaised[uint8(_fundRaiseType)].add(spentValue);\n        if(address(_token) != address(polyToken))\n            stableCoinsRaised[address(_token)] = stableCoinsRaised[address(_token)].add(spentValue);\n        // Forward coins to issuer wallet\n        require(_token.transferFrom(msg.sender, wallet, spentValue), \"Transfer failed\");\n        emit FundsReceived(msg.sender, _beneficiary, spentUSD, _fundRaiseType, _tokenAmount, spentValue, rate);\n        return (spentUSD, spentValue, getTokensMinted().sub(initialMinted));\n    }\n\n    function _getSpentvalues(address _beneficiary, uint256 _amount, FundRaiseType _fundRaiseType, uint256 _minTokens) internal returns(uint256 rate, uint256 spentUSD, uint256 spentValue, uint256 initialMinted) {\n        initialMinted = getTokensMinted();\n        rate = getRate(_fundRaiseType);\n        (spentUSD, spentValue) = _buyTokens(_beneficiary, _amount, rate, _fundRaiseType);\n        require(getTokensMinted().sub(initialMinted) >= _minTokens, \"Insufficient minted\");\n    }\n\n\n    /**\n      * @notice Low level token purchase\n      * @param _beneficiary Address where security tokens will be sent\n      * @param _investmentValue Amount of POLY, ETH or Stable coins invested\n      * @param _fundRaiseType Fund raise type (POLY, ETH, SC)\n      */\n    function _buyTokens(\n        address _beneficiary,\n        uint256 _investmentValue,\n        uint256 _rate,\n        FundRaiseType _fundRaiseType\n    )\n        internal\n        whenNotPaused\n        returns(uint256 spentUSD, uint256 spentValue)\n    {\n        if (!allowBeneficialInvestments) {\n            require(_beneficiary == msg.sender, \"Beneficiary != funder\");\n        }\n\n        require(_canBuy(_beneficiary), \"Unauthorized\");\n\n        uint256 originalUSD = DecimalMath.mul(_rate, _investmentValue);\n        uint256 allowedUSD = _buyTokensChecks(_beneficiary, _investmentValue, originalUSD);\n\n        for (uint256 i = currentTier; i < tiers.length; i++) {\n            bool gotoNextTier;\n            uint256 tempSpentUSD;\n            // Update current tier if needed\n            if (currentTier != i)\n                currentTier = i;\n            // If there are tokens remaining, process investment\n            if (tiers[i].mintedTotal < tiers[i].tokenTotal) {\n                (tempSpentUSD, gotoNextTier) = _calculateTier(_beneficiary, i, allowedUSD.sub(spentUSD), _fundRaiseType);\n                spentUSD = spentUSD.add(tempSpentUSD);\n                // If all funds have been spent, exit the loop\n                if (!gotoNextTier)\n                    break;\n            }\n        }\n\n        // Modify storage\n        if (spentUSD > 0) {\n            if (investorInvestedUSD[_beneficiary] == 0)\n                investorCount = investorCount + 1;\n            investorInvestedUSD[_beneficiary] = investorInvestedUSD[_beneficiary].add(spentUSD);\n            fundsRaisedUSD = fundsRaisedUSD.add(spentUSD);\n        }\n\n        spentValue = DecimalMath.div(spentUSD, _rate);\n    }\n\n    function _buyTokensChecks(\n        address _beneficiary,\n        uint256 _investmentValue,\n        uint256 investedUSD\n    )\n        internal\n        view\n        returns(uint256 netInvestedUSD)\n    {\n        require(isOpen(), \"STO not open\");\n        require(_investmentValue > 0, \"No funds sent\");\n\n        // Check for minimum investment\n        require(investedUSD.add(investorInvestedUSD[_beneficiary]) >= minimumInvestmentUSD, \"Investment < min\");\n        netInvestedUSD = investedUSD;\n        // Check for non-accredited cap\n        if (!_isAccredited(_beneficiary)) {\n            uint256 investorLimitUSD = (nonAccreditedLimitUSDOverride[_beneficiary] == 0) ? nonAccreditedLimitUSD : nonAccreditedLimitUSDOverride[_beneficiary];\n            require(investorInvestedUSD[_beneficiary] < investorLimitUSD, \"Over Non-accredited investor limit\");\n            if (investedUSD.add(investorInvestedUSD[_beneficiary]) > investorLimitUSD)\n                netInvestedUSD = investorLimitUSD.sub(investorInvestedUSD[_beneficiary]);\n        }\n    }\n\n    function _calculateTier(\n        address _beneficiary,\n        uint256 _tier,\n        uint256 _investedUSD,\n        FundRaiseType _fundRaiseType\n    )\n        internal\n        returns(uint256 spentUSD, bool gotoNextTier)\n     {\n        // First purchase any discounted tokens if POLY investment\n        uint256 tierSpentUSD;\n        uint256 tierPurchasedTokens;\n        uint256 investedUSD = _investedUSD;\n        Tier storage tierData = tiers[_tier];\n        // Check whether there are any remaining discounted tokens\n        if ((_fundRaiseType == FundRaiseType.POLY) && (tierData.tokensDiscountPoly > tierData.mintedDiscountPoly)) {\n            uint256 discountRemaining = tierData.tokensDiscountPoly.sub(tierData.mintedDiscountPoly);\n            uint256 totalRemaining = tierData.tokenTotal.sub(tierData.mintedTotal);\n            if (totalRemaining < discountRemaining)\n                (spentUSD, tierPurchasedTokens, gotoNextTier) = _purchaseTier(_beneficiary, tierData.rateDiscountPoly, totalRemaining, investedUSD, _tier);\n            else\n                (spentUSD, tierPurchasedTokens, gotoNextTier) = _purchaseTier(_beneficiary, tierData.rateDiscountPoly, discountRemaining, investedUSD, _tier);\n            investedUSD = investedUSD.sub(spentUSD);\n            tierData.mintedDiscountPoly = tierData.mintedDiscountPoly.add(tierPurchasedTokens);\n            tierData.minted[uint8(_fundRaiseType)] = tierData.minted[uint8(_fundRaiseType)].add(tierPurchasedTokens);\n            tierData.mintedTotal = tierData.mintedTotal.add(tierPurchasedTokens);\n        }\n        // Now, if there is any remaining USD to be invested, purchase at non-discounted rate\n        if (investedUSD > 0 &&\n            tierData.tokenTotal.sub(tierData.mintedTotal) > 0 &&\n            (_fundRaiseType != FundRaiseType.POLY || tierData.tokensDiscountPoly <= tierData.mintedDiscountPoly)\n        ) {\n            (tierSpentUSD, tierPurchasedTokens, gotoNextTier) = _purchaseTier(_beneficiary, tierData.rate, tierData.tokenTotal.sub(tierData.mintedTotal), investedUSD, _tier);\n            spentUSD = spentUSD.add(tierSpentUSD);\n            tierData.minted[uint8(_fundRaiseType)] = tierData.minted[uint8(_fundRaiseType)].add(tierPurchasedTokens);\n            tierData.mintedTotal = tierData.mintedTotal.add(tierPurchasedTokens);\n        }\n    }\n\n    function _purchaseTier(\n        address _beneficiary,\n        uint256 _tierPrice,\n        uint256 _tierRemaining,\n        uint256 _investedUSD,\n        uint256 _tier\n    )\n        internal\n        returns(uint256 spentUSD, uint256 purchasedTokens, bool gotoNextTier)\n    {\n        purchasedTokens = DecimalMath.div(_investedUSD, _tierPrice);\n        uint256 granularity = securityToken.granularity();\n\n        if (purchasedTokens > _tierRemaining) {\n            purchasedTokens = _tierRemaining.div(granularity);\n            gotoNextTier = true;\n        } else {\n            purchasedTokens = purchasedTokens.div(granularity);\n        }\n\n        purchasedTokens = purchasedTokens.mul(granularity);\n        spentUSD = DecimalMath.mul(purchasedTokens, _tierPrice);\n\n        // In case of rounding issues, ensure that spentUSD is never more than investedUSD\n        if (spentUSD > _investedUSD) {\n            spentUSD = _investedUSD;\n        }\n\n        if (purchasedTokens > 0) {\n            securityToken.issue(_beneficiary, purchasedTokens, \"\");\n            emit TokenPurchase(msg.sender, _beneficiary, purchasedTokens, spentUSD, _tierPrice, _tier);\n        }\n    }\n\n    function _isAccredited(address _investor) internal view returns(bool) {\n        IDataStore dataStore = getDataStore();\n        return _getIsAccredited(_investor, dataStore);\n    }\n\n    function _getIsAccredited(address _investor, IDataStore dataStore) internal view returns(bool) {\n        uint256 flags = dataStore.getUint256(_getKey(INVESTORFLAGS, _investor));\n        uint256 flag = flags & uint256(1); //isAccredited is flag 0 so we don't need to bit shift flags.\n        return flag > 0 ? true : false;\n    }\n\n    /////////////\n    // Getters //\n    /////////////\n\n    /**\n     * @notice This function returns whether or not the STO is in fundraising mode (open)\n     * @return bool Whether the STO is accepting investments\n     */\n    function isOpen() public view returns(bool) {\n        /*solium-disable-next-line security/no-block-members*/\n        if (isFinalized || now < startTime || now >= endTime || capReached())\n            return false;\n        return true;\n    }\n\n    /**\n     * @notice Checks whether the cap has been reached.\n     * @return bool Whether the cap was reached\n     */\n    function capReached() public view returns (bool) {\n        if (isFinalized) {\n            return (finalAmountReturned == 0);\n        }\n        return (tiers[tiers.length - 1].mintedTotal == tiers[tiers.length - 1].tokenTotal);\n    }\n\n    /**\n     * @dev returns current conversion rate of funds\n     * @param _fundRaiseType Fund raise type to get rate of\n     */\n    function getRate(FundRaiseType _fundRaiseType) public returns (uint256) {\n        if (_fundRaiseType == FundRaiseType.ETH) {\n            return IOracle(_getOracle(bytes32(\"ETH\"), bytes32(\"USD\"))).getPrice();\n        } else if (_fundRaiseType == FundRaiseType.POLY) {\n            return IOracle(_getOracle(bytes32(\"POLY\"), bytes32(\"USD\"))).getPrice();\n        } else if (_fundRaiseType == FundRaiseType.SC) {\n            return 10**18;\n        }\n    }\n\n    /**\n     * @notice This function converts from ETH or POLY to USD\n     * @param _fundRaiseType Currency key\n     * @param _amount Value to convert to USD\n     * @return uint256 Value in USD\n     */\n    function convertToUSD(FundRaiseType _fundRaiseType, uint256 _amount) public returns(uint256) {\n        return DecimalMath.mul(_amount, getRate(_fundRaiseType));\n    }\n\n    /**\n     * @notice This function converts from USD to ETH or POLY\n     * @param _fundRaiseType Currency key\n     * @param _amount Value to convert from USD\n     * @return uint256 Value in ETH or POLY\n     */\n    function convertFromUSD(FundRaiseType _fundRaiseType, uint256 _amount) public returns(uint256) {\n        return DecimalMath.div(_amount, getRate(_fundRaiseType));\n    }\n\n    /**\n     * @notice Return the total no. of tokens sold\n     * @return uint256 Total number of tokens sold\n     */\n    function getTokensSold() public view returns (uint256) {\n        if (isFinalized)\n            return totalTokensSold;\n        return getTokensMinted();\n    }\n\n    /**\n     * @notice Return the total no. of tokens minted\n     * @return uint256 Total number of tokens minted\n     */\n    function getTokensMinted() public view returns (uint256 tokensMinted) {\n        for (uint256 i = 0; i < tiers.length; i++) {\n            tokensMinted = tokensMinted.add(tiers[i].mintedTotal);\n        }\n    }\n\n    /**\n     * @notice Return the total no. of tokens sold for the given fund raise type\n     * param _fundRaiseType The fund raising currency (e.g. ETH, POLY, SC) to calculate sold tokens for\n     * @return uint256 Total number of tokens sold for ETH\n     */\n    function getTokensSoldFor(FundRaiseType _fundRaiseType) external view returns (uint256 tokensSold) {\n        for (uint256 i = 0; i < tiers.length; i++) {\n            tokensSold = tokensSold.add(tiers[i].minted[uint8(_fundRaiseType)]);\n        }\n    }\n\n    /**\n     * @notice Return array of minted tokens in each fund raise type for given tier\n     * param _tier The tier to return minted tokens for\n     * @return uint256[] array of minted tokens in each fund raise type\n     */\n    function getTokensMintedByTier(uint256 _tier) external view returns(uint256[] memory) {\n        uint256[] memory tokensMinted = new uint256[](3);\n        tokensMinted[0] = tiers[_tier].minted[uint8(FundRaiseType.ETH)];\n        tokensMinted[1] = tiers[_tier].minted[uint8(FundRaiseType.POLY)];\n        tokensMinted[2] = tiers[_tier].minted[uint8(FundRaiseType.SC)];\n        return tokensMinted;\n    }\n\n    /**\n     * @notice Return the total no. of tokens sold in a given tier\n     * param _tier The tier to calculate sold tokens for\n     * @return uint256 Total number of tokens sold in the tier\n     */\n    function getTokensSoldByTier(uint256 _tier) external view returns (uint256) {\n        uint256 tokensSold;\n        tokensSold = tokensSold.add(tiers[_tier].minted[uint8(FundRaiseType.ETH)]);\n        tokensSold = tokensSold.add(tiers[_tier].minted[uint8(FundRaiseType.POLY)]);\n        tokensSold = tokensSold.add(tiers[_tier].minted[uint8(FundRaiseType.SC)]);\n        return tokensSold;\n    }\n\n    /**\n     * @notice Return the total no. of tiers\n     * @return uint256 Total number of tiers\n     */\n    function getNumberOfTiers() external view returns (uint256) {\n        return tiers.length;\n    }\n\n    /**\n     * @notice Return the usd tokens accepted by the STO\n     * @return address[] usd tokens\n     */\n    function getUsdTokens() external view returns (IERC20[] memory) {\n        return usdTokens;\n    }\n\n    /**\n     * @notice Return the permissions flag that are associated with STO\n     */\n    function getPermissions() public view returns(bytes32[] memory allPermissions) {\n        allPermissions = new bytes32[](2);\n        allPermissions[0] = OPERATOR;\n        allPermissions[1] = ADMIN;\n        return allPermissions;\n    }\n\n    /**\n     * @notice Return the STO details\n     * @return Unixtimestamp at which offering gets start.\n     * @return Unixtimestamp at which offering ends.\n     * @return Currently active tier\n     * @return Array of Number of tokens this STO will be allowed to sell at different tiers.\n     * @return Array Rate at which tokens are sold at different tiers\n     * @return Amount of funds raised\n     * @return Number of individual investors this STO have.\n     * @return Amount of tokens sold.\n     * @return Array of bools to show if funding is allowed in ETH, POLY, SC respectively\n     */\n    function getSTODetails() external view returns(uint256, uint256, uint256, uint256[] memory, uint256[] memory, uint256, uint256, uint256, bool[] memory) {\n        uint256[] memory cap = new uint256[](tiers.length);\n        uint256[] memory rate = new uint256[](tiers.length);\n        for(uint256 i = 0; i < tiers.length; i++) {\n            cap[i] = tiers[i].tokenTotal;\n            rate[i] = tiers[i].rate;\n        }\n        bool[] memory _fundRaiseTypes = new bool[](3);\n        _fundRaiseTypes[0] = fundRaiseTypes[uint8(FundRaiseType.ETH)];\n        _fundRaiseTypes[1] = fundRaiseTypes[uint8(FundRaiseType.POLY)];\n        _fundRaiseTypes[2] = fundRaiseTypes[uint8(FundRaiseType.SC)];\n        return (\n            startTime,\n            endTime,\n            currentTier,\n            cap,\n            rate,\n            fundsRaisedUSD,\n            investorCount,\n            getTokensSold(),\n            _fundRaiseTypes\n        );\n    }\n\n    /**\n     * @notice This function returns the signature of configure function\n     * @return bytes4 Configure function signature\n     */\n    function getInitFunction() public pure returns(bytes4) {\n        return this.configure.selector;\n    }\n\n    function _getOracle(bytes32 _currency, bytes32 _denominatedCurrency) internal view returns(address oracleAddress) {\n        oracleAddress = customOracles[_currency][_denominatedCurrency];\n        if (oracleAddress == address(0))\n            oracleAddress =  IPolymathRegistry(securityToken.polymathRegistry()).getAddress(oracleKeys[_currency][_denominatedCurrency]);\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tiers\",\"outputs\":[{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"rateDiscountPoly\",\"type\":\"uint256\"},{\"name\":\"tokenTotal\",\"type\":\"uint256\"},{\"name\":\"tokensDiscountPoly\",\"type\":\"uint256\"},{\"name\":\"mintedTotal\",\"type\":\"uint256\"},{\"name\":\"mintedDiscountPoly\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tier\",\"type\":\"uint256\"}],\"name\":\"getTokensSoldByTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSTODetails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitFunction\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tier\",\"type\":\"uint256\"}],\"name\":\"getTokensMintedByTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAccreditedData\",\"outputs\":[{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"accredited\",\"type\":\"bool[]\"},{\"name\":\"overrides\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowBeneficialInvestments\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nonAccreditedLimitUSD\",\"type\":\"uint256\"},{\"name\":\"_minimumInvestmentUSD\",\"type\":\"uint256\"}],\"name\":\"modifyLimits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfTiers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allowBeneficialInvestments\",\"type\":\"bool\"}],\"name\":\"changeAllowBeneficialInvestments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyWithETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasuryWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonAccreditedLimitUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_investedPOLY\",\"type\":\"uint256\"}],\"name\":\"buyWithPOLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_investedPOLY\",\"type\":\"uint256\"},{\"name\":\"_minTokens\",\"type\":\"uint256\"}],\"name\":\"buyWithPOLYRateLimited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUsdTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalAmountReturned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_investedSC\",\"type\":\"uint256\"},{\"name\":\"_minTokens\",\"type\":\"uint256\"},{\"name\":\"_usdToken\",\"type\":\"address\"}],\"name\":\"buyWithUSDRateLimited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"polyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ratePerTier\",\"type\":\"uint256[]\"},{\"name\":\"_ratePerTierDiscountPoly\",\"type\":\"uint256[]\"},{\"name\":\"_tokensPerTierTotal\",\"type\":\"uint256[]\"},{\"name\":\"_tokensPerTierDiscountPoly\",\"type\":\"uint256[]\"}],\"name\":\"modifyTiers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stableCoinsRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_investedSC\",\"type\":\"uint256\"},{\"name\":\"_usdToken\",\"type\":\"address\"}],\"name\":\"buyWithUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fundRaiseType\",\"type\":\"uint8\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"convertToUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"investorInvested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"reclaimERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fundRaiseType\",\"type\":\"uint8\"},{\"name\":\"_oracleAddress\",\"type\":\"address\"}],\"name\":\"modifyOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fundRaiseType\",\"type\":\"uint8\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"convertFromUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OPERATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fundRaiseType\",\"type\":\"uint8\"}],\"name\":\"getRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_treasuryWallet\",\"type\":\"address\"},{\"name\":\"_usdTokens\",\"type\":\"address[]\"}],\"name\":\"modifyAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pausedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fundRaiseType\",\"type\":\"uint8\"}],\"name\":\"getTokensSoldFor\",\"outputs\":[{\"name\":\"tokensSold\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"modifyTimes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fundRaiseType\",\"type\":\"uint8\"}],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"securityToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fundRaiseTypes\",\"type\":\"uint8[]\"}],\"name\":\"modifyFunding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPermissions\",\"outputs\":[{\"name\":\"allPermissions\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"fundsRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investorInvestedUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_minTokens\",\"type\":\"uint256\"}],\"name\":\"buyWithETHRateLimited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"fundRaiseTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokensMinted\",\"outputs\":[{\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonAccreditedLimitUSDOverride\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_ratePerTier\",\"type\":\"uint256[]\"},{\"name\":\"_ratePerTierDiscountPoly\",\"type\":\"uint256[]\"},{\"name\":\"_tokensPerTierTotal\",\"type\":\"uint256[]\"},{\"name\":\"_tokensPerTierDiscountPoly\",\"type\":\"uint256[]\"},{\"name\":\"_nonAccreditedLimitUSD\",\"type\":\"uint256\"},{\"name\":\"_minimumInvestmentUSD\",\"type\":\"uint256\"},{\"name\":\"_fundRaiseTypes\",\"type\":\"uint8[]\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_treasuryWallet\",\"type\":\"address\"},{\"name\":\"_usdTokens\",\"type\":\"address[]\"}],\"name\":\"configure\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumInvestmentUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"},{\"name\":\"_nonAccreditedLimit\",\"type\":\"uint256[]\"}],\"name\":\"changeNonAccreditedLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDataStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundsRaisedUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_securityToken\",\"type\":\"address\"},{\"name\":\"_polyAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"SetAllowBeneficialInvestments\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"SetNonAccreditedLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_usdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tierPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tier\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_usdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_fundRaiseType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_receivedValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_spentValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"FundsReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_latestTier\",\"type\":\"uint256\"}],\"name\":\"ReserveTokenMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_usdTokens\",\"type\":\"address[]\"}],\"name\":\"SetAddresses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_nonAccreditedLimitUSD\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_minimumInvestmentUSD\",\"type\":\"uint256\"}],\"name\":\"SetLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"SetTimes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ratePerTier\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"_ratePerTierDiscountPoly\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"_tokensPerTierTotal\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"_tokensPerTierDiscountPoly\",\"type\":\"uint256[]\"}],\"name\":\"SetTiers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"SetTreasuryWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_fundRaiseTypes\",\"type\":\"uint8[]\"}],\"name\":\"SetFundRaiseTypes\",\"type\":\"event\"}]","ContractName":"USDTieredSTO","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://22fb791d88df9cac85dd0b977d0bad66c83b6ce208cb38e86b9fbe5ad97ffd2b"}]}