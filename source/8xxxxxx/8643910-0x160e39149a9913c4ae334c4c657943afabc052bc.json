{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\n\r\ninterface TubInterface {\r\n    function open() external returns (bytes32);\r\n    function join(uint) external;\r\n    function exit(uint) external;\r\n    function lock(bytes32, uint) external;\r\n    function free(bytes32, uint) external;\r\n    function draw(bytes32, uint) external;\r\n    function wipe(bytes32, uint) external;\r\n    function give(bytes32, address) external;\r\n    function shut(bytes32) external;\r\n    function cups(bytes32) external view returns (address, uint, uint, uint);\r\n    function gem() external view returns (TokenInterface);\r\n    function gov() external view returns (TokenInterface);\r\n    function skr() external view returns (TokenInterface);\r\n    function sai() external view returns (TokenInterface);\r\n    function ink(bytes32) external view returns (uint);\r\n    function tab(bytes32) external returns (uint);\r\n    function rap(bytes32) external returns (uint);\r\n    function per() external view returns (uint);\r\n    function pep() external view returns (PepInterface);\r\n}\r\n\r\ninterface TokenInterface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface PepInterface {\r\n    function peek() external returns (bytes32, bool);\r\n}\r\n\r\ninterface MakerOracleInterface {\r\n    function read() external view returns (bytes32);\r\n}\r\n\r\ninterface UniswapExchange {\r\n    function getEthToTokenOutputPrice(uint256 tokensBought) external view returns (uint256 ethSold);\r\n    function getTokenToEthOutputPrice(uint256 ethBought) external view returns (uint256 tokensSold);\r\n    function tokenToTokenSwapOutput(\r\n        uint256 tokensBought,\r\n        uint256 maxTokensSold,\r\n        uint256 maxEthSold,\r\n        uint256 deadline,\r\n        address tokenAddr\r\n        ) external returns (uint256  tokensSold);\r\n}\r\n\r\ninterface LiquidityInterface {\r\n    function borrowTknAndTransfer(address ctknAddr, uint tknAmt) external;\r\n    function payBorrowBack(address ctknAddr, uint tknAmt) external;\r\n}\r\n\r\ninterface CTokenInterface {\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function liquidateBorrow(address borrower, uint repayAmount, address cTokenCollateral) external returns (uint);\r\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function totalBorrowsCurrent() external returns (uint);\r\n    function borrowRatePerBlock() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n    function totalReserves() external view returns (uint);\r\n    function reserveFactorMantissa() external view returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function allowance(address, address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface CERC20Interface {\r\n    function mint(uint mintAmount) external returns (uint); // For ERC20\r\n    function repayBorrow(uint repayAmount) external returns (uint); // For ERC20\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint); // For ERC20\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n}\r\n\r\ninterface CETHInterface {\r\n    function mint() external payable; // For ETH\r\n    function repayBorrow() external payable; // For ETH\r\n    function repayBorrowBehalf(address borrower) external payable; // For ETH\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cTokenAddress) external returns (uint);\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\r\n}\r\n\r\ninterface CompOracleInterface {\r\n    function getUnderlyingPrice(address) external view returns (uint);\r\n}\r\n\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Helper is DSMath {\r\n\r\n    /**\r\n     * @dev get ethereum address for trade\r\n     */\r\n    function getAddressETH() public pure returns (address eth) {\r\n        eth = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n\r\n    /**\r\n     * @dev get MakerDAO CDP engine\r\n     */\r\n    function getSaiTubAddress() public pure returns (address sai) {\r\n        sai = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;\r\n    }\r\n\r\n    /**\r\n     * @dev get MakerDAO Oracle for ETH price\r\n     */\r\n    function getOracleAddress() public pure returns (address oracle) {\r\n        oracle = 0x729D19f657BD0614b4985Cf1D82531c67569197B;\r\n    }\r\n\r\n    /**\r\n     * @dev get uniswap MKR exchange\r\n     */\r\n    function getUniswapMKRExchange() public pure returns (address ume) {\r\n        ume = 0x2C4Bd064b998838076fa341A83d007FC2FA50957;\r\n    }\r\n\r\n    /**\r\n     * @dev get uniswap DAI exchange\r\n     */\r\n    function getUniswapDAIExchange() public pure returns (address ude) {\r\n        ude = 0x09cabEC1eAd1c0Ba254B09efb3EE13841712bE14;\r\n    }\r\n\r\n    /**\r\n     * @dev get InstaDApp Liquidity contract\r\n     */\r\n    function getLiquidityAddr() public pure returns (address liquidity) {\r\n        liquidity = 0x7281Db02c62e2966d5Cd20504B7C4C6eF4bD48E1;\r\n    }\r\n\r\n    /**\r\n     * @dev get Compound Comptroller Address\r\n     */\r\n    function getComptrollerAddress() public pure returns (address troller) {\r\n        troller = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    }\r\n\r\n    /**\r\n     * @dev get Compound Oracle Address\r\n     */\r\n    function getCompOracleAddress() public pure returns (address troller) {\r\n        troller = 0xe7664229833AE4Abf4E269b8F23a86B657E2338D;\r\n    }\r\n\r\n    /**\r\n     * @dev get CETH Address\r\n     */\r\n    function getCETHAddress() public pure returns (address cEth) {\r\n        cEth = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\r\n    }\r\n\r\n    /**\r\n     * @dev get DAI Address\r\n     */\r\n    function getDAIAddress() public pure returns (address dai) {\r\n        dai = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\r\n    }\r\n\r\n    /**\r\n     * @dev get CDAI Address\r\n     */\r\n    function getCDAIAddress() public pure returns (address cDai) {\r\n        cDai = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;\r\n    }\r\n\r\n    /**\r\n     * @dev setting allowance to compound contracts for the \"user proxy\" if required\r\n     */\r\n    function setApproval(address erc20, uint srcAmt, address to) internal {\r\n        TokenInterface erc20Contract = TokenInterface(erc20);\r\n        uint tokenAllowance = erc20Contract.allowance(address(this), to);\r\n        if (srcAmt > tokenAllowance) {\r\n            erc20Contract.approve(to, uint(-1));\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract MakerHelper is Helper {\r\n\r\n    event LogOpen(uint cdpNum, address owner);\r\n    event LogLock(uint cdpNum, uint amtETH, uint amtPETH, address owner);\r\n    event LogFree(uint cdpNum, uint amtETH, uint amtPETH, address owner);\r\n    event LogDraw(uint cdpNum, uint amtDAI, address owner);\r\n    event LogWipe(uint cdpNum, uint daiAmt, uint mkrFee, uint daiFee, address owner);\r\n    event LogShut(uint cdpNum);\r\n\r\n    /**\r\n     * @dev Allowance to Maker's contract\r\n     */\r\n    function setMakerAllowance(TokenInterface _token, address _spender) internal {\r\n        if (_token.allowance(address(this), _spender) != uint(-1)) {\r\n            _token.approve(_spender, uint(-1));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev CDP stats by Bytes\r\n     */\r\n    function getCDPStats(bytes32 cup) internal view returns (uint ethCol, uint daiDebt) {\r\n        TubInterface tub = TubInterface(getSaiTubAddress());\r\n        (, uint pethCol, uint debt,) = tub.cups(cup);\r\n        ethCol = rmul(pethCol, tub.per()); // get ETH col from PETH col\r\n        daiDebt = debt;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract CompoundHelper is MakerHelper {\r\n\r\n    event LogMint(address erc20, address cErc20, uint tokenAmt, address owner);\r\n    event LogRedeem(address erc20, address cErc20, uint tokenAmt, address owner);\r\n    event LogBorrow(address erc20, address cErc20, uint tokenAmt, address owner);\r\n    event LogRepay(address erc20, address cErc20, uint tokenAmt, address owner);\r\n\r\n    /**\r\n     * @dev Compound Enter Market which allows borrowing\r\n     */\r\n    function enterMarket(address cErc20) internal {\r\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\r\n        address[] memory markets = troller.getAssetsIn(address(this));\r\n        bool isEntered = false;\r\n        for (uint i = 0; i < markets.length; i++) {\r\n            if (markets[i] == cErc20) {\r\n                isEntered = true;\r\n            }\r\n        }\r\n        if (!isEntered) {\r\n            address[] memory toEnter = new address[](1);\r\n            toEnter[0] = cErc20;\r\n            troller.enterMarkets(toEnter);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract MakerResolver is CompoundHelper {\r\n\r\n    /**\r\n     * @dev Open new CDP\r\n     */\r\n    function open() internal returns (uint) {\r\n        bytes32 cup = TubInterface(getSaiTubAddress()).open();\r\n        emit LogOpen(uint(cup), address(this));\r\n        return uint(cup);\r\n    }\r\n\r\n    /**\r\n     * @dev transfer CDP ownership\r\n     */\r\n    function give(uint cdpNum, address nextOwner) internal {\r\n        TubInterface(getSaiTubAddress()).give(bytes32(cdpNum), nextOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Pay CDP debt\r\n     */\r\n    function wipe(uint cdpNum, uint _wad) internal returns (uint daiAmt) {\r\n        if (_wad > 0) {\r\n            TubInterface tub = TubInterface(getSaiTubAddress());\r\n            UniswapExchange daiEx = UniswapExchange(getUniswapDAIExchange());\r\n            UniswapExchange mkrEx = UniswapExchange(getUniswapMKRExchange());\r\n            TokenInterface dai = tub.sai();\r\n            TokenInterface mkr = tub.gov();\r\n\r\n            bytes32 cup = bytes32(cdpNum);\r\n\r\n            (address lad,,,) = tub.cups(cup);\r\n            require(lad == address(this), \"cup-not-owned\");\r\n\r\n            setMakerAllowance(dai, getSaiTubAddress());\r\n            setMakerAllowance(mkr, getSaiTubAddress());\r\n            setMakerAllowance(dai, getUniswapDAIExchange());\r\n\r\n            (bytes32 val, bool ok) = tub.pep().peek();\r\n\r\n            // MKR required for wipe = Stability fees accrued in Dai / MKRUSD value\r\n            uint mkrFee = wdiv(rmul(_wad, rdiv(tub.rap(cup), tub.tab(cup))), uint(val));\r\n\r\n            uint daiFeeAmt = daiEx.getTokenToEthOutputPrice(mkrEx.getEthToTokenOutputPrice(mkrFee));\r\n            daiAmt = add(_wad, daiFeeAmt);\r\n\r\n            // Getting Liquidity from Liquidity Contract\r\n            LiquidityInterface(getLiquidityAddr()).borrowTknAndTransfer(getCDAIAddress(), daiAmt);\r\n\r\n            if (ok && val != 0) {\r\n                daiEx.tokenToTokenSwapOutput(\r\n                    mkrFee,\r\n                    daiAmt,\r\n                    uint(999000000000000000000),\r\n                    uint(1899063809), // 6th March 2030 GMT // no logic\r\n                    address(mkr)\r\n                );\r\n            }\r\n\r\n            tub.wipe(cup, _wad);\r\n\r\n            emit LogWipe(\r\n                cdpNum,\r\n                daiAmt,\r\n                mkrFee,\r\n                daiFeeAmt,\r\n                address(this)\r\n            );\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw CDP\r\n     */\r\n    function free(uint cdpNum, uint jam) internal {\r\n        if (jam > 0) {\r\n            bytes32 cup = bytes32(cdpNum);\r\n            address tubAddr = getSaiTubAddress();\r\n\r\n            TubInterface tub = TubInterface(tubAddr);\r\n            TokenInterface peth = tub.skr();\r\n            TokenInterface weth = tub.gem();\r\n\r\n            uint ink = rdiv(jam, tub.per());\r\n            ink = rmul(ink, tub.per()) <= jam ? ink : ink - 1;\r\n            tub.free(cup, ink);\r\n\r\n            setMakerAllowance(peth, tubAddr);\r\n\r\n            tub.exit(ink);\r\n            uint freeJam = weth.balanceOf(address(this)); // withdraw possible previous stuck WETH as well\r\n            weth.withdraw(freeJam);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit Collateral\r\n     */\r\n    function lock(uint cdpNum, uint ethAmt) internal {\r\n        if (ethAmt > 0) {\r\n            bytes32 cup = bytes32(cdpNum);\r\n            address tubAddr = getSaiTubAddress();\r\n\r\n            TubInterface tub = TubInterface(tubAddr);\r\n            TokenInterface weth = tub.gem();\r\n            TokenInterface peth = tub.skr();\r\n\r\n            (address lad,,,) = tub.cups(cup);\r\n            require(lad == address(this), \"cup-not-owned\");\r\n\r\n            weth.deposit.value(ethAmt)();\r\n\r\n            uint ink = rdiv(ethAmt, tub.per());\r\n            ink = rmul(ink, tub.per()) <= ethAmt ? ink : ink - 1;\r\n\r\n            setMakerAllowance(weth, tubAddr);\r\n            tub.join(ink);\r\n\r\n            setMakerAllowance(peth, tubAddr);\r\n            tub.lock(cup, ink);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Borrow DAI Debt\r\n     */\r\n    function draw(uint cdpNum, uint _wad) internal {\r\n        bytes32 cup = bytes32(cdpNum);\r\n        if (_wad > 0) {\r\n            TubInterface tub = TubInterface(getSaiTubAddress());\r\n\r\n            tub.draw(cup, _wad);\r\n\r\n            // Returning Liquidity To Liquidity Contract\r\n            require(TokenInterface(getDAIAddress()).transfer(getLiquidityAddr(), _wad), \"Not-enough-DAI\");\r\n            LiquidityInterface(getLiquidityAddr()).payBorrowBack(getCDAIAddress(), _wad);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Check if entered amt is valid or not (Used in makerToCompound)\r\n     */\r\n    function checkCDP(bytes32 cup, uint ethAmt, uint daiAmt) internal returns (uint ethCol, uint daiDebt) {\r\n        TubInterface tub = TubInterface(getSaiTubAddress());\r\n        ethCol = rmul(tub.ink(cup), tub.per()) - 1; // get ETH col from PETH col\r\n        daiDebt = tub.tab(cup);\r\n        daiDebt = daiAmt < daiDebt ? daiAmt : daiDebt; // if DAI amount > max debt. Set max debt\r\n        ethCol = ethAmt < ethCol ? ethAmt : ethCol; // if ETH amount > max Col. Set max col\r\n    }\r\n\r\n    /**\r\n     * @dev Run wipe & Free function together\r\n     */\r\n    function wipeAndFreeMaker(uint cdpNum, uint jam, uint _wad) internal returns (uint daiAmt) {\r\n        daiAmt = wipe(cdpNum, _wad);\r\n        free(cdpNum, jam);\r\n    }\r\n\r\n    /**\r\n     * @dev Run Lock & Draw function together\r\n     */\r\n    function lockAndDrawMaker(uint cdpNum, uint jam, uint _wad) internal {\r\n        lock(cdpNum, jam);\r\n        draw(cdpNum, _wad);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract CompoundResolver is MakerResolver {\r\n\r\n    /**\r\n     * @dev Deposit ETH and mint CETH\r\n     */\r\n    function mintCEth(uint tokenAmt) internal {\r\n        enterMarket(getCETHAddress());\r\n        CETHInterface cToken = CETHInterface(getCETHAddress());\r\n        cToken.mint.value(tokenAmt)();\r\n        emit LogMint(\r\n            getAddressETH(),\r\n            getCETHAddress(),\r\n            tokenAmt,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev borrow DAI\r\n     */\r\n    function borrowDAIComp(uint daiAmt) internal {\r\n        enterMarket(getCDAIAddress());\r\n        require(CTokenInterface(getCDAIAddress()).borrow(daiAmt) == 0, \"got collateral?\");\r\n        // Returning Liquidity to Liquidity Contract\r\n        require(TokenInterface(getDAIAddress()).transfer(getLiquidityAddr(), daiAmt), \"Not-enough-DAI\");\r\n        LiquidityInterface(getLiquidityAddr()).payBorrowBack(getCDAIAddress(), daiAmt);\r\n        emit LogBorrow(\r\n            getDAIAddress(),\r\n            getCDAIAddress(),\r\n            daiAmt,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Pay DAI Debt\r\n     */\r\n    function repayDaiComp(uint tokenAmt) internal returns (uint wipeAmt) {\r\n        CERC20Interface cToken = CERC20Interface(getCDAIAddress());\r\n        uint daiBorrowed = cToken.borrowBalanceCurrent(address(this));\r\n        wipeAmt = tokenAmt < daiBorrowed ? tokenAmt : daiBorrowed;\r\n        // Getting Liquidity from Liquidity Contract\r\n        LiquidityInterface(getLiquidityAddr()).borrowTknAndTransfer(getCDAIAddress(), wipeAmt);\r\n        setApproval(getDAIAddress(), wipeAmt, getCDAIAddress());\r\n        require(cToken.repayBorrow(wipeAmt) == 0, \"transfer approved?\");\r\n        emit LogRepay(\r\n            getDAIAddress(),\r\n            getCDAIAddress(),\r\n            wipeAmt,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Redeem CETH\r\n     * @param tokenAmt Amount of token To Redeem\r\n     */\r\n    function redeemCETH(uint tokenAmt) internal returns(uint ethAmtReddemed) {\r\n        CTokenInterface cToken = CTokenInterface(getCETHAddress());\r\n        uint cethBal = cToken.balanceOf(address(this));\r\n        uint exchangeRate = cToken.exchangeRateCurrent();\r\n        uint cethInEth = wmul(cethBal, exchangeRate);\r\n        setApproval(getCETHAddress(), 2**128, getCETHAddress());\r\n        ethAmtReddemed = tokenAmt;\r\n        if (tokenAmt > cethInEth) {\r\n            require(cToken.redeem(cethBal) == 0, \"something went wrong\");\r\n            ethAmtReddemed = cethInEth;\r\n        } else {\r\n            require(cToken.redeemUnderlying(tokenAmt) == 0, \"something went wrong\");\r\n        }\r\n        emit LogRedeem(\r\n            getAddressETH(),\r\n            getCETHAddress(),\r\n            ethAmtReddemed,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev run mint & borrow together\r\n     */\r\n    function mintAndBorrowComp(uint ethAmt, uint daiAmt) internal {\r\n        mintCEth(ethAmt);\r\n        borrowDAIComp(daiAmt);\r\n    }\r\n\r\n    /**\r\n     * @dev run payback & redeem together\r\n     */\r\n    function paybackAndRedeemComp(uint ethCol, uint daiDebt) internal returns (uint ethAmt, uint daiAmt) {\r\n        daiAmt = repayDaiComp(daiDebt);\r\n        ethAmt = redeemCETH(ethCol);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if entered amt is valid or not (Used in makerToCompound)\r\n     */\r\n    function checkCompound(uint ethAmt, uint daiAmt) internal returns (uint ethCol, uint daiDebt) {\r\n        CTokenInterface cEthContract = CTokenInterface(getCETHAddress());\r\n        uint cEthBal = cEthContract.balanceOf(address(this));\r\n        uint ethExchangeRate = cEthContract.exchangeRateCurrent();\r\n        ethCol = wmul(cEthBal, ethExchangeRate);\r\n        ethCol = wdiv(ethCol, ethExchangeRate) <= cEthBal ? ethCol : ethCol - 1;\r\n        ethCol = ethCol <= ethAmt ? ethCol : ethAmt; // Set Max if amount is greater than the Col user have\r\n\r\n        daiDebt = CERC20Interface(getCDAIAddress()).borrowBalanceCurrent(address(this));\r\n        daiDebt = daiDebt <= daiAmt ? daiDebt : daiAmt; // Set Max if amount is greater than the Debt user have\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract InstaMakerCompBridge is CompoundResolver {\r\n\r\n    event LogMakerToCompound(uint ethAmt, uint daiAmt);\r\n    event LogCompoundToMaker(uint ethAmt, uint daiAmt);\r\n\r\n    /**\r\n     * @dev convert Maker CDP into Compound Collateral\r\n     */\r\n    function makerToCompound(uint cdpId, uint ethQty, uint daiQty) external {\r\n        (uint ethAmt, uint daiDebt) = checkCDP(bytes32(cdpId), ethQty, daiQty);\r\n        uint daiAmt = wipeAndFreeMaker(cdpId, ethAmt, daiDebt); // Getting Liquidity inside Wipe function\r\n        enterMarket(getCETHAddress());\r\n        enterMarket(getCDAIAddress());\r\n        mintAndBorrowComp(ethAmt, daiAmt); // Returning Liquidity inside Borrow function\r\n        emit LogMakerToCompound(ethAmt, daiAmt);\r\n    }\r\n\r\n    /**\r\n     * @dev convert Compound Collateral into Maker CDP\r\n     * @param cdpId = 0, if user don't have any CDP\r\n     */\r\n    function compoundToMaker(uint cdpId, uint ethQty, uint daiQty) external {\r\n        uint cdpNum = cdpId > 0 ? cdpId : open();\r\n        (uint ethCol, uint daiDebt) = checkCompound(ethQty, daiQty);\r\n        (uint ethAmt, uint daiAmt) = paybackAndRedeemComp(ethCol, daiDebt); // Getting Liquidity inside Wipe function\r\n        ethAmt = ethAmt < address(this).balance ? ethAmt : address(this).balance;\r\n        lockAndDrawMaker(cdpNum, ethAmt, daiAmt); // Returning Liquidity inside Borrow function\r\n        emit LogCompoundToMaker(ethAmt, daiAmt);\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getComptrollerAddress\",\"outputs\":[{\"name\":\"troller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCompOracleAddress\",\"outputs\":[{\"name\":\"troller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"uint256\"},{\"name\":\"ethQty\",\"type\":\"uint256\"},{\"name\":\"daiQty\",\"type\":\"uint256\"}],\"name\":\"makerToCompound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUniswapMKRExchange\",\"outputs\":[{\"name\":\"ume\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLiquidityAddr\",\"outputs\":[{\"name\":\"liquidity\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressETH\",\"outputs\":[{\"name\":\"eth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOracleAddress\",\"outputs\":[{\"name\":\"oracle\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"uint256\"},{\"name\":\"ethQty\",\"type\":\"uint256\"},{\"name\":\"daiQty\",\"type\":\"uint256\"}],\"name\":\"compoundToMaker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCETHAddress\",\"outputs\":[{\"name\":\"cEth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUniswapDAIExchange\",\"outputs\":[{\"name\":\"ude\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDAIAddress\",\"outputs\":[{\"name\":\"dai\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSaiTubAddress\",\"outputs\":[{\"name\":\"sai\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCDAIAddress\",\"outputs\":[{\"name\":\"cDai\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ethAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiAmt\",\"type\":\"uint256\"}],\"name\":\"LogMakerToCompound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ethAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiAmt\",\"type\":\"uint256\"}],\"name\":\"LogCompoundToMaker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cErc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cErc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cErc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogBorrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cErc20\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogRepay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtPETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtPETH\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogFree\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amtDAI\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogDraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mkrFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogWipe\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"}],\"name\":\"LogShut\",\"type\":\"event\"}]","ContractName":"InstaMakerCompBridge","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://58bb91de15d21fe063eaba61a6618cff80dbf0713a0e4fc3e912b8e8e96ffd26"}]}