{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.5;\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @title ERC165\r\n * @author Matt Condon (@shrugs)\r\n * @dev Implements ERC165 using a lookup table.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    /**\r\n     * 0x01ffc9a7 ===\r\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\r\n     */\r\n\r\n    /**\r\n     * @dev a mapping of interface id to whether or not it's supported\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    /**\r\n     * @dev A contract implementing SupportsInterfaceWithLookup\r\n     * implement ERC165 itself\r\n     */\r\n    constructor () internal {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev implement supportsInterface(bytes4) using a lookup table\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev internal method for registering an interface\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff);\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n        public returns (bytes4);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) public _tokenOwner;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => uint256) public _ownedTokensCount;\r\n\r\n    bytes4 internal constant _INTERFACE_ID_ERC721 = 0xab7fecf1;\r\n    /*\r\n     * 0xab7fecf1 ===\r\n     *     bytes4(keccak256('balanceOf(address)')) ^\r\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n     */\r\n\r\n    constructor () public {\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0));\r\n        return _ownedTokensCount[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return owner address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        require(ownerOf(tokenId) == from);\r\n        require(to != address(0));\r\n        require(_checkOnERC721Received(from, to, tokenId, _data));\r\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\r\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\r\n        _tokenOwner[tokenId] = to;\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return whether the token exists\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0));\r\n        require(!_exists(tokenId));\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to]= _ownedTokensCount[to].add(1);\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address\r\n     * The call is not executed if the target address is not a contract\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        internal returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\r\n\r\n    // Token class name e.g. \"2019 Coachella Gathering Trophies\" \r\n    string internal _name;\r\n\r\n    // Token class symbol e.g. \"CGT19\"\r\n    string internal _symbol;\r\n\r\n    // Mapping for token URIs\r\n    mapping(uint256 => string) internal _tokenURIs;\r\n\r\n    // // Optional mapping for token names\r\n    mapping(uint256 => string) internal _tokenNames;\r\n\r\n    bytes4 internal constant _INTERFACE_ID_ERC721_METADATA = 0xbc7bebe8;\r\n    /**\r\n     * 0xbc7bebe8 ===\r\n     *     bytes4(keccak256('name()')) ^\r\n     *     bytes4(keccak256('symbol()')) ^\r\n     *     bytes4(keccak256('tokenURI(uint256)')) ^\r\n     *     bytes4(keccak256('tokenName(uint256)'))\r\n     */\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token name\r\n     * @return string representing the token name\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol\r\n     * @return string representing the token symbol\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an URI for a given token ID\r\n     * Throws if the token ID does not exist. May return an empty string.\r\n     * @param tokenId uint256 ID of the token to query\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId));\r\n        return _tokenURIs[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a trophy name for a given token ID\r\n     * Throws if the token ID does not exist. May return an empty string.\r\n     * @param tokenId uint256 ID of the token to query\r\n     */\r\n    function tokenName(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId));\r\n        return _tokenNames[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the token URI for a given token\r\n     * Reverts if the token ID does not exist\r\n     * @param tokenId uint256 ID of the token to set its URI\r\n     * @param uri string URI to assign\r\n     */\r\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\r\n        require(_exists(tokenId));\r\n        _tokenURIs[tokenId] = uri;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that extracts the part of a string based on the desired length and offset. The\r\n     *      offset and length must not exceed the lenth of the base string.\r\n     * \r\n     * @param _base When being used for a data type this is the extended object\r\n     *              otherwise this is the string that will be used for \r\n     *              extracting the sub string from\r\n     * @param _length The length of the sub string to extract\r\n     * @param _offset The starting point to extract the sub string from\r\n     * @return string The extracted sub string\r\n     */\r\n\r\n    function _substring(string memory _base, int _length, int _offset) internal pure returns (string memory) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n\r\n        assert(uint(_offset+_length) <= _baseBytes.length);\r\n\r\n        string memory _tmp = new string(uint(_length));\r\n        bytes memory _tmpBytes = bytes(_tmp);\r\n\r\n        uint j = 0;\r\n            for(uint i = uint(_offset); i < uint(_offset+_length); i++) {\r\n                _tmpBytes[j++] = _baseBytes[i];\r\n            }\r\n            return string(_tmpBytes);\r\n        }\r\n}\r\n\r\n/**\r\n * @title Gather Standard Trophies - Gathering-based Non-Fungible ERC721 Tokens \r\n * @author Victor Rortvedt (@vrortvedt)\r\n * This implementation includes all the required and some optional functionality of the ERC721 standard\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract GatherStandardTrophies is ERC721, ERC721Metadata {\r\n\r\n    // Address of contract deployer/trophy minter\r\n    address public creator;\r\n\r\n     /**\r\n     * @dev Modifier limiting certain functions to creator address\r\n     */\r\n    modifier onlyCreator() {\r\n        require(creator == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        creator = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Mints six standard trophies at conclusion of gathering\r\n     * @param winners Array containing six addresses of trophy winners \r\n     * @param uri String containing ordered list of all trophies' URI info, in 59 character length chunks pointing to ipfs URL\r\n     */\r\n    function mintStandardTrophies(address[] memory winners, string memory uri) public onlyCreator {\r\n        mintSchmoozerTrophy((winners[0]), _substring(uri,59,0));\r\n        mintCupidTrophy((winners[1]), _substring(uri,59,59));\r\n        mintMVPTrophy((winners[2]), _substring(uri,59,118));\r\n        mintHumanRouterTrophy((winners[3]), _substring(uri,59,177));\r\n        mintOracleTrophy((winners[4]), _substring(uri,59,236));\r\n        mintKevinBaconTrophy((winners[5]), _substring(uri,59,295));\r\n    }\r\n\r\n    /**\r\n     * @dev Public function that mints Schmoozer trophy at conclusion of gathering to gatherNode with most connections made\r\n     * @param winner Address of trophy winner \r\n     * @param uri String containing IPFS link to URI info\r\n     */\r\n    function mintSchmoozerTrophy(address winner, string memory uri) public onlyCreator {\r\n        _mint(winner, 1);\r\n        _tokenNames[1] = \"Schmoozer Trophy\";\r\n        _tokenURIs[1] = uri;\r\n    }\r\n\r\n    /**\r\n     * @dev Public function that mints Cupid trophy at conclusion of gathering to gatherNode with most matches made\r\n     * @param winner Address of trophy winner \r\n     * @param uri String containing IPFS link to URI info\r\n     */\r\n    function mintCupidTrophy(address winner, string memory uri) public onlyCreator  {\r\n        _mint(winner, 2);\r\n        _tokenNames[2] = \"Cupid Trophy\";\r\n        _tokenURIs[2] = uri;\r\n    } \r\n    \r\n    /**\r\n     * @dev Public function that mints  MVP trophy at conclusion of gathering to gatherNode with most total points\r\n     * @param winner Address of trophy winner \r\n     * @param uri String containing IPFS link to URI info\r\n     */ \r\n    function mintMVPTrophy(address winner, string memory uri) public onlyCreator {\r\n        _mint(winner, 3);\r\n        _tokenNames[3] = \"MVP Trophy\";\r\n        _tokenURIs[3] = uri;\r\n    } \r\n\r\n    /**\r\n     * @dev Public function that mints Human Router trophy at conclusion of gathering to gatherNode with most recommendations made\r\n     * @param winner Address of trophy winner \r\n     * @param uri String containing IPFS link to URI info\r\n     */\r\n    function mintHumanRouterTrophy(address winner, string memory uri) public onlyCreator {\r\n        _mint(winner, 4);\r\n        _tokenNames[4] = \"Human Router Trophy\";\r\n        _tokenURIs[4] = uri;\r\n    }\r\n    \r\n    /**\r\n     * @dev Public function that mints Oracle trophy at conclusion of gathering to gatherNode with most supermatches \r\n     * @param winner Address of trophy winner \r\n     * @param uri String containing IPFS link to URI info\r\n     */\r\n    function mintOracleTrophy(address winner, string memory uri) public onlyCreator {\r\n        _mint(winner, 5);\r\n        _tokenNames[5] = \"Oracle Trophy\";\r\n        _tokenURIs[5] = uri;\r\n    } \r\n\r\n\r\n    /**\r\n     * @dev Public function that mints Kevin Bacon trophy at conclusion of gathering \r\n     * to gatherNode with fewest average degrees of separation from all other gatherNodes\r\n     * @param winner Address of trophy winner \r\n     * @param uri String containing IPFS link to URI info\r\n     */\r\n    function mintKevinBaconTrophy(address winner, string memory uri) public onlyCreator {\r\n        _mint(winner, 6);\r\n        _tokenNames[6] = \"Kevin Bacon Trophy\";\r\n        _tokenURIs[6] = uri;\r\n    }   \r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"mintCupidTrophy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_tokenOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"mintOracleTrophy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"winners\",\"type\":\"address[]\"},{\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"mintStandardTrophies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"mintKevinBaconTrophy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"mintHumanRouterTrophy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"mintSchmoozerTrophy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"mintMVPTrophy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_ownedTokensCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"GatherStandardTrophies","CompilerVersion":"v0.5.5+commit.47a71e8f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000021495046532043616d70203230313920476174686572696e672054726f70686965730000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000064950465347540000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://5d450e2c89e8f18c76561d646af971cb4415d54ceb240f34b500a3ff2b9bfff1"}]}