{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\r\n\r\n\r\ninterface ERC20 {\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n/// @title Kyber Reserve contract\r\ninterface KyberReserveInterface {\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address payable destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        external\r\n        payable\r\n        returns(bool);\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) external view returns(uint);\r\n}\r\n\r\ncontract OtcInterface {\r\n    function getOffer(uint id) external view returns (uint, ERC20, uint, ERC20);\r\n    function getBestOffer(ERC20 sellGem, ERC20 buyGem) external view returns(uint);\r\n    function getWorseOffer(uint id) external view returns(uint);\r\n    function take(bytes32 id, uint128 maxTakeAmount) external;\r\n}\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        emit TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        emit TransferAdminPending(newAdmin);\r\n        emit AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        emit AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n}\r\n\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        emit TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address payable sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        emit EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\n\r\ncontract WethInterface is ERC20 {\r\n    function deposit() public payable;\r\n    function withdraw(uint) public;\r\n}\r\n\r\ninterface UniswapExchange {\r\n    function ethToTokenSwapInput(\r\n        uint256 min_tokens,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256  tokens_bought);\r\n\r\n    function tokenToEthSwapInput(\r\n        uint256 tokens_sold,\r\n        uint256 min_eth,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (uint256  eth_bought);\r\n\r\n    function getEthToTokenInputPrice(\r\n        uint256 eth_sold\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 tokens_bought);\r\n\r\n    function getTokenToEthInputPrice(\r\n        uint256 tokens_sold\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 eth_bought);\r\n}\r\n\r\n\r\ninterface UniswapFactory {\r\n    function getExchange(address token) external view returns (address exchange);\r\n}\r\n\r\n\r\ncontract UniswapOasisBridgeReserve is KyberReserveInterface, Withdrawable {\r\n\r\n    // constants\r\n    uint constant internal INVALID_ID = uint(-1);\r\n    uint constant internal POW_2_32 = 2 ** 32;\r\n    uint constant internal POW_2_96 = 2 ** 96;\r\n    uint constant internal BPS = 10000; // 10^4\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n\r\n    // values\r\n    address public kyberNetwork;\r\n    bool public tradeEnabled = true;\r\n    uint public feeBps = 50; // 0.5%\r\n\r\n    OtcInterface public otc = OtcInterface(0x39755357759cE0d7f32dC8dC45414CCa409AE24e);\r\n    WethInterface public wethToken = WethInterface(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    UniswapFactory public uniswapFactory = UniswapFactory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);\r\n\r\n    mapping(address => bool) public isTokenListed;\r\n    // split between uniswap + oasis\r\n    mapping(address => uint) public tokenSplitPercentage;\r\n    mapping(address => address) public tokenExchange;\r\n    // basicData contains compact data of min eth support, max traverse and max takes\r\n    // min eth support (first 192 bits) + max traverse (32 bits) + max takes (32 bits) = 256 bits\r\n    mapping(address => uint) internal tokenBasicData;\r\n\r\n    struct BasicDataConfig {\r\n        uint minETHSupport;\r\n        uint maxTraverse;\r\n        uint maxTakes;\r\n    }\r\n\r\n    struct OfferData {\r\n        uint payAmount;\r\n        uint buyAmount;\r\n        uint id;\r\n    }\r\n\r\n    constructor(address _kyberNetwork, uint _feeBps, address _admin) public {\r\n        require(wethToken.approve(address(otc), 2**255), \"constructor: failed to approve otc (wethToken)\");\r\n\r\n        kyberNetwork = _kyberNetwork;\r\n        feeBps = _feeBps;\r\n        admin = _admin;\r\n        tradeEnabled = true;\r\n    }\r\n\r\n    function() external payable {} // solhint-disable-line no-empty-blocks\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint) public view returns(uint) {\r\n        if (!tradeEnabled) { return 0; }\r\n        if (srcQty == 0) { return 0; }\r\n\r\n        ERC20 token = src == ETH_TOKEN_ADDRESS ? dest : src;\r\n        uint firstQty = srcQty * tokenSplitPercentage[address(token)] / 100;\r\n\r\n        (, uint destAmountUni) = getConversionRateUniswap(src, dest, firstQty);\r\n        (, uint destAmountOasis) = getConversionRateOasis(src, dest, srcQty - firstQty);\r\n\r\n        uint totalDest = destAmountUni + destAmountOasis;\r\n        if (destAmountUni == 0 || destAmountOasis == 0) { totalDest = 0; }\r\n\r\n        (, uint allAmountUni) = getConversionRateUniswap(src, dest, srcQty);\r\n        (, uint allAmountOasis) = getConversionRateOasis(src, dest, srcQty);\r\n\r\n        uint destQty = totalDest;\r\n        if (destQty < allAmountUni) {\r\n            destQty = allAmountUni;\r\n        }\r\n        if (destQty < allAmountOasis) {\r\n            destQty = allAmountOasis;\r\n        }\r\n        uint rate = calcRateFromQty(srcQty, destQty, MAX_DECIMALS, MAX_DECIMALS);\r\n        rate -= rate % 4;\r\n        if (rate == 0) { return rate; }\r\n        if (destQty == totalDest) { return rate; }\r\n        if (destQty == allAmountUni) { rate -= 1; }\r\n        if (destQty == allAmountOasis) { rate -= 2; }\r\n        return rate;\r\n    }\r\n\r\n    function getConversionRateOasis(ERC20 src, ERC20 dest, uint srcQty) public view returns(uint rate, uint destAmount) {\r\n        if (!tradeEnabled || srcQty == 0) {\r\n            rate = 0;\r\n            destAmount = 0;\r\n            return (rate, destAmount);\r\n        }\r\n        // check if token's listed\r\n        ERC20 token = src == ETH_TOKEN_ADDRESS ? dest : src;\r\n        if (!isTokenListed[address(token)]) {\r\n            rate = 0;\r\n            destAmount = 0;\r\n            return (rate, destAmount);\r\n        }\r\n        \r\n        OfferData memory bid;\r\n        OfferData memory ask;\r\n        (bid, ask) = getFirstBidAndAskOrders(token);\r\n\r\n        OfferData[] memory offers;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            (destAmount, offers) = findBestOffers(dest, wethToken, srcQty, bid, ask);\r\n        } else {\r\n            (destAmount, offers) = findBestOffers(wethToken, src, srcQty, bid, ask);\r\n        }\r\n\r\n        if (offers.length == 0 || destAmount == 0) {\r\n            rate = 0;\r\n            destAmount = 0;\r\n            return (rate, destAmount);\r\n        }\r\n\r\n        destAmount = valueAfterReducingFee(destAmount);\r\n        rate = calcRateFromQty(srcQty, destAmount, MAX_DECIMALS, MAX_DECIMALS);\r\n\r\n        return (rate, destAmount);\r\n    }\r\n\r\n    function getConversionRateUniswap(ERC20 src, ERC20 dest, uint srcQty)\r\n        public\r\n        view\r\n        returns(uint rate, uint destAmount)\r\n    {\r\n        (rate, destAmount) = calcUniswapConversion(src, dest, srcQty);\r\n        return (rate, destAmount);\r\n    }\r\n\r\n    function getConversionRateWithPercentage(ERC20 src, ERC20 dest, uint srcQty, uint percentage) \r\n        public\r\n        view\r\n        returns(uint rateUniswap, uint rateOasis, uint rate, uint totalDestAmount)\r\n    {\r\n        uint firstQty = srcQty * percentage / 100;\r\n        uint destAmountUni;\r\n        uint destAmountOasis;\r\n        (rateUniswap, destAmountUni) = getConversionRateUniswap(src, dest, firstQty);\r\n        (rateOasis, destAmountOasis) = getConversionRateOasis(src, dest, srcQty - firstQty);\r\n        totalDestAmount = destAmountUni + destAmountOasis;\r\n        rate = calcRateFromQty(srcQty, totalDestAmount, MAX_DECIMALS, MAX_DECIMALS);\r\n    }\r\n\r\n    function calcUniswapConversion(\r\n        ERC20 src,\r\n        ERC20 dest,\r\n        uint srcQty\r\n    )\r\n        internal\r\n        view\r\n        returns(uint rate, uint destQty)\r\n    {\r\n        UniswapExchange exchange;\r\n        ERC20 token = src == ETH_TOKEN_ADDRESS ? dest : src;\r\n        if (tokenExchange[address(token)] == address(0)) {\r\n            rate = 0;\r\n            destQty = 0;\r\n            return (rate, destQty);\r\n        }\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            exchange = UniswapExchange(tokenExchange[address(dest)]);\r\n            destQty = exchange.getEthToTokenInputPrice(srcQty);\r\n        } else {\r\n            exchange = UniswapExchange(tokenExchange[address(src)]);\r\n            destQty = exchange.getTokenToEthInputPrice(srcQty);\r\n        }\r\n\r\n        destQty = valueAfterReducingFee(destQty);\r\n\r\n        rate = calcRateFromQty(\r\n            srcQty, /* srcAmount */\r\n            destQty, /* destAmount */\r\n            getDecimals(src), /* srcDecimals */\r\n            getDecimals(dest) /* dstDecimals */\r\n        );\r\n\r\n        return (rate, destQty);\r\n    }\r\n\r\n    event TradeExecute(\r\n        address indexed origin,\r\n        address src,\r\n        uint srcAmount,\r\n        address destToken,\r\n        uint destAmount,\r\n        address payable destAddress\r\n    );\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address payable destAddress,\r\n        uint conversionRate,\r\n        bool\r\n    )\r\n        public\r\n        payable\r\n        returns(bool)\r\n    {\r\n        require(tradeEnabled, \"trade: tradeEnabled is false\");\r\n        require(msg.sender == kyberNetwork, \"trade: not call from kyberNetwork's contract\");\r\n        require(srcToken == ETH_TOKEN_ADDRESS || destToken == ETH_TOKEN_ADDRESS, \"trade: srcToken or destToken must be ETH\");\r\n\r\n        ERC20 token = srcToken == ETH_TOKEN_ADDRESS ? destToken : srcToken;\r\n        require(isTokenListed[address(token)], \"trade: token is not listed\");\r\n\r\n        if (srcToken == ETH_TOKEN_ADDRESS) {\r\n            require(msg.value == srcAmount, \"trade: ETH amount is not correct\");\r\n        } else {\r\n            // collect token\r\n            require(srcToken.transferFrom(msg.sender, address(this), srcAmount));\r\n        }\r\n\r\n        uint srcBalBefore;\r\n        uint destBalBefore;\r\n        if (srcToken == ETH_TOKEN_ADDRESS) {\r\n            srcBalBefore = address(this).balance;\r\n            destBalBefore = destToken.balanceOf(address(this));\r\n        } else {\r\n            srcBalBefore = srcToken.balanceOf(address(this));\r\n            destBalBefore = address(this).balance;\r\n        }\r\n\r\n        uint totalDestAmount;\r\n\r\n        if (conversionRate % 4 == 0) {\r\n            uint firstQty = srcAmount * tokenSplitPercentage[address(token)] / 100;\r\n            totalDestAmount = doTradeUniswap(srcToken, destToken, firstQty);\r\n            uint oasisSwapDestAmt = doTradeOasis(srcToken, destToken, srcAmount - firstQty);\r\n            totalDestAmount += oasisSwapDestAmt;\r\n        } else if (conversionRate % 2 == 0) {\r\n            totalDestAmount = doTradeOasis(srcToken, destToken, srcAmount);\r\n        } else {\r\n            totalDestAmount = doTradeUniswap(srcToken, destToken, srcAmount);\r\n        }\r\n\r\n        uint expectedDestAmount = calcDestAmount(\r\n            srcToken, /* src */\r\n            destToken, /* dest */\r\n            srcAmount, /* srcAmount */\r\n            conversionRate /* rate */\r\n        );\r\n\r\n        require(totalDestAmount >= expectedDestAmount, \"not enough dest amount\");\r\n\r\n        uint srcBalAfter;\r\n        uint destBalAfter;\r\n\r\n        if (srcToken == ETH_TOKEN_ADDRESS) {\r\n            srcBalAfter = address(this).balance;\r\n            destBalAfter = destToken.balanceOf(address(this));\r\n        } else {\r\n            srcBalAfter = srcToken.balanceOf(address(this));\r\n            destBalAfter = address(this).balance;\r\n        }\r\n\r\n        require(srcBalAfter >= srcBalBefore - srcAmount, \"src bal is not correct\");\r\n        require(destBalAfter >= destBalBefore + expectedDestAmount, \"dest bal is not correct\");\r\n\r\n        // transfer exact expected dest amount\r\n        if (destToken == ETH_TOKEN_ADDRESS) {\r\n            destAddress.transfer(expectedDestAmount);\r\n        } else {\r\n            require(destToken.transfer(destAddress, expectedDestAmount));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    event TokenConfigDataSet(\r\n        ERC20 token, uint maxTraverse,\r\n        uint maxTake,\r\n        uint minETHSupport\r\n    );\r\n\r\n    function setTokenConfigData(\r\n        ERC20 token,\r\n        uint maxTraverse,\r\n        uint maxTake,\r\n        uint minETHSupport\r\n    )\r\n        public onlyAdmin\r\n    {\r\n        address tokenAddr = address(token);\r\n        require(isTokenListed[tokenAddr]);\r\n        tokenBasicData[tokenAddr] = encodeTokenBasicData(minETHSupport, maxTraverse, maxTake);\r\n        emit TokenConfigDataSet(\r\n            token, maxTraverse,\r\n            maxTake, minETHSupport\r\n        );\r\n    }\r\n\r\n    function doTradeUniswap(ERC20 src, ERC20 dest, uint srcQty) internal returns(uint destAmount) {\r\n        UniswapExchange exchange;\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            // Deduct fees (in ETH) before converting\r\n            if (tokenExchange[address(dest)] == address(0)) {\r\n                destAmount = 0;\r\n            } else {\r\n                exchange = UniswapExchange(tokenExchange[address(dest)]);\r\n                destAmount = exchange.ethToTokenSwapInput.value(srcQty)(\r\n                    1, /* min_tokens: uniswap requires it to be > 0 */\r\n                    2 ** 255 /* deadline */\r\n                );\r\n            }\r\n        } else {\r\n            if (tokenExchange[address(src)] == address(0)) {\r\n                destAmount = 0;\r\n            } else {\r\n                exchange = UniswapExchange(tokenExchange[address(src)]);\r\n                destAmount = exchange.tokenToEthSwapInput(\r\n                    srcQty,\r\n                    1, /* min_eth: uniswap requires it to be > 0 */\r\n                    2 ** 255 /* deadline */\r\n                );\r\n            }\r\n        }\r\n        return destAmount;\r\n    }\r\n\r\n    function doTradeOasis(\r\n        ERC20 srcToken,\r\n        ERC20 destToken,\r\n        uint srcAmount\r\n    )\r\n        internal\r\n        returns(uint)\r\n    {\r\n\r\n        uint actualDestAmount;\r\n\r\n        OfferData memory bid;\r\n        OfferData memory ask;\r\n        (bid, ask) = getFirstBidAndAskOrders(srcToken == ETH_TOKEN_ADDRESS ? destToken : srcToken);\r\n\r\n        // get offers to take\r\n        OfferData[] memory offers;\r\n        if (srcToken == ETH_TOKEN_ADDRESS) {\r\n            (actualDestAmount, offers) = findBestOffers(destToken, wethToken, srcAmount, bid, ask);   \r\n        } else {\r\n            (actualDestAmount, offers) = findBestOffers(wethToken, srcToken, srcAmount, bid, ask);\r\n        }\r\n\r\n        if (srcToken == ETH_TOKEN_ADDRESS) {\r\n            wethToken.deposit.value(msg.value)();\r\n            actualDestAmount = takeMatchingOrders(destToken, srcAmount, offers);\r\n        } else {\r\n            actualDestAmount = takeMatchingOrders(wethToken, srcAmount, offers);\r\n            wethToken.withdraw(actualDestAmount);\r\n        }\r\n\r\n        return actualDestAmount;\r\n    }\r\n\r\n    event TradeEnabled(bool enable);\r\n\r\n    function enableTrade(bool isEnabled) public onlyAdmin returns(bool) {\r\n        tradeEnabled = isEnabled;\r\n        emit TradeEnabled(isEnabled);\r\n        return true;\r\n    }\r\n\r\n    event ContractsSet(address kyberNetwork, address otc);\r\n\r\n    function setContracts(address _kyberNetwork, address _otc, address _uniswapFactory) public onlyAdmin {\r\n        require(_kyberNetwork != address(0), \"setContracts: kyberNetwork's address is missing\");\r\n        require(_otc != address(0), \"setContracts: otc's address is missing\");\r\n\r\n        kyberNetwork = _kyberNetwork;\r\n        otc = OtcInterface(_otc);\r\n        uniswapFactory = UniswapFactory(_uniswapFactory);\r\n\r\n        emit ContractsSet(_kyberNetwork, _otc);\r\n    }\r\n\r\n    function setTokenSplitPercentage(ERC20 token, uint splitPercentage) public onlyAdmin {\r\n        address tokenAddr = address(token);\r\n        require(isTokenListed[tokenAddr]);\r\n        require(splitPercentage <= 100);\r\n        tokenSplitPercentage[tokenAddr] = splitPercentage;\r\n    }\r\n\r\n    event TokenListed(ERC20 token);\r\n\r\n    function listToken(ERC20 token, uint splitPercentage) public onlyAdmin {\r\n        address tokenAddr = address(token);\r\n\r\n        require(tokenAddr != address(0), \"listToken: token's address is missing\");\r\n        require(!isTokenListed[tokenAddr], \"listToken: token's alr listed\");\r\n        require(getDecimals(token) == MAX_DECIMALS, \"listToken: token's decimals is not MAX_DECIMALS\");\r\n        require(token.approve(address(otc), 2**255), \"listToken: approve token otc failed\");\r\n\r\n        require(splitPercentage < 100 && splitPercentage > 0);\r\n        tokenSplitPercentage[tokenAddr] = splitPercentage;\r\n\r\n        address uniswapExchange = uniswapFactory.getExchange(tokenAddr);\r\n        tokenExchange[address(token)] = uniswapExchange;\r\n        if (address(uniswapExchange) != address(0)) {\r\n            require(token.approve(uniswapExchange, 2**255), \"listToken: approve token uniswap failed\");\r\n        }\r\n\r\n        isTokenListed[tokenAddr] = true;\r\n\r\n        emit TokenListed(token);\r\n    }\r\n\r\n    event TokenDelisted(ERC20 token);\r\n\r\n    function delistToken(ERC20 token) public onlyAdmin {\r\n        address tokenAddr = address(token);\r\n\r\n        require(isTokenListed[tokenAddr], \"delistToken: token is not listed\");\r\n        require(token.approve(address(otc), 0), \"delistToken: reset approve token failed\");\r\n        address uniswapExchange = tokenExchange[tokenAddr];\r\n        if (uniswapExchange != address(0)) {\r\n            require(token.approve(uniswapExchange, 0), \"listToken: approve token uniswap failed\");\r\n        }\r\n\r\n        delete isTokenListed[tokenAddr];\r\n        delete tokenBasicData[tokenAddr];\r\n        delete tokenSplitPercentage[tokenAddr];\r\n\r\n        emit TokenDelisted(token);\r\n    }\r\n\r\n    event FeeBpsSet(uint feeBps);\r\n\r\n    function setFeeBps(uint _feeBps) public onlyAdmin {\r\n        feeBps = _feeBps;\r\n        emit FeeBpsSet(feeBps);\r\n    }\r\n\r\n    function takeMatchingOrders(ERC20 destToken, uint srcAmount, OfferData[] memory offers)\r\n        internal\r\n        returns(uint actualDestAmount)\r\n    {\r\n        require(destToken != ETH_TOKEN_ADDRESS, \"takeMatchingOrders: destToken is ETH\");\r\n\r\n        uint lastReserveBalance = destToken.balanceOf(address(this));\r\n        uint remainingSrcAmount = srcAmount;\r\n\r\n        for (uint i = 0; i < offers.length; i++) {\r\n            if (offers[i].id == 0 || remainingSrcAmount == 0) { break; }\r\n\r\n            uint payAmount = minOf(remainingSrcAmount, offers[i].payAmount);\r\n            uint buyAmount = payAmount * offers[i].buyAmount / offers[i].payAmount;\r\n\r\n            otc.take(bytes32(offers[i].id), uint128(buyAmount));\r\n            remainingSrcAmount -= payAmount;\r\n        }\r\n\r\n        // must use all amount\r\n        require(remainingSrcAmount == 0, \"takeMatchingOrders: did not take all src amount\");\r\n\r\n        uint newReserveBalance = destToken.balanceOf(address(this));\r\n\r\n        require(newReserveBalance > lastReserveBalance, \"takeMatchingOrders: newReserveBalance <= lastReserveBalance\");\r\n\r\n        actualDestAmount = newReserveBalance - lastReserveBalance;\r\n    }\r\n\r\n    function valueAfterReducingFee(uint val) internal view returns(uint) {\r\n        return ((BPS - feeBps) * val) / BPS;\r\n    }\r\n\r\n    function findBestOffers(\r\n        ERC20 dstToken,\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        OfferData memory bid,\r\n        OfferData memory ask\r\n    )\r\n        internal view\r\n        returns(uint totalDestAmount, OfferData[] memory offers)\r\n    {\r\n        uint remainingSrcAmount = srcAmount;\r\n        uint maxOrdersToTake;\r\n        uint maxTraversedOrders;\r\n        uint minPayAmount;\r\n        uint numTakenOffer = 0;\r\n        totalDestAmount = 0;\r\n        ERC20 token = srcToken == wethToken ? dstToken : srcToken;\r\n\r\n        (maxOrdersToTake, maxTraversedOrders, minPayAmount) = calcOfferLimitsFromFactorData(\r\n            token,\r\n            (srcToken == wethToken),\r\n            bid,\r\n            ask\r\n        );\r\n\r\n        offers = new OfferData[](maxTraversedOrders);\r\n\r\n        // return earlier, we don't want to take any orders\r\n        if (maxTraversedOrders == 0 || maxOrdersToTake == 0) {\r\n            return (totalDestAmount, offers);\r\n        }\r\n\r\n        // otc's terminology is of offer maker, so their sellGem is our (the taker's) dest token.\r\n        // if we don't have best offers, get them.\r\n        if ((srcToken == wethToken && bid.id == 0) || (dstToken == wethToken && ask.id == 0)) {\r\n            offers[0].id = otc.getBestOffer(dstToken, srcToken);\r\n            // assuming pay amount is taker pay amount. (in otc it is used differently)\r\n            (offers[0].buyAmount, , offers[0].payAmount, ) = otc.getOffer(offers[0].id);\r\n        } else {\r\n            offers[0] = srcToken == wethToken ? bid : ask;\r\n        }\r\n\r\n        uint thisOffer;\r\n\r\n        OfferData memory biggestSkippedOffer = OfferData(0, 0, 0);\r\n\r\n        for (; maxTraversedOrders > 0; --maxTraversedOrders) {\r\n            thisOffer = numTakenOffer;\r\n\r\n            // in case both biggestSkippedOffer & current offer have amount >= remainingSrcAmount\r\n            // biggestSkippedOffer should have better rate than current offer\r\n            if (biggestSkippedOffer.payAmount >= remainingSrcAmount) {\r\n                offers[numTakenOffer].id = biggestSkippedOffer.id;\r\n                offers[numTakenOffer].buyAmount = remainingSrcAmount * biggestSkippedOffer.buyAmount / biggestSkippedOffer.payAmount;\r\n                offers[numTakenOffer].payAmount = remainingSrcAmount;\r\n                totalDestAmount += offers[numTakenOffer].buyAmount;\r\n                ++numTakenOffer;\r\n                remainingSrcAmount = 0;\r\n                break;\r\n            } else if (offers[numTakenOffer].payAmount >= remainingSrcAmount) {\r\n                offers[numTakenOffer].buyAmount = remainingSrcAmount * offers[numTakenOffer].buyAmount / offers[numTakenOffer].payAmount;\r\n                offers[numTakenOffer].payAmount = remainingSrcAmount;\r\n                totalDestAmount += offers[numTakenOffer].buyAmount;\r\n                ++numTakenOffer;\r\n                remainingSrcAmount = 0;\r\n                break;\r\n            } else if ((maxOrdersToTake - numTakenOffer) > 1\r\n                        && offers[numTakenOffer].payAmount >= minPayAmount) {\r\n                totalDestAmount += offers[numTakenOffer].buyAmount;\r\n                remainingSrcAmount -= offers[numTakenOffer].payAmount;\r\n                ++numTakenOffer;\r\n            } else if (offers[numTakenOffer].payAmount > biggestSkippedOffer.payAmount) {\r\n                biggestSkippedOffer.payAmount = offers[numTakenOffer].payAmount;\r\n                biggestSkippedOffer.buyAmount = offers[numTakenOffer].buyAmount;\r\n                biggestSkippedOffer.id = offers[numTakenOffer].id;\r\n            }\r\n\r\n            offers[numTakenOffer].id = otc.getWorseOffer(offers[thisOffer].id);\r\n            (offers[numTakenOffer].buyAmount, , offers[numTakenOffer].payAmount, ) = otc.getOffer(offers[numTakenOffer].id);\r\n        }\r\n\r\n        if (remainingSrcAmount > 0) totalDestAmount = 0;\r\n        if (totalDestAmount == 0) offers = new OfferData[](0);\r\n    }\r\n\r\n    // returns max takes, max traverse, min order size to take using config factor data\r\n    function calcOfferLimitsFromFactorData(\r\n        ERC20 token,\r\n        bool isEthToToken,\r\n        OfferData memory bid,\r\n        OfferData memory ask\r\n    )\r\n        internal view\r\n        returns(uint maxTakes, uint maxTraverse, uint minPayAmount)\r\n    {\r\n        if (!isEthToToken && (ask.id == 0 || bid.id == 0)) {\r\n            // need to compute equivalent eth amount but no ask and bid offers are available\r\n            maxTakes = 0;\r\n            maxTraverse = 0;\r\n            minPayAmount = 0;\r\n            return (maxTakes, maxTraverse, minPayAmount);\r\n        }\r\n\r\n        uint order0Pay = 0;\r\n        uint order0Buy = 0;\r\n\r\n        if (!isEthToToken) {\r\n            // only need to use median when token -> eth trade\r\n            order0Pay = ask.payAmount;\r\n            order0Buy = (ask.buyAmount + ask.payAmount * bid.payAmount / bid.buyAmount) / 2;\r\n        }\r\n\r\n        BasicDataConfig memory basicData = getTokenBasicData(token);\r\n\r\n        maxTraverse = basicData.maxTraverse;\r\n        maxTakes = basicData.maxTakes;\r\n\r\n        uint minETHAmount = basicData.minETHSupport;\r\n\r\n        // translate min amount to pay token\r\n        minPayAmount = isEthToToken ? minETHAmount : minETHAmount * order0Pay / order0Buy;\r\n    }\r\n\r\n    // bid: buy WETH, ask: sell WETH (their base token is DAI)\r\n    function getFirstBidAndAskOrders(ERC20 token)\r\n        internal view\r\n        returns(OfferData memory bid, OfferData memory ask)\r\n    {\r\n        // getting first bid offer (buy WETH)\r\n        (bid.id, bid.payAmount, bid.buyAmount) = getFirstOffer(token, wethToken);\r\n        // getting first ask offer (sell WETH)\r\n        (ask.id, ask.payAmount, ask.buyAmount) = getFirstOffer(wethToken, token);\r\n    }\r\n\r\n    function getFirstOffer(ERC20 offerSellGem, ERC20 offerBuyGem)\r\n        internal view\r\n        returns(uint offerId, uint offerPayAmount, uint offerBuyAmount)\r\n    {\r\n        offerId = otc.getBestOffer(offerSellGem, offerBuyGem);\r\n        (offerBuyAmount, , offerPayAmount, ) = otc.getOffer(offerId);\r\n    }\r\n\r\n    function getTokenBasicData(ERC20 token) \r\n        internal view \r\n        returns(BasicDataConfig memory data)\r\n    {\r\n        (data.minETHSupport, data.maxTraverse, data.maxTakes) = decodeTokenBasicData(tokenBasicData[address(token)]);\r\n    }\r\n\r\n    function encodeTokenBasicData(uint ethSize, uint maxTraverse, uint maxTakes) \r\n        internal pure\r\n        returns(uint data)\r\n    {\r\n        require(maxTakes < POW_2_32, \"encodeTokenBasicData: maxTakes is too big\");\r\n        require(maxTraverse < POW_2_32, \"encodeTokenBasicData: maxTraverse is too big\");\r\n        require(ethSize < POW_2_96, \"encodeTokenBasicData: ethSize is too big\");\r\n        data = maxTakes & (POW_2_32 - 1);\r\n        data |= (maxTraverse & (POW_2_32 - 1)) * POW_2_32;\r\n        data |= (ethSize & (POW_2_96 * POW_2_96 - 1)) * POW_2_32 * POW_2_32;\r\n    }\r\n\r\n    function decodeTokenBasicData(uint data) \r\n        internal pure\r\n        returns(uint ethSize, uint maxTraverse, uint maxTakes)\r\n    {\r\n        maxTakes = data & (POW_2_32 - 1);\r\n        maxTraverse = (data / POW_2_32) & (POW_2_32 - 1);\r\n        ethSize = (data / (POW_2_32 * POW_2_32)) & (POW_2_96 * POW_2_96 - 1);\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        return token.decimals();\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\r\n        internal pure returns(uint)\r\n    {\r\n        require(srcAmount <= MAX_QTY);\r\n        require(destAmount <= MAX_QTY);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\r\n        }\r\n    }\r\n\r\n    function minOf(uint x, uint y) internal pure returns(uint) {\r\n        return x > y ? y : x;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"splitPercentage\",\"type\":\"uint256\"}],\"name\":\"listToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenExchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"splitPercentage\",\"type\":\"uint256\"}],\"name\":\"setTokenSplitPercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"otc\",\"outputs\":[{\"internalType\":\"contract OtcInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethToken\",\"outputs\":[{\"internalType\":\"contract WethInterface\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"destAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"conversionRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"trade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeBps\",\"type\":\"uint256\"}],\"name\":\"setFeeBps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcQty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getConversionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcQty\",\"type\":\"uint256\"}],\"name\":\"getConversionRateUniswap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapFactory\",\"outputs\":[{\"internalType\":\"contract UniswapFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenSplitPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcQty\",\"type\":\"uint256\"}],\"name\":\"getConversionRateOasis\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"delistToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_kyberNetwork\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_otc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapFactory\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyberNetwork\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"enableTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTraverse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minETHSupport\",\"type\":\"uint256\"}],\"name\":\"setTokenConfigData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTokenListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcQty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"getConversionRateWithPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rateUniswap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateOasis\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDestAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_kyberNetwork\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeBps\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"destAddress\",\"type\":\"address\"}],\"name\":\"TradeExecute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTraverse\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minETHSupport\",\"type\":\"uint256\"}],\"name\":\"TokenConfigDataSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"TradeEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"kyberNetwork\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"otc\",\"type\":\"address\"}],\"name\":\"ContractsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenDelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeBps\",\"type\":\"uint256\"}],\"name\":\"FeeBpsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"}]","ContractName":"UniswapOasisBridgeReserve","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004f2604aac91114ae3b3d0be485d407d02b24480b000000000000000000000000000000000000000000000000000000000000000b0000000000000000000000004f2604aac91114ae3b3d0be485d407d02b24480b","Library":"","LicenseType":"None","SwarmSource":"bzzr://206ed4c7039081a1104d4d735aef28cb0e8bb594e1e93b0f92824045a8834847"}]}