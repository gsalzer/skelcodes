{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.6;\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract IOperationalWallet2 {\r\n    function setTrustedToggler(address _trustedToggler) external;\r\n    function toggleTrustedWithdrawer(address _withdrawer, bool isEnabled) external;\r\n    function withdrawCoin(address coin, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IWithdrawalOracle {\r\n    function get(address coinAddress) external view returns (bool, uint, uint);\r\n    function set(address coinAddress, bool _isEnabled, uint _currencyAmount, uint _zangllTokenAmount) external;\r\n}\r\n\r\ncontract IBooking {\r\n\r\n    enum Status {\r\n        New, Requested, Confirmed, Rejected, Canceled, Booked, Started,\r\n        Finished, Arbitration, ArbitrationFinished, ArbitrationPossible\r\n    }\r\n    enum CancellationPolicy {Soft, Flexible, Strict}\r\n\r\n\r\n    // methods\r\n    function calculateCancel() external view returns(bool, uint, uint, uint);\r\n    function cancel() external;\r\n\r\n    function setArbiter(address _arbiter) external;\r\n    function submitToArbitration(int _ticket) external;\r\n\r\n    function arbitrate(uint depositToHostPpm, uint cleaningToHostPpm, uint priceToHostPpm, bool useCancellationPolicy) external;\r\n\r\n    function calculateHostWithdraw() external view returns (bool isPossible, uint zangllTokenAmountToPut, uint hostPart);\r\n    function hostWithdraw() external;\r\n\r\n    function calculateGuestWithdraw() external view returns (bool isPossible, uint guestPart);\r\n    function guestWithdraw() external;\r\n\r\n    // fields\r\n    function bookingId() external view returns(uint128);\r\n    function dateFrom() external view returns(uint32);\r\n    function dateTo() external view returns(uint32);\r\n    function dateCancel() external view returns(uint32);\r\n    function host() external view returns(address);\r\n    function guest() external view returns(address);\r\n    function cancellationPolicy() external view returns (IBooking.CancellationPolicy);\r\n\r\n    function guestCoin() external view returns(address);\r\n    function hostCoin() external view returns(address);\r\n    function withdrawalOracle() external view returns(address);\r\n\r\n    function price() external view returns(uint256);\r\n    function cleaning() external view returns(uint256);\r\n    function deposit() external view returns(uint256);\r\n\r\n    function guestAmount() external view returns (uint256);\r\n\r\n    function feeBeneficiary() external view returns(address);\r\n\r\n    function ticket() external view returns(int);\r\n\r\n    function arbiter() external view returns(address);\r\n\r\n    function balance() external view returns (uint);\r\n    function balanceToken(address) external view returns (uint);\r\n    function status() external view returns(Status);\r\n}\r\n\r\ncontract IBookingFactory {\r\n\r\n    function createBooking(uint128 _bookingId, uint32 _dateFrom, uint32 _dateTo, uint256 _guestAmount,\r\n        uint256 _price, uint256 _cleaning, uint256 _deposit, IBooking.CancellationPolicy _cancellationPolicy,\r\n        address _guest, address _host, address _guestCoin, address _hostCoin)\r\n    public payable returns (address);\r\n\r\n    function toggleCoin(address coinAddress, bool enable) public;\r\n\r\n    function setFeeBeneficiary(address _feeBeneficiary) public;\r\n    function setOperationalWallet1(address payable _operationalWallet1) public;\r\n    function setOperationalWallet2(address _operationalWallet2) public;\r\n\r\n    function addArbiter(address _arbiter) public;\r\n    function removeArbiter(address _arbiter) public;\r\n    function setBookingArbiter(address _arbiter, address _booking) public;\r\n}\r\n\r\nlibrary BookingLib {\r\n\r\n    struct Booking {\r\n        uint128 bookingId;\r\n        uint32 dateFrom;\r\n        uint32 dateTo;\r\n        uint32 dateCancel;\r\n\r\n        address withdrawalOracle;\r\n        address operationalWallet2;\r\n\r\n        address guestCoin;\r\n        address hostCoin;\r\n        address znglToken;\r\n\r\n        // prices in host currency\r\n        uint256 price;\r\n        uint256 cleaning;\r\n        uint256 deposit;\r\n\r\n        // total amount in guest currency\r\n        uint256 guestAmount;\r\n\r\n        address host;\r\n        address guest;\r\n        address feeBeneficiary;\r\n        IBooking.Status status;\r\n        IBooking.CancellationPolicy cancellationPolicy;\r\n        address factory;\r\n        address arbiter;\r\n        int ticket;\r\n\r\n        bool guestFundsWithdriven; // false by default\r\n        bool hostFundsWithdriven;  // false by default\r\n\r\n        uint256 guestWithdrawAllowance; // deposit (by default)\r\n        uint256 hostWithdrawAllowance;  // price + cleaning (by default)\r\n    }\r\n\r\n    // STATUS HELPERS AND FUNCTIONS---------------------------------------------------------------------------\r\n    event StatusChanged (\r\n        IBooking.Status indexed _from,\r\n        IBooking.Status indexed _to\r\n    );\r\n\r\n    function getStatus(Booking storage booking)\r\n    internal view returns (IBooking.Status) {\r\n        if (booking.dateCancel == 0) {\r\n            // normal flow\r\n            if (booking.status == IBooking.Status.Booked) {\r\n                if (now < booking.dateFrom) {\r\n                    return IBooking.Status.Booked;\r\n                } else if (now < booking.dateTo) {\r\n                    return IBooking.Status.Started;\r\n                } else if (now < booking.dateTo + 24 * 60 * 60) {\r\n                    return IBooking.Status.ArbitrationPossible;\r\n                } else {\r\n                    return IBooking.Status.Finished;\r\n                }\r\n            } else {\r\n                return booking.status;\r\n            }\r\n        } else {\r\n            // canceled flow\r\n            if (booking.status == IBooking.Status.ArbitrationFinished) {\r\n                return booking.status;\r\n            }\r\n            if (now < booking.dateCancel + 24 * 60 * 60) {\r\n                return IBooking.Status.ArbitrationPossible;\r\n            } else {\r\n                return IBooking.Status.Canceled;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setStatus(Booking storage booking, IBooking.Status newStatus)\r\n    internal {\r\n        emit StatusChanged(booking.status, newStatus);\r\n        booking.status = newStatus;\r\n    }\r\n    // -------------------------------------------------------------------------------------------------------\r\n\r\n    // WITHDRAWAL FUNCTIONS ----------------------------------------------------------------------------------\r\n    function isStatusAllowsWithdrawal(Booking storage booking)\r\n    internal view returns (bool) {\r\n        IBooking.Status currentStatus = getStatus(booking);\r\n        return (\r\n            currentStatus == IBooking.Status.Finished ||\r\n            currentStatus == IBooking.Status.ArbitrationFinished ||\r\n            currentStatus == IBooking.Status.Canceled\r\n        );\r\n    }\r\n\r\n    function calculateGuestWithdraw(Booking storage booking)\r\n    internal view returns (bool, uint) {\r\n        if (!booking.guestFundsWithdriven &&\r\n            isStatusAllowsWithdrawal(booking) &&\r\n            IERC20(booking.hostCoin).balanceOf(booking.operationalWallet2) >= booking.guestWithdrawAllowance\r\n        ) {\r\n            return (true, booking.guestWithdrawAllowance);\r\n        } else {\r\n            return (false, 0);\r\n        }\r\n    }\r\n\r\n    function guestWithdraw(Booking storage booking) internal {\r\n        (bool isPossible, uint guestPart) = calculateGuestWithdraw(booking);\r\n        require(isPossible);\r\n\r\n        bool isWithdrawSuccessful = IOperationalWallet2(booking.operationalWallet2)\r\n            .withdrawCoin(booking.hostCoin, booking.guest, guestPart);\r\n        require(isWithdrawSuccessful);\r\n        booking.guestFundsWithdriven = true;\r\n    }\r\n\r\n    function calculateHostWithdraw(Booking storage booking) internal view\r\n    returns (bool isPossible, uint zangllTokenAmountToPut, uint hostPart) {\r\n        (bool isCoinEnabled, uint currencyAmount, uint zangllTokenAmount) =\r\n            IWithdrawalOracle(booking.withdrawalOracle).get(booking.hostCoin);\r\n\r\n        if (!booking.hostFundsWithdriven &&\r\n            isStatusAllowsWithdrawal(booking) &&\r\n            isCoinEnabled &&\r\n            IERC20(booking.hostCoin).balanceOf(booking.operationalWallet2) >= booking.hostWithdrawAllowance\r\n        ) {\r\n            isPossible = true;\r\n            zangllTokenAmountToPut = booking.hostWithdrawAllowance * zangllTokenAmount / currencyAmount;\r\n            hostPart = booking.hostWithdrawAllowance;\r\n        } else {\r\n            isPossible = false;\r\n            zangllTokenAmountToPut = 0;\r\n            hostPart = 0;\r\n        }\r\n    }\r\n\r\n    function hostWithdraw(Booking storage booking) internal {\r\n        (bool isPossible, uint zangllTokenAmountToPut, uint hostPart) = calculateHostWithdraw(booking);\r\n        require(isPossible);\r\n\r\n        bool isZnglTokenWithdrawSuccessful = IERC20(booking.znglToken)\r\n            .transferFrom(booking.host, booking.feeBeneficiary, zangllTokenAmountToPut);\r\n        require(isZnglTokenWithdrawSuccessful);\r\n\r\n        bool isWithdrawSuccessful = IOperationalWallet2(booking.operationalWallet2)\r\n            .withdrawCoin(booking.hostCoin, booking.host, hostPart);\r\n        require(isWithdrawSuccessful);\r\n        booking.hostFundsWithdriven = true;\r\n    }\r\n    // -------------------------------------------------------------------------------------------------------\r\n\r\n    // CANCELLATION FUNCTIONS --------------------------------------------------------------------------------\r\n    function calculateCancel(Booking storage booking)\r\n    internal view returns (bool isPossible, uint depositToHostPpm, uint cleaningToHostPpm, uint priceToHostPpm) {\r\n\r\n        // initialization\r\n        isPossible = false;\r\n        IBooking.Status currentStatus = getStatus(booking);\r\n\r\n        (uint nightsAlreadyOccupied, uint nightsTotal) = getNights(booking);\r\n\r\n        // checking\r\n        if ((currentStatus != IBooking.Status.Booked && currentStatus != IBooking.Status.Started) ||\r\n            (nightsTotal == 0 || nightsAlreadyOccupied >= nightsTotal) ||\r\n            (currentStatus == IBooking.Status.Started && msg.sender == booking.host)) {\r\n            return (false, 0, 0, 0);\r\n        }\r\n\r\n        depositToHostPpm = 0;\r\n        cleaningToHostPpm = nightsAlreadyOccupied == 0 ? 0 : 1000000;\r\n        priceToHostPpm = currentStatus == IBooking.Status.Booked && (msg.sender == booking.host || msg.sender == booking.feeBeneficiary)\r\n            ? 0\r\n            : getPriceToHostPpmByCancellationPolicy(booking, nightsAlreadyOccupied, nightsTotal, now);\r\n\r\n        isPossible = true;\r\n    }\r\n\r\n    function cancel(Booking storage booking)\r\n    internal {\r\n        bool isPossible; uint depositToHostPpm; uint cleaningToHostPpm; uint priceToHostPpm;\r\n        (isPossible, depositToHostPpm, cleaningToHostPpm, priceToHostPpm) = calculateCancel(booking);\r\n        require(isPossible);\r\n\r\n        booking.dateCancel = uint32(now);\r\n        splitAllBalance(booking, depositToHostPpm, cleaningToHostPpm, priceToHostPpm);\r\n        emit StatusChanged(booking.status, IBooking.Status.ArbitrationPossible);\r\n    }\r\n    // -------------------------------------------------------------------------------------------------------\r\n\r\n    // ARBITRATION FUNCTIONS ---------------------------------------------------------------------------------\r\n    function setArbiter(Booking storage booking, address _arbiter)\r\n    internal {\r\n        require(msg.sender == booking.factory);\r\n        booking.arbiter = _arbiter;\r\n    }\r\n\r\n    function submitToArbitration(Booking storage booking, int _ticket)\r\n    internal {\r\n        IBooking.Status currentStatus = getStatus(booking);\r\n        require(\r\n            currentStatus == IBooking.Status.Booked ||\r\n            currentStatus == IBooking.Status.Started ||\r\n            currentStatus == IBooking.Status.ArbitrationPossible\r\n        );\r\n        require(!booking.guestFundsWithdriven && !booking.hostFundsWithdriven);\r\n        booking.ticket = _ticket;\r\n        setStatus(booking, IBooking.Status.Arbitration);\r\n    }\r\n\r\n    function arbitrate(Booking storage booking,\r\n        uint depositToHostPpm, uint cleaningToHostPpm, uint priceToHostPpm, bool useCancellationPolicy)\r\n    internal {\r\n        require (booking.status == IBooking.Status.Arbitration && depositToHostPpm <= 1000000 &&\r\n            cleaningToHostPpm <= 1000000 && priceToHostPpm <= 1000000);\r\n\r\n        if (useCancellationPolicy) {\r\n            (uint nightsAlreadyOccupied, uint nightsTotal) = getNights(booking);\r\n            priceToHostPpm = getPriceToHostPpmByCancellationPolicy(booking, nightsAlreadyOccupied, nightsTotal, now);\r\n        }\r\n\r\n        splitAllBalance(booking, depositToHostPpm, cleaningToHostPpm, priceToHostPpm);\r\n        setStatus(booking, IBooking.Status.ArbitrationFinished);\r\n    }\r\n    // -------------------------------------------------------------------------------------------------------\r\n\r\n    // FUNCTIONS THAT SPLIT ALL BALANCE AND RETURN MONEY TO THE GUEST ----------------------------------------\r\n    function splitAllBalance(Booking storage booking,\r\n        uint depositToHostPpm, uint cleaningToHostPpm, uint priceToHostPpm)\r\n    internal {\r\n        uint priceToHost = booking.price * priceToHostPpm / 1000000;\r\n        uint depositToHost = booking.deposit * depositToHostPpm / 1000000;\r\n        uint cleaningToHost = booking.cleaning * cleaningToHostPpm / 1000000;\r\n\r\n        booking.hostWithdrawAllowance = priceToHost + cleaningToHost + depositToHost;\r\n        booking.guestWithdrawAllowance =\r\n            (booking.price - priceToHost) +\r\n            (booking.deposit - depositToHost) +\r\n            (booking.cleaning - cleaningToHost);\r\n    }\r\n\r\n    // HELPERS FOR SPLITTING FUNDS ---------------------------------------------------------------------------\r\n    function getNights(Booking storage booking)\r\n    internal view returns (uint nightsAlreadyOccupied, uint nightsTotal) {\r\n        nightsTotal = (12 * 60 * 60 + booking.dateTo - booking.dateFrom) / (24 * 60 * 60);\r\n        if (now <= booking.dateFrom) {\r\n            nightsAlreadyOccupied = 0;\r\n        } else {\r\n            // first night is occupied when 1 second is passed after check-in, and so on\r\n            nightsAlreadyOccupied = (24 * 60 * 60 - 1 + now - booking.dateFrom) / (24 * 60 * 60);\r\n        }\r\n        if (nightsAlreadyOccupied > nightsTotal) {\r\n            nightsAlreadyOccupied = nightsTotal;\r\n        }\r\n    }\r\n\r\n    function getPriceToHostPpmByCancellationPolicy(\r\n        Booking storage booking, uint nightsAlreadyOccupied, uint nightsTotal, uint _now)\r\n    internal view returns (uint priceToHostPpm) {\r\n        if (booking.cancellationPolicy == IBooking.CancellationPolicy.Flexible) {\r\n            uint nightsToPay = _now < booking.dateFrom - 24 * 60 * 60\r\n                ? 0\r\n                : nightsAlreadyOccupied >= nightsTotal ? nightsTotal : nightsAlreadyOccupied + 1;\r\n            priceToHostPpm = 1000000 * nightsToPay / nightsTotal;\r\n        } else if (booking.cancellationPolicy == IBooking.CancellationPolicy.Strict) {\r\n            priceToHostPpm = _now < booking.dateFrom - 5 * 24 * 60 * 60\r\n                ? 0\r\n                : (nightsTotal - (nightsTotal - nightsAlreadyOccupied) / 2) * 1000000;\r\n        } else {// IBooking.CancellationPolicy.Soft\r\n            priceToHostPpm = 1000000 * nightsAlreadyOccupied / nightsTotal;\r\n        }\r\n    }\r\n    // -------------------------------------------------------------------------------------------------------\r\n}\r\n\r\ncontract Booking is IBooking {\r\n\r\n    using BookingLib for BookingLib.Booking;\r\n\r\n    BookingLib.Booking booking;\r\n\r\n    event StatusChanged (\r\n        IBooking.Status indexed from,\r\n        IBooking.Status indexed to\r\n    );\r\n\r\n    modifier onlyFactory {\r\n        require(msg.sender == booking.factory);\r\n        _;\r\n    }\r\n\r\n    modifier onlyGuest {\r\n        require(msg.sender == booking.guest);\r\n        _;\r\n    }\r\n\r\n    modifier onlyHost {\r\n        require(msg.sender == booking.host);\r\n        _;\r\n    }\r\n\r\n    modifier onlyFeeBeneficiary {\r\n        require(msg.sender == booking.feeBeneficiary);\r\n        _;\r\n    }\r\n\r\n    modifier onlyParticipant {\r\n        require(msg.sender == booking.guest || msg.sender == booking.host || msg.sender == booking.feeBeneficiary);\r\n        _;\r\n    }\r\n\r\n    modifier onlyArbiter {\r\n        require(msg.sender == booking.arbiter);\r\n        _;\r\n    }\r\n\r\n    constructor(address _znglToken, uint128 _bookingId, uint32 _dateFrom, uint32 _dateTo, uint256 _guestAmount,\r\n        uint256 _price, uint256 _cleaning, uint256 _deposit, IBooking.CancellationPolicy _cancellationPolicy,\r\n        address _guest, address _host, address _feeBeneficiary, address _defaultArbiter\r\n    ) public {\r\n        require(_dateFrom < _dateTo);\r\n        require(_host != _guest);\r\n\r\n        booking.znglToken = _znglToken;\r\n        booking.bookingId = _bookingId;\r\n        booking.dateFrom = _dateFrom;\r\n        booking.dateTo = _dateTo;\r\n\r\n        booking.guestAmount = _guestAmount;\r\n        booking.price = _price;\r\n        booking.cleaning = _cleaning;\r\n        booking.deposit = _deposit;\r\n\r\n        booking.cancellationPolicy = _cancellationPolicy;\r\n        booking.host = _host;\r\n        booking.guest = _guest;\r\n        booking.feeBeneficiary = _feeBeneficiary;\r\n        booking.arbiter = _defaultArbiter;\r\n\r\n        booking.factory = msg.sender;\r\n\r\n        booking.status = IBooking.Status.Booked;\r\n\r\n        booking.guestFundsWithdriven = false;\r\n        booking.hostFundsWithdriven = false;\r\n\r\n        booking.guestWithdrawAllowance = _deposit;\r\n        booking.hostWithdrawAllowance = _price + _cleaning;\r\n    }\r\n\r\n    function setAdditionalInfo(address _operationalWallet2, address _withdrawalOracle,\r\n        address _guestCoin, address _hostCoin)\r\n    external onlyFactory {\r\n        booking.operationalWallet2 = _operationalWallet2;\r\n        booking.withdrawalOracle = _withdrawalOracle;\r\n        booking.guestCoin = _guestCoin;\r\n        booking.hostCoin = _hostCoin;\r\n    }\r\n\r\n    function calculateCancel() external view onlyParticipant returns(bool, uint, uint, uint) {\r\n        return booking.calculateCancel();\r\n    }\r\n\r\n    function cancel() external onlyParticipant {\r\n        booking.cancel();\r\n    }\r\n\r\n    function setArbiter(address _arbiter) external {\r\n        booking.setArbiter(_arbiter);\r\n    }\r\n\r\n    function submitToArbitration(int _ticket) external onlyParticipant {\r\n        booking.submitToArbitration(_ticket);\r\n    }\r\n\r\n    function arbitrate(uint depositToHostPpm, uint cleaningToHostPpm, uint priceToHostPpm, bool useCancellationPolicy)\r\n    external onlyArbiter {\r\n        booking.arbitrate(depositToHostPpm, cleaningToHostPpm, priceToHostPpm, useCancellationPolicy);\r\n    }\r\n\r\n    function bookingId() external view returns (uint128) {\r\n        return booking.bookingId;\r\n    }\r\n\r\n    function dateFrom() external view returns (uint32) {\r\n        return booking.dateFrom;\r\n    }\r\n\r\n    function dateTo() external view returns (uint32) {\r\n        return booking.dateTo;\r\n    }\r\n\r\n    function dateCancel() external view returns (uint32) {\r\n        return booking.dateCancel;\r\n    }\r\n\r\n    function host() external view returns (address) {\r\n        return booking.host;\r\n    }\r\n\r\n    function guest() external view returns (address) {\r\n        return booking.guest;\r\n    }\r\n\r\n    function cancellationPolicy() external view returns (IBooking.CancellationPolicy) {\r\n        return booking.cancellationPolicy;\r\n    }\r\n\r\n    function guestCoin() external view returns (address) {\r\n        return booking.guestCoin;\r\n    }\r\n\r\n    function hostCoin() external view returns (address) {\r\n        return booking.hostCoin;\r\n    }\r\n\r\n    function withdrawalOracle() external view returns (address) {\r\n        return booking.withdrawalOracle;\r\n    }\r\n\r\n    function price() external view returns (uint256) {\r\n        return booking.price;\r\n    }\r\n\r\n    function cleaning() external view returns (uint256) {\r\n        return booking.cleaning;\r\n    }\r\n\r\n    function deposit() external view returns (uint256) {\r\n        return booking.deposit;\r\n    }\r\n\r\n    function guestAmount() external view returns (uint256) {\r\n        return booking.guestAmount;\r\n    }\r\n\r\n    function feeBeneficiary() external view returns (address) {\r\n        return booking.feeBeneficiary;\r\n    }\r\n\r\n    function ticket() external view returns(int) {\r\n        return booking.ticket;\r\n    }\r\n\r\n    function arbiter() external view returns(address) {\r\n        return booking.arbiter;\r\n    }\r\n\r\n    function balance() external view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function balanceToken(address _token) external view returns (uint) {\r\n        return IERC20(_token).balanceOf(address(this));\r\n    }\r\n\r\n    function status() external view returns (IBooking.Status) {\r\n        return booking.getStatus();\r\n    }\r\n\r\n    function calculateHostWithdraw() onlyHost external view\r\n    returns (bool isPossible, uint zangllTokenAmountToPut, uint hostPart) {\r\n        return booking.calculateHostWithdraw();\r\n    }\r\n\r\n    function hostWithdraw() external {\r\n        require(msg.sender == booking.host || msg.sender == booking.znglToken);\r\n        booking.hostWithdraw();\r\n    }\r\n\r\n    function calculateGuestWithdraw() onlyGuest external view\r\n    returns (bool isPossible, uint guestPart) {\r\n        return booking.calculateGuestWithdraw();\r\n    }\r\n\r\n    function guestWithdraw() external onlyGuest {\r\n        booking.guestWithdraw();\r\n    }\r\n}\r\n\r\ncontract BookingFactory is Ownable, IBookingFactory {\r\n\r\n    event BookingCreated (\r\n        address indexed bookingContractAddress,\r\n        uint128 indexed bookingId\r\n    );\r\n\r\n    // coins -------------------------------------------------------------------------------------------------\r\n    mapping(address => bool) public enabledCoins;\r\n    function toggleCoin(address coinAddress, bool enable) public onlyOwner {\r\n        enabledCoins[coinAddress] = enable;\r\n    }\r\n    //--------------------------------------------------------------------------------------------------------\r\n\r\n    address public znglToken;\r\n    address payable public operationalWallet1; // funds receiver\r\n    address public operationalWallet2; // funds storage to withdraw when booking is ready to pay\r\n    address public withdrawalOracle;\r\n\r\n    mapping(uint128 => bool) private bookingIds;\r\n    mapping(address => bool) private arbiters;\r\n    address public feeBeneficiary;\r\n\r\n    constructor(address _znglToken, address _withdrawalOracle, address payable _operationalWallet1, address _operationalWallet2)\r\n    public {\r\n        feeBeneficiary = owner();\r\n        znglToken = _znglToken;\r\n        withdrawalOracle = _withdrawalOracle;\r\n        operationalWallet1 = _operationalWallet1;\r\n        operationalWallet2 = _operationalWallet2;\r\n    }\r\n\r\n    function createBooking(uint128 _bookingId, uint32 _dateFrom, uint32 _dateTo, uint256 _guestAmount,\r\n        uint256 _price, uint256 _cleaning, uint256 _deposit, IBooking.CancellationPolicy _cancellationPolicy,\r\n        address _guest, address _host, address _guestCoin, address _hostCoin)\r\n    public payable returns (address) {\r\n        require(msg.value > 0 || enabledCoins[_guestCoin]);\r\n        require(enabledCoins[_hostCoin]);\r\n        require(!bookingIds[_bookingId]);\r\n        bookingIds[_bookingId] = true;\r\n\r\n        Booking booking = new Booking(znglToken, _bookingId, _dateFrom, _dateTo, _guestAmount,\r\n            _price, _cleaning, _deposit, _cancellationPolicy,\r\n            _guest, _host, feeBeneficiary, owner());\r\n        emit BookingCreated(address(booking), _bookingId);\r\n\r\n        if (msg.value > 0) {\r\n            booking.setAdditionalInfo(operationalWallet2, withdrawalOracle, 0x0000000000000000000000000000000000000000, _hostCoin);\r\n            operationalWallet1.transfer(_guestAmount);\r\n            if (address(this).balance > 0) {\r\n                msg.sender.transfer(address(this).balance);\r\n            }\r\n        } else {\r\n            booking.setAdditionalInfo(operationalWallet2, withdrawalOracle, _guestCoin, _hostCoin);\r\n            IERC20(_guestCoin).transferFrom(_guest, operationalWallet1, _guestAmount);\r\n        }\r\n\r\n        IOperationalWallet2(operationalWallet2).toggleTrustedWithdrawer(address(booking), true);\r\n\r\n        return address(booking);\r\n    }\r\n\r\n    function setFeeBeneficiary(address _feeBeneficiary) public onlyOwner {\r\n        feeBeneficiary = _feeBeneficiary;\r\n    }\r\n\r\n    function setOperationalWallet1(address payable _operationalWallet1) public onlyOwner {\r\n        operationalWallet1 = _operationalWallet1;\r\n    }\r\n\r\n    function setOperationalWallet2(address _operationalWallet2) public onlyOwner {\r\n        operationalWallet2 = _operationalWallet2;\r\n    }\r\n\r\n    function addArbiter(address _arbiter) public {\r\n        require (isOwner() || arbiters[msg.sender]);\r\n        arbiters[_arbiter] = true;\r\n    }\r\n\r\n    function removeArbiter(address _arbiter) public {\r\n        require (isOwner() || arbiters[msg.sender]);\r\n        arbiters[_arbiter] = false;\r\n    }\r\n\r\n    function setBookingArbiter(address _arbiter, address _booking) public onlyOwner {\r\n        require(arbiters[_arbiter], \"Arbiter should be added to arbiter list first\");\r\n        Booking booking = Booking(_booking);\r\n        booking.setArbiter(_arbiter);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"operationalWallet2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bookingId\",\"type\":\"uint128\"},{\"name\":\"_dateFrom\",\"type\":\"uint32\"},{\"name\":\"_dateTo\",\"type\":\"uint32\"},{\"name\":\"_guestAmount\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_cleaning\",\"type\":\"uint256\"},{\"name\":\"_deposit\",\"type\":\"uint256\"},{\"name\":\"_cancellationPolicy\",\"type\":\"uint8\"},{\"name\":\"_guest\",\"type\":\"address\"},{\"name\":\"_host\",\"type\":\"address\"},{\"name\":\"_guestCoin\",\"type\":\"address\"},{\"name\":\"_hostCoin\",\"type\":\"address\"}],\"name\":\"createBooking\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_arbiter\",\"type\":\"address\"}],\"name\":\"removeArbiter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeBeneficiary\",\"type\":\"address\"}],\"name\":\"setFeeBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"znglToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"coinAddress\",\"type\":\"address\"},{\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"toggleCoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operationalWallet2\",\"type\":\"address\"}],\"name\":\"setOperationalWallet2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawalOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operationalWallet1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"enabledCoins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_arbiter\",\"type\":\"address\"}],\"name\":\"addArbiter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_arbiter\",\"type\":\"address\"},{\"name\":\"_booking\",\"type\":\"address\"}],\"name\":\"setBookingArbiter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operationalWallet1\",\"type\":\"address\"}],\"name\":\"setOperationalWallet1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_znglToken\",\"type\":\"address\"},{\"name\":\"_withdrawalOracle\",\"type\":\"address\"},{\"name\":\"_operationalWallet1\",\"type\":\"address\"},{\"name\":\"_operationalWallet2\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bookingContractAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"bookingId\",\"type\":\"uint128\"}],\"name\":\"BookingCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BookingFactory","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002f4366069824e4042bddaf27df092b20c907402b000000000000000000000000c9a4e0dc1480434b58e4dd65244b46f300ba876a000000000000000000000000a1410cbef144f7b6e60f7126289db8e7d0abca0d000000000000000000000000a01d934db16f3c63d9b08febeef1361442c37456","Library":"","LicenseType":"None","SwarmSource":"bzzr://01fa17d0cd90037f9942483a0358caeac78b345126094f4c1cded10634ed420c"}]}