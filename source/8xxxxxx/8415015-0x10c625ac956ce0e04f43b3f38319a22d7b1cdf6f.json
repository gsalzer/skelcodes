{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n\\n  /**\\n   * Returns whether the target address is a contract\\n   * @dev This function will return false if invoked during the constructor of a contract,\\n   * as the code is not actually created until after the constructor finishes.\\n   * @param account address of the account to check\\n   * @return whether the target address is a contract\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    uint256 size;\\n    // XXX Currently there is no better way to check if there is a contract in an address\\n    // than to check the size of the code at that address.\\n    // See https://ethereum.stackexchange.com/a/14016/36603\\n    // for more details about how this works.\\n    // TODO Check this again before the Serenity release, because all addresses will be\\n    // contracts then.\\n    // solium-disable-next-line security/no-inline-assembly\\n    assembly { size := extcodesize(account) }\\n    return size \\u003e 0;\\n  }\\n\\n}\"},\"ERC165.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC165\\r\\n * @author Matt Condon (@shrugs)\\r\\n * @dev Implements ERC165 using a lookup table.\\r\\n */\\r\\ncontract ERC165 is IERC165 {\\r\\n\\r\\n  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\\r\\n  /**\\r\\n   * 0x01ffc9a7 ===\\r\\n   *   bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027))\\r\\n   */\\r\\n\\r\\n  /**\\r\\n   * @dev a mapping of interface id to whether or not it\\u0027s supported\\r\\n   */\\r\\n  mapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\r\\n\\r\\n  /**\\r\\n   * @dev A contract implementing SupportsInterfaceWithLookup\\r\\n   * implement ERC165 itself\\r\\n   */\\r\\n  constructor()\\r\\n    internal\\r\\n  {\\r\\n    _registerInterface(_InterfaceId_ERC165);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev implement supportsInterface(bytes4) using a lookup table\\r\\n   */\\r\\n  function supportsInterface(bytes4 interfaceId)\\r\\n    external\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    return _supportedInterfaces[interfaceId];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev internal method for registering an interface\\r\\n   */\\r\\n  function _registerInterface(bytes4 interfaceId)\\r\\n    internal\\r\\n  {\\r\\n    require(interfaceId != 0xffffffff);\\r\\n    _supportedInterfaces[interfaceId] = true;\\r\\n  }\\r\\n}\"},\"ERC721.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"./IERC721.sol\\\";\\r\\nimport \\\"./IERC721Receiver.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./ERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\r\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n */\\r\\ncontract ERC721 is ERC165, IERC721 {\\r\\n\\r\\n  using SafeMath for uint256;\\r\\n  using Address for address;\\r\\n\\r\\n  // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\r\\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\r\\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\r\\n\\r\\n  // Mapping from token ID to owner\\r\\n  mapping (uint256 =\\u003e address) private _tokenOwner;\\r\\n\\r\\n  // Mapping from token ID to approved address\\r\\n  mapping (uint256 =\\u003e address) private _tokenApprovals;\\r\\n\\r\\n  // Mapping from owner to number of owned token\\r\\n  mapping (address =\\u003e uint256) private _ownedTokensCount;\\r\\n\\r\\n  // Mapping from owner to operator approvals\\r\\n  mapping (address =\\u003e mapping (address =\\u003e bool)) private _operatorApprovals;\\r\\n\\r\\n  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\\r\\n  /*\\r\\n   * 0x80ac58cd ===\\r\\n   *   bytes4(keccak256(\\u0027balanceOf(address)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027ownerOf(uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027approve(address,uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027getApproved(uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027setApprovalForAll(address,bool)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027isApprovedForAll(address,address)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027transferFrom(address,address,uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256)\\u0027)) ^\\r\\n   *   bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256,bytes)\\u0027))\\r\\n   */\\r\\n\\r\\n  constructor()\\r\\n    public\\r\\n  {\\r\\n    // register the supported interfaces to conform to ERC721 via ERC165\\r\\n    _registerInterface(_InterfaceId_ERC721);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the balance of the specified address\\r\\n   * @param owner address to query the balance of\\r\\n   * @return uint256 representing the amount owned by the passed address\\r\\n   */\\r\\n  function balanceOf(address owner) public view returns (uint256) {\\r\\n    require(owner != address(0));\\r\\n    return _ownedTokensCount[owner];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the owner of the specified token ID\\r\\n   * @param tokenId uint256 ID of the token to query the owner of\\r\\n   * @return owner address currently marked as the owner of the given token ID\\r\\n   */\\r\\n  function ownerOf(uint256 tokenId) public view returns (address) {\\r\\n    address owner = _tokenOwner[tokenId];\\r\\n    require(owner != address(0));\\r\\n    return owner;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Approves another address to transfer the given token ID\\r\\n   * The zero address indicates there is no approved address.\\r\\n   * There can only be one approved address per token at a given time.\\r\\n   * Can only be called by the token owner or an approved operator.\\r\\n   * @param to address to be approved for the given token ID\\r\\n   * @param tokenId uint256 ID of the token to be approved\\r\\n   */\\r\\n  function approve(address to, uint256 tokenId) public {\\r\\n    address owner = ownerOf(tokenId);\\r\\n    require(to != owner);\\r\\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\\r\\n\\r\\n    _tokenApprovals[tokenId] = to;\\r\\n    emit Approval(owner, to, tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Gets the approved address for a token ID, or zero if no address set\\r\\n   * Reverts if the token ID does not exist.\\r\\n   * @param tokenId uint256 ID of the token to query the approval of\\r\\n   * @return address currently approved for the given token ID\\r\\n   */\\r\\n  function getApproved(uint256 tokenId) public view returns (address) {\\r\\n    require(_exists(tokenId));\\r\\n    return _tokenApprovals[tokenId];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets or unsets the approval of a given operator\\r\\n   * An operator is allowed to transfer all tokens of the sender on their behalf\\r\\n   * @param to operator address to set the approval\\r\\n   * @param approved representing the status of the approval to be set\\r\\n   */\\r\\n  function setApprovalForAll(address to, bool approved) public {\\r\\n    require(to != msg.sender);\\r\\n    _operatorApprovals[msg.sender][to] = approved;\\r\\n    emit ApprovalForAll(msg.sender, to, approved);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Tells whether an operator is approved by a given owner\\r\\n   * @param owner owner address which you want to query the approval of\\r\\n   * @param operator operator address which you want to query the approval of\\r\\n   * @return bool whether the given operator is approved by the given owner\\r\\n   */\\r\\n  function isApprovedForAll(\\r\\n    address owner,\\r\\n    address operator\\r\\n  )\\r\\n    public\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    return _operatorApprovals[owner][operator];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers the ownership of a given token ID to another address\\r\\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\\r\\n   * Requires the msg sender to be the owner, approved, or operator\\r\\n   * @param from current owner of the token\\r\\n   * @param to address to receive the ownership of the given token ID\\r\\n   * @param tokenId uint256 ID of the token to be transferred\\r\\n  */\\r\\n  function transferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  )\\r\\n    public\\r\\n  {\\r\\n    require(_isApprovedOrOwner(msg.sender, tokenId));\\r\\n    require(to != address(0));\\r\\n\\r\\n    _clearApproval(from, tokenId);\\r\\n    _removeTokenFrom(from, tokenId);\\r\\n    _addTokenTo(to, tokenId);\\r\\n\\r\\n    emit Transfer(from, to, tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Safely transfers the ownership of a given token ID to another address\\r\\n   * If the target address is a contract, it must implement `onERC721Received`,\\r\\n   * which is called upon a safe transfer, and return the magic value\\r\\n   * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\r\\n   * the transfer is reverted.\\r\\n   *\\r\\n   * Requires the msg sender to be the owner, approved, or operator\\r\\n   * @param from current owner of the token\\r\\n   * @param to address to receive the ownership of the given token ID\\r\\n   * @param tokenId uint256 ID of the token to be transferred\\r\\n  */\\r\\n  function safeTransferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  )\\r\\n    public\\r\\n  {\\r\\n    // solium-disable-next-line arg-overflow\\r\\n    safeTransferFrom(from, to, tokenId, \\\"\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Safely transfers the ownership of a given token ID to another address\\r\\n   * If the target address is a contract, it must implement `onERC721Received`,\\r\\n   * which is called upon a safe transfer, and return the magic value\\r\\n   * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\r\\n   * the transfer is reverted.\\r\\n   * Requires the msg sender to be the owner, approved, or operator\\r\\n   * @param from current owner of the token\\r\\n   * @param to address to receive the ownership of the given token ID\\r\\n   * @param tokenId uint256 ID of the token to be transferred\\r\\n   * @param _data bytes data to send along with a safe transfer check\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId,\\r\\n    bytes _data\\r\\n  )\\r\\n    public\\r\\n  {\\r\\n    transferFrom(from, to, tokenId);\\r\\n    // solium-disable-next-line arg-overflow\\r\\n    require(_checkOnERC721Received(from, to, tokenId, _data));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns whether the specified token exists\\r\\n   * @param tokenId uint256 ID of the token to query the existence of\\r\\n   * @return whether the token exists\\r\\n   */\\r\\n  function _exists(uint256 tokenId) internal view returns (bool) {\\r\\n    address owner = _tokenOwner[tokenId];\\r\\n    return owner != address(0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns whether the given spender can transfer a given token ID\\r\\n   * @param spender address of the spender to query\\r\\n   * @param tokenId uint256 ID of the token to be transferred\\r\\n   * @return bool whether the msg.sender is approved for the given token ID,\\r\\n   *  is an operator of the owner, or is the owner of the token\\r\\n   */\\r\\n  function _isApprovedOrOwner(\\r\\n    address spender,\\r\\n    uint256 tokenId\\r\\n  )\\r\\n    internal\\r\\n    view\\r\\n    returns (bool)\\r\\n  {\\r\\n    address owner = ownerOf(tokenId);\\r\\n    // Disable solium check because of\\r\\n    // https://github.com/duaraghav8/Solium/issues/175\\r\\n    // solium-disable-next-line operator-whitespace\\r\\n    return (\\r\\n      spender == owner ||\\r\\n      getApproved(tokenId) == spender ||\\r\\n      isApprovedForAll(owner, spender)\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to mint a new token\\r\\n   * Reverts if the given token ID already exists\\r\\n   * @param to The address that will own the minted token\\r\\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\\r\\n   */\\r\\n  function _mint(address to, uint256 tokenId) internal {\\r\\n    require(to != address(0));\\r\\n    _addTokenTo(to, tokenId);\\r\\n    emit Transfer(address(0), to, tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to burn a specific token\\r\\n   * Reverts if the token does not exist\\r\\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\\r\\n   */\\r\\n  function _burn(address owner, uint256 tokenId) internal {\\r\\n    _clearApproval(owner, tokenId);\\r\\n    _removeTokenFrom(owner, tokenId);\\r\\n    emit Transfer(owner, address(0), tokenId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to add a token ID to the list of a given address\\r\\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\\r\\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event.\\r\\n   * @param to address representing the new owner of the given token ID\\r\\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\r\\n   */\\r\\n  function _addTokenTo(address to, uint256 tokenId) internal {\\r\\n    require(_tokenOwner[tokenId] == address(0));\\r\\n    _tokenOwner[tokenId] = to;\\r\\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to remove a token ID from the list of a given address\\r\\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\\r\\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event,\\r\\n   * and doesn\\u0027t clear approvals.\\r\\n   * @param from address representing the previous owner of the given token ID\\r\\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\r\\n   */\\r\\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\\r\\n    require(ownerOf(tokenId) == from);\\r\\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\\r\\n    _tokenOwner[tokenId] = address(0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Internal function to invoke `onERC721Received` on a target address\\r\\n   * The call is not executed if the target address is not a contract\\r\\n   * @param from address representing the previous owner of the given token ID\\r\\n   * @param to target address that will receive the tokens\\r\\n   * @param tokenId uint256 ID of the token to be transferred\\r\\n   * @param _data bytes optional data to send along with the call\\r\\n   * @return whether the call correctly returned the expected magic value\\r\\n   */\\r\\n  function _checkOnERC721Received(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId,\\r\\n    bytes _data\\r\\n  )\\r\\n    internal\\r\\n    returns (bool)\\r\\n  {\\r\\n    if (!to.isContract()) {\\r\\n      return true;\\r\\n    }\\r\\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\\r\\n      msg.sender, from, tokenId, _data);\\r\\n    return (retval == _ERC721_RECEIVED);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Private function to clear current approval of a given token ID\\r\\n   * Reverts if the given address is not indeed the owner of the token\\r\\n   * @param owner owner of the token\\r\\n   * @param tokenId uint256 ID of the token to be transferred\\r\\n   */\\r\\n  function _clearApproval(address owner, uint256 tokenId) private {\\r\\n    require(ownerOf(tokenId) == owner);\\r\\n    if (_tokenApprovals[tokenId] != address(0)) {\\r\\n      _tokenApprovals[tokenId] = address(0);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\\r\\ninterface ERC721Metadata /* is ERC721 */ {\\r\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\r\\n    function name() external view returns (string _name);\\r\\n\\r\\n    /// @notice An abbreviated name for NFTs in this contract\\r\\n    function symbol() external view returns (string _symbol);\\r\\n\\r\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\r\\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\r\\n    ///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\r\\n    ///  Metadata JSON Schema\\\".\\r\\n    function tokenURI(uint256 _tokenId) external view returns (string);\\r\\n}\\r\\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\r\\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\\r\\ninterface ERC721Enumerable /* is ERC721 */ {\\r\\n    /// @notice Count NFTs tracked by this contract\\r\\n    /// @return A count of valid NFTs tracked by this contract, where each one of\\r\\n    ///  them has an assigned and queryable owner not equal to the zero address\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /// @notice Enumerate valid NFTs\\r\\n    /// @dev Throws if `_index` \\u003e= `totalSupply()`.\\r\\n    /// @param _index A counter less than `totalSupply()`\\r\\n    /// @return The token identifier for the `_index`th NFT,\\r\\n    ///  (sort order not specified)\\r\\n    function tokenByIndex(uint256 _index) external view returns (uint256);\\r\\n\\r\\n    /// @notice Enumerate NFTs assigned to an owner\\r\\n    /// @dev Throws if `_index` \\u003e= `balanceOf(_owner)` or if\\r\\n    ///  `_owner` is the zero address, representing invalid NFTs.\\r\\n    /// @param _owner An address where we are interested in NFTs owned by them\\r\\n    /// @param _index A counter less than `balanceOf(_owner)`\\r\\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\\r\\n    ///   (sort order not specified)\\r\\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\r\\n}\\r\\n\"},\"IERC165.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\n/**\\r\\n * @title IERC165\\r\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\r\\n */\\r\\ninterface IERC165 {\\r\\n\\r\\n  /**\\r\\n   * @notice Query if a contract implements an interface\\r\\n   * @param interfaceId The interface identifier, as specified in ERC-165\\r\\n   * @dev Interface identification is specified in ERC-165. This function\\r\\n   * uses less than 30,000 gas.\\r\\n   */\\r\\n  function supportsInterface(bytes4 interfaceId)\\r\\n    external\\r\\n    view\\r\\n    returns (bool);\\r\\n}\"},\"IERC721.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC721 Non-Fungible Token Standard basic interface\\r\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\r\\n */\\r\\ncontract IERC721 is IERC165 {\\r\\n\\r\\n  event Transfer(\\r\\n    address indexed from,\\r\\n    address indexed to,\\r\\n    uint256 indexed tokenId\\r\\n  );\\r\\n  event Approval(\\r\\n    address indexed owner,\\r\\n    address indexed approved,\\r\\n    uint256 indexed tokenId\\r\\n  );\\r\\n  event ApprovalForAll(\\r\\n    address indexed owner,\\r\\n    address indexed operator,\\r\\n    bool approved\\r\\n  );\\r\\n\\r\\n  function balanceOf(address owner) public view returns (uint256 balance);\\r\\n  function ownerOf(uint256 tokenId) public view returns (address owner);\\r\\n\\r\\n  function approve(address to, uint256 tokenId) public;\\r\\n  function getApproved(uint256 tokenId)\\r\\n    public view returns (address operator);\\r\\n\\r\\n  function setApprovalForAll(address operator, bool _approved) public;\\r\\n  function isApprovedForAll(address owner, address operator)\\r\\n    public view returns (bool);\\r\\n\\r\\n  function transferFrom(address from, address to, uint256 tokenId) public;\\r\\n  function safeTransferFrom(address from, address to, uint256 tokenId)\\r\\n    public;\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId,\\r\\n    bytes data\\r\\n  )\\r\\n    public;\\r\\n}\"},\"IERC721Receiver.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\n/**\\r\\n * @title ERC721 token receiver interface\\r\\n * @dev Interface for any contract that wants to support safeTransfers\\r\\n * from ERC721 asset contracts.\\r\\n */\\r\\ncontract IERC721Receiver {\\r\\n  /**\\r\\n   * @notice Handle the receipt of an NFT\\r\\n   * @dev The ERC721 smart contract calls this function on the recipient\\r\\n   * after a `safeTransfer`. This function MUST return the function selector,\\r\\n   * otherwise the caller will revert the transaction. The selector to be\\r\\n   * returned can be obtained as `this.onERC721Received.selector`. This\\r\\n   * function MAY throw to revert and reject the transfer.\\r\\n   * Note: the ERC721 contract address is always the message sender.\\r\\n   * @param operator The address which called `safeTransferFrom` function\\r\\n   * @param from The address which previously owned the token\\r\\n   * @param tokenId The NFT identifier which is being transferred\\r\\n   * @param data Additional data with no specified format\\r\\n   * @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\r\\n   */\\r\\n  function onERC721Received(\\r\\n    address operator,\\r\\n    address from,\\r\\n    uint256 tokenId,\\r\\n    bytes data\\r\\n  )\\r\\n    public\\r\\n    returns(bytes4);\\r\\n}\"},\"ownable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address private _owner;\\n\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() internal {\\n    _owner = msg.sender;\\n    emit OwnershipTransferred(address(0), _owner);\\n  }\\n\\n  /**\\n   * @return the address of the owner.\\n   */\\n  function owner() public view returns(address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(isOwner());\\n    _;\\n  }\\n\\n  /**\\n   * @return true if `msg.sender` is the owner of the contract.\\n   */\\n  function isOwner() public view returns(bool) {\\n    return msg.sender == _owner;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to relinquish control of the contract.\\n   * @notice Renouncing to ownership will leave the contract without an owner.\\n   * It will not be possible to call the functions with the `onlyOwner`\\n   * modifier anymore.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipTransferred(_owner, address(0));\\n    _owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function _transferOwnership(address newOwner) internal {\\n    require(newOwner != address(0));\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n}\\n\\n\\n\"},\"Pausable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"./PauserRole.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Pausable\\r\\n * @dev Base contract which allows children to implement an emergency stop mechanism.\\r\\n */\\r\\ncontract Pausable is PauserRole {\\r\\n    event Paused(address account);\\r\\n    event Unpaused(address account);\\r\\n\\r\\n    bool private _paused;\\r\\n\\r\\n    constructor () internal {\\r\\n        _paused = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return true if the contract is paused, false otherwise.\\r\\n     */\\r\\n    function paused() public view returns (bool) {\\r\\n        return _paused;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     */\\r\\n    modifier whenNotPaused() {\\r\\n        require(!_paused);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is paused.\\r\\n     */\\r\\n    modifier whenPaused() {\\r\\n        require(_paused);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev called by the owner to pause, triggers stopped state\\r\\n     */\\r\\n    function pause() public onlyPauser whenNotPaused {\\r\\n        _paused = true;\\r\\n        emit Paused(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev called by the owner to unpause, returns to normal state\\r\\n     */\\r\\n    function unpause() public onlyPauser whenPaused {\\r\\n        _paused = false;\\r\\n        emit Unpaused(msg.sender);\\r\\n    }\\r\\n}\"},\"PauserRole.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\\"./Roles.sol\\\";\\r\\n\\r\\ncontract PauserRole {\\r\\n    using Roles for Roles.Role;\\r\\n\\r\\n    event PauserAdded(address indexed account);\\r\\n    event PauserRemoved(address indexed account);\\r\\n\\r\\n    Roles.Role private _pausers;\\r\\n\\r\\n    constructor () internal {\\r\\n        _addPauser(msg.sender);\\r\\n    }\\r\\n\\r\\n    modifier onlyPauser() {\\r\\n        require(isPauser(msg.sender));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isPauser(address account) public view returns (bool) {\\r\\n        return _pausers.has(account);\\r\\n    }\\r\\n\\r\\n    function addPauser(address account) public onlyPauser {\\r\\n        _addPauser(account);\\r\\n    }\\r\\n\\r\\n    function renouncePauser() public {\\r\\n        _removePauser(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _addPauser(address account) internal {\\r\\n        _pausers.add(account);\\r\\n        emit PauserAdded(account);\\r\\n    }\\r\\n\\r\\n    function _removePauser(address account) internal {\\r\\n        _pausers.remove(account);\\r\\n        emit PauserRemoved(account);\\r\\n    }\\r\\n}\"},\"Roles.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\n/**\\r\\n * @title Roles\\r\\n * @dev Library for managing addresses assigned to a Role.\\r\\n */\\r\\nlibrary Roles {\\r\\n    struct Role {\\r\\n        mapping (address =\\u003e bool) bearer;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev give an account access to this role\\r\\n     */\\r\\n    function add(Role storage role, address account) internal {\\r\\n        require(account != address(0));\\r\\n        require(!has(role, account));\\r\\n\\r\\n        role.bearer[account] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev remove an account\\u0027s access to this role\\r\\n     */\\r\\n    function remove(Role storage role, address account) internal {\\r\\n        require(account != address(0));\\r\\n        require(has(role, account));\\r\\n\\r\\n        role.bearer[account] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev check if an account has this role\\r\\n     * @return bool\\r\\n     */\\r\\n    function has(Role storage role, address account) internal view returns (bool) {\\r\\n        require(account != address(0));\\r\\n        return role.bearer[account];\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, reverts on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b \\u003e 0); // Solidity only automatically asserts when dividing by 0\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b \\u003c= a);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, reverts on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c \\u003e= a);\\n\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n  * reverts when dividing by zero.\\n  */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0);\\n    return a % b;\\n  }\\n}\\n\\n\\n/**\\n * @title SafeMath32\\n * @dev SafeMath library implemented for uint32\\n */\\nlibrary SafeMath32 {\\n\\n  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint32 c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  function div(uint32 a, uint32 b) internal pure returns (uint32) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    uint32 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return c;\\n  }\\n\\n  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  function add(uint32 a, uint32 b) internal pure returns (uint32) {\\n    uint32 c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\\n/**\\n * @title SafeMath16\\n * @dev SafeMath library implemented for uint16\\n */\\nlibrary SafeMath16 {\\n\\n  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint16 c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  function div(uint16 a, uint16 b) internal pure returns (uint16) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    uint16 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return c;\\n  }\\n\\n  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  function add(uint16 a, uint16 b) internal pure returns (uint16) {\\n    uint16 c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\"},\"selfie.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/*\\n#\\n#...######..########.##.......########.####.########..######..##.....##....###....####.##....##\\n#..##....##.##.......##.......##........##..##.......##....##.##.....##...##.##....##..###...##\\n#..##.......##.......##.......##........##..##.......##.......##.....##..##...##...##..####..##\\n#...######..######...##.......######....##..######...##.......#########.##.....##..##..##.##.##\\n#........##.##.......##.......##........##..##.......##.......##.....##.#########..##..##..####\\n#..##....##.##.......##.......##........##..##.......##....##.##.....##.##.....##..##..##...###\\n#...######..########.########.##.......####.########..######..##.....##.##.....##.####.##....##\\n#..............................................................................................\\n#....................................................................by Daniel Fernando Perosio\\n#\\n# @title Selfiechain un contrato para creación de selfies en Ethereum blockchain\\n# @author Daniel Fernando Perosio (http://danielperosio.com) e-mail daniel@perosio.com - dperosio@gmail.com\\n# @notice Selfiechain es un conjunto de instrucciones para realizar autorretratos a partir de tu identidad en la red Ethereum (Ethereum Address)\\n# @dev Compatible con la implementación de OpenZeppelin de la especificación ERC721 Crypto Coleccionables\\n#\\n*/\\n\\nimport \\\"./ownable.sol\\\";\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\n\\ncontract Selfiechain is Ownable, ERC721, Pausable {\\n\\n    string public name = \\\"Selfiechain\\\";\\n    string public symbol = \\\"ツ\\\";\\n    ERC721Metadata public erc721Metadata;\\n    using SafeMath for uint256;\\n    using SafeMath32 for uint32;\\n    using SafeMath16 for uint16;\\n    event NewSelfie(uint selfieId, string _hair, string _forehead, string _eyes, string _nose, string _mouth, string _neck, string _body);\\n    uint public randNonce = 0;\\n \\nstring[104] public array = [\\\"┆\\\",\\\"╵\\\",\\\"║\\\", \\\"¦\\\",\\\"╷\\\",\\\"ı\\\", \\\"ﾉ\\\", \\\"つ\\\", \\\"╰\\\", \\\"೨\\\", \\\"ɿ\\\", \\\"╎\\\", \\\"╔\\\", \\\"@\\\", \\\"╯\\\", \\\"/\\\", \\n                            \\\"I\\\", \\\"╲\\\",\\\"[\\\", \\\"{\\\", \\\"├\\\",\\\"ʕ\\\", \\\"|\\\",\\\"ʅ\\\", \\\"(\\\", \\\"└\\\", \\\"╱\\\", \\n                            \\\"I\\\", \\\"╱\\\",\\\"]\\\", \\\"}\\\", \\\"┤\\\", \\\"ʔ\\\",\\\"|\\\", \\\"ʃ\\\", \\\")\\\",\\\"┘\\\", \\\"╲\\\",  \\n                            \\\"J\\\",\\\"ʃ\\\",\\\"ʖ\\\",\\\"^\\\",\\\"L\\\",\\\"¨\\\",\\\"┘\\\",\\\"┴\\\",\\\"Δ\\\",\\\"⌒\\\",\\\"Ɔ\\\", \\\"ȷ\\\", \\\"フ\\\",\\\"ʌ\\\", \\\"へ\\\", \\\"C\\\",\\n                            \\\"┅\\\",\\\"┉\\\",\\\"─\\\", \\\"-\\\", \\\"━\\\", \\\"~\\\" ,\\\"_\\\",   \\n                            \\\"‿\\\",\\\"˽\\\", \\\"▁\\\", \\\"﹏\\\", \\\"︶\\\", \\\"︿\\\",\\\"皿\\\", \\\"⺫\\\", \\\"⌂\\\", \\\"⌒\\\", \\\"ヮ\\\", \\n                             \\\"o\\\", \\\"￢\\\", \\\"=\\\", \\\"O\\\",\\n                            \\\"◎\\\",\\\"ㆆ\\\",\\\"ಥ\\\",\\\"°\\\",\\\"®\\\",\\\"©\\\",\\\"ʘ\\\",\\\"0\\\",\\\"ಠ\\\",\\\"Ơ\\\",\\\"ø\\\",\\\"º\\\",\\\"●\\\",\\\"Ф\\\",\\\"◕\\\", \\\"ϴ\\\", \\\"e\\\" ,\\n                             \\\"♥\\\" ,\\\"$\\\" ,\\\"•\\\" ,\\\"+\\\" ,\\\"*\\\" ,\\\"×\\\" ,\\\"·\\\" ,\\\"`\\\" ,\\\":\\\" ,\\\" \\\" ,\\\"´\\\" ];  \\n\\nstruct Selfie {\\n      string hair;\\n      string forehead;\\n      string eyes;\\n      string nose;\\n      string mouth;\\n      string neck;\\n      string body;            \\n    }\\n\\n    Selfie[] public selfies;\\n\\n    mapping (uint =\\u003e address) public selfieToOwner;\\n    mapping (address =\\u003e uint) ownerSelfieCount;\\n\\n    function _createSelf(string _hair, string _forehead, string _eyes, string _nose, string _mouth, string _neck, string _body) internal whenNotPaused {\\n        uint id = selfies.push(Selfie(_hair, _forehead, _eyes, _nose, _mouth, _neck, _body)) - 1;\\n        selfieToOwner[id] = msg.sender;\\n        ownerSelfieCount[msg.sender] = ownerSelfieCount[msg.sender].add(1);\\n        randNonce = randNonce.add(1);\\n        emit NewSelfie(id, _hair, _forehead, _eyes, _nose, _mouth, _neck, _body); \\n    }\\n\\n    uint fee = 0 ether;\\n\\n    function withdraw() external onlyOwner {\\n        owner().transfer(address(this).balance);\\n    }\\n\\n    function setUpFee(uint _feecreate) external onlyOwner {\\n        fee = _feecreate;\\n    } \\n  \\n   function _createRand(uint8 j) internal view returns (uint i) {\\n        uint x = uint(keccak256(abi.encodePacked(msg.sender, randNonce))); \\n           i =  x % j;    \\n    } \\n\\n    function _createId(uint8 j) internal view returns (uint i) {\\n        uint x = uint(keccak256(abi.encodePacked(msg.sender)));  \\n         i =  x % j;    \\n    } \\n \\n    function _trait(uint8 _j, string _l ) internal view returns (string) {\\n        uint8 _n1 = uint8(_createId(100)); \\n        if (_n1 \\u003c= _j ){\\n            string memory x = _l;\\n            return x; \\n        }               \\n        else  {\\n            string memory i = \\\".\\\";\\n            return i; \\n        }       \\n    } \\n\\n    function _createBg( uint8 i) internal view returns (string) {  \\n        string memory x = string(array[_createRand(8)+95]);\\n        string memory x8 = string(abi.encodePacked(\\\".\\\" ,x ,\\\".\\\",x ,\\\".\\\" ,x ,\\\".\\\" ,x )); //8\\n        if ( i == 8){ \\n          string memory a = string(abi.encodePacked(x8));\\n          return a;\\n             } \\n           else if (i == 9) {\\n         string memory b = string(abi.encodePacked(x8,\\\".\\\")); //9\\n         return b;\\n           } \\n           else if (i == 10) {\\n         string memory c = string(abi.encodePacked(x8,\\\".\\\" ,x)); //10\\n         return c;\\n         \\n           } \\n         else  if (i == 12) {\\n         string memory d = string(abi.encodePacked(x8,\\\".\\\" ,x,\\\".\\\" ,x)); //12\\n         return d;\\n         \\n           }   \\n         else   {\\n         string memory f = string(abi.encodePacked(x8));\\n         return f;\\n         \\n           }   \\n    } \\n\\n    function _createString(uint8 i, string _a, string _b, string _c, string _d) internal view returns (string) {         \\n        if (i == 0) {\\n            string memory x = _trait(80,_a);  \\n            string memory bg = _createBg(10);  \\n            return string(abi.encodePacked(bg ,x ,_b ,x ,_b ,x ,_b ,x ,bg ));   //10\\n        } \\n        else {\\n            string memory x1 = _trait(90,_a);  \\n            string memory x2 = _trait(90,_b);\\n            string memory bg1 = _createBg(8); \\n            return string(abi.encodePacked(bg1 ,x1 ,x2 ,_c , \\\"     \\\" ,_d ,x2 ,x1 ,bg1 )); //8\\n        }                 \\n    }   \\n\\n    function _createStringOne(uint8 i, string _a, string _b, string _c, string _d) internal view returns (string) { \\n        if (i == 0){\\n            string memory x3 = _trait(70,_a); \\n            string memory bg2 = _createBg(9);  \\n            return string(abi.encodePacked(bg2,x3, _b ,\\\" \\\"  ,_d ,\\\"  \\\" ,_d ,\\\" \\\"  ,_c ,x3 ,bg2 ));  //9            \\n        }\\n        else {\\n            string memory x4 = _trait(60,_d);\\n            string memory bg3 = _createBg(8);   \\n            return string(abi.encodePacked(bg3 ,x4 ,_a ,\\\"   \\\" ,_c ,\\\"   \\\" ,_b ,x4 ,bg3 ));  //8\\n        }                        \\n    }   \\n\\n    function _createStringTwo(uint8 i, string _a, string _b, string _c, string _d) internal view returns (string) {       \\n        if (i == 0) {\\n            string memory x5 = _trait(50,_d); \\n            string memory bg4 = _createBg(9); \\n            return string(abi.encodePacked(bg4 ,x5 ,_a ,\\\"  \\\" ,_c ,\\\"  \\\" ,_b ,x5 ,bg4 )); //9\\n        }\\n        else if (i == 1) {\\n         string memory bg5 = _createBg(12); \\n         return string(abi.encodePacked(bg5 ,_a ,_b ,_a ,bg5 )); //12\\n        }\\n        else {\\n            string memory bg6 = _createBg(10); \\n            uint256 balance = msg.sender.balance;\\n            if (balance \\u003e= 200*1000000000000000000 ){\\n                 return string(abi.encodePacked(bg6 ,\\\"_.\\u003e·\\u003c._\\\" ,bg6 )); //10\\n            }               \\n            else {\\n                return string(abi.encodePacked(bg6 ,\\\"_.\\\", _a, \\\"__\\\", _b, \\\"._\\\" ,bg6)); //10\\n            }         \\n        }         \\n    } \\n\\n    function takeSelfie() external payable whenNotPaused {\\n        require(msg.value == fee);\\n        string memory _a = string(array[_createId(36)]);\\n        string memory _b = string(array[_createRand(36)]);\\n        string memory dhair =  _createString(0 ,_a , _b ,\\\"\\\" ,\\\"\\\" );     \\n        string memory dforehead =  _createString(1, _a, _b, string(array[_createId(9)+18]), string(array[_createId(9)+29]) ); \\n        string memory deyes =  _createStringOne(0, _b, string(array[_createId(8)+18]), string(array[_createId(8)+29]), string(array[_createRand(27)+70])); \\n        string memory dnose =  _createStringOne(1, string(array[_createId(9)+17]), string(array[_createId(9)+28]), string(array[_createId(16)+38]) ,_a ); \\n        string memory dmouth =  _createStringTwo(0, string(array[_createId(7)+17]), string(array[_createId(7)+28]), string(array[_createRand(23)+54]) ,_b ); \\n        string memory dneck =  _createStringTwo(1, string(array[_createId(6)+54]) ,string(array[_createId(10)+55]) ,\\\"\\\" ,\\\"\\\" ); \\n        string memory dbody =  _createStringTwo(2,string(array[_createRand(10)+16]) ,string(array[_createRand(10)+27]) ,\\\"\\\" ,\\\"\\\" ); \\n        _createSelf(dhair, dforehead, deyes, dnose, dmouth, dneck, dbody);\\n    }\\n\\n    modifier onlyOwnerOf(uint _selfieId) {\\n      require(msg.sender == selfieToOwner[_selfieId]);\\n      _;\\n    }\\n\\n    function getSelfieByOwner(address _owner) external view returns(uint[]) {\\n        uint[] memory result = new uint[](ownerSelfieCount[_owner]);\\n        uint counter = 0;\\n        for (uint i = 0; i \\u003c selfies.length; i++) {\\n          if (selfieToOwner[i] == _owner) {\\n                result[counter] = i;\\n                counter++;\\n          }\\n        }\\n        return result;\\n    }\\n\\n    modifier validDestination( address to ) {\\n        require(to != address(0x0));\\n        require(to != address(this) );\\n        _;\\n    }\\n\\n    /*ERC721*/  \\n\\n    mapping (uint =\\u003e address) selfieApprovals;\\n\\n    function balanceOf(address _owner) public view returns (uint256 _balance) {\\n        return ownerSelfieCount[_owner];\\n    }\\n\\n    function ownerOf(uint256 _tokenId) public view returns (address _owner) {\\n        return selfieToOwner[_tokenId];\\n    }\\n\\n    function _transfer(address _from, address _to, uint256 _tokenId) private validDestination(_to) {\\n        ownerSelfieCount[_to] = ownerSelfieCount[_to].add(1);\\n        ownerSelfieCount[_from] = ownerSelfieCount[_from].sub(1);\\n        selfieToOwner[_tokenId] = _to;\\n        emit Transfer(_from, _to, _tokenId);\\n    }\\n\\n    function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) validDestination(_to) {\\n        _transfer(msg.sender, _to, _tokenId);\\n    }\\n\\n    function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) validDestination(_to) {\\n        selfieApprovals[_tokenId] = _to;\\n        emit Approval(msg.sender, _to, _tokenId);\\n    }\\n\\n    function takeOwnership(uint256 _tokenId) public {\\n        require(selfieApprovals[_tokenId] == msg.sender);\\n        address  owner = ownerOf(_tokenId);\\n        _transfer(owner, msg.sender, _tokenId);\\n    }\\n\\n    function totalSupply() public view returns (uint) {\\n        return selfies.length - 1;\\n    }    \\n    \\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"takeSelfie\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"array\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"randNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"selfieToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feecreate\",\"type\":\"uint256\"}],\"name\":\"setUpFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc721Metadata\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getSelfieByOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"selfies\",\"outputs\":[{\"name\":\"hair\",\"type\":\"string\"},{\"name\":\"forehead\",\"type\":\"string\"},{\"name\":\"eyes\",\"type\":\"string\"},{\"name\":\"nose\",\"type\":\"string\"},{\"name\":\"mouth\",\"type\":\"string\"},{\"name\":\"neck\",\"type\":\"string\"},{\"name\":\"body\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"selfieId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_hair\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_forehead\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_eyes\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_nose\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_mouth\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_neck\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_body\",\"type\":\"string\"}],\"name\":\"NewSelfie\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Selfiechain","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://6d89901cdc72009f2b9c9b0311a08ba12503486228053e8a1240a4820bb46669"}]}