{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.25 <0.6.0;\npragma experimental ABIEncoderV2;\n\n\ncontract Modifiable {\n    \n    \n    \n    modifier notNullAddress(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier notThisAddress(address _address) {\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notNullOrThisAddress(address _address) {\n        require(_address != address(0));\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notSameAddresses(address _address1, address _address2) {\n        if (_address1 != _address2)\n            _;\n    }\n}\n\ncontract SelfDestructible {\n    \n    \n    \n    bool public selfDestructionDisabled;\n\n    \n    \n    \n    event SelfDestructionDisabledEvent(address wallet);\n    event TriggerSelfDestructionEvent(address wallet);\n\n    \n    \n    \n    \n    function destructor()\n    public\n    view\n    returns (address);\n\n    \n    \n    function disableSelfDestruction()\n    public\n    {\n        \n        require(destructor() == msg.sender);\n\n        \n        selfDestructionDisabled = true;\n\n        \n        emit SelfDestructionDisabledEvent(msg.sender);\n    }\n\n    \n    function triggerSelfDestruction()\n    public\n    {\n        \n        require(destructor() == msg.sender);\n\n        \n        require(!selfDestructionDisabled);\n\n        \n        emit TriggerSelfDestructionEvent(msg.sender);\n\n        \n        selfdestruct(msg.sender);\n    }\n}\n\ncontract Ownable is Modifiable, SelfDestructible {\n    \n    \n    \n    address public deployer;\n    address public operator;\n\n    \n    \n    \n    event SetDeployerEvent(address oldDeployer, address newDeployer);\n    event SetOperatorEvent(address oldOperator, address newOperator);\n\n    \n    \n    \n    constructor(address _deployer) internal notNullOrThisAddress(_deployer) {\n        deployer = _deployer;\n        operator = _deployer;\n    }\n\n    \n    \n    \n    \n    function destructor()\n    public\n    view\n    returns (address)\n    {\n        return deployer;\n    }\n\n    \n    \n    function setDeployer(address newDeployer)\n    public\n    onlyDeployer\n    notNullOrThisAddress(newDeployer)\n    {\n        if (newDeployer != deployer) {\n            \n            address oldDeployer = deployer;\n            deployer = newDeployer;\n\n            \n            emit SetDeployerEvent(oldDeployer, newDeployer);\n        }\n    }\n\n    \n    \n    function setOperator(address newOperator)\n    public\n    onlyOperator\n    notNullOrThisAddress(newOperator)\n    {\n        if (newOperator != operator) {\n            \n            address oldOperator = operator;\n            operator = newOperator;\n\n            \n            emit SetOperatorEvent(oldOperator, newOperator);\n        }\n    }\n\n    \n    \n    function isDeployer()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == deployer;\n    }\n\n    \n    \n    function isOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == operator;\n    }\n\n    \n    \n    \n    function isDeployerOrOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return isDeployer() || isOperator();\n    }\n\n    \n    \n    modifier onlyDeployer() {\n        require(isDeployer());\n        _;\n    }\n\n    modifier notDeployer() {\n        require(!isDeployer());\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(isOperator());\n        _;\n    }\n\n    modifier notOperator() {\n        require(!isOperator());\n        _;\n    }\n\n    modifier onlyDeployerOrOperator() {\n        require(isDeployerOrOperator());\n        _;\n    }\n\n    modifier notDeployerOrOperator() {\n        require(!isDeployerOrOperator());\n        _;\n    }\n}\n\ncontract Servable is Ownable {\n    \n    \n    \n    struct ServiceInfo {\n        bool registered;\n        uint256 activationTimestamp;\n        mapping(bytes32 => bool) actionsEnabledMap;\n        bytes32[] actionsList;\n    }\n\n    \n    \n    \n    mapping(address => ServiceInfo) internal registeredServicesMap;\n    uint256 public serviceActivationTimeout;\n\n    \n    \n    \n    event ServiceActivationTimeoutEvent(uint256 timeoutInSeconds);\n    event RegisterServiceEvent(address service);\n    event RegisterServiceDeferredEvent(address service, uint256 timeout);\n    event DeregisterServiceEvent(address service);\n    event EnableServiceActionEvent(address service, string action);\n    event DisableServiceActionEvent(address service, string action);\n\n    \n    \n    \n    \n    \n    function setServiceActivationTimeout(uint256 timeoutInSeconds)\n    public\n    onlyDeployer\n    {\n        serviceActivationTimeout = timeoutInSeconds;\n\n        \n        emit ServiceActivationTimeoutEvent(timeoutInSeconds);\n    }\n\n    \n    \n    function registerService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, 0);\n\n        \n        emit RegisterServiceEvent(service);\n    }\n\n    \n    \n    function registerServiceDeferred(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, serviceActivationTimeout);\n\n        \n        emit RegisterServiceDeferredEvent(service, serviceActivationTimeout);\n    }\n\n    \n    \n    function deregisterService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        registeredServicesMap[service].registered = false;\n\n        \n        emit DeregisterServiceEvent(service);\n    }\n\n    \n    \n    \n    function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        \n        emit EnableServiceActionEvent(service, action);\n    }\n\n    \n    \n    \n    function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        \n        emit DisableServiceActionEvent(service, action);\n    }\n\n    \n    \n    \n    function isRegisteredService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return registeredServicesMap[service].registered;\n    }\n\n    \n    \n    \n    function isRegisteredActiveService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return isRegisteredService(service) && block.timestamp >= registeredServicesMap[service].activationTimestamp;\n    }\n\n    \n    \n    \n    function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }\n\n    \n    \n    \n    function hashString(string memory _string)\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_string));\n    }\n\n    \n    \n    \n    function _registerService(address service, uint256 timeout)\n    private\n    {\n        if (!registeredServicesMap[service].registered) {\n            registeredServicesMap[service].registered = true;\n            registeredServicesMap[service].activationTimestamp = block.timestamp + timeout;\n        }\n    }\n\n    \n    \n    \n    modifier onlyActiveService() {\n        require(isRegisteredActiveService(msg.sender));\n        _;\n    }\n\n    modifier onlyEnabledServiceAction(string memory action) {\n        require(isEnabledServiceAction(msg.sender, action));\n        _;\n    }\n}\n\nlibrary SafeMathIntLib {\n    int256 constant INT256_MIN = int256((uint256(1) << 255));\n    int256 constant INT256_MAX = int256(~((uint256(1) << 255)));\n\n    \n    \n    \n    function div(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != INT256_MIN || b != - 1);\n        return a / b;\n    }\n\n    function mul(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a != - 1 || b != INT256_MIN);\n        \n        require(b != - 1 || a != INT256_MIN);\n        \n        int256 c = a * b;\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    function sub(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\n        return a - b;\n    }\n\n    function add(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n\n    \n    \n    \n    function div_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b > 0);\n        return a / b;\n    }\n\n    function mul_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a * b;\n        require(a == 0 || c / a == b);\n        require(c >= 0);\n        return c;\n    }\n\n    function sub_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0 && b <= a);\n        return a - b;\n    }\n\n    function add_nn(int256 a, int256 b)\n    internal\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && b >= 0);\n        int256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    \n    \n    \n    function abs(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return a < 0 ? neg(a) : a;\n    }\n\n    function neg(int256 a)\n    public\n    pure\n    returns (int256)\n    {\n        return mul(a, - 1);\n    }\n\n    function toNonZeroInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a > 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toInt256(uint256 a)\n    public\n    pure\n    returns (int256)\n    {\n        require(a >= 0 && a < (uint256(1) << 255));\n        return int256(a);\n    }\n\n    function toUInt256(int256 a)\n    public\n    pure\n    returns (uint256)\n    {\n        require(a >= 0);\n        return uint256(a);\n    }\n\n    function isNonZeroPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a > 0);\n    }\n\n    function isPositiveInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a >= 0);\n    }\n\n    function isNonZeroNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a < 0);\n    }\n\n    function isNegativeInt256(int256 a)\n    public\n    pure\n    returns (bool)\n    {\n        return (a <= 0);\n    }\n\n    \n    \n    \n    function clamp(int256 a, int256 min, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        if (a < min)\n            return min;\n        return (a > max) ? max : a;\n    }\n\n    function clampMin(int256 a, int256 min)\n    public\n    pure\n    returns (int256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(int256 a, int256 max)\n    public\n    pure\n    returns (int256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\nlibrary BlockNumbUintsLib {\n    \n    \n    \n    struct Entry {\n        uint256 blockNumber;\n        uint256 value;\n    }\n\n    struct BlockNumbUints {\n        Entry[] entries;\n    }\n\n    \n    \n    \n    function currentValue(BlockNumbUints storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbUints storage self)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbUints storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbUints storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbUints storage self, uint256 blockNumber, uint256 value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbUintsLib.sol:62]\"\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbUints storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbUints storage self)\n    internal\n    view\n    returns (Entry[] memory)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbUints storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbUintsLib.sol:92]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\nlibrary BlockNumbIntsLib {\n    \n    \n    \n    struct Entry {\n        uint256 blockNumber;\n        int256 value;\n    }\n\n    struct BlockNumbInts {\n        Entry[] entries;\n    }\n\n    \n    \n    \n    function currentValue(BlockNumbInts storage self)\n    internal\n    view\n    returns (int256)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbInts storage self)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbInts storage self, uint256 blockNumber, int256 value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbIntsLib.sol:62]\"\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbInts storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbInts storage self)\n    internal\n    view\n    returns (Entry[] memory)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbInts storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbIntsLib.sol:92]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\nlibrary ConstantsLib {\n    \n    function PARTS_PER()\n    public\n    pure\n    returns (int256)\n    {\n        return 1e18;\n    }\n}\n\nlibrary BlockNumbDisdIntsLib {\n    using SafeMathIntLib for int256;\n\n    \n    \n    \n    struct Discount {\n        int256 tier;\n        int256 value;\n    }\n\n    struct Entry {\n        uint256 blockNumber;\n        int256 nominal;\n        Discount[] discounts;\n    }\n\n    struct BlockNumbDisdInts {\n        Entry[] entries;\n    }\n\n    \n    \n    \n    function currentNominalValue(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (int256)\n    {\n        return nominalValueAt(self, block.number);\n    }\n\n    function currentDiscountedValue(BlockNumbDisdInts storage self, int256 tier)\n    internal\n    view\n    returns (int256)\n    {\n        return discountedValueAt(self, block.number, tier);\n    }\n\n    function currentEntry(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function nominalValueAt(BlockNumbDisdInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        return entryAt(self, _blockNumber).nominal;\n    }\n\n    function discountedValueAt(BlockNumbDisdInts storage self, uint256 _blockNumber, int256 tier)\n    internal\n    view\n    returns (int256)\n    {\n        Entry memory entry = entryAt(self, _blockNumber);\n        if (0 < entry.discounts.length) {\n            uint256 index = indexByTier(entry.discounts, tier);\n            if (0 < index)\n                return entry.nominal.mul(\n                    ConstantsLib.PARTS_PER().sub(entry.discounts[index - 1].value)\n                ).div(\n                    ConstantsLib.PARTS_PER()\n                );\n            else\n                return entry.nominal;\n        } else\n            return entry.nominal;\n    }\n\n    function entryAt(BlockNumbDisdInts storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry memory)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addNominalEntry(BlockNumbDisdInts storage self, uint256 blockNumber, int256 nominal)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbDisdIntsLib.sol:101]\"\n        );\n\n        self.entries.length++;\n        Entry storage entry = self.entries[self.entries.length - 1];\n\n        entry.blockNumber = blockNumber;\n        entry.nominal = nominal;\n    }\n\n    function addDiscountedEntry(BlockNumbDisdInts storage self, uint256 blockNumber, int256 nominal,\n        int256[] memory discountTiers, int256[] memory discountValues)\n    internal\n    {\n        require(discountTiers.length == discountValues.length, \"Parameter array lengths mismatch [BlockNumbDisdIntsLib.sol:118]\");\n\n        addNominalEntry(self, blockNumber, nominal);\n\n        Entry storage entry = self.entries[self.entries.length - 1];\n        for (uint256 i = 0; i < discountTiers.length; i++)\n            entry.discounts.push(Discount(discountTiers[i], discountValues[i]));\n    }\n\n    function count(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbDisdInts storage self)\n    internal\n    view\n    returns (Entry[] memory)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbDisdInts storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbDisdIntsLib.sol:148]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n\n    \n    function indexByTier(Discount[] memory discounts, int256 tier)\n    internal\n    pure\n    returns (uint256)\n    {\n        require(0 < discounts.length, \"No discounts found [BlockNumbDisdIntsLib.sol:161]\");\n        for (uint256 i = discounts.length; i > 0; i--)\n            if (tier >= discounts[i - 1].tier)\n                return i;\n        return 0;\n    }\n}\n\nlibrary MonetaryTypesLib {\n    \n    \n    \n    struct Currency {\n        address ct;\n        uint256 id;\n    }\n\n    struct Figure {\n        int256 amount;\n        Currency currency;\n    }\n\n    struct NoncedAmount {\n        uint256 nonce;\n        int256 amount;\n    }\n}\n\nlibrary BlockNumbReferenceCurrenciesLib {\n    \n    \n    \n    struct Entry {\n        uint256 blockNumber;\n        MonetaryTypesLib.Currency currency;\n    }\n\n    struct BlockNumbReferenceCurrencies {\n        mapping(address => mapping(uint256 => Entry[])) entriesByCurrency;\n    }\n\n    \n    \n    \n    function currentCurrency(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency storage)\n    {\n        return currencyAt(self, referenceCurrency, block.number);\n    }\n\n    function currentEntry(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return entryAt(self, referenceCurrency, block.number);\n    }\n\n    function currencyAt(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency,\n        uint256 _blockNumber)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency storage)\n    {\n        return entryAt(self, referenceCurrency, _blockNumber).currency;\n    }\n\n    function entryAt(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency,\n        uint256 _blockNumber)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][indexByBlockNumber(self, referenceCurrency, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbReferenceCurrencies storage self, uint256 blockNumber,\n        MonetaryTypesLib.Currency memory referenceCurrency, MonetaryTypesLib.Currency memory currency)\n    internal\n    {\n        require(\n            0 == self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length ||\n        blockNumber > self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length - 1].blockNumber,\n            \"Later entry found for currency [BlockNumbReferenceCurrenciesLib.sol:67]\"\n        );\n\n        self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].push(Entry(blockNumber, currency));\n    }\n\n    function count(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length;\n    }\n\n    function entriesByCurrency(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\n    internal\n    view\n    returns (Entry[] storage)\n    {\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id];\n    }\n\n    function indexByBlockNumber(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length, \"No entries found for currency [BlockNumbReferenceCurrenciesLib.sol:97]\");\n        for (uint256 i = self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length - 1; i >= 0; i--)\n            if (blockNumber >= self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\nlibrary BlockNumbFiguresLib {\n    \n    \n    \n    struct Entry {\n        uint256 blockNumber;\n        MonetaryTypesLib.Figure value;\n    }\n\n    struct BlockNumbFigures {\n        Entry[] entries;\n    }\n\n    \n    \n    \n    function currentValue(BlockNumbFigures storage self)\n    internal\n    view\n    returns (MonetaryTypesLib.Figure storage)\n    {\n        return valueAt(self, block.number);\n    }\n\n    function currentEntry(BlockNumbFigures storage self)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return entryAt(self, block.number);\n    }\n\n    function valueAt(BlockNumbFigures storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (MonetaryTypesLib.Figure storage)\n    {\n        return entryAt(self, _blockNumber).value;\n    }\n\n    function entryAt(BlockNumbFigures storage self, uint256 _blockNumber)\n    internal\n    view\n    returns (Entry storage)\n    {\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\n    }\n\n    function addEntry(BlockNumbFigures storage self, uint256 blockNumber, MonetaryTypesLib.Figure memory value)\n    internal\n    {\n        require(\n            0 == self.entries.length ||\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\n            \"Later entry found [BlockNumbFiguresLib.sol:65]\"\n        );\n\n        self.entries.push(Entry(blockNumber, value));\n    }\n\n    function count(BlockNumbFigures storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.entries.length;\n    }\n\n    function entries(BlockNumbFigures storage self)\n    internal\n    view\n    returns (Entry[] storage)\n    {\n        return self.entries;\n    }\n\n    function indexByBlockNumber(BlockNumbFigures storage self, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        require(0 < self.entries.length, \"No entries found [BlockNumbFiguresLib.sol:95]\");\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\n            if (blockNumber >= self.entries[i].blockNumber)\n                return i;\n        revert();\n    }\n}\n\ncontract Configuration is Modifiable, Ownable, Servable {\n    using SafeMathIntLib for int256;\n    using BlockNumbUintsLib for BlockNumbUintsLib.BlockNumbUints;\n    using BlockNumbIntsLib for BlockNumbIntsLib.BlockNumbInts;\n    using BlockNumbDisdIntsLib for BlockNumbDisdIntsLib.BlockNumbDisdInts;\n    using BlockNumbReferenceCurrenciesLib for BlockNumbReferenceCurrenciesLib.BlockNumbReferenceCurrencies;\n    using BlockNumbFiguresLib for BlockNumbFiguresLib.BlockNumbFigures;\n\n    \n    \n    \n    string constant public OPERATIONAL_MODE_ACTION = \"operational_mode\";\n\n    \n    \n    \n    enum OperationalMode {Normal, Exit}\n\n    \n    \n    \n    OperationalMode public operationalMode = OperationalMode.Normal;\n\n    BlockNumbUintsLib.BlockNumbUints private updateDelayBlocksByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private confirmationBlocksByBlockNumber;\n\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private tradeMakerFeeByBlockNumber;\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private tradeTakerFeeByBlockNumber;\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private paymentFeeByBlockNumber;\n    mapping(address => mapping(uint256 => BlockNumbDisdIntsLib.BlockNumbDisdInts)) private currencyPaymentFeeByBlockNumber;\n\n    BlockNumbIntsLib.BlockNumbInts private tradeMakerMinimumFeeByBlockNumber;\n    BlockNumbIntsLib.BlockNumbInts private tradeTakerMinimumFeeByBlockNumber;\n    BlockNumbIntsLib.BlockNumbInts private paymentMinimumFeeByBlockNumber;\n    mapping(address => mapping(uint256 => BlockNumbIntsLib.BlockNumbInts)) private currencyPaymentMinimumFeeByBlockNumber;\n\n    BlockNumbReferenceCurrenciesLib.BlockNumbReferenceCurrencies private feeCurrencyByCurrencyBlockNumber;\n\n    BlockNumbUintsLib.BlockNumbUints private walletLockTimeoutByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private cancelOrderChallengeTimeoutByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private settlementChallengeTimeoutByBlockNumber;\n\n    BlockNumbUintsLib.BlockNumbUints private fraudStakeFractionByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private walletSettlementStakeFractionByBlockNumber;\n    BlockNumbUintsLib.BlockNumbUints private operatorSettlementStakeFractionByBlockNumber;\n\n    BlockNumbFiguresLib.BlockNumbFigures private operatorSettlementStakeByBlockNumber;\n\n    uint256 public earliestSettlementBlockNumber;\n    bool public earliestSettlementBlockNumberUpdateDisabled;\n\n    \n    \n    \n    event SetOperationalModeExitEvent();\n    event SetUpdateDelayBlocksEvent(uint256 fromBlockNumber, uint256 newBlocks);\n    event SetConfirmationBlocksEvent(uint256 fromBlockNumber, uint256 newBlocks);\n    event SetTradeMakerFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetTradeTakerFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetPaymentFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\n    event SetCurrencyPaymentFeeEvent(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] discountTiers, int256[] discountValues);\n    event SetTradeMakerMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetTradeTakerMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetPaymentMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\n    event SetCurrencyPaymentMinimumFeeEvent(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal);\n    event SetFeeCurrencyEvent(uint256 fromBlockNumber, address referenceCurrencyCt, uint256 referenceCurrencyId,\n        address feeCurrencyCt, uint256 feeCurrencyId);\n    event SetWalletLockTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetCancelOrderChallengeTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetSettlementChallengeTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\n    event SetWalletSettlementStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetOperatorSettlementStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetOperatorSettlementStakeEvent(uint256 fromBlockNumber, int256 stakeAmount, address stakeCurrencyCt,\n        uint256 stakeCurrencyId);\n    event SetFraudStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\n    event SetEarliestSettlementBlockNumberEvent(uint256 earliestSettlementBlockNumber);\n    event DisableEarliestSettlementBlockNumberUpdateEvent();\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n        updateDelayBlocksByBlockNumber.addEntry(block.number, 0);\n    }\n\n    \n    \n    \n    \n    \n    function setOperationalModeExit()\n    public\n    onlyEnabledServiceAction(OPERATIONAL_MODE_ACTION)\n    {\n        operationalMode = OperationalMode.Exit;\n        emit SetOperationalModeExitEvent();\n    }\n\n    \n    function isOperationalModeNormal()\n    public\n    view\n    returns (bool)\n    {\n        return OperationalMode.Normal == operationalMode;\n    }\n\n    \n    function isOperationalModeExit()\n    public\n    view\n    returns (bool)\n    {\n        return OperationalMode.Exit == operationalMode;\n    }\n\n    \n    \n    function updateDelayBlocks()\n    public\n    view\n    returns (uint256)\n    {\n        return updateDelayBlocksByBlockNumber.currentValue();\n    }\n\n    \n    \n    function updateDelayBlocksCount()\n    public\n    view\n    returns (uint256)\n    {\n        return updateDelayBlocksByBlockNumber.count();\n    }\n\n    \n    \n    \n    function setUpdateDelayBlocks(uint256 fromBlockNumber, uint256 newUpdateDelayBlocks)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        updateDelayBlocksByBlockNumber.addEntry(fromBlockNumber, newUpdateDelayBlocks);\n        emit SetUpdateDelayBlocksEvent(fromBlockNumber, newUpdateDelayBlocks);\n    }\n\n    \n    \n    function confirmationBlocks()\n    public\n    view\n    returns (uint256)\n    {\n        return confirmationBlocksByBlockNumber.currentValue();\n    }\n\n    \n    \n    function confirmationBlocksCount()\n    public\n    view\n    returns (uint256)\n    {\n        return confirmationBlocksByBlockNumber.count();\n    }\n\n    \n    \n    \n    function setConfirmationBlocks(uint256 fromBlockNumber, uint256 newConfirmationBlocks)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        confirmationBlocksByBlockNumber.addEntry(fromBlockNumber, newConfirmationBlocks);\n        emit SetConfirmationBlocksEvent(fromBlockNumber, newConfirmationBlocks);\n    }\n\n    \n    function tradeMakerFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeMakerFeeByBlockNumber.count();\n    }\n\n    \n    \n    \n    function tradeMakerFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return tradeMakerFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    \n    \n    \n    \n    \n    function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    \n    function tradeTakerFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeTakerFeeByBlockNumber.count();\n    }\n\n    \n    \n    \n    function tradeTakerFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return tradeTakerFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    \n    \n    \n    \n    \n    function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    \n    function paymentFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return paymentFeeByBlockNumber.count();\n    }\n\n    \n    \n    \n    function paymentFee(uint256 blockNumber, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        return paymentFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\n    }\n\n    \n    \n    \n    \n    \n    function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }\n\n    \n    \n    \n    function currencyPaymentFeesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return currencyPaymentFeeByBlockNumber[currencyCt][currencyId].count();\n    }\n\n    \n    \n    \n    \n    \n    \n    function currencyPaymentFee(uint256 blockNumber, address currencyCt, uint256 currencyId, int256 discountTier)\n    public\n    view\n    returns (int256)\n    {\n        if (0 < currencyPaymentFeeByBlockNumber[currencyCt][currencyId].count())\n            return currencyPaymentFeeByBlockNumber[currencyCt][currencyId].discountedValueAt(\n                blockNumber, discountTier\n            );\n        else\n            return paymentFee(blockNumber, discountTier);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }\n\n    \n    function tradeMakerMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeMakerMinimumFeeByBlockNumber.count();\n    }\n\n    \n    \n    function tradeMakerMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return tradeMakerMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    \n    \n    \n    function setTradeMakerMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetTradeMakerMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    \n    function tradeTakerMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return tradeTakerMinimumFeeByBlockNumber.count();\n    }\n\n    \n    \n    function tradeTakerMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return tradeTakerMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    \n    \n    \n    function setTradeTakerMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetTradeTakerMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    \n    function paymentMinimumFeesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return paymentMinimumFeeByBlockNumber.count();\n    }\n\n    \n    \n    function paymentMinimumFee(uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        return paymentMinimumFeeByBlockNumber.valueAt(blockNumber);\n    }\n\n    \n    \n    \n    function setPaymentMinimumFee(uint256 fromBlockNumber, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\n        emit SetPaymentMinimumFeeEvent(fromBlockNumber, nominal);\n    }\n\n    \n    \n    \n    function currencyPaymentMinimumFeesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].count();\n    }\n\n    \n    \n    \n    \n    function currencyPaymentMinimumFee(uint256 blockNumber, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        if (0 < currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].count())\n            return currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].valueAt(blockNumber);\n        else\n            return paymentMinimumFee(blockNumber);\n    }\n\n    \n    \n    \n    \n    \n    function setCurrencyPaymentMinimumFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].addEntry(fromBlockNumber, nominal);\n        emit SetCurrencyPaymentMinimumFeeEvent(fromBlockNumber, currencyCt, currencyId, nominal);\n    }\n\n    \n    \n    \n    function feeCurrenciesCount(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return feeCurrencyByCurrencyBlockNumber.count(MonetaryTypesLib.Currency(currencyCt, currencyId));\n    }\n\n    \n    \n    \n    \n    function feeCurrency(uint256 blockNumber, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (address ct, uint256 id)\n    {\n        MonetaryTypesLib.Currency storage _feeCurrency = feeCurrencyByCurrencyBlockNumber.currencyAt(\n            MonetaryTypesLib.Currency(currencyCt, currencyId), blockNumber\n        );\n        ct = _feeCurrency.ct;\n        id = _feeCurrency.id;\n    }\n\n    \n    \n    \n    \n    \n    \n    function setFeeCurrency(uint256 fromBlockNumber, address referenceCurrencyCt, uint256 referenceCurrencyId,\n        address feeCurrencyCt, uint256 feeCurrencyId)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        feeCurrencyByCurrencyBlockNumber.addEntry(\n            fromBlockNumber,\n            MonetaryTypesLib.Currency(referenceCurrencyCt, referenceCurrencyId),\n            MonetaryTypesLib.Currency(feeCurrencyCt, feeCurrencyId)\n        );\n        emit SetFeeCurrencyEvent(fromBlockNumber, referenceCurrencyCt, referenceCurrencyId,\n            feeCurrencyCt, feeCurrencyId);\n    }\n\n    \n    \n    function walletLockTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return walletLockTimeoutByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    function setWalletLockTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        walletLockTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetWalletLockTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    \n    \n    function cancelOrderChallengeTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return cancelOrderChallengeTimeoutByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    function setCancelOrderChallengeTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        cancelOrderChallengeTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetCancelOrderChallengeTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    \n    \n    function settlementChallengeTimeout()\n    public\n    view\n    returns (uint256)\n    {\n        return settlementChallengeTimeoutByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    function setSettlementChallengeTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        settlementChallengeTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\n        emit SetSettlementChallengeTimeoutEvent(fromBlockNumber, timeoutInSeconds);\n    }\n\n    \n    \n    function fraudStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return fraudStakeFractionByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    \n    function setFraudStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        fraudStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetFraudStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    \n    \n    function walletSettlementStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return walletSettlementStakeFractionByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    \n    function setWalletSettlementStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        walletSettlementStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetWalletSettlementStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    \n    \n    function operatorSettlementStakeFraction()\n    public\n    view\n    returns (uint256)\n    {\n        return operatorSettlementStakeFractionByBlockNumber.currentValue();\n    }\n\n    \n    \n    \n    \n    function setOperatorSettlementStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        operatorSettlementStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\n        emit SetOperatorSettlementStakeFractionEvent(fromBlockNumber, stakeFraction);\n    }\n\n    \n    \n    function operatorSettlementStake()\n    public\n    view\n    returns (int256 amount, address currencyCt, uint256 currencyId)\n    {\n        MonetaryTypesLib.Figure storage stake = operatorSettlementStakeByBlockNumber.currentValue();\n        amount = stake.amount;\n        currencyCt = stake.currency.ct;\n        currencyId = stake.currency.id;\n    }\n\n    \n    \n    \n    \n    \n    \n    function setOperatorSettlementStake(uint256 fromBlockNumber, int256 stakeAmount,\n        address stakeCurrencyCt, uint256 stakeCurrencyId)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        MonetaryTypesLib.Figure memory stake = MonetaryTypesLib.Figure(stakeAmount, MonetaryTypesLib.Currency(stakeCurrencyCt, stakeCurrencyId));\n        operatorSettlementStakeByBlockNumber.addEntry(fromBlockNumber, stake);\n        emit SetOperatorSettlementStakeEvent(fromBlockNumber, stakeAmount, stakeCurrencyCt, stakeCurrencyId);\n    }\n\n    \n    \n    function setEarliestSettlementBlockNumber(uint256 _earliestSettlementBlockNumber)\n    public\n    onlyOperator\n    {\n        require(!earliestSettlementBlockNumberUpdateDisabled, \"Earliest settlement block number update disabled [Configuration.sol:715]\");\n\n        earliestSettlementBlockNumber = _earliestSettlementBlockNumber;\n        emit SetEarliestSettlementBlockNumberEvent(earliestSettlementBlockNumber);\n    }\n\n    \n    \n    function disableEarliestSettlementBlockNumberUpdate()\n    public\n    onlyOperator\n    {\n        earliestSettlementBlockNumberUpdateDisabled = true;\n        emit DisableEarliestSettlementBlockNumberUpdateEvent();\n    }\n\n    \n    \n    \n    modifier onlyDelayedBlockNumber(uint256 blockNumber) {\n        require(\n            0 == updateDelayBlocksByBlockNumber.count() ||\n        blockNumber >= block.number + updateDelayBlocksByBlockNumber.currentValue(),\n            \"Block number not sufficiently delayed [Configuration.sol:735]\"\n        );\n        _;\n    }\n}\n\ncontract Configurable is Ownable {\n    \n    \n    \n    Configuration public configuration;\n\n    \n    \n    \n    event SetConfigurationEvent(Configuration oldConfiguration, Configuration newConfiguration);\n\n    \n    \n    \n    \n    \n    function setConfiguration(Configuration newConfiguration)\n    public\n    onlyDeployer\n    notNullAddress(address(newConfiguration))\n    notSameAddresses(address(newConfiguration), address(configuration))\n    {\n        \n        Configuration oldConfiguration = configuration;\n        configuration = newConfiguration;\n\n        \n        emit SetConfigurationEvent(oldConfiguration, newConfiguration);\n    }\n\n    \n    \n    \n    modifier configurationInitialized() {\n        require(address(configuration) != address(0), \"Configuration not initialized [Configurable.sol:52]\");\n        _;\n    }\n}\n\nlibrary SafeMathUintLib {\n    function mul(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        \n        uint256 c = a / b;\n        \n        return c;\n    }\n\n    function sub(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    \n    \n    \n    function clamp(uint256 a, uint256 min, uint256 max)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a > max) ? max : ((a < min) ? min : a);\n    }\n\n    function clampMin(uint256 a, uint256 min)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a < min) ? min : a;\n    }\n\n    function clampMax(uint256 a, uint256 max)\n    public\n    pure\n    returns (uint256)\n    {\n        return (a > max) ? max : a;\n    }\n}\n\nlibrary NahmiiTypesLib {\n    \n    \n    \n    enum ChallengePhase {Dispute, Closed}\n\n    \n    \n    \n    struct OriginFigure {\n        uint256 originId;\n        MonetaryTypesLib.Figure figure;\n    }\n\n    struct IntendedConjugateCurrency {\n        MonetaryTypesLib.Currency intended;\n        MonetaryTypesLib.Currency conjugate;\n    }\n\n    struct SingleFigureTotalOriginFigures {\n        MonetaryTypesLib.Figure single;\n        OriginFigure[] total;\n    }\n\n    struct TotalOriginFigures {\n        OriginFigure[] total;\n    }\n\n    struct CurrentPreviousInt256 {\n        int256 current;\n        int256 previous;\n    }\n\n    struct SingleTotalInt256 {\n        int256 single;\n        int256 total;\n    }\n\n    struct IntendedConjugateCurrentPreviousInt256 {\n        CurrentPreviousInt256 intended;\n        CurrentPreviousInt256 conjugate;\n    }\n\n    struct IntendedConjugateSingleTotalInt256 {\n        SingleTotalInt256 intended;\n        SingleTotalInt256 conjugate;\n    }\n\n    struct WalletOperatorHashes {\n        bytes32 wallet;\n        bytes32 operator;\n    }\n\n    struct Signature {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n    }\n\n    struct Seal {\n        bytes32 hash;\n        Signature signature;\n    }\n\n    struct WalletOperatorSeal {\n        Seal wallet;\n        Seal operator;\n    }\n}\n\nlibrary PaymentTypesLib {\n    \n    \n    \n    enum PaymentPartyRole {Sender, Recipient}\n\n    \n    \n    \n    struct PaymentSenderParty {\n        uint256 nonce;\n        address wallet;\n\n        NahmiiTypesLib.CurrentPreviousInt256 balances;\n\n        NahmiiTypesLib.SingleFigureTotalOriginFigures fees;\n\n        string data;\n    }\n\n    struct PaymentRecipientParty {\n        uint256 nonce;\n        address wallet;\n\n        NahmiiTypesLib.CurrentPreviousInt256 balances;\n\n        NahmiiTypesLib.TotalOriginFigures fees;\n    }\n\n    struct Operator {\n        uint256 id;\n        string data;\n    }\n\n    struct Payment {\n        int256 amount;\n        MonetaryTypesLib.Currency currency;\n\n        PaymentSenderParty sender;\n        PaymentRecipientParty recipient;\n\n        \n        NahmiiTypesLib.SingleTotalInt256 transfers;\n\n        NahmiiTypesLib.WalletOperatorSeal seals;\n        uint256 blockNumber;\n\n        Operator operator;\n    }\n\n    \n    \n    \n    function PAYMENT_KIND()\n    public\n    pure\n    returns (string memory)\n    {\n        return \"payment\";\n    }\n}\n\ncontract PaymentHasher is Ownable {\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    function hashPaymentAsWallet(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 amountCurrencyHash = hashPaymentAmountCurrency(payment);\n        bytes32 senderHash = hashPaymentSenderPartyAsWallet(payment.sender);\n        bytes32 recipientHash = hashAddress(payment.recipient.wallet);\n\n        return keccak256(abi.encodePacked(amountCurrencyHash, senderHash, recipientHash));\n    }\n\n    function hashPaymentAsOperator(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 walletSignatureHash = hashSignature(payment.seals.wallet.signature);\n        bytes32 senderHash = hashPaymentSenderPartyAsOperator(payment.sender);\n        bytes32 recipientHash = hashPaymentRecipientPartyAsOperator(payment.recipient);\n        bytes32 transfersHash = hashSingleTotalInt256(payment.transfers);\n        bytes32 operatorHash = hashString(payment.operator.data);\n\n        return keccak256(abi.encodePacked(\n                walletSignatureHash, senderHash, recipientHash, transfersHash, operatorHash\n            ));\n    }\n\n    function hashPaymentAmountCurrency(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                payment.amount,\n                payment.currency.ct,\n                payment.currency.id\n            ));\n    }\n\n    function hashPaymentSenderPartyAsWallet(\n        PaymentTypesLib.PaymentSenderParty memory paymentSenderParty)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                paymentSenderParty.wallet,\n                paymentSenderParty.data\n            ));\n    }\n\n    function hashPaymentSenderPartyAsOperator(\n        PaymentTypesLib.PaymentSenderParty memory paymentSenderParty)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 rootHash = hashUint256(paymentSenderParty.nonce);\n        bytes32 balancesHash = hashCurrentPreviousInt256(paymentSenderParty.balances);\n        bytes32 singleFeeHash = hashFigure(paymentSenderParty.fees.single);\n        bytes32 totalFeesHash = hashOriginFigures(paymentSenderParty.fees.total);\n\n        return keccak256(abi.encodePacked(\n                rootHash, balancesHash, singleFeeHash, totalFeesHash\n            ));\n    }\n\n    function hashPaymentRecipientPartyAsOperator(\n        PaymentTypesLib.PaymentRecipientParty memory paymentRecipientParty)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 rootHash = hashUint256(paymentRecipientParty.nonce);\n        bytes32 balancesHash = hashCurrentPreviousInt256(paymentRecipientParty.balances);\n        bytes32 totalFeesHash = hashOriginFigures(paymentRecipientParty.fees.total);\n\n        return keccak256(abi.encodePacked(\n                rootHash, balancesHash, totalFeesHash\n            ));\n    }\n\n    function hashCurrentPreviousInt256(\n        NahmiiTypesLib.CurrentPreviousInt256 memory currentPreviousInt256)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                currentPreviousInt256.current,\n                currentPreviousInt256.previous\n            ));\n    }\n\n    function hashSingleTotalInt256(\n        NahmiiTypesLib.SingleTotalInt256 memory singleTotalInt256)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                singleTotalInt256.single,\n                singleTotalInt256.total\n            ));\n    }\n\n    function hashFigure(MonetaryTypesLib.Figure memory figure)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                figure.amount,\n                figure.currency.ct,\n                figure.currency.id\n            ));\n    }\n\n    function hashOriginFigures(NahmiiTypesLib.OriginFigure[] memory originFigures)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 hash;\n        for (uint256 i = 0; i < originFigures.length; i++) {\n            hash = keccak256(abi.encodePacked(\n                    hash,\n                    originFigures[i].originId,\n                    originFigures[i].figure.amount,\n                    originFigures[i].figure.currency.ct,\n                    originFigures[i].figure.currency.id\n                )\n            );\n        }\n        return hash;\n    }\n\n    function hashUint256(uint256 _uint256)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_uint256));\n    }\n\n    function hashString(string memory _string)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_string));\n    }\n\n    function hashAddress(address _address)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_address));\n    }\n\n    function hashSignature(NahmiiTypesLib.Signature memory signature)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n                signature.v,\n                signature.r,\n                signature.s\n            ));\n    }\n}\n\ncontract PaymentHashable is Ownable {\n    \n    \n    \n    PaymentHasher public paymentHasher;\n\n    \n    \n    \n    event SetPaymentHasherEvent(PaymentHasher oldPaymentHasher, PaymentHasher newPaymentHasher);\n\n    \n    \n    \n    \n    \n    function setPaymentHasher(PaymentHasher newPaymentHasher)\n    public\n    onlyDeployer\n    notNullAddress(address(newPaymentHasher))\n    notSameAddresses(address(newPaymentHasher), address(paymentHasher))\n    {\n        \n        PaymentHasher oldPaymentHasher = paymentHasher;\n        paymentHasher = newPaymentHasher;\n\n        \n        emit SetPaymentHasherEvent(oldPaymentHasher, newPaymentHasher);\n    }\n\n    \n    \n    \n    modifier paymentHasherInitialized() {\n        require(address(paymentHasher) != address(0), \"Payment hasher not initialized [PaymentHashable.sol:52]\");\n        _;\n    }\n}\n\ncontract SignerManager is Ownable {\n    using SafeMathUintLib for uint256;\n    \n    \n    \n    \n    mapping(address => uint256) public signerIndicesMap; \n    address[] public signers;\n\n    \n    \n    \n    event RegisterSignerEvent(address signer);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n        registerSigner(deployer);\n    }\n\n    \n    \n    \n    \n    \n    \n    function isSigner(address _address)\n    public\n    view\n    returns (bool)\n    {\n        return 0 < signerIndicesMap[_address];\n    }\n\n    \n    \n    function signersCount()\n    public\n    view\n    returns (uint256)\n    {\n        return signers.length;\n    }\n\n    \n    \n    \n    function signerIndex(address _address)\n    public\n    view\n    returns (uint256)\n    {\n        require(isSigner(_address), \"Address not signer [SignerManager.sol:71]\");\n        return signerIndicesMap[_address] - 1;\n    }\n\n    \n    \n    function registerSigner(address newSigner)\n    public\n    onlyOperator\n    notNullOrThisAddress(newSigner)\n    {\n        if (0 == signerIndicesMap[newSigner]) {\n            \n            signers.push(newSigner);\n            signerIndicesMap[newSigner] = signers.length;\n\n            \n            emit RegisterSignerEvent(newSigner);\n        }\n    }\n\n    \n    \n    \n    \n    function signersByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (address[] memory)\n    {\n        require(0 < signers.length, \"No signers found [SignerManager.sol:101]\");\n        require(low <= up, \"Bounds parameters mismatch [SignerManager.sol:102]\");\n\n        up = up.clampMax(signers.length - 1);\n        address[] memory _signers = new address[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _signers[i - low] = signers[i];\n\n        return _signers;\n    }\n}\n\ncontract SignerManageable is Ownable {\n    \n    \n    \n    SignerManager public signerManager;\n\n    \n    \n    \n    event SetSignerManagerEvent(address oldSignerManager, address newSignerManager);\n\n    \n    \n    \n    constructor(address manager) public notNullAddress(manager) {\n        signerManager = SignerManager(manager);\n    }\n\n    \n    \n    \n    \n    \n    function setSignerManager(address newSignerManager)\n    public\n    onlyDeployer\n    notNullOrThisAddress(newSignerManager)\n    {\n        if (newSignerManager != address(signerManager)) {\n            \n            address oldSignerManager = address(signerManager);\n            signerManager = SignerManager(newSignerManager);\n\n            \n            emit SetSignerManagerEvent(oldSignerManager, newSignerManager);\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n    function ethrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n    public\n    pure\n    returns (address)\n    {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\n        return ecrecover(prefixedHash, v, r, s);\n    }\n\n    \n    \n    \n    \n    \n    \n    function isSignedByRegisteredSigner(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n    public\n    view\n    returns (bool)\n    {\n        return signerManager.isSigner(ethrecover(hash, v, r, s));\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function isSignedBy(bytes32 hash, uint8 v, bytes32 r, bytes32 s, address signer)\n    public\n    pure\n    returns (bool)\n    {\n        return signer == ethrecover(hash, v, r, s);\n    }\n\n    \n    \n    modifier signerManagerInitialized() {\n        require(address(signerManager) != address(0), \"Signer manager not initialized [SignerManageable.sol:105]\");\n        _;\n    }\n}\n\ncontract Validator is Ownable, SignerManageable, Configurable, PaymentHashable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    constructor(address deployer, address signerManager) Ownable(deployer) SignerManageable(signerManager) public {\n    }\n\n    \n    \n    \n    function isGenuineOperatorSignature(bytes32 hash, NahmiiTypesLib.Signature memory signature)\n    public\n    view\n    returns (bool)\n    {\n        return isSignedByRegisteredSigner(hash, signature.v, signature.r, signature.s);\n    }\n\n    function isGenuineWalletSignature(bytes32 hash, NahmiiTypesLib.Signature memory signature, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return isSignedBy(hash, signature.v, signature.r, signature.s, wallet);\n    }\n\n    function isGenuinePaymentWalletHash(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return paymentHasher.hashPaymentAsWallet(payment) == payment.seals.wallet.hash;\n    }\n\n    function isGenuinePaymentOperatorHash(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return paymentHasher.hashPaymentAsOperator(payment) == payment.seals.operator.hash;\n    }\n\n    function isGenuinePaymentWalletSeal(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentWalletHash(payment)\n        && isGenuineWalletSignature(payment.seals.wallet.hash, payment.seals.wallet.signature, payment.sender.wallet);\n    }\n\n    function isGenuinePaymentOperatorSeal(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentOperatorHash(payment)\n        && isGenuineOperatorSignature(payment.seals.operator.hash, payment.seals.operator.signature);\n    }\n\n    function isGenuinePaymentSeals(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentWalletSeal(payment) && isGenuinePaymentOperatorSeal(payment);\n    }\n\n    \n    function isGenuinePaymentFeeOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        int256 feePartsPer = int256(ConstantsLib.PARTS_PER());\n\n        int256 feeAmount = payment.amount\n        .mul(\n            configuration.currencyPaymentFee(\n                payment.blockNumber, payment.currency.ct, payment.currency.id, payment.amount\n            )\n        ).div(feePartsPer);\n\n        if (1 > feeAmount)\n            feeAmount = 1;\n\n        return (payment.sender.fees.single.amount == feeAmount);\n    }\n\n    \n    function isGenuinePaymentFeeOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        (address feeCurrencyCt, uint256 feeCurrencyId) = configuration.feeCurrency(\n            payment.blockNumber, payment.currency.ct, payment.currency.id\n        );\n\n        return feeCurrencyCt == payment.sender.fees.single.currency.ct\n        && feeCurrencyId == payment.sender.fees.single.currency.id;\n    }\n\n    \n    function isGenuinePaymentSenderOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet))\n        && (payment.sender.balances.current == payment.sender.balances.previous.sub(payment.transfers.single).sub(payment.sender.fees.single.amount));\n    }\n\n    \n    function isGenuinePaymentRecipientOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (payment.recipient.balances.current == payment.recipient.balances.previous.add(payment.transfers.single));\n    }\n\n    \n    function isGenuinePaymentSenderOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet));\n    }\n\n    \n    function isGenuinePaymentRecipientOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet);\n    }\n\n    function isSuccessivePaymentsPartyNonces(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment memory lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole\n    )\n    public\n    pure\n    returns (bool)\n    {\n        uint256 firstNonce = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.nonce : firstPayment.recipient.nonce);\n        uint256 lastNonce = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.nonce : lastPayment.recipient.nonce);\n        return lastNonce == firstNonce.add(1);\n    }\n\n    function isGenuineSuccessivePaymentsBalances(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment memory lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole,\n        int256 delta\n    )\n    public\n    pure\n    returns (bool)\n    {\n        NahmiiTypesLib.CurrentPreviousInt256 memory firstCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.balances : firstPayment.recipient.balances);\n        NahmiiTypesLib.CurrentPreviousInt256 memory lastCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.balances : lastPayment.recipient.balances);\n\n        return lastCurrentPreviousBalances.previous == firstCurrentPreviousBalances.current.add(delta);\n    }\n\n    function isGenuineSuccessivePaymentsTotalFees(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.Payment memory lastPayment\n    )\n    public\n    pure\n    returns (bool)\n    {\n        MonetaryTypesLib.Figure memory firstTotalFee = getProtocolFigureByCurrency(firstPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        MonetaryTypesLib.Figure memory lastTotalFee = getProtocolFigureByCurrency(lastPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        return lastTotalFee.amount == firstTotalFee.amount.add(lastPayment.sender.fees.single.amount);\n    }\n\n    function isPaymentParty(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet || wallet == payment.recipient.wallet;\n    }\n\n    function isPaymentSender(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet;\n    }\n\n    function isPaymentRecipient(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.recipient.wallet;\n    }\n\n    function isPaymentCurrency(PaymentTypesLib.Payment memory payment, MonetaryTypesLib.Currency memory currency)\n    public\n    pure\n    returns (bool)\n    {\n        return currency.ct == payment.currency.ct && currency.id == payment.currency.id;\n    }\n\n    function isPaymentCurrencyNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return payment.currency.ct != payment.sender.fees.single.currency.ct\n        || payment.currency.id != payment.sender.fees.single.currency.id;\n    }\n\n    \n    \n    \n    function getProtocolFigureByCurrency(NahmiiTypesLib.OriginFigure[] memory originFigures, MonetaryTypesLib.Currency memory currency)\n    private\n    pure\n    returns (MonetaryTypesLib.Figure memory) {\n        for (uint256 i = 0; i < originFigures.length; i++)\n            if (originFigures[i].figure.currency.ct == currency.ct && originFigures[i].figure.currency.id == currency.id\n            && originFigures[i].originId == 0)\n                return originFigures[i].figure;\n        return MonetaryTypesLib.Figure(0, currency);\n    }\n}\n\nlibrary TradeTypesLib {\n    \n    \n    \n    enum CurrencyRole {Intended, Conjugate}\n    enum LiquidityRole {Maker, Taker}\n    enum Intention {Buy, Sell}\n    enum TradePartyRole {Buyer, Seller}\n\n    \n    \n    \n    struct OrderPlacement {\n        Intention intention;\n\n        int256 amount;\n        NahmiiTypesLib.IntendedConjugateCurrency currencies;\n        int256 rate;\n\n        NahmiiTypesLib.CurrentPreviousInt256 residuals;\n    }\n\n    struct Order {\n        uint256 nonce;\n        address wallet;\n\n        OrderPlacement placement;\n\n        NahmiiTypesLib.WalletOperatorSeal seals;\n        uint256 blockNumber;\n        uint256 operatorId;\n    }\n\n    struct TradeOrder {\n        int256 amount;\n        NahmiiTypesLib.WalletOperatorHashes hashes;\n        NahmiiTypesLib.CurrentPreviousInt256 residuals;\n    }\n\n    struct TradeParty {\n        uint256 nonce;\n        address wallet;\n\n        uint256 rollingVolume;\n\n        LiquidityRole liquidityRole;\n\n        TradeOrder order;\n\n        NahmiiTypesLib.IntendedConjugateCurrentPreviousInt256 balances;\n\n        NahmiiTypesLib.SingleFigureTotalOriginFigures fees;\n    }\n\n    struct Trade {\n        uint256 nonce;\n\n        int256 amount;\n        NahmiiTypesLib.IntendedConjugateCurrency currencies;\n        int256 rate;\n\n        TradeParty buyer;\n        TradeParty seller;\n\n        \n        \n        NahmiiTypesLib.IntendedConjugateSingleTotalInt256 transfers;\n\n        NahmiiTypesLib.Seal seal;\n        uint256 blockNumber;\n        uint256 operatorId;\n    }\n\n    \n    \n    \n    function TRADE_KIND()\n    public\n    pure\n    returns (string memory)\n    {\n        return \"trade\";\n    }\n\n    function ORDER_KIND()\n    public\n    pure\n    returns (string memory)\n    {\n        return \"order\";\n    }\n}\n\ncontract Validatable is Ownable {\n    \n    \n    \n    Validator public validator;\n\n    \n    \n    \n    event SetValidatorEvent(Validator oldValidator, Validator newValidator);\n\n    \n    \n    \n    \n    \n    function setValidator(Validator newValidator)\n    public\n    onlyDeployer\n    notNullAddress(address(newValidator))\n    notSameAddresses(address(newValidator), address(validator))\n    {\n        \n        Validator oldValidator = validator;\n        validator = newValidator;\n\n        \n        emit SetValidatorEvent(oldValidator, newValidator);\n    }\n\n    \n    \n    \n    modifier validatorInitialized() {\n        require(address(validator) != address(0), \"Validator not initialized [Validatable.sol:55]\");\n        _;\n    }\n\n    modifier onlyOperatorSealedPayment(PaymentTypesLib.Payment memory payment) {\n        require(validator.isGenuinePaymentOperatorSeal(payment), \"Payment operator seal not genuine [Validatable.sol:60]\");\n        _;\n    }\n\n    modifier onlySealedPayment(PaymentTypesLib.Payment memory payment) {\n        require(validator.isGenuinePaymentSeals(payment), \"Payment seals not genuine [Validatable.sol:65]\");\n        _;\n    }\n\n    modifier onlyPaymentParty(PaymentTypesLib.Payment memory payment, address wallet) {\n        require(validator.isPaymentParty(payment, wallet), \"Wallet not payment party [Validatable.sol:70]\");\n        _;\n    }\n\n    modifier onlyPaymentSender(PaymentTypesLib.Payment memory payment, address wallet) {\n        require(validator.isPaymentSender(payment, wallet), \"Wallet not payment sender [Validatable.sol:75]\");\n        _;\n    }\n}\n\ncontract Beneficiary {\n    \n    \n    \n    function receiveEthersTo(address wallet, string memory balanceType)\n    public\n    payable;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function receiveTokensTo(address wallet, string memory balanceType, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public;\n}\n\ncontract Benefactor is Ownable {\n    \n    \n    \n    Beneficiary[] public beneficiaries;\n    mapping(address => uint256) public beneficiaryIndexByAddress;\n\n    \n    \n    \n    event RegisterBeneficiaryEvent(Beneficiary beneficiary);\n    event DeregisterBeneficiaryEvent(Beneficiary beneficiary);\n\n    \n    \n    \n    \n    \n    function registerBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        address _beneficiary = address(beneficiary);\n\n        if (beneficiaryIndexByAddress[_beneficiary] > 0)\n            return false;\n\n        beneficiaries.push(beneficiary);\n        beneficiaryIndexByAddress[_beneficiary] = beneficiaries.length;\n\n        \n        emit RegisterBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    \n    \n    function deregisterBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        address _beneficiary = address(beneficiary);\n\n        if (beneficiaryIndexByAddress[_beneficiary] == 0)\n            return false;\n\n        uint256 idx = beneficiaryIndexByAddress[_beneficiary] - 1;\n        if (idx < beneficiaries.length - 1) {\n            \n            beneficiaries[idx] = beneficiaries[beneficiaries.length - 1];\n            beneficiaryIndexByAddress[address(beneficiaries[idx])] = idx + 1;\n        }\n        beneficiaries.length--;\n        beneficiaryIndexByAddress[_beneficiary] = 0;\n\n        \n        emit DeregisterBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    \n    \n    \n    function isRegisteredBeneficiary(Beneficiary beneficiary)\n    public\n    view\n    returns (bool)\n    {\n        return beneficiaryIndexByAddress[address(beneficiary)] > 0;\n    }\n\n    \n    \n    function registeredBeneficiariesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return beneficiaries.length;\n    }\n}\n\ncontract AuthorizableServable is Servable {\n    \n    \n    \n    bool public initialServiceAuthorizationDisabled;\n\n    mapping(address => bool) public initialServiceAuthorizedMap;\n    mapping(address => mapping(address => bool)) public initialServiceWalletUnauthorizedMap;\n\n    mapping(address => mapping(address => bool)) public serviceWalletAuthorizedMap;\n\n    mapping(address => mapping(bytes32 => mapping(address => bool))) public serviceActionWalletAuthorizedMap;\n    mapping(address => mapping(bytes32 => mapping(address => bool))) public serviceActionWalletTouchedMap;\n    mapping(address => mapping(address => bytes32[])) public serviceWalletActionList;\n\n    \n    \n    \n    event AuthorizeInitialServiceEvent(address wallet, address service);\n    event AuthorizeRegisteredServiceEvent(address wallet, address service);\n    event AuthorizeRegisteredServiceActionEvent(address wallet, address service, string action);\n    event UnauthorizeRegisteredServiceEvent(address wallet, address service);\n    event UnauthorizeRegisteredServiceActionEvent(address wallet, address service, string action);\n\n    \n    \n    \n    \n    \n    \n    function authorizeInitialService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(!initialServiceAuthorizationDisabled);\n        require(msg.sender != service);\n\n        \n        require(registeredServicesMap[service].registered);\n\n        \n        initialServiceAuthorizedMap[service] = true;\n\n        \n        emit AuthorizeInitialServiceEvent(msg.sender, service);\n    }\n\n    \n    \n    function disableInitialServiceAuthorization()\n    public\n    onlyDeployer\n    {\n        initialServiceAuthorizationDisabled = true;\n    }\n\n    \n    \n    \n    function authorizeRegisteredService(address service)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        \n        require(registeredServicesMap[service].registered);\n\n        \n        require(!initialServiceAuthorizedMap[service]);\n\n        \n        serviceWalletAuthorizedMap[service][msg.sender] = true;\n\n        \n        emit AuthorizeRegisteredServiceEvent(msg.sender, service);\n    }\n\n    \n    \n    \n    function unauthorizeRegisteredService(address service)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        \n        require(registeredServicesMap[service].registered);\n\n        \n        if (initialServiceAuthorizedMap[service])\n            initialServiceWalletUnauthorizedMap[service][msg.sender] = true;\n\n        \n        else {\n            serviceWalletAuthorizedMap[service][msg.sender] = false;\n            for (uint256 i = 0; i < serviceWalletActionList[service][msg.sender].length; i++)\n                serviceActionWalletAuthorizedMap[service][serviceWalletActionList[service][msg.sender][i]][msg.sender] = true;\n        }\n\n        \n        emit UnauthorizeRegisteredServiceEvent(msg.sender, service);\n    }\n\n    \n    \n    \n    \n    function isAuthorizedRegisteredService(address service, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return isRegisteredActiveService(service) &&\n        (isInitialServiceAuthorizedForWallet(service, wallet) || serviceWalletAuthorizedMap[service][wallet]);\n    }\n\n    \n    \n    \n    \n    function authorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        \n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        \n        require(!initialServiceAuthorizedMap[service]);\n\n        \n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n        \n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }\n\n    \n    \n    \n    \n    function unauthorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        \n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        \n        require(!initialServiceAuthorizedMap[service]);\n\n        \n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n        \n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }\n\n    \n    \n    \n    \n    \n    function isAuthorizedRegisteredServiceAction(address service, string memory action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }\n\n    function isInitialServiceAuthorizedForWallet(address service, address wallet)\n    private\n    view\n    returns (bool)\n    {\n        return initialServiceAuthorizedMap[service] ? !initialServiceWalletUnauthorizedMap[service][wallet] : false;\n    }\n\n    \n    \n    \n    modifier onlyAuthorizedService(address wallet) {\n        require(isAuthorizedRegisteredService(msg.sender, wallet));\n        _;\n    }\n\n    modifier onlyAuthorizedServiceAction(string memory action, address wallet) {\n        require(isAuthorizedRegisteredServiceAction(msg.sender, action, wallet));\n        _;\n    }\n}\n\ncontract TransferController {\n    \n    \n    \n    event CurrencyTransferred(address from, address to, uint256 value,\n        address currencyCt, uint256 currencyId);\n\n    \n    \n    \n    function isFungible()\n    public\n    view\n    returns (bool);\n\n    function standard()\n    public\n    view\n    returns (string memory);\n\n    \n    function receive(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    \n    function approve(address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    \n    function dispatch(address from, address to, uint256 value, address currencyCt, uint256 currencyId)\n    public;\n\n    \n\n    function getReceiveSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"receive(address,address,uint256,address,uint256)\"));\n    }\n\n    function getApproveSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"approve(address,uint256,address,uint256)\"));\n    }\n\n    function getDispatchSignature()\n    public\n    pure\n    returns (bytes4)\n    {\n        return bytes4(keccak256(\"dispatch(address,address,uint256,address,uint256)\"));\n    }\n}\n\ncontract TransferControllerManager is Ownable {\n    \n    \n    \n    struct CurrencyInfo {\n        bytes32 standard;\n        bool blacklisted;\n    }\n\n    \n    \n    \n    mapping(bytes32 => address) public registeredTransferControllers;\n    mapping(address => CurrencyInfo) public registeredCurrencies;\n\n    \n    \n    \n    event RegisterTransferControllerEvent(string standard, address controller);\n    event ReassociateTransferControllerEvent(string oldStandard, string newStandard, address controller);\n\n    event RegisterCurrencyEvent(address currencyCt, string standard);\n    event DeregisterCurrencyEvent(address currencyCt);\n    event BlacklistCurrencyEvent(address currencyCt);\n    event WhitelistCurrencyEvent(address currencyCt);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    function registerTransferController(string calldata standard, address controller)\n    external\n    onlyDeployer\n    notNullAddress(controller)\n    {\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:58]\");\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n        registeredTransferControllers[standardHash] = controller;\n\n        \n        emit RegisterTransferControllerEvent(standard, controller);\n    }\n\n    function reassociateTransferController(string calldata oldStandard, string calldata newStandard, address controller)\n    external\n    onlyDeployer\n    notNullAddress(controller)\n    {\n        require(bytes(newStandard).length > 0, \"Empty new standard not supported [TransferControllerManager.sol:72]\");\n        bytes32 oldStandardHash = keccak256(abi.encodePacked(oldStandard));\n        bytes32 newStandardHash = keccak256(abi.encodePacked(newStandard));\n\n        require(registeredTransferControllers[oldStandardHash] != address(0), \"Old standard not registered [TransferControllerManager.sol:76]\");\n        require(registeredTransferControllers[newStandardHash] == address(0), \"New standard previously registered [TransferControllerManager.sol:77]\");\n\n        registeredTransferControllers[newStandardHash] = registeredTransferControllers[oldStandardHash];\n        registeredTransferControllers[oldStandardHash] = address(0);\n\n        \n        emit ReassociateTransferControllerEvent(oldStandard, newStandard, controller);\n    }\n\n    function registerCurrency(address currencyCt, string calldata standard)\n    external\n    onlyOperator\n    notNullAddress(currencyCt)\n    {\n        require(bytes(standard).length > 0, \"Empty standard not supported [TransferControllerManager.sol:91]\");\n        bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n        require(registeredCurrencies[currencyCt].standard == bytes32(0), \"Currency previously registered [TransferControllerManager.sol:94]\");\n\n        registeredCurrencies[currencyCt].standard = standardHash;\n\n        \n        emit RegisterCurrencyEvent(currencyCt, standard);\n    }\n\n    function deregisterCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != 0, \"Currency not registered [TransferControllerManager.sol:106]\");\n\n        registeredCurrencies[currencyCt].standard = bytes32(0);\n        registeredCurrencies[currencyCt].blacklisted = false;\n\n        \n        emit DeregisterCurrencyEvent(currencyCt);\n    }\n\n    function blacklistCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:119]\");\n\n        registeredCurrencies[currencyCt].blacklisted = true;\n\n        \n        emit BlacklistCurrencyEvent(currencyCt);\n    }\n\n    function whitelistCurrency(address currencyCt)\n    external\n    onlyOperator\n    {\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:131]\");\n\n        registeredCurrencies[currencyCt].blacklisted = false;\n\n        \n        emit WhitelistCurrencyEvent(currencyCt);\n    }\n\n    \n    function transferController(address currencyCt, string memory standard)\n    public\n    view\n    returns (TransferController)\n    {\n        if (bytes(standard).length > 0) {\n            bytes32 standardHash = keccak256(abi.encodePacked(standard));\n\n            require(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\n            return TransferController(registeredTransferControllers[standardHash]);\n        }\n\n        require(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\n        require(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\n        address controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\n        require(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\n        return TransferController(controllerAddress);\n    }\n}\n\ncontract TransferControllerManageable is Ownable {\n    \n    \n    \n    TransferControllerManager public transferControllerManager;\n\n    \n    \n    \n    event SetTransferControllerManagerEvent(TransferControllerManager oldTransferControllerManager,\n        TransferControllerManager newTransferControllerManager);\n\n    \n    \n    \n    \n    \n    function setTransferControllerManager(TransferControllerManager newTransferControllerManager)\n    public\n    onlyDeployer\n    notNullAddress(address(newTransferControllerManager))\n    notSameAddresses(address(newTransferControllerManager), address(transferControllerManager))\n    {\n        \n        TransferControllerManager oldTransferControllerManager = transferControllerManager;\n        transferControllerManager = newTransferControllerManager;\n\n        \n        emit SetTransferControllerManagerEvent(oldTransferControllerManager, newTransferControllerManager);\n    }\n\n    \n    function transferController(address currencyCt, string memory standard)\n    internal\n    view\n    returns (TransferController)\n    {\n        return transferControllerManager.transferController(currencyCt, standard);\n    }\n\n    \n    \n    \n    modifier transferControllerManagerInitialized() {\n        require(address(transferControllerManager) != address(0), \"Transfer controller manager not initialized [TransferControllerManageable.sol:63]\");\n        _;\n    }\n}\n\nlibrary CurrenciesLib {\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    struct Currencies {\n        MonetaryTypesLib.Currency[] currencies;\n        mapping(address => mapping(uint256 => uint256)) indexByCurrency;\n    }\n\n    \n    \n    \n    function add(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        \n        if (0 == self.indexByCurrency[currencyCt][currencyId]) {\n            self.currencies.push(MonetaryTypesLib.Currency(currencyCt, currencyId));\n            self.indexByCurrency[currencyCt][currencyId] = self.currencies.length;\n        }\n    }\n\n    function removeByCurrency(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        \n        uint256 index = self.indexByCurrency[currencyCt][currencyId];\n        if (0 < index)\n            removeByIndex(self, index - 1);\n    }\n\n    function removeByIndex(Currencies storage self, uint256 index)\n    internal\n    {\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:51]\");\n\n        address currencyCt = self.currencies[index].ct;\n        uint256 currencyId = self.currencies[index].id;\n\n        if (index < self.currencies.length - 1) {\n            self.currencies[index] = self.currencies[self.currencies.length - 1];\n            self.indexByCurrency[self.currencies[index].ct][self.currencies[index].id] = index + 1;\n        }\n        self.currencies.length--;\n        self.indexByCurrency[currencyCt][currencyId] = 0;\n    }\n\n    function count(Currencies storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencies.length;\n    }\n\n    function has(Currencies storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return 0 != self.indexByCurrency[currencyCt][currencyId];\n    }\n\n    function getByIndex(Currencies storage self, uint256 index)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency memory)\n    {\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:85]\");\n        return self.currencies[index];\n    }\n\n    function getByIndices(Currencies storage self, uint256 low, uint256 up)\n    internal\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        require(0 < self.currencies.length, \"No currencies found [CurrenciesLib.sol:94]\");\n        require(low <= up, \"Bounds parameters mismatch [CurrenciesLib.sol:95]\");\n\n        up = up.clampMax(self.currencies.length - 1);\n        MonetaryTypesLib.Currency[] memory _currencies = new MonetaryTypesLib.Currency[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _currencies[i - low] = self.currencies[i];\n\n        return _currencies;\n    }\n}\n\nlibrary FungibleBalanceLib {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    \n    \n    \n    struct Record {\n        int256 amount;\n        uint256 blockNumber;\n    }\n\n    struct Balance {\n        mapping(address => mapping(uint256 => int256)) amountByCurrency;\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\n\n        CurrenciesLib.Currencies inUseCurrencies;\n        CurrenciesLib.Currencies everUsedCurrencies;\n    }\n\n    \n    \n    \n    function get(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256)\n    {\n        return self.amountByCurrency[currencyCt][currencyId];\n    }\n\n    function getByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        (int256 amount,) = recordByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return amount;\n    }\n\n    function set(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = amount;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function setByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\n        uint256 blockNumber)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = amount;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function add(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function addByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\n        uint256 blockNumber)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function sub(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function subByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\n        uint256 blockNumber)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function transfer(Balance storage _from, Balance storage _to, int256 amount,\n        address currencyCt, uint256 currencyId)\n    internal\n    {\n        sub(_from, amount, currencyCt, currencyId);\n        add(_to, amount, currencyCt, currencyId);\n    }\n\n    function add_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add_nn(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function sub_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub_nn(amount);\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateCurrencies(self, currencyCt, currencyId);\n    }\n\n    function transfer_nn(Balance storage _from, Balance storage _to, int256 amount,\n        address currencyCt, uint256 currencyId)\n    internal\n    {\n        sub_nn(_from, amount, currencyCt, currencyId);\n        add_nn(_to, amount, currencyCt, currencyId);\n    }\n\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.recordsByCurrency[currencyCt][currencyId].length;\n    }\n\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (0, 0);\n    }\n\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (0, 0);\n\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\n        return (record.amount, record.blockNumber);\n    }\n\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (0, 0);\n\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\n        return (record.amount, record.blockNumber);\n    }\n\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.inUseCurrencies.has(currencyCt, currencyId);\n    }\n\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\n    }\n\n    function updateCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        if (0 == self.amountByCurrency[currencyCt][currencyId] && self.inUseCurrencies.has(currencyCt, currencyId))\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\n            self.inUseCurrencies.add(currencyCt, currencyId);\n            self.everUsedCurrencies.add(currencyCt, currencyId);\n        }\n    }\n\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return 0;\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\n                return i;\n        return 0;\n    }\n}\n\nlibrary NonFungibleBalanceLib {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    \n    \n    \n    struct Record {\n        int256[] ids;\n        uint256 blockNumber;\n    }\n\n    struct Balance {\n        mapping(address => mapping(uint256 => int256[])) idsByCurrency;\n        mapping(address => mapping(uint256 => mapping(int256 => uint256))) idIndexById;\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\n\n        CurrenciesLib.Currencies inUseCurrencies;\n        CurrenciesLib.Currencies everUsedCurrencies;\n    }\n\n    \n    \n    \n    function get(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256[] memory)\n    {\n        return self.idsByCurrency[currencyCt][currencyId];\n    }\n\n    function getByIndices(Balance storage self, address currencyCt, uint256 currencyId, uint256 indexLow, uint256 indexUp)\n    internal\n    view\n    returns (int256[] memory)\n    {\n        if (0 == self.idsByCurrency[currencyCt][currencyId].length)\n            return new int256[](0);\n\n        indexUp = indexUp.clampMax(self.idsByCurrency[currencyCt][currencyId].length - 1);\n\n        int256[] memory idsByCurrency = new int256[](indexUp - indexLow + 1);\n        for (uint256 i = indexLow; i < indexUp; i++)\n            idsByCurrency[i - indexLow] = self.idsByCurrency[currencyCt][currencyId][i];\n\n        return idsByCurrency;\n    }\n\n    function idsCount(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.idsByCurrency[currencyCt][currencyId].length;\n    }\n\n    function hasId(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return 0 < self.idIndexById[currencyCt][currencyId][id];\n    }\n\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (int256[] memory, uint256)\n    {\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (new int256[](0), 0);\n    }\n\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\n    internal\n    view\n    returns (int256[] memory, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (new int256[](0), 0);\n\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\n        return (record.ids, record.blockNumber);\n    }\n\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (int256[] memory, uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return (new int256[](0), 0);\n\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\n        return (record.ids, record.blockNumber);\n    }\n\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.recordsByCurrency[currencyCt][currencyId].length;\n    }\n\n    function set(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\n    internal\n    {\n        int256[] memory ids = new int256[](1);\n        ids[0] = id;\n        set(self, ids, currencyCt, currencyId);\n    }\n\n    function set(Balance storage self, int256[] memory ids, address currencyCt, uint256 currencyId)\n    internal\n    {\n        uint256 i;\n        for (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\n\n        self.idsByCurrency[currencyCt][currencyId] = ids;\n\n        for (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = i + 1;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateInUseCurrencies(self, currencyCt, currencyId);\n    }\n\n    function reset(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        for (uint256 i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\n\n        self.idsByCurrency[currencyCt][currencyId].length = 0;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateInUseCurrencies(self, currencyCt, currencyId);\n    }\n\n    function add(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\n    internal\n    returns (bool)\n    {\n        if (0 < self.idIndexById[currencyCt][currencyId][id])\n            return false;\n\n        self.idsByCurrency[currencyCt][currencyId].push(id);\n\n        self.idIndexById[currencyCt][currencyId][id] = self.idsByCurrency[currencyCt][currencyId].length;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateInUseCurrencies(self, currencyCt, currencyId);\n\n        return true;\n    }\n\n    function sub(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\n    internal\n    returns (bool)\n    {\n        uint256 index = self.idIndexById[currencyCt][currencyId][id];\n\n        if (0 == index)\n            return false;\n\n        if (index < self.idsByCurrency[currencyCt][currencyId].length) {\n            self.idsByCurrency[currencyCt][currencyId][index - 1] = self.idsByCurrency[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId].length - 1];\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][index - 1]] = index;\n        }\n        self.idsByCurrency[currencyCt][currencyId].length--;\n        self.idIndexById[currencyCt][currencyId][id] = 0;\n\n        self.recordsByCurrency[currencyCt][currencyId].push(\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\n        );\n\n        updateInUseCurrencies(self, currencyCt, currencyId);\n\n        return true;\n    }\n\n    function transfer(Balance storage _from, Balance storage _to, int256 id,\n        address currencyCt, uint256 currencyId)\n    internal\n    returns (bool)\n    {\n        return sub(_from, id, currencyCt, currencyId) && add(_to, id, currencyCt, currencyId);\n    }\n\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.inUseCurrencies.has(currencyCt, currencyId);\n    }\n\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (bool)\n    {\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\n    }\n\n    function updateInUseCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\n    internal\n    {\n        if (0 == self.idsByCurrency[currencyCt][currencyId].length && self.inUseCurrencies.has(currencyCt, currencyId))\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\n            self.inUseCurrencies.add(currencyCt, currencyId);\n            self.everUsedCurrencies.add(currencyCt, currencyId);\n        }\n    }\n\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\n    internal\n    view\n    returns (uint256)\n    {\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\n            return 0;\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\n                return i;\n        return 0;\n    }\n}\n\ncontract BalanceTracker is Ownable, Servable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using NonFungibleBalanceLib for NonFungibleBalanceLib.Balance;\n\n    \n    \n    \n    string constant public DEPOSITED_BALANCE_TYPE = \"deposited\";\n    string constant public SETTLED_BALANCE_TYPE = \"settled\";\n    string constant public STAGED_BALANCE_TYPE = \"staged\";\n\n    \n    \n    \n    struct Wallet {\n        mapping(bytes32 => FungibleBalanceLib.Balance) fungibleBalanceByType;\n        mapping(bytes32 => NonFungibleBalanceLib.Balance) nonFungibleBalanceByType;\n    }\n\n    \n    \n    \n    bytes32 public depositedBalanceType;\n    bytes32 public settledBalanceType;\n    bytes32 public stagedBalanceType;\n\n    bytes32[] public _allBalanceTypes;\n    bytes32[] public _activeBalanceTypes;\n\n    bytes32[] public trackedBalanceTypes;\n    mapping(bytes32 => bool) public trackedBalanceTypeMap;\n\n    mapping(address => Wallet) private walletMap;\n\n    address[] public trackedWallets;\n    mapping(address => uint256) public trackedWalletIndexByWallet;\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer)\n    public\n    {\n        depositedBalanceType = keccak256(abi.encodePacked(DEPOSITED_BALANCE_TYPE));\n        settledBalanceType = keccak256(abi.encodePacked(SETTLED_BALANCE_TYPE));\n        stagedBalanceType = keccak256(abi.encodePacked(STAGED_BALANCE_TYPE));\n\n        _allBalanceTypes.push(settledBalanceType);\n        _allBalanceTypes.push(depositedBalanceType);\n        _allBalanceTypes.push(stagedBalanceType);\n\n        _activeBalanceTypes.push(settledBalanceType);\n        _activeBalanceTypes.push(depositedBalanceType);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function get(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].get(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function getByIndices(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 indexLow, uint256 indexUp)\n    public\n    view\n    returns (int256[] memory)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].getByIndices(\n            currencyCt, currencyId, indexLow, indexUp\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    function getAll(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256[] memory)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].get(\n            currencyCt, currencyId\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    function idsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].idsCount(\n            currencyCt, currencyId\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function hasId(address wallet, bytes32 _type, int256 id, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].hasId(\n            id, currencyCt, currencyId\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function set(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId, bool fungible)\n    public\n    onlyActiveService\n    {\n        \n        if (fungible)\n            walletMap[wallet].fungibleBalanceByType[_type].set(\n                value, currencyCt, currencyId\n            );\n\n        else\n            walletMap[wallet].nonFungibleBalanceByType[_type].set(\n                value, currencyCt, currencyId\n            );\n\n        \n        _updateTrackedBalanceTypes(_type);\n\n        \n        _updateTrackedWallets(wallet);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setIds(address wallet, bytes32 _type, int256[] memory ids, address currencyCt, uint256 currencyId)\n    public\n    onlyActiveService\n    {\n        \n        walletMap[wallet].nonFungibleBalanceByType[_type].set(\n            ids, currencyCt, currencyId\n        );\n\n        \n        _updateTrackedBalanceTypes(_type);\n\n        \n        _updateTrackedWallets(wallet);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function add(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId,\n        bool fungible)\n    public\n    onlyActiveService\n    {\n        \n        if (fungible)\n            walletMap[wallet].fungibleBalanceByType[_type].add(\n                value, currencyCt, currencyId\n            );\n        else\n            walletMap[wallet].nonFungibleBalanceByType[_type].add(\n                value, currencyCt, currencyId\n            );\n\n        \n        _updateTrackedBalanceTypes(_type);\n\n        \n        _updateTrackedWallets(wallet);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function sub(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId,\n        bool fungible)\n    public\n    onlyActiveService\n    {\n        \n        if (fungible)\n            walletMap[wallet].fungibleBalanceByType[_type].sub(\n                value, currencyCt, currencyId\n            );\n        else\n            walletMap[wallet].nonFungibleBalanceByType[_type].sub(\n                value, currencyCt, currencyId\n            );\n\n        \n        _updateTrackedWallets(wallet);\n    }\n\n    \n    \n    \n    \n    \n    \n    function hasInUseCurrency(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].hasInUseCurrency(currencyCt, currencyId)\n        || walletMap[wallet].nonFungibleBalanceByType[_type].hasInUseCurrency(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    function hasEverUsedCurrency(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].hasEverUsedCurrency(currencyCt, currencyId)\n        || walletMap[wallet].nonFungibleBalanceByType[_type].hasEverUsedCurrency(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    function fungibleRecordsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].recordsCount(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function fungibleRecordByIndex(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 index)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].recordByIndex(currencyCt, currencyId, index);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function fungibleRecordByBlockNumber(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 _blockNumber)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].recordByBlockNumber(currencyCt, currencyId, _blockNumber);\n    }\n\n    \n    \n    \n    \n    \n    \n    function lastFungibleRecord(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        return walletMap[wallet].fungibleBalanceByType[_type].lastRecord(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    function nonFungibleRecordsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordsCount(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function nonFungibleRecordByIndex(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 index)\n    public\n    view\n    returns (int256[] memory ids, uint256 blockNumber)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordByIndex(currencyCt, currencyId, index);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function nonFungibleRecordByBlockNumber(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\n        uint256 _blockNumber)\n    public\n    view\n    returns (int256[] memory ids, uint256 blockNumber)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordByBlockNumber(currencyCt, currencyId, _blockNumber);\n    }\n\n    \n    \n    \n    \n    \n    \n    function lastNonFungibleRecord(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256[] memory ids, uint256 blockNumber)\n    {\n        return walletMap[wallet].nonFungibleBalanceByType[_type].lastRecord(currencyCt, currencyId);\n    }\n\n    \n    \n    function trackedBalanceTypesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return trackedBalanceTypes.length;\n    }\n\n    \n    \n    function trackedWalletsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return trackedWallets.length;\n    }\n\n    \n    \n    function allBalanceTypes()\n    public\n    view\n    returns (bytes32[] memory)\n    {\n        return _allBalanceTypes;\n    }\n\n    \n    \n    function activeBalanceTypes()\n    public\n    view\n    returns (bytes32[] memory)\n    {\n        return _activeBalanceTypes;\n    }\n\n    \n    \n    \n    \n    function trackedWalletsByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (address[] memory)\n    {\n        require(0 < trackedWallets.length, \"No tracked wallets found [BalanceTracker.sol:473]\");\n        require(low <= up, \"Bounds parameters mismatch [BalanceTracker.sol:474]\");\n\n        up = up.clampMax(trackedWallets.length - 1);\n        address[] memory _trackedWallets = new address[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _trackedWallets[i - low] = trackedWallets[i];\n\n        return _trackedWallets;\n    }\n\n    \n    \n    \n    function _updateTrackedBalanceTypes(bytes32 _type)\n    private\n    {\n        if (!trackedBalanceTypeMap[_type]) {\n            trackedBalanceTypeMap[_type] = true;\n            trackedBalanceTypes.push(_type);\n        }\n    }\n\n    function _updateTrackedWallets(address wallet)\n    private\n    {\n        if (0 == trackedWalletIndexByWallet[wallet]) {\n            trackedWallets.push(wallet);\n            trackedWalletIndexByWallet[wallet] = trackedWallets.length;\n        }\n    }\n}\n\ncontract BalanceTrackable is Ownable {\n    \n    \n    \n    BalanceTracker public balanceTracker;\n    bool public balanceTrackerFrozen;\n\n    \n    \n    \n    event SetBalanceTrackerEvent(BalanceTracker oldBalanceTracker, BalanceTracker newBalanceTracker);\n    event FreezeBalanceTrackerEvent();\n\n    \n    \n    \n    \n    \n    function setBalanceTracker(BalanceTracker newBalanceTracker)\n    public\n    onlyDeployer\n    notNullAddress(address(newBalanceTracker))\n    notSameAddresses(address(newBalanceTracker), address(balanceTracker))\n    {\n        \n        require(!balanceTrackerFrozen, \"Balance tracker frozen [BalanceTrackable.sol:43]\");\n\n        \n        BalanceTracker oldBalanceTracker = balanceTracker;\n        balanceTracker = newBalanceTracker;\n\n        \n        emit SetBalanceTrackerEvent(oldBalanceTracker, newBalanceTracker);\n    }\n\n    \n    \n    function freezeBalanceTracker()\n    public\n    onlyDeployer\n    {\n        balanceTrackerFrozen = true;\n\n        \n        emit FreezeBalanceTrackerEvent();\n    }\n\n    \n    \n    \n    modifier balanceTrackerInitialized() {\n        require(address(balanceTracker) != address(0), \"Balance tracker not initialized [BalanceTrackable.sol:69]\");\n        _;\n    }\n}\n\ncontract TransactionTracker is Ownable, Servable {\n\n    \n    \n    \n    struct TransactionRecord {\n        int256 value;\n        uint256 blockNumber;\n        address currencyCt;\n        uint256 currencyId;\n    }\n\n    struct TransactionLog {\n        TransactionRecord[] records;\n        mapping(address => mapping(uint256 => uint256[])) recordIndicesByCurrency;\n    }\n\n    \n    \n    \n    string constant public DEPOSIT_TRANSACTION_TYPE = \"deposit\";\n    string constant public WITHDRAWAL_TRANSACTION_TYPE = \"withdrawal\";\n\n    \n    \n    \n    bytes32 public depositTransactionType;\n    bytes32 public withdrawalTransactionType;\n\n    mapping(address => mapping(bytes32 => TransactionLog)) private transactionLogByWalletType;\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer)\n    public\n    {\n        depositTransactionType = keccak256(abi.encodePacked(DEPOSIT_TRANSACTION_TYPE));\n        withdrawalTransactionType = keccak256(abi.encodePacked(WITHDRAWAL_TRANSACTION_TYPE));\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function add(address wallet, bytes32 _type, int256 value, address currencyCt,\n        uint256 currencyId)\n    public\n    onlyActiveService\n    {\n        transactionLogByWalletType[wallet][_type].records.length++;\n\n        uint256 index = transactionLogByWalletType[wallet][_type].records.length - 1;\n\n        transactionLogByWalletType[wallet][_type].records[index].value = value;\n        transactionLogByWalletType[wallet][_type].records[index].blockNumber = block.number;\n        transactionLogByWalletType[wallet][_type].records[index].currencyCt = currencyCt;\n        transactionLogByWalletType[wallet][_type].records[index].currencyId = currencyId;\n\n        transactionLogByWalletType[wallet][_type].recordIndicesByCurrency[currencyCt][currencyId].push(index);\n    }\n\n    \n    \n    \n    \n    function count(address wallet, bytes32 _type)\n    public\n    view\n    returns (uint256)\n    {\n        return transactionLogByWalletType[wallet][_type].records.length;\n    }\n\n    \n    \n    \n    \n    \n    function getByIndex(address wallet, bytes32 _type, uint256 index)\n    public\n    view\n    returns (int256 value, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        TransactionRecord storage entry = transactionLogByWalletType[wallet][_type].records[index];\n        value = entry.value;\n        blockNumber = entry.blockNumber;\n        currencyCt = entry.currencyCt;\n        currencyId = entry.currencyId;\n    }\n\n    \n    \n    \n    \n    \n    function getByBlockNumber(address wallet, bytes32 _type, uint256 _blockNumber)\n    public\n    view\n    returns (int256 value, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        return getByIndex(wallet, _type, _indexByBlockNumber(wallet, _type, _blockNumber));\n    }\n\n    \n    \n    \n    \n    \n    \n    function countByCurrency(address wallet, bytes32 _type, address currencyCt,\n        uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return transactionLogByWalletType[wallet][_type].recordIndicesByCurrency[currencyCt][currencyId].length;\n    }\n\n    \n    \n    \n    \n    \n    function getByCurrencyIndex(address wallet, bytes32 _type, address currencyCt,\n        uint256 currencyId, uint256 index)\n    public\n    view\n    returns (int256 value, uint256 blockNumber)\n    {\n        uint256 entryIndex = transactionLogByWalletType[wallet][_type].recordIndicesByCurrency[currencyCt][currencyId][index];\n\n        TransactionRecord storage entry = transactionLogByWalletType[wallet][_type].records[entryIndex];\n        value = entry.value;\n        blockNumber = entry.blockNumber;\n    }\n\n    \n    \n    \n    \n    \n    function getByCurrencyBlockNumber(address wallet, bytes32 _type, address currencyCt,\n        uint256 currencyId, uint256 _blockNumber)\n    public\n    view\n    returns (int256 value, uint256 blockNumber)\n    {\n        return getByCurrencyIndex(\n            wallet, _type, currencyCt, currencyId,\n            _indexByCurrencyBlockNumber(\n                wallet, _type, currencyCt, currencyId, _blockNumber\n            )\n        );\n    }\n\n    \n    \n    \n    function _indexByBlockNumber(address wallet, bytes32 _type, uint256 blockNumber)\n    private\n    view\n    returns (uint256)\n    {\n        require(\n            0 < transactionLogByWalletType[wallet][_type].records.length,\n            \"No transactions found for wallet and type [TransactionTracker.sol:187]\"\n        );\n        for (uint256 i = transactionLogByWalletType[wallet][_type].records.length - 1; i >= 0; i--)\n            if (blockNumber >= transactionLogByWalletType[wallet][_type].records[i].blockNumber)\n                return i;\n        revert();\n    }\n\n    function _indexByCurrencyBlockNumber(address wallet, bytes32 _type, address currencyCt,\n        uint256 currencyId, uint256 blockNumber)\n    private\n    view\n    returns (uint256)\n    {\n        require(\n            0 < transactionLogByWalletType[wallet][_type].recordIndicesByCurrency[currencyCt][currencyId].length,\n            \"No transactions found for wallet, type and currency [TransactionTracker.sol:203]\"\n        );\n        for (uint256 i = transactionLogByWalletType[wallet][_type].recordIndicesByCurrency[currencyCt][currencyId].length - 1; i >= 0; i--) {\n            uint256 j = transactionLogByWalletType[wallet][_type].recordIndicesByCurrency[currencyCt][currencyId][i];\n            if (blockNumber >= transactionLogByWalletType[wallet][_type].records[j].blockNumber)\n                return j;\n        }\n        revert();\n    }\n}\n\ncontract TransactionTrackable is Ownable {\n    \n    \n    \n    TransactionTracker public transactionTracker;\n    bool public transactionTrackerFrozen;\n\n    \n    \n    \n    event SetTransactionTrackerEvent(TransactionTracker oldTransactionTracker, TransactionTracker newTransactionTracker);\n    event FreezeTransactionTrackerEvent();\n\n    \n    \n    \n    \n    \n    function setTransactionTracker(TransactionTracker newTransactionTracker)\n    public\n    onlyDeployer\n    notNullAddress(address(newTransactionTracker))\n    notSameAddresses(address(newTransactionTracker), address(transactionTracker))\n    {\n        \n        require(!transactionTrackerFrozen, \"Transaction tracker frozen [TransactionTrackable.sol:43]\");\n\n        \n        TransactionTracker oldTransactionTracker = transactionTracker;\n        transactionTracker = newTransactionTracker;\n\n        \n        emit SetTransactionTrackerEvent(oldTransactionTracker, newTransactionTracker);\n    }\n\n    \n    \n    function freezeTransactionTracker()\n    public\n    onlyDeployer\n    {\n        transactionTrackerFrozen = true;\n\n        \n        emit FreezeTransactionTrackerEvent();\n    }\n\n    \n    \n    \n    modifier transactionTrackerInitialized() {\n        require(address(transactionTracker) != address(0), \"Transaction track not initialized [TransactionTrackable.sol:69]\");\n        _;\n    }\n}\n\ncontract WalletLocker is Ownable, Configurable, AuthorizableServable {\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    struct FungibleLock {\n        address locker;\n        address currencyCt;\n        uint256 currencyId;\n        int256 amount;\n        uint256 visibleTime;\n        uint256 unlockTime;\n    }\n\n    struct NonFungibleLock {\n        address locker;\n        address currencyCt;\n        uint256 currencyId;\n        int256[] ids;\n        uint256 visibleTime;\n        uint256 unlockTime;\n    }\n\n    \n    \n    \n    mapping(address => FungibleLock[]) public walletFungibleLocks;\n    mapping(address => mapping(address => mapping(uint256 => mapping(address => uint256)))) public lockedCurrencyLockerFungibleLockIndex;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public walletCurrencyFungibleLockCount;\n\n    mapping(address => NonFungibleLock[]) public walletNonFungibleLocks;\n    mapping(address => mapping(address => mapping(uint256 => mapping(address => uint256)))) public lockedCurrencyLockerNonFungibleLockIndex;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public walletCurrencyNonFungibleLockCount;\n\n    \n    \n    \n    event LockFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256 amount,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds);\n    event LockNonFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256[] ids,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds);\n    event UnlockFungibleEvent(address lockedWallet, address lockerWallet, int256 amount, address currencyCt,\n        uint256 currencyId);\n    event UnlockFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256 amount, address currencyCt,\n        uint256 currencyId);\n    event UnlockNonFungibleEvent(address lockedWallet, address lockerWallet, int256[] ids, address currencyCt,\n        uint256 currencyId);\n    event UnlockNonFungibleByProxyEvent(address lockedWallet, address lockerWallet, int256[] ids, address currencyCt,\n        uint256 currencyId);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer)\n    public\n    {\n    }\n\n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n    \n    function lockFungibleByProxy(address lockedWallet, address lockerWallet, int256 amount,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n        \n        require(lockedWallet != lockerWallet);\n\n        \n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n        \n        require(\n            (0 == lockIndex) ||\n            (block.timestamp >= walletFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n        );\n\n        \n        if (0 == lockIndex) {\n            lockIndex = ++(walletFungibleLocks[lockedWallet].length);\n            lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\n            walletCurrencyFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n        }\n\n        \n        walletFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\n        walletFungibleLocks[lockedWallet][lockIndex - 1].amount = amount;\n        walletFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\n        walletFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\n        walletFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\n        block.timestamp.add(visibleTimeoutInSeconds);\n        walletFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\n        block.timestamp.add(configuration.walletLockTimeout());\n\n        \n        emit LockFungibleByProxyEvent(lockedWallet, lockerWallet, amount, currencyCt, currencyId, visibleTimeoutInSeconds);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function lockNonFungibleByProxy(address lockedWallet, address lockerWallet, int256[] memory ids,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n        \n        require(lockedWallet != lockerWallet);\n\n        \n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n        \n        require(\n            (0 == lockIndex) ||\n            (block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n        );\n\n        \n        if (0 == lockIndex) {\n            lockIndex = ++(walletNonFungibleLocks[lockedWallet].length);\n            lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\n            walletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n        }\n\n        \n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids = ids;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\n        block.timestamp.add(visibleTimeoutInSeconds);\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\n        block.timestamp.add(configuration.walletLockTimeout());\n\n        \n        emit LockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId, visibleTimeoutInSeconds);\n    }\n\n    \n    \n    \n    \n    \n    \n    function unlockFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    {\n        \n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        \n        if (0 == lockIndex)\n            return;\n\n        \n        require(\n            block.timestamp >= walletFungibleLocks[lockedWallet][lockIndex - 1].unlockTime\n        );\n\n        \n        int256 amount = _unlockFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\n\n        \n        emit UnlockFungibleEvent(lockedWallet, lockerWallet, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    function unlockFungibleByProxy(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n        \n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        \n        if (0 == lockIndex)\n            return;\n\n        \n        int256 amount = _unlockFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\n\n        \n        emit UnlockFungibleByProxyEvent(lockedWallet, lockerWallet, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    function unlockNonFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    {\n        \n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        \n        if (0 == lockIndex)\n            return;\n\n        \n        require(\n            block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime\n        );\n\n        \n        int256[] memory ids = _unlockNonFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\n\n        \n        emit UnlockNonFungibleEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    function unlockNonFungibleByProxy(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n        \n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        \n        if (0 == lockIndex)\n            return;\n\n        \n        int256[] memory ids = _unlockNonFungible(lockedWallet, lockerWallet, currencyCt, currencyId, lockIndex);\n\n        \n        emit UnlockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    function fungibleLocksCount(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        return walletFungibleLocks[wallet].length;\n    }\n\n    \n    \n    \n    function nonFungibleLocksCount(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        return walletNonFungibleLocks[wallet].length;\n    }\n\n    \n    \n    \n    \n    \n    \n    function lockedAmount(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        uint256 lockIndex = lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        if (0 == lockIndex || block.timestamp < walletFungibleLocks[lockedWallet][lockIndex - 1].visibleTime)\n            return 0;\n\n        return walletFungibleLocks[lockedWallet][lockIndex - 1].amount;\n    }\n\n    \n    \n    \n    \n    \n    \n    function lockedIdsCount(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        if (0 == lockIndex || block.timestamp < walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime)\n            return 0;\n\n        return walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids.length;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function lockedIdsByIndices(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId,\n        uint256 low, uint256 up)\n    public\n    view\n    returns (int256[] memory)\n    {\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n\n        if (0 == lockIndex || block.timestamp < walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime)\n            return new int256[](0);\n\n        NonFungibleLock storage lock = walletNonFungibleLocks[lockedWallet][lockIndex - 1];\n\n        if (0 == lock.ids.length)\n            return new int256[](0);\n\n        up = up.clampMax(lock.ids.length - 1);\n        int256[] memory _ids = new int256[](up - low + 1);\n        for (uint256 i = low; i <= up; i++)\n            _ids[i - low] = lock.ids[i];\n\n        return _ids;\n    }\n\n    \n    \n    \n    function isLocked(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return 0 < walletFungibleLocks[wallet].length ||\n        0 < walletNonFungibleLocks[wallet].length;\n    }\n\n    \n    \n    \n    \n    \n    function isLocked(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return 0 < walletCurrencyFungibleLockCount[wallet][currencyCt][currencyId] ||\n        0 < walletCurrencyNonFungibleLockCount[wallet][currencyCt][currencyId];\n    }\n\n    \n    \n    \n    \n    function isLocked(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (bool)\n    {\n        return 0 < lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] ||\n        0 < lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet];\n    }\n\n    \n    \n    \n    \n    function _unlockFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId, uint256 lockIndex)\n    private\n    returns (int256)\n    {\n        int256 amount = walletFungibleLocks[lockedWallet][lockIndex - 1].amount;\n\n        if (lockIndex < walletFungibleLocks[lockedWallet].length) {\n            walletFungibleLocks[lockedWallet][lockIndex - 1] =\n            walletFungibleLocks[lockedWallet][walletFungibleLocks[lockedWallet].length - 1];\n\n            lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][walletFungibleLocks[lockedWallet][lockIndex - 1].locker] = lockIndex;\n        }\n        walletFungibleLocks[lockedWallet].length--;\n\n        lockedCurrencyLockerFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = 0;\n\n        walletCurrencyFungibleLockCount[lockedWallet][currencyCt][currencyId]--;\n\n        return amount;\n    }\n\n    function _unlockNonFungible(address lockedWallet, address lockerWallet, address currencyCt, uint256 currencyId, uint256 lockIndex)\n    private\n    returns (int256[] memory)\n    {\n        int256[] memory ids = walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids;\n\n        if (lockIndex < walletNonFungibleLocks[lockedWallet].length) {\n            walletNonFungibleLocks[lockedWallet][lockIndex - 1] =\n            walletNonFungibleLocks[lockedWallet][walletNonFungibleLocks[lockedWallet].length - 1];\n\n            lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][walletNonFungibleLocks[lockedWallet][lockIndex - 1].locker] = lockIndex;\n        }\n        walletNonFungibleLocks[lockedWallet].length--;\n\n        lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = 0;\n\n        walletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]--;\n\n        return ids;\n    }\n}\n\ncontract WalletLockable is Ownable {\n    \n    \n    \n    WalletLocker public walletLocker;\n    bool public walletLockerFrozen;\n\n    \n    \n    \n    event SetWalletLockerEvent(WalletLocker oldWalletLocker, WalletLocker newWalletLocker);\n    event FreezeWalletLockerEvent();\n\n    \n    \n    \n    \n    \n    function setWalletLocker(WalletLocker newWalletLocker)\n    public\n    onlyDeployer\n    notNullAddress(address(newWalletLocker))\n    notSameAddresses(address(newWalletLocker), address(walletLocker))\n    {\n        \n        require(!walletLockerFrozen, \"Wallet locker frozen [WalletLockable.sol:43]\");\n\n        \n        WalletLocker oldWalletLocker = walletLocker;\n        walletLocker = newWalletLocker;\n\n        \n        emit SetWalletLockerEvent(oldWalletLocker, newWalletLocker);\n    }\n\n    \n    \n    function freezeWalletLocker()\n    public\n    onlyDeployer\n    {\n        walletLockerFrozen = true;\n\n        \n        emit FreezeWalletLockerEvent();\n    }\n\n    \n    \n    \n    modifier walletLockerInitialized() {\n        require(address(walletLocker) != address(0), \"Wallet locker not initialized [WalletLockable.sol:69]\");\n        _;\n    }\n}\n\ncontract AccrualBeneficiary is Beneficiary {\n    \n    \n    \n    event CloseAccrualPeriodEvent();\n\n    \n    \n    \n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }\n}\n\nlibrary TxHistoryLib {\n    \n    \n    \n    struct AssetEntry {\n        int256 amount;\n        uint256 blockNumber;\n        address currencyCt;      \n        uint256 currencyId;\n    }\n\n    struct TxHistory {\n        AssetEntry[] deposits;\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyDeposits;\n\n        AssetEntry[] withdrawals;\n        mapping(address => mapping(uint256 => AssetEntry[])) currencyWithdrawals;\n    }\n\n    \n    \n    \n    function addDeposit(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        AssetEntry memory deposit = AssetEntry(amount, block.number, currencyCt, currencyId);\n        self.deposits.push(deposit);\n        self.currencyDeposits[currencyCt][currencyId].push(deposit);\n    }\n\n    function addWithdrawal(TxHistory storage self, int256 amount, address currencyCt, uint256 currencyId)\n    internal\n    {\n        AssetEntry memory withdrawal = AssetEntry(amount, block.number, currencyCt, currencyId);\n        self.withdrawals.push(withdrawal);\n        self.currencyWithdrawals[currencyCt][currencyId].push(withdrawal);\n    }\n\n    \n\n    function deposit(TxHistory storage self, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(index < self.deposits.length, \"Index ouf of bounds [TxHistoryLib.sol:56]\");\n\n        amount = self.deposits[index].amount;\n        blockNumber = self.deposits[index].blockNumber;\n        currencyCt = self.deposits[index].currencyCt;\n        currencyId = self.deposits[index].currencyId;\n    }\n\n    function depositsCount(TxHistory storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.deposits.length;\n    }\n\n    function currencyDeposit(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        require(index < self.currencyDeposits[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:77]\");\n\n        amount = self.currencyDeposits[currencyCt][currencyId][index].amount;\n        blockNumber = self.currencyDeposits[currencyCt][currencyId][index].blockNumber;\n    }\n\n    function currencyDepositsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencyDeposits[currencyCt][currencyId].length;\n    }\n\n    \n\n    function withdrawal(TxHistory storage self, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(index < self.withdrawals.length, \"Index out of bounds [TxHistoryLib.sol:98]\");\n\n        amount = self.withdrawals[index].amount;\n        blockNumber = self.withdrawals[index].blockNumber;\n        currencyCt = self.withdrawals[index].currencyCt;\n        currencyId = self.withdrawals[index].currencyId;\n    }\n\n    function withdrawalsCount(TxHistory storage self)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.withdrawals.length;\n    }\n\n    function currencyWithdrawal(TxHistory storage self, address currencyCt, uint256 currencyId, uint index)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        require(index < self.currencyWithdrawals[currencyCt][currencyId].length, \"Index out of bounds [TxHistoryLib.sol:119]\");\n\n        amount = self.currencyWithdrawals[currencyCt][currencyId][index].amount;\n        blockNumber = self.currencyWithdrawals[currencyCt][currencyId][index].blockNumber;\n    }\n\n    function currencyWithdrawalsCount(TxHistory storage self, address currencyCt, uint256 currencyId)\n    internal\n    view\n    returns (uint256)\n    {\n        return self.currencyWithdrawals[currencyCt][currencyId].length;\n    }\n}\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    \n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    \n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    \n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    \n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    \n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    \n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    \n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     \n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    \n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    \n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    \n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    \n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    \n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\ncontract ERC20Mintable is ERC20, MinterRole {\n    \n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n\ncontract RevenueToken is ERC20Mintable {\n    using SafeMath for uint256;\n\n    bool public mintingDisabled;\n\n    address[] public holders;\n\n    mapping(address => bool) public holdersMap;\n\n    mapping(address => uint256[]) public balances;\n\n    mapping(address => uint256[]) public balanceBlocks;\n\n    mapping(address => uint256[]) public balanceBlockNumbers;\n\n    event DisableMinting();\n\n    \n    function disableMinting()\n    public\n    onlyMinter\n    {\n        mintingDisabled = true;\n\n        emit DisableMinting();\n    }\n\n    \n    function mint(address to, uint256 value)\n    public\n    onlyMinter\n    returns (bool)\n    {\n        require(!mintingDisabled, \"Minting disabled [RevenueToken.sol:60]\");\n\n        \n        bool minted = super.mint(to, value);\n\n        if (minted) {\n            \n            addBalanceBlocks(to);\n\n            \n            if (!holdersMap[to]) {\n                holdersMap[to] = true;\n                holders.push(to);\n            }\n        }\n\n        return minted;\n    }\n\n    \n    function transfer(address to, uint256 value)\n    public\n    returns (bool)\n    {\n        \n        bool transferred = super.transfer(to, value);\n\n        if (transferred) {\n            \n            addBalanceBlocks(msg.sender);\n            addBalanceBlocks(to);\n\n            \n            if (!holdersMap[to]) {\n                holdersMap[to] = true;\n                holders.push(to);\n            }\n        }\n\n        return transferred;\n    }\n\n    \n    function approve(address spender, uint256 value)\n    public\n    returns (bool)\n    {\n        \n        require(\n            0 == value || 0 == allowance(msg.sender, spender),\n            \"Value or allowance non-zero [RevenueToken.sol:121]\"\n        );\n\n        \n        return super.approve(spender, value);\n    }\n\n    \n    function transferFrom(address from, address to, uint256 value)\n    public\n    returns (bool)\n    {\n        \n        bool transferred = super.transferFrom(from, to, value);\n\n        if (transferred) {\n            \n            addBalanceBlocks(from);\n            addBalanceBlocks(to);\n\n            \n            if (!holdersMap[to]) {\n                holdersMap[to] = true;\n                holders.push(to);\n            }\n        }\n\n        return transferred;\n    }\n\n    \n    function balanceBlocksIn(address account, uint256 startBlock, uint256 endBlock)\n    public\n    view\n    returns (uint256)\n    {\n        require(startBlock < endBlock, \"Bounds parameters mismatch [RevenueToken.sol:173]\");\n        require(account != address(0), \"Account is null address [RevenueToken.sol:174]\");\n\n        if (balanceBlockNumbers[account].length == 0 || endBlock < balanceBlockNumbers[account][0])\n            return 0;\n\n        uint256 i = 0;\n        while (i < balanceBlockNumbers[account].length && balanceBlockNumbers[account][i] < startBlock)\n            i++;\n\n        uint256 r;\n        if (i >= balanceBlockNumbers[account].length)\n            r = balances[account][balanceBlockNumbers[account].length - 1].mul(endBlock.sub(startBlock));\n\n        else {\n            uint256 l = (i == 0) ? startBlock : balanceBlockNumbers[account][i - 1];\n\n            uint256 h = balanceBlockNumbers[account][i];\n            if (h > endBlock)\n                h = endBlock;\n\n            h = h.sub(startBlock);\n            r = (h == 0) ? 0 : balanceBlocks[account][i].mul(h).div(balanceBlockNumbers[account][i].sub(l));\n            i++;\n\n            while (i < balanceBlockNumbers[account].length && balanceBlockNumbers[account][i] < endBlock) {\n                r = r.add(balanceBlocks[account][i]);\n                i++;\n            }\n\n            if (i >= balanceBlockNumbers[account].length)\n                r = r.add(\n                    balances[account][balanceBlockNumbers[account].length - 1].mul(\n                        endBlock.sub(balanceBlockNumbers[account][balanceBlockNumbers[account].length - 1])\n                    )\n                );\n\n            else if (balanceBlockNumbers[account][i - 1] < endBlock)\n                r = r.add(\n                    balanceBlocks[account][i].mul(\n                        endBlock.sub(balanceBlockNumbers[account][i - 1])\n                    ).div(\n                        balanceBlockNumbers[account][i].sub(balanceBlockNumbers[account][i - 1])\n                    )\n                );\n        }\n\n        return r;\n    }\n\n    \n    function balanceUpdatesCount(address account)\n    public\n    view\n    returns (uint256)\n    {\n        return balanceBlocks[account].length;\n    }\n\n    \n    function holdersCount()\n    public\n    view\n    returns (uint256)\n    {\n        return holders.length;\n    }\n\n    \n    function holdersByIndices(uint256 low, uint256 up, bool posOnly)\n    public\n    view\n    returns (address[] memory)\n    {\n        require(low <= up, \"Bounds parameters mismatch [RevenueToken.sol:259]\");\n\n        up = up > holders.length - 1 ? holders.length - 1 : up;\n\n        uint256 length = 0;\n        if (posOnly) {\n            for (uint256 i = low; i <= up; i++)\n                if (0 < balanceOf(holders[i]))\n                    length++;\n        } else\n            length = up - low + 1;\n\n        address[] memory _holders = new address[](length);\n\n        uint256 j = 0;\n        for (uint256 i = low; i <= up; i++)\n            if (!posOnly || 0 < balanceOf(holders[i]))\n                _holders[j++] = holders[i];\n\n        return _holders;\n    }\n\n    function addBalanceBlocks(address account)\n    private\n    {\n        uint256 length = balanceBlockNumbers[account].length;\n        balances[account].push(balanceOf(account));\n        if (0 < length)\n            balanceBlocks[account].push(\n                balances[account][length - 1].mul(\n                    block.number.sub(balanceBlockNumbers[account][length - 1])\n                )\n            );\n        else\n            balanceBlocks[account].push(0);\n        balanceBlockNumbers[account].push(block.number);\n    }\n}\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        \n        \n        \n\n        uint256 size;\n        \n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        \n        \n        \n        \n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    \n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        \n        \n\n        \n        \n        \n        \n        \n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        \n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { \n            \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract TokenMultiTimelock is Ownable {\n    using SafeERC20 for IERC20;\n\n    \n    \n    \n    struct Release {\n        uint256 earliestReleaseTime;\n        uint256 amount;\n        uint256 blockNumber;\n        bool done;\n    }\n\n    \n    \n    \n    IERC20 public token;\n    address public beneficiary;\n\n    Release[] public releases;\n    uint256 public totalLockedAmount;\n    uint256 public executedReleasesCount;\n\n    \n    \n    \n    event SetTokenEvent(IERC20 token);\n    event SetBeneficiaryEvent(address beneficiary);\n    event DefineReleaseEvent(uint256 earliestReleaseTime, uint256 amount, uint256 blockNumber);\n    event SetReleaseBlockNumberEvent(uint256 index, uint256 blockNumber);\n    event ReleaseEvent(uint256 index, uint256 blockNumber, uint256 earliestReleaseTime,\n        uint256 actualReleaseTime, uint256 amount);\n\n    \n    \n    \n    constructor(address deployer)\n    Ownable(deployer)\n    public\n    {\n    }\n\n    \n    \n    \n    \n    \n    function setToken(IERC20 _token)\n    public\n    onlyOperator\n    notNullOrThisAddress(address(_token))\n    {\n        \n        require(address(token) == address(0), \"Token previously set [TokenMultiTimelock.sol:73]\");\n\n        \n        token = _token;\n\n        \n        emit SetTokenEvent(token);\n    }\n\n    \n    \n    function setBeneficiary(address _beneficiary)\n    public\n    onlyOperator\n    notNullAddress(_beneficiary)\n    {\n        \n        beneficiary = _beneficiary;\n\n        \n        emit SetBeneficiaryEvent(beneficiary);\n    }\n\n    \n    \n    \n    \n    \n    function defineReleases(uint256[] memory earliestReleaseTimes, uint256[] memory amounts, uint256[] memory releaseBlockNumbers)\n    onlyOperator\n    public\n    {\n        require(\n            earliestReleaseTimes.length == amounts.length,\n            \"Earliest release times and amounts lengths mismatch [TokenMultiTimelock.sol:105]\"\n        );\n        require(\n            earliestReleaseTimes.length >= releaseBlockNumbers.length,\n            \"Earliest release times and release block numbers lengths mismatch [TokenMultiTimelock.sol:109]\"\n        );\n\n        \n        require(address(token) != address(0), \"Token not initialized [TokenMultiTimelock.sol:115]\");\n\n        for (uint256 i = 0; i < earliestReleaseTimes.length; i++) {\n            \n            totalLockedAmount += amounts[i];\n\n            \n            \n            require(token.balanceOf(address(this)) >= totalLockedAmount, \"Total locked amount overrun [TokenMultiTimelock.sol:123]\");\n\n            \n            uint256 blockNumber = i < releaseBlockNumbers.length ? releaseBlockNumbers[i] : 0;\n\n            \n            releases.push(Release(earliestReleaseTimes[i], amounts[i], blockNumber, false));\n\n            \n            emit DefineReleaseEvent(earliestReleaseTimes[i], amounts[i], blockNumber);\n        }\n    }\n\n    \n    \n    function releasesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return releases.length;\n    }\n\n    \n    \n    \n    function setReleaseBlockNumber(uint256 index, uint256 blockNumber)\n    public\n    onlyBeneficiary\n    {\n        \n        require(!releases[index].done, \"Release previously done [TokenMultiTimelock.sol:154]\");\n\n        \n        releases[index].blockNumber = blockNumber;\n\n        \n        emit SetReleaseBlockNumberEvent(index, blockNumber);\n    }\n\n    \n    \n    function release(uint256 index)\n    public\n    onlyBeneficiary\n    {\n        \n        Release storage _release = releases[index];\n\n        \n        require(0 < _release.amount, \"Release amount not strictly positive [TokenMultiTimelock.sol:173]\");\n\n        \n        require(!_release.done, \"Release previously done [TokenMultiTimelock.sol:176]\");\n\n        \n        require(block.timestamp >= _release.earliestReleaseTime, \"Block time stamp less than earliest release time [TokenMultiTimelock.sol:179]\");\n\n        \n        _release.done = true;\n\n        \n        if (0 == _release.blockNumber)\n            _release.blockNumber = block.number;\n\n        \n        executedReleasesCount++;\n\n        \n        totalLockedAmount -= _release.amount;\n\n        \n        token.safeTransfer(beneficiary, _release.amount);\n\n        \n        emit ReleaseEvent(index, _release.blockNumber, _release.earliestReleaseTime, block.timestamp, _release.amount);\n    }\n\n    \n    \n    modifier onlyBeneficiary() {\n        require(msg.sender == beneficiary, \"Message sender not beneficiary [TokenMultiTimelock.sol:204]\");\n        _;\n    }\n}\n\ncontract RevenueTokenManager is TokenMultiTimelock {\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    uint256[] public totalReleasedAmounts;\n    uint256[] public totalReleasedAmountBlocks;\n\n    \n    \n    \n    constructor(address deployer)\n    public\n    TokenMultiTimelock(deployer)\n    {\n    }\n\n    \n    \n    \n    \n    \n    \n    function release(uint256 index)\n    public\n    onlyBeneficiary\n    {\n        \n        super.release(index);\n\n        \n        _addAmountBlocks(index);\n    }\n\n    \n    \n    \n    \n    \n    function releasedAmountBlocksIn(uint256 startBlock, uint256 endBlock)\n    public\n    view\n    returns (uint256)\n    {\n        require(startBlock < endBlock, \"Bounds parameters mismatch [RevenueTokenManager.sol:60]\");\n\n        if (executedReleasesCount == 0 || endBlock < releases[0].blockNumber)\n            return 0;\n\n        uint256 i = 0;\n        while (i < executedReleasesCount && releases[i].blockNumber < startBlock)\n            i++;\n\n        uint256 r;\n        if (i >= executedReleasesCount)\n            r = totalReleasedAmounts[executedReleasesCount - 1].mul(endBlock.sub(startBlock));\n\n        else {\n            uint256 l = (i == 0) ? startBlock : releases[i - 1].blockNumber;\n\n            uint256 h = releases[i].blockNumber;\n            if (h > endBlock)\n                h = endBlock;\n\n            h = h.sub(startBlock);\n            r = (h == 0) ? 0 : totalReleasedAmountBlocks[i].mul(h).div(releases[i].blockNumber.sub(l));\n            i++;\n\n            while (i < executedReleasesCount && releases[i].blockNumber < endBlock) {\n                r = r.add(totalReleasedAmountBlocks[i]);\n                i++;\n            }\n\n            if (i >= executedReleasesCount)\n                r = r.add(\n                    totalReleasedAmounts[executedReleasesCount - 1].mul(\n                        endBlock.sub(releases[executedReleasesCount - 1].blockNumber)\n                    )\n                );\n\n            else if (releases[i - 1].blockNumber < endBlock)\n                r = r.add(\n                    totalReleasedAmountBlocks[i].mul(\n                        endBlock.sub(releases[i - 1].blockNumber)\n                    ).div(\n                        releases[i].blockNumber.sub(releases[i - 1].blockNumber)\n                    )\n                );\n        }\n\n        return r;\n    }\n\n    \n    \n    \n    function releaseBlockNumbers(uint256 index)\n    public\n    view\n    returns (uint256)\n    {\n        return releases[index].blockNumber;\n    }\n\n    \n    \n    \n    function _addAmountBlocks(uint256 index)\n    private\n    {\n        \n        if (0 < index) {\n            totalReleasedAmounts.push(\n                totalReleasedAmounts[index - 1].add(releases[index].amount)\n            );\n            totalReleasedAmountBlocks.push(\n                totalReleasedAmounts[index - 1].mul(\n                    releases[index].blockNumber.sub(releases[index - 1].blockNumber)\n                )\n            );\n\n        } else {\n            totalReleasedAmounts.push(releases[index].amount);\n            totalReleasedAmountBlocks.push(0);\n        }\n    }\n}\n\ncontract TokenHolderRevenueFund is Ownable, AccrualBeneficiary, Servable, TransferControllerManageable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using TxHistoryLib for TxHistoryLib.TxHistory;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    \n    \n    \n    string constant public CLOSE_ACCRUAL_PERIOD_ACTION = \"close_accrual_period\";\n\n    \n    \n    \n    RevenueTokenManager public revenueTokenManager;\n\n    FungibleBalanceLib.Balance private periodAccrual;\n    CurrenciesLib.Currencies private periodCurrencies;\n\n    FungibleBalanceLib.Balance private aggregateAccrual;\n    CurrenciesLib.Currencies private aggregateCurrencies;\n\n    TxHistoryLib.TxHistory private txHistory;\n\n    mapping(address => mapping(address => mapping(uint256 => uint256[]))) public claimedAccrualBlockNumbersByWalletCurrency;\n\n    mapping(address => mapping(uint256 => uint256[])) public accrualBlockNumbersByCurrency;\n    mapping(address => mapping(uint256 => mapping(uint256 => int256))) public aggregateAccrualAmountByCurrencyBlockNumber;\n\n    mapping(address => FungibleBalanceLib.Balance) private stagedByWallet;\n\n    \n    \n    \n    event SetRevenueTokenManagerEvent(RevenueTokenManager oldRevenueTokenManager,\n        RevenueTokenManager newRevenueTokenManager);\n    event ReceiveEvent(address wallet, int256 amount, address currencyCt,\n        uint256 currencyId);\n    event WithdrawEvent(address to, int256 amount, address currencyCt, uint256 currencyId);\n    event CloseAccrualPeriodEvent(int256 periodAmount, int256 aggregateAmount, address currencyCt,\n        uint256 currencyId);\n    event ClaimAndTransferToBeneficiaryEvent(address wallet, string balanceType, int256 amount,\n        address currencyCt, uint256 currencyId, string standard);\n    event ClaimAndTransferToBeneficiaryByProxyEvent(address wallet, string balanceType, int256 amount,\n        address currencyCt, uint256 currencyId, string standard);\n    event ClaimAndStageEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event WithdrawEvent(address from, int256 amount, address currencyCt, uint256 currencyId,\n        string standard);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    \n    function setRevenueTokenManager(RevenueTokenManager newRevenueTokenManager)\n    public\n    onlyDeployer\n    notNullAddress(address(newRevenueTokenManager))\n    {\n        if (newRevenueTokenManager != revenueTokenManager) {\n            \n            RevenueTokenManager oldRevenueTokenManager = revenueTokenManager;\n            revenueTokenManager = newRevenueTokenManager;\n\n            \n            emit SetRevenueTokenManagerEvent(oldRevenueTokenManager, newRevenueTokenManager);\n        }\n    }\n\n    \n    function() external payable {\n        receiveEthersTo(msg.sender, \"\");\n    }\n\n    \n    \n    function receiveEthersTo(address wallet, string memory)\n    public\n    payable\n    {\n        int256 amount = SafeMathIntLib.toNonZeroInt256(msg.value);\n\n        \n        periodAccrual.add(amount, address(0), 0);\n        aggregateAccrual.add(amount, address(0), 0);\n\n        \n        periodCurrencies.add(address(0), 0);\n        aggregateCurrencies.add(address(0), 0);\n\n        \n        txHistory.addDeposit(amount, address(0), 0);\n\n        \n        emit ReceiveEvent(wallet, amount, address(0), 0);\n    }\n\n    \n    \n    \n    \n    \n    function receiveTokens(string memory, int256 amount, address currencyCt, uint256 currencyId,\n        string memory standard)\n    public\n    {\n        receiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    \n    \n    \n    function receiveTokensTo(address wallet, string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [TokenHolderRevenueFund.sol:157]\");\n\n        \n        TransferController controller = transferController(currencyCt, standard);\n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\n            )\n        );\n        require(success, \"Reception by controller failed [TokenHolderRevenueFund.sol:166]\");\n\n        \n        periodAccrual.add(amount, currencyCt, currencyId);\n        aggregateAccrual.add(amount, currencyCt, currencyId);\n\n        \n        periodCurrencies.add(currencyCt, currencyId);\n        aggregateCurrencies.add(currencyCt, currencyId);\n\n        \n        txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        \n        emit ReceiveEvent(wallet, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    function periodAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return periodAccrual.get(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function aggregateAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return aggregateAccrual.get(currencyCt, currencyId);\n    }\n\n    \n    \n    function periodCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return periodCurrencies.count();\n    }\n\n    \n    \n    \n    \n    function periodCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return periodCurrencies.getByIndices(low, up);\n    }\n\n    \n    \n    function aggregateCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return aggregateCurrencies.count();\n    }\n\n    \n    \n    \n    \n    function aggregateCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return aggregateCurrencies.getByIndices(low, up);\n    }\n\n    \n    \n    function depositsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return txHistory.depositsCount();\n    }\n\n    \n    \n    function deposit(uint index)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        return txHistory.deposit(index);\n    }\n\n    \n    \n    \n    \n    \n    function stagedBalance(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return stagedByWallet[wallet].get(currencyCt, currencyId);\n    }\n\n    \n    \n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\n    public\n    onlyEnabledServiceAction(CLOSE_ACCRUAL_PERIOD_ACTION)\n    {\n        \n        for (uint256 i = 0; i < currencies.length; i++) {\n            MonetaryTypesLib.Currency memory currency = currencies[i];\n\n            \n            int256 periodAmount = periodAccrual.get(currency.ct, currency.id);\n\n            \n            accrualBlockNumbersByCurrency[currency.ct][currency.id].push(block.number);\n\n            \n            aggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number] = aggregateAccrualBalance(\n                currency.ct, currency.id\n            );\n\n            if (periodAmount > 0) {\n                \n                periodAccrual.set(0, currency.ct, currency.id);\n\n                \n                periodCurrencies.removeByCurrency(currency.ct, currency.id);\n            }\n\n            \n            emit CloseAccrualPeriodEvent(\n                periodAmount,\n                aggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number],\n                currency.ct, currency.id\n            );\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function claimAndTransferToBeneficiary(Beneficiary beneficiary, address destWallet, string memory balanceType,\n        address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        \n        int256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n        \n        if (address(0) == currencyCt && 0 == currencyId)\n            beneficiary.receiveEthersTo.value(uint256(claimedAmount))(destWallet, balanceType);\n\n        else {\n            \n            TransferController controller = transferController(currencyCt, standard);\n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\n                )\n            );\n            require(success, \"Approval by controller failed [TokenHolderRevenueFund.sol:349]\");\n\n            \n            beneficiary.receiveTokensTo(destWallet, balanceType, claimedAmount, currencyCt, currencyId, standard);\n        }\n\n        \n        emit ClaimAndTransferToBeneficiaryEvent(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    function claimAndStage(address currencyCt, uint256 currencyId)\n    public\n    {\n        \n        int256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n        \n        stagedByWallet[msg.sender].add(claimedAmount, currencyCt, currencyId);\n\n        \n        emit ClaimAndStageEvent(msg.sender, claimedAmount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        \n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [TokenHolderRevenueFund.sol:384]\");\n\n        \n        amount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n        \n        stagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n        \n        if (address(0) == currencyCt && 0 == currencyId)\n            msg.sender.transfer(uint256(amount));\n\n        else {\n            TransferController controller = transferController(currencyCt, standard);\n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n                )\n            );\n            require(success, \"Dispatch by controller failed [TokenHolderRevenueFund.sol:403]\");\n        }\n\n        \n        emit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    function _claim(address wallet, address currencyCt, uint256 currencyId)\n    private\n    returns (int256)\n    {\n        \n        require(0 < accrualBlockNumbersByCurrency[currencyCt][currencyId].length, \"No terminated accrual period found [TokenHolderRevenueFund.sol:418]\");\n\n        \n        uint256[] storage claimedAccrualBlockNumbers = claimedAccrualBlockNumbersByWalletCurrency[wallet][currencyCt][currencyId];\n        uint256 bnLow = (0 == claimedAccrualBlockNumbers.length ? 0 : claimedAccrualBlockNumbers[claimedAccrualBlockNumbers.length - 1]);\n\n        \n        uint256 bnUp = accrualBlockNumbersByCurrency[currencyCt][currencyId][accrualBlockNumbersByCurrency[currencyCt][currencyId].length - 1];\n\n        \n        require(bnLow < bnUp, \"Bounds parameters mismatch [TokenHolderRevenueFund.sol:428]\");\n\n        \n        int256 claimableAmount = aggregateAccrualAmountByCurrencyBlockNumber[currencyCt][currencyId][bnUp]\n        - (0 == bnLow ? 0 : aggregateAccrualAmountByCurrencyBlockNumber[currencyCt][currencyId][bnLow]);\n\n        \n        require(claimableAmount.isNonZeroPositiveInt256(), \"Claimable amount not strictly positive [TokenHolderRevenueFund.sol:435]\");\n\n        \n        int256 walletBalanceBlocks = int256(\n            RevenueToken(address(revenueTokenManager.token())).balanceBlocksIn(wallet, bnLow, bnUp)\n        );\n\n        \n        int256 releasedAmountBlocks = int256(\n            revenueTokenManager.releasedAmountBlocksIn(bnLow, bnUp)\n        );\n\n        \n        int256 claimedAmount = walletBalanceBlocks.mul_nn(claimableAmount).mul_nn(1e18).div_nn(releasedAmountBlocks.mul_nn(1e18));\n\n        \n        claimedAccrualBlockNumbers.push(bnUp);\n\n        \n        return claimedAmount;\n    }\n}\n\ncontract ClientFund is Ownable, Beneficiary, Benefactor, AuthorizableServable, TransferControllerManageable,\nBalanceTrackable, TransactionTrackable, WalletLockable {\n    using SafeMathIntLib for int256;\n\n    address[] public seizedWallets;\n    mapping(address => bool) public seizedByWallet;\n\n    TokenHolderRevenueFund public tokenHolderRevenueFund;\n\n    \n    \n    \n    event SetTokenHolderRevenueFundEvent(TokenHolderRevenueFund oldTokenHolderRevenueFund,\n        TokenHolderRevenueFund newTokenHolderRevenueFund);\n    event ReceiveEvent(address wallet, string balanceType, int256 value, address currencyCt,\n        uint256 currencyId, string standard);\n    event WithdrawEvent(address wallet, int256 value, address currencyCt, uint256 currencyId,\n        string standard);\n    event StageEvent(address wallet, int256 value, address currencyCt, uint256 currencyId,\n        string standard);\n    event UnstageEvent(address wallet, int256 value, address currencyCt, uint256 currencyId,\n        string standard);\n    event UpdateSettledBalanceEvent(address wallet, int256 value, address currencyCt,\n        uint256 currencyId);\n    event StageToBeneficiaryEvent(address sourceWallet, Beneficiary beneficiary, int256 value,\n        address currencyCt, uint256 currencyId, string standard);\n    event TransferToBeneficiaryEvent(address wallet, Beneficiary beneficiary, int256 value,\n        address currencyCt, uint256 currencyId, string standard);\n    event SeizeBalancesEvent(address seizedWallet, address seizerWallet, int256 value,\n        address currencyCt, uint256 currencyId);\n    event ClaimRevenueEvent(address claimer, string balanceType, address currencyCt,\n        uint256 currencyId, string standard);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) Beneficiary() Benefactor()\n    public\n    {\n        serviceActivationTimeout = 1 weeks;\n    }\n\n    \n    \n    \n    \n    \n    function setTokenHolderRevenueFund(TokenHolderRevenueFund newTokenHolderRevenueFund)\n    public\n    onlyDeployer\n    notNullAddress(address(newTokenHolderRevenueFund))\n    notSameAddresses(address(newTokenHolderRevenueFund), address(tokenHolderRevenueFund))\n    {\n        \n        TokenHolderRevenueFund oldTokenHolderRevenueFund = tokenHolderRevenueFund;\n        tokenHolderRevenueFund = newTokenHolderRevenueFund;\n\n        \n        emit SetTokenHolderRevenueFundEvent(oldTokenHolderRevenueFund, newTokenHolderRevenueFund);\n    }\n\n    \n    function()\n    external\n    payable\n    {\n        receiveEthersTo(msg.sender, balanceTracker.DEPOSITED_BALANCE_TYPE());\n    }\n\n    \n    \n    \n    function receiveEthersTo(address wallet, string memory balanceType)\n    public\n    payable\n    {\n        int256 value = SafeMathIntLib.toNonZeroInt256(msg.value);\n\n        \n        _receiveTo(wallet, balanceType, value, address(0), 0, true);\n\n        \n        emit ReceiveEvent(wallet, balanceType, value, address(0), 0, \"\");\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function receiveTokens(string memory balanceType, int256 value, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        receiveTokensTo(msg.sender, balanceType, value, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function receiveTokensTo(address wallet, string memory balanceType, int256 value, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        require(value.isNonZeroPositiveInt256());\n\n        \n        TransferController controller = transferController(currencyCt, standard);\n\n        \n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(value), currencyCt, currencyId\n            )\n        );\n        require(success);\n\n        \n        _receiveTo(wallet, balanceType, value, currencyCt, currencyId, controller.isFungible());\n\n        \n        emit ReceiveEvent(wallet, balanceType, value, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function updateSettledBalance(address wallet, int256 value, address currencyCt, uint256 currencyId,\n        string memory standard, uint256 blockNumber)\n    public\n    onlyAuthorizedService(wallet)\n    notNullAddress(wallet)\n    {\n        require(value.isPositiveInt256());\n\n        if (_isFungible(currencyCt, currencyId, standard)) {\n            (int256 depositedValue,) = balanceTracker.fungibleRecordByBlockNumber(\n                wallet, balanceTracker.depositedBalanceType(), currencyCt, currencyId, blockNumber\n            );\n            balanceTracker.set(\n                wallet, balanceTracker.settledBalanceType(), value.sub(depositedValue),\n                currencyCt, currencyId, true\n            );\n\n        } else {\n            balanceTracker.sub(\n                wallet, balanceTracker.depositedBalanceType(), value, currencyCt, currencyId, false\n            );\n            balanceTracker.add(\n                wallet, balanceTracker.settledBalanceType(), value, currencyCt, currencyId, false\n            );\n        }\n\n        \n        emit UpdateSettledBalanceEvent(wallet, value, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    \n    function stage(address wallet, int256 value, address currencyCt, uint256 currencyId,\n        string memory standard)\n    public\n    onlyAuthorizedService(wallet)\n    {\n        require(value.isNonZeroPositiveInt256());\n\n        \n        bool fungible = _isFungible(currencyCt, currencyId, standard);\n\n        \n        value = _subtractSequentially(wallet, balanceTracker.activeBalanceTypes(), value, currencyCt, currencyId, fungible);\n\n        \n        balanceTracker.add(\n            wallet, balanceTracker.stagedBalanceType(), value, currencyCt, currencyId, fungible\n        );\n\n        \n        emit StageEvent(wallet, value, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    \n    \n    function unstage(int256 value, address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        require(value.isNonZeroPositiveInt256());\n\n        \n        bool fungible = _isFungible(currencyCt, currencyId, standard);\n\n        \n        value = _subtractFromStaged(msg.sender, value, currencyCt, currencyId, fungible);\n\n        \n        balanceTracker.add(\n            msg.sender, balanceTracker.depositedBalanceType(), value, currencyCt, currencyId, fungible\n        );\n\n        \n        emit UnstageEvent(msg.sender, value, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function stageToBeneficiary(address wallet, Beneficiary beneficiary, int256 value,\n        address currencyCt, uint256 currencyId, string memory standard)\n    public\n    onlyAuthorizedService(wallet)\n    {\n        \n        bool fungible = _isFungible(currencyCt, currencyId, standard);\n\n        \n        value = _subtractSequentially(wallet, balanceTracker.activeBalanceTypes(), value, currencyCt, currencyId, fungible);\n\n        \n        _transferToBeneficiary(wallet, beneficiary, value, currencyCt, currencyId, standard);\n\n        \n        emit StageToBeneficiaryEvent(wallet, beneficiary, value, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transferToBeneficiary(address wallet, Beneficiary beneficiary, int256 value,\n        address currencyCt, uint256 currencyId, string memory standard)\n    public\n    onlyAuthorizedService(wallet)\n    {\n        \n        _transferToBeneficiary(wallet, beneficiary, value, currencyCt, currencyId, standard);\n\n        \n        emit TransferToBeneficiaryEvent(wallet, beneficiary, value, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    \n    \n    \n    function seizeBalances(address wallet, address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        if (_isFungible(currencyCt, currencyId, standard))\n            _seizeFungibleBalances(wallet, msg.sender, currencyCt, currencyId);\n\n        else\n            _seizeNonFungibleBalances(wallet, msg.sender, currencyCt, currencyId);\n\n        \n        if (!seizedByWallet[wallet]) {\n            seizedByWallet[wallet] = true;\n            seizedWallets.push(wallet);\n        }\n    }\n\n    \n    \n    \n    \n    \n    function withdraw(int256 value, address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        require(value.isNonZeroPositiveInt256());\n\n        \n        require(!walletLocker.isLocked(msg.sender, currencyCt, currencyId));\n\n        \n        bool fungible = _isFungible(currencyCt, currencyId, standard);\n\n        \n        value = _subtractFromStaged(msg.sender, value, currencyCt, currencyId, fungible);\n\n        \n        transactionTracker.add(\n            msg.sender, transactionTracker.withdrawalTransactionType(), value, currencyCt, currencyId\n        );\n\n        \n        _transferToWallet(msg.sender, value, currencyCt, currencyId, standard);\n\n        \n        emit WithdrawEvent(msg.sender, value, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    function isSeizedWallet(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return seizedByWallet[wallet];\n    }\n\n    \n    \n    function seizedWalletsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return seizedWallets.length;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function claimRevenue(address claimer, string memory balanceType, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    onlyOperator\n    {\n        tokenHolderRevenueFund.claimAndTransferToBeneficiary(\n            this, claimer, balanceType,\n            currencyCt, currencyId, standard\n        );\n\n        emit ClaimRevenueEvent(claimer, balanceType, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    function _receiveTo(address wallet, string memory balanceType, int256 value, address currencyCt,\n        uint256 currencyId, bool fungible)\n    private\n    {\n        bytes32 balanceHash = 0 < bytes(balanceType).length ?\n        keccak256(abi.encodePacked(balanceType)) :\n        balanceTracker.depositedBalanceType();\n\n        \n        if (balanceTracker.stagedBalanceType() == balanceHash)\n            balanceTracker.add(\n                wallet, balanceTracker.stagedBalanceType(), value, currencyCt, currencyId, fungible\n            );\n\n        \n        else if (balanceTracker.depositedBalanceType() == balanceHash) {\n            balanceTracker.add(\n                wallet, balanceTracker.depositedBalanceType(), value, currencyCt, currencyId, fungible\n            );\n\n            \n            transactionTracker.add(\n                wallet, transactionTracker.depositTransactionType(), value, currencyCt, currencyId\n            );\n        }\n\n        else\n            revert();\n    }\n\n    function _subtractSequentially(address wallet, bytes32[] memory balanceTypes, int256 value, address currencyCt,\n        uint256 currencyId, bool fungible)\n    private\n    returns (int256)\n    {\n        if (fungible)\n            return _subtractFungibleSequentially(wallet, balanceTypes, value, currencyCt, currencyId);\n        else\n            return _subtractNonFungibleSequentially(wallet, balanceTypes, value, currencyCt, currencyId);\n    }\n\n    function _subtractFungibleSequentially(address wallet, bytes32[] memory balanceTypes, int256 amount, address currencyCt, uint256 currencyId)\n    private\n    returns (int256)\n    {\n        \n        require(0 <= amount);\n\n        uint256 i;\n        int256 totalBalanceAmount = 0;\n        for (i = 0; i < balanceTypes.length; i++)\n            totalBalanceAmount = totalBalanceAmount.add(\n                balanceTracker.get(\n                    wallet, balanceTypes[i], currencyCt, currencyId\n                )\n            );\n\n        \n        amount = amount.clampMax(totalBalanceAmount);\n\n        int256 _amount = amount;\n        for (i = 0; i < balanceTypes.length; i++) {\n            int256 typeAmount = balanceTracker.get(\n                wallet, balanceTypes[i], currencyCt, currencyId\n            );\n\n            if (typeAmount >= _amount) {\n                balanceTracker.sub(\n                    wallet, balanceTypes[i], _amount, currencyCt, currencyId, true\n                );\n                break;\n\n            } else {\n                balanceTracker.set(\n                    wallet, balanceTypes[i], 0, currencyCt, currencyId, true\n                );\n                _amount = _amount.sub(typeAmount);\n            }\n        }\n\n        return amount;\n    }\n\n    function _subtractNonFungibleSequentially(address wallet, bytes32[] memory balanceTypes, int256 id, address currencyCt, uint256 currencyId)\n    private\n    returns (int256)\n    {\n        for (uint256 i = 0; i < balanceTypes.length; i++)\n            if (balanceTracker.hasId(wallet, balanceTypes[i], id, currencyCt, currencyId)) {\n                balanceTracker.sub(wallet, balanceTypes[i], id, currencyCt, currencyId, false);\n                break;\n            }\n\n        return id;\n    }\n\n    function _subtractFromStaged(address wallet, int256 value, address currencyCt, uint256 currencyId, bool fungible)\n    private\n    returns (int256)\n    {\n        if (fungible) {\n            \n            value = value.clampMax(\n                balanceTracker.get(wallet, balanceTracker.stagedBalanceType(), currencyCt, currencyId)\n            );\n\n            \n            require(0 <= value);\n\n        } else {\n            \n            require(balanceTracker.hasId(wallet, balanceTracker.stagedBalanceType(), value, currencyCt, currencyId));\n        }\n\n        \n        balanceTracker.sub(wallet, balanceTracker.stagedBalanceType(), value, currencyCt, currencyId, fungible);\n\n        return value;\n    }\n\n    function _transferToBeneficiary(address destWallet, Beneficiary beneficiary,\n        int256 value, address currencyCt, uint256 currencyId, string memory standard)\n    private\n    {\n        require(value.isNonZeroPositiveInt256());\n        require(isRegisteredBeneficiary(beneficiary));\n\n        \n        if (address(0) == currencyCt && 0 == currencyId)\n            beneficiary.receiveEthersTo.value(uint256(value))(destWallet, \"\");\n\n        else {\n            \n            TransferController controller = transferController(currencyCt, standard);\n\n            \n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getApproveSignature(), address(beneficiary), uint256(value), currencyCt, currencyId\n                )\n            );\n            require(success);\n\n            \n            beneficiary.receiveTokensTo(destWallet, \"\", value, currencyCt, currencyId, controller.standard());\n        }\n    }\n\n    function _transferToWallet(address payable wallet,\n        int256 value, address currencyCt, uint256 currencyId, string memory standard)\n    private\n    {\n        \n        if (address(0) == currencyCt && 0 == currencyId)\n            wallet.transfer(uint256(value));\n\n        else {\n            \n            TransferController controller = transferController(currencyCt, standard);\n\n            \n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getDispatchSignature(), address(this), wallet, uint256(value), currencyCt, currencyId\n                )\n            );\n            require(success);\n        }\n    }\n\n    function _seizeFungibleBalances(address lockedWallet, address lockerWallet, address currencyCt,\n        uint256 currencyId)\n    private\n    {\n        \n        int256 amount = walletLocker.lockedAmount(lockedWallet, lockerWallet, currencyCt, currencyId);\n\n        \n        require(amount > 0);\n\n        \n        _subtractFungibleSequentially(lockedWallet, balanceTracker.allBalanceTypes(), amount, currencyCt, currencyId);\n\n        \n        balanceTracker.add(\n            lockerWallet, balanceTracker.stagedBalanceType(), amount, currencyCt, currencyId, true\n        );\n\n        \n        emit SeizeBalancesEvent(lockedWallet, lockerWallet, amount, currencyCt, currencyId);\n    }\n\n    function _seizeNonFungibleBalances(address lockedWallet, address lockerWallet, address currencyCt,\n        uint256 currencyId)\n    private\n    {\n        \n        uint256 lockedIdsCount = walletLocker.lockedIdsCount(lockedWallet, lockerWallet, currencyCt, currencyId);\n        require(0 < lockedIdsCount);\n\n        \n        int256[] memory ids = walletLocker.lockedIdsByIndices(\n            lockedWallet, lockerWallet, currencyCt, currencyId, 0, lockedIdsCount - 1\n        );\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            \n            _subtractNonFungibleSequentially(lockedWallet, balanceTracker.allBalanceTypes(), ids[i], currencyCt, currencyId);\n\n            \n            balanceTracker.add(\n                lockerWallet, balanceTracker.stagedBalanceType(), ids[i], currencyCt, currencyId, false\n            );\n\n            \n            emit SeizeBalancesEvent(lockedWallet, lockerWallet, ids[i], currencyCt, currencyId);\n        }\n    }\n\n    function _isFungible(address currencyCt, uint256 currencyId, string memory standard)\n    private\n    view\n    returns (bool)\n    {\n        return (address(0) == currencyCt && 0 == currencyId) || transferController(currencyCt, standard).isFungible();\n    }\n}\n\ncontract ClientFundable is Ownable {\n    \n    \n    \n    ClientFund public clientFund;\n\n    \n    \n    \n    event SetClientFundEvent(ClientFund oldClientFund, ClientFund newClientFund);\n\n    \n    \n    \n    \n    \n    function setClientFund(ClientFund newClientFund) public\n    onlyDeployer\n    notNullAddress(address(newClientFund))\n    notSameAddresses(address(newClientFund), address(clientFund))\n    {\n        \n        ClientFund oldClientFund = clientFund;\n        clientFund = newClientFund;\n\n        \n        emit SetClientFundEvent(oldClientFund, newClientFund);\n    }\n\n    \n    \n    \n    modifier clientFundInitialized() {\n        require(address(clientFund) != address(0), \"Client fund not initialized [ClientFundable.sol:51]\");\n        _;\n    }\n}\n\ncontract CommunityVote is Ownable {\n    \n    \n    \n    mapping(address => bool) doubleSpenderByWallet;\n    uint256 maxDriipNonce;\n    uint256 maxNullNonce;\n    bool dataAvailable;\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n        dataAvailable = true;\n    }\n\n    \n    \n    \n    \n    \n    \n    function isDoubleSpenderWallet(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return doubleSpenderByWallet[wallet];\n    }\n\n    \n    \n    function getMaxDriipNonce()\n    public\n    view\n    returns (uint256)\n    {\n        return maxDriipNonce;\n    }\n\n    \n    \n    function getMaxNullNonce()\n    public\n    view\n    returns (uint256)\n    {\n        return maxNullNonce;\n    }\n\n    \n    \n    function isDataAvailable()\n    public\n    view\n    returns (bool)\n    {\n        return dataAvailable;\n    }\n}\n\ncontract CommunityVotable is Ownable {\n    \n    \n    \n    CommunityVote public communityVote;\n    bool public communityVoteFrozen;\n\n    \n    \n    \n    event SetCommunityVoteEvent(CommunityVote oldCommunityVote, CommunityVote newCommunityVote);\n    event FreezeCommunityVoteEvent();\n\n    \n    \n    \n    \n    \n    function setCommunityVote(CommunityVote newCommunityVote) \n    public \n    onlyDeployer\n    notNullAddress(address(newCommunityVote))\n    notSameAddresses(address(newCommunityVote), address(communityVote))\n    {\n        require(!communityVoteFrozen, \"Community vote frozen [CommunityVotable.sol:41]\");\n\n        \n        CommunityVote oldCommunityVote = communityVote;\n        communityVote = newCommunityVote;\n\n        \n        emit SetCommunityVoteEvent(oldCommunityVote, newCommunityVote);\n    }\n\n    \n    \n    function freezeCommunityVote()\n    public\n    onlyDeployer\n    {\n        communityVoteFrozen = true;\n\n        \n        emit FreezeCommunityVoteEvent();\n    }\n\n    \n    \n    \n    modifier communityVoteInitialized() {\n        require(address(communityVote) != address(0), \"Community vote not initialized [CommunityVotable.sol:67]\");\n        _;\n    }\n}\n\ncontract FraudChallenge is Ownable, Servable {\n    \n    \n    \n    string constant public ADD_SEIZED_WALLET_ACTION = \"add_seized_wallet\";\n    string constant public ADD_DOUBLE_SPENDER_WALLET_ACTION = \"add_double_spender_wallet\";\n    string constant public ADD_FRAUDULENT_ORDER_ACTION = \"add_fraudulent_order\";\n    string constant public ADD_FRAUDULENT_TRADE_ACTION = \"add_fraudulent_trade\";\n    string constant public ADD_FRAUDULENT_PAYMENT_ACTION = \"add_fraudulent_payment\";\n\n    \n    \n    \n    address[] public doubleSpenderWallets;\n    mapping(address => bool) public doubleSpenderByWallet;\n\n    bytes32[] public fraudulentOrderHashes;\n    mapping(bytes32 => bool) public fraudulentByOrderHash;\n\n    bytes32[] public fraudulentTradeHashes;\n    mapping(bytes32 => bool) public fraudulentByTradeHash;\n\n    bytes32[] public fraudulentPaymentHashes;\n    mapping(bytes32 => bool) public fraudulentByPaymentHash;\n\n    \n    \n    \n    event AddDoubleSpenderWalletEvent(address wallet);\n    event AddFraudulentOrderHashEvent(bytes32 hash);\n    event AddFraudulentTradeHashEvent(bytes32 hash);\n    event AddFraudulentPaymentHashEvent(bytes32 hash);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    \n    \n    function isDoubleSpenderWallet(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return doubleSpenderByWallet[wallet];\n    }\n\n    \n    \n    function doubleSpenderWalletsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return doubleSpenderWallets.length;\n    }\n\n    \n    \n    function addDoubleSpenderWallet(address wallet)\n    public\n    onlyEnabledServiceAction(ADD_DOUBLE_SPENDER_WALLET_ACTION) {\n        if (!doubleSpenderByWallet[wallet]) {\n            doubleSpenderWallets.push(wallet);\n            doubleSpenderByWallet[wallet] = true;\n            emit AddDoubleSpenderWalletEvent(wallet);\n        }\n    }\n\n    \n    function fraudulentOrderHashesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return fraudulentOrderHashes.length;\n    }\n\n    \n    \n    function isFraudulentOrderHash(bytes32 hash)\n    public\n    view returns (bool) {\n        return fraudulentByOrderHash[hash];\n    }\n\n    \n    function addFraudulentOrderHash(bytes32 hash)\n    public\n    onlyEnabledServiceAction(ADD_FRAUDULENT_ORDER_ACTION)\n    {\n        if (!fraudulentByOrderHash[hash]) {\n            fraudulentByOrderHash[hash] = true;\n            fraudulentOrderHashes.push(hash);\n            emit AddFraudulentOrderHashEvent(hash);\n        }\n    }\n\n    \n    function fraudulentTradeHashesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return fraudulentTradeHashes.length;\n    }\n\n    \n    \n    \n    function isFraudulentTradeHash(bytes32 hash)\n    public\n    view\n    returns (bool)\n    {\n        return fraudulentByTradeHash[hash];\n    }\n\n    \n    function addFraudulentTradeHash(bytes32 hash)\n    public\n    onlyEnabledServiceAction(ADD_FRAUDULENT_TRADE_ACTION)\n    {\n        if (!fraudulentByTradeHash[hash]) {\n            fraudulentByTradeHash[hash] = true;\n            fraudulentTradeHashes.push(hash);\n            emit AddFraudulentTradeHashEvent(hash);\n        }\n    }\n\n    \n    function fraudulentPaymentHashesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return fraudulentPaymentHashes.length;\n    }\n\n    \n    \n    \n    function isFraudulentPaymentHash(bytes32 hash)\n    public\n    view\n    returns (bool)\n    {\n        return fraudulentByPaymentHash[hash];\n    }\n\n    \n    function addFraudulentPaymentHash(bytes32 hash)\n    public\n    onlyEnabledServiceAction(ADD_FRAUDULENT_PAYMENT_ACTION)\n    {\n        if (!fraudulentByPaymentHash[hash]) {\n            fraudulentByPaymentHash[hash] = true;\n            fraudulentPaymentHashes.push(hash);\n            emit AddFraudulentPaymentHashEvent(hash);\n        }\n    }\n}\n\ncontract FraudChallengable is Ownable {\n    \n    \n    \n    FraudChallenge public fraudChallenge;\n\n    \n    \n    \n    event SetFraudChallengeEvent(FraudChallenge oldFraudChallenge, FraudChallenge newFraudChallenge);\n\n    \n    \n    \n    \n    \n    function setFraudChallenge(FraudChallenge newFraudChallenge)\n    public\n    onlyDeployer\n    notNullAddress(address(newFraudChallenge))\n    notSameAddresses(address(newFraudChallenge), address(fraudChallenge))\n    {\n        \n        FraudChallenge oldFraudChallenge = fraudChallenge;\n        fraudChallenge = newFraudChallenge;\n\n        \n        emit SetFraudChallengeEvent(oldFraudChallenge, newFraudChallenge);\n    }\n\n    \n    \n    \n    modifier fraudChallengeInitialized() {\n        require(address(fraudChallenge) != address(0), \"Fraud challenge not initialized [FraudChallengable.sol:52]\");\n        _;\n    }\n}\n\ncontract PartnerBenefactor is Ownable, Benefactor {\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) Benefactor()\n    public\n    {\n    }\n}\n\ncontract PartnerBenefactorable is Ownable {\n    \n    \n    \n    PartnerBenefactor public partnerBenefactor;\n\n    \n    \n    \n    event SetPartnerBenefactorEvent(PartnerBenefactor oldPartnerBenefactor, PartnerBenefactor newPartnerBenefactor);\n\n    \n    \n    \n    \n    \n    function setPartnerBenefactor(PartnerBenefactor newPartnerBenefactor)\n    public\n    onlyDeployer\n    notNullAddress(address(newPartnerBenefactor))\n    notSameAddresses(address(newPartnerBenefactor), address(partnerBenefactor))\n    {\n        \n        PartnerBenefactor oldPartnerBenefactor = partnerBenefactor;\n        partnerBenefactor = newPartnerBenefactor;\n\n        \n        emit SetPartnerBenefactorEvent(oldPartnerBenefactor, newPartnerBenefactor);\n    }\n\n    \n    \n    \n    modifier partnerBenefactorInitialized() {\n        require(address(partnerBenefactor) != address(0), \"Partner benefactor not initialized [PartnerBenefactorable.sol:52]\");\n        _;\n    }\n}\n\ncontract AccrualBenefactor is Benefactor {\n    using SafeMathIntLib for int256;\n\n    \n    \n    \n    mapping(address => int256) private _beneficiaryFractionMap;\n    int256 public totalBeneficiaryFraction;\n\n    \n    \n    \n    event RegisterAccrualBeneficiaryEvent(Beneficiary beneficiary, int256 fraction);\n    event DeregisterAccrualBeneficiaryEvent(Beneficiary beneficiary);\n\n    \n    \n    \n    \n    \n    function registerBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        return registerFractionalBeneficiary(AccrualBeneficiary(address(beneficiary)), ConstantsLib.PARTS_PER());\n    }\n\n    \n    \n    \n    function registerFractionalBeneficiary(AccrualBeneficiary beneficiary, int256 fraction)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        require(fraction > 0, \"Fraction not strictly positive [AccrualBenefactor.sol:59]\");\n        require(\n            totalBeneficiaryFraction.add(fraction) <= ConstantsLib.PARTS_PER(),\n            \"Total beneficiary fraction out of bounds [AccrualBenefactor.sol:60]\"\n        );\n\n        if (!super.registerBeneficiary(beneficiary))\n            return false;\n\n        _beneficiaryFractionMap[address(beneficiary)] = fraction;\n        totalBeneficiaryFraction = totalBeneficiaryFraction.add(fraction);\n\n        \n        emit RegisterAccrualBeneficiaryEvent(beneficiary, fraction);\n\n        return true;\n    }\n\n    \n    \n    function deregisterBeneficiary(Beneficiary beneficiary)\n    public\n    onlyDeployer\n    notNullAddress(address(beneficiary))\n    returns (bool)\n    {\n        if (!super.deregisterBeneficiary(beneficiary))\n            return false;\n\n        address _beneficiary = address(beneficiary);\n\n        totalBeneficiaryFraction = totalBeneficiaryFraction.sub(_beneficiaryFractionMap[_beneficiary]);\n        _beneficiaryFractionMap[_beneficiary] = 0;\n\n        \n        emit DeregisterAccrualBeneficiaryEvent(beneficiary);\n\n        return true;\n    }\n\n    \n    \n    \n    function beneficiaryFraction(AccrualBeneficiary beneficiary)\n    public\n    view\n    returns (int256)\n    {\n        return _beneficiaryFractionMap[address(beneficiary)];\n    }\n}\n\ncontract RevenueFund is Ownable, AccrualBeneficiary, AccrualBenefactor, TransferControllerManageable {\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using TxHistoryLib for TxHistoryLib.TxHistory;\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using CurrenciesLib for CurrenciesLib.Currencies;\n\n    \n    \n    \n    FungibleBalanceLib.Balance periodAccrual;\n    CurrenciesLib.Currencies periodCurrencies;\n\n    FungibleBalanceLib.Balance aggregateAccrual;\n    CurrenciesLib.Currencies aggregateCurrencies;\n\n    TxHistoryLib.TxHistory private txHistory;\n\n    \n    \n    \n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event CloseAccrualPeriodEvent();\n    event RegisterServiceEvent(address service);\n    event DeregisterServiceEvent(address service);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    function() external payable {\n        receiveEthersTo(msg.sender, \"\");\n    }\n\n    \n    \n    function receiveEthersTo(address wallet, string memory)\n    public\n    payable\n    {\n        int256 amount = SafeMathIntLib.toNonZeroInt256(msg.value);\n\n        \n        periodAccrual.add(amount, address(0), 0);\n        aggregateAccrual.add(amount, address(0), 0);\n\n        \n        periodCurrencies.add(address(0), 0);\n        aggregateCurrencies.add(address(0), 0);\n\n        \n        txHistory.addDeposit(amount, address(0), 0);\n\n        \n        emit ReceiveEvent(wallet, amount, address(0), 0);\n    }\n\n    \n    \n    \n    \n    \n    function receiveTokens(string memory balanceType, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        receiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);\n    }\n\n    \n    \n    \n    \n    \n    \n    function receiveTokensTo(address wallet, string memory, int256 amount,\n        address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        require(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [RevenueFund.sol:115]\");\n\n        \n        TransferController controller = transferController(currencyCt, standard);\n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\n            )\n        );\n        require(success, \"Reception by controller failed [RevenueFund.sol:124]\");\n\n        \n        periodAccrual.add(amount, currencyCt, currencyId);\n        aggregateAccrual.add(amount, currencyCt, currencyId);\n\n        \n        periodCurrencies.add(currencyCt, currencyId);\n        aggregateCurrencies.add(currencyCt, currencyId);\n\n        \n        txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        \n        emit ReceiveEvent(wallet, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    function periodAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return periodAccrual.get(currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function aggregateAccrualBalance(address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        return aggregateAccrual.get(currencyCt, currencyId);\n    }\n\n    \n    \n    function periodCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return periodCurrencies.count();\n    }\n\n    \n    \n    \n    \n    function periodCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return periodCurrencies.getByIndices(low, up);\n    }\n\n    \n    \n    function aggregateCurrenciesCount()\n    public\n    view\n    returns (uint256)\n    {\n        return aggregateCurrencies.count();\n    }\n\n    \n    \n    \n    \n    function aggregateCurrenciesByIndices(uint256 low, uint256 up)\n    public\n    view\n    returns (MonetaryTypesLib.Currency[] memory)\n    {\n        return aggregateCurrencies.getByIndices(low, up);\n    }\n\n    \n    \n    function depositsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return txHistory.depositsCount();\n    }\n\n    \n    \n    function deposit(uint index)\n    public\n    view\n    returns (int256 amount, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        return txHistory.deposit(index);\n    }\n\n    \n    \n    function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\n    public\n    onlyOperator\n    {\n        require(\n            ConstantsLib.PARTS_PER() == totalBeneficiaryFraction,\n            \"Total beneficiary fraction out of bounds [RevenueFund.sol:236]\"\n        );\n\n        \n        for (uint256 i = 0; i < currencies.length; i++) {\n            MonetaryTypesLib.Currency memory currency = currencies[i];\n\n            int256 remaining = periodAccrual.get(currency.ct, currency.id);\n\n            if (0 >= remaining)\n                continue;\n\n            for (uint256 j = 0; j < beneficiaries.length; j++) {\n                AccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n                if (beneficiaryFraction(beneficiary) > 0) {\n                    int256 transferable = periodAccrual.get(currency.ct, currency.id)\n                    .mul(beneficiaryFraction(beneficiary))\n                    .div(ConstantsLib.PARTS_PER());\n\n                    if (transferable > remaining)\n                        transferable = remaining;\n\n                    if (transferable > 0) {\n                        \n                        if (currency.ct == address(0))\n                            beneficiary.receiveEthersTo.value(uint256(transferable))(address(0), \"\");\n\n                        \n                        else {\n                            TransferController controller = transferController(currency.ct, \"\");\n                            (bool success,) = address(controller).delegatecall(\n                                abi.encodeWithSelector(\n                                    controller.getApproveSignature(), address(beneficiary), uint256(transferable), currency.ct, currency.id\n                                )\n                            );\n                            require(success, \"Approval by controller failed [RevenueFund.sol:274]\");\n\n                            beneficiary.receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\n                        }\n\n                        remaining = remaining.sub(transferable);\n                    }\n                }\n            }\n\n            \n            periodAccrual.set(remaining, currency.ct, currency.id);\n        }\n\n        \n        for (uint256 j = 0; j < beneficiaries.length; j++) {\n            AccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n            \n            if (0 >= beneficiaryFraction(beneficiary))\n                continue;\n\n            \n            beneficiary.closeAccrualPeriod(currencies);\n        }\n\n        \n        emit CloseAccrualPeriodEvent();\n    }\n}\n\ncontract Upgradable {\n    \n    \n    \n    address public upgradeAgent;\n    bool public upgradesFrozen;\n\n    \n    \n    \n    event SetUpgradeAgentEvent(address upgradeAgent);\n    event FreezeUpgradesEvent();\n\n    \n    \n    \n    \n    \n    function setUpgradeAgent(address _upgradeAgent)\n    public\n    onlyWhenUpgradable\n    {\n        require(address(0) == upgradeAgent, \"Upgrade agent has already been set [Upgradable.sol:37]\");\n\n        \n        upgradeAgent = _upgradeAgent;\n\n        \n        emit SetUpgradeAgentEvent(upgradeAgent);\n    }\n\n    \n    \n    function freezeUpgrades()\n    public\n    onlyWhenUpgrading\n    {\n        \n        upgradesFrozen = true;\n\n        \n        emit FreezeUpgradesEvent();\n    }\n\n    \n    \n    \n    modifier onlyWhenUpgrading() {\n        require(msg.sender == upgradeAgent, \"Caller is not upgrade agent [Upgradable.sol:63]\");\n        require(!upgradesFrozen, \"Upgrades have been frozen [Upgradable.sol:64]\");\n        _;\n    }\n\n    modifier onlyWhenUpgradable() {\n        require(!upgradesFrozen, \"Upgrades have been frozen [Upgradable.sol:69]\");\n        _;\n    }\n}\n\nlibrary SettlementChallengeTypesLib {\n    \n    \n    \n    enum Status {Qualified, Disqualified}\n\n    struct Proposal {\n        address wallet;\n        uint256 nonce;\n        uint256 referenceBlockNumber;\n        uint256 definitionBlockNumber;\n\n        uint256 expirationTime;\n\n        \n        Status status;\n\n        \n        Amounts amounts;\n\n        \n        MonetaryTypesLib.Currency currency;\n\n        \n        Driip challenged;\n\n        \n        bool walletInitiated;\n\n        \n        bool terminated;\n\n        \n        Disqualification disqualification;\n    }\n\n    struct Amounts {\n        \n        int256 cumulativeTransfer;\n\n        \n        int256 stage;\n\n        \n        int256 targetBalance;\n    }\n\n    struct Driip {\n        \n        string kind;\n\n        \n        bytes32 hash;\n    }\n\n    struct Disqualification {\n        \n        address challenger;\n        uint256 nonce;\n        uint256 blockNumber;\n\n        \n        Driip candidate;\n    }\n}\n\ncontract DriipSettlementChallengeState is Ownable, Servable, Configurable, Upgradable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    string constant public INITIATE_PROPOSAL_ACTION = \"initiate_proposal\";\n    string constant public TERMINATE_PROPOSAL_ACTION = \"terminate_proposal\";\n    string constant public REMOVE_PROPOSAL_ACTION = \"remove_proposal\";\n    string constant public DISQUALIFY_PROPOSAL_ACTION = \"disqualify_proposal\";\n    string constant public QUALIFY_PROPOSAL_ACTION = \"qualify_proposal\";\n\n    \n    \n    \n    SettlementChallengeTypesLib.Proposal[] public proposals;\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public proposalIndexByWalletCurrency;\n    mapping(address => mapping(uint256 => mapping(address => mapping(uint256 => uint256)))) public proposalIndexByWalletNonceCurrency;\n\n    \n    \n    \n    event InitiateProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string challengedKind);\n    event TerminateProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string challengedKind);\n    event RemoveProposalEvent(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string challengedKind);\n    event DisqualifyProposalEvent(address challengedWallet, uint256 challengedNonce, int256 cumulativeTransferAmount,\n        int256 stageAmount, int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber,\n        bool walletInitiated, address challengerWallet, uint256 candidateNonce, bytes32 candidateHash,\n        string candidateKind);\n    event QualifyProposalEvent(address challengedWallet, uint256 challengedNonce, int256 cumulativeTransferAmount,\n        int256 stageAmount, int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber,\n        bool walletInitiated, address challengerWallet, uint256 candidateNonce, bytes32 candidateHash,\n        string candidateKind);\n    event UpgradeProposalEvent(SettlementChallengeTypesLib.Proposal proposal);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    \n    function proposalsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return proposals.length;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated,\n        bytes32 challengedHash, string memory challengedKind)\n    public\n    onlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n    {\n        \n        _initiateProposal(\n            wallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\n            currency, blockNumber, walletInitiated, challengedHash, challengedKind\n        );\n\n        \n        emit InitiateProposalEvent(\n            wallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\n            blockNumber, walletInitiated, challengedHash, challengedKind\n        );\n    }\n\n    \n    \n    \n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce)\n    public\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index)\n            return;\n\n        \n        if (clearNonce)\n            proposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n        \n        proposals[index - 1].terminated = true;\n\n        \n        emit TerminateProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n    }\n\n    \n    \n    \n    \n    \n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce,\n        bool walletTerminated)\n    public\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index)\n            return;\n\n        \n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:165]\");\n\n        \n        if (clearNonce)\n            proposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n        \n        proposals[index - 1].terminated = true;\n\n        \n        emit TerminateProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n    }\n\n    \n    \n    \n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index)\n            return;\n\n        \n        emit RemoveProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n\n        \n        _removeProposal(index);\n    }\n\n    \n    \n    \n    \n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\n    public\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index)\n            return;\n\n        \n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:225]\");\n\n        \n        emit RemoveProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n        );\n\n        \n        _removeProposal(index);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\n        uint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\n    public\n    onlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:255]\");\n\n        \n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        proposals[index - 1].disqualification.challenger = challengerWallet;\n        proposals[index - 1].disqualification.nonce = candidateNonce;\n        proposals[index - 1].disqualification.blockNumber = blockNumber;\n        proposals[index - 1].disqualification.candidate.hash = candidateHash;\n        proposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n        \n        emit DisqualifyProposalEvent(\n            challengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\n            currency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            challengerWallet, candidateNonce, candidateHash, candidateKind\n        );\n    }\n\n    \n    \n    \n    function qualifyProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    onlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:284]\");\n\n        \n        emit QualifyProposalEvent(\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n            proposals[index - 1].disqualification.challenger,\n            proposals[index - 1].disqualification.nonce,\n            proposals[index - 1].disqualification.candidate.hash,\n            proposals[index - 1].disqualification.candidate.kind\n        );\n\n        \n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        delete proposals[index - 1].disqualification;\n    }\n\n    \n    \n    \n    \n    \n    \n    function hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        \n        return 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];\n    }\n\n    \n    \n    \n    \n    function hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        \n        return 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n    }\n\n    \n    \n    \n    \n    function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:342]\");\n        return proposals[index - 1].terminated;\n    }\n\n    \n    \n    \n    \n    function hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        \n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:357]\");\n        return block.timestamp >= proposals[index - 1].expirationTime;\n    }\n\n    \n    \n    \n    \n    function proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:371]\");\n        return proposals[index - 1].nonce;\n    }\n\n    \n    \n    \n    \n    function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:385]\");\n        return proposals[index - 1].referenceBlockNumber;\n    }\n\n    \n    \n    \n    \n    function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:399]\");\n        return proposals[index - 1].definitionBlockNumber;\n    }\n\n    \n    \n    \n    \n    function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:413]\");\n        return proposals[index - 1].expirationTime;\n    }\n\n    \n    \n    \n    \n    function proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (SettlementChallengeTypesLib.Status)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:427]\");\n        return proposals[index - 1].status;\n    }\n\n    \n    \n    \n    \n    function proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:441]\");\n        return proposals[index - 1].amounts.cumulativeTransfer;\n    }\n\n    \n    \n    \n    \n    function proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:455]\");\n        return proposals[index - 1].amounts.stage;\n    }\n\n    \n    \n    \n    \n    function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (int256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:469]\");\n        return proposals[index - 1].amounts.targetBalance;\n    }\n\n    \n    \n    \n    \n    function proposalChallengedHash(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bytes32)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:483]\");\n        return proposals[index - 1].challenged.hash;\n    }\n\n    \n    \n    \n    \n    function proposalChallengedKind(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (string memory)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:497]\");\n        return proposals[index - 1].challenged.kind;\n    }\n\n    \n    \n    \n    \n    function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bool)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:511]\");\n        return proposals[index - 1].walletInitiated;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (address)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:525]\");\n        return proposals[index - 1].disqualification.challenger;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:539]\");\n        return proposals[index - 1].disqualification.nonce;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:553]\");\n        return proposals[index - 1].disqualification.blockNumber;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (bytes32)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:567]\");\n        return proposals[index - 1].disqualification.candidate.hash;\n    }\n\n    \n    \n    \n    \n    function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (string memory)\n    {\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:581]\");\n        return proposals[index - 1].disqualification.candidate.kind;\n    }\n\n    \n    \n    function upgradeProposal(SettlementChallengeTypesLib.Proposal memory proposal)\n    public\n    onlyWhenUpgrading\n    {\n        \n        require(\n            0 == proposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id],\n            \"Proposal exists for wallet, nonce and currency [DriipSettlementChallengeState.sol:592]\"\n        );\n\n        \n        proposals.push(proposal);\n\n        \n        uint256 index = proposals.length;\n\n        \n        proposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id] = index;\n        proposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id] = index;\n\n        \n        emit UpgradeProposalEvent(proposal);\n    }\n\n    \n    \n    \n    function _initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency memory currency, uint256 referenceBlockNumber, bool walletInitiated,\n        bytes32 challengedHash, string memory challengedKind)\n    private\n    {\n        \n        require(\n            0 == proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id],\n            \"Existing proposal found for wallet, nonce and currency [DriipSettlementChallengeState.sol:620]\"\n        );\n\n        \n        require(stageAmount.isPositiveInt256(), \"Stage amount not positive [DriipSettlementChallengeState.sol:626]\");\n        require(targetBalanceAmount.isPositiveInt256(), \"Target balance amount not positive [DriipSettlementChallengeState.sol:627]\");\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        \n        if (0 == index) {\n            index = ++(proposals.length);\n            proposalIndexByWalletCurrency[wallet][currency.ct][currency.id] = index;\n        }\n\n        \n        proposals[index - 1].wallet = wallet;\n        proposals[index - 1].nonce = nonce;\n        proposals[index - 1].referenceBlockNumber = referenceBlockNumber;\n        proposals[index - 1].definitionBlockNumber = block.number;\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\n        proposals[index - 1].currency = currency;\n        proposals[index - 1].amounts.cumulativeTransfer = cumulativeTransferAmount;\n        proposals[index - 1].amounts.stage = stageAmount;\n        proposals[index - 1].amounts.targetBalance = targetBalanceAmount;\n        proposals[index - 1].walletInitiated = walletInitiated;\n        proposals[index - 1].terminated = false;\n        proposals[index - 1].challenged.hash = challengedHash;\n        proposals[index - 1].challenged.kind = challengedKind;\n\n        \n        proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id] = index;\n    }\n\n    function _removeProposal(uint256 index)\n    private\n    {\n        \n        proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = 0;\n        proposalIndexByWalletNonceCurrency[proposals[index - 1].wallet][proposals[index - 1].nonce][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = 0;\n        if (index < proposals.length) {\n            proposals[index - 1] = proposals[proposals.length - 1];\n            proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = index;\n            proposalIndexByWalletNonceCurrency[proposals[index - 1].wallet][proposals[index - 1].nonce][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = index;\n        }\n        proposals.length--;\n    }\n}\n\nlibrary Strings {\n\n    \n    function concat(string memory _base, string memory _value)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        assert(_valueBytes.length > 0);\n\n        string memory _tmpValue = new string(_baseBytes.length +\n            _valueBytes.length);\n        bytes memory _newValue = bytes(_tmpValue);\n\n        uint i;\n        uint j;\n\n        for (i = 0; i < _baseBytes.length; i++) {\n            _newValue[j++] = _baseBytes[i];\n        }\n\n        for (i = 0; i < _valueBytes.length; i++) {\n            _newValue[j++] = _valueBytes[i];\n        }\n\n        return string(_newValue);\n    }\n\n    \n    function indexOf(string memory _base, string memory _value)\n        internal\n        pure\n        returns (int) {\n        return _indexOf(_base, _value, 0);\n    }\n\n    \n    function _indexOf(string memory _base, string memory _value, uint _offset)\n        internal\n        pure\n        returns (int) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        assert(_valueBytes.length == 1);\n\n        for (uint i = _offset; i < _baseBytes.length; i++) {\n            if (_baseBytes[i] == _valueBytes[0]) {\n                return int(i);\n            }\n        }\n\n        return -1;\n    }\n\n    \n    function length(string memory _base)\n        internal\n        pure\n        returns (uint) {\n        bytes memory _baseBytes = bytes(_base);\n        return _baseBytes.length;\n    }\n\n    \n    function substring(string memory _base, int _length)\n        internal\n        pure\n        returns (string memory) {\n        return _substring(_base, _length, 0);\n    }\n\n    \n    function _substring(string memory _base, int _length, int _offset)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n\n        assert(uint(_offset + _length) <= _baseBytes.length);\n\n        string memory _tmp = new string(uint(_length));\n        bytes memory _tmpBytes = bytes(_tmp);\n\n        uint j = 0;\n        for (uint i = uint(_offset); i < uint(_offset + _length); i++) {\n            _tmpBytes[j++] = _baseBytes[i];\n        }\n\n        return string(_tmpBytes);\n    }\n\n    \n    function split(string memory _base, string memory _value)\n        internal\n        pure\n        returns (string[] memory splitArr) {\n        bytes memory _baseBytes = bytes(_base);\n\n        uint _offset = 0;\n        uint _splitsCount = 1;\n        while (_offset < _baseBytes.length - 1) {\n            int _limit = _indexOf(_base, _value, _offset);\n            if (_limit == -1)\n                break;\n            else {\n                _splitsCount++;\n                _offset = uint(_limit) + 1;\n            }\n        }\n\n        splitArr = new string[](_splitsCount);\n\n        _offset = 0;\n        _splitsCount = 0;\n        while (_offset < _baseBytes.length - 1) {\n\n            int _limit = _indexOf(_base, _value, _offset);\n            if (_limit == - 1) {\n                _limit = int(_baseBytes.length);\n            }\n\n            string memory _tmp = new string(uint(_limit) - _offset);\n            bytes memory _tmpBytes = bytes(_tmp);\n\n            uint j = 0;\n            for (uint i = _offset; i < uint(_limit); i++) {\n                _tmpBytes[j++] = _baseBytes[i];\n            }\n            _offset = uint(_limit) + 1;\n            splitArr[_splitsCount++] = string(_tmpBytes);\n        }\n        return splitArr;\n    }\n\n    \n    function compareTo(string memory _base, string memory _value)\n        internal\n        pure\n        returns (bool) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        if (_baseBytes.length != _valueBytes.length) {\n            return false;\n        }\n\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            if (_baseBytes[i] != _valueBytes[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \n    function compareToIgnoreCase(string memory _base, string memory _value)\n        internal\n        pure\n        returns (bool) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        if (_baseBytes.length != _valueBytes.length) {\n            return false;\n        }\n\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            if (_baseBytes[i] != _valueBytes[i] &&\n            _upper(_baseBytes[i]) != _upper(_valueBytes[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \n    function upper(string memory _base)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _upper(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    \n    function lower(string memory _base)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _lower(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    \n    function _upper(bytes1 _b1)\n        private\n        pure\n        returns (bytes1) {\n\n        if (_b1 >= 0x61 && _b1 <= 0x7A) {\n            return bytes1(uint8(_b1) - 32);\n        }\n\n        return _b1;\n    }\n\n    \n    function _lower(bytes1 _b1)\n        private\n        pure\n        returns (bytes1) {\n\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\n            return bytes1(uint8(_b1) + 32);\n        }\n\n        return _b1;\n    }\n}\n\ncontract PartnerFund is Ownable, Beneficiary, TransferControllerManageable {\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\n    using TxHistoryLib for TxHistoryLib.TxHistory;\n    using SafeMathIntLib for int256;\n    using Strings for string;\n\n    \n    \n    \n    struct Partner {\n        bytes32 nameHash;\n\n        uint256 fee;\n        address wallet;\n        uint256 index;\n\n        bool operatorCanUpdate;\n        bool partnerCanUpdate;\n\n        FungibleBalanceLib.Balance active;\n        FungibleBalanceLib.Balance staged;\n\n        TxHistoryLib.TxHistory txHistory;\n        FullBalanceHistory[] fullBalanceHistory;\n    }\n\n    struct FullBalanceHistory {\n        uint256 listIndex;\n        int256 balance;\n        uint256 blockNumber;\n    }\n\n    \n    \n    \n    Partner[] private partners;\n\n    mapping(bytes32 => uint256) private _indexByNameHash;\n    mapping(address => uint256) private _indexByWallet;\n\n    \n    \n    \n    event ReceiveEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event RegisterPartnerByNameEvent(string name, uint256 fee, address wallet);\n    event RegisterPartnerByNameHashEvent(bytes32 nameHash, uint256 fee, address wallet);\n    event SetFeeByIndexEvent(uint256 index, uint256 oldFee, uint256 newFee);\n    event SetFeeByNameEvent(string name, uint256 oldFee, uint256 newFee);\n    event SetFeeByNameHashEvent(bytes32 nameHash, uint256 oldFee, uint256 newFee);\n    event SetFeeByWalletEvent(address wallet, uint256 oldFee, uint256 newFee);\n    event SetPartnerWalletByIndexEvent(uint256 index, address oldWallet, address newWallet);\n    event SetPartnerWalletByNameEvent(string name, address oldWallet, address newWallet);\n    event SetPartnerWalletByNameHashEvent(bytes32 nameHash, address oldWallet, address newWallet);\n    event SetPartnerWalletByWalletEvent(address oldWallet, address newWallet);\n    event StageEvent(address from, int256 amount, address currencyCt, uint256 currencyId);\n    event WithdrawEvent(address to, int256 amount, address currencyCt, uint256 currencyId);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    function() external payable {\n        _receiveEthersTo(\n            indexByWallet(msg.sender) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\n        );\n    }\n\n    \n    \n    function receiveEthersTo(address tag, string memory)\n    public\n    payable\n    {\n        _receiveEthersTo(\n            uint256(tag) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\n        );\n    }\n\n    \n    \n    \n    \n    \n    function receiveTokens(string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        _receiveTokensTo(\n            indexByWallet(msg.sender) - 1, amount, currencyCt, currencyId, standard\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    function receiveTokensTo(address tag, string memory, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    public\n    {\n        _receiveTokensTo(\n            uint256(tag) - 1, amount, currencyCt, currencyId, standard\n        );\n    }\n\n    \n    \n    \n    function hashName(string memory name)\n    public\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(name.upper()));\n    }\n\n    \n    \n    \n    \n    function depositByIndices(uint256 partnerIndex, uint256 depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        \n        require(0 < partnerIndex && partnerIndex <= partners.length, \"Some error message when require fails [PartnerFund.sol:160]\");\n\n        return _depositByIndices(partnerIndex - 1, depositIndex);\n    }\n\n    \n    \n    \n    \n    function depositByName(string memory name, uint depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        \n        return _depositByIndices(indexByName(name) - 1, depositIndex);\n    }\n\n    \n    \n    \n    \n    function depositByNameHash(bytes32 nameHash, uint depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        \n        return _depositByIndices(indexByNameHash(nameHash) - 1, depositIndex);\n    }\n\n    \n    \n    \n    \n    function depositByWallet(address wallet, uint depositIndex)\n    public\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        \n        return _depositByIndices(indexByWallet(wallet) - 1, depositIndex);\n    }\n\n    \n    \n    \n    function depositsCountByIndex(uint256 index)\n    public\n    view\n    returns (uint256)\n    {\n        \n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:213]\");\n\n        return _depositsCountByIndex(index - 1);\n    }\n\n    \n    \n    \n    function depositsCountByName(string memory name)\n    public\n    view\n    returns (uint256)\n    {\n        \n        return _depositsCountByIndex(indexByName(name) - 1);\n    }\n\n    \n    \n    \n    function depositsCountByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (uint256)\n    {\n        \n        return _depositsCountByIndex(indexByNameHash(nameHash) - 1);\n    }\n\n    \n    \n    \n    function depositsCountByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        \n        return _depositsCountByIndex(indexByWallet(wallet) - 1);\n    }\n\n    \n    \n    \n    \n    \n    function activeBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:265]\");\n\n        return _activeBalanceByIndex(index - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function activeBalanceByName(string memory name, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        return _activeBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function activeBalanceByNameHash(bytes32 nameHash, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        return _activeBalanceByIndex(indexByNameHash(nameHash) - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function activeBalanceByWallet(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        return _activeBalanceByIndex(indexByWallet(wallet) - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function stagedBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:323]\");\n\n        return _stagedBalanceByIndex(index - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function stagedBalanceByName(string memory name, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        return _stagedBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function stagedBalanceByNameHash(bytes32 nameHash, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        return _stagedBalanceByIndex(indexByNameHash(nameHash) - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function stagedBalanceByWallet(address wallet, address currencyCt, uint256 currencyId)\n    public\n    view\n    returns (int256)\n    {\n        \n        return _stagedBalanceByIndex(indexByWallet(wallet) - 1, currencyCt, currencyId);\n    }\n\n    \n    \n    function partnersCount()\n    public\n    view\n    returns (uint256)\n    {\n        return partners.length;\n    }\n\n    \n    \n    \n    \n    \n    \n    function registerByName(string memory name, uint256 fee, address wallet,\n        bool partnerCanUpdate, bool operatorCanUpdate)\n    public\n    onlyOperator\n    {\n        \n        require(bytes(name).length > 0, \"Some error message when require fails [PartnerFund.sol:392]\");\n\n        \n        bytes32 nameHash = hashName(name);\n\n        \n        _registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\n\n        \n        emit RegisterPartnerByNameEvent(name, fee, wallet);\n    }\n\n    \n    \n    \n    \n    \n    \n    function registerByNameHash(bytes32 nameHash, uint256 fee, address wallet,\n        bool partnerCanUpdate, bool operatorCanUpdate)\n    public\n    onlyOperator\n    {\n        \n        _registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\n\n        \n        emit RegisterPartnerByNameHashEvent(nameHash, fee, wallet);\n    }\n\n    \n    \n    \n    function indexByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = _indexByNameHash[nameHash];\n        require(0 < index, \"Some error message when require fails [PartnerFund.sol:431]\");\n        return index;\n    }\n\n    \n    \n    \n    function indexByName(string memory name)\n    public\n    view\n    returns (uint256)\n    {\n        return indexByNameHash(hashName(name));\n    }\n\n    \n    \n    \n    function indexByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 index = _indexByWallet[wallet];\n        require(0 < index, \"Some error message when require fails [PartnerFund.sol:455]\");\n        return index;\n    }\n\n    \n    \n    \n    function isRegisteredByName(string memory name)\n    public\n    view\n    returns (bool)\n    {\n        return (0 < _indexByNameHash[hashName(name)]);\n    }\n\n    \n    \n    \n    function isRegisteredByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (bool)\n    {\n        return (0 < _indexByNameHash[nameHash]);\n    }\n\n    \n    \n    \n    function isRegisteredByWallet(address wallet)\n    public\n    view\n    returns (bool)\n    {\n        return (0 < _indexByWallet[wallet]);\n    }\n\n    \n    \n    \n    function feeByIndex(uint256 index)\n    public\n    view\n    returns (uint256)\n    {\n        \n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:501]\");\n\n        return _partnerFeeByIndex(index - 1);\n    }\n\n    \n    \n    \n    function feeByName(string memory name)\n    public\n    view\n    returns (uint256)\n    {\n        \n        return _partnerFeeByIndex(indexByName(name) - 1);\n    }\n\n    \n    \n    \n    function feeByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (uint256)\n    {\n        \n        return _partnerFeeByIndex(indexByNameHash(nameHash) - 1);\n    }\n\n    \n    \n    \n    function feeByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        \n        return _partnerFeeByIndex(indexByWallet(wallet) - 1);\n    }\n\n    \n    \n    \n    function setFeeByIndex(uint256 index, uint256 newFee)\n    public\n    {\n        \n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:549]\");\n\n        \n        uint256 oldFee = _setPartnerFeeByIndex(index - 1, newFee);\n\n        \n        emit SetFeeByIndexEvent(index, oldFee, newFee);\n    }\n\n    \n    \n    \n    function setFeeByName(string memory name, uint256 newFee)\n    public\n    {\n        \n        uint256 oldFee = _setPartnerFeeByIndex(indexByName(name) - 1, newFee);\n\n        \n        emit SetFeeByNameEvent(name, oldFee, newFee);\n    }\n\n    \n    \n    \n    function setFeeByNameHash(bytes32 nameHash, uint256 newFee)\n    public\n    {\n        \n        uint256 oldFee = _setPartnerFeeByIndex(indexByNameHash(nameHash) - 1, newFee);\n\n        \n        emit SetFeeByNameHashEvent(nameHash, oldFee, newFee);\n    }\n\n    \n    \n    \n    function setFeeByWallet(address wallet, uint256 newFee)\n    public\n    {\n        \n        uint256 oldFee = _setPartnerFeeByIndex(indexByWallet(wallet) - 1, newFee);\n\n        \n        emit SetFeeByWalletEvent(wallet, oldFee, newFee);\n    }\n\n    \n    \n    \n    function walletByIndex(uint256 index)\n    public\n    view\n    returns (address)\n    {\n        \n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:606]\");\n\n        return partners[index - 1].wallet;\n    }\n\n    \n    \n    \n    function walletByName(string memory name)\n    public\n    view\n    returns (address)\n    {\n        \n        return partners[indexByName(name) - 1].wallet;\n    }\n\n    \n    \n    \n    function walletByNameHash(bytes32 nameHash)\n    public\n    view\n    returns (address)\n    {\n        \n        return partners[indexByNameHash(nameHash) - 1].wallet;\n    }\n\n    \n    \n    \n    function setWalletByIndex(uint256 index, address newWallet)\n    public\n    {\n        \n        require(0 < index && index <= partners.length, \"Some error message when require fails [PartnerFund.sol:642]\");\n\n        \n        address oldWallet = _setPartnerWalletByIndex(index - 1, newWallet);\n\n        \n        emit SetPartnerWalletByIndexEvent(index, oldWallet, newWallet);\n    }\n\n    \n    \n    \n    function setWalletByName(string memory name, address newWallet)\n    public\n    {\n        \n        address oldWallet = _setPartnerWalletByIndex(indexByName(name) - 1, newWallet);\n\n        \n        emit SetPartnerWalletByNameEvent(name, oldWallet, newWallet);\n    }\n\n    \n    \n    \n    function setWalletByNameHash(bytes32 nameHash, address newWallet)\n    public\n    {\n        \n        address oldWallet = _setPartnerWalletByIndex(indexByNameHash(nameHash) - 1, newWallet);\n\n        \n        emit SetPartnerWalletByNameHashEvent(nameHash, oldWallet, newWallet);\n    }\n\n    \n    \n    \n    function setWalletByWallet(address oldWallet, address newWallet)\n    public\n    {\n        \n        _setPartnerWalletByIndex(indexByWallet(oldWallet) - 1, newWallet);\n\n        \n        emit SetPartnerWalletByWalletEvent(oldWallet, newWallet);\n    }\n\n    \n    \n    \n    \n    function stage(int256 amount, address currencyCt, uint256 currencyId)\n    public\n    {\n        \n        uint256 index = indexByWallet(msg.sender);\n\n        \n        require(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:701]\");\n\n        \n        amount = amount.clampMax(partners[index - 1].active.get(currencyCt, currencyId));\n\n        partners[index - 1].active.sub(amount, currencyCt, currencyId);\n        partners[index - 1].staged.add(amount, currencyCt, currencyId);\n\n        partners[index - 1].txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        \n        partners[index - 1].fullBalanceHistory.push(\n            FullBalanceHistory(\n                partners[index - 1].txHistory.depositsCount() - 1,\n                partners[index - 1].active.get(currencyCt, currencyId),\n                block.number\n            )\n        );\n\n        \n        emit StageEvent(msg.sender, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    \n    function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\n    public\n    {\n        \n        uint256 index = indexByWallet(msg.sender);\n\n        \n        require(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:736]\");\n\n        \n        amount = amount.clampMax(partners[index - 1].staged.get(currencyCt, currencyId));\n\n        partners[index - 1].staged.sub(amount, currencyCt, currencyId);\n\n        \n        if (address(0) == currencyCt && 0 == currencyId)\n            msg.sender.transfer(uint256(amount));\n\n        else {\n            TransferController controller = transferController(currencyCt, standard);\n            (bool success,) = address(controller).delegatecall(\n                abi.encodeWithSelector(\n                    controller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n                )\n            );\n            require(success, \"Some error message when require fails [PartnerFund.sol:754]\");\n        }\n\n        \n        emit WithdrawEvent(msg.sender, amount, currencyCt, currencyId);\n    }\n\n    \n    \n    \n    \n    function _receiveEthersTo(uint256 index, int256 amount)\n    private\n    {\n        \n        require(index < partners.length, \"Some error message when require fails [PartnerFund.sol:769]\");\n\n        \n        partners[index].active.add(amount, address(0), 0);\n        partners[index].txHistory.addDeposit(amount, address(0), 0);\n\n        \n        partners[index].fullBalanceHistory.push(\n            FullBalanceHistory(\n                partners[index].txHistory.depositsCount() - 1,\n                partners[index].active.get(address(0), 0),\n                block.number\n            )\n        );\n\n        \n        emit ReceiveEvent(msg.sender, amount, address(0), 0);\n    }\n\n    \n    function _receiveTokensTo(uint256 index, int256 amount, address currencyCt,\n        uint256 currencyId, string memory standard)\n    private\n    {\n        \n        require(index < partners.length, \"Some error message when require fails [PartnerFund.sol:794]\");\n\n        require(amount.isNonZeroPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:796]\");\n\n        \n        TransferController controller = transferController(currencyCt, standard);\n        (bool success,) = address(controller).delegatecall(\n            abi.encodeWithSelector(\n                controller.getReceiveSignature(), msg.sender, this, uint256(amount), currencyCt, currencyId\n            )\n        );\n        require(success, \"Some error message when require fails [PartnerFund.sol:805]\");\n\n        \n        partners[index].active.add(amount, currencyCt, currencyId);\n        partners[index].txHistory.addDeposit(amount, currencyCt, currencyId);\n\n        \n        partners[index].fullBalanceHistory.push(\n            FullBalanceHistory(\n                partners[index].txHistory.depositsCount() - 1,\n                partners[index].active.get(currencyCt, currencyId),\n                block.number\n            )\n        );\n\n        \n        emit ReceiveEvent(msg.sender, amount, currencyCt, currencyId);\n    }\n\n    \n    function _depositByIndices(uint256 partnerIndex, uint256 depositIndex)\n    private\n    view\n    returns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        require(depositIndex < partners[partnerIndex].fullBalanceHistory.length, \"Some error message when require fails [PartnerFund.sol:830]\");\n\n        FullBalanceHistory storage entry = partners[partnerIndex].fullBalanceHistory[depositIndex];\n        (,, currencyCt, currencyId) = partners[partnerIndex].txHistory.deposit(entry.listIndex);\n\n        balance = entry.balance;\n        blockNumber = entry.blockNumber;\n    }\n\n    \n    function _depositsCountByIndex(uint256 index)\n    private\n    view\n    returns (uint256)\n    {\n        return partners[index].fullBalanceHistory.length;\n    }\n\n    \n    function _activeBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256)\n    {\n        return partners[index].active.get(currencyCt, currencyId);\n    }\n\n    \n    function _stagedBalanceByIndex(uint256 index, address currencyCt, uint256 currencyId)\n    private\n    view\n    returns (int256)\n    {\n        return partners[index].staged.get(currencyCt, currencyId);\n    }\n\n    function _registerPartnerByNameHash(bytes32 nameHash, uint256 fee, address wallet,\n        bool partnerCanUpdate, bool operatorCanUpdate)\n    private\n    {\n        \n        require(0 == _indexByNameHash[nameHash], \"Some error message when require fails [PartnerFund.sol:871]\");\n\n        \n        require(partnerCanUpdate || operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:874]\");\n\n        \n        partners.length++;\n\n        \n        uint256 index = partners.length;\n\n        \n        partners[index - 1].nameHash = nameHash;\n        partners[index - 1].fee = fee;\n        partners[index - 1].wallet = wallet;\n        partners[index - 1].partnerCanUpdate = partnerCanUpdate;\n        partners[index - 1].operatorCanUpdate = operatorCanUpdate;\n        partners[index - 1].index = index;\n\n        \n        _indexByNameHash[nameHash] = index;\n\n        \n        _indexByWallet[wallet] = index;\n    }\n\n    \n    function _setPartnerFeeByIndex(uint256 index, uint256 fee)\n    private\n    returns (uint256)\n    {\n        uint256 oldFee = partners[index].fee;\n\n        \n        if (isOperator())\n            require(partners[index].operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:906]\");\n\n        else {\n            \n            require(msg.sender == partners[index].wallet, \"Some error message when require fails [PartnerFund.sol:910]\");\n\n            \n            require(partners[index].partnerCanUpdate, \"Some error message when require fails [PartnerFund.sol:913]\");\n        }\n\n        \n        partners[index].fee = fee;\n\n        return oldFee;\n    }\n\n    \n    function _setPartnerWalletByIndex(uint256 index, address newWallet)\n    private\n    returns (address)\n    {\n        address oldWallet = partners[index].wallet;\n\n        \n        if (oldWallet == address(0))\n            require(isOperator(), \"Some error message when require fails [PartnerFund.sol:931]\");\n\n        \n        else if (isOperator())\n            require(partners[index].operatorCanUpdate, \"Some error message when require fails [PartnerFund.sol:935]\");\n\n        else {\n            \n            require(msg.sender == oldWallet, \"Some error message when require fails [PartnerFund.sol:939]\");\n\n            \n            require(partners[index].partnerCanUpdate, \"Some error message when require fails [PartnerFund.sol:942]\");\n\n            \n            require(partners[index].operatorCanUpdate || newWallet != address(0), \"Some error message when require fails [PartnerFund.sol:945]\");\n        }\n\n        \n        partners[index].wallet = newWallet;\n\n        \n        if (oldWallet != address(0))\n            _indexByWallet[oldWallet] = 0;\n        if (newWallet != address(0))\n            _indexByWallet[newWallet] = index;\n\n        return oldWallet;\n    }\n\n    \n    function _partnerFeeByIndex(uint256 index)\n    private\n    view\n    returns (uint256)\n    {\n        return partners[index].fee;\n    }\n}\n\nlibrary DriipSettlementTypesLib {\n    \n    \n    \n    enum SettlementRole {Origin, Target}\n\n    struct SettlementParty {\n        uint256 nonce;\n        address wallet;\n        uint256 doneBlockNumber;\n    }\n\n    struct Settlement {\n        string settledKind;\n        bytes32 settledHash;\n        SettlementParty origin;\n        SettlementParty target;\n    }\n}\n\ncontract DriipSettlementState is Ownable, Servable, CommunityVotable, Upgradable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    \n    \n    \n    string constant public INIT_SETTLEMENT_ACTION = \"init_settlement\";\n    string constant public COMPLETE_SETTLEMENT_ACTION = \"complete_settlement\";\n    string constant public SET_MAX_NONCE_ACTION = \"set_max_nonce\";\n    string constant public ADD_SETTLED_AMOUNT_ACTION = \"add_settled_amount\";\n    string constant public SET_TOTAL_FEE_ACTION = \"set_total_fee\";\n\n    \n    \n    \n    uint256 public maxDriipNonce;\n\n    DriipSettlementTypesLib.Settlement[] public settlements;\n    mapping(address => uint256[]) public walletSettlementIndices;\n    mapping(address => mapping(uint256 => uint256)) public walletNonceSettlementIndex;\n\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public walletCurrencyMaxNonce;\n\n    mapping(address => mapping(address => mapping(uint256 => mapping(uint256 => int256)))) public walletCurrencyBlockNumberSettledAmount;\n    mapping(address => mapping(address => mapping(uint256 => uint256[]))) public walletCurrencySettledBlockNumbers;\n\n    mapping(address => mapping(address => mapping(address => mapping(address => mapping(uint256 => MonetaryTypesLib.NoncedAmount))))) public totalFeesMap;\n\n    \n    \n    \n    event InitSettlementEvent(DriipSettlementTypesLib.Settlement settlement);\n    event CompleteSettlementPartyEvent(address wallet, uint256 nonce, DriipSettlementTypesLib.SettlementRole settlementRole,\n        uint256 doneBlockNumber);\n    event SetMaxDriipNonceEvent(uint256 maxDriipNonce);\n    event UpdateMaxDriipNonceFromCommunityVoteEvent(uint256 maxDriipNonce);\n    event SetMaxNonceByWalletAndCurrencyEvent(address wallet, MonetaryTypesLib.Currency currency,\n        uint256 maxNonce);\n    event AddSettledAmountEvent(address wallet, int256 amount, MonetaryTypesLib.Currency currency,\n        uint256 blockNumber);\n    event SetTotalFeeEvent(address wallet, Beneficiary beneficiary, address destination,\n        MonetaryTypesLib.Currency currency, MonetaryTypesLib.NoncedAmount totalFee);\n    event UpgradeSettlementEvent(DriipSettlementTypesLib.Settlement settlement);\n    event UpgradeSettledAmountEvent(address wallet, int256 amount, MonetaryTypesLib.Currency currency,\n        uint256 blockNumber);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    function settlementsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return settlements.length;\n    }\n\n    \n    \n    \n    function settlementsCountByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        return walletSettlementIndices[wallet].length;\n    }\n\n    \n    \n    \n    \n    function settlementByWalletAndIndex(address wallet, uint256 index)\n    public\n    view\n    returns (DriipSettlementTypesLib.Settlement memory)\n    {\n        require(walletSettlementIndices[wallet].length > index, \"Index out of bounds [DriipSettlementState.sol:114]\");\n        return settlements[walletSettlementIndices[wallet][index] - 1];\n    }\n\n    \n    \n    \n    \n    function settlementByWalletAndNonce(address wallet, uint256 nonce)\n    public\n    view\n    returns (DriipSettlementTypesLib.Settlement memory)\n    {\n        require(0 != walletNonceSettlementIndex[wallet][nonce], \"No settlement found for wallet and nonce [DriipSettlementState.sol:127]\");\n        return settlements[walletNonceSettlementIndex[wallet][nonce] - 1];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    function initSettlement(string memory settledKind, bytes32 settledHash, address originWallet,\n        uint256 originNonce, address targetWallet, uint256 targetNonce)\n    public\n    onlyEnabledServiceAction(INIT_SETTLEMENT_ACTION)\n    {\n        if (\n            0 == walletNonceSettlementIndex[originWallet][originNonce] &&\n            0 == walletNonceSettlementIndex[targetWallet][targetNonce]\n        ) {\n            \n            settlements.length++;\n\n            \n            uint256 index = settlements.length - 1;\n\n            \n            settlements[index].settledKind = settledKind;\n            settlements[index].settledHash = settledHash;\n            settlements[index].origin.nonce = originNonce;\n            settlements[index].origin.wallet = originWallet;\n            settlements[index].target.nonce = targetNonce;\n            settlements[index].target.wallet = targetWallet;\n\n            \n            emit InitSettlementEvent(settlements[index]);\n\n            \n            index++;\n            walletSettlementIndices[originWallet].push(index);\n            walletSettlementIndices[targetWallet].push(index);\n            walletNonceSettlementIndex[originWallet][originNonce] = index;\n            walletNonceSettlementIndex[targetWallet][targetNonce] = index;\n        }\n    }\n\n    \n    \n    \n    \n    \n    function completeSettlement(address wallet, uint256 nonce,\n        DriipSettlementTypesLib.SettlementRole settlementRole, bool done)\n    public\n    onlyEnabledServiceAction(COMPLETE_SETTLEMENT_ACTION)\n    {\n        \n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        \n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:188]\");\n\n        \n        DriipSettlementTypesLib.SettlementParty storage party =\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\n        settlements[index - 1].origin :\n        settlements[index - 1].target;\n\n        \n        party.doneBlockNumber = done ? block.number : 0;\n\n        \n        emit CompleteSettlementPartyEvent(wallet, nonce, settlementRole, party.doneBlockNumber);\n    }\n\n    \n    \n    \n    \n    function isSettlementPartyDone(address wallet, uint256 nonce)\n    public\n    view\n    returns (bool)\n    {\n        \n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        \n        if (0 == index)\n            return false;\n\n        \n        return (\n        wallet == settlements[index - 1].origin.wallet ?\n        0 != settlements[index - 1].origin.doneBlockNumber :\n        0 != settlements[index - 1].target.doneBlockNumber\n        );\n    }\n\n    \n    \n    \n    \n    \n    \n    function isSettlementPartyDone(address wallet, uint256 nonce,\n        DriipSettlementTypesLib.SettlementRole settlementRole)\n    public\n    view\n    returns (bool)\n    {\n        \n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        \n        if (0 == index)\n            return false;\n\n        \n        DriipSettlementTypesLib.SettlementParty storage settlementParty =\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\n        settlements[index - 1].origin : settlements[index - 1].target;\n\n        \n        require(wallet == settlementParty.wallet, \"Wallet has wrong settlement role [DriipSettlementState.sol:252]\");\n\n        \n        return 0 != settlementParty.doneBlockNumber;\n    }\n\n    \n    \n    \n    \n    function settlementPartyDoneBlockNumber(address wallet, uint256 nonce)\n    public\n    view\n    returns (uint256)\n    {\n        \n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        \n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:271]\");\n\n        \n        return (\n        wallet == settlements[index - 1].origin.wallet ?\n        settlements[index - 1].origin.doneBlockNumber :\n        settlements[index - 1].target.doneBlockNumber\n        );\n    }\n\n    \n    \n    \n    \n    \n    function settlementPartyDoneBlockNumber(address wallet, uint256 nonce,\n        DriipSettlementTypesLib.SettlementRole settlementRole)\n    public\n    view\n    returns (uint256)\n    {\n        \n        uint256 index = walletNonceSettlementIndex[wallet][nonce];\n\n        \n        require(0 != index, \"No settlement found for wallet and nonce [DriipSettlementState.sol:296]\");\n\n        \n        DriipSettlementTypesLib.SettlementParty storage settlementParty =\n        DriipSettlementTypesLib.SettlementRole.Origin == settlementRole ?\n        settlements[index - 1].origin : settlements[index - 1].target;\n\n        \n        require(wallet == settlementParty.wallet, \"Wallet has wrong settlement role [DriipSettlementState.sol:304]\");\n\n        \n        return settlementParty.doneBlockNumber;\n    }\n\n    \n    \n    function setMaxDriipNonce(uint256 _maxDriipNonce)\n    public\n    onlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n    {\n        maxDriipNonce = _maxDriipNonce;\n\n        \n        emit SetMaxDriipNonceEvent(maxDriipNonce);\n    }\n\n    \n    function updateMaxDriipNonceFromCommunityVote()\n    public\n    {\n        uint256 _maxDriipNonce = communityVote.getMaxDriipNonce();\n        if (0 == _maxDriipNonce)\n            return;\n\n        maxDriipNonce = _maxDriipNonce;\n\n        \n        emit UpdateMaxDriipNonceFromCommunityVoteEvent(maxDriipNonce);\n    }\n\n    \n    \n    \n    \n    function maxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (uint256)\n    {\n        return walletCurrencyMaxNonce[wallet][currency.ct][currency.id];\n    }\n\n    \n    \n    \n    \n    function setMaxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency,\n        uint256 maxNonce)\n    public\n    onlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n    {\n        \n        walletCurrencyMaxNonce[wallet][currency.ct][currency.id] = maxNonce;\n\n        \n        emit SetMaxNonceByWalletAndCurrencyEvent(wallet, currency, maxNonce);\n    }\n\n    \n    \n    \n    \n    function settledAmountByBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency,\n        uint256 blockNumber)\n    public\n    view\n    returns (int256)\n    {\n        uint256 settledBlockNumber = _walletSettledBlockNumber(wallet, currency, blockNumber);\n        return walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber];\n    }\n\n    \n    \n    \n    \n    \n    function addSettledAmountByBlockNumber(address wallet, int256 amount, MonetaryTypesLib.Currency memory currency,\n        uint256 blockNumber)\n    public\n    onlyEnabledServiceAction(ADD_SETTLED_AMOUNT_ACTION)\n    {\n        \n        uint256 settledBlockNumber = _walletSettledBlockNumber(wallet, currency, blockNumber);\n\n        \n        walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber] =\n        walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber].add(amount);\n\n        \n        walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].push(block.number);\n\n        \n        emit AddSettledAmountEvent(wallet, amount, currency, blockNumber);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function totalFee(address wallet, Beneficiary beneficiary, address destination,\n        MonetaryTypesLib.Currency memory currency)\n    public\n    view\n    returns (MonetaryTypesLib.NoncedAmount memory)\n    {\n        return totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id];\n    }\n\n    \n    \n    \n    \n    \n    \n    function setTotalFee(address wallet, Beneficiary beneficiary, address destination,\n        MonetaryTypesLib.Currency memory currency, MonetaryTypesLib.NoncedAmount memory _totalFee)\n    public\n    onlyEnabledServiceAction(SET_TOTAL_FEE_ACTION)\n    {\n        \n        totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id] = _totalFee;\n\n        \n        emit SetTotalFeeEvent(wallet, beneficiary, destination, currency, _totalFee);\n    }\n\n    \n    \n    function upgradeSettlement(DriipSettlementTypesLib.Settlement memory settlement)\n    public\n    onlyWhenUpgrading\n    {\n        \n        require(\n            0 == walletNonceSettlementIndex[settlement.origin.wallet][settlement.origin.nonce],\n            \"Settlement exists for origin wallet and nonce [DriipSettlementState.sol:443]\"\n        );\n        require(\n            0 == walletNonceSettlementIndex[settlement.target.wallet][settlement.target.nonce],\n            \"Settlement exists for target wallet and nonce [DriipSettlementState.sol:447]\"\n        );\n\n        \n        settlements.push(settlement);\n\n        \n        uint256 index = settlements.length;\n\n        \n        walletSettlementIndices[settlement.origin.wallet].push(index);\n        walletSettlementIndices[settlement.target.wallet].push(index);\n        walletNonceSettlementIndex[settlement.origin.wallet][settlement.origin.nonce] = index;\n        walletNonceSettlementIndex[settlement.target.wallet][settlement.target.nonce] = index;\n\n        \n        emit UpgradeSettlementEvent(settlement);\n    }\n\n    \n    \n    \n    \n    \n    function upgradeSettledAmount(address wallet, int256 amount, MonetaryTypesLib.Currency memory currency,\n        uint256 blockNumber)\n    public\n    onlyWhenUpgrading\n    {\n        \n        require(0 == walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][blockNumber], \"[DriipSettlementState.sol:479]\");\n\n        \n        walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][blockNumber] = amount;\n\n        \n        walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].push(blockNumber);\n\n        \n        emit UpgradeSettledAmountEvent(wallet, amount, currency, blockNumber);\n    }\n\n    \n    \n    \n    function _walletSettledBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency,\n        uint256 blockNumber)\n    private\n    view\n    returns (uint256)\n    {\n        for (uint256 i = walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].length; i > 0; i--)\n            if (walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id][i - 1] <= blockNumber)\n                return walletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id][i - 1];\n        return 0;\n    }\n}\n\nlibrary BalanceTrackerLib {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n\n    function fungibleActiveRecordByBlockNumber(BalanceTracker self, address wallet,\n        MonetaryTypesLib.Currency memory currency, uint256 _blockNumber)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        \n        (int256 depositedAmount, uint256 depositedBlockNumber) = self.fungibleRecordByBlockNumber(\n            wallet, self.depositedBalanceType(), currency.ct, currency.id, _blockNumber\n        );\n        (int256 settledAmount, uint256 settledBlockNumber) = self.fungibleRecordByBlockNumber(\n            wallet, self.settledBalanceType(), currency.ct, currency.id, _blockNumber\n        );\n\n        \n        amount = depositedAmount.add(settledAmount);\n        blockNumber = depositedBlockNumber.clampMin(settledBlockNumber);\n    }\n\n    function fungibleActiveBalanceAmountByBlockNumber(BalanceTracker self, address wallet,\n        MonetaryTypesLib.Currency memory currency, uint256 blockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        (int256 amount,) = fungibleActiveRecordByBlockNumber(self, wallet, currency, blockNumber);\n        return amount;\n    }\n\n    function fungibleActiveDeltaBalanceAmountByBlockNumbers(BalanceTracker self, address wallet,\n        MonetaryTypesLib.Currency memory currency, uint256 fromBlockNumber, uint256 toBlockNumber)\n    internal\n    view\n    returns (int256)\n    {\n        return fungibleActiveBalanceAmountByBlockNumber(self, wallet, currency, toBlockNumber) -\n        fungibleActiveBalanceAmountByBlockNumber(self, wallet, currency, fromBlockNumber);\n    }\n\n    function fungibleActiveRecord(BalanceTracker self, address wallet,\n        MonetaryTypesLib.Currency memory currency)\n    internal\n    view\n    returns (int256 amount, uint256 blockNumber)\n    {\n        \n        (int256 depositedAmount, uint256 depositedBlockNumber) = self.lastFungibleRecord(\n            wallet, self.depositedBalanceType(), currency.ct, currency.id\n        );\n        (int256 settledAmount, uint256 settledBlockNumber) = self.lastFungibleRecord(\n            wallet, self.settledBalanceType(), currency.ct, currency.id\n        );\n\n        \n        amount = depositedAmount.add(settledAmount);\n        blockNumber = depositedBlockNumber.clampMin(settledBlockNumber);\n    }\n\n    function fungibleActiveBalanceAmount(BalanceTracker self, address wallet, MonetaryTypesLib.Currency memory currency)\n    internal\n    view\n    returns (int256)\n    {\n        return self.get(wallet, self.depositedBalanceType(), currency.ct, currency.id).add(\n            self.get(wallet, self.settledBalanceType(), currency.ct, currency.id)\n        );\n    }\n}\n\ncontract DriipSettlementByPayment is Ownable, Configurable, Validatable, ClientFundable, BalanceTrackable,\nCommunityVotable, FraudChallengable, WalletLockable, PartnerBenefactorable {\n    using SafeMathIntLib for int256;\n    using SafeMathUintLib for uint256;\n    using BalanceTrackerLib for BalanceTracker;\n\n    \n    \n    \n    DriipSettlementChallengeState public driipSettlementChallengeState;\n    DriipSettlementState public driipSettlementState;\n    RevenueFund public revenueFund;\n\n    \n    \n    \n    event SettlePaymentEvent(address wallet, PaymentTypesLib.Payment payment, string standard);\n    event SettlePaymentByProxyEvent(address proxy, address wallet, PaymentTypesLib.Payment payment, string standard);\n    event SetDriipSettlementChallengeStateEvent(DriipSettlementChallengeState oldDriipSettlementChallengeState,\n        DriipSettlementChallengeState newDriipSettlementChallengeState);\n    event SetDriipSettlementStateEvent(DriipSettlementState oldDriipSettlementState,\n        DriipSettlementState newDriipSettlementState);\n    event SetRevenueFundEvent(RevenueFund oldRevenueFund, RevenueFund newRevenueFund);\n    event StageFeesEvent(address wallet, int256 deltaAmount, int256 cumulativeAmount,\n        address currencyCt, uint256 currencyId);\n\n    \n    \n    \n    constructor(address deployer) Ownable(deployer) public {\n    }\n\n    \n    \n    \n    \n    \n    function setDriipSettlementChallengeState(DriipSettlementChallengeState newDriipSettlementChallengeState)\n    public\n    onlyDeployer\n    notNullAddress(address(newDriipSettlementChallengeState))\n    {\n        DriipSettlementChallengeState oldDriipSettlementChallengeState = driipSettlementChallengeState;\n        driipSettlementChallengeState = newDriipSettlementChallengeState;\n        emit SetDriipSettlementChallengeStateEvent(oldDriipSettlementChallengeState, driipSettlementChallengeState);\n    }\n\n    \n    \n    function setDriipSettlementState(DriipSettlementState newDriipSettlementState)\n    public\n    onlyDeployer\n    notNullAddress(address(newDriipSettlementState))\n    {\n        DriipSettlementState oldDriipSettlementState = driipSettlementState;\n        driipSettlementState = newDriipSettlementState;\n        emit SetDriipSettlementStateEvent(oldDriipSettlementState, driipSettlementState);\n    }\n\n    \n    \n    function setRevenueFund(RevenueFund newRevenueFund)\n    public\n    onlyDeployer\n    notNullAddress(address(newRevenueFund))\n    {\n        RevenueFund oldRevenueFund = revenueFund;\n        revenueFund = newRevenueFund;\n        emit SetRevenueFundEvent(oldRevenueFund, revenueFund);\n    }\n\n    \n    function settlementsCount()\n    public\n    view\n    returns (uint256)\n    {\n        return driipSettlementState.settlementsCount();\n    }\n\n    \n    \n    \n    function settlementsCountByWallet(address wallet)\n    public\n    view\n    returns (uint256)\n    {\n        return driipSettlementState.settlementsCountByWallet(wallet);\n    }\n\n    \n    \n    \n    \n    function settlementByWalletAndIndex(address wallet, uint256 index)\n    public\n    view\n    returns (DriipSettlementTypesLib.Settlement memory)\n    {\n        return driipSettlementState.settlementByWalletAndIndex(wallet, index);\n    }\n\n    \n    \n    \n    \n    function settlementByWalletAndNonce(address wallet, uint256 nonce)\n    public\n    view\n    returns (DriipSettlementTypesLib.Settlement memory)\n    {\n        return driipSettlementState.settlementByWalletAndNonce(wallet, nonce);\n    }\n\n    \n    \n    \n    function settlePayment(PaymentTypesLib.Payment memory payment, string memory standard)\n    public\n    {\n        \n        _settlePayment(msg.sender, payment, standard);\n\n        \n        emit SettlePaymentEvent(msg.sender, payment, standard);\n    }\n\n    \n    \n    \n    \n    function settlePaymentByProxy(address wallet, PaymentTypesLib.Payment memory payment, string memory standard)\n    public\n    onlyOperator\n    {\n        \n        _settlePayment(wallet, payment, standard);\n\n        \n        emit SettlePaymentByProxyEvent(msg.sender, wallet, payment, standard);\n    }\n\n    \n    \n    \n    function _settlePayment(address wallet, PaymentTypesLib.Payment memory payment, string memory standard)\n    private\n    onlySealedPayment(payment)\n    onlyPaymentParty(payment, wallet)\n    {\n        require(\n            !fraudChallenge.isFraudulentPaymentHash(payment.seals.operator.hash),\n            \"Payment deemed fraudulent [DriipSettlementByPayment.sol:190]\"\n        );\n        require(\n            !communityVote.isDoubleSpenderWallet(wallet),\n            \"Wallet deemed double spender [DriipSettlementByPayment.sol:194]\"\n        );\n\n        \n        require(!walletLocker.isLocked(wallet), \"Wallet found locked [DriipSettlementByPayment.sol:200]\");\n\n        \n        require(\n            payment.seals.operator.hash == driipSettlementChallengeState.proposalChallengedHash(wallet, payment.currency),\n            \"Payment not challenged [DriipSettlementByPayment.sol:203]\"\n        );\n\n        \n        (DriipSettlementTypesLib.SettlementRole settlementRole, uint256 nonce) = _getSettlementRoleNonce(payment, wallet);\n\n        \n        require(\n            driipSettlementChallengeState.hasProposal(wallet, nonce, payment.currency),\n            \"No proposal found [DriipSettlementByPayment.sol:212]\"\n        );\n\n        \n        require(\n            !driipSettlementChallengeState.hasProposalTerminated(wallet, payment.currency),\n            \"Proposal found terminated [DriipSettlementByPayment.sol:218]\"\n        );\n\n        \n        require(\n            driipSettlementChallengeState.hasProposalExpired(wallet, payment.currency),\n            \"Proposal found not expired [DriipSettlementByPayment.sol:224]\"\n        );\n\n        \n        require(\n            SettlementChallengeTypesLib.Status.Qualified == driipSettlementChallengeState.proposalStatus(wallet, payment.currency),\n            \"Proposal found not qualified [DriipSettlementByPayment.sol:230]\"\n        );\n\n        \n        require(configuration.isOperationalModeNormal(), \"Not normal operational mode [DriipSettlementByPayment.sol:236]\");\n        require(communityVote.isDataAvailable(), \"Data not available [DriipSettlementByPayment.sol:237]\");\n\n        \n        driipSettlementState.initSettlement(\n            PaymentTypesLib.PAYMENT_KIND(), payment.seals.operator.hash,\n            payment.sender.wallet, payment.sender.nonce,\n            payment.recipient.wallet, payment.recipient.nonce\n        );\n\n        \n        require(\n            !driipSettlementState.isSettlementPartyDone(wallet, nonce, settlementRole),\n            \"Settlement party already done [DriipSettlementByPayment.sol:247]\"\n        );\n\n        \n        _settle(wallet, payment, standard, nonce, settlementRole);\n\n        \n        driipSettlementChallengeState.terminateProposal(wallet, payment.currency, false);\n    }\n\n    function _settle(address wallet, PaymentTypesLib.Payment memory payment, string memory standard,\n        uint256 nonce, DriipSettlementTypesLib.SettlementRole settlementRole)\n    private\n    {\n        \n        (int256 correctedCurrentBalanceAmount, int settleAmount, NahmiiTypesLib.OriginFigure[] memory totalFees) =\n        _paymentPartyProperties(payment, wallet);\n\n        \n        uint256 maxNonce = driipSettlementState.maxNonceByWalletAndCurrency(wallet, payment.currency);\n\n        \n        \n        if (maxNonce < nonce) {\n            \n            driipSettlementState.setMaxNonceByWalletAndCurrency(wallet, payment.currency, nonce);\n\n            \n            clientFund.updateSettledBalance(\n                wallet, correctedCurrentBalanceAmount, payment.currency.ct, payment.currency.id, standard, block.number\n            );\n\n            \n            driipSettlementState.addSettledAmountByBlockNumber(wallet, settleAmount, payment.currency, payment.blockNumber);\n\n            \n            clientFund.stage(\n                wallet, driipSettlementChallengeState.proposalStageAmount(wallet, payment.currency),\n                payment.currency.ct, payment.currency.id, standard\n            );\n\n            \n            if (address(0) != address(revenueFund))\n                _stageFees(wallet, totalFees, revenueFund, nonce, standard);\n\n            \n            driipSettlementState.completeSettlement(\n                wallet, nonce, settlementRole, true\n            );\n        }\n    }\n\n    function _getSettlementRoleNonce(PaymentTypesLib.Payment memory payment, address wallet)\n    private\n    view\n    returns (DriipSettlementTypesLib.SettlementRole settlementRole, uint256 nonce)\n    {\n        if (validator.isPaymentSender(payment, wallet)) {\n            settlementRole = DriipSettlementTypesLib.SettlementRole.Origin;\n            nonce = payment.sender.nonce;\n        } else {\n            settlementRole = DriipSettlementTypesLib.SettlementRole.Target;\n            nonce = payment.recipient.nonce;\n        }\n    }\n\n    function _paymentPartyProperties(PaymentTypesLib.Payment memory payment,\n        address wallet)\n    private\n    view\n    returns (int256 correctedPaymentBalanceAmount, int settleAmount, NahmiiTypesLib.OriginFigure[] memory totalFees)\n    {\n        if (validator.isPaymentSender(payment, wallet)) {\n            correctedPaymentBalanceAmount = payment.sender.balances.current;\n            totalFees = payment.sender.fees.total;\n        } else {\n            correctedPaymentBalanceAmount = payment.recipient.balances.current;\n            totalFees = payment.recipient.fees.total;\n        }\n\n        \n        int256 deltaActiveBalanceAmount = balanceTracker.fungibleActiveDeltaBalanceAmountByBlockNumbers(\n            wallet, payment.currency, payment.blockNumber, block.number\n        );\n\n        \n        int256 deltaSettledBalanceAmount = driipSettlementState.settledAmountByBlockNumber(\n            wallet, payment.currency, payment.blockNumber\n        );\n\n        \n        settleAmount = correctedPaymentBalanceAmount.sub(\n            balanceTracker.fungibleActiveBalanceAmountByBlockNumber(\n                wallet, payment.currency, payment.blockNumber\n            )\n        ).sub(deltaSettledBalanceAmount);\n\n        \n        correctedPaymentBalanceAmount = correctedPaymentBalanceAmount\n        .add(deltaActiveBalanceAmount)\n        .sub(deltaSettledBalanceAmount);\n    }\n\n    function _stageFees(address wallet, NahmiiTypesLib.OriginFigure[] memory fees,\n        Beneficiary protocolBeneficiary, uint256 nonce, string memory standard)\n    private\n    {\n        \n        for (uint256 i = 0; i < fees.length; i++) {\n            \n            Beneficiary beneficiary;\n            if (0 == fees[i].originId)\n                beneficiary = protocolBeneficiary;\n            else if (\n                0 < partnerBenefactor.registeredBeneficiariesCount() &&\n                fees[i].originId <= partnerBenefactor.registeredBeneficiariesCount()\n            )\n                beneficiary = partnerBenefactor.beneficiaries(fees[i].originId.sub(1));\n\n            \n            if (address(0) == address(beneficiary))\n                continue;\n\n            \n            address destination = address(fees[i].originId);\n\n            \n            if (driipSettlementState.totalFee(wallet, beneficiary, destination, fees[i].figure.currency).nonce < nonce) {\n                \n                int256 deltaAmount = fees[i].figure.amount.sub(driipSettlementState.totalFee(wallet, beneficiary, destination, fees[i].figure.currency).amount);\n\n                \n                if (deltaAmount.isNonZeroPositiveInt256()) {\n                    \n                    driipSettlementState.setTotalFee(wallet, beneficiary, destination, fees[i].figure.currency, MonetaryTypesLib.NoncedAmount(nonce, fees[i].figure.amount));\n\n                    \n                    clientFund.transferToBeneficiary(\n                        wallet, beneficiary, deltaAmount, fees[i].figure.currency.ct, fees[i].figure.currency.id, standard\n                    );\n\n                    \n                    emit StageFeesEvent(\n                        wallet, deltaAmount, fees[i].figure.amount, fees[i].figure.currency.ct, fees[i].figure.currency.id\n                    );\n                }\n            }\n        }\n    }\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"contract FraudChallenge\",\"name\":\"newFraudChallenge\",\"type\":\"address\"}],\"name\":\"setFraudChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Validator\",\"name\":\"newValidator\",\"type\":\"address\"}],\"name\":\"setValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceTracker\",\"outputs\":[{\"internalType\":\"contract BalanceTracker\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletLockerFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"driipSettlementState\",\"outputs\":[{\"internalType\":\"contract DriipSettlementState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract DriipSettlementChallengeState\",\"name\":\"newDriipSettlementChallengeState\",\"type\":\"address\"}],\"name\":\"setDriipSettlementChallengeState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructionDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validator\",\"outputs\":[{\"internalType\":\"contract Validator\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fraudChallenge\",\"outputs\":[{\"internalType\":\"contract FraudChallenge\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceTrackerFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract DriipSettlementState\",\"name\":\"newDriipSettlementState\",\"type\":\"address\"}],\"name\":\"setDriipSettlementState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destructor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"driipSettlementChallengeState\",\"outputs\":[{\"internalType\":\"contract DriipSettlementChallengeState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract PartnerBenefactor\",\"name\":\"newPartnerBenefactor\",\"type\":\"address\"}],\"name\":\"setPartnerBenefactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract BalanceTracker\",\"name\":\"newBalanceTracker\",\"type\":\"address\"}],\"name\":\"setBalanceTracker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeWalletLocker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Configuration\",\"name\":\"newConfiguration\",\"type\":\"address\"}],\"name\":\"setConfiguration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeCommunityVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"configuration\",\"outputs\":[{\"internalType\":\"contract Configuration\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract WalletLocker\",\"name\":\"newWalletLocker\",\"type\":\"address\"}],\"name\":\"setWalletLocker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partnerBenefactor\",\"outputs\":[{\"internalType\":\"contract PartnerBenefactor\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settlementsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityVoteFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"revenueFund\",\"outputs\":[{\"internalType\":\"contract RevenueFund\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"single\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.SingleFigureTotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.PaymentSenderParty\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.TotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"}],\"internalType\":\"struct PaymentTypesLib.PaymentRecipientParty\",\"name\":\"recipient\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"single\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"total\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.SingleTotalInt256\",\"name\":\"transfers\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"wallet\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"operator\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.WalletOperatorSeal\",\"name\":\"seals\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.Operator\",\"name\":\"operator\",\"type\":\"tuple\"}],\"internalType\":\"struct PaymentTypesLib.Payment\",\"name\":\"payment\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"standard\",\"type\":\"string\"}],\"name\":\"settlePaymentByProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeBalanceTracker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ClientFund\",\"name\":\"newClientFund\",\"type\":\"address\"}],\"name\":\"setClientFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityVote\",\"outputs\":[{\"internalType\":\"contract CommunityVote\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"settlementByWalletAndIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"settledKind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"target\",\"type\":\"tuple\"}],\"internalType\":\"struct DriipSettlementTypesLib.Settlement\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"settlementByWalletAndNonce\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"settledKind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"settledHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"origin\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"doneBlockNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct DriipSettlementTypesLib.SettlementParty\",\"name\":\"target\",\"type\":\"tuple\"}],\"internalType\":\"struct DriipSettlementTypesLib.Settlement\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"single\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.SingleFigureTotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.PaymentSenderParty\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.TotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"}],\"internalType\":\"struct PaymentTypesLib.PaymentRecipientParty\",\"name\":\"recipient\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"single\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"total\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.SingleTotalInt256\",\"name\":\"transfers\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"wallet\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"operator\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.WalletOperatorSeal\",\"name\":\"seals\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.Operator\",\"name\":\"operator\",\"type\":\"tuple\"}],\"internalType\":\"struct PaymentTypesLib.Payment\",\"name\":\"payment\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"standard\",\"type\":\"string\"}],\"name\":\"settlePayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"clientFund\",\"outputs\":[{\"internalType\":\"contract ClientFund\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract CommunityVote\",\"name\":\"newCommunityVote\",\"type\":\"address\"}],\"name\":\"setCommunityVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletLocker\",\"outputs\":[{\"internalType\":\"contract WalletLocker\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract RevenueFund\",\"name\":\"newRevenueFund\",\"type\":\"address\"}],\"name\":\"setRevenueFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"settlementsCountByWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"single\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.SingleFigureTotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.PaymentSenderParty\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.TotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"}],\"internalType\":\"struct PaymentTypesLib.PaymentRecipientParty\",\"name\":\"recipient\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"single\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"total\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.SingleTotalInt256\",\"name\":\"transfers\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"wallet\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"operator\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.WalletOperatorSeal\",\"name\":\"seals\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.Operator\",\"name\":\"operator\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct PaymentTypesLib.Payment\",\"name\":\"payment\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"standard\",\"type\":\"string\"}],\"name\":\"SettlePaymentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"single\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.SingleFigureTotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.PaymentSenderParty\",\"name\":\"sender\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"previous\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.CurrentPreviousInt256\",\"name\":\"balances\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"originId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"internalType\":\"struct MonetaryTypesLib.Figure\",\"name\":\"figure\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.OriginFigure[]\",\"name\":\"total\",\"type\":\"tuple[]\"}],\"internalType\":\"struct NahmiiTypesLib.TotalOriginFigures\",\"name\":\"fees\",\"type\":\"tuple\"}],\"internalType\":\"struct PaymentTypesLib.PaymentRecipientParty\",\"name\":\"recipient\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"single\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"total\",\"type\":\"int256\"}],\"internalType\":\"struct NahmiiTypesLib.SingleTotalInt256\",\"name\":\"transfers\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"wallet\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct NahmiiTypesLib.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.Seal\",\"name\":\"operator\",\"type\":\"tuple\"}],\"internalType\":\"struct NahmiiTypesLib.WalletOperatorSeal\",\"name\":\"seals\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"internalType\":\"struct PaymentTypesLib.Operator\",\"name\":\"operator\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct PaymentTypesLib.Payment\",\"name\":\"payment\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"standard\",\"type\":\"string\"}],\"name\":\"SettlePaymentByProxyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract DriipSettlementChallengeState\",\"name\":\"oldDriipSettlementChallengeState\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract DriipSettlementChallengeState\",\"name\":\"newDriipSettlementChallengeState\",\"type\":\"address\"}],\"name\":\"SetDriipSettlementChallengeStateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract DriipSettlementState\",\"name\":\"oldDriipSettlementState\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract DriipSettlementState\",\"name\":\"newDriipSettlementState\",\"type\":\"address\"}],\"name\":\"SetDriipSettlementStateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract RevenueFund\",\"name\":\"oldRevenueFund\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract RevenueFund\",\"name\":\"newRevenueFund\",\"type\":\"address\"}],\"name\":\"SetRevenueFundEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"deltaAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"cumulativeAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currencyCt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"StageFeesEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract PartnerBenefactor\",\"name\":\"oldPartnerBenefactor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract PartnerBenefactor\",\"name\":\"newPartnerBenefactor\",\"type\":\"address\"}],\"name\":\"SetPartnerBenefactorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract WalletLocker\",\"name\":\"oldWalletLocker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract WalletLocker\",\"name\":\"newWalletLocker\",\"type\":\"address\"}],\"name\":\"SetWalletLockerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeWalletLockerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract FraudChallenge\",\"name\":\"oldFraudChallenge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract FraudChallenge\",\"name\":\"newFraudChallenge\",\"type\":\"address\"}],\"name\":\"SetFraudChallengeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract CommunityVote\",\"name\":\"oldCommunityVote\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract CommunityVote\",\"name\":\"newCommunityVote\",\"type\":\"address\"}],\"name\":\"SetCommunityVoteEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeCommunityVoteEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract BalanceTracker\",\"name\":\"oldBalanceTracker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract BalanceTracker\",\"name\":\"newBalanceTracker\",\"type\":\"address\"}],\"name\":\"SetBalanceTrackerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeBalanceTrackerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ClientFund\",\"name\":\"oldClientFund\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract ClientFund\",\"name\":\"newClientFund\",\"type\":\"address\"}],\"name\":\"SetClientFundEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract Validator\",\"name\":\"oldValidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract Validator\",\"name\":\"newValidator\",\"type\":\"address\"}],\"name\":\"SetValidatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract Configuration\",\"name\":\"oldConfiguration\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract Configuration\",\"name\":\"newConfiguration\",\"type\":\"address\"}],\"name\":\"SetConfigurationEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDeployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"SetDeployerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"SetOperatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SelfDestructionDisabledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TriggerSelfDestructionEvent\",\"type\":\"event\"}]","ContractName":"DriipSettlementByPayment","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000f05179bac3d1fbef58a2fcd7ad0f769840027cc6","Library":"PaymentTypesLib:b99f3f4aacb6e1197a623919103b99f4b41aaef0;SafeMathIntLib:2fcb98529d58669e229c453de4b4705bb6b2d414;SafeMathUintLib:0ff948c236c8d4dfcd0168bf243314c8ff8ec967","SwarmSource":"bzzr://24448d33b6dd20e2fca9b1c67e91baa5019c153e77804bf494e2ddeabfed11b3"}]}