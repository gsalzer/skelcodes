{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.6 <0.6.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ERC165Interface\r\n/// @dev https://eips.ethereum.org/EIPS/eip-165\r\ninterface ERC165Interface {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceId The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///      uses less than 30,000 gas.\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// We use a contract and multiple inheritance to expose this constant.\r\n// It's the best that Solidity offers at the moment.\r\ncontract DuelResolverInterfaceId {\r\n    /// @notice The erc165 interface ID\r\n    bytes4 internal constant _INTERFACE_ID_DUELRESOLVER = 0x41fc4f1e;\r\n}\r\n\r\n/// @notice An interface for contracts that resolve duels between Cheeze Wizards. Abstracting this out\r\n///         into its own interface and instance allows for different tournaments to use\r\n///         different duel mechanics while keeping the core tournament logic unchanged.\r\ncontract DuelResolverInterface is DuelResolverInterfaceId, ERC165Interface {\r\n    /// @notice Indicates if the given move set is a valid input for this duel resolver.\r\n    ///         It's important that this method is called before a move set is committed to\r\n    ///         because resolveDuel() will abort if it the moves are invalid, making it\r\n    ///         impossible to resolve the duel.\r\n    function isValidMoveSet(bytes32 moveSet) public pure returns(bool);\r\n\r\n    /// @notice Indicates that a particular affinity is a valid input for this duel resolver.\r\n    ///         Should be called before a Wizard is entered into a tournament. As a rule, Wizard\r\n    ///         Affinities don't change, so there's not point in checking for each duel.\r\n    ///\r\n    /// @dev    This method should _only_ return false for affinities that are\r\n    ///         known to cause problems with your duel resolver. If your resolveDuel() function\r\n    ///         can safely work with any affinity value (even if it just ignores the values that\r\n    ///         it doesn't know about), it should return true.\r\n    function isValidAffinity(uint256 affinity) external pure returns(bool);\r\n\r\n    /// @notice Resolves the duel between two Cheeze Wizards given their chosen move sets, their\r\n    ///         powers, and each Wizard's affinity. It is the responsibility of the Tournament contract\r\n    ///         to ensure that ALL Wizards in a Tournament have an affinity value that is compatible with\r\n    ///         the logic of this DuelResolver. It must also ensure that both move sets are valid before\r\n    ///         those move sets are locked in, otherwise the duel can never be resolved!\r\n    ///\r\n    ///         Returns the amount of power to be transferred from the first Wizard to the second Wizard\r\n    ///         (which will be a negative number if the second Wizard wins the duel), zero in the case of\r\n    ///         a tie.\r\n    /// @param moveSet1 The move set for the first Wizard. The interpretation and therefore valid\r\n    ///                 values for this are determined by the individual duel resolver.\r\n    /// @param moveSet2 The move set for the second Wizard.\r\n    function resolveDuel(\r\n        bytes32 moveSet1,\r\n        bytes32 moveSet2,\r\n        uint256 power1,\r\n        uint256 power2,\r\n        uint256 affinity1,\r\n        uint256 affinity2)\r\n        public pure returns(int256);\r\n}\r\n\r\n\r\n\r\ncontract ThreeAffinityDuelResolver is DuelResolverInterface {\r\n    /// @dev A bitmask that filters all but the bits that are significant as part of a valid move set for this\r\n    /// duel resolver.\r\n    bytes32 public constant MOVE_MASK = 0x0303030303000000000000000000000000000000000000000000000000000000;\r\n\r\n    /// @dev The moves come in from the front end as 2, 3, and 4; the logic below is simpler if the valid\r\n    /// moves are 0, 1, 2. Thus, we subtract 2 from each value to put things in the range that works well for us.\r\n    /// See WizardConstants for the element values, to understand where 2, 3 and 4 come from.\r\n    uint256 public constant MOVE_DELTA = 0x0202020202000000000000000000000000000000000000000000000000000000;\r\n\r\n    /// @dev The relative weight applied to each round in the duel. We ramp up the weight as the duel progresses\r\n    /// to make the later rounds more impactful, and to minimize the probability of a dead tie (which is super\r\n    /// boring!)\r\n    uint256 public constant WEIGHT_SUM = 78 + 79 + 81 + 86 + 100;\r\n\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceId The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///      uses less than 30,000 gas.\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return\r\n            interfaceId == this.supportsInterface.selector || // ERC165\r\n            interfaceId == _INTERFACE_ID_DUELRESOLVER; // DuelResolverInterface\r\n    }\r\n\r\n    /// @notice Checks to see that the given move set is valid for the RPS game. Valid format is 5 set bytes followed by\r\n    /// 27 zero bytes.  Each set byte can be 2, 3, or 4. All other values are rejected as invalid.\r\n    /// @param moveSet the moveset to be validated\r\n    function isValidMoveSet(bytes32 moveSet) public pure returns(bool) { // solium-disable-line security/no-assign-params\r\n        // Map the input values 2, 3, 4 onto 0, 1, 2.\r\n        moveSet = bytes32(uint256(moveSet) - MOVE_DELTA);\r\n\r\n        // Fails if any bit is set outside the allowed mask\r\n        if (moveSet != (moveSet & MOVE_MASK)) {\r\n            return false;\r\n        }\r\n\r\n        // The previous line ensures that all values are 0, 1, 2, or 3, but\r\n        // 3 isn’t actually valid. The following check ensures that no two\r\n        // adjacent bits are set, which excludes any threes.\r\n        if ((moveSet & (moveSet << 1)) != bytes32(0)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Any affinity value is acceptable with this resolver, we just safely ignore any affinities\r\n    /// that don't match Fire, Air, or Water.\r\n    function isValidAffinity(uint256) public pure returns(bool) {\r\n        return true;\r\n    }\r\n\r\n    function resolveDuel(\r\n        bytes32 moveSet1,\r\n        bytes32 moveSet2,\r\n        uint256 power1,\r\n        uint256 power2,\r\n        uint256 affinity1,\r\n        uint256 affinity2)\r\n        public pure returns(int256 power)\r\n    {\r\n        require(isValidMoveSet(moveSet1) && isValidMoveSet(moveSet2), \"Invalid moveset\");\r\n\r\n        int256 score = _duelScore(moveSet1, moveSet2, affinity1, affinity2);\r\n        power = _powerTransfer(score, power1, power2);\r\n    }\r\n\r\n    /// @notice Calculate the score for a duel. A positive score means the first wizard\r\n    ///         won the match, a negative score means the second wizard won, and zero\r\n    ///         means they tied (boooooring).\r\n    /// @dev A NOTE ON VARIABLE NAMING: Throughout this file, you will find variables that end with\r\n    /// Qn, where n is 6 or 10. This is used to indicate that these are fixed point fractional\r\n    /// values, with a denominator of 64 (2^6) or 1024 (2^10). Wikipedia has a decent description\r\n    /// of fixed-point arithmetic if you are unfamiliar (https://en.wikipedia.org/wiki/Fixed-point_arithmetic)\r\n    // solium-disable-next-line security/no-assign-params\r\n    function _duelScore(bytes32 moveSet1, bytes32 moveSet2, uint256 affinity1, uint256 affinity2) internal pure returns (int256 score) {\r\n        // Although these values are essentially constants, we have to keep them\r\n        // inside the function for it to be pure.\r\n        int256[5] memory weights = [int256(78), int256(79), int256(81), int256(86), int256(100)];\r\n\r\n        // Map the input values 2, 3, 4 onto 0, 1, 2 to make the calculations easier.\r\n        moveSet1 = bytes32(uint256(moveSet1) - MOVE_DELTA);\r\n        moveSet2 = bytes32(uint256(moveSet2) - MOVE_DELTA);\r\n        affinity1 -= 2;\r\n        affinity2 -= 2;\r\n\r\n        for (uint256 i = 0; i < 5; i++) {\r\n            // So this bit of casting is a bit weird. Subscripting a bytes32 value gives you a byte object,\r\n            // which seems like something that could be cast into an integer. But the Solidity docs point out\r\n            // that \"byte\" is actually just an alias for bytes1, which is more like an array type. What Solidity\r\n            // does allow is a cast between a bytesX object and an integer of the same size, so we have to cast\r\n            // to an 8-bit integer before we are allowed to cast to a full word. ¯\\_(ツ)_/¯\r\n            int256 move1 = int256(uint8(moveSet1[i]));\r\n            int256 move2 = int256(uint8(moveSet2[i]));\r\n            int256 diff = move1 - move2;\r\n\r\n            if (diff == 0) {\r\n                continue;\r\n            }\r\n\r\n            // Results in 1 if p1 beats p2, -1 if p2 beats p1\r\n            // 1 (water) beats 0 (fire) = (1)  | 0 (fire) loses to 1 (water) = (-1)\r\n            // 2 (wind) beats 1 (water) = (1)  | 1 (water) loses to 2 (wind) = (-1)\r\n            // 0 (fire) beats 2 (wind)  = (-2) | 2 (wind) loses to 0 (fire)  = (2)\r\n            if (diff*diff == 4) {\r\n                diff = -(diff >> 1);\r\n            }\r\n\r\n            // Switch to a fixed-point math with a numerator of 100\r\n            diff *= 100;\r\n\r\n            // The result is 30% larger if the a wizard is playing their affinity\r\n            // This effect can compound!\r\n            if (move1 == int256(affinity1)) {\r\n                diff = diff * 130 / 100;\r\n            }\r\n\r\n            if (move2 == int256(affinity2)) {\r\n                diff = diff * 130 / 100;\r\n            }\r\n\r\n            score += diff * weights[i];\r\n        }\r\n\r\n        score /= 100;\r\n    }\r\n\r\n    /// @dev Returns the amount of power to be transferred from the first wizard to the second wizard. The value\r\n    /// is negative if power is actually transferred from second to first.\r\n    /// @param score The result of the RPS minigame, a positive score means the first wizard\r\n    /// won the match, a negative score means the second wizard won.\r\n    // solium-disable-next-line security/no-assign-params\r\n    function _powerTransfer(int256 score, uint256 power1, uint256 power2) private pure returns(int256) {\r\n        // if the score is negative, switch the positions of the wizards so that the rest of the\r\n        // logic in this function only has to handle the case where the first wizard is the winner,\r\n        // and the power transfer is positive. We do this before verifying the inputs so they\r\n        // are not verified twice.\r\n        if (score < 0) {\r\n            return -_powerTransfer(-score, power2, power1);\r\n        }\r\n\r\n        // Cap the power of each player so the arithmetic cannot possibly overflow.\r\n        require((power1 < (1<<245)) && power2 < (1<<245), \"Invalid power value\");\r\n\r\n        // Wizard power values must be strictly positive or something has gone very wrong.\r\n        require(power1 > 0 && power2 > 0, \"Invalid power value\");\r\n\r\n        if (score == 0) {\r\n            // Handle the simple case of a tie first\r\n            return 0;\r\n        }\r\n\r\n        // From here on out in the function, we can assume that the first wizard is the winner, and the\r\n        // power transfer will be > 0.\r\n\r\n        // Convert the score into a number 0-1\r\n        uint256 normalizedScoreQ10 = 1024 * uint256(score) / WEIGHT_SUM;\r\n\r\n        // Because elemental wizards get a bonus (or penalty) when using their affinity spells, there is\r\n        // a chance that the total score for an Elemental Wizard will exceed 100%. We cap it at 100%...\r\n        if (normalizedScoreQ10 > 1024) {\r\n            normalizedScoreQ10 = 1024;\r\n        }\r\n\r\n        // The base transfer ratio is the square root of the normalized score. We use our fakePow\r\n        // function to get an approximation of the square root. x^(1/2) == sqrt(x)\r\n        uint256 baseTransferRatioQ10 = _fakePowQ10(normalizedScoreQ10, 1024 * 1/2);\r\n\r\n        // The base transfer ratio (BTR) is now, more or less, the inverse of the linearized probability\r\n        // of the outcome. By \"inverse probability\", we mean the BTR will be small if the outcome was\r\n        // quite likely (winning by a little), and large if the outcome was unlikely (winning by a lot).\r\n        // By \"linearized\" we mean that if the outcome was twice as unlikely, the BTR will be doubled.\r\n        // (Please don't ignore the phrase \"more or less\" here! The true probability distribution depends\r\n        // on the wizard alignments and is close to a gaussian density curve. Approximating this curve\r\n        // using a parabola makes it feasible to compute on-chain, and has an error term we can live with...)\r\n        //\r\n        // However, this BTR computed above is only appropriate in a \"fair fight\"; that is, when the\r\n        // wizards have equal power. When one wizard has more power than the other, we have to do something\r\n        // a bit different!\r\n        //\r\n        // The goal here is to keep the fight fair (in that neither the stronger nor weaker wizard has\r\n        // a systemic advantage), but to have as much power as possible to be at stake for both wizards. This\r\n        // seems like a paradox! If we're playing a symmetric game akin to RPS, and each player has the same\r\n        // probability distribution for the outcomes, how can keep the match fair while having one player have\r\n        // more value at risk?\r\n        //\r\n        // The answer is to \"bend\" the odds so that small wins (which are much more common) favour the stronger\r\n        // wizard, since large wins will favour the weaker wizard. The math below is more magic than science (appropriate\r\n        // for wizards, I suppose!), but has the impact that -- even though the stronger wizards has \"more to\r\n        // lose\" -- the fight is still balanced. Most of the time, the winning margin will be small, and stronger\r\n        // wizard will get a bigger reward than the weaker wizard would get from winning with the same margin.\r\n        // BUT, if they win by a large enough margin, the weak wizard can drain a wizard even 7 times more powerful!\r\n        //\r\n        // We do cap the \"at risk\" power of the stronger wizard to 7x the weaker wizard, otherwise the\r\n        // probability curves get WAAAAY out of whack (basically, the battle quickly devolves into an \"all or\r\n        // nothing\" exchange with next to zero odds of winning anything for the weaker wizard).\r\n\r\n        if (power2 > power1 * 7) {\r\n            power2 = power1 * 7;\r\n        } else if (power1 > power2 * 7) {\r\n            power1 = power2 * 7;\r\n        }\r\n\r\n        // Use our power function to bend the curve to something very close to a zero EV for each player.\r\n        uint256 transferRatioQ10 = _fakePowQ10(baseTransferRatioQ10, 1024 * power2 / power1);\r\n\r\n        // Return the actual power transferred, which is determined as a fraction of the loser's power\r\n        // in the preceding math.\r\n        return int256((power2 * transferRatioQ10) >> 10);\r\n    }\r\n\r\n    /// @dev A function that approximates x^y, where x and y are fixed point values with a denominator\r\n    /// of 1024 (10 bits). x must be in the range 0-1 (0-1024 as an int) and y can be any\r\n    /// value > 1/128 (>8 as an int). For efficiency, y values are rounded to the nearest 1/64th\r\n    /// (which seemed in our testing to be the sweet spot between accuracy and efficiency).\r\n    ///\r\n    /// This function will produce wholly accurate results for all integer powers (i.e.\r\n    /// when y is a multiple of 1024 when viewed as an int), and will produce reasonable results\r\n    /// when y has a fractional component. The error term on this approximation isn't tiny, but\r\n    /// over the range 0-1 the errors tend to cancel out, which means the integral of the approximation\r\n    /// is VERY close to the integral of the real power function. This is critical, because we use\r\n    /// this approximation for determining the power transfer after a duel. This approximation can\r\n    /// result in errors, but systemically - across a large number of fights - those errors will\r\n    /// cancel out and result in a system very close to the expected equilibrium.\r\n    ///\r\n    /// tl;dr We fake the power function in a way that means that any error the approximation introduces\r\n    /// is just as likely to help you as hurt you, while saving a butt-ton of gas.\r\n    function _fakePowQ10(uint256 xQ10, uint256 yQ10) private pure returns(uint256) {\r\n\r\n        // Round the y value to the nearest 1/64th, while also converting from\r\n        // a denominator of 1024 to a denominator of 64.\r\n        // Apologies for how unclear this is, but it makes for tighter code!\r\n        // A more explicit version would look like this:\r\n        //    float y = float(xQ10) / 1024.0;\r\n        //    y = floor(y + 0.5);\r\n        //    int xQ6 = int(y * 64);\r\n        uint256 yQ6 = (yQ10 + 8) >> 4;\r\n\r\n        // Call the recursive internal function to do that actual math\r\n        return _fakePowInternal(xQ10, yQ6, 64, 5);\r\n    }\r\n\r\n\r\n    /// @dev An internal helper function for the fakePow function. X must be a value between 0-1\r\n    /// expressed as a fixed point value with a denominator of 1024. numerator and denominator\r\n    /// can be any integers. Returns the value x^(n/d).\r\n    function _fakePowInternal(uint256 xQ10, uint256 numerator, uint256 denominator, uint256 iterations) private pure returns (uint256) {\r\n        // Initialize the result to 1 (1024 is 1 in Q10)\r\n        uint256 resultQ10 = 1024;\r\n\r\n        // Grab the integer part of the exponent, which we can compute exactly\r\n        uint256 integerExponent = numerator / denominator;\r\n\r\n        // We have to be careful with overflow here. We know that x fits in 11 bits, because\r\n        // we require x to be in the range 0-1. We also know that if x fits in n bits, then\r\n        // x^y fits in n*y bits. So, any power <23 will safely fit into 256-bits. Any power\r\n        // >= 23 might not! We can loop over powers >22 (which will be very rare!) and safely\r\n        // compute them in chunks without overflow.\r\n        while (integerExponent >= 22) {\r\n            resultQ10 *= xQ10 ** 22;\r\n            resultQ10 >>= 220; // back out the 22 extra multiples of 1024\r\n            integerExponent -= 22;\r\n        }\r\n\r\n        // Handle any remaining integer part of the power function without the possibility\r\n        // of overflow\r\n        if (integerExponent > 0) {\r\n            resultQ10 *= xQ10 ** integerExponent;\r\n            resultQ10 >>= (integerExponent * 10);\r\n        }\r\n\r\n        uint256 fractionalExponent = numerator % denominator;\r\n\r\n        // If we've run out of iterations, or there is no fractional part, we can\r\n        // just return the value we've computed to this point.\r\n        if ((iterations == 0) || (fractionalExponent == 0)) {\r\n            return resultQ10;\r\n        }\r\n\r\n        // This is the magic, and -- I'll be honest -- I don't have much other than some\r\n        // empirical testing to defend it. If we have a fractional power n/d, where n < d\r\n        // we recursively call this function \"flipping\" everything. We flip the base value\r\n        // x, by using 1-x. And we flip the fractional exponent and use d/n which will\r\n        // result in a power > 1.  And then we flip the result again by using 1-result.\r\n        //\r\n        // The result is a value that is _quite close_ to x^(n/d), but is much cheaper to\r\n        // to compute on a VM that only has an integer unit.\r\n        resultQ10 *= (1024 - _fakePowInternal(1024 - xQ10, denominator, fractionalExponent, iterations - 1));\r\n\r\n        return resultQ10 >> 10;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"moveSet\",\"type\":\"bytes32\"}],\"name\":\"isValidMoveSet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MOVE_MASK\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"moveSet1\",\"type\":\"bytes32\"},{\"name\":\"moveSet2\",\"type\":\"bytes32\"},{\"name\":\"power1\",\"type\":\"uint256\"},{\"name\":\"power2\",\"type\":\"uint256\"},{\"name\":\"affinity1\",\"type\":\"uint256\"},{\"name\":\"affinity2\",\"type\":\"uint256\"}],\"name\":\"resolveDuel\",\"outputs\":[{\"name\":\"power\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MOVE_DELTA\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isValidAffinity\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WEIGHT_SUM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ThreeAffinityDuelResolver","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://996940750a71c3e240b0e9532ee8afe0f9015b2dfa59d097a3aac0e4a7ed1417"}]}