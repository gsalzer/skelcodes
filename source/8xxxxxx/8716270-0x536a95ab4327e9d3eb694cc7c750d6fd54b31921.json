{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract LitionPool {\r\n    using SafeMath for uint256;\r\n    \r\n    event StakingStarted(address indexed staker, uint256 amount, uint8 lockupPeriod, bool compound);\r\n    event StakingFinished(address indexed staker, uint256 amount);\r\n    event StakerRemoved(address indexed staker, uint256 amount);\r\n    event RewardSent(uint256 amount);\r\n    event CompoundChanged(address indexed staker);\r\n    event RewardsWithdrawn(address indexed staker, uint256 amount);\r\n\r\n    address public owner;\r\n    IERC20 litionToken;\r\n    uint256 public lastRewardedBlock = 0;\r\n\r\n    struct Stake {\r\n        bool valid;\r\n        uint256 amount;\r\n        uint8 lockupPeriod;\r\n        bool compound;\r\n        uint256 timestamp;\r\n        uint256 rewards;\r\n    }\r\n\r\n    address[] stakers;\r\n    mapping (address => Stake) public stakesBySender;\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor(IERC20 _litionToken) public {\r\n        owner = msg.sender;\r\n        litionToken = _litionToken;\r\n    }\r\n    \r\n    function stakeTokens(uint8 _lockupPeriod, bool _compound, uint256 _amount) public {\r\n        require(!stakesBySender[msg.sender].valid, \"You can't increase your stake\");\r\n        require(_isValidLockupPeriod(_lockupPeriod), \"The lockup period is invalid\");\r\n        require(_amount >= 5000000000000000000000, \"You must stake at least 5000 LIT\");\r\n\r\n        require(IERC20(litionToken).transferFrom(msg.sender, address(this), _amount));\r\n        \r\n        stakesBySender[msg.sender].valid = true;\r\n        stakesBySender[msg.sender].amount = _amount;\r\n        stakesBySender[msg.sender].lockupPeriod = _lockupPeriod;\r\n        stakesBySender[msg.sender].compound = _compound;\r\n        stakesBySender[msg.sender].timestamp = now;\r\n        \r\n        stakers.push(msg.sender);\r\n        \r\n        emit StakingStarted(msg.sender, _amount, _lockupPeriod, _compound);\r\n    }\r\n    \r\n    function rewardStakers(uint256 _rewardedBlock, uint256 _amount) public onlyOwner {\r\n        lastRewardedBlock = _rewardedBlock;\r\n        \r\n        uint256 fees = _amount.mul(5) / 100;\r\n        uint256 totalParts = _calculateParts();\r\n        uint256 totalTransferred = 0;\r\n        \r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            Stake memory stake = stakesBySender[stakers[i]];\r\n            \r\n            if (!_isValidAndNotExpired(stakers[i])) {\r\n                continue;\r\n            }\r\n            \r\n            uint256 amountToTransfer = _getAmountToTransfer(totalParts, _amount.sub(fees), stake.lockupPeriod, stake.amount);\r\n            totalTransferred = totalTransferred.add(amountToTransfer);\r\n            \r\n            if (stake.compound) {\r\n                stakesBySender[stakers[i]].amount = stakesBySender[stakers[i]].amount.add(amountToTransfer);\r\n            }\r\n            else {\r\n                stakesBySender[stakers[i]].rewards = stakesBySender[stakers[i]].rewards.add(amountToTransfer);\r\n            }\r\n        }\r\n        \r\n        require(IERC20(litionToken).transferFrom(msg.sender, address(this), totalTransferred));\r\n\r\n        emit RewardSent(_amount);\r\n    }\r\n    \r\n    function switchCompound() public {\r\n        require(stakesBySender[msg.sender].valid, \"You are not staking\");\r\n        stakesBySender[msg.sender].compound = !stakesBySender[msg.sender].compound;\r\n        emit CompoundChanged(msg.sender);\r\n    }\r\n    \r\n    function withdrawRewards() public {\r\n        require(stakesBySender[msg.sender].valid, \"You are not staking tokens\");\r\n        require(stakesBySender[msg.sender].rewards > 0, \"You don't have rewards to claim\");\r\n        \r\n        uint256 amount = stakesBySender[msg.sender].rewards;\r\n        stakesBySender[msg.sender].rewards = 0;\r\n\r\n        require(litionToken.transfer(msg.sender, amount));\r\n\r\n        emit RewardsWithdrawn(msg.sender, amount);\r\n    }\r\n    \r\n    function finishStaking() public {\r\n        require(_isLockupPeriodFinished(stakesBySender[msg.sender].timestamp, stakesBySender[msg.sender].lockupPeriod), \"The lockup period is not finished\");\r\n\r\n        uint256 total = _closeStake(msg.sender);\r\n        \r\n        emit StakingFinished(msg.sender, total);\r\n    }\r\n    \r\n    function getTotalInStake() public view returns (uint256) {\r\n        uint256 total = 0;\r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            Stake memory stake = stakesBySender[stakers[i]];\r\n            total = total.add(stake.amount);\r\n        }\r\n        return total;\r\n    }\r\n    \r\n    function getTotalStakers() public view returns (uint256) {\r\n        return stakers.length;\r\n    }\r\n    \r\n    function getLockupFinishTimestamp(address _staker) public view returns (uint256) {\r\n        require(stakesBySender[_staker].valid, \"The address is not staking tokens\");\r\n\r\n        Stake memory stake = stakesBySender[_staker];\r\n        return stake.timestamp + stake.lockupPeriod * (30 days);\r\n    }\r\n\r\n    function _removeStaker(address _staker) public onlyOwner {\r\n        uint256 total = _closeStake(_staker);\r\n\r\n        emit StakerRemoved(_staker, total);\r\n    }\r\n\r\n    function _closeStake(address _staker) internal returns (uint256) {\r\n        require(stakesBySender[_staker].valid, \"This is not a valid staker\");\r\n\r\n        stakesBySender[_staker].valid = false;\r\n        uint256 rewards = stakesBySender[_staker].rewards;\r\n        uint256 total = stakesBySender[_staker].amount.add(rewards);\r\n        stakesBySender[_staker].amount = 0;\r\n        stakesBySender[_staker].rewards = 0;\r\n        \r\n        _removeByValue(_staker);\r\n        \r\n        require(litionToken.transfer(_staker, total));\r\n\r\n        return total;\r\n    }\r\n    \r\n    function _extractLitSentByMistake(address _to) public onlyOwner {\r\n        require(stakers.length == 0, \"There are still stakers in the contract\");\r\n        uint256 litBalance = litionToken.balanceOf(address(this));\r\n        require(litionToken.transfer(_to, litBalance));\r\n    }\r\n        \r\n    function _calculateParts() internal view returns (uint256) {\r\n        uint256 divideInParts = 0;\r\n        \r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            Stake memory stake = stakesBySender[stakers[i]];\r\n            \r\n            if (!_isValidAndNotExpired(stakers[i])) {\r\n                continue;\r\n            }\r\n\r\n            if (stake.lockupPeriod == 1) {\r\n                divideInParts = divideInParts.add(stake.amount.mul(12));\r\n            }\r\n            else if (stake.lockupPeriod == 3) {\r\n                divideInParts = divideInParts.add(stake.amount.mul(14));\r\n            }\r\n            else if (stake.lockupPeriod == 6) {\r\n                divideInParts = divideInParts.add(stake.amount.mul(16));\r\n            }\r\n            else if (stake.lockupPeriod == 12) {\r\n                divideInParts = divideInParts.add(stake.amount.mul(18));\r\n            }\r\n        }\r\n        \r\n        return divideInParts;\r\n    }\r\n    \r\n    function _getAmountToTransfer(uint256 _totalParts, uint256 _rewards, uint8 _lockupPeriod, uint256 _amount) internal pure returns (uint256) {\r\n        uint256 factor;\r\n        \r\n        if (_lockupPeriod == 1) {\r\n            factor = 12;\r\n        }\r\n        else if (_lockupPeriod == 3) {\r\n            factor = 14;\r\n        }\r\n        else if (_lockupPeriod == 6) {\r\n            factor = 16;\r\n        }\r\n        else if (_lockupPeriod == 12) {\r\n            factor = 18;\r\n        }\r\n\r\n        return _amount.mul(factor).mul(_rewards).div(_totalParts).div(10);\r\n    }\r\n    \r\n    function _isValidLockupPeriod(uint8 n) internal pure returns (bool) {\r\n        if (n == 1) {\r\n            return true;\r\n        }\r\n        else if (n == 3) {\r\n            return true;\r\n        }\r\n        else if (n == 6) {\r\n            return true;\r\n        }\r\n        else if (n == 12) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function _isValidAndNotExpired(address _staker) internal view returns (bool) {\r\n        if (!stakesBySender[_staker].valid) {\r\n            return false;\r\n        }\r\n        if (_isLockupPeriodFinished(stakesBySender[_staker].timestamp, stakesBySender[_staker].lockupPeriod)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function _isLockupPeriodFinished(uint256 _timestamp, uint8 _lockupPeriod) internal view returns (bool) {\r\n        return now > _timestamp + _lockupPeriod * (30 days);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function _find(address _value) internal view returns(uint) {\r\n        uint i = 0;\r\n        while (stakers[i] != _value) {\r\n            i++;\r\n        }\r\n        return i;\r\n    }\r\n\r\n    function _removeByValue(address _value) internal {\r\n        uint i = _find(_value);\r\n        _removeByIndex(i);\r\n    }\r\n\r\n    function _removeByIndex(uint i) internal {\r\n        while (i<stakers.length-1) {\r\n            stakers[i] = stakers[i+1];\r\n            i++;\r\n        }\r\n        stakers.length--;\r\n    }\r\n    \r\n    function() external payable {\r\n        revert();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getTotalStakers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakesBySender\",\"outputs\":[{\"name\":\"valid\",\"type\":\"bool\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"lockupPeriod\",\"type\":\"uint8\"},{\"name\":\"compound\",\"type\":\"bool\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"rewards\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRewardedBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockupPeriod\",\"type\":\"uint8\"},{\"name\":\"_compound\",\"type\":\"bool\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stakeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rewardedBlock\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"rewardStakers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getLockupFinishTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"_removeStaker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"_extractLitSentByMistake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"_transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishStaking\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"switchCompound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalInStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_litionToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lockupPeriod\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"compound\",\"type\":\"bool\"}],\"name\":\"StakingStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakingFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"CompoundChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsWithdrawn\",\"type\":\"event\"}]","ContractName":"LitionPool","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000763fa6806e1acf68130d2d0f0df754c93cc546b2","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://287d665064fba0cb2efd6b75b696cf1dc40f932428621bc6628f12dfa574ec1e"}]}