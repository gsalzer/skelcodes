{"status":"1","message":"OK","result":[{"SourceCode":"{\"BancorFormula.sol\":{\"content\":\"pragma solidity 0.4.26;\\r\\nimport \\u0027IBancorFormula.sol\\u0027;\\r\\nimport \\u0027SafeMath.sol\\u0027;\\r\\nimport \\u0027Utils.sol\\u0027;\\r\\n\\r\\ncontract BancorFormula is IBancorFormula, Utils {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n\\r\\n    uint16 public version = 4;\\r\\n\\r\\n    uint256 private constant ONE = 1;\\r\\n    uint32 private constant MAX_RATIO = 1000000;\\r\\n    uint8 private constant MIN_PRECISION = 32;\\r\\n    uint8 private constant MAX_PRECISION = 127;\\r\\n\\r\\n    /**\\r\\n      * Auto-generated via \\u0027PrintIntScalingFactors.py\\u0027\\r\\n    */\\r\\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\\r\\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\\r\\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\\r\\n\\r\\n    /**\\r\\n      * Auto-generated via \\u0027PrintLn2ScalingFactors.py\\u0027\\r\\n    */\\r\\n    uint256 private constant LN2_NUMERATOR   = 0x3f80fe03f80fe03f80fe03f80fe03f8;\\r\\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\\r\\n\\r\\n    /**\\r\\n      * Auto-generated via \\u0027PrintFunctionOptimalLog.py\\u0027 and \\u0027PrintFunctionOptimalExp.py\\u0027\\r\\n    */\\r\\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\\r\\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\\r\\n\\r\\n    /**\\r\\n      * Auto-generated via \\u0027PrintFunctionConstructor.py\\u0027\\r\\n    */\\r\\n    uint256[128] private maxExpArray;\\r\\n    constructor() public {\\r\\n    //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\\r\\n    //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\\r\\n        maxExpArray[ 32] = 0x1c35fedd14ffffffffffffffffffffffff;\\r\\n        maxExpArray[ 33] = 0x1b0ce43b323fffffffffffffffffffffff;\\r\\n        maxExpArray[ 34] = 0x19f0028ec1ffffffffffffffffffffffff;\\r\\n        maxExpArray[ 35] = 0x18ded91f0e7fffffffffffffffffffffff;\\r\\n        maxExpArray[ 36] = 0x17d8ec7f0417ffffffffffffffffffffff;\\r\\n        maxExpArray[ 37] = 0x16ddc6556cdbffffffffffffffffffffff;\\r\\n        maxExpArray[ 38] = 0x15ecf52776a1ffffffffffffffffffffff;\\r\\n        maxExpArray[ 39] = 0x15060c256cb2ffffffffffffffffffffff;\\r\\n        maxExpArray[ 40] = 0x1428a2f98d72ffffffffffffffffffffff;\\r\\n        maxExpArray[ 41] = 0x13545598e5c23fffffffffffffffffffff;\\r\\n        maxExpArray[ 42] = 0x1288c4161ce1dfffffffffffffffffffff;\\r\\n        maxExpArray[ 43] = 0x11c592761c666fffffffffffffffffffff;\\r\\n        maxExpArray[ 44] = 0x110a688680a757ffffffffffffffffffff;\\r\\n        maxExpArray[ 45] = 0x1056f1b5bedf77ffffffffffffffffffff;\\r\\n        maxExpArray[ 46] = 0x0faadceceeff8bffffffffffffffffffff;\\r\\n        maxExpArray[ 47] = 0x0f05dc6b27edadffffffffffffffffffff;\\r\\n        maxExpArray[ 48] = 0x0e67a5a25da4107fffffffffffffffffff;\\r\\n        maxExpArray[ 49] = 0x0dcff115b14eedffffffffffffffffffff;\\r\\n        maxExpArray[ 50] = 0x0d3e7a392431239fffffffffffffffffff;\\r\\n        maxExpArray[ 51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\\r\\n        maxExpArray[ 52] = 0x0c2d415c3db974afffffffffffffffffff;\\r\\n        maxExpArray[ 53] = 0x0bad03e7d883f69bffffffffffffffffff;\\r\\n        maxExpArray[ 54] = 0x0b320d03b2c343d5ffffffffffffffffff;\\r\\n        maxExpArray[ 55] = 0x0abc25204e02828dffffffffffffffffff;\\r\\n        maxExpArray[ 56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\\r\\n        maxExpArray[ 57] = 0x09deaf736ac1f569ffffffffffffffffff;\\r\\n        maxExpArray[ 58] = 0x0976bd9952c7aa957fffffffffffffffff;\\r\\n        maxExpArray[ 59] = 0x09131271922eaa606fffffffffffffffff;\\r\\n        maxExpArray[ 60] = 0x08b380f3558668c46fffffffffffffffff;\\r\\n        maxExpArray[ 61] = 0x0857ddf0117efa215bffffffffffffffff;\\r\\n        maxExpArray[ 62] = 0x07ffffffffffffffffffffffffffffffff;\\r\\n        maxExpArray[ 63] = 0x07abbf6f6abb9d087fffffffffffffffff;\\r\\n        maxExpArray[ 64] = 0x075af62cbac95f7dfa7fffffffffffffff;\\r\\n        maxExpArray[ 65] = 0x070d7fb7452e187ac13fffffffffffffff;\\r\\n        maxExpArray[ 66] = 0x06c3390ecc8af379295fffffffffffffff;\\r\\n        maxExpArray[ 67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\\r\\n        maxExpArray[ 68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\\r\\n        maxExpArray[ 69] = 0x05f63b1fc104dbd39587ffffffffffffff;\\r\\n        maxExpArray[ 70] = 0x05b771955b36e12f7235ffffffffffffff;\\r\\n        maxExpArray[ 71] = 0x057b3d49dda84556d6f6ffffffffffffff;\\r\\n        maxExpArray[ 72] = 0x054183095b2c8ececf30ffffffffffffff;\\r\\n        maxExpArray[ 73] = 0x050a28be635ca2b888f77fffffffffffff;\\r\\n        maxExpArray[ 74] = 0x04d5156639708c9db33c3fffffffffffff;\\r\\n        maxExpArray[ 75] = 0x04a23105873875bd52dfdfffffffffffff;\\r\\n        maxExpArray[ 76] = 0x0471649d87199aa990756fffffffffffff;\\r\\n        maxExpArray[ 77] = 0x04429a21a029d4c1457cfbffffffffffff;\\r\\n        maxExpArray[ 78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\\r\\n        maxExpArray[ 79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\\r\\n        maxExpArray[ 80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\\r\\n        maxExpArray[ 81] = 0x0399e96897690418f785257fffffffffff;\\r\\n        maxExpArray[ 82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\\r\\n        maxExpArray[ 83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\\r\\n        maxExpArray[ 84] = 0x032cbfd4a7adc790560b3337ffffffffff;\\r\\n        maxExpArray[ 85] = 0x030b50570f6e5d2acca94613ffffffffff;\\r\\n        maxExpArray[ 86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\\r\\n        maxExpArray[ 87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\\r\\n        maxExpArray[ 88] = 0x02af09481380a0a35cf1ba02ffffffffff;\\r\\n        maxExpArray[ 89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\\r\\n        maxExpArray[ 90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\\r\\n        maxExpArray[ 91] = 0x025daf6654b1eaa55fd64df5efffffffff;\\r\\n        maxExpArray[ 92] = 0x0244c49c648baa98192dce88b7ffffffff;\\r\\n        maxExpArray[ 93] = 0x022ce03cd5619a311b2471268bffffffff;\\r\\n        maxExpArray[ 94] = 0x0215f77c045fbe885654a44a0fffffffff;\\r\\n        maxExpArray[ 95] = 0x01ffffffffffffffffffffffffffffffff;\\r\\n        maxExpArray[ 96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\\r\\n        maxExpArray[ 97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\\r\\n        maxExpArray[ 98] = 0x01c35fedd14b861eb0443f7f133fffffff;\\r\\n        maxExpArray[ 99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\\r\\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\\r\\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\\r\\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\\r\\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\\r\\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\\r\\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\\r\\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\\r\\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\\r\\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\\r\\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\\r\\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\\r\\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\\r\\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\\r\\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\\r\\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\\r\\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\\r\\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\\r\\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\\r\\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\\r\\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\\r\\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\\r\\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\\r\\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\\r\\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\\r\\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\\r\\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\\r\\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\\r\\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev given a token supply, reserve balance, ratio and a deposit amount (in the reserve token),\\r\\n      * calculates the return for a given conversion (in the main token)\\r\\n      * \\r\\n      * Formula:\\r\\n      * Return = _supply * ((1 + _depositAmount / _reserveBalance) ^ (_reserveRatio / 1000000) - 1)\\r\\n      * \\r\\n      * @param _supply              token total supply\\r\\n      * @param _reserveBalance      total reserve balance\\r\\n      * @param _reserveRatio        reserve ratio, represented in ppm, 1-1000000\\r\\n      * @param _depositAmount       deposit amount, in reserve token\\r\\n      * \\r\\n      * @return purchase return amount\\r\\n    */\\r\\n    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _depositAmount) public view returns (uint256) {\\r\\n        // validate input\\r\\n        require(_supply \\u003e 0 \\u0026\\u0026 _reserveBalance \\u003e 0 \\u0026\\u0026 _reserveRatio \\u003e 0 \\u0026\\u0026 _reserveRatio \\u003c= MAX_RATIO);\\r\\n\\r\\n        // special case for 0 deposit amount\\r\\n        if (_depositAmount == 0)\\r\\n            return 0;\\r\\n\\r\\n        // special case if the ratio = 100%\\r\\n        if (_reserveRatio == MAX_RATIO)\\r\\n            return _supply.mul(_depositAmount) / _reserveBalance;\\r\\n\\r\\n        uint256 result;\\r\\n        uint8 precision;\\r\\n        uint256 baseN = _depositAmount.add(_reserveBalance);\\r\\n        (result, precision) = power(baseN, _reserveBalance, _reserveRatio, MAX_RATIO);\\r\\n        uint256 temp = _supply.mul(result) \\u003e\\u003e precision;\\r\\n        return temp - _supply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev given a token supply, reserve balance, ratio and a sell amount (in the main token),\\r\\n      * calculates the return for a given conversion (in the reserve token)\\r\\n      * \\r\\n      * Formula:\\r\\n      * Return = _reserveBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_reserveRatio / 1000000)))\\r\\n      * \\r\\n      * @param _supply              token total supply\\r\\n      * @param _reserveBalance      total reserve\\r\\n      * @param _reserveRatio        constant reserve Ratio, represented in ppm, 1-1000000\\r\\n      * @param _sellAmount          sell amount, in the token itself\\r\\n      * \\r\\n      * @return sale return amount\\r\\n    */\\r\\n    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _sellAmount) public view returns (uint256) {\\r\\n        // validate input\\r\\n        require(_supply \\u003e 0 \\u0026\\u0026 _reserveBalance \\u003e 0 \\u0026\\u0026 _reserveRatio \\u003e 0 \\u0026\\u0026 _reserveRatio \\u003c= MAX_RATIO \\u0026\\u0026 _sellAmount \\u003c= _supply);\\r\\n\\r\\n        // special case for 0 sell amount\\r\\n        if (_sellAmount == 0)\\r\\n            return 0;\\r\\n\\r\\n        // special case for selling the entire supply\\r\\n        if (_sellAmount == _supply)\\r\\n            return _reserveBalance;\\r\\n\\r\\n        // special case if the ratio = 100%\\r\\n        if (_reserveRatio == MAX_RATIO)\\r\\n            return _reserveBalance.mul(_sellAmount) / _supply;\\r\\n\\r\\n        uint256 result;\\r\\n        uint8 precision;\\r\\n        uint256 baseD = _supply - _sellAmount;\\r\\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _reserveRatio);\\r\\n        uint256 temp1 = _reserveBalance.mul(result);\\r\\n        uint256 temp2 = _reserveBalance \\u003c\\u003c precision;\\r\\n        return (temp1 - temp2) / result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev given two reserve balances/ratios and a sell amount (in the first reserve token),\\r\\n      * calculates the return for a conversion from the first reserve token to the second reserve token (in the second reserve token)\\r\\n      * note that prior to version 4, you should use \\u0027calculateCrossConnectorReturn\\u0027 instead\\r\\n      * \\r\\n      * Formula:\\r\\n      * Return = _toReserveBalance * (1 - (_fromReserveBalance / (_fromReserveBalance + _amount)) ^ (_fromReserveRatio / _toReserveRatio))\\r\\n      * \\r\\n      * @param _fromReserveBalance      input reserve balance\\r\\n      * @param _fromReserveRatio        input reserve ratio, represented in ppm, 1-1000000\\r\\n      * @param _toReserveBalance        output reserve balance\\r\\n      * @param _toReserveRatio          output reserve ratio, represented in ppm, 1-1000000\\r\\n      * @param _amount                  input reserve amount\\r\\n      * \\r\\n      * @return second reserve amount\\r\\n    */\\r\\n    function calculateCrossReserveReturn(uint256 _fromReserveBalance, uint32 _fromReserveRatio, uint256 _toReserveBalance, uint32 _toReserveRatio, uint256 _amount) public view returns (uint256) {\\r\\n        // validate input\\r\\n        require(_fromReserveBalance \\u003e 0 \\u0026\\u0026 _fromReserveRatio \\u003e 0 \\u0026\\u0026 _fromReserveRatio \\u003c= MAX_RATIO \\u0026\\u0026 _toReserveBalance \\u003e 0 \\u0026\\u0026 _toReserveRatio \\u003e 0 \\u0026\\u0026 _toReserveRatio \\u003c= MAX_RATIO);\\r\\n\\r\\n        // special case for equal ratios\\r\\n        if (_fromReserveRatio == _toReserveRatio)\\r\\n            return _toReserveBalance.mul(_amount) / _fromReserveBalance.add(_amount);\\r\\n\\r\\n        uint256 result;\\r\\n        uint8 precision;\\r\\n        uint256 baseN = _fromReserveBalance.add(_amount);\\r\\n        (result, precision) = power(baseN, _fromReserveBalance, _fromReserveRatio, _toReserveRatio);\\r\\n        uint256 temp1 = _toReserveBalance.mul(result);\\r\\n        uint256 temp2 = _toReserveBalance \\u003c\\u003c precision;\\r\\n        return (temp1 - temp2) / result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev General Description:\\r\\n      *     Determine a value of precision.\\r\\n      *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\\r\\n      *     Return the result along with the precision used.\\r\\n      * \\r\\n      * Detailed Description:\\r\\n      *     Instead of calculating \\\"base ^ exp\\\", we calculate \\\"e ^ (log(base) * exp)\\\".\\r\\n      *     The value of \\\"log(base)\\\" is represented with an integer slightly smaller than \\\"log(base) * 2 ^ precision\\\".\\r\\n      *     The larger \\\"precision\\\" is, the more accurately this value represents the real value.\\r\\n      *     However, the larger \\\"precision\\\" is, the more bits are required in order to store this value.\\r\\n      *     And the exponentiation function, which takes \\\"x\\\" and calculates \\\"e ^ x\\\", is limited to a maximum exponent (maximum value of \\\"x\\\").\\r\\n      *     This maximum exponent depends on the \\\"precision\\\" used, and it is given by \\\"maxExpArray[precision] \\u003e\\u003e (MAX_PRECISION - precision)\\\".\\r\\n      *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\\r\\n      *     This allows us to compute \\\"base ^ exp\\\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\\r\\n      *     This functions assumes that \\\"_expN \\u003c 2 ^ 256 / log(MAX_NUM - 1)\\\", otherwise the multiplication should be replaced with a \\\"safeMul\\\".\\r\\n    */\\r\\n    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) internal view returns (uint256, uint8) {\\r\\n        require(_baseN \\u003c MAX_NUM);\\r\\n\\r\\n        uint256 baseLog;\\r\\n        uint256 base = _baseN * FIXED_1 / _baseD;\\r\\n        if (base \\u003c OPT_LOG_MAX_VAL) {\\r\\n            baseLog = optimalLog(base);\\r\\n        }\\r\\n        else {\\r\\n            baseLog = generalLog(base);\\r\\n        }\\r\\n\\r\\n        uint256 baseLogTimesExp = baseLog * _expN / _expD;\\r\\n        if (baseLogTimesExp \\u003c OPT_EXP_MAX_VAL) {\\r\\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\\r\\n        }\\r\\n        else {\\r\\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\\r\\n            return (generalExp(baseLogTimesExp \\u003e\\u003e (MAX_PRECISION - precision), precision), precision);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev computes log(x / FIXED_1) * FIXED_1.\\r\\n      * This functions assumes that \\\"x \\u003e= FIXED_1\\\", because the output would be negative otherwise.\\r\\n    */\\r\\n    function generalLog(uint256 x) internal pure returns (uint256) {\\r\\n        uint256 res = 0;\\r\\n\\r\\n        // If x \\u003e= 2, then we compute the integer part of log2(x), which is larger than 0.\\r\\n        if (x \\u003e= FIXED_2) {\\r\\n            uint8 count = floorLog2(x / FIXED_1);\\r\\n            x \\u003e\\u003e= count; // now x \\u003c 2\\r\\n            res = count * FIXED_1;\\r\\n        }\\r\\n\\r\\n        // If x \\u003e 1, then we compute the fraction part of log2(x), which is larger than 0.\\r\\n        if (x \\u003e FIXED_1) {\\r\\n            for (uint8 i = MAX_PRECISION; i \\u003e 0; --i) {\\r\\n                x = (x * x) / FIXED_1; // now 1 \\u003c x \\u003c 4\\r\\n                if (x \\u003e= FIXED_2) {\\r\\n                    x \\u003e\\u003e= 1; // now 1 \\u003c x \\u003c 2\\r\\n                    res += ONE \\u003c\\u003c (i - 1);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return res * LN2_NUMERATOR / LN2_DENOMINATOR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\\r\\n    */\\r\\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\\r\\n        uint8 res = 0;\\r\\n\\r\\n        if (_n \\u003c 256) {\\r\\n            // At most 8 iterations\\r\\n            while (_n \\u003e 1) {\\r\\n                _n \\u003e\\u003e= 1;\\r\\n                res += 1;\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            // Exactly 8 iterations\\r\\n            for (uint8 s = 128; s \\u003e 0; s \\u003e\\u003e= 1) {\\r\\n                if (_n \\u003e= (ONE \\u003c\\u003c s)) {\\r\\n                    _n \\u003e\\u003e= s;\\r\\n                    res |= s;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev the global \\\"maxExpArray\\\" is sorted in descending order, and therefore the following statements are equivalent:\\r\\n      * - This function finds the position of [the smallest value in \\\"maxExpArray\\\" larger than or equal to \\\"x\\\"]\\r\\n      * - This function finds the highest position of [a value in \\\"maxExpArray\\\" larger than or equal to \\\"x\\\"]\\r\\n    */\\r\\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\\r\\n        uint8 lo = MIN_PRECISION;\\r\\n        uint8 hi = MAX_PRECISION;\\r\\n\\r\\n        while (lo + 1 \\u003c hi) {\\r\\n            uint8 mid = (lo + hi) / 2;\\r\\n            if (maxExpArray[mid] \\u003e= _x)\\r\\n                lo = mid;\\r\\n            else\\r\\n                hi = mid;\\r\\n        }\\r\\n\\r\\n        if (maxExpArray[hi] \\u003e= _x)\\r\\n            return hi;\\r\\n        if (maxExpArray[lo] \\u003e= _x)\\r\\n            return lo;\\r\\n\\r\\n        require(false);\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev this function can be auto-generated by the script \\u0027PrintFunctionGeneralExp.py\\u0027.\\r\\n      * it approximates \\\"e ^ x\\\" via maclaurin summation: \\\"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\\\".\\r\\n      * it returns \\\"e ^ (x / 2 ^ precision) * 2 ^ precision\\\", that is, the result is upshifted for accuracy.\\r\\n      * the global \\\"maxExpArray\\\" maps each \\\"precision\\\" to \\\"((maximumExponent + 1) \\u003c\\u003c (MAX_PRECISION - precision)) - 1\\\".\\r\\n      * the maximum permitted value for \\\"x\\\" is therefore given by \\\"maxExpArray[precision] \\u003e\\u003e (MAX_PRECISION - precision)\\\".\\r\\n    */\\r\\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\\r\\n        uint256 xi = _x;\\r\\n        uint256 res = 0;\\r\\n\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\\r\\n        xi = (xi * _x) \\u003e\\u003e _precision; res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\\r\\n\\r\\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE \\u003c\\u003c _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev computes log(x / FIXED_1) * FIXED_1\\r\\n      * Input range: FIXED_1 \\u003c= x \\u003c= LOG_EXP_MAX_VAL - 1\\r\\n      * Auto-generated via \\u0027PrintFunctionOptimalLog.py\\u0027\\r\\n      * Detailed description:\\r\\n      * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 \\u003c r \\u003c 2\\r\\n      * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\\r\\n      * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\\r\\n      * - The natural logarithm of the input is calculated by summing up the intermediate results above\\r\\n      * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\\r\\n    */\\r\\n    function optimalLog(uint256 x) internal pure returns (uint256) {\\r\\n        uint256 res = 0;\\r\\n\\r\\n        uint256 y;\\r\\n        uint256 z;\\r\\n        uint256 w;\\r\\n\\r\\n        if (x \\u003e= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {res += 0x40000000000000000000000000000000; x = x * FIXED_1 / 0xd3094c70f034de4b96ff7d5b6f99fcd8;} // add 1 / 2^1\\r\\n        if (x \\u003e= 0xa45af1e1f40c333b3de1db4dd55f29a7) {res += 0x20000000000000000000000000000000; x = x * FIXED_1 / 0xa45af1e1f40c333b3de1db4dd55f29a7;} // add 1 / 2^2\\r\\n        if (x \\u003e= 0x910b022db7ae67ce76b441c27035c6a1) {res += 0x10000000000000000000000000000000; x = x * FIXED_1 / 0x910b022db7ae67ce76b441c27035c6a1;} // add 1 / 2^3\\r\\n        if (x \\u003e= 0x88415abbe9a76bead8d00cf112e4d4a8) {res += 0x08000000000000000000000000000000; x = x * FIXED_1 / 0x88415abbe9a76bead8d00cf112e4d4a8;} // add 1 / 2^4\\r\\n        if (x \\u003e= 0x84102b00893f64c705e841d5d4064bd3) {res += 0x04000000000000000000000000000000; x = x * FIXED_1 / 0x84102b00893f64c705e841d5d4064bd3;} // add 1 / 2^5\\r\\n        if (x \\u003e= 0x8204055aaef1c8bd5c3259f4822735a2) {res += 0x02000000000000000000000000000000; x = x * FIXED_1 / 0x8204055aaef1c8bd5c3259f4822735a2;} // add 1 / 2^6\\r\\n        if (x \\u003e= 0x810100ab00222d861931c15e39b44e99) {res += 0x01000000000000000000000000000000; x = x * FIXED_1 / 0x810100ab00222d861931c15e39b44e99;} // add 1 / 2^7\\r\\n        if (x \\u003e= 0x808040155aabbbe9451521693554f733) {res += 0x00800000000000000000000000000000; x = x * FIXED_1 / 0x808040155aabbbe9451521693554f733;} // add 1 / 2^8\\r\\n\\r\\n        z = y = x - FIXED_1;\\r\\n        w = y * y / FIXED_1;\\r\\n        res += z * (0x100000000000000000000000000000000 - y) / 0x100000000000000000000000000000000; z = z * w / FIXED_1; // add y^01 / 01 - y^02 / 02\\r\\n        res += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y) / 0x200000000000000000000000000000000; z = z * w / FIXED_1; // add y^03 / 03 - y^04 / 04\\r\\n        res += z * (0x099999999999999999999999999999999 - y) / 0x300000000000000000000000000000000; z = z * w / FIXED_1; // add y^05 / 05 - y^06 / 06\\r\\n        res += z * (0x092492492492492492492492492492492 - y) / 0x400000000000000000000000000000000; z = z * w / FIXED_1; // add y^07 / 07 - y^08 / 08\\r\\n        res += z * (0x08e38e38e38e38e38e38e38e38e38e38e - y) / 0x500000000000000000000000000000000; z = z * w / FIXED_1; // add y^09 / 09 - y^10 / 10\\r\\n        res += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y) / 0x600000000000000000000000000000000; z = z * w / FIXED_1; // add y^11 / 11 - y^12 / 12\\r\\n        res += z * (0x089d89d89d89d89d89d89d89d89d89d89 - y) / 0x700000000000000000000000000000000; z = z * w / FIXED_1; // add y^13 / 13 - y^14 / 14\\r\\n        res += z * (0x088888888888888888888888888888888 - y) / 0x800000000000000000000000000000000;                      // add y^15 / 15 - y^16 / 16\\r\\n\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev computes e ^ (x / FIXED_1) * FIXED_1\\r\\n      * input range: 0 \\u003c= x \\u003c= OPT_EXP_MAX_VAL - 1\\r\\n      * auto-generated via \\u0027PrintFunctionOptimalExp.py\\u0027\\r\\n      * Detailed description:\\r\\n      * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\\r\\n      * - The exponentiation of each binary exponent is given (pre-calculated)\\r\\n      * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\\r\\n      * - The exponentiation of the input is calculated by multiplying the intermediate results above\\r\\n      * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\\r\\n    */\\r\\n    function optimalExp(uint256 x) internal pure returns (uint256) {\\r\\n        uint256 res = 0;\\r\\n\\r\\n        uint256 y;\\r\\n        uint256 z;\\r\\n\\r\\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\\r\\n        z = z * y / FIXED_1; res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\\r\\n        z = z * y / FIXED_1; res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\\r\\n        z = z * y / FIXED_1; res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\\r\\n        z = z * y / FIXED_1; res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\\r\\n        z = z * y / FIXED_1; res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\\r\\n        z = z * y / FIXED_1; res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\\r\\n        z = z * y / FIXED_1; res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\\r\\n        z = z * y / FIXED_1; res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\\r\\n        z = z * y / FIXED_1; res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\\r\\n        z = z * y / FIXED_1; res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\\r\\n        z = z * y / FIXED_1; res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\\r\\n        z = z * y / FIXED_1; res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\\r\\n        z = z * y / FIXED_1; res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\\r\\n        z = z * y / FIXED_1; res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\\r\\n        z = z * y / FIXED_1; res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\\r\\n        z = z * y / FIXED_1; res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\\r\\n        z = z * y / FIXED_1; res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\\r\\n        z = z * y / FIXED_1; res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\\r\\n        z = z * y / FIXED_1; res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\\r\\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\\r\\n\\r\\n        if ((x \\u0026 0x010000000000000000000000000000000) != 0) res = res * 0x1c3d6a24ed82218787d624d3e5eba95f9 / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\\r\\n        if ((x \\u0026 0x020000000000000000000000000000000) != 0) res = res * 0x18ebef9eac820ae8682b9793ac6d1e778 / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\\r\\n        if ((x \\u0026 0x040000000000000000000000000000000) != 0) res = res * 0x1368b2fc6f9609fe7aceb46aa619baed5 / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\\r\\n        if ((x \\u0026 0x080000000000000000000000000000000) != 0) res = res * 0x0bc5ab1b16779be3575bd8f0520a9f21e / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\\r\\n        if ((x \\u0026 0x100000000000000000000000000000000) != 0) res = res * 0x0454aaa8efe072e7f6ddbab84b40a55c5 / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\\r\\n        if ((x \\u0026 0x200000000000000000000000000000000) != 0) res = res * 0x00960aadc109e7a3bf4578099615711d7 / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\\r\\n        if ((x \\u0026 0x400000000000000000000000000000000) != 0) res = res * 0x0002bf84208204f5977f9a8cf01fdc307 / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\\r\\n\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev deprecated, backward compatibility\\r\\n    */\\r\\n    function calculateCrossConnectorReturn(uint256 _fromConnectorBalance, uint32 _fromConnectorWeight, uint256 _toConnectorBalance, uint32 _toConnectorWeight, uint256 _amount) public view returns (uint256) {\\r\\n        return calculateCrossReserveReturn(_fromConnectorBalance, _fromConnectorWeight, _toConnectorBalance, _toConnectorWeight, _amount);\\r\\n    }\\r\\n}\\r\\n\"},\"IBancorFormula.sol\":{\"content\":\"pragma solidity 0.4.26;\\n\\n/*\\n    Bancor Formula interface\\n*/\\ncontract IBancorFormula {\\n    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _depositAmount) public view returns (uint256);\\n    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _sellAmount) public view returns (uint256);\\n    function calculateCrossReserveReturn(uint256 _fromReserveBalance, uint32 _fromReserveRatio, uint256 _toReserveBalance, uint32 _toReserveRatio, uint256 _amount) public view returns (uint256);\\n    // deprecated, backward compatibility\\n    function calculateCrossConnectorReturn(uint256 _fromConnectorBalance, uint32 _fromConnectorWeight, uint256 _toConnectorBalance, uint32 _toConnectorWeight, uint256 _amount) public view returns (uint256);\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.4.26;\\r\\n\\r\\n/**\\r\\n  * @dev Library for basic math operations with overflow/underflow protection\\r\\n*/\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n      * @dev returns the sum of _x and _y, reverts if the calculation overflows\\r\\n      * \\r\\n      * @param _x   value 1\\r\\n      * @param _y   value 2\\r\\n      * \\r\\n      * @return sum\\r\\n    */\\r\\n    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\\r\\n        uint256 z = _x + _y;\\r\\n        require(z \\u003e= _x);\\r\\n        return z;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev returns the difference of _x minus _y, reverts if the calculation underflows\\r\\n      * \\r\\n      * @param _x   minuend\\r\\n      * @param _y   subtrahend\\r\\n      * \\r\\n      * @return difference\\r\\n    */\\r\\n    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\\r\\n        require(_x \\u003e= _y);\\r\\n        return _x - _y;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n      * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\\r\\n      * \\r\\n      * @param _x   factor 1\\r\\n      * @param _y   factor 2\\r\\n      * \\r\\n      * @return product\\r\\n    */\\r\\n    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\\r\\n        // gas optimization\\r\\n        if (_x == 0)\\r\\n            return 0;\\r\\n\\r\\n        uint256 z = _x * _y;\\r\\n        require(z / _x == _y);\\r\\n        return z;\\r\\n    }\\r\\n\\r\\n      /**\\r\\n        * ev Integer division of two numbers truncating the quotient, reverts on division by zero.\\r\\n        * \\r\\n        * aram _x   dividend\\r\\n        * aram _y   divisor\\r\\n        * \\r\\n        * eturn quotient\\r\\n    */\\r\\n    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\\r\\n        require(_y \\u003e 0);\\r\\n        uint256 c = _x / _y;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n\"},\"Utils.sol\":{\"content\":\"pragma solidity 0.4.26;\\r\\n\\r\\n/**\\r\\n  * @dev Utilities \\u0026 Common Modifiers\\r\\n*/\\r\\ncontract Utils {\\r\\n    /**\\r\\n      * constructor\\r\\n    */\\r\\n    constructor() public {\\r\\n    }\\r\\n\\r\\n    // verifies that an amount is greater than zero\\r\\n    modifier greaterThanZero(uint256 _amount) {\\r\\n        require(_amount \\u003e 0);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // validates an address - currently only checks that it isn\\u0027t null\\r\\n    modifier validAddress(address _address) {\\r\\n        require(_address != address(0));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // verifies that the address is different than this contract address\\r\\n    modifier notThis(address _address) {\\r\\n        require(_address != address(this));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n}\\r\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_reserveBalance\",\"type\":\"uint256\"},{\"name\":\"_reserveRatio\",\"type\":\"uint32\"},{\"name\":\"_depositAmount\",\"type\":\"uint256\"}],\"name\":\"calculatePurchaseReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_reserveBalance\",\"type\":\"uint256\"},{\"name\":\"_reserveRatio\",\"type\":\"uint32\"},{\"name\":\"_sellAmount\",\"type\":\"uint256\"}],\"name\":\"calculateSaleReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fromConnectorBalance\",\"type\":\"uint256\"},{\"name\":\"_fromConnectorWeight\",\"type\":\"uint32\"},{\"name\":\"_toConnectorBalance\",\"type\":\"uint256\"},{\"name\":\"_toConnectorWeight\",\"type\":\"uint32\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculateCrossConnectorReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fromReserveBalance\",\"type\":\"uint256\"},{\"name\":\"_fromReserveRatio\",\"type\":\"uint32\"},{\"name\":\"_toReserveBalance\",\"type\":\"uint256\"},{\"name\":\"_toReserveRatio\",\"type\":\"uint32\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculateCrossReserveReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"BancorFormula","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"5000000","ConstructorArguments":"","Library":"","LicenseType":"MPL-2.0","SwarmSource":"bzzr://0c110437f159e839a181e97418b7b91a8c50a25e94c609bf1c87dbf827ce31f8"}]}