{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"optimizer\": {},\r\n    \"evmVersion\": \"constantinople\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/Pool.sol\": {\r\n        \"DrawManager\": \"0xD215CF8D8bC151414A9c5c145fE219E746E5cE80\",\r\n        \"FixidityLib\": \"0x5Ce0678E90719ff5382a57fA693394Aee468f11B\"\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/DrawManager.sol\": {\r\n      \"content\": \"/**\\nCopyright 2019 PoolTogether LLC\\n\\nThis file is part of PoolTogether.\\n\\nPoolTogether is free software: you can redistribute it and/or modify\\nit under the terms of the GNU General Public License as published by\\nthe Free Software Foundation under version 3 of the License.\\n\\nPoolTogether is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\nGNU General Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License\\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\\n*/\\n\\npragma solidity 0.5.10;\\n\\nimport \\\"./UniformRandomNumber.sol\\\";\\nimport \\\"@kleros/kleros/contracts/data-structures/SortitionSumTreeFactory.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @author Brendan Asselstine\\n * @notice Tracks committed and open balances for addresses.  Affords selection of an address by indexing all committed balances.\\n *\\n * Balances are tracked in Draws.  There is always one open Draw.  Deposits are always added to the open Draw.\\n * When a new draw is opened, the previous opened draw is committed.\\n *\\n * The committed balance for an address is the total of their balances for committed Draws.\\n * An address's open balance is their balance in the open Draw.\\n */\\nlibrary DrawManager {\\n    using SortitionSumTreeFactory for SortitionSumTreeFactory.SortitionSumTrees;\\n    using SafeMath for uint256;\\n\\n    /**\\n     * The ID to use for the selection tree.\\n     */\\n    bytes32 public constant TREE_OF_DRAWS = \\\"TreeOfDraws\\\";\\n\\n    uint8 public constant MAX_LEAVES = 10;\\n\\n    /**\\n     * Stores information for all draws.\\n     */\\n    struct State {\\n        /**\\n         * Each Draw stores it's address balances in a sortitionSumTree.  Draw trees are indexed using the Draw index.\\n         * There is one root sortitionSumTree that stores all of the draw totals.  The root tree is indexed using the constant TREE_OF_DRAWS.\\n         */\\n        SortitionSumTreeFactory.SortitionSumTrees sortitionSumTrees;\\n\\n        /**\\n         * Stores the first Draw index that an address deposited to.\\n         */\\n        mapping(address => uint256) usersFirstDrawIndex;\\n\\n        /**\\n         * Stores the last Draw index that an address deposited to.\\n         */\\n        mapping(address => uint256) usersSecondDrawIndex;\\n\\n        /**\\n         * Stores a mapping of Draw index => Draw total\\n         */\\n        mapping(uint256 => uint256) drawTotals;\\n\\n        /**\\n         * The current open Draw index\\n         */\\n        uint256 openDrawIndex;\\n\\n        /**\\n         * The total of committed balances\\n         */\\n        uint256 committedSupply;\\n    }\\n\\n    /**\\n     * @notice Opens the next Draw and commits the previous open Draw (if any).\\n     * @param self The drawState this library is attached to\\n     * @return The index of the new open Draw\\n     */\\n    function openNextDraw(State storage self) public returns (uint256) {\\n        if (self.openDrawIndex == 0) {\\n            // If there is no previous draw, we must initialize\\n            self.sortitionSumTrees.createTree(TREE_OF_DRAWS, MAX_LEAVES);\\n        } else {\\n            // else add current draw to sortition sum trees\\n            bytes32 drawId = bytes32(self.openDrawIndex);\\n            uint256 drawTotal = self.drawTotals[self.openDrawIndex];\\n            self.sortitionSumTrees.set(TREE_OF_DRAWS, drawTotal, drawId);\\n            self.committedSupply = self.committedSupply.add(drawTotal);\\n        }\\n        // now create a new draw\\n        uint256 drawIndex = self.openDrawIndex.add(1);\\n        self.sortitionSumTrees.createTree(bytes32(drawIndex), MAX_LEAVES);\\n        self.openDrawIndex = drawIndex;\\n\\n        return drawIndex;\\n    }\\n\\n    /**\\n     * @notice Deposits the given amount into the current open draw by the given user.\\n     * @param self The DrawManager state\\n     * @param _addr The address to deposit for\\n     * @param _amount The amount to deposit\\n     */\\n    function deposit(State storage self, address _addr, uint256 _amount) public requireOpenDraw(self) {\\n        bytes32 userId = bytes32(uint256(_addr));\\n        uint256 openDrawIndex = self.openDrawIndex;\\n\\n        // update the current draw\\n        uint256 currentAmount = self.sortitionSumTrees.stakeOf(bytes32(openDrawIndex), userId);\\n        currentAmount = currentAmount.add(_amount);\\n        drawSet(self, openDrawIndex, currentAmount, _addr);\\n\\n        uint256 firstDrawIndex = self.usersFirstDrawIndex[_addr];\\n        uint256 secondDrawIndex = self.usersSecondDrawIndex[_addr];\\n\\n        // if this is the users first draw, set it\\n        if (firstDrawIndex == 0) {\\n            self.usersFirstDrawIndex[_addr] = openDrawIndex;\\n        // otherwise, if the first draw is not this draw\\n        } else if (firstDrawIndex != openDrawIndex) {\\n            // if a second draw does not exist\\n            if (secondDrawIndex == 0) {\\n                // set the second draw to the current draw\\n                self.usersSecondDrawIndex[_addr] = openDrawIndex;\\n            // otherwise if a second draw exists but is not the current one\\n            } else if (secondDrawIndex != openDrawIndex) {\\n                // merge it into the first draw, and update the second draw index to this one\\n                uint256 firstAmount = self.sortitionSumTrees.stakeOf(bytes32(firstDrawIndex), userId);\\n                uint256 secondAmount = self.sortitionSumTrees.stakeOf(bytes32(secondDrawIndex), userId);\\n                drawSet(self, firstDrawIndex, firstAmount.add(secondAmount), _addr);\\n                drawSet(self, secondDrawIndex, 0, _addr);\\n                self.usersSecondDrawIndex[_addr] = openDrawIndex;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Withdraws a user's committed and open draws.\\n     * @param self The DrawManager state\\n     * @param _addr The address whose balance to withdraw\\n     */\\n    function withdraw(State storage self, address _addr) public requireOpenDraw(self) {\\n        uint256 firstDrawIndex = self.usersFirstDrawIndex[_addr];\\n        uint256 secondDrawIndex = self.usersSecondDrawIndex[_addr];\\n\\n        if (firstDrawIndex != 0) {\\n            drawSet(self, firstDrawIndex, 0, _addr);\\n        }\\n\\n        if (secondDrawIndex != 0) {\\n            drawSet(self, secondDrawIndex, 0, _addr);\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the total balance for an address, including committed balances and the open balance.\\n     */\\n    function balanceOf(State storage drawState, address _addr) public view returns (uint256) {\\n        return committedBalanceOf(drawState, _addr).add(openBalanceOf(drawState, _addr));\\n    }\\n\\n    /**\\n     * @notice Returns the total committed balance for an address.\\n     * @param self The DrawManager state\\n     * @param _addr The address whose committed balance should be returned\\n     * @return The total committed balance\\n     */\\n    function committedBalanceOf(State storage self, address _addr) public view returns (uint256) {\\n        uint256 balance = 0;\\n\\n        uint256 firstDrawIndex = self.usersFirstDrawIndex[_addr];\\n        uint256 secondDrawIndex = self.usersSecondDrawIndex[_addr];\\n\\n        if (firstDrawIndex != 0 && firstDrawIndex != self.openDrawIndex) {\\n            balance = balance.add(self.sortitionSumTrees.stakeOf(bytes32(firstDrawIndex), bytes32(uint256(_addr))));\\n        }\\n\\n        if (secondDrawIndex != 0 && secondDrawIndex != self.openDrawIndex) {\\n            balance = balance.add(self.sortitionSumTrees.stakeOf(bytes32(secondDrawIndex), bytes32(uint256(_addr))));\\n        }\\n\\n        return balance;\\n    }\\n\\n    /**\\n     * @notice Returns the open balance for an address\\n     * @param self The DrawManager state\\n     * @param _addr The address whose open balance should be returned\\n     * @return The open balance\\n     */\\n    function openBalanceOf(State storage self, address _addr) public view returns (uint256) {\\n        if (self.openDrawIndex == 0) {\\n            return 0;\\n        } else {\\n            return self.sortitionSumTrees.stakeOf(bytes32(self.openDrawIndex), bytes32(uint256(_addr)));\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the open Draw balance for the DrawManager\\n     * @param self The DrawManager state\\n     * @return The open draw total balance\\n     */\\n    function openSupply(State storage self) public view returns (uint256) {\\n        return self.drawTotals[self.openDrawIndex];\\n    }\\n\\n    /**\\n     * @notice Updates the Draw balance for an address.\\n     * @param self The DrawManager state\\n     * @param _drawIndex The Draw index\\n     * @param _amount The new balance\\n     * @param _addr The address whose balance should be updated\\n     */\\n    function drawSet(State storage self, uint256 _drawIndex, uint256 _amount, address _addr) internal {\\n        bytes32 drawId = bytes32(_drawIndex);\\n        bytes32 userId = bytes32(uint256(_addr));\\n        uint256 oldAmount = self.sortitionSumTrees.stakeOf(drawId, userId);\\n\\n        if (oldAmount != _amount) {\\n            // If the amount has changed\\n\\n            // Update the Draw's balance for that address\\n            self.sortitionSumTrees.set(drawId, _amount, userId);\\n\\n            uint256 drawTotal = self.drawTotals[_drawIndex];\\n            if (oldAmount > _amount) {\\n                // If the amount is less than the old amount\\n\\n                // Subtract the difference from the Draw total\\n                uint256 diffAmount = oldAmount.sub(_amount);\\n                drawTotal = drawTotal.sub(diffAmount);\\n                if (_drawIndex != self.openDrawIndex) {\\n                    // If the Draw is committed, update the root tree and committed supply\\n                    self.sortitionSumTrees.set(TREE_OF_DRAWS, drawTotal, drawId);\\n                    self.committedSupply = self.committedSupply.sub(diffAmount);\\n                }\\n            } else { // oldAmount < _amount\\n                // if the amount is greater than the old amount\\n\\n                // Add the difference to the Draw total\\n                uint256 diffAmount = _amount.sub(oldAmount);\\n                drawTotal = drawTotal.add(diffAmount);\\n                if (_drawIndex != self.openDrawIndex) {\\n                    // If the Draw is committed, update the root tree and committed supply\\n                    self.sortitionSumTrees.set(TREE_OF_DRAWS, drawTotal, drawId);\\n                    self.committedSupply = self.committedSupply.add(diffAmount);\\n                }\\n            }\\n            // Update the Draw total with the new total\\n            self.drawTotals[_drawIndex] = drawTotal;\\n        }\\n    }\\n\\n   /**\\n     * @notice Selects an address by indexing into the committed tokens using the passed token\\n     * @param self The DrawManager state\\n     * @param _token The token index to select\\n     * @return The selected address\\n     */\\n    function draw(State storage self, uint256 _token) public view returns (address) {\\n        // If there is no one to select, just return the zero address\\n        if (self.committedSupply == 0) {\\n            return address(0);\\n        }\\n        require(_token < self.committedSupply, \\\"token is beyond the eligible supply\\\");\\n        uint256 drawIndex = uint256(self.sortitionSumTrees.draw(TREE_OF_DRAWS, _token));\\n        assert(drawIndex != 0);\\n        uint256 drawSupply = self.drawTotals[drawIndex];\\n        assert(drawSupply > 0);\\n        uint256 drawToken = _token % drawSupply;\\n        return address(uint256(self.sortitionSumTrees.draw(bytes32(drawIndex), drawToken)));\\n    }\\n\\n    /**\\n     * @notice Selects an address using the entropy as an index into the committed tokens\\n     * The entropy is passed into the UniformRandomNumber library to remove modulo bias.\\n     * @param self The DrawManager state\\n     * @param _entropy The random entropy to use\\n     * @return The selected address\\n     */\\n    function drawWithEntropy(State storage self, bytes32 _entropy) public view returns (address) {\\n        return draw(self, UniformRandomNumber.uniform(uint256(_entropy), self.committedSupply));\\n    }\\n\\n    modifier requireOpenDraw(State storage self) {\\n        require(self.openDrawIndex > 0, \\\"there is no open draw\\\");\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/Migrations.sol\": {\r\n      \"content\": \"/**\\nCopyright 2019 PoolTogether LLC\\n\\nThis file is part of PoolTogether.\\n\\nPoolTogether is free software: you can redistribute it and/or modify\\nit under the terms of the GNU General Public License as published by\\nthe Free Software Foundation under version 3 of the License.\\n\\nPoolTogether is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\nGNU General Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License\\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\\n*/\\n\\n// Migrations.sol\\n\\npragma solidity 0.5.10;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\\\";\\n\\ncontract Migrations is Ownable {\\n  uint public last_completed_migration;\\n\\n  function setCompleted(uint completed) public onlyOwner {\\n    last_completed_migration = completed;\\n  }\\n\\n  function upgrade(address new_address) public onlyOwner {\\n    Migrations upgraded = Migrations(new_address);\\n    upgraded.setCompleted(last_completed_migration);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Pool.sol\": {\r\n      \"content\": \"/**\\nCopyright 2019 PoolTogether LLC\\n\\nThis file is part of PoolTogether.\\n\\nPoolTogether is free software: you can redistribute it and/or modify\\nit under the terms of the GNU General Public License as published by\\nthe Free Software Foundation under version 3 of the License.\\n\\nPoolTogether is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\nGNU General Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License\\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\\n*/\\n\\npragma solidity 0.5.10;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol\\\";\\nimport \\\"./compound/ICErc20.sol\\\";\\nimport \\\"./DrawManager.sol\\\";\\nimport \\\"fixidity/contracts/FixidityLib.sol\\\";\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\n/**\\n * @title The Pool contract\\n * @author Brendan Asselstine\\n * @notice This contract allows users to pool deposits into Compound and win the accrued interest in periodic draws.\\n * Funds are immediately deposited and withdrawn from the Compound cToken contract.\\n * Draws go through three stages: open, committed and rewarded in that order.\\n * Only one draw is ever in the open stage.  Users deposits are always added to the open draw.  Funds in the open Draw are that user's open balance.\\n * When a Draw is committed, the funds in it are moved to a user's committed total and the total committed balance of all users is updated.\\n * When a Draw is rewarded, the gross winnings are the accrued interest since the last reward (if any).  A winner is selected with their chances being\\n * proportional to their committed balance vs the total committed balance of all users.\\n *\\n *\\n * With the above in mind, there is always an open draw and possibly a committed draw.  The progression is:\\n *\\n * Step 1: Draw 1 Open\\n * Step 2: Draw 2 Open | Draw 1 Committed\\n * Step 3: Draw 3 Open | Draw 2 Committed | Draw 1 Rewarded\\n * Step 4: Draw 4 Open | Draw 3 Committed | Draw 2 Rewarded\\n * Step 5: Draw 5 Open | Draw 4 Committed | Draw 3 Rewarded\\n * Step X: ...\\n */\\ncontract Pool is Initializable, ReentrancyGuard {\\n  using DrawManager for DrawManager.State;\\n  using SafeMath for uint256;\\n  using Roles for Roles.Role;\\n\\n  uint256 private constant ETHER_IN_WEI = 1000000000000000000;\\n\\n  /**\\n   * Emitted when a user deposits into the Pool.\\n   * @param sender The purchaser of the tickets\\n   * @param amount The size of the deposit\\n   */\\n  event Deposited(address indexed sender, uint256 amount);\\n\\n  /**\\n   * Emitted when Sponsors have deposited into the Pool\\n   * @param sender The purchaser of the tickets\\n   * @param amount The size of the deposit\\n   */\\n  event SponsorshipDeposited(address indexed sender, uint256 amount);\\n\\n  /**\\n   * Emitted when an admin has been added to the Pool.\\n   * @param admin The admin that was added\\n   */\\n  event AdminAdded(address indexed admin);\\n\\n  /**\\n   * Emitted when an admin has been removed from the Pool.\\n   * @param admin The admin that was removed\\n   */\\n  event AdminRemoved(address indexed admin);\\n\\n  /**\\n   * Emitted when a user withdraws from the pool.\\n   * @param sender The user that is withdrawing from the pool\\n   * @param amount The amount that the user withdrew\\n   */\\n  event Withdrawn(address indexed sender, uint256 amount);\\n\\n  /**\\n   * Emitted when a new draw is opened for deposit.\\n   * @param drawId The draw id\\n   * @param feeBeneficiary The fee beneficiary for this draw\\n   * @param secretHash The committed secret hash\\n   * @param feeFraction The fee fraction of the winnings to be given to the beneficiary\\n   */\\n  event Opened(\\n    uint256 indexed drawId,\\n    address indexed feeBeneficiary,\\n    bytes32 secretHash,\\n    uint256 feeFraction\\n  );\\n\\n  /**\\n   * Emitted when a draw is committed.\\n   * @param drawId The draw id\\n   */\\n  event Committed(\\n    uint256 indexed drawId\\n  );\\n\\n  /**\\n   * Emitted when a draw is rewarded.\\n   * @param drawId The draw id\\n   * @param winner The address of the winner\\n   * @param entropy The entropy used to select the winner\\n   * @param winnings The net winnings given to the winner\\n   * @param fee The fee being given to the draw beneficiary\\n   */\\n  event Rewarded(\\n    uint256 indexed drawId,\\n    address indexed winner,\\n    bytes32 entropy,\\n    uint256 winnings,\\n    uint256 fee\\n  );\\n\\n  /**\\n   * Emitted when the fee fraction is changed.  Takes effect on the next draw.\\n   * @param feeFraction The next fee fraction encoded as a fixed point 18 decimal\\n   */\\n  event NextFeeFractionChanged(uint256 feeFraction);\\n\\n  /**\\n   * Emitted when the next fee beneficiary changes.  Takes effect on the next draw.\\n   * @param feeBeneficiary The next fee beneficiary\\n   */\\n  event NextFeeBeneficiaryChanged(address indexed feeBeneficiary);\\n\\n  /**\\n   * Emitted when an admin pauses the contract\\n   */\\n  event Paused(address indexed sender);\\n\\n  /**\\n   * Emitted when an admin unpauses the contract\\n   */\\n  event Unpaused(address indexed sender);\\n\\n  struct Draw {\\n    uint256 feeFraction; //fixed point 18\\n    address feeBeneficiary;\\n    uint256 openedBlock;\\n    bytes32 secretHash;\\n  }\\n\\n  /**\\n   * The Compound cToken that this Pool is bound to.\\n   */\\n  ICErc20 public cToken;\\n\\n  /**\\n   * The fee beneficiary to use for subsequent Draws.\\n   */\\n  address public nextFeeBeneficiary;\\n\\n  /**\\n   * The fee fraction to use for subsequent Draws.\\n   */\\n  uint256 public nextFeeFraction;\\n\\n  /**\\n   * The total of all balances\\n   */\\n  uint256 public accountedBalance;\\n\\n  /**\\n   * The total deposits and winnings for each user.\\n   */\\n  mapping (address => uint256) balances;\\n\\n  /**\\n   * A mapping of draw ids to Draw structures\\n   */\\n  mapping(uint256 => Draw) draws;\\n\\n  /**\\n   * A structure that is used to manage the user's odds of winning.\\n   */\\n  DrawManager.State drawState;\\n\\n  /**\\n   * A structure containing the administrators\\n   */\\n  Roles.Role admins;\\n\\n  /**\\n   * Whether the contract is paused\\n   */\\n  bool public paused;\\n\\n  /**\\n   * @notice Initializes a new Pool contract.\\n   * @param _owner The owner of the Pool.  They are able to change settings and are set as the owner of new lotteries.\\n   * @param _cToken The Compound Finance MoneyMarket contract to supply and withdraw tokens.\\n   * @param _feeFraction The fraction of the gross winnings that should be transferred to the owner as the fee.  Is a fixed point 18 number.\\n   * @param _feeBeneficiary The address that will receive the fee fraction\\n   */\\n  function init (\\n    address _owner,\\n    address _cToken,\\n    uint256 _feeFraction,\\n    address _feeBeneficiary\\n  ) public initializer {\\n    require(_owner != address(0), \\\"owner cannot be the null address\\\");\\n    require(_cToken != address(0), \\\"money market address is zero\\\");\\n    cToken = ICErc20(_cToken);\\n    _addAdmin(_owner);\\n    _setNextFeeFraction(_feeFraction);\\n    _setNextFeeBeneficiary(_feeBeneficiary);\\n  }\\n\\n  /**\\n   * @notice Opens a new Draw.\\n   * @param _secretHash The secret hash to commit to the Draw.\\n   */\\n  function open(bytes32 _secretHash) internal {\\n    drawState.openNextDraw();\\n    draws[drawState.openDrawIndex] = Draw(nextFeeFraction, nextFeeBeneficiary, block.number, _secretHash);\\n    emit Opened(\\n      drawState.openDrawIndex,\\n      nextFeeBeneficiary,\\n      _secretHash,\\n      nextFeeFraction\\n    );\\n  }\\n\\n  /**\\n   * @notice Commits the current draw.\\n   */\\n  function commit() internal {\\n    uint256 drawId = currentOpenDrawId();\\n    emit Committed(drawId);\\n  }\\n\\n  /**\\n   * @notice Commits the current open draw, if any, and opens the next draw using the passed hash.  Really this function is only called twice:\\n   * the first after Pool contract creation and the second immediately after.\\n   * Can only be called by an admin.\\n   * May fire the Committed event, and always fires the Open event.\\n   * @param nextSecretHash The secret hash to use to open a new Draw\\n   */\\n  function openNextDraw(bytes32 nextSecretHash) public onlyAdmin unlessPaused {\\n    require(currentCommittedDrawId() == 0, \\\"there is a committed draw\\\");\\n    if (currentOpenDrawId() != 0) {\\n      commit();\\n    }\\n    open(nextSecretHash);\\n  }\\n\\n  /**\\n   * @notice Rewards the current committed draw using the passed secret, commits the current open draw, and opens the next draw using the passed secret hash.\\n   * Can only be called by an admin.\\n   * Fires the Rewarded event, the Committed event, and the Open event.\\n   * @param nextSecretHash The secret hash to use to open a new Draw\\n   * @param lastSecret The secret to reveal to reward the current committed Draw.\\n   */\\n  function rewardAndOpenNextDraw(bytes32 nextSecretHash, bytes32 lastSecret, bytes32 _salt) public onlyAdmin unlessPaused {\\n    require(currentCommittedDrawId() != 0, \\\"a draw has not been committed\\\");\\n    reward(lastSecret, _salt);\\n    commit();\\n    open(nextSecretHash);\\n  }\\n\\n  /**\\n   * @notice Rewards the winner for the current committed Draw using the passed secret.\\n   * The gross winnings are calculated by subtracting the accounted balance from the current underlying cToken balance.\\n   * A winner is calculated using the revealed secret and a hash of the Draw's opened block and the gross winnings.\\n   * If there is a winner (i.e. any eligible users) then winner's balance is updated with their net winnings.\\n   * The draw beneficiary's balance is updated with the fee.\\n   * The accounted balance is updated to include the fee and, if there was a winner, the net winnings.\\n   * Fires the Rewarded event.\\n   * @param _secret The secret to reveal for the current committed Draw\\n   */\\n  function reward(bytes32 _secret, bytes32 _salt) internal {\\n    uint256 drawId = currentCommittedDrawId();\\n    Draw storage draw = draws[drawId];\\n\\n    require(draw.secretHash == keccak256(abi.encodePacked(_secret, _salt)), \\\"secret does not match\\\");\\n\\n    // Calculate the gross winnings\\n    uint256 underlyingBalance = balance();\\n    uint256 grossWinnings = underlyingBalance.sub(accountedBalance);\\n\\n    // derive entropy from the revealed secret and the hash of the openedBlock and gross winnings\\n    bytes32 entropy = _secret ^ keccak256(abi.encodePacked(draw.openedBlock, grossWinnings));\\n\\n    // Select the winner using the hash as entropy\\n    address winningAddress = calculateWinner(entropy);\\n\\n    // Calculate the beneficiary fee\\n    uint256 fee = calculateFee(draw.feeFraction, grossWinnings);\\n\\n    // Update balance of the beneficiary\\n    balances[draw.feeBeneficiary] = balances[draw.feeBeneficiary].add(fee);\\n\\n    // Calculate the net winnings\\n    uint256 netWinnings = grossWinnings.sub(fee);\\n\\n    // If there is a winner who is to receive non-zero winnings\\n    if (winningAddress != address(0) && netWinnings != 0) {\\n      // Update balance of the winner\\n      balances[winningAddress] = balances[winningAddress].add(netWinnings);\\n\\n      // Enter their winnings into the next draw\\n      drawState.deposit(winningAddress, netWinnings);\\n\\n      // Updated the accounted total\\n      accountedBalance = underlyingBalance;\\n    } else {\\n      // Only account for the fee\\n      accountedBalance = accountedBalance.add(fee);\\n    }\\n\\n    // Destroy the draw now that it's complete\\n    delete draws[drawId];\\n\\n    emit Rewarded(\\n      drawId,\\n      winningAddress,\\n      entropy,\\n      netWinnings,\\n      fee\\n    );\\n  }\\n\\n  /**\\n   * @notice Calculate the beneficiary fee using the passed fee fraction and gross winnings.\\n   * @param _feeFraction The fee fraction, between 0 and 1, represented as a 18 point fixed number.\\n   * @param _grossWinnings The gross winnings to take a fraction of.\\n   */\\n  function calculateFee(uint256 _feeFraction, uint256 _grossWinnings) internal pure returns (uint256) {\\n    int256 grossWinningsFixed = FixidityLib.newFixed(int256(_grossWinnings));\\n    int256 feeFixed = FixidityLib.multiply(grossWinningsFixed, FixidityLib.newFixed(int256(_feeFraction), uint8(18)));\\n    return uint256(FixidityLib.fromFixed(feeFixed));\\n  }\\n\\n  /**\\n   * @notice Allows a user to deposit a sponsorship amount.  The deposit is transferred into the cToken.\\n   * Sponsorships allow a user to contribute to the pool without becoming eligible to win.  They can withdraw their sponsorship at any time.\\n   * The deposit will immediately be added to Compound and the interest will contribute to the next draw.\\n   * @param _amount The amount of the token underlying the cToken to deposit.\\n   */\\n  function depositSponsorship(uint256 _amount) public nonReentrant unlessPaused {\\n    // Deposit the funds\\n    _deposit(_amount);\\n\\n    emit SponsorshipDeposited(msg.sender, _amount);\\n  }\\n\\n  /**\\n   * @notice Deposits into the pool under the current open Draw.  The deposit is transferred into the cToken.\\n   * Once the open draw is committed, the deposit will be added to the user's total committed balance and increase their chances of winning\\n   * proportional to the total committed balance of all users.\\n   * @param _amount The amount of the token underlying the cToken to deposit.\\n   */\\n  function depositPool(uint256 _amount) public requireOpenDraw nonReentrant unlessPaused {\\n    // Update the user's eligibility\\n    drawState.deposit(msg.sender, _amount);\\n\\n    // Deposit the funds\\n    _deposit(_amount);\\n\\n    emit Deposited(msg.sender, _amount);\\n  }\\n\\n  /**\\n   * @notice Transfers tokens from the sender into the Compound cToken contract and updates the accountedBalance.\\n   * @param _amount The amount of the token underlying the cToken to deposit.\\n   */\\n  function _deposit(uint256 _amount) internal {\\n    require(_amount > 0, \\\"deposit is not greater than zero\\\");\\n\\n    // Transfer the tokens into this contract\\n    require(token().transferFrom(msg.sender, address(this), _amount), \\\"token transfer failed\\\");\\n\\n    // Update the user's balance\\n    balances[msg.sender] = balances[msg.sender].add(_amount);\\n\\n    // Update the total of this contract\\n    accountedBalance = accountedBalance.add(_amount);\\n\\n    // Deposit into Compound\\n    require(token().approve(address(cToken), _amount), \\\"could not approve money market spend\\\");\\n    require(cToken.mint(_amount) == 0, \\\"could not supply money market\\\");\\n  }\\n\\n  /**\\n   * @notice Withdraw the sender's entire balance back to them.\\n   */\\n  function withdraw() public nonReentrant {\\n    uint balance = balances[msg.sender];\\n\\n    require(balance > 0, \\\"balance has already been withdrawn\\\");\\n\\n    // Update the user's balance\\n    balances[msg.sender] = 0;\\n\\n    // Update their chances of winning\\n    drawState.withdraw(msg.sender);\\n\\n    _withdraw(balance);\\n  }\\n\\n  /**\\n   * @notice Transfers tokens from the cToken contract to the sender.  Updates the accounted balance.\\n   */\\n  function _withdraw(uint256 _amount) internal {\\n    require(_amount > 0, \\\"withdrawal is not greater than zero\\\");\\n\\n    // Update the total of this contract\\n    accountedBalance = accountedBalance.sub(_amount);\\n\\n    // Withdraw from Compound and transfer\\n    require(cToken.redeemUnderlying(_amount) == 0, \\\"could not redeem from compound\\\");\\n    require(token().transfer(msg.sender, _amount), \\\"could not transfer winnings\\\");\\n\\n    emit Withdrawn(msg.sender, _amount);\\n  }\\n\\n  /**\\n   * @notice Returns the id of the current open Draw.\\n   * @return The current open Draw id\\n   */\\n  function currentOpenDrawId() public view returns (uint256) {\\n    return drawState.openDrawIndex;\\n  }\\n\\n  /**\\n   * @notice Returns the id of the current committed Draw.\\n   * @return The current committed Draw id\\n   */\\n  function currentCommittedDrawId() public view returns (uint256) {\\n    if (drawState.openDrawIndex > 1) {\\n      return drawState.openDrawIndex - 1;\\n    } else {\\n      return 0;\\n    }\\n  }\\n\\n  /**\\n   * @notice Gets information for a given draw.\\n   * @param _drawId The id of the Draw to retrieve info for.\\n   * @return Fields including:\\n   *  feeFraction: the fee fraction\\n   *  feeBeneficiary: the beneficiary of the fee\\n   *  openedBlock: The block at which the draw was opened\\n   *  secretHash: The hash of the secret committed to this draw.\\n   */\\n  function getDraw(uint256 _drawId) public view returns (\\n    uint256 feeFraction,\\n    address feeBeneficiary,\\n    uint256 openedBlock,\\n    bytes32 secretHash\\n  ) {\\n    Draw storage draw = draws[_drawId];\\n    feeFraction = draw.feeFraction;\\n    feeBeneficiary = draw.feeBeneficiary;\\n    openedBlock = draw.openedBlock;\\n    secretHash = draw.secretHash;\\n  }\\n\\n  /**\\n   * @notice Returns the total of the address's balance in committed Draws.  That is, the total that contributes to their chances of winning.\\n   * @param _addr The address of the user\\n   * @return The total committed balance for the user\\n   */\\n  function committedBalanceOf(address _addr) public view returns (uint256) {\\n    return drawState.committedBalanceOf(_addr);\\n  }\\n\\n  /**\\n   * @notice Returns the total of the address's balance in the open Draw.  That is, the total that will *eventually* contribute to their chances of winning.\\n   * @param _addr The address of the user\\n   * @return The total open balance for the user\\n   */\\n  function openBalanceOf(address _addr) public view returns (uint256) {\\n    return drawState.openBalanceOf(_addr);\\n  }\\n\\n  /**\\n   * @notice Returns a user's total balance, including both committed Draw balance and open Draw balance.\\n   * @param _addr The address of the user to check.\\n   * @return The users's current balance.\\n   */\\n  function balanceOf(address _addr) public view returns (uint256) {\\n    return balances[_addr];\\n  }\\n\\n  /**\\n   * @notice Calculates a winner using the passed entropy for the current committed balances.\\n   * @param _entropy The entropy to use to select the winner\\n   * @return The winning address\\n   */\\n  function calculateWinner(bytes32 _entropy) public view returns (address) {\\n    return drawState.drawWithEntropy(_entropy);\\n  }\\n\\n  /**\\n   * @notice Returns the total committed balance.  Used to compute an address's chances of winning.\\n   * @return The total committed balance.\\n   */\\n  function committedSupply() public view returns (uint256) {\\n    return drawState.committedSupply;\\n  }\\n\\n  /**\\n   * @notice Returns the total open balance.  This balance is the number of tickets purchased for the open draw.\\n   * @return The total open balance\\n   */\\n  function openSupply() public view returns (uint256) {\\n    return drawState.openSupply();\\n  }\\n\\n  /**\\n   * @notice Calculates the total estimated interest earned for the given number of blocks\\n   * @param _blocks The number of block that interest accrued for\\n   * @return The total estimated interest as a 18 point fixed decimal.\\n   */\\n  function estimatedInterestRate(uint256 _blocks) public view returns (uint256) {\\n    return supplyRatePerBlock().mul(_blocks);\\n  }\\n\\n  /**\\n   * @notice Convenience function to return the supplyRatePerBlock value from the money market contract.\\n   * @return The cToken supply rate per block\\n   */\\n  function supplyRatePerBlock() public view returns (uint256) {\\n    return cToken.supplyRatePerBlock();\\n  }\\n\\n  /**\\n   * @notice Sets the beneficiary fee fraction for subsequent Draws.\\n   * Fires the NextFeeFractionChanged event.\\n   * Can only be called by an admin.\\n   * @param _feeFraction The fee fraction to use.\\n   * Must be between 0 and 1 and formatted as a fixed point number with 18 decimals (as in Ether).\\n   */\\n  function setNextFeeFraction(uint256 _feeFraction) public onlyAdmin {\\n    _setNextFeeFraction(_feeFraction);\\n  }\\n\\n  function _setNextFeeFraction(uint256 _feeFraction) internal {\\n    require(_feeFraction >= 0, \\\"fee must be zero or greater\\\");\\n    require(_feeFraction <= ETHER_IN_WEI, \\\"fee fraction must be 1 or less\\\");\\n    nextFeeFraction = _feeFraction;\\n\\n    emit NextFeeFractionChanged(_feeFraction);\\n  }\\n\\n  /**\\n   * @notice Sets the fee beneficiary for subsequent Draws.\\n   * Can only be called by admins.\\n   * @param _feeBeneficiary The beneficiary for the fee fraction.  Cannot be the 0 address.\\n   */\\n  function setNextFeeBeneficiary(address _feeBeneficiary) public onlyAdmin {\\n    _setNextFeeBeneficiary(_feeBeneficiary);\\n  }\\n\\n  function _setNextFeeBeneficiary(address _feeBeneficiary) internal {\\n    require(_feeBeneficiary != address(0), \\\"beneficiary should not be 0x0\\\");\\n    nextFeeBeneficiary = _feeBeneficiary;\\n\\n    emit NextFeeBeneficiaryChanged(_feeBeneficiary);\\n  }\\n\\n  /**\\n   * @notice Adds an administrator.\\n   * Can only be called by administrators.\\n   * Fires the AdminAdded event.\\n   * @param _admin The address of the admin to add\\n   */\\n  function addAdmin(address _admin) public onlyAdmin {\\n    _addAdmin(_admin);\\n  }\\n\\n  /**\\n   * @notice Checks whether a given address is an administrator.\\n   * @param _admin The address to check\\n   * @return True if the address is an admin, false otherwise.\\n   */\\n  function isAdmin(address _admin) public view returns (bool) {\\n    return admins.has(_admin);\\n  }\\n\\n  function _addAdmin(address _admin) internal {\\n    admins.add(_admin);\\n\\n    emit AdminAdded(_admin);\\n  }\\n\\n  /**\\n   * @notice Removes an administrator\\n   * Can only be called by an admin.\\n   * @param _admin The address of the admin to remove\\n   */\\n  function removeAdmin(address _admin) public onlyAdmin {\\n    require(admins.has(_admin), \\\"admin does not exist\\\");\\n    admins.remove(_admin);\\n\\n    emit AdminRemoved(_admin);\\n  }\\n\\n  /**\\n   * @notice Returns the token underlying the cToken.\\n   * @return An ERC20 token address\\n   */\\n  function token() internal view returns (IERC20) {\\n    return IERC20(cToken.underlying());\\n  }\\n\\n  /**\\n   * @notice Returns the underlying balance of this contract in the cToken.\\n   * @return The cToken underlying balance for this contract.\\n   */\\n  function balance() public returns (uint256) {\\n    return cToken.balanceOfUnderlying(address(this));\\n  }\\n\\n  function pause() public unlessPaused onlyAdmin {\\n    paused = true;\\n\\n    emit Paused(msg.sender);\\n  }\\n\\n  function unpause() public whenPaused onlyAdmin {\\n    paused = false;\\n\\n    emit Unpaused(msg.sender);\\n  }\\n\\n  modifier onlyAdmin() {\\n    require(admins.has(msg.sender), \\\"must be an admin\\\");\\n    _;\\n  }\\n\\n  modifier requireOpenDraw() {\\n    require(currentOpenDrawId() != 0, \\\"there is no open draw\\\");\\n    _;\\n  }\\n\\n  modifier whenPaused() {\\n    require(paused, \\\"contract is not paused\\\");\\n    _;\\n  }\\n\\n  modifier unlessPaused() {\\n    require(!paused, \\\"contract is paused\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/UniformRandomNumber.sol\": {\r\n      \"content\": \"/**\\nCopyright 2019 PoolTogether LLC\\n\\nThis file is part of PoolTogether.\\n\\nPoolTogether is free software: you can redistribute it and/or modify\\nit under the terms of the GNU General Public License as published by\\nthe Free Software Foundation under version 3 of the License.\\n\\nPoolTogether is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\nGNU General Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License\\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\\n*/\\n\\npragma solidity 0.5.10;\\n\\n/**\\n * @author Brendan Asselstine\\n * @notice A library that uses entropy to select a random number within a bound.  Compensates for modulo bias.\\n * @dev Thanks to https://medium.com/hownetworks/dont-waste-cycles-with-modulo-bias-35b6fdafcf94\\n */\\nlibrary UniformRandomNumber {\\n  /// @notice Select a random number without modulo bias using a random seed and upper bound\\n  /// @param _entropy The seed for randomness\\n  /// @param _upperBound The upper bound of the desired number\\n  /// @return A random number less than the _upperBound\\n  function uniform(uint256 _entropy, uint256 _upperBound) internal pure returns (uint256) {\\n    if (_upperBound == 0) {\\n      return 0;\\n    }\\n    uint256 min = -_upperBound % _upperBound;\\n    uint256 random = _entropy;\\n    while (true) {\\n      if (random >= min) {\\n        break;\\n      }\\n      random = uint256(keccak256(abi.encodePacked(random)));\\n    }\\n    return random % _upperBound;\\n  }\\n}\"\r\n    },\r\n    \"contracts/compound/ICErc20.sol\": {\r\n      \"content\": \"/**\\nCopyright 2019 PoolTogether LLC\\n\\nThis file is part of PoolTogether.\\n\\nPoolTogether is free software: you can redistribute it and/or modify\\nit under the terms of the GNU General Public License as published by\\nthe Free Software Foundation under version 3 of the License.\\n\\nPoolTogether is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\nGNU General Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License\\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\\n*/\\n\\npragma solidity 0.5.10;\\n\\ncontract ICErc20 {\\n    address public underlying;\\n    function mint(uint mintAmount) external returns (uint);\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\n    function balanceOfUnderlying(address owner) external returns (uint);\\n    function getCash() external view returns (uint);\\n    function supplyRatePerBlock() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/test/CErc20Mock.sol\": {\r\n      \"content\": \"/**\\nCopyright 2019 PoolTogether LLC\\n\\nThis file is part of PoolTogether.\\n\\nPoolTogether is free software: you can redistribute it and/or modify\\nit under the terms of the GNU General Public License as published by\\nthe Free Software Foundation under version 3 of the License.\\n\\nPoolTogether is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\nGNU General Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License\\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\\n*/\\n\\npragma solidity 0.5.10;\\n\\nimport \\\"../compound/ICErc20.sol\\\";\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract CErc20Mock is Initializable, ICErc20 {\\n  mapping(address => uint256) ownerTokenAmounts;\\n\\n  uint __supplyRatePerBlock;\\n\\n  function initialize (address _token, uint256 _supplyRatePerBlock) public initializer {\\n    require(_token != address(0), \\\"token is not defined\\\");\\n    underlying = _token;\\n    __supplyRatePerBlock = _supplyRatePerBlock;\\n  }\\n\\n  function mint(uint amount) external returns (uint) {\\n    ownerTokenAmounts[msg.sender] = ownerTokenAmounts[msg.sender] + amount;\\n    require(IERC20(underlying).transferFrom(msg.sender, address(this), amount), \\\"could not transfer tokens\\\");\\n    return 0;\\n  }\\n\\n  function getCash() external view returns (uint) {\\n    return IERC20(underlying).balanceOf(address(this));\\n  }\\n\\n  function redeemUnderlying(uint requestedAmount) external returns (uint) {\\n    require(ownerTokenAmounts[msg.sender] > 0, \\\"you must have supplied tokens\\\");\\n    ownerTokenAmounts[msg.sender] = ownerTokenAmounts[msg.sender] - requestedAmount;\\n    require(IERC20(underlying).transfer(msg.sender, requestedAmount), \\\"could not transfer tokens\\\");\\n  }\\n\\n  function reward(address account) external {\\n    ownerTokenAmounts[account] = (ownerTokenAmounts[account] * 120) / 100;\\n  }\\n\\n  function balanceOfUnderlying(address account) external returns (uint) {\\n    return ownerTokenAmounts[account];\\n  }\\n\\n  function supplyRatePerBlock() external view returns (uint) {\\n    return __supplyRatePerBlock;\\n  }\\n\\n  function setSupplyRateMantissa(uint256 _supplyRatePerBlock) external {\\n    __supplyRatePerBlock = _supplyRatePerBlock;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/test/ExposedDrawManager.sol\": {\r\n      \"content\": \"/**\\nCopyright 2019 PoolTogether LLC\\n\\nThis file is part of PoolTogether.\\n\\nPoolTogether is free software: you can redistribute it and/or modify\\nit under the terms of the GNU General Public License as published by\\nthe Free Software Foundation under version 3 of the License.\\n\\nPoolTogether is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\nGNU General Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License\\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\\n*/\\n\\npragma solidity 0.5.10;\\n\\nimport \\\"../DrawManager.sol\\\";\\n\\ncontract ExposedDrawManager {\\n    using DrawManager for DrawManager.State;\\n\\n    DrawManager.State state;\\n\\n    function openNextDraw() public {\\n      state.openNextDraw();\\n    }\\n\\n    function deposit(address user, uint256 amount) public {\\n      state.deposit(user, amount);\\n    }\\n\\n    function withdraw(address user) public {\\n      state.withdraw(user);\\n    }\\n\\n    function balanceOf(address user) public view returns (uint256) {\\n      return state.balanceOf(user);\\n    }\\n\\n    function committedBalanceOf(address user) public view returns (uint256) {\\n      return state.committedBalanceOf(user);\\n    }\\n\\n    function openBalanceOf(address user) public view returns (uint256) {\\n      return state.openBalanceOf(user);\\n    }\\n\\n    function committedSupply() public view returns (uint256) {\\n      return state.committedSupply;\\n    }\\n\\n    function openSupply() public view returns (uint256) {\\n      return state.openSupply();\\n    }\\n\\n    function openDrawIndex() public view returns (uint256) {\\n      return state.openDrawIndex;\\n    }\\n\\n    function draw(uint256 token) public view returns (address) {\\n      return state.draw(token);\\n    }\\n\\n    function firstDrawIndex(address user) public view returns (uint256) {\\n        return state.usersFirstDrawIndex[user];\\n    }\\n\\n    function secondDrawIndex(address user) public view returns (uint256) {\\n        return state.usersSecondDrawIndex[user];\\n    }\\n\\n    function drawWithEntropy(bytes32 entropy) public view returns (address) {\\n        return state.drawWithEntropy(entropy);\\n    }\\n}\"\r\n    },\r\n    \"contracts/test/ExposedUniformRandomNumber.sol\": {\r\n      \"content\": \"/**\\nCopyright 2019 PoolTogether LLC\\n\\nThis file is part of PoolTogether.\\n\\nPoolTogether is free software: you can redistribute it and/or modify\\nit under the terms of the GNU General Public License as published by\\nthe Free Software Foundation under version 3 of the License.\\n\\nPoolTogether is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\nGNU General Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License\\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\\n*/\\n\\npragma solidity ^0.5.10;\\n\\nimport \\\"../UniformRandomNumber.sol\\\";\\n\\ncontract ExposedUniformRandomNumber {\\n  function uniform(uint256 _entropy, uint256 _upperBound) public pure returns (uint256) {\\n    return UniformRandomNumber.uniform(_entropy, _upperBound);\\n  }\\n}\"\r\n    },\r\n    \"contracts/test/Token.sol\": {\r\n      \"content\": \"/**\\nCopyright 2019 PoolTogether LLC\\n\\nThis file is part of PoolTogether.\\n\\nPoolTogether is free software: you can redistribute it and/or modify\\nit under the terms of the GNU General Public License as published by\\nthe Free Software Foundation under version 3 of the License.\\n\\nPoolTogether is distributed in the hope that it will be useful,\\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\nGNU General Public License for more details.\\n\\nYou should have received a copy of the GNU General Public License\\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\\n*/\\n\\npragma solidity 0.5.10;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol\\\";\\n\\n/**\\n * @author Brendan Asselstine\\n * @notice An ERC20 Token contract to be used for testing the Pool contract\\n */\\ncontract Token is ERC20Mintable {\\n  string public constant name = \\\"Token\\\";\\n  string public constant symbol = \\\"TOK\\\";\\n  uint8 public constant decimals = 18;\\n}\\n\"\r\n    },\r\n    \"@kleros/kleros/contracts/data-structures/SortitionSumTreeFactory.sol\": {\r\n      \"content\": \"/**\\n *  @reviewers: [@clesaege, @unknownunknown1, @ferittuncer]\\n *  @auditors: []\\n *  @bounties: [<14 days 10 ETH max payout>]\\n *  @deployments: []\\n */\\n\\npragma solidity ^0.5.0;\\n\\n/**\\n *  @title SortitionSumTreeFactory\\n *  @author Enrique Piqueras - <epiquerass@gmail.com>\\n *  @dev A factory of trees that keep track of staked values for sortition.\\n */\\nlibrary SortitionSumTreeFactory {\\n    /* Structs */\\n\\n    struct SortitionSumTree {\\n        uint K; // The maximum number of childs per node.\\n        // We use this to keep track of vacant positions in the tree after removing a leaf. This is for keeping the tree as balanced as possible without spending gas on moving nodes around.\\n        uint[] stack;\\n        uint[] nodes;\\n        // Two-way mapping of IDs to node indexes. Note that node index 0 is reserved for the root node, and means the ID does not have a node.\\n        mapping(bytes32 => uint) IDsToNodeIndexes;\\n        mapping(uint => bytes32) nodeIndexesToIDs;\\n    }\\n\\n    /* Storage */\\n\\n    struct SortitionSumTrees {\\n        mapping(bytes32 => SortitionSumTree) sortitionSumTrees;\\n    }\\n\\n    /* internal */\\n\\n    /**\\n     *  @dev Create a sortition sum tree at the specified key.\\n     *  @param _key The key of the new tree.\\n     *  @param _K The number of children each node in the tree should have.\\n     */\\n    function createTree(SortitionSumTrees storage self, bytes32 _key, uint _K) internal {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n        require(tree.K == 0, \\\"Tree already exists.\\\");\\n        require(_K > 1, \\\"K must be greater than one.\\\");\\n        tree.K = _K;\\n        tree.stack.length = 0;\\n        tree.nodes.length = 0;\\n        tree.nodes.push(0);\\n    }\\n\\n    /**\\n     *  @dev Set a value of a tree.\\n     *  @param _key The key of the tree.\\n     *  @param _value The new value.\\n     *  @param _ID The ID of the value.\\n     *  `O(log_k(n))` where\\n     *  `k` is the maximum number of childs per node in the tree,\\n     *   and `n` is the maximum number of nodes ever appended.\\n     */\\n    function set(SortitionSumTrees storage self, bytes32 _key, uint _value, bytes32 _ID) internal {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\\n\\n        if (treeIndex == 0) { // No existing node.\\n            if (_value != 0) { // Non zero value.\\n                // Append.\\n                // Add node.\\n                if (tree.stack.length == 0) { // No vacant spots.\\n                    // Get the index and append the value.\\n                    treeIndex = tree.nodes.length;\\n                    tree.nodes.push(_value);\\n\\n                    // Potentially append a new node and make the parent a sum node.\\n                    if (treeIndex != 1 && (treeIndex - 1) % tree.K == 0) { // Is first child.\\n                        uint parentIndex = treeIndex / tree.K;\\n                        bytes32 parentID = tree.nodeIndexesToIDs[parentIndex];\\n                        uint newIndex = treeIndex + 1;\\n                        tree.nodes.push(tree.nodes[parentIndex]);\\n                        delete tree.nodeIndexesToIDs[parentIndex];\\n                        tree.IDsToNodeIndexes[parentID] = newIndex;\\n                        tree.nodeIndexesToIDs[newIndex] = parentID;\\n                    }\\n                } else { // Some vacant spot.\\n                    // Pop the stack and append the value.\\n                    treeIndex = tree.stack[tree.stack.length - 1];\\n                    tree.stack.length--;\\n                    tree.nodes[treeIndex] = _value;\\n                }\\n\\n                // Add label.\\n                tree.IDsToNodeIndexes[_ID] = treeIndex;\\n                tree.nodeIndexesToIDs[treeIndex] = _ID;\\n\\n                updateParents(self, _key, treeIndex, true, _value);\\n            }\\n        } else { // Existing node.\\n            if (_value == 0) { // Zero value.\\n                // Remove.\\n                // Remember value and set to 0.\\n                uint value = tree.nodes[treeIndex];\\n                tree.nodes[treeIndex] = 0;\\n\\n                // Push to stack.\\n                tree.stack.push(treeIndex);\\n\\n                // Clear label.\\n                delete tree.IDsToNodeIndexes[_ID];\\n                delete tree.nodeIndexesToIDs[treeIndex];\\n\\n                updateParents(self, _key, treeIndex, false, value);\\n            } else if (_value != tree.nodes[treeIndex]) { // New, non zero value.\\n                // Set.\\n                bool plusOrMinus = tree.nodes[treeIndex] <= _value;\\n                uint plusOrMinusValue = plusOrMinus ? _value - tree.nodes[treeIndex] : tree.nodes[treeIndex] - _value;\\n                tree.nodes[treeIndex] = _value;\\n\\n                updateParents(self, _key, treeIndex, plusOrMinus, plusOrMinusValue);\\n            }\\n        }\\n    }\\n\\n    /* internal Views */\\n\\n    /**\\n     *  @dev Query the leaves of a tree. Note that if `startIndex == 0`, the tree is empty and the root node will be returned.\\n     *  @param _key The key of the tree to get the leaves from.\\n     *  @param _cursor The pagination cursor.\\n     *  @param _count The number of items to return.\\n     *  @return The index at which leaves start, the values of the returned leaves, and whether there are more for pagination.\\n     *  `O(n)` where\\n     *  `n` is the maximum number of nodes ever appended.\\n     */\\n    function queryLeafs(\\n        SortitionSumTrees storage self,\\n        bytes32 _key,\\n        uint _cursor,\\n        uint _count\\n    ) internal view returns(uint startIndex, uint[] memory values, bool hasMore) {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n\\n        // Find the start index.\\n        for (uint i = 0; i < tree.nodes.length; i++) {\\n            if ((tree.K * i) + 1 >= tree.nodes.length) {\\n                startIndex = i;\\n                break;\\n            }\\n        }\\n\\n        // Get the values.\\n        uint loopStartIndex = startIndex + _cursor;\\n        values = new uint[](loopStartIndex + _count > tree.nodes.length ? tree.nodes.length - loopStartIndex : _count);\\n        uint valuesIndex = 0;\\n        for (uint j = loopStartIndex; j < tree.nodes.length; j++) {\\n            if (valuesIndex < _count) {\\n                values[valuesIndex] = tree.nodes[j];\\n                valuesIndex++;\\n            } else {\\n                hasMore = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     *  @dev Draw an ID from a tree using a number. Note that this function reverts if the sum of all values in the tree is 0.\\n     *  @param _key The key of the tree.\\n     *  @param _drawnNumber The drawn number.\\n     *  @return The drawn ID.\\n     *  `O(k * log_k(n))` where\\n     *  `k` is the maximum number of childs per node in the tree,\\n     *   and `n` is the maximum number of nodes ever appended.\\n     */\\n    function draw(SortitionSumTrees storage self, bytes32 _key, uint _drawnNumber) internal view returns(bytes32 ID) {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n        uint treeIndex = 0;\\n        uint currentDrawnNumber = _drawnNumber % tree.nodes[0];\\n\\n        while ((tree.K * treeIndex) + 1 < tree.nodes.length)  // While it still has children.\\n            for (uint i = 1; i <= tree.K; i++) { // Loop over children.\\n                uint nodeIndex = (tree.K * treeIndex) + i;\\n                uint nodeValue = tree.nodes[nodeIndex];\\n\\n                if (currentDrawnNumber >= nodeValue) currentDrawnNumber -= nodeValue; // Go to the next child.\\n                else { // Pick this child.\\n                    treeIndex = nodeIndex;\\n                    break;\\n                }\\n            }\\n        \\n        ID = tree.nodeIndexesToIDs[treeIndex];\\n    }\\n\\n    /** @dev Gets a specified ID's associated value.\\n     *  @param _key The key of the tree.\\n     *  @param _ID The ID of the value.\\n     *  @return The associated value.\\n     */\\n    function stakeOf(SortitionSumTrees storage self, bytes32 _key, bytes32 _ID) internal view returns(uint value) {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\\n\\n        if (treeIndex == 0) value = 0;\\n        else value = tree.nodes[treeIndex];\\n    }\\n\\n    /* Private */\\n\\n    /**\\n     *  @dev Update all the parents of a node.\\n     *  @param _key The key of the tree to update.\\n     *  @param _treeIndex The index of the node to start from.\\n     *  @param _plusOrMinus Wether to add (true) or substract (false).\\n     *  @param _value The value to add or substract.\\n     *  `O(log_k(n))` where\\n     *  `k` is the maximum number of childs per node in the tree,\\n     *   and `n` is the maximum number of nodes ever appended.\\n     */\\n    function updateParents(SortitionSumTrees storage self, bytes32 _key, uint _treeIndex, bool _plusOrMinus, uint _value) private {\\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\\n\\n        uint parentIndex = _treeIndex;\\n        while (parentIndex != 0) {\\n            parentIndex = (parentIndex - 1) / tree.K;\\n            tree.nodes[parentIndex] = _plusOrMinus ? tree.nodes[parentIndex] + _value : tree.nodes[parentIndex] - _value;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two unsigned integers, reverts on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n     * reverts when dividing by zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable is Initializable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    function initialize(address sender) public initializer {\\n        _owner = sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     * @notice Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\n\\n/**\\n * @title Helps contracts guard against reentrancy attacks.\\n * @author Remco Bloemen <remco@2.com>, Eenae <alexey@mixbytes.io>\\n * @dev If you mark a function `nonReentrant`, you should also\\n * mark it `external`.\\n */\\ncontract ReentrancyGuard is Initializable {\\n    /// @dev counter to allow mutex lock with only one SSTORE operation\\n    uint256 private _guardCounter;\\n\\n    function initialize() public initializer {\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\n        // value, which is a more expensive operation.\\n        _guardCounter = 1;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _guardCounter += 1;\\n        uint256 localCounter = _guardCounter;\\n        _;\\n        require(localCounter == _guardCounter);\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address => bool) bearer;\\n    }\\n\\n    /**\\n     * @dev give an account access to this role\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(account != address(0));\\n        require(!has(role, account));\\n\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev remove an account's access to this role\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(account != address(0));\\n        require(has(role, account));\\n\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev check if an account has this role\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0));\\n        return role.bearer[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"fixidity/contracts/FixidityLib.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\n/**\\n * @title FixidityLib\\n * @author Gadi Guy, Alberto Cuesta Canada\\n * @notice This library provides fixed point arithmetic with protection against\\n * overflow. \\n * All operations are done with int256 and the operands must have been created \\n * with any of the newFrom* functions, which shift the comma digits() to the \\n * right and check for limits.\\n * When using this library be sure of using maxNewFixed() as the upper limit for\\n * creation of fixed point numbers. Use maxFixedMul(), maxFixedDiv() and\\n * maxFixedAdd() if you want to be certain that those operations don't \\n * overflow.\\n */\\nlibrary FixidityLib {\\n\\n    /**\\n     * @notice Number of positions that the comma is shifted to the right.\\n     */\\n    function digits() public pure returns(uint8) {\\n        return 24;\\n    }\\n    \\n    /**\\n     * @notice This is 1 in the fixed point units used in this library.\\n     * @dev Test fixed1() equals 10^digits()\\n     * Hardcoded to 24 digits.\\n     */\\n    function fixed1() public pure returns(int256) {\\n        return 1000000000000000000000000;\\n    }\\n\\n    /**\\n     * @notice The amount of decimals lost on each multiplication operand.\\n     * @dev Test mulPrecision() equals sqrt(fixed1)\\n     * Hardcoded to 24 digits.\\n     */\\n    function mulPrecision() public pure returns(int256) {\\n        return 1000000000000;\\n    }\\n\\n    /**\\n     * @notice Maximum value that can be represented in an int256\\n     * @dev Test maxInt256() equals 2^255 -1\\n     */\\n    function maxInt256() public pure returns(int256) {\\n        return 57896044618658097711785492504343953926634992332820282019728792003956564819967;\\n    }\\n\\n    /**\\n     * @notice Minimum value that can be represented in an int256\\n     * @dev Test minInt256 equals (2^255) * (-1)\\n     */\\n    function minInt256() public pure returns(int256) {\\n        return -57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n    }\\n\\n    /**\\n     * @notice Maximum value that can be converted to fixed point. Optimize for\\n     * @dev deployment. \\n     * Test maxNewFixed() equals maxInt256() / fixed1()\\n     * Hardcoded to 24 digits.\\n     */\\n    function maxNewFixed() public pure returns(int256) {\\n        return 57896044618658097711785492504343953926634992332820282;\\n    }\\n\\n    /**\\n     * @notice Minimum value that can be converted to fixed point. Optimize for\\n     * deployment. \\n     * @dev Test minNewFixed() equals -(maxInt256()) / fixed1()\\n     * Hardcoded to 24 digits.\\n     */\\n    function minNewFixed() public pure returns(int256) {\\n        return -57896044618658097711785492504343953926634992332820282;\\n    }\\n\\n    /**\\n     * @notice Maximum value that can be safely used as an addition operator.\\n     * @dev Test maxFixedAdd() equals maxInt256()-1 / 2\\n     * Test add(maxFixedAdd(),maxFixedAdd()) equals maxFixedAdd() + maxFixedAdd()\\n     * Test add(maxFixedAdd()+1,maxFixedAdd()) throws \\n     * Test add(-maxFixedAdd(),-maxFixedAdd()) equals -maxFixedAdd() - maxFixedAdd()\\n     * Test add(-maxFixedAdd(),-maxFixedAdd()-1) throws \\n     */\\n    function maxFixedAdd() public pure returns(int256) {\\n        return 28948022309329048855892746252171976963317496166410141009864396001978282409983;\\n    }\\n\\n    /**\\n     * @notice Maximum negative value that can be safely in a subtraction.\\n     * @dev Test maxFixedSub() equals minInt256() / 2\\n     */\\n    function maxFixedSub() public pure returns(int256) {\\n        return -28948022309329048855892746252171976963317496166410141009864396001978282409984;\\n    }\\n\\n    /**\\n     * @notice Maximum value that can be safely used as a multiplication operator.\\n     * @dev Calculated as sqrt(maxInt256()*fixed1()). \\n     * Be careful with your sqrt() implementation. I couldn't find a calculator\\n     * that would give the exact square root of maxInt256*fixed1 so this number\\n     * is below the real number by no more than 3*10**28. It is safe to use as\\n     * a limit for your multiplications, although powers of two of numbers over\\n     * this value might still work.\\n     * Test multiply(maxFixedMul(),maxFixedMul()) equals maxFixedMul() * maxFixedMul()\\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) throws \\n     * Test multiply(-maxFixedMul(),maxFixedMul()) equals -maxFixedMul() * maxFixedMul()\\n     * Test multiply(-maxFixedMul(),maxFixedMul()+1) throws \\n     * Hardcoded to 24 digits.\\n     */\\n    function maxFixedMul() public pure returns(int256) {\\n        return 240615969168004498257251713877715648331380787511296;\\n    }\\n\\n    /**\\n     * @notice Maximum value that can be safely used as a dividend.\\n     * @dev divide(maxFixedDiv,newFixedFraction(1,fixed1())) = maxInt256().\\n     * Test maxFixedDiv() equals maxInt256()/fixed1()\\n     * Test divide(maxFixedDiv(),multiply(mulPrecision(),mulPrecision())) = maxFixedDiv()*(10^digits())\\n     * Test divide(maxFixedDiv()+1,multiply(mulPrecision(),mulPrecision())) throws\\n     * Hardcoded to 24 digits.\\n     */\\n    function maxFixedDiv() public pure returns(int256) {\\n        return 57896044618658097711785492504343953926634992332820282;\\n    }\\n\\n    /**\\n     * @notice Maximum value that can be safely used as a divisor.\\n     * @dev Test maxFixedDivisor() equals fixed1()*fixed1() - Or 10**(digits()*2)\\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2)) = returns 10*fixed1()\\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2 + 1)) = throws\\n     * Hardcoded to 24 digits.\\n     */\\n    function maxFixedDivisor() public pure returns(int256) {\\n        return 1000000000000000000000000000000000000000000000000;\\n    }\\n\\n    /**\\n     * @notice Converts an int256 to fixed point units, equivalent to multiplying\\n     * by 10^digits().\\n     * @dev Test newFixed(0) returns 0\\n     * Test newFixed(1) returns fixed1()\\n     * Test newFixed(maxNewFixed()) returns maxNewFixed() * fixed1()\\n     * Test newFixed(maxNewFixed()+1) fails\\n     */\\n    function newFixed(int256 x)\\n        public\\n        pure\\n        returns (int256)\\n    {\\n        require(x <= maxNewFixed());\\n        require(x >= minNewFixed());\\n        return x * fixed1();\\n    }\\n\\n    /**\\n     * @notice Converts an int256 in the fixed point representation of this \\n     * library to a non decimal. All decimal digits will be truncated.\\n     */\\n    function fromFixed(int256 x)\\n        public\\n        pure\\n        returns (int256)\\n    {\\n        return x / fixed1();\\n    }\\n\\n    /**\\n     * @notice Converts an int256 which is already in some fixed point \\n     * representation to a different fixed precision representation.\\n     * Both the origin and destination precisions must be 38 or less digits.\\n     * Origin values with a precision higher than the destination precision\\n     * will be truncated accordingly.\\n     * @dev \\n     * Test convertFixed(1,0,0) returns 1;\\n     * Test convertFixed(1,1,1) returns 1;\\n     * Test convertFixed(1,1,0) returns 0;\\n     * Test convertFixed(1,0,1) returns 10;\\n     * Test convertFixed(10,1,0) returns 1;\\n     * Test convertFixed(10,0,1) returns 100;\\n     * Test convertFixed(100,1,0) returns 10;\\n     * Test convertFixed(100,0,1) returns 1000;\\n     * Test convertFixed(1000,2,0) returns 10;\\n     * Test convertFixed(1000,0,2) returns 100000;\\n     * Test convertFixed(1000,2,1) returns 100;\\n     * Test convertFixed(1000,1,2) returns 10000;\\n     * Test convertFixed(maxInt256,1,0) returns maxInt256/10;\\n     * Test convertFixed(maxInt256,0,1) throws\\n     * Test convertFixed(maxInt256,38,0) returns maxInt256/(10**38);\\n     * Test convertFixed(1,0,38) returns 10**38;\\n     * Test convertFixed(maxInt256,39,0) throws\\n     * Test convertFixed(1,0,39) throws\\n     */\\n    function convertFixed(int256 x, uint8 _originDigits, uint8 _destinationDigits)\\n        public\\n        pure\\n        returns (int256)\\n    {\\n        require(_originDigits <= 38 && _destinationDigits <= 38);\\n        \\n        uint8 decimalDifference;\\n        if ( _originDigits > _destinationDigits ){\\n            decimalDifference = _originDigits - _destinationDigits;\\n            return x/(uint128(10)**uint128(decimalDifference));\\n        }\\n        else if ( _originDigits < _destinationDigits ){\\n            decimalDifference = _destinationDigits - _originDigits;\\n            // Cast uint8 -> uint128 is safe\\n            // Exponentiation is safe:\\n            //     _originDigits and _destinationDigits limited to 38 or less\\n            //     decimalDifference = abs(_destinationDigits - _originDigits)\\n            //     decimalDifference < 38\\n            //     10**38 < 2**128-1\\n            require(x <= maxInt256()/uint128(10)**uint128(decimalDifference));\\n            require(x >= minInt256()/uint128(10)**uint128(decimalDifference));\\n            return x*(uint128(10)**uint128(decimalDifference));\\n        }\\n        // _originDigits == digits()) \\n        return x;\\n    }\\n\\n    /**\\n     * @notice Converts an int256 which is already in some fixed point \\n     * representation to that of this library. The _originDigits parameter is the\\n     * precision of x. Values with a precision higher than FixidityLib.digits()\\n     * will be truncated accordingly.\\n     */\\n    function newFixed(int256 x, uint8 _originDigits)\\n        public\\n        pure\\n        returns (int256)\\n    {\\n        return convertFixed(x, _originDigits, digits());\\n    }\\n\\n    /**\\n     * @notice Converts an int256 in the fixed point representation of this \\n     * library to a different representation. The _destinationDigits parameter is the\\n     * precision of the output x. Values with a precision below than \\n     * FixidityLib.digits() will be truncated accordingly.\\n     */\\n    function fromFixed(int256 x, uint8 _destinationDigits)\\n        public\\n        pure\\n        returns (int256)\\n    {\\n        return convertFixed(x, digits(), _destinationDigits);\\n    }\\n\\n    /**\\n     * @notice Converts two int256 representing a fraction to fixed point units,\\n     * equivalent to multiplying dividend and divisor by 10^digits().\\n     * @dev \\n     * Test newFixedFraction(maxFixedDiv()+1,1) fails\\n     * Test newFixedFraction(1,maxFixedDiv()+1) fails\\n     * Test newFixedFraction(1,0) fails     \\n     * Test newFixedFraction(0,1) returns 0\\n     * Test newFixedFraction(1,1) returns fixed1()\\n     * Test newFixedFraction(maxFixedDiv(),1) returns maxFixedDiv()*fixed1()\\n     * Test newFixedFraction(1,fixed1()) returns 1\\n     * Test newFixedFraction(1,fixed1()-1) returns 0\\n     */\\n    function newFixedFraction(\\n        int256 numerator, \\n        int256 denominator\\n        )\\n        public\\n        pure\\n        returns (int256)\\n    {\\n        require(numerator <= maxNewFixed());\\n        require(denominator <= maxNewFixed());\\n        require(denominator != 0);\\n        int256 convertedNumerator = newFixed(numerator);\\n        int256 convertedDenominator = newFixed(denominator);\\n        return divide(convertedNumerator, convertedDenominator);\\n    }\\n\\n    /**\\n     * @notice Returns the integer part of a fixed point number.\\n     * @dev \\n     * Test integer(0) returns 0\\n     * Test integer(fixed1()) returns fixed1()\\n     * Test integer(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\\n     * Test integer(-fixed1()) returns -fixed1()\\n     * Test integer(newFixed(-maxNewFixed())) returns -maxNewFixed()*fixed1()\\n     */\\n    function integer(int256 x) public pure returns (int256) {\\n        return (x / fixed1()) * fixed1(); // Can't overflow\\n    }\\n\\n    /**\\n     * @notice Returns the fractional part of a fixed point number. \\n     * In the case of a negative number the fractional is also negative.\\n     * @dev \\n     * Test fractional(0) returns 0\\n     * Test fractional(fixed1()) returns 0\\n     * Test fractional(fixed1()-1) returns 10^24-1\\n     * Test fractional(-fixed1()) returns 0\\n     * Test fractional(-fixed1()+1) returns -10^24-1\\n     */\\n    function fractional(int256 x) public pure returns (int256) {\\n        return x - (x / fixed1()) * fixed1(); // Can't overflow\\n    }\\n\\n    /**\\n     * @notice Converts to positive if negative.\\n     * Due to int256 having one more negative number than positive numbers \\n     * abs(minInt256) reverts.\\n     * @dev \\n     * Test abs(0) returns 0\\n     * Test abs(fixed1()) returns -fixed1()\\n     * Test abs(-fixed1()) returns fixed1()\\n     * Test abs(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\\n     * Test abs(newFixed(minNewFixed())) returns -minNewFixed()*fixed1()\\n     */\\n    function abs(int256 x) public pure returns (int256) {\\n        if (x >= 0) {\\n            return x;\\n        } else {\\n            int256 result = -x;\\n            assert (result > 0);\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice x+y. If any operator is higher than maxFixedAdd() it \\n     * might overflow.\\n     * In solidity maxInt256 + 1 = minInt256 and viceversa.\\n     * @dev \\n     * Test add(maxFixedAdd(),maxFixedAdd()) returns maxInt256()-1\\n     * Test add(maxFixedAdd()+1,maxFixedAdd()+1) fails\\n     * Test add(-maxFixedSub(),-maxFixedSub()) returns minInt256()\\n     * Test add(-maxFixedSub()-1,-maxFixedSub()-1) fails\\n     * Test add(maxInt256(),maxInt256()) fails\\n     * Test add(minInt256(),minInt256()) fails\\n     */\\n    function add(int256 x, int256 y) public pure returns (int256) {\\n        int256 z = x + y;\\n        if (x > 0 && y > 0) assert(z > x && z > y);\\n        if (x < 0 && y < 0) assert(z < x && z < y);\\n        return z;\\n    }\\n\\n    /**\\n     * @notice x-y. You can use add(x,-y) instead. \\n     * @dev Tests covered by add(x,y)\\n     */\\n    function subtract(int256 x, int256 y) public pure returns (int256) {\\n        return add(x,-y);\\n    }\\n\\n    /**\\n     * @notice x*y. If any of the operators is higher than maxFixedMul() it \\n     * might overflow.\\n     * @dev \\n     * Test multiply(0,0) returns 0\\n     * Test multiply(maxFixedMul(),0) returns 0\\n     * Test multiply(0,maxFixedMul()) returns 0\\n     * Test multiply(maxFixedMul(),fixed1()) returns maxFixedMul()\\n     * Test multiply(fixed1(),maxFixedMul()) returns maxFixedMul()\\n     * Test all combinations of (2,-2), (2, 2.5), (2, -2.5) and (0.5, -0.5)\\n     * Test multiply(fixed1()/mulPrecision(),fixed1()*mulPrecision())\\n     * Test multiply(maxFixedMul()-1,maxFixedMul()) equals multiply(maxFixedMul(),maxFixedMul()-1)\\n     * Test multiply(maxFixedMul(),maxFixedMul()) returns maxInt256() // Probably not to the last digits\\n     * Test multiply(maxFixedMul()+1,maxFixedMul()) fails\\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) fails\\n     */\\n    function multiply(int256 x, int256 y) public pure returns (int256) {\\n        if (x == 0 || y == 0) return 0;\\n        if (y == fixed1()) return x;\\n        if (x == fixed1()) return y;\\n\\n        // Separate into integer and fractional parts\\n        // x = x1 + x2, y = y1 + y2\\n        int256 x1 = integer(x) / fixed1();\\n        int256 x2 = fractional(x);\\n        int256 y1 = integer(y) / fixed1();\\n        int256 y2 = fractional(y);\\n        \\n        // (x1 + x2) * (y1 + y2) = (x1 * y1) + (x1 * y2) + (x2 * y1) + (x2 * y2)\\n        int256 x1y1 = x1 * y1;\\n        if (x1 != 0) assert(x1y1 / x1 == y1); // Overflow x1y1\\n        \\n        // x1y1 needs to be multiplied back by fixed1\\n        // solium-disable-next-line mixedcase\\n        int256 fixed_x1y1 = x1y1 * fixed1();\\n        if (x1y1 != 0) assert(fixed_x1y1 / x1y1 == fixed1()); // Overflow x1y1 * fixed1\\n        x1y1 = fixed_x1y1;\\n\\n        int256 x2y1 = x2 * y1;\\n        if (x2 != 0) assert(x2y1 / x2 == y1); // Overflow x2y1\\n\\n        int256 x1y2 = x1 * y2;\\n        if (x1 != 0) assert(x1y2 / x1 == y2); // Overflow x1y2\\n\\n        x2 = x2 / mulPrecision();\\n        y2 = y2 / mulPrecision();\\n        int256 x2y2 = x2 * y2;\\n        if (x2 != 0) assert(x2y2 / x2 == y2); // Overflow x2y2\\n\\n        // result = fixed1() * x1 * y1 + x1 * y2 + x2 * y1 + x2 * y2 / fixed1();\\n        int256 result = x1y1;\\n        result = add(result, x2y1); // Add checks for overflow\\n        result = add(result, x1y2); // Add checks for overflow\\n        result = add(result, x2y2); // Add checks for overflow\\n        return result;\\n    }\\n    \\n    /**\\n     * @notice 1/x\\n     * @dev \\n     * Test reciprocal(0) fails\\n     * Test reciprocal(fixed1()) returns fixed1()\\n     * Test reciprocal(fixed1()*fixed1()) returns 1 // Testing how the fractional is truncated\\n     * Test reciprocal(2*fixed1()*fixed1()) returns 0 // Testing how the fractional is truncated\\n     */\\n    function reciprocal(int256 x) public pure returns (int256) {\\n        require(x != 0);\\n        return (fixed1()*fixed1()) / x; // Can't overflow\\n    }\\n\\n    /**\\n     * @notice x/y. If the dividend is higher than maxFixedDiv() it \\n     * might overflow. You can use multiply(x,reciprocal(y)) instead.\\n     * There is a loss of precision on division for the lower mulPrecision() decimals.\\n     * @dev \\n     * Test divide(fixed1(),0) fails\\n     * Test divide(maxFixedDiv(),1) = maxFixedDiv()*(10^digits())\\n     * Test divide(maxFixedDiv()+1,1) throws\\n     * Test divide(maxFixedDiv(),maxFixedDiv()) returns fixed1()\\n     */\\n    function divide(int256 x, int256 y) public pure returns (int256) {\\n        if (y == fixed1()) return x;\\n        require(y != 0);\\n        require(y <= maxFixedDivisor());\\n        return multiply(x, reciprocal(y));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/upgrades/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.6.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    uint256 cs;\\n    assembly { cs := extcodesize(address) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"../../access/roles/MinterRole.sol\\\";\\n\\n/**\\n * @title ERC20Mintable\\n * @dev ERC20 minting logic\\n */\\ncontract ERC20Mintable is Initializable, ERC20, MinterRole {\\n    function initialize(address sender) public initializer {\\n        MinterRole.initialize(sender);\\n    }\\n\\n    /**\\n     * @dev Function to mint tokens\\n     * @param to The address that will receive the minted tokens.\\n     * @param value The amount of tokens to mint.\\n     * @return A boolean that indicates if the operation was successful.\\n     */\\n    function mint(address to, uint256 value) public onlyMinter returns (bool) {\\n        _mint(to, value);\\n        return true;\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @title Standard ERC20 token\\n *\\n * @dev Implementation of the basic standard token.\\n * https://eips.ethereum.org/EIPS/eip-20\\n * Originally based on code by FirstBlood:\\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n *\\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\\n * compliant implementations may not do it.\\n */\\ncontract ERC20 is Initializable, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev Total number of tokens in existence\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param owner The address to query the balance of.\\n     * @return A uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOf(address owner) public view returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param owner address The address which owns the funds.\\n     * @param spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Transfer token to a specified address\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one address to another.\\n     * Note that while this function emits an Approval event, this is not required as per the specification,\\n     * and other compliant implementations may not emit the event.\\n     * @param from address The address which you want to send tokens from\\n     * @param to address The address which you want to transfer to\\n     * @param value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        _transfer(from, to, value);\\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer token for a specified addresses\\n     * @param from The address to transfer from.\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0));\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that mints an amount of the token and assigns it to\\n     * an account. This encapsulates the modification of balances such that the\\n     * proper events are emitted.\\n     * @param account The account that will receive the created tokens.\\n     * @param value The amount that will be created.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.add(value);\\n        _balances[account] = _balances[account].add(value);\\n        emit Transfer(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account.\\n     * @param account The account whose tokens will be burnt.\\n     * @param value The amount that will be burnt.\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0));\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Approve an address to spend another addresses' tokens.\\n     * @param owner The address that owns the tokens.\\n     * @param spender The address that will spend the tokens.\\n     * @param value The number of tokens that can be spent.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(spender != address(0));\\n        require(owner != address(0));\\n\\n        _allowed[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev Internal function that burns an amount of the token of a given\\n     * account, deducting from the sender's allowance for said account. Uses the\\n     * internal burn function.\\n     * Emits an Approval event (reflecting the reduced allowance).\\n     * @param account The account whose tokens will be burnt.\\n     * @param value The amount that will be burnt.\\n     */\\n    function _burnFrom(address account, uint256 value) internal {\\n        _burn(account, value);\\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/access/roles/MinterRole.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"@openzeppelin/upgrades/contracts/Initializable.sol\\\";\\nimport \\\"../Roles.sol\\\";\\n\\n\\ncontract MinterRole is Initializable {\\n    using Roles for Roles.Role;\\n\\n    event MinterAdded(address indexed account);\\n    event MinterRemoved(address indexed account);\\n\\n    Roles.Role private _minters;\\n\\n    function initialize(address sender) public initializer {\\n        if (!isMinter(sender)) {\\n            _addMinter(sender);\\n        }\\n    }\\n\\n    modifier onlyMinter() {\\n        require(isMinter(msg.sender));\\n        _;\\n    }\\n\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters.has(account);\\n    }\\n\\n    function addMinter(address account) public onlyMinter {\\n        _addMinter(account);\\n    }\\n\\n    function renounceMinter() public {\\n        _removeMinter(msg.sender);\\n    }\\n\\n    function _addMinter(address account) internal {\\n        _minters.add(account);\\n        emit MinterAdded(account);\\n    }\\n\\n    function _removeMinter(address account) internal {\\n        _minters.remove(account);\\n        emit MinterRemoved(account);\\n    }\\n\\n    uint256[50] private ______gap;\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"accountedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextFeeFraction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentOpenDrawId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeBeneficiary\",\"type\":\"address\"}],\"name\":\"setNextFeeBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositSponsorship\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_cToken\",\"type\":\"address\"},{\"name\":\"_feeFraction\",\"type\":\"uint256\"},{\"name\":\"_feeBeneficiary\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"openBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blocks\",\"type\":\"uint256\"}],\"name\":\"estimatedInterestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"committedBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentCommittedDrawId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nextSecretHash\",\"type\":\"bytes32\"},{\"name\":\"lastSecret\",\"type\":\"bytes32\"},{\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"rewardAndOpenNextDraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeFraction\",\"type\":\"uint256\"}],\"name\":\"setNextFeeFraction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextFeeBeneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_entropy\",\"type\":\"bytes32\"}],\"name\":\"calculateWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyRatePerBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_drawId\",\"type\":\"uint256\"}],\"name\":\"getDraw\",\"outputs\":[{\"name\":\"feeFraction\",\"type\":\"uint256\"},{\"name\":\"feeBeneficiary\",\"type\":\"address\"},{\"name\":\"openedBlock\",\"type\":\"uint256\"},{\"name\":\"secretHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nextSecretHash\",\"type\":\"bytes32\"}],\"name\":\"openNextDraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"committedSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SponsorshipDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"drawId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"feeBeneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"secretHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"feeFraction\",\"type\":\"uint256\"}],\"name\":\"Opened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"drawId\",\"type\":\"uint256\"}],\"name\":\"Committed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"drawId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"entropy\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"winnings\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Rewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"feeFraction\",\"type\":\"uint256\"}],\"name\":\"NextFeeFractionChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"feeBeneficiary\",\"type\":\"address\"}],\"name\":\"NextFeeBeneficiaryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"}]","ContractName":"Pool","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://4f56aea8ae7585b4254f75cd16f60cfe6d95ca3c3081d15b87c30f009647b059"}]}