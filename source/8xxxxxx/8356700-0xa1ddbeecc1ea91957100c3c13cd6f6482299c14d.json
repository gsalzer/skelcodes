{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n/// @title Ownable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev The Ownable contract has an owner address, and provides basic\r\n///      authorization control functions, this simplifies the implementation of\r\n///      \"user permissions\".\r\ncontract Ownable\r\n{\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract\r\n    ///      to the sender.\r\n    constructor()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a\r\n    ///      new owner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function renounceOwnership()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n/// @title Claimable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Extension for the Ownable contract, where the ownership needs\r\n///      to be claimed. This allows the new owner to accept the transfer.\r\ncontract Claimable is Ownable\r\n{\r\n    address public pendingOwner;\r\n\r\n    /// @dev Modifier throws if called by any account other than the pendingOwner.\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to set the pendingOwner address.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /// @dev Allows the pendingOwner address to finalize the transfer.\r\n    function claimOwnership()\r\n        public\r\n        onlyPendingOwner\r\n    {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n/// @title ReentrancyGuard\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Exposes a modifier that guards a function against reentrancy\r\n///      Changing the value of the same storage value multiple times in a transaction\r\n///      is cheap (starting from Istanbul) so there is no need to minimize\r\n///      the number of times the value is changed\r\ncontract ReentrancyGuard\r\n{\r\n    //The default value must be 0 in order to work behind a proxy.\r\n    uint private _guardValue;\r\n\r\n    // Use this modifier on a function to prevent reentrancy\r\n    modifier nonReentrant()\r\n    {\r\n        // Check if the guard value has its original value\r\n        require(_guardValue == 0, \"REENTRANCY\");\r\n\r\n        // Set the value to something else\r\n        _guardValue = 1;\r\n\r\n        // Function body\r\n        _;\r\n\r\n        // Set the value back\r\n        _guardValue = 0;\r\n    }\r\n}\r\n\r\nlibrary Verifier\r\n{\r\n    function ScalarField ()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    }\r\n\r\n    function NegateY( uint256 Y )\r\n        internal pure returns (uint256)\r\n    {\r\n        uint q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n        return q - (Y % q);\r\n    }\r\n\r\n\r\n    /*\r\n    * This implements the Solidity equivalent of the following Python code:\r\n\r\n        from py_ecc.bn128 import *\r\n\r\n        data = # ... arguments to function [in_vk, vk_gammaABC, in_proof, proof_inputs]\r\n\r\n        vk = [int(_, 16) for _ in data[0]]\r\n        ic = [FQ(int(_, 16)) for _ in data[1]]\r\n        proof = [int(_, 16) for _ in data[2]]\r\n        inputs = [int(_, 16) for _ in data[3]]\r\n\r\n        it = iter(ic)\r\n        ic = [(_, next(it)) for _ in it]\r\n        vk_alpha = [FQ(_) for _ in vk[:2]]\r\n        vk_beta = (FQ2(vk[2:4][::-1]), FQ2(vk[4:6][::-1]))\r\n        vk_gamma = (FQ2(vk[6:8][::-1]), FQ2(vk[8:10][::-1]))\r\n        vk_delta = (FQ2(vk[10:12][::-1]), FQ2(vk[12:14][::-1]))\r\n\r\n        assert is_on_curve(vk_alpha, b)\r\n        assert is_on_curve(vk_beta, b2)\r\n        assert is_on_curve(vk_gamma, b2)\r\n        assert is_on_curve(vk_delta, b2)\r\n\r\n        proof_A = [FQ(_) for _ in proof[:2]]\r\n        proof_B = (FQ2(proof[2:4][::-1]), FQ2(proof[4:-2][::-1]))\r\n        proof_C = [FQ(_) for _ in proof[-2:]]\r\n\r\n        assert is_on_curve(proof_A, b)\r\n        assert is_on_curve(proof_B, b2)\r\n        assert is_on_curve(proof_C, b)\r\n\r\n        vk_x = ic[0]\r\n        for i, s in enumerate(inputs):\r\n            vk_x = add(vk_x, multiply(ic[i + 1], s))\r\n\r\n        check_1 = pairing(proof_B, proof_A)\r\n        check_2 = pairing(vk_beta, neg(vk_alpha))\r\n        check_3 = pairing(vk_gamma, neg(vk_x))\r\n        check_4 = pairing(vk_delta, neg(proof_C))\r\n\r\n        ok = check_1 * check_2 * check_3 * check_4\r\n        assert ok == FQ12.one()\r\n    */\r\n    function Verify(\r\n        uint256[14] memory in_vk,\r\n        uint256[4] memory vk_gammaABC,\r\n        uint256[] memory in_proof,\r\n        uint256[] memory proof_inputs\r\n        )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 snark_scalar_field = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n        require(((vk_gammaABC.length / 2) - 1) == proof_inputs.length, \"INVALID_VALUE\");\r\n\r\n        // Compute the linear combination vk_x\r\n        uint256[3] memory mul_input;\r\n        uint256[4] memory add_input;\r\n        bool success;\r\n        uint m = 2;\r\n\r\n        // First two fields are used as the sum\r\n        add_input[0] = vk_gammaABC[0];\r\n        add_input[1] = vk_gammaABC[1];\r\n\r\n        // Performs a sum of gammaABC[0] + sum[ gammaABC[i+1]^proof_inputs[i] ]\r\n        for (uint i = 0; i < proof_inputs.length; i++) {\r\n            require(proof_inputs[i] < snark_scalar_field, \"INVALID_INPUT\");\r\n            mul_input[0] = vk_gammaABC[m++];\r\n            mul_input[1] = vk_gammaABC[m++];\r\n            mul_input[2] = proof_inputs[i];\r\n\r\n            assembly {\r\n                // ECMUL, output to last 2 elements of `add_input`\r\n                success := staticcall(sub(gas, 2000), 7, mul_input, 0x80, add(add_input, 0x40), 0x60)\r\n            }\r\n            if (!success) {\r\n                return false;\r\n            }\r\n\r\n            assembly {\r\n                // ECADD\r\n                success := staticcall(sub(gas, 2000), 6, add_input, 0xc0, add_input, 0x60)\r\n            }\r\n            if (!success) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        uint[24] memory input = [\r\n            // (proof.A, proof.B)\r\n            in_proof[0], in_proof[1],                           // proof.A   (G1)\r\n            in_proof[2], in_proof[3], in_proof[4], in_proof[5], // proof.B   (G2)\r\n\r\n            // (-vk.alpha, vk.beta)\r\n            in_vk[0], NegateY(in_vk[1]),                        // -vk.alpha (G1)\r\n            in_vk[2], in_vk[3], in_vk[4], in_vk[5],             // vk.beta   (G2)\r\n\r\n            // (-vk_x, vk.gamma)\r\n            add_input[0], NegateY(add_input[1]),                // -vk_x     (G1)\r\n            in_vk[6], in_vk[7], in_vk[8], in_vk[9],             // vk.gamma  (G2)\r\n\r\n            // (-proof.C, vk.delta)\r\n            in_proof[6], NegateY(in_proof[7]),                  // -proof.C  (G1)\r\n            in_vk[10], in_vk[11], in_vk[12], in_vk[13]          // vk.delta  (G2)\r\n        ];\r\n\r\n        uint[1] memory out;\r\n        assembly {\r\n            success := staticcall(sub(gas, 2000), 8, input, 768, out, 0x20)\r\n        }\r\n        return success && out[0] != 0;\r\n    }\r\n}\r\n\r\nlibrary BatchVerifier {\r\n    function GroupOrder ()\r\n        public pure returns (uint256)\r\n    {\r\n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    }\r\n\r\n    function NegateY( uint256 Y )\r\n        internal pure returns (uint256)\r\n    {\r\n        uint q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n        return q - (Y % q);\r\n    }\r\n\r\n    function getProofEntropy(\r\n        uint256[] memory in_proof,\r\n        uint256[] memory proof_inputs,\r\n        uint proofNumber\r\n    )\r\n        internal pure returns (uint256)\r\n    {\r\n        // Truncate the least significant 3 bits from the 256bit entropy so it fits the scalar field\r\n        return uint256(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    in_proof[proofNumber*8 + 0], in_proof[proofNumber*8 + 1], in_proof[proofNumber*8 + 2], in_proof[proofNumber*8 + 3],\r\n                    in_proof[proofNumber*8 + 4], in_proof[proofNumber*8 + 5], in_proof[proofNumber*8 + 6], in_proof[proofNumber*8 + 7],\r\n                    proof_inputs[proofNumber]\r\n                )\r\n            )\r\n        ) >> 3;\r\n    }\r\n\r\n    function accumulate(\r\n        uint256[] memory in_proof,\r\n        uint256[] memory proof_inputs, // public inputs, length is num_inputs * num_proofs\r\n        uint256 num_proofs\r\n    ) internal view returns (\r\n        bool success,\r\n        uint256[] memory proofsAandC,\r\n        uint256[] memory inputAccumulators\r\n    ) {\r\n        uint256 q = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n        uint256 numPublicInputs = proof_inputs.length / num_proofs;\r\n        uint256[] memory entropy = new uint256[](num_proofs);\r\n        inputAccumulators = new uint256[](numPublicInputs + 1);\r\n\r\n        for (uint256 proofNumber = 0; proofNumber < num_proofs; proofNumber++) {\r\n            if (proofNumber == 0) {\r\n                entropy[proofNumber] = 1;\r\n            } else {\r\n                // entropy[proofNumber] = uint256(blockhash(block.number - proofNumber)) % q;\r\n                // Safer entropy:\r\n                entropy[proofNumber] = getProofEntropy(in_proof, proof_inputs, proofNumber);\r\n            }\r\n            require(entropy[proofNumber] != 0, \"Entropy should not be zero\");\r\n            // here multiplication by 1 is implied\r\n            inputAccumulators[0] = addmod(inputAccumulators[0], entropy[proofNumber], q);\r\n            for (uint256 i = 0; i < numPublicInputs; i++) {\r\n                require(proof_inputs[proofNumber * numPublicInputs + i] < q, \"INVALID_INPUT\");\r\n                // accumulate the exponent with extra entropy mod q\r\n                inputAccumulators[i+1] = addmod(inputAccumulators[i+1], mulmod(entropy[proofNumber], proof_inputs[proofNumber * numPublicInputs + i], q), q);\r\n            }\r\n            // coefficient for +vk.alpha (mind +) is the same as inputAccumulator[0]\r\n        }\r\n\r\n        // inputs for scalar multiplication\r\n        uint256[3] memory mul_input;\r\n\r\n        // use scalar multiplications to get proof.A[i] * entropy[i]\r\n\r\n        proofsAandC = new uint256[](num_proofs*2 + 2);\r\n\r\n        proofsAandC[0] = in_proof[0];\r\n        proofsAandC[1] = in_proof[1];\r\n\r\n        for (uint256 proofNumber = 1; proofNumber < num_proofs; proofNumber++) {\r\n            require(entropy[proofNumber] < q, \"INVALID_INPUT\");\r\n            mul_input[0] = in_proof[proofNumber*8];\r\n            mul_input[1] = in_proof[proofNumber*8 + 1];\r\n            mul_input[2] = entropy[proofNumber];\r\n            assembly {\r\n                // ECMUL, output proofsA[i]\r\n                // success := staticcall(sub(gas, 2000), 7, mul_input, 0x60, add(add(proofsAandC, 0x20), mul(proofNumber, 0x40)), 0x40)\r\n                success := staticcall(sub(gas, 2000), 7, mul_input, 0x60, mul_input, 0x40)\r\n            }\r\n            if (!success) {\r\n                return (false, proofsAandC, inputAccumulators);\r\n            }\r\n            proofsAandC[proofNumber*2] = mul_input[0];\r\n            proofsAandC[proofNumber*2 + 1] = mul_input[1];\r\n        }\r\n\r\n        // use scalar multiplication and addition to get sum(proof.C[i] * entropy[i])\r\n\r\n        uint256[4] memory add_input;\r\n\r\n        add_input[0] = in_proof[6];\r\n        add_input[1] = in_proof[7];\r\n\r\n        for (uint256 proofNumber = 1; proofNumber < num_proofs; proofNumber++) {\r\n            mul_input[0] = in_proof[proofNumber*8 + 6];\r\n            mul_input[1] = in_proof[proofNumber*8 + 7];\r\n            mul_input[2] = entropy[proofNumber];\r\n            assembly {\r\n                // ECMUL, output proofsA\r\n                success := staticcall(sub(gas, 2000), 7, mul_input, 0x60, add(add_input, 0x40), 0x40)\r\n            }\r\n            if (!success) {\r\n                return (false, proofsAandC, inputAccumulators);\r\n            }\r\n\r\n            assembly {\r\n                // ECADD from two elements that are in add_input and output into first two elements of add_input\r\n                success := staticcall(sub(gas, 2000), 6, add_input, 0x80, add_input, 0x40)\r\n            }\r\n            if (!success) {\r\n                return (false, proofsAandC, inputAccumulators);\r\n            }\r\n        }\r\n\r\n        proofsAandC[num_proofs*2] = add_input[0];\r\n        proofsAandC[num_proofs*2 + 1] = add_input[1];\r\n    }\r\n\r\n    function prepareBatches(\r\n        uint256[14] memory in_vk,\r\n        uint256[4] memory vk_gammaABC,\r\n        uint256[] memory inputAccumulators\r\n    ) internal view returns (\r\n        bool success,\r\n        uint256[4] memory finalVksAlphaX\r\n    ) {\r\n        // Compute the linear combination vk_x using accumulator\r\n        // First two fields are used as the sum and are initially zero\r\n        uint256[4] memory add_input;\r\n        uint256[3] memory mul_input;\r\n\r\n        // Performs a sum(gammaABC[i] * inputAccumulator[i])\r\n        for (uint256 i = 0; i < inputAccumulators.length; i++) {\r\n            mul_input[0] = vk_gammaABC[2*i];\r\n            mul_input[1] = vk_gammaABC[2*i + 1];\r\n            mul_input[2] = inputAccumulators[i];\r\n\r\n            assembly {\r\n                // ECMUL, output to the last 2 elements of `add_input`\r\n                success := staticcall(sub(gas, 2000), 7, mul_input, 0x60, add(add_input, 0x40), 0x40)\r\n            }\r\n            if (!success) {\r\n                return (false, finalVksAlphaX);\r\n            }\r\n\r\n            assembly {\r\n                // ECADD from four elements that are in add_input and output into first two elements of add_input\r\n                success := staticcall(sub(gas, 2000), 6, add_input, 0x80, add_input, 0x40)\r\n            }\r\n            if (!success) {\r\n                return (false, finalVksAlphaX);\r\n            }\r\n        }\r\n\r\n        finalVksAlphaX[2] = add_input[0];\r\n        finalVksAlphaX[3] = add_input[1];\r\n\r\n        // add one extra memory slot for scalar for multiplication usage\r\n        uint256[3] memory finalVKalpha;\r\n        finalVKalpha[0] = in_vk[0];\r\n        finalVKalpha[1] = in_vk[1];\r\n        finalVKalpha[2] = inputAccumulators[0];\r\n\r\n        assembly {\r\n            // ECMUL, output to first 2 elements of finalVKalpha\r\n            success := staticcall(sub(gas, 2000), 7, finalVKalpha, 0x60, finalVKalpha, 0x40)\r\n        }\r\n        if (!success) {\r\n            return (false, finalVksAlphaX);\r\n        }\r\n\r\n        finalVksAlphaX[0] = finalVKalpha[0];\r\n        finalVksAlphaX[1] = finalVKalpha[1];\r\n    }\r\n\r\n    // original equation\r\n    // e(proof.A, proof.B)*e(-vk.alpha, vk.beta)*e(-vk_x, vk.gamma)*e(-proof.C, vk.delta) == 1\r\n    // accumulation of inputs\r\n    // gammaABC[0] + sum[ gammaABC[i+1]^proof_inputs[i] ]\r\n\r\n    function BatchVerify (\r\n        uint256[14] memory in_vk, // verifying key is always constant number of elements\r\n        uint256[4] memory vk_gammaABC, // variable length, depends on number of inputs\r\n        uint256[] memory in_proof, // proof itself, length is 8 * num_proofs\r\n        uint256[] memory proof_inputs, // public inputs, length is num_inputs * num_proofs\r\n        uint256 num_proofs\r\n    )\r\n    internal\r\n    view\r\n    returns (bool success)\r\n    {\r\n        require(in_proof.length == num_proofs * 8, \"Invalid proofs length for a batch\");\r\n        require(proof_inputs.length % num_proofs == 0, \"Invalid inputs length for a batch\");\r\n        require(((vk_gammaABC.length / 2) - 1) == proof_inputs.length / num_proofs, \"Invalid verification key\");\r\n\r\n        // strategy is to accumulate entropy separately for some proof elements\r\n        // (accumulate only for G1, can't in G2) of the pairing equation, as well as input verification key,\r\n        // postpone scalar multiplication as much as possible and check only one equation\r\n        // by using 3 + num_proofs pairings only plus 2*num_proofs + (num_inputs+1) + 1 scalar multiplications compared to naive\r\n        // 4*num_proofs pairings and num_proofs*(num_inputs+1) scalar multiplications\r\n\r\n        bool valid;\r\n        uint256[] memory proofsAandC;\r\n        uint256[] memory inputAccumulators;\r\n        (valid, proofsAandC, inputAccumulators) = accumulate(in_proof, proof_inputs, num_proofs);\r\n        if (!valid) {\r\n            return false;\r\n        }\r\n\r\n        uint256[4] memory finalVksAlphaX;\r\n        (valid, finalVksAlphaX) = prepareBatches(in_vk, vk_gammaABC, inputAccumulators);\r\n        if (!valid) {\r\n            return false;\r\n        }\r\n\r\n        uint256[] memory inputs = new uint256[](6*num_proofs + 18);\r\n        // first num_proofs pairings e(ProofA, ProofB)\r\n        for (uint256 proofNumber = 0; proofNumber < num_proofs; proofNumber++) {\r\n            inputs[proofNumber*6] = proofsAandC[proofNumber*2];\r\n            inputs[proofNumber*6 + 1] = proofsAandC[proofNumber*2 + 1];\r\n            inputs[proofNumber*6 + 2] = in_proof[proofNumber*8 + 2];\r\n            inputs[proofNumber*6 + 3] = in_proof[proofNumber*8 + 3];\r\n            inputs[proofNumber*6 + 4] = in_proof[proofNumber*8 + 4];\r\n            inputs[proofNumber*6 + 5] = in_proof[proofNumber*8 + 5];\r\n        }\r\n\r\n        // second pairing e(-finalVKaplha, vk.beta)\r\n        inputs[num_proofs*6] = finalVksAlphaX[0];\r\n        inputs[num_proofs*6 + 1] = NegateY(finalVksAlphaX[1]);\r\n        inputs[num_proofs*6 + 2] = in_vk[2];\r\n        inputs[num_proofs*6 + 3] = in_vk[3];\r\n        inputs[num_proofs*6 + 4] = in_vk[4];\r\n        inputs[num_proofs*6 + 5] = in_vk[5];\r\n\r\n        // third pairing e(-finalVKx, vk.gamma)\r\n        inputs[num_proofs*6 + 6] = finalVksAlphaX[2];\r\n        inputs[num_proofs*6 + 7] = NegateY(finalVksAlphaX[3]);\r\n        inputs[num_proofs*6 + 8] = in_vk[6];\r\n        inputs[num_proofs*6 + 9] = in_vk[7];\r\n        inputs[num_proofs*6 + 10] = in_vk[8];\r\n        inputs[num_proofs*6 + 11] = in_vk[9];\r\n\r\n        // fourth pairing e(-proof.C, finalVKdelta)\r\n        inputs[num_proofs*6 + 12] = proofsAandC[num_proofs*2];\r\n        inputs[num_proofs*6 + 13] = NegateY(proofsAandC[num_proofs*2 + 1]);\r\n        inputs[num_proofs*6 + 14] = in_vk[10];\r\n        inputs[num_proofs*6 + 15] = in_vk[11];\r\n        inputs[num_proofs*6 + 16] = in_vk[12];\r\n        inputs[num_proofs*6 + 17] = in_vk[13];\r\n\r\n        uint256 inputsLength = inputs.length * 32;\r\n        uint[1] memory out;\r\n        require(inputsLength % 192 == 0, \"Inputs length should be multiple of 192 bytes\");\r\n\r\n        assembly {\r\n            success := staticcall(sub(gas, 2000), 8, add(inputs, 0x20), inputsLength, out, 0x20)\r\n        }\r\n        return success && out[0] == 1;\r\n    }\r\n}\r\n\r\n/// @title IBlockVerifier\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\ncontract IBlockVerifier\r\n{\r\n    // -- Events --\r\n\r\n    event CircuitRegistered(\r\n        uint8  indexed blockType,\r\n        bool           onchainDataAvailability,\r\n        uint16         blockSize,\r\n        uint8          blockVersion\r\n    );\r\n\r\n    event CircuitDisabled(\r\n        uint8  indexed blockType,\r\n        bool           onchainDataAvailability,\r\n        uint16         blockSize,\r\n        uint8          blockVersion\r\n    );\r\n\r\n    // -- Public functions --\r\n\r\n    /// @dev Sets the verifying key for the specified circuit.\r\n    ///      Every block permutation needs its own circuit and thus its own set of\r\n    ///      verification keys. Only a limited number of block sizes per block\r\n    ///      type are supported.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @param vk The verification key\r\n    function registerCircuit(\r\n        uint8    blockType,\r\n        bool     onchainDataAvailability,\r\n        uint16   blockSize,\r\n        uint8    blockVersion,\r\n        uint[18] calldata vk\r\n        )\r\n        external;\r\n\r\n    /// @dev Disables the use of the specified circuit.\r\n    ///      This will stop NEW blocks from using the given circuit, blocks that were already committed\r\n    ///      can still be verified.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    function disableCircuit(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external;\r\n\r\n    /// @dev Verify blocks with the given public data and proofs.\r\n    ///      Verifying a block makes sure all requests handled in the block\r\n    ///      are correctly handled by the operator.\r\n    /// @param blockType The type of block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @param publicInputs The hash of all the public data of the blocks\r\n    /// @param proofs The ZK proofs proving that the blocks are correct\r\n    /// @return True if the block is valid, false otherwise\r\n    function verifyProofs(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion,\r\n        uint[] calldata publicInputs,\r\n        uint[] calldata proofs\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Checks if a circuit with the specified parameters is registered.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @return True if the circuit is registered, false otherwise\r\n    function isCircuitRegistered(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Checks if a circuit can still be used to commit new blocks.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @return True if the circuit is enabled, false otherwise\r\n    function isCircuitEnabled(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n/// @title ILoopring\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract ILoopring is Claimable, ReentrancyGuard\r\n{\r\n    address public protocolRegistry;\r\n    address public lrcAddress;\r\n    uint    public exchangeCreationCostLRC;\r\n\r\n    event ExchangeInitialized(\r\n        uint    indexed exchangeId,\r\n        address indexed exchangeAddress,\r\n        address indexed owner,\r\n        address         operator,\r\n        bool            onchainDataAvailability\r\n    );\r\n\r\n    /// @dev Initialize and register an exchange.\r\n    ///      This function should only be callabled by the protocolRegistry contract.\r\n    ///      Also note that this function can only be called once per exchange instance.\r\n    /// @param  exchangeAddress The address of the exchange to initialize and register.\r\n    /// @param  exchangeId The unique exchange id.\r\n    /// @param  owner The owner of the exchange.\r\n    /// @param  operator The operator of the exchange.\r\n    /// @param  onchainDataAvailability True if \"Data Availability\" is turned on for this\r\n    ///         exchange. Note that this value can not be changed once the exchange is initialized.\r\n    /// @return exchangeId The id of the exchange.\r\n    function initializeExchange(\r\n        address exchangeAddress,\r\n        uint    exchangeId,\r\n        address owner,\r\n        address payable operator,\r\n        bool    onchainDataAvailability\r\n        )\r\n        external;\r\n}\r\n\r\n/// @title ILoopringV3\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract ILoopringV3 is ILoopring\r\n{\r\n    // == Events ==\r\n\r\n    event ExchangeStakeDeposited(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ExchangeStakeWithdrawn(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ExchangeStakeBurned(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ProtocolFeeStakeDeposited(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ProtocolFeeStakeWithdrawn(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event SettingsUpdated(\r\n        uint            time\r\n    );\r\n\r\n    // == Public Variables ==\r\n    struct Exchange\r\n    {\r\n        address exchangeAddress;\r\n        uint    exchangeStake;\r\n        uint    protocolFeeStake;\r\n    }\r\n\r\n    mapping (uint => Exchange) internal exchanges;\r\n\r\n    uint    public totalStake;\r\n\r\n    address public wethAddress;\r\n    address public exchangeDeployerAddress;\r\n    address public blockVerifierAddress;\r\n    address public downtimeCostCalculator;\r\n    uint    public maxWithdrawalFee;\r\n    uint    public withdrawalFineLRC;\r\n    uint    public tokenRegistrationFeeLRCBase;\r\n    uint    public tokenRegistrationFeeLRCDelta;\r\n    uint    public minExchangeStakeWithDataAvailability;\r\n    uint    public minExchangeStakeWithoutDataAvailability;\r\n    uint    public revertFineLRC;\r\n    uint8   public minProtocolTakerFeeBips;\r\n    uint8   public maxProtocolTakerFeeBips;\r\n    uint8   public minProtocolMakerFeeBips;\r\n    uint8   public maxProtocolMakerFeeBips;\r\n    uint    public targetProtocolTakerFeeStake;\r\n    uint    public targetProtocolMakerFeeStake;\r\n\r\n    address payable public protocolFeeVault;\r\n\r\n    // == Public Functions ==\r\n    /// @dev Update the global exchange settings.\r\n    ///      This function can only be called by the owner of this contract.\r\n    ///\r\n    ///      Warning: these new values will be used by existing and\r\n    ///      new Loopring exchanges.\r\n    function updateSettings(\r\n        address payable _protocolFeeVault,   // address(0) not allowed\r\n        address _blockVerifierAddress,       // address(0) not allowed\r\n        address _downtimeCostCalculator,     // address(0) allowed\r\n        uint    _exchangeCreationCostLRC,\r\n        uint    _maxWithdrawalFee,\r\n        uint    _tokenRegistrationFeeLRCBase,\r\n        uint    _tokenRegistrationFeeLRCDelta,\r\n        uint    _minExchangeStakeWithDataAvailability,\r\n        uint    _minExchangeStakeWithoutDataAvailability,\r\n        uint    _revertFineLRC,\r\n        uint    _withdrawalFineLRC\r\n        )\r\n        external;\r\n\r\n    /// @dev Update the global protocol fee settings.\r\n    ///      This function can only be called by the owner of this contract.\r\n    ///\r\n    ///      Warning: these new values will be used by existing and\r\n    ///      new Loopring exchanges.\r\n    function updateProtocolFeeSettings(\r\n        uint8 _minProtocolTakerFeeBips,\r\n        uint8 _maxProtocolTakerFeeBips,\r\n        uint8 _minProtocolMakerFeeBips,\r\n        uint8 _maxProtocolMakerFeeBips,\r\n        uint  _targetProtocolTakerFeeStake,\r\n        uint  _targetProtocolMakerFeeStake\r\n        )\r\n        external;\r\n\r\n    /// @dev Returns whether the Exchange has staked enough to commit blocks\r\n    ///      Exchanges with on-chain data-availaiblity need to stake at least\r\n    ///      minExchangeStakeWithDataAvailability, exchanges without\r\n    ///      data-availability need to stake at least\r\n    ///      minExchangeStakeWithoutDataAvailability.\r\n    /// @param exchangeId The id of the exchange\r\n    /// @param onchainDataAvailability True if the exchange has on-chain\r\n    ///        data-availability, else false\r\n    /// @return True if the exchange has staked enough, else false\r\n    function canExchangeCommitBlocks(\r\n        uint exchangeId,\r\n        bool onchainDataAvailability\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Get the amount of staked LRC for an exchange.\r\n    /// @param exchangeId The id of the exchange\r\n    /// @return stakedLRC The amount of LRC\r\n    function getExchangeStake(\r\n        uint exchangeId\r\n        )\r\n        public\r\n        view\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Burn a certain amount of staked LRC for a specific exchange.\r\n    ///      This function is meant to be called only from exchange contracts.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @return burnedLRC The amount of LRC burned. If the amount is greater than\r\n    ///         the staked amount, all staked LRC will be burned.\r\n    function burnExchangeStake(\r\n        uint exchangeId,\r\n        uint amount\r\n        )\r\n        external\r\n        returns (uint burnedLRC);\r\n\r\n    /// @dev Stake more LRC for an exchange.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  amountLRC The amount of LRC to stake\r\n    /// @return stakedLRC The total amount of LRC staked for the exchange\r\n    function depositExchangeStake(\r\n        uint exchangeId,\r\n        uint amountLRC\r\n        )\r\n        external\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Withdraw a certain amount of staked LRC for an exchange to the given address.\r\n    ///      This function is meant to be called only from within exchange contracts.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  recipient The address to receive LRC\r\n    /// @param  requestedAmount The amount of LRC to withdraw\r\n    /// @return stakedLRC The amount of LRC withdrawn\r\n    function withdrawExchangeStake(\r\n        uint    exchangeId,\r\n        address recipient,\r\n        uint    requestedAmount\r\n        )\r\n        external\r\n        returns (uint amount);\r\n\r\n    /// @dev Stake more LRC for an exchange.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  amountLRC The amount of LRC to stake\r\n    /// @return stakedLRC The total amount of LRC staked for the exchange\r\n    function depositProtocolFeeStake(\r\n        uint exchangeId,\r\n        uint amountLRC\r\n        )\r\n        external\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Withdraw a certain amount of staked LRC for an exchange to the given address.\r\n    ///      This function is meant to be called only from within exchange contracts.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  recipient The address to receive LRC\r\n    /// @param  amount The amount of LRC to withdraw\r\n    function withdrawProtocolFeeStake(\r\n        uint    exchangeId,\r\n        address recipient,\r\n        uint    amount\r\n        )\r\n        external;\r\n\r\n    /// @dev Get the protocol fee values for an exchange.\r\n    /// @param exchangeId The id of the exchange\r\n    /// @param onchainDataAvailability True if the exchange has on-chain\r\n    ///        data-availability, else false\r\n    /// @return takerFeeBips The protocol taker fee\r\n    /// @return makerFeeBips The protocol maker fee\r\n    function getProtocolFeeValues(\r\n        uint exchangeId,\r\n        bool onchainDataAvailability\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint8 takerFeeBips,\r\n            uint8 makerFeeBips\r\n        );\r\n\r\n    /// @dev Returns the exchange's protocol fee stake.\r\n    /// @param  exchangeId The exchange's id.\r\n    /// @return protocolFeeStake The exchange's protocol fee stake.\r\n    function getProtocolFeeStake(\r\n        uint exchangeId\r\n        )\r\n        external\r\n        view\r\n        returns (uint protocolFeeStake);\r\n}\r\n\r\n/// @title ExchangeData\r\n/// @dev All methods in this lib are internal, therefore, there is no need\r\n///      to deploy this library independently.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeData\r\n{\r\n    // -- Enums --\r\n    enum BlockType\r\n    {\r\n        RING_SETTLEMENT,\r\n        DEPOSIT,\r\n        ONCHAIN_WITHDRAWAL,\r\n        OFFCHAIN_WITHDRAWAL,\r\n        ORDER_CANCELLATION,\r\n        TRANSFER\r\n    }\r\n\r\n    enum BlockState\r\n    {\r\n        // This value should never be seen onchain, but we want to reserve 0 so the\r\n        // relayer can use this as the default for new blocks.\r\n        NEW,            // = 0\r\n\r\n        // The default state when a new block is included onchain.\r\n        COMMITTED,      // = 1\r\n\r\n        // A valid ZK proof has been submitted for this block.\r\n        // The genesis block is VERIFIED by default.\r\n        VERIFIED        // = 2\r\n    }\r\n\r\n    // -- Structs --\r\n    struct Account\r\n    {\r\n        address owner;\r\n\r\n        // pubKeyX and pubKeyY put together is the EdDSA public trading key. Users or their\r\n        // wallet software are supposed to manage the corresponding private key for signing\r\n        // orders and offchain requests.\r\n        //\r\n        // We use EdDSA because it is more circuit friendly than ECDSA. In later versions\r\n        // we may switch back to ECDSA, then we will not need such a dedicated tradig key-pair.\r\n        //\r\n        // We split the public key into two uint to make it more circuit friendly.\r\n        uint    pubKeyX;\r\n        uint    pubKeyY;\r\n    }\r\n\r\n    struct Token\r\n    {\r\n        address token;\r\n        bool    depositDisabled;\r\n    }\r\n\r\n    struct ProtocolFeeData\r\n    {\r\n        uint32 timestamp;\r\n        uint8 takerFeeBips;\r\n        uint8 makerFeeBips;\r\n        uint8 previousTakerFeeBips;\r\n        uint8 previousMakerFeeBips;\r\n    }\r\n\r\n    // This is the (virtual) block an operator needs to submit onchain to maintain the\r\n    // per-exchange (virtual) blockchain.\r\n    struct Block\r\n    {\r\n        // The merkle root of the offchain data stored in a merkle tree. The merkle tree\r\n        // stores balances for users using an account model.\r\n        bytes32 merkleRoot;\r\n\r\n        // The hash of all the public data sent in commitBlock. Committing a block\r\n        // is decoupled from the verification of a block, but we don't want to send\r\n        // the (often) large amount of data (certainly with onchain data availability) again\r\n        // when verifying the proof, so we hash all that data onchain in commitBlock so that we\r\n        // can use it in verifyBlock to verify the block. This also makes the verification cheaper\r\n        // onchain because we only have this single public input.\r\n        bytes32 publicDataHash;\r\n\r\n        // The current state of the block. See @BlockState for more information.\r\n        BlockState state;\r\n\r\n        // The type of the block (i.e. what kind of requests were processed).\r\n        // See @BlockType for more information.\r\n        BlockType blockType;\r\n\r\n        // The number of requests processed in the block. Only a limited number of permutations\r\n        // are available for each block type (because each will need a different circuit\r\n        // and thus different verification key onchain). Use IBlockVerifier.canVerify to find out if\r\n        // the block is supported.\r\n        uint16 blockSize;\r\n\r\n        // The block version (i.e. what circuit version needs to be used to verify the block).\r\n        uint8  blockVersion;\r\n\r\n        // The time the block was created.\r\n        uint32 timestamp;\r\n\r\n        // The number of onchain deposit requests that have been processed\r\n        // up to and including this block.\r\n        uint32 numDepositRequestsCommitted;\r\n\r\n        // The number of onchain withdrawal requests that have been processed\r\n        // up to and including this block.\r\n        uint32 numWithdrawalRequestsCommitted;\r\n\r\n        // Stores whether the fee earned by the operator for processing onchain requests\r\n        // is withdrawn or not.\r\n        bool   blockFeeWithdrawn;\r\n\r\n        // Number of withdrawals distributed using `distributeWithdrawals`\r\n        uint16 numWithdrawalsDistributed;\r\n\r\n        // The approved withdrawal data. Needs to be stored onchain so this data is available\r\n        // once the block is finalized and the funds can be withdrawn using the info stored\r\n        // in this data.\r\n        // For every withdrawal (there are 'blockSize' withdrawals),\r\n        // stored sequentially after each other:\r\n        //    - Token ID: 1 bytes\r\n        //    - Account ID: 2,5 bytes\r\n        //    - Amount: 3,5 bytes\r\n        bytes  withdrawals;\r\n    }\r\n\r\n    // Represents the post-state of an onchain deposit/withdrawal request. We can visualize\r\n    // a deposit request-chain and a withdrawal request-chain, each of which is\r\n    // composed of such Request objects. Please refer to the design doc for more details.\r\n    struct Request\r\n    {\r\n        bytes32 accumulatedHash;\r\n        uint    accumulatedFee;\r\n        uint32  timestamp;\r\n    }\r\n\r\n    // Represents an onchain deposit request.  `tokenID` being `0x0` means depositing Ether.\r\n    struct Deposit\r\n    {\r\n        uint24 accountID;\r\n        uint16 tokenID;\r\n        uint96 amount;\r\n    }\r\n\r\n    function SNARK_SCALAR_FIELD() internal pure returns (uint) {\r\n        // This is the prime number that is used for the alt_bn128 elliptic curve, see EIP-196.\r\n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    }\r\n\r\n    function MAX_PROOF_GENERATION_TIME_IN_SECONDS() internal pure returns (uint32) { return 1 hours; }\r\n    function MAX_GAP_BETWEEN_FINALIZED_AND_VERIFIED_BLOCKS() internal pure returns (uint32) { return 2500; }\r\n    function MAX_OPEN_DEPOSIT_REQUESTS() internal pure returns (uint16) { return 1024; }\r\n    function MAX_OPEN_WITHDRAWAL_REQUESTS() internal pure returns (uint16) { return 1024; }\r\n    function MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 1 days; }\r\n    function MAX_AGE_REQUEST_UNTIL_FORCED() internal pure returns (uint32) { return 15 minutes; }\r\n    function MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 1 days; }\r\n    function MAX_TIME_IN_SHUTDOWN_BASE() internal pure returns (uint32) { return 1 days; }\r\n    function MAX_TIME_IN_SHUTDOWN_DELTA() internal pure returns (uint32) { return 15 seconds; }\r\n    function TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() internal pure returns (uint32) { return 10 minutes; }\r\n    function MAX_NUM_TOKENS() internal pure returns (uint) { return 2 ** 8; }\r\n    function MAX_NUM_ACCOUNTS() internal pure returns (uint) { return 2 ** 20 - 1; }\r\n    function MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 2 hours; }\r\n    function FEE_BLOCK_FINE_START_TIME() internal pure returns (uint32) { return 5 minutes; }\r\n    function FEE_BLOCK_FINE_MAX_DURATION() internal pure returns (uint32) { return 30 minutes; }\r\n    function MIN_GAS_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 60000; }\r\n    function MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED() internal pure returns (uint32) { return 1 days; }\r\n    function GAS_LIMIT_SEND_TOKENS() internal pure returns (uint32) { return 30000; }\r\n\r\n    // Represents the entire exchange state except the owner of the exchange.\r\n    struct State\r\n    {\r\n        uint    id;\r\n        uint    exchangeCreationTimestamp;\r\n        address payable operator; // The only address that can submit new blocks.\r\n        bool    onchainDataAvailability;\r\n\r\n        ILoopringV3    loopring;\r\n        IBlockVerifier blockVerifier;\r\n\r\n        address lrcAddress;\r\n\r\n        uint    totalTimeInMaintenanceSeconds;\r\n        uint    numDowntimeMinutes;\r\n        uint    downtimeStart;\r\n\r\n        address addressWhitelist;\r\n        uint    accountCreationFeeETH;\r\n        uint    accountUpdateFeeETH;\r\n        uint    depositFeeETH;\r\n        uint    withdrawalFeeETH;\r\n\r\n        Block[]     blocks;\r\n        Token[]     tokens;\r\n        Account[]   accounts;\r\n        Deposit[]   deposits;\r\n        Request[]   depositChain;\r\n        Request[]   withdrawalChain;\r\n\r\n        // A map from the account owner to accountID + 1\r\n        mapping (address => uint24) ownerToAccountId;\r\n        mapping (address => uint16) tokenToTokenId;\r\n\r\n        // A map from an account owner to a token to if the balance is withdrawn\r\n        mapping (address => mapping (address => bool)) withdrawnInWithdrawMode;\r\n\r\n        // A map from token address to their accumulated balances\r\n        mapping (address => uint) tokenBalances;\r\n\r\n        // A block's state will become FINALIZED when and only when this block is VERIFIED\r\n        // and all previous blocks in the chain have become FINALIZED.\r\n        // The genesis block is FINALIZED by default.\r\n        uint numBlocksFinalized;\r\n\r\n        // Cached data for the protocol fee\r\n        ProtocolFeeData protocolFeeData;\r\n\r\n        // Time when the exchange was shutdown\r\n        uint shutdownStartTime;\r\n    }\r\n}\r\n\r\n/// @title An Implementation of IBlockVerifier.\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\ncontract BlockVerifier is Claimable, ReentrancyGuard, IBlockVerifier\r\n{\r\n    struct Circuit\r\n    {\r\n        bool registered;\r\n        bool enabled;\r\n        uint[18] verificationKey;\r\n    }\r\n\r\n    mapping (bool => mapping (uint8 => mapping (uint16 => mapping (uint8 => Circuit)))) public circuits;\r\n\r\n    constructor() Claimable() public {}\r\n\r\n    function registerCircuit(\r\n        uint8    blockType,\r\n        bool     onchainDataAvailability,\r\n        uint16   blockSize,\r\n        uint8    blockVersion,\r\n        uint[18] calldata vk\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n    {\r\n        bool dataAvailability = needsDataAvailability(blockType, onchainDataAvailability);\r\n        require(dataAvailability == onchainDataAvailability, \"NO_DATA_AVAILABILITY_NEEDED\");\r\n        Circuit storage circuit = circuits[onchainDataAvailability][blockType][blockSize][blockVersion];\r\n        require(circuit.registered == false, \"ALREADY_REGISTERED\");\r\n\r\n        for (uint i = 0; i < 18; i++) {\r\n            circuit.verificationKey[i] = vk[i];\r\n        }\r\n        circuit.registered = true;\r\n        circuit.enabled = true;\r\n\r\n        emit CircuitRegistered(\r\n            blockType,\r\n            onchainDataAvailability,\r\n            blockSize,\r\n            blockVersion\r\n        );\r\n    }\r\n\r\n    function disableCircuit(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        nonReentrant\r\n        onlyOwner\r\n    {\r\n        Circuit storage circuit = circuits[onchainDataAvailability][blockType][blockSize][blockVersion];\r\n        require(circuit.registered == true, \"NOT_REGISTERED\");\r\n        require(circuit.enabled == true, \"ALREADY_DISABLED\");\r\n\r\n        circuit.enabled = false;\r\n\r\n        emit CircuitDisabled(\r\n            blockType,\r\n            onchainDataAvailability,\r\n            blockSize,\r\n            blockVersion\r\n        );\r\n    }\r\n\r\n    function verifyProofs(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion,\r\n        uint[] calldata publicInputs,\r\n        uint[] calldata proofs\r\n        )\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool dataAvailability = needsDataAvailability(blockType, onchainDataAvailability);\r\n        Circuit storage circuit = circuits[dataAvailability][blockType][blockSize][blockVersion];\r\n        require(circuit.registered == true, \"NOT_REGISTERED\");\r\n\r\n        uint[18] storage vk = circuit.verificationKey;\r\n        uint[14] memory _vk = [\r\n            vk[0], vk[1], vk[2], vk[3], vk[4], vk[5], vk[6],\r\n            vk[7], vk[8], vk[9], vk[10], vk[11], vk[12], vk[13]\r\n        ];\r\n        uint[4] memory _vk_gammaABC = [vk[14], vk[15], vk[16], vk[17]];\r\n\r\n        if (publicInputs.length == 1) {\r\n            return Verifier.Verify(_vk, _vk_gammaABC, proofs, publicInputs);\r\n        } else {\r\n            return BatchVerifier.BatchVerify(\r\n                _vk,\r\n                _vk_gammaABC,\r\n                proofs,\r\n                publicInputs,\r\n                publicInputs.length\r\n            );\r\n        }\r\n    }\r\n\r\n    function isCircuitRegistered(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool dataAvailability = needsDataAvailability(blockType, onchainDataAvailability);\r\n        return circuits[dataAvailability][blockType][blockSize][blockVersion].registered;\r\n    }\r\n\r\n    function isCircuitEnabled(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool dataAvailability = needsDataAvailability(blockType, onchainDataAvailability);\r\n        return circuits[dataAvailability][blockType][blockSize][blockVersion].enabled;\r\n    }\r\n\r\n    function needsDataAvailability(\r\n        uint8 blockType,\r\n        bool  onchainDataAvailability\r\n        )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // On-chain requests never need data-availability\r\n        return (\r\n            (blockType == uint(ExchangeData.BlockType.DEPOSIT)) ||\r\n            (blockType == uint(ExchangeData.BlockType.ONCHAIN_WITHDRAWAL))\r\n            ? false : onchainDataAvailability\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"onchainDataAvailability\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"publicInputs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"proofs\",\"type\":\"uint256[]\"}],\"name\":\"verifyProofs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"onchainDataAvailability\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"}],\"name\":\"isCircuitEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"onchainDataAvailability\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"}],\"name\":\"isCircuitRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"onchainDataAvailability\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"},{\"internalType\":\"uint256[18]\",\"name\":\"vk\",\"type\":\"uint256[18]\"}],\"name\":\"registerCircuit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"circuits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"onchainDataAvailability\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"}],\"name\":\"disableCircuit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"onchainDataAvailability\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"}],\"name\":\"CircuitRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"blockType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"onchainDataAvailability\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"blockSize\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"blockVersion\",\"type\":\"uint8\"}],\"name\":\"CircuitDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BlockVerifier","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://11817542707e049258c31055044e44692ee12510feca277569235a377b5f2ba3"}]}