{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract LibMath {\r\n    using SafeMath for uint256;\r\n\r\n    function getPartialAmount(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256 partialAmount)\r\n    {\r\n        partialAmount = numerator.mul(target).div(denominator);\r\n    }\r\n\r\n    function getFeeAmount(\r\n        uint256 numerator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256 feeAmount)\r\n    {\r\n        feeAmount = numerator.mul(target).div(1 ether); // todo: constants\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract LibOrder {\r\n\r\n    struct Order {\r\n        uint256 makerSellAmount;\r\n        uint256 makerBuyAmount;\r\n        uint256 takerSellAmount;\r\n        uint256 salt;\r\n        uint256 expiration;\r\n        address taker;\r\n        address maker;\r\n        address makerSellToken;\r\n        address makerBuyToken;\r\n    }\r\n\r\n    struct OrderInfo {\r\n        uint256 filledAmount;\r\n        bytes32 hash;\r\n        uint8 status;\r\n    }\r\n\r\n    struct OrderFill {\r\n        uint256 makerFillAmount;\r\n        uint256 takerFillAmount;\r\n        uint256 takerFeePaid;\r\n        uint256 exchangeFeeReceived;\r\n        uint256 referralFeeReceived;\r\n        uint256 makerFeeReceived;\r\n    }\r\n\r\n    enum OrderStatus {\r\n        INVALID_SIGNER,\r\n        INVALID_TAKER_AMOUNT,\r\n        INVALID_MAKER_AMOUNT,\r\n        FILLABLE,\r\n        EXPIRED,\r\n        FULLY_FILLED,\r\n        CANCELLED\r\n    }\r\n\r\n    function getHash(Order memory order)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                order.maker,\r\n                order.makerSellToken,\r\n                order.makerSellAmount,\r\n                order.makerBuyToken,\r\n                order.makerBuyAmount,\r\n                order.salt,\r\n                order.expiration\r\n            )\r\n        );\r\n    }\r\n\r\n    function getPrefixedHash(Order memory order)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        bytes32 orderHash = getHash(order);\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", orderHash));\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract LibSignatureValidator   {\r\n\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            // solium-disable-next-line arg-overflow\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract IKyberNetworkProxy {\r\n    function getExpectedRate(address src, address dest, uint srcQty) public view\r\n        returns (uint expectedRate, uint slippageRate);\r\n\r\n    function trade(\r\n        address src,\r\n        uint srcAmount,\r\n        address dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    ) public payable returns(uint256);\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract LibKyberData {\r\n\r\n    struct KyberData {\r\n        uint256 expectedReceiveAmount;\r\n        uint256 rate;\r\n        uint256 value;\r\n        address givenToken;\r\n        address receivedToken;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract IExchangeUpgradability {\r\n\r\n    uint8 public VERSION;\r\n\r\n    event FundsMigrated(address indexed user, address indexed newExchange);\r\n    \r\n    function allowOrRestrictMigrations() external;\r\n\r\n    function migrateFunds(address[] calldata tokens) external;\r\n\r\n    function migrateEthers() private;\r\n\r\n    function migrateTokens(address[] memory tokens) private;\r\n\r\n    function importEthers(address user) external payable;\r\n\r\n    function importTokens(address tokenAddress, uint256 tokenAmount, address user) external;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract LibCrowdsale {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct Crowdsale {\r\n        uint256 startBlock;\r\n        uint256 endBlock;\r\n        uint256 hardCap;\r\n        uint256 leftAmount;\r\n        uint256 tokenRatio;\r\n        uint256 minContribution;\r\n        uint256 maxContribution;\r\n        uint256 weiRaised;\r\n        address wallet;\r\n    }\r\n\r\n    enum ContributionStatus {\r\n        CROWDSALE_NOT_OPEN,\r\n        MIN_CONTRIBUTION,\r\n        MAX_CONTRIBUTION,\r\n        HARDCAP_REACHED,\r\n        VALID\r\n    }\r\n\r\n    enum CrowdsaleStatus {\r\n        INVALID_START_BLOCK,\r\n        INVALID_END_BLOCK,\r\n        INVALID_TOKEN_RATIO,\r\n        INVALID_LEFT_AMOUNT,\r\n        VALID\r\n    }\r\n\r\n    function getCrowdsaleStatus(Crowdsale memory crowdsale)\r\n        public\r\n        view\r\n        returns (CrowdsaleStatus)\r\n    {\r\n\r\n        if(crowdsale.startBlock < block.number) {\r\n            return CrowdsaleStatus.INVALID_START_BLOCK;\r\n        }\r\n\r\n        if(crowdsale.endBlock < crowdsale.startBlock) {\r\n            return CrowdsaleStatus.INVALID_END_BLOCK;\r\n        }\r\n\r\n        if(crowdsale.tokenRatio == 0) {\r\n            return CrowdsaleStatus.INVALID_TOKEN_RATIO;\r\n        }\r\n\r\n        uint256 tokenForSale = crowdsale.hardCap.mul(crowdsale.tokenRatio);\r\n\r\n        if(tokenForSale != crowdsale.leftAmount) {\r\n            return CrowdsaleStatus.INVALID_LEFT_AMOUNT;\r\n        }\r\n\r\n        return CrowdsaleStatus.VALID;\r\n    }\r\n\r\n    function isOpened(uint256 startBlock, uint256 endBlock)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (block.number >= startBlock && block.number <= endBlock);\r\n    }\r\n\r\n\r\n    function isFinished(uint256 endBlock)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return block.number > endBlock;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract ExchangeStorage is Ownable {\r\n\r\n    /**\r\n      * @dev The minimum fee rate that the maker will receive\r\n      * Note: 20% = 20 * 10^16\r\n      */\r\n    uint256 constant internal minMakerFeeRate = 200000000000000000;\r\n\r\n    /**\r\n      * @dev The maximum fee rate that the maker will receive\r\n      * Note: 90% = 90 * 10^16\r\n      */\r\n    uint256 constant internal maxMakerFeeRate = 900000000000000000;\r\n\r\n    /**\r\n      * @dev The minimum fee rate that the taker will pay\r\n      * Note: 0.1% = 0.1 * 10^16\r\n      */\r\n    uint256 constant internal minTakerFeeRate = 1000000000000000;\r\n\r\n    /**\r\n      * @dev The maximum fee rate that the taker will pay\r\n      * Note: 1% = 1 * 10^16\r\n      */\r\n    uint256 constant internal maxTakerFeeRate = 10000000000000000;\r\n\r\n    /**\r\n      * @dev The referrer will receive 10% from each taker fee.\r\n      * Note: 10% = 10 * 10^16\r\n      */\r\n    uint256 constant internal referralFeeRate = 100000000000000000;\r\n\r\n    /**\r\n      * @dev The amount of percentage the maker will receive from each taker fee.\r\n      * Note: Initially: 50% = 50 * 10^16\r\n      */\r\n    uint256 public makerFeeRate;\r\n\r\n    /**\r\n      * @dev The amount of percentage the will pay for taking an order.\r\n      * Note: Initially: 0.2% = 0.2 * 10^16\r\n      */\r\n    uint256 public takerFeeRate;\r\n\r\n    /**\r\n      * @dev 2-level map: tokenAddress -> userAddress -> balance\r\n      */\r\n    mapping(address => mapping(address => uint256)) internal balances;\r\n\r\n    /**\r\n      * @dev map: orderHash -> filled amount\r\n      */\r\n    mapping(bytes32 => uint256) internal filled;\r\n\r\n    /**\r\n      * @dev map: orderHash -> isCancelled\r\n      */\r\n    mapping(bytes32 => bool) internal cancelled;\r\n\r\n    /**\r\n      * @dev map: user -> userReferrer\r\n      */\r\n    mapping(address => address) internal referrals;\r\n\r\n    /**\r\n      * @dev The address where all exchange fees (0,08%) are kept.\r\n      * Node: multisig wallet\r\n      */\r\n    address public feeAccount;\r\n\r\n    /**\r\n      * @return return the balance of `token` for certain `user`\r\n      */\r\n    function getBalance(\r\n        address user,\r\n        address token\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balances[token][user];\r\n    }\r\n\r\n    /**\r\n      * @return return the balance of multiple tokens for certain `user`\r\n      */\r\n    function getBalances(\r\n        address user,\r\n        address[] memory token\r\n    )\r\n        public\r\n        view\r\n        returns(uint256[] memory balanceArray)\r\n    {\r\n        balanceArray = new uint256[](token.length);\r\n\r\n        for(uint256 index = 0; index < token.length; index++) {\r\n            balanceArray[index] = balances[token[index]][user];\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @return return the filled amount of order specified by `orderHash`\r\n      */\r\n    function getFill(\r\n        bytes32 orderHash\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return filled[orderHash];\r\n    }\r\n\r\n    /**\r\n      * @return return the filled amount of multple orders specified by `orderHash` array\r\n      */\r\n    function getFills(\r\n        bytes32[] memory orderHash\r\n    )\r\n        public\r\n        view\r\n        returns (uint256[] memory filledArray)\r\n    {\r\n        filledArray = new uint256[](orderHash.length);\r\n\r\n        for(uint256 index = 0; index < orderHash.length; index++) {\r\n            filledArray[index] = filled[orderHash[index]];\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @return return true(false) if order specified by `orderHash` is(not) cancelled\r\n      */\r\n    function getCancel(\r\n        bytes32 orderHash\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return cancelled[orderHash];\r\n    }\r\n\r\n    /**\r\n      * @return return array of true(false) if orders specified by `orderHash` array are(not) cancelled\r\n      */\r\n    function getCancels(\r\n        bytes32[] memory orderHash\r\n    )\r\n        public\r\n        view\r\n        returns (bool[]memory cancelledArray)\r\n    {\r\n        cancelledArray = new bool[](orderHash.length);\r\n\r\n        for(uint256 index = 0; index < orderHash.length; index++) {\r\n            cancelledArray[index] = cancelled[orderHash[index]];\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @return return the referrer address of `user`\r\n      */\r\n    function getReferral(\r\n        address user\r\n    )\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return referrals[user];\r\n    }\r\n\r\n    /**\r\n      * @return set new rate for the maker fee received\r\n      */\r\n    function setMakerFeeRate(\r\n        uint256 newMakerFeeRate\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            newMakerFeeRate >= minMakerFeeRate &&\r\n            newMakerFeeRate <= maxMakerFeeRate,\r\n            \"INVALID_MAKER_FEE_RATE\"\r\n        );\r\n        makerFeeRate = newMakerFeeRate;\r\n    }\r\n\r\n    /**\r\n      * @return set new rate for the taker fee paid\r\n      */\r\n    function setTakerFeeRate(\r\n        uint256 newTakerFeeRate\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            newTakerFeeRate >= minTakerFeeRate &&\r\n            newTakerFeeRate <= maxTakerFeeRate,\r\n            \"INVALID_TAKER_FEE_RATE\"\r\n        );\r\n\r\n        takerFeeRate = newTakerFeeRate;\r\n    }\r\n\r\n    /**\r\n      * @return set new fee account\r\n      */\r\n    function setFeeAccount(\r\n        address newFeeAccount\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        feeAccount = newFeeAccount;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract Exchange is LibMath, LibOrder, LibSignatureValidator, ExchangeStorage {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n      * @dev emitted when a trade is executed\r\n      */\r\n    event Trade(\r\n        address indexed makerAddress,        // Address that created the order\r\n        address indexed takerAddress,        // Address that filled the order\r\n        bytes32 indexed orderHash,           // Hash of the order\r\n        address makerFilledAsset,            // Address of assets filled for maker\r\n        address takerFilledAsset,            // Address of assets filled for taker\r\n        uint256 makerFilledAmount,           // Amount of assets filled for maker\r\n        uint256 takerFilledAmount,           // Amount of assets filled for taker\r\n        uint256 takerFeePaid,                // Amount of fee paid by the taker\r\n        uint256 makerFeeReceived,            // Amount of fee received by the maker\r\n        uint256 referralFeeReceived          // Amount of fee received by the referrer\r\n    );\r\n\r\n    /**\r\n      * @dev emitted when a cancel order is executed\r\n      */\r\n    event Cancel(\r\n        address indexed makerBuyToken,        // Address of asset being bought.\r\n        address makerSellToken,               // Address of asset being sold.\r\n        address indexed maker,                // Address that created the order\r\n        bytes32 indexed orderHash             // Hash of the order\r\n    );\r\n\r\n    /**\r\n      * @dev Compute the status of an order.\r\n      * Should be called before a contract execution is performet in order to not waste gas.\r\n      * @return OrderStatus.FILLABLE if the order is valid for taking.\r\n      * Note: See LibOrder.sol to see all statuses\r\n      */\r\n    function getOrderInfo(\r\n        uint256 partialAmount,\r\n        Order memory order\r\n    )\r\n        public\r\n        view\r\n        returns (OrderInfo memory orderInfo)\r\n    {\r\n        // Compute the order hash\r\n        orderInfo.hash = getPrefixedHash(order);\r\n\r\n        // Fetch filled amount\r\n        orderInfo.filledAmount = filled[orderInfo.hash];\r\n\r\n        // Check taker balance\r\n        if(balances[order.makerBuyToken][order.taker] < order.takerSellAmount) {\r\n            orderInfo.status = uint8(OrderStatus.INVALID_TAKER_AMOUNT);\r\n            return orderInfo;\r\n        }\r\n\r\n        // Check maker balance\r\n        if(balances[order.makerSellToken][order.maker] < partialAmount) {\r\n            orderInfo.status = uint8(OrderStatus.INVALID_MAKER_AMOUNT);\r\n            return orderInfo;\r\n        }\r\n\r\n        // Check if order is filled\r\n        if (orderInfo.filledAmount.add(order.takerSellAmount) > order.makerBuyAmount) {\r\n            orderInfo.status = uint8(OrderStatus.FULLY_FILLED);\r\n            return orderInfo;\r\n        }\r\n\r\n        // Check for expiration\r\n        if (block.number >= order.expiration) {\r\n            orderInfo.status = uint8(OrderStatus.EXPIRED);\r\n            return orderInfo;\r\n        }\r\n\r\n        // Check if order has been cancelled\r\n        if (cancelled[orderInfo.hash]) {\r\n            orderInfo.status = uint8(OrderStatus.CANCELLED);\r\n            return orderInfo;\r\n        }\r\n\r\n        orderInfo.status = uint8(OrderStatus.FILLABLE);\r\n        return orderInfo;\r\n    }\r\n\r\n    /**\r\n      * @dev Execute a trade based on the input order and signature.\r\n      * Reverts if order is not valid\r\n      */\r\n    function trade(\r\n        Order memory order,\r\n        bytes memory signature\r\n    )\r\n        public\r\n    {\r\n        bool result = _trade(order, signature);\r\n        require(result, \"INVALID_TRADE\");\r\n    }\r\n\r\n    /**\r\n      * @dev Execute a trade based on the input order and signature.\r\n      * If the order is valid returns true.\r\n      */\r\n    function _trade(\r\n        Order memory order,\r\n        bytes memory signature\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        order.taker = msg.sender;\r\n\r\n        uint256 takerReceivedAmount = getPartialAmount(\r\n            order.makerSellAmount,\r\n            order.makerBuyAmount,\r\n            order.takerSellAmount\r\n        );\r\n\r\n        OrderInfo memory orderInfo = getOrderInfo(takerReceivedAmount, order);\r\n\r\n        uint8 status = assertTakeOrder(orderInfo.hash, orderInfo.status, order.maker, signature);\r\n\r\n        if(status != uint8(OrderStatus.FILLABLE)) {\r\n            return false;\r\n        }\r\n\r\n        OrderFill memory orderFill = getOrderFillResult(takerReceivedAmount, order);\r\n\r\n        executeTrade(order, orderFill);\r\n\r\n        filled[orderInfo.hash] = filled[orderInfo.hash].add(order.takerSellAmount);\r\n\r\n        emit Trade(\r\n            order.maker,\r\n            order.taker,\r\n            orderInfo.hash,\r\n            order.makerBuyToken,\r\n            order.makerSellToken,\r\n            orderFill.makerFillAmount,\r\n            orderFill.takerFillAmount,\r\n            orderFill.takerFeePaid,\r\n            orderFill.makerFeeReceived,\r\n            orderFill.referralFeeReceived\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * @dev Cancel an order if msg.sender is the order signer.\r\n      */\r\n    function cancelSingleOrder(\r\n        Order memory order,\r\n        bytes memory signature\r\n    )\r\n        public\r\n    {\r\n        bytes32 orderHash = getPrefixedHash(order);\r\n\r\n        require(\r\n            recover(orderHash, signature) == msg.sender,\r\n            \"INVALID_SIGNER\"\r\n        );\r\n\r\n        require(\r\n            cancelled[orderHash] == false,\r\n            \"ALREADY_CANCELLED\"\r\n        );\r\n\r\n        cancelled[orderHash] = true;\r\n\r\n        emit Cancel(\r\n            order.makerBuyToken,\r\n            order.makerSellToken,\r\n            msg.sender,\r\n            orderHash\r\n        );\r\n    }\r\n\r\n    /**\r\n      * @dev Computation of the following properties based on the order input:\r\n      * takerFillAmount -> amount of assets received by the taker\r\n      * makerFillAmount -> amount of assets received by the maker\r\n      * takerFeePaid -> amount of fee paid by the taker (0.2% of takerFillAmount)\r\n      * makerFeeReceived -> amount of fee received by the maker (50% of takerFeePaid)\r\n      * referralFeeReceived -> amount of fee received by the taker referrer (10% of takerFeePaid)\r\n      * exchangeFeeReceived -> amount of fee received by the exchange (40% of takerFeePaid)\r\n      */\r\n    function getOrderFillResult(\r\n        uint256 takerReceivedAmount,\r\n        Order memory order\r\n    )\r\n        internal\r\n        view\r\n        returns (OrderFill memory orderFill)\r\n    {\r\n        orderFill.takerFillAmount = takerReceivedAmount;\r\n\r\n        orderFill.makerFillAmount = order.takerSellAmount;\r\n\r\n        // 0.2% == 0.2*10^16\r\n        orderFill.takerFeePaid = getFeeAmount(\r\n            takerReceivedAmount,\r\n            takerFeeRate\r\n        );\r\n\r\n        // 50% of taker fee == 50*10^16\r\n        orderFill.makerFeeReceived = getFeeAmount(\r\n            orderFill.takerFeePaid,\r\n            makerFeeRate\r\n        );\r\n\r\n        // 10% of taker fee == 10*10^16\r\n        orderFill.referralFeeReceived = getFeeAmount(\r\n            orderFill.takerFeePaid,\r\n            referralFeeRate\r\n        );\r\n\r\n        // exchangeFee = (takerFeePaid - makerFeeReceived - referralFeeReceived)\r\n        orderFill.exchangeFeeReceived = orderFill.takerFeePaid.sub(\r\n            orderFill.makerFeeReceived).sub(\r\n                orderFill.referralFeeReceived);\r\n\r\n    }\r\n\r\n    /**\r\n      * @dev Throws when the order status is invalid or the signer is not valid.\r\n      */\r\n    function assertTakeOrder(\r\n        bytes32 orderHash,\r\n        uint8 status,\r\n        address signer,\r\n        bytes memory signature\r\n    )\r\n        internal\r\n        pure\r\n        returns(uint8)\r\n    {\r\n        uint8 result = uint8(OrderStatus.FILLABLE);\r\n\r\n        if(recover(orderHash, signature) != signer) {\r\n            result = uint8(OrderStatus.INVALID_SIGNER);\r\n        }\r\n\r\n        if(status != uint8(OrderStatus.FILLABLE)) {\r\n            result = status;\r\n        }\r\n\r\n        return status;\r\n    }\r\n\r\n    /**\r\n      * @dev Updates the contract state i.e. user balances\r\n      */\r\n    function executeTrade(\r\n        Order memory order,\r\n        OrderFill memory orderFill\r\n    )\r\n        private\r\n    {\r\n        uint256 makerGiveAmount = orderFill.takerFillAmount.sub(orderFill.makerFeeReceived);\r\n        uint256 takerFillAmount = orderFill.takerFillAmount.sub(orderFill.takerFeePaid);\r\n\r\n        address referrer = referrals[order.taker];\r\n        address feeAddress = feeAccount;\r\n\r\n        balances[order.makerSellToken][referrer] = balances[order.makerSellToken][referrer].add(orderFill.referralFeeReceived);\r\n        balances[order.makerSellToken][feeAddress] = balances[order.makerSellToken][feeAddress].add(orderFill.exchangeFeeReceived);\r\n\r\n        balances[order.makerBuyToken][order.taker] = balances[order.makerBuyToken][order.taker].sub(orderFill.makerFillAmount);\r\n        balances[order.makerBuyToken][order.maker] = balances[order.makerBuyToken][order.maker].add(orderFill.makerFillAmount);\r\n\r\n        balances[order.makerSellToken][order.taker] = balances[order.makerSellToken][order.taker].add(takerFillAmount);\r\n        balances[order.makerSellToken][order.maker] = balances[order.makerSellToken][order.maker].sub(makerGiveAmount);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract ExchangeKyberProxy is Exchange, LibKyberData {\r\n    using SafeERC20 for IERC20;\r\n\r\n    /**\r\n      * @dev The precision used for calculating the amounts - 10*18\r\n      */\r\n    uint256 constant internal PRECISION = 1000000000000000000;\r\n\r\n    /**\r\n      * @dev Max decimals allowed when calculating amounts.\r\n      */\r\n    uint256 constant internal MAX_DECIMALS = 18;\r\n\r\n    /**\r\n      * @dev Decimals of Ether.\r\n      */\r\n    uint256 constant internal ETH_DECIMALS = 18;\r\n\r\n    /**\r\n      * @dev The address that represents ETH in Kyber Network Contracts.\r\n      */\r\n    address constant internal KYBER_ETH_TOKEN_ADDRESS =\r\n        address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n\r\n    /**\r\n      * @dev KyberNetworkProxy contract address\r\n      */\r\n    IKyberNetworkProxy constant internal kyberNetworkContract =\r\n        IKyberNetworkProxy(0x818E6FECD516Ecc3849DAf6845e3EC868087B755);\r\n\r\n    /**\r\n      * @dev Swaps ETH/TOKEN, TOKEN/ETH or TOKEN/TOKEN using KyberNetwork reserves.\r\n      */\r\n    function kyberSwap(\r\n        uint256 givenAmount,\r\n        address givenToken,\r\n        address receivedToken,\r\n        bytes32 hash\r\n    )\r\n        public\r\n        payable\r\n    {\r\n        address taker = msg.sender;\r\n\r\n        KyberData memory kyberData = getSwapInfo(\r\n            givenAmount,\r\n            givenToken,\r\n            receivedToken,\r\n            taker\r\n        );\r\n\r\n        uint256 convertedAmount = kyberNetworkContract.trade.value(kyberData.value)(\r\n            kyberData.givenToken,\r\n            givenAmount,\r\n            kyberData.receivedToken,\r\n            taker,\r\n            kyberData.expectedReceiveAmount,\r\n            kyberData.rate,\r\n            feeAccount\r\n        );\r\n\r\n        emit Trade(\r\n            address(kyberNetworkContract),\r\n            taker,\r\n            hash,\r\n            givenToken,\r\n            receivedToken,\r\n            givenAmount,\r\n            convertedAmount,\r\n            0,\r\n            0,\r\n            0\r\n        );\r\n    }\r\n\r\n    /**\r\n      * @dev Exchange ETH/TOKEN, TOKEN/ETH or TOKEN/TOKEN using the internal\r\n      * balance mapping that keeps track of user's balances. It requires user to first invoke deposit function.\r\n      * The function relies on KyberNetworkProxy contract.\r\n      */\r\n    function kyberTrade(\r\n        uint256 givenAmount,\r\n        address givenToken,\r\n        address receivedToken,\r\n        bytes32 hash\r\n    )\r\n        public\r\n    {\r\n        address taker = msg.sender;\r\n\r\n        KyberData memory kyberData = getTradeInfo(\r\n            givenAmount,\r\n            givenToken,\r\n            receivedToken\r\n        );\r\n\r\n        balances[givenToken][taker] = balances[givenToken][taker].sub(givenAmount);\r\n\r\n        uint256 convertedAmount = kyberNetworkContract.trade.value(kyberData.value)(\r\n            kyberData.givenToken,\r\n            givenAmount,\r\n            kyberData.receivedToken,\r\n            address(this),\r\n            kyberData.expectedReceiveAmount,\r\n            kyberData.rate,\r\n            feeAccount\r\n        );\r\n\r\n        balances[receivedToken][taker] = balances[receivedToken][taker].add(convertedAmount);\r\n\r\n        emit Trade(\r\n            address(kyberNetworkContract),\r\n            taker,\r\n            hash,\r\n            givenToken,\r\n            receivedToken,\r\n            givenAmount,\r\n            convertedAmount,\r\n            0,\r\n            0,\r\n            0\r\n        );\r\n    }\r\n\r\n    /**\r\n      * @dev Helper function to determine what is being swapped.\r\n      */\r\n    function getSwapInfo(\r\n        uint256 givenAmount,\r\n        address givenToken,\r\n        address receivedToken,\r\n        address taker\r\n    )\r\n        private\r\n        returns(KyberData memory)\r\n    {\r\n        KyberData memory kyberData;\r\n        uint256 givenTokenDecimals;\r\n        uint256 receivedTokenDecimals;\r\n\r\n        if(givenToken == address(0x0)) {\r\n            require(msg.value == givenAmount, \"INVALID_ETH_VALUE\");\r\n\r\n            kyberData.givenToken = KYBER_ETH_TOKEN_ADDRESS;\r\n            kyberData.receivedToken = receivedToken;\r\n            kyberData.value = givenAmount;\r\n\r\n            givenTokenDecimals = ETH_DECIMALS;\r\n            receivedTokenDecimals = IERC20(receivedToken).decimals();\r\n        } else if(receivedToken == address(0x0)) {\r\n            kyberData.givenToken = givenToken;\r\n            kyberData.receivedToken = KYBER_ETH_TOKEN_ADDRESS;\r\n            kyberData.value = 0;\r\n\r\n            givenTokenDecimals = IERC20(givenToken).decimals();\r\n            receivedTokenDecimals = ETH_DECIMALS;\r\n\r\n            IERC20(givenToken).safeTransferFrom(taker, address(this), givenAmount);\r\n            IERC20(givenToken).safeApprove(address(kyberNetworkContract), givenAmount);\r\n        } else {\r\n            kyberData.givenToken = givenToken;\r\n            kyberData.receivedToken = receivedToken;\r\n            kyberData.value = 0;\r\n\r\n            givenTokenDecimals = IERC20(givenToken).decimals();\r\n            receivedTokenDecimals = IERC20(receivedToken).decimals();\r\n\r\n            IERC20(givenToken).safeTransferFrom(taker, address(this), givenAmount);\r\n            IERC20(givenToken).safeApprove(address(kyberNetworkContract), givenAmount);\r\n        }\r\n\r\n        (kyberData.rate, ) = kyberNetworkContract.getExpectedRate(\r\n            kyberData.givenToken,\r\n            kyberData.receivedToken,\r\n            givenAmount\r\n        );\r\n\r\n        kyberData.expectedReceiveAmount = calculateExpectedAmount(\r\n            givenAmount,\r\n            givenTokenDecimals,\r\n            receivedTokenDecimals,\r\n            kyberData.rate\r\n        );\r\n\r\n        return kyberData;\r\n    }\r\n\r\n    /**\r\n      * @dev Helper function to determines what is being\r\n        swapped using the internal balance mapping.\r\n      */\r\n    function getTradeInfo(\r\n        uint256 givenAmount,\r\n        address givenToken,\r\n        address receivedToken\r\n    )\r\n        private\r\n        returns(KyberData memory)\r\n    {\r\n        KyberData memory kyberData;\r\n        uint256 givenTokenDecimals;\r\n        uint256 receivedTokenDecimals;\r\n\r\n        if(givenToken == address(0x0)) {\r\n            kyberData.givenToken = KYBER_ETH_TOKEN_ADDRESS;\r\n            kyberData.receivedToken = receivedToken;\r\n            kyberData.value = givenAmount;\r\n\r\n            givenTokenDecimals = ETH_DECIMALS;\r\n            receivedTokenDecimals = IERC20(receivedToken).decimals();\r\n        } else if(receivedToken == address(0x0)) {\r\n            kyberData.givenToken = givenToken;\r\n            kyberData.receivedToken = KYBER_ETH_TOKEN_ADDRESS;\r\n            kyberData.value = 0;\r\n\r\n            givenTokenDecimals = IERC20(givenToken).decimals();\r\n            receivedTokenDecimals = ETH_DECIMALS;\r\n            IERC20(givenToken).safeApprove(address(kyberNetworkContract), givenAmount);\r\n        } else {\r\n            kyberData.givenToken = givenToken;\r\n            kyberData.receivedToken = receivedToken;\r\n            kyberData.value = 0;\r\n\r\n            givenTokenDecimals = IERC20(givenToken).decimals();\r\n            receivedTokenDecimals = IERC20(receivedToken).decimals();\r\n            IERC20(givenToken).safeApprove(address(kyberNetworkContract), givenAmount);\r\n        }\r\n\r\n        (kyberData.rate, ) = kyberNetworkContract.getExpectedRate(\r\n            kyberData.givenToken,\r\n            kyberData.receivedToken,\r\n            givenAmount\r\n        );\r\n\r\n        kyberData.expectedReceiveAmount = calculateExpectedAmount(\r\n            givenAmount,\r\n            givenTokenDecimals,\r\n            receivedTokenDecimals,\r\n            kyberData.rate\r\n        );\r\n\r\n        return kyberData;\r\n    }\r\n\r\n    function getExpectedRateBatch(\r\n        address[] memory givenTokens,\r\n        address[] memory receivedTokens,\r\n        uint256[] memory givenAmounts\r\n    )\r\n        public\r\n        view\r\n        returns(uint256[] memory, uint256[] memory)\r\n    {\r\n        uint256 size = givenTokens.length;\r\n        uint256[] memory expectedRates = new uint256[](size);\r\n        uint256[] memory slippageRates = new uint256[](size);\r\n\r\n        for(uint256 index = 0; index < size; index++) {\r\n            (expectedRates[index], slippageRates[index]) = kyberNetworkContract.getExpectedRate(\r\n                givenTokens[index],\r\n                receivedTokens[index],\r\n                givenAmounts[index]\r\n            );\r\n        }\r\n\r\n       return (expectedRates, slippageRates);\r\n    }\r\n\r\n    /**\r\n      * @dev Helper function to get the expected amount based on\r\n      * the given token and the rate from the KyberNetworkProxy\r\n      */\r\n    function calculateExpectedAmount(\r\n        uint256 givenAmount,\r\n        uint256 givenDecimals,\r\n        uint256 receivedDecimals,\r\n        uint256 rate\r\n    )\r\n        internal\r\n        pure\r\n        returns(uint)\r\n    {\r\n        if (receivedDecimals >= givenDecimals) {\r\n            require(\r\n                (receivedDecimals - givenDecimals) <= MAX_DECIMALS,\r\n                \"MAX_DECIMALS_EXCEEDED\"\r\n            );\r\n\r\n            return (givenAmount * rate * (10 ** (receivedDecimals - givenDecimals)) ) / PRECISION;\r\n        } else {\r\n            require(\r\n                (givenDecimals - receivedDecimals) <= MAX_DECIMALS,\r\n                \"MAX_DECIMALS_EXCEEDED\"\r\n            );\r\n\r\n            return (givenAmount * rate) / (PRECISION * (10**(givenDecimals - receivedDecimals)));\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract ExchangeBatchTrade is Exchange {\r\n\r\n    /**\r\n      * @dev Cancel an array of orders if msg.sender is the order signer.\r\n      */\r\n    function cancelMultipleOrders(\r\n        Order[] memory orders,\r\n        bytes[] memory signatures\r\n    )\r\n        public\r\n    {\r\n        for (uint256 index = 0; index < orders.length; index++) {\r\n            cancelSingleOrder(\r\n                orders[index],\r\n                signatures[index]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @dev Execute multiple trades based on the input orders and signatures.\r\n      * Note: reverts of one or more trades fail.\r\n      */\r\n    function takeAllOrRevert(\r\n        Order[] memory orders,\r\n        bytes[] memory signatures\r\n    )\r\n        public\r\n    {\r\n        for (uint256 index = 0; index < orders.length; index++) {\r\n            bool result = _trade(orders[index], signatures[index]);\r\n            require(result, \"INVALID_TAKEALL\");\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @dev Execute multiple trades based on the input orders and signatures.\r\n      * Note: does not revert if one or more trades fail.\r\n      */\r\n    function takeAllPossible(\r\n        Order[] memory orders,\r\n        bytes[] memory signatures\r\n    )\r\n        public\r\n    {\r\n        for (uint256 index = 0; index < orders.length; index++) {\r\n            _trade(orders[index], signatures[index]);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract ExchangeMovements is ExchangeStorage {\r\n\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n      * @dev emitted when a deposit is received\r\n      */\r\n    event Deposit(\r\n        address indexed token,\r\n        address indexed user,\r\n        address indexed referral,\r\n        address beneficiary,\r\n        uint256 amount,\r\n        uint256 balance\r\n    );\r\n\r\n    /**\r\n      * @dev emitted when a withdraw is received\r\n      */\r\n    event Withdraw(\r\n        address indexed token,\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 balance\r\n    );\r\n\r\n    /**\r\n      * @dev emitted when a transfer is received\r\n      */\r\n    event Transfer(\r\n        address indexed token,\r\n        address indexed user,\r\n        address indexed beneficiary,\r\n        uint256 amount,\r\n        uint256 userBalance,\r\n        uint256 beneficiaryBalance\r\n    );\r\n\r\n    /**\r\n      * @dev Updates the level 2 map `balances` based on the input\r\n      *      Note: token address is (0x0) when the deposit is for ETH\r\n      */\r\n    function deposit(\r\n        address token,\r\n        uint256 amount,\r\n        address beneficiary,\r\n        address referral\r\n    )\r\n        public\r\n        payable\r\n    {\r\n        uint256 value = amount;\r\n        address user = msg.sender;\r\n\r\n        if(token == address(0x0)) {\r\n            value = msg.value;\r\n        } else {\r\n            IERC20(token).safeTransferFrom(user, address(this), value);\r\n        }\r\n\r\n        balances[token][beneficiary] = balances[token][beneficiary].add(value);\r\n\r\n        if(referrals[user] == address(0x0)) {\r\n            referrals[user] = referral;\r\n        }\r\n\r\n        emit Deposit(\r\n            token,\r\n            user,\r\n            referrals[user],\r\n            beneficiary,\r\n            value,\r\n            balances[token][beneficiary]\r\n        );\r\n    }\r\n\r\n    /**\r\n      * @dev Updates the level 2 map `balances` based on the input\r\n      *      Note: token address is (0x0) when the deposit is for ETH\r\n      */\r\n    function withdraw(\r\n        address token,\r\n        uint amount\r\n    )\r\n        public\r\n    {\r\n        address payable user = msg.sender;\r\n\r\n        require(\r\n            balances[token][user] >= amount,\r\n            \"INVALID_WITHDRAW\"\r\n        );\r\n\r\n        balances[token][user] = balances[token][user].sub(amount);\r\n\r\n        if (token == address(0x0)) {\r\n            user.transfer(amount);\r\n        } else {\r\n            IERC20(token).safeTransfer(user, amount);\r\n        }\r\n\r\n        emit Withdraw(\r\n            token,\r\n            user,\r\n            amount,\r\n            balances[token][user]\r\n        );\r\n    }\r\n\r\n    /**\r\n      * @dev Transfer assets between two users inside the exchange. Updates the level 2 map `balances`\r\n      */\r\n    function transfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        external\r\n        payable\r\n    {\r\n        address user = msg.sender;\r\n\r\n        require(\r\n            balances[token][user] >= amount,\r\n            \"INVALID_TRANSFER\"\r\n        );\r\n\r\n        balances[token][user] = balances[token][user].sub(amount);\r\n\r\n        balances[token][to] = balances[token][to].add(amount);\r\n\r\n        emit Transfer(\r\n            token,\r\n            user,\r\n            to,\r\n            amount,\r\n            balances[token][user],\r\n            balances[token][to]\r\n        );\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract ExchangeUpgradability is Ownable, ExchangeStorage {\r\n\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n      * @dev version of the exchange\r\n      */\r\n    uint8 constant public VERSION = 1;\r\n\r\n    /**\r\n      * @dev the address of the upgraded exchange contract\r\n      */\r\n    address public newExchange;\r\n\r\n    /**\r\n      * @dev flag to allow migrating to an upgraded contract\r\n      */\r\n    bool public migrationAllowed;\r\n\r\n    /**\r\n      * @dev emitted when funds are migrated\r\n      */\r\n    event FundsMigrated(address indexed user, address indexed newExchange);\r\n\r\n    /**\r\n    * @dev Owner can set the address of the new version of the exchange contract.\r\n    */\r\n    function setNewExchangeAddress(address exchange)\r\n        external\r\n        onlyOwner\r\n    {\r\n        newExchange = exchange;\r\n    }\r\n\r\n    /**\r\n    * @dev Enables/Disables the migrations. Can be called only by the owner.\r\n    */\r\n    function allowOrRestrictMigrations()\r\n        external\r\n        onlyOwner\r\n    {\r\n        migrationAllowed = !migrationAllowed;\r\n    }\r\n\r\n    /**\r\n    * @dev Migrating assets of the caller to the new exchange contract\r\n    */\r\n    function migrateFunds(address[] calldata tokens) external {\r\n\r\n        require(\r\n            false != migrationAllowed,\r\n            \"MIGRATIONS_DISALLOWED\"\r\n        );\r\n\r\n        require(\r\n            IExchangeUpgradability(newExchange).VERSION() > VERSION,\r\n            \"INVALID_VERSION\"\r\n        );\r\n\r\n        migrateEthers();\r\n\r\n        migrateTokens(tokens);\r\n\r\n        emit FundsMigrated(msg.sender, newExchange);\r\n    }\r\n\r\n    /**\r\n    * @dev Helper function to migrate user's Ethers. Should be called in migrateFunds() function.\r\n    */\r\n    function migrateEthers() private {\r\n        address user = msg.sender;\r\n        uint256 etherAmount = balances[address(0x0)][user];\r\n        if (etherAmount > 0) {\r\n            balances[address(0x0)][user] = 0;\r\n            IExchangeUpgradability(newExchange).importEthers.value(etherAmount)(user);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Helper function to migrate user's tokens. Should be called in migrateFunds() function.\r\n    */\r\n    function migrateTokens(address[] memory tokens) private {\r\n        address user = msg.sender;\r\n        address exchange = newExchange;\r\n        for (uint256 index = 0; index < tokens.length; index++) {\r\n\r\n            address tokenAddress = tokens[index];\r\n\r\n            uint256 tokenAmount = balances[tokenAddress][user];\r\n\r\n            if (0 == tokenAmount) {\r\n                continue;\r\n            }\r\n\r\n            IERC20(tokenAddress).safeApprove(exchange, tokenAmount);\r\n\r\n            balances[tokenAddress][user] = 0;\r\n\r\n            IExchangeUpgradability(exchange).importTokens(tokenAddress, tokenAmount, user);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Helper function to migrate user's Ethers. Should be called only from the new exchange contract.\r\n    */\r\n    function importEthers(address user)\r\n        external\r\n        payable\r\n    {\r\n        require(\r\n            false != migrationAllowed,\r\n            \"MIGRATION_DISALLOWED\"\r\n        );\r\n\r\n        require(\r\n            user != address(0x0),\r\n            \"INVALID_USER\"\r\n        );\r\n\r\n        require(\r\n            msg.value > 0,\r\n            \"INVALID_AMOUNT\"\r\n        );\r\n\r\n        require(\r\n            IExchangeUpgradability(msg.sender).VERSION() < VERSION,\r\n            \"INVALID_VERSION\"\r\n        );\r\n\r\n        balances[address(0x0)][user] = balances[address(0x0)][user].add(msg.value); // todo: constants\r\n    }\r\n    \r\n    /**\r\n    * @dev Helper function to migrate user's Tokens. Should be called only from the new exchange contract.\r\n    */\r\n    function importTokens(\r\n        address token,\r\n        uint256 amount,\r\n        address user\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            false != migrationAllowed,\r\n            \"MIGRATION_DISALLOWED\"\r\n        );\r\n\r\n        require(\r\n            token != address(0x0),\r\n            \"INVALID_TOKEN\"\r\n        );\r\n\r\n        require(\r\n            user != address(0x0),\r\n            \"INVALID_USER\"\r\n        );\r\n\r\n        require(\r\n            amount > 0,\r\n            \"INVALID_AMOUNT\"\r\n        );\r\n\r\n        require(\r\n            IExchangeUpgradability(msg.sender).VERSION() < VERSION,\r\n            \"INVALID_VERSION\"\r\n        );\r\n\r\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\r\n\r\n        balances[token][user] = balances[token][user].add(amount);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract ExchangeOffering is ExchangeStorage, LibCrowdsale {\r\n\r\n    address constant internal BURN_ADDRESS = address(0x000000000000000000000000000000000000dEaD);\r\n    address constant internal ETH_ADDRESS = address(0x0);\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => Crowdsale) public crowdsales;\r\n\r\n    mapping(address => mapping(address => uint256)) public contributions;\r\n\r\n    event TokenPurchase(\r\n        address indexed token,\r\n        address indexed user,\r\n        uint256 tokenAmount,\r\n        uint256 weiAmount\r\n    );\r\n\r\n    event TokenBurned(\r\n        address indexed token,\r\n        uint256 tokenAmount\r\n    );\r\n\r\n    function registerCrowdsale(\r\n        Crowdsale memory crowdsale,\r\n        address token\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(\r\n            CrowdsaleStatus.VALID == getCrowdsaleStatus(crowdsale),\r\n            \"INVALID_CROWDSALE\"\r\n        );\r\n\r\n        require(\r\n            crowdsales[token].wallet == address(0),\r\n            \"CROWDSALE_ALREADY_EXISTS\"\r\n        );\r\n\r\n        uint256 tokenForSale = crowdsale.hardCap.mul(crowdsale.tokenRatio);\r\n\r\n        IERC20(token).safeTransferFrom(crowdsale.wallet, address(this), tokenForSale);\r\n\r\n        crowdsales[token] = crowdsale;\r\n    }\r\n\r\n    function buyTokens(address token)\r\n       public\r\n       payable\r\n    {\r\n        require(msg.value != 0, \"INVALID_MSG_VALUE\");\r\n\r\n        uint256 weiAmount = msg.value;\r\n\r\n        address user = msg.sender;\r\n\r\n        Crowdsale memory crowdsale = crowdsales[token];\r\n\r\n        require(\r\n            ContributionStatus.VALID == validContribution(weiAmount, crowdsale, user, token),\r\n            \"INVALID_CONTRIBUTION\"\r\n        );\r\n\r\n        uint256 purchasedTokens = weiAmount.mul(crowdsale.tokenRatio);\r\n\r\n        crowdsale.leftAmount = crowdsale.leftAmount.sub(purchasedTokens);\r\n\r\n        crowdsale.weiRaised = crowdsale.weiRaised.add(weiAmount);\r\n\r\n        balances[ETH_ADDRESS][crowdsale.wallet] = balances[ETH_ADDRESS][crowdsale.wallet].add(weiAmount);\r\n\r\n        balances[token][user] = balances[token][user].add(purchasedTokens);\r\n\r\n        contributions[token][user] = contributions[token][user].add(weiAmount);\r\n\r\n        crowdsales[token] = crowdsale;\r\n\r\n        emit TokenPurchase(token, user, purchasedTokens, weiAmount);\r\n    }\r\n\r\n    function burnTokensWhenFinished(address token) public\r\n    {\r\n        require(\r\n            isFinished(crowdsales[token].endBlock),\r\n            \"CROWDSALE_NOT_FINISHED_YET\"\r\n        );\r\n\r\n        uint256 leftAmount = crowdsales[token].leftAmount;\r\n\r\n        crowdsales[token].leftAmount = 0;\r\n\r\n        IERC20(token).safeTransfer(BURN_ADDRESS, leftAmount);\r\n\r\n        emit TokenBurned(token, leftAmount);\r\n    }\r\n\r\n    function validContribution(\r\n        uint256 weiAmount,\r\n        Crowdsale memory crowdsale,\r\n        address user,\r\n        address token\r\n    )\r\n        public\r\n        view\r\n        returns(ContributionStatus)\r\n    {\r\n        if (!isOpened(crowdsale.startBlock, crowdsale.endBlock)) {\r\n            return ContributionStatus.CROWDSALE_NOT_OPEN;\r\n        }\r\n\r\n        if(weiAmount < crowdsale.minContribution) {\r\n            return ContributionStatus.MIN_CONTRIBUTION;\r\n        }\r\n\r\n        if (contributions[token][user].add(weiAmount) > crowdsale.maxContribution) {\r\n            return ContributionStatus.MAX_CONTRIBUTION;\r\n        }\r\n\r\n        if (crowdsale.hardCap < crowdsale.weiRaised.add(weiAmount)) {\r\n            return ContributionStatus.HARDCAP_REACHED;\r\n        }\r\n\r\n        return ContributionStatus.VALID;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract ExchangeSwap is Exchange, ExchangeMovements  {\r\n\r\n    /**\r\n      * @dev Swaps ETH/TOKEN, TOKEN/ETH or TOKEN/TOKEN using off-chain signed messages.\r\n      * The flow of the function is Deposit -> Trade -> Withdraw to allow users to directly\r\n      * take liquidity without the need of deposit and withdraw.\r\n      */\r\n    function swapFill(\r\n        Order[] memory orders,\r\n        bytes[] memory signatures,\r\n        uint256 givenAmount,\r\n        address givenToken,\r\n        address receivedToken,\r\n        address referral\r\n    )\r\n        public\r\n        payable\r\n    {\r\n        address taker = msg.sender;\r\n\r\n        uint256 balanceGivenBefore = balances[givenToken][taker];\r\n        uint256 balanceReceivedBefore = balances[receivedToken][taker];\r\n\r\n        deposit(givenToken, givenAmount, taker, referral);\r\n\r\n        for (uint256 index = 0; index < orders.length; index++) {\r\n            require(orders[index].makerBuyToken == givenToken, \"GIVEN_TOKEN\");\r\n            require(orders[index].makerSellToken == receivedToken, \"RECEIVED_TOKEN\");\r\n\r\n            _trade(orders[index], signatures[index]);\r\n        }\r\n\r\n        uint256 balanceGivenAfter = balances[givenToken][taker];\r\n        uint256 balanceReceivedAfter = balances[receivedToken][taker];\r\n\r\n        uint256 balanceGivenDelta = balanceGivenAfter.sub(balanceGivenBefore);\r\n        uint256 balanceReceivedDelta = balanceReceivedAfter.sub(balanceReceivedBefore);\r\n\r\n        if(balanceGivenDelta > 0) {\r\n            withdraw(givenToken, balanceGivenDelta);\r\n        }\r\n\r\n        if(balanceReceivedDelta > 0) {\r\n            withdraw(receivedToken, balanceReceivedDelta);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract WeiDex is\r\n    Exchange,\r\n    ExchangeKyberProxy,\r\n    ExchangeBatchTrade,\r\n    ExchangeMovements,\r\n    ExchangeUpgradability,\r\n    ExchangeOffering,\r\n    ExchangeSwap\r\n{\r\n    function () external payable { }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newTakerFeeRate\",\"type\":\"uint256\"}],\"name\":\"setTakerFeeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newExchange\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partialAmount\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"makerSellAmount\",\"type\":\"uint256\"},{\"name\":\"makerBuyAmount\",\"type\":\"uint256\"},{\"name\":\"takerSellAmount\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"makerSellToken\",\"type\":\"address\"},{\"name\":\"makerBuyToken\",\"type\":\"address\"}],\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"getOrderInfo\",\"outputs\":[{\"components\":[{\"name\":\"filledAmount\",\"type\":\"uint256\"},{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"orderInfo\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"givenTokens\",\"type\":\"address[]\"},{\"name\":\"receivedTokens\",\"type\":\"address[]\"},{\"name\":\"givenAmounts\",\"type\":\"uint256[]\"}],\"name\":\"getExpectedRateBatch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"makerSellAmount\",\"type\":\"uint256\"},{\"name\":\"makerBuyAmount\",\"type\":\"uint256\"},{\"name\":\"takerSellAmount\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"makerSellToken\",\"type\":\"address\"},{\"name\":\"makerBuyToken\",\"type\":\"address\"}],\"name\":\"order\",\"type\":\"tuple\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"cancelSingleOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMakerFeeRate\",\"type\":\"uint256\"}],\"name\":\"setMakerFeeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"makerSellAmount\",\"type\":\"uint256\"},{\"name\":\"makerBuyAmount\",\"type\":\"uint256\"},{\"name\":\"takerSellAmount\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"makerSellToken\",\"type\":\"address\"},{\"name\":\"makerBuyToken\",\"type\":\"address\"}],\"name\":\"orders\",\"type\":\"tuple[]\"},{\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"cancelMultipleOrders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"makerSellAmount\",\"type\":\"uint256\"},{\"name\":\"makerBuyAmount\",\"type\":\"uint256\"},{\"name\":\"takerSellAmount\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"makerSellToken\",\"type\":\"address\"},{\"name\":\"makerBuyToken\",\"type\":\"address\"}],\"name\":\"orders\",\"type\":\"tuple[]\"},{\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"takeAllPossible\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getReferral\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"makerSellAmount\",\"type\":\"uint256\"},{\"name\":\"makerBuyAmount\",\"type\":\"uint256\"},{\"name\":\"takerSellAmount\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"makerSellToken\",\"type\":\"address\"},{\"name\":\"makerBuyToken\",\"type\":\"address\"}],\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"getHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFeeAccount\",\"type\":\"address\"}],\"name\":\"setFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"takerFeeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"givenAmount\",\"type\":\"uint256\"},{\"name\":\"givenToken\",\"type\":\"address\"},{\"name\":\"receivedToken\",\"type\":\"address\"},{\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"kyberTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"makerSellAmount\",\"type\":\"uint256\"},{\"name\":\"makerBuyAmount\",\"type\":\"uint256\"},{\"name\":\"takerSellAmount\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"makerSellToken\",\"type\":\"address\"},{\"name\":\"makerBuyToken\",\"type\":\"address\"}],\"name\":\"orders\",\"type\":\"tuple[]\"},{\"name\":\"signatures\",\"type\":\"bytes[]\"},{\"name\":\"givenAmount\",\"type\":\"uint256\"},{\"name\":\"givenToken\",\"type\":\"address\"},{\"name\":\"receivedToken\",\"type\":\"address\"},{\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"swapFill\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address[]\"}],\"name\":\"getBalances\",\"outputs\":[{\"name\":\"balanceArray\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"makerSellAmount\",\"type\":\"uint256\"},{\"name\":\"makerBuyAmount\",\"type\":\"uint256\"},{\"name\":\"takerSellAmount\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"makerSellToken\",\"type\":\"address\"},{\"name\":\"makerBuyToken\",\"type\":\"address\"}],\"name\":\"order\",\"type\":\"tuple\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"makerFeeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderHash\",\"type\":\"bytes32[]\"}],\"name\":\"getFills\",\"outputs\":[{\"name\":\"filledArray\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"burnTokensWhenFinished\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"importTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderHash\",\"type\":\"bytes32[]\"}],\"name\":\"getCancels\",\"outputs\":[{\"name\":\"cancelledArray\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exchange\",\"type\":\"address\"}],\"name\":\"setNewExchangeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"getFill\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"makerSellAmount\",\"type\":\"uint256\"},{\"name\":\"makerBuyAmount\",\"type\":\"uint256\"},{\"name\":\"takerSellAmount\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"makerSellToken\",\"type\":\"address\"},{\"name\":\"makerBuyToken\",\"type\":\"address\"}],\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"getPrefixedHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"importEthers\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowOrRestrictMigrations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"getCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"migrateFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"makerSellAmount\",\"type\":\"uint256\"},{\"name\":\"makerBuyAmount\",\"type\":\"uint256\"},{\"name\":\"takerSellAmount\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"makerSellToken\",\"type\":\"address\"},{\"name\":\"makerBuyToken\",\"type\":\"address\"}],\"name\":\"orders\",\"type\":\"tuple[]\"},{\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"takeAllOrRevert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"startBlock\",\"type\":\"uint256\"},{\"name\":\"endBlock\",\"type\":\"uint256\"},{\"name\":\"hardCap\",\"type\":\"uint256\"},{\"name\":\"leftAmount\",\"type\":\"uint256\"},{\"name\":\"tokenRatio\",\"type\":\"uint256\"},{\"name\":\"minContribution\",\"type\":\"uint256\"},{\"name\":\"maxContribution\",\"type\":\"uint256\"},{\"name\":\"weiRaised\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"crowdsale\",\"type\":\"tuple\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"validContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"crowdsales\",\"outputs\":[{\"name\":\"startBlock\",\"type\":\"uint256\"},{\"name\":\"endBlock\",\"type\":\"uint256\"},{\"name\":\"hardCap\",\"type\":\"uint256\"},{\"name\":\"leftAmount\",\"type\":\"uint256\"},{\"name\":\"tokenRatio\",\"type\":\"uint256\"},{\"name\":\"minContribution\",\"type\":\"uint256\"},{\"name\":\"maxContribution\",\"type\":\"uint256\"},{\"name\":\"weiRaised\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"givenAmount\",\"type\":\"uint256\"},{\"name\":\"givenToken\",\"type\":\"address\"},{\"name\":\"receivedToken\",\"type\":\"address\"},{\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"kyberSwap\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"startBlock\",\"type\":\"uint256\"},{\"name\":\"endBlock\",\"type\":\"uint256\"},{\"name\":\"hardCap\",\"type\":\"uint256\"},{\"name\":\"leftAmount\",\"type\":\"uint256\"},{\"name\":\"tokenRatio\",\"type\":\"uint256\"},{\"name\":\"minContribution\",\"type\":\"uint256\"},{\"name\":\"maxContribution\",\"type\":\"uint256\"},{\"name\":\"weiRaised\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"crowdsale\",\"type\":\"tuple\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"registerCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"startBlock\",\"type\":\"uint256\"},{\"name\":\"endBlock\",\"type\":\"uint256\"},{\"name\":\"hardCap\",\"type\":\"uint256\"},{\"name\":\"leftAmount\",\"type\":\"uint256\"},{\"name\":\"tokenRatio\",\"type\":\"uint256\"},{\"name\":\"minContribution\",\"type\":\"uint256\"},{\"name\":\"maxContribution\",\"type\":\"uint256\"},{\"name\":\"weiRaised\",\"type\":\"uint256\"},{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"crowdsale\",\"type\":\"tuple\"}],\"name\":\"getCrowdsaleStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"TokenBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newExchange\",\"type\":\"address\"}],\"name\":\"FundsMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"userBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"beneficiaryBalance\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"makerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"takerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"makerFilledAsset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"takerFilledAsset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"makerFilledAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerFilledAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerFeePaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"makerFeeReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referralFeeReceived\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"makerBuyToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"makerSellToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"WeiDex","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://409da86e878973f1cb1845f5462345b1503b34286d0a32280efcfef087a0d932"}]}