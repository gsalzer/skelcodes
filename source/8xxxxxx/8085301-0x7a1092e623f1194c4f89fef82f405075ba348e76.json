{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.21 <0.6.0;\r\n\r\n\r\n/**\r\n * @author Wanseob Lim <email@wanseob.com>\r\n * @title Merkle Mountain Range solidity library\r\n *\r\n * The index starts from 1 not 0. And it uses keccak256 for its hash function\r\n */\r\nlibrary MMR {\r\n\r\n    struct Tree {\r\n        bytes32 root;\r\n        uint256 size;\r\n        mapping(uint256 => bytes32) hashes;\r\n    }\r\n\r\n    /**\r\n     * @dev This only stores the hashed value of the leaf.\r\n     * If you need to retrieve the detail data later, use a map to store them.\r\n     */\r\n    function append(Tree storage tree, bytes memory data) public {\r\n        // Hash the leaf node first\r\n        bytes32 hash = hashLeaf(tree.size + 1, data);\r\n        // Put the hashed leaf to the map\r\n        tree.hashes[tree.size + 1] = hash;\r\n        // Find peaks for the increased size tree\r\n        uint256[] memory peaks = getPeaks(tree.size + 1);\r\n        // The right most peak's value is the new size of the updated tree\r\n        tree.size = peaks[peaks.length - 1];\r\n        // Starting from the left-most peak, get all peak hashes using _getOrCreateNode() function.\r\n        bytes32[] memory peakBagging = new bytes32[](peaks.length);\r\n        for (uint i = 0; i < peaks.length; i++) {\r\n            peakBagging[i] = _getOrCreateNode(tree, peaks[i]);\r\n        }\r\n        // Create the root hash and update the tree\r\n        tree.root = keccak256(\r\n            abi.encodePacked(\r\n                tree.size,\r\n                keccak256(abi.encodePacked(tree.size, abi.encodePacked(peakBagging)))\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev It returns the root value of the tree\r\n     */\r\n    function getRoot(Tree storage tree) public view returns (bytes32) {\r\n        return tree.root;\r\n    }\r\n\r\n    /**\r\n     * @dev It returns the size of the tree\r\n     */\r\n    function getSize(Tree storage tree) public view returns (uint256) {\r\n        return tree.size;\r\n    }\r\n\r\n    /**\r\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1\r\n     */\r\n    function getNode(Tree storage tree, uint256 index) public view returns (bytes32) {\r\n        return tree.hashes[index];\r\n    }\r\n\r\n    /**\r\n     * @dev It returns a merkle proof for the given position. Note that the index starts from 1\r\n     */\r\n    function getMerkleProof(Tree storage tree, uint256 index) public view returns (\r\n        bytes32 root,\r\n        uint256 size,\r\n        bytes32[] memory peakBagging,\r\n        bytes32[] memory siblings\r\n    ){\r\n        require(index < tree.size, \"Out of range\");\r\n        require(isLeaf(index), \"Not a leaf\");\r\n\r\n        root = tree.root;\r\n        size = tree.size;\r\n        // Find all peaks for bagging\r\n        uint256[] memory peaks = getPeaks(size);\r\n\r\n        peakBagging = new bytes32[](peaks.length);\r\n        uint256 myPeakIndex;\r\n        for (uint i = 0; i < peaks.length; i++) {\r\n            // Collect the hash of all peaks\r\n            peakBagging[i] = tree.hashes[peaks[i]];\r\n            // Find the peak which includes the target index\r\n            if (peaks[i] >= index && myPeakIndex == 0) {\r\n                myPeakIndex = peaks[i];\r\n            }\r\n        }\r\n        uint256 left;\r\n        uint256 right;\r\n\r\n        // Get hashes of the siblings in the mountain which the index belongs to.\r\n        // It moves myPeakIndex from the summit of the mountain down to the target index\r\n        uint8 myPeakHeight = heightAt(myPeakIndex);\r\n        siblings = new bytes32[](myPeakHeight - 1);\r\n        while (myPeakIndex != index) {\r\n            myPeakHeight--;\r\n            (left, right) = getChildren(myPeakIndex);\r\n            // Move myPeakIndex down to the left side or right side\r\n            myPeakIndex = index <= left ? left : right;\r\n            // Remaining node is the sibling\r\n            siblings[myPeakHeight - 1] = tree.hashes[index <= left ? right : left];\r\n        }\r\n    }\r\n\r\n    /** Pure functions */\r\n\r\n    /**\r\n     * @dev It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\r\n     */\r\n    function inclusionProof(\r\n        bytes32 root,\r\n        uint256 size,\r\n        uint256 index,\r\n        bytes memory value,\r\n        bytes32[] memory peakBagging,\r\n        bytes32[] memory siblings\r\n    ) public pure returns (bool) {\r\n        // Check the root equals the peak bagging hash\r\n        require(root == keccak256(abi.encodePacked(size, keccak256(abi.encodePacked(size, peakBagging)))), \"Invalid root hash from the peaks\");\r\n\r\n        // Find the mountain where the target index belongs to\r\n        uint256 cursor;\r\n        bytes32 targetPeak;\r\n        uint256[] memory peaks = getPeaks(size);\r\n        for (uint i = 0; i < peaks.length; i++) {\r\n            if (peaks[i] >= index) {\r\n                targetPeak = peakBagging[i];\r\n                cursor = peaks[i];\r\n                break;\r\n            }\r\n        }\r\n        require(targetPeak != bytes32(0), \"Target is not found\");\r\n\r\n        // Find the path climbing down\r\n        uint256[] memory path = new uint256[](siblings.length + 1);\r\n        uint256 left;\r\n        uint256 right;\r\n        uint8 height = uint8(siblings.length) + 1;\r\n        while (height > 0) {\r\n            // Record the current cursor and climb down\r\n            path[--height] = cursor;\r\n            if (cursor == index) {\r\n                // On the leaf node. Stop climbing down\r\n                break;\r\n            } else {\r\n                // On the parent node. Go left or right\r\n                (left, right) = getChildren(cursor);\r\n                cursor = index > left ? right : left;\r\n                continue;\r\n            }\r\n        }\r\n\r\n        // Calculate the summit hash climbing up again\r\n        bytes32 node;\r\n        while (height < path.length) {\r\n            // Move cursor\r\n            cursor = path[height];\r\n            if (height == 0) {\r\n                // cursor is on the leaf\r\n                node = hashLeaf(cursor, value);\r\n            } else if (cursor - 1 == path[height - 1]) {\r\n                // cursor is on a parent and a sibling is on the left\r\n                node = hashParent(cursor, siblings[height - 1], node);\r\n            } else {\r\n                // cursor is on a parent and a sibling is on the right\r\n                node = hashParent(cursor, node, siblings[height - 1]);\r\n            }\r\n            // Climb up\r\n            height++;\r\n        }\r\n\r\n        // Computed hash value of the summit should equal to the target peak hash\r\n        require(node == targetPeak, \"Hashed peak is invalid\");\r\n        return true;\r\n    }\r\n\r\n    // Hash(M | Left | Right )\r\n    function hashParent(uint256 index, bytes32 left, bytes32 right) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(index, left, right));\r\n    }\r\n\r\n    // Hash(M | DATA )\r\n    function hashLeaf(uint256 index, bytes memory data) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(index, data));\r\n    }\r\n\r\n    /**\r\n     * It returns the height of the highest peak\r\n     */\r\n    function mountainHeight(uint256 size) public pure returns (uint8) {\r\n        uint8 height = 1;\r\n        while (uint256(1) << height <= size + height) {\r\n            height++;\r\n        }\r\n        return height - 1;\r\n    }\r\n\r\n    /**\r\n     * It returns the height of the index\r\n     */\r\n    function heightAt(uint256 index) public pure returns (uint8 height) {\r\n        uint256 reducedIndex = index;\r\n        uint256 peakIndex;\r\n        // If an index has a left mountain subtract the mountain\r\n        while (reducedIndex > peakIndex) {\r\n            reducedIndex -= (uint256(1) << height) - 1;\r\n            height = mountainHeight(reducedIndex);\r\n            peakIndex = (uint256(1) << height) - 1;\r\n        }\r\n        // Index is on the right slope\r\n        height = height - uint8((peakIndex - reducedIndex));\r\n    }\r\n\r\n    function isLeaf(uint256 index) public pure returns (bool) {\r\n        return heightAt(index) == 1;\r\n    }\r\n\r\n    function getChildren(uint256 index) public pure returns (uint256 left, uint256 right) {\r\n        left = index - (uint256(1) << (heightAt(index) - 1));\r\n        right = index - 1;\r\n        require(left != right, \"Not a parent\");\r\n    }\r\n\r\n    /**\r\n     * @dev It returns all peaks of the smallest merkle mountain range tree which includes\r\n            the given index(size)\r\n     */\r\n    function getPeaks(uint256 size) public pure returns (uint256[] memory peaks) {\r\n        uint8 height = 0;\r\n        uint256 leftPeak = 0;\r\n        uint8 i = 0;\r\n\r\n\r\n        // Maximum number of possible peaks is 256\r\n        uint256[] memory tempPeaks = new uint256[](256);\r\n        // Find peaks from the left\r\n        while (size > leftPeak) {\r\n            height = mountainHeight(size - leftPeak);\r\n            leftPeak += (uint256(1) << height) - 1;\r\n            tempPeaks[i++] = leftPeak;\r\n        }\r\n        // Return\r\n        peaks = new uint256[](i);\r\n        while (i > 0) {\r\n            i--;\r\n            peaks[i] = tempPeaks[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev It returns the hash value of the node for the index.\r\n            If the hash already exists it simply returns the value, but on the other hand,\r\n            it computes hashes recursively through downward. This computation occurs when a\r\n            new item appended to the node\r\n     */\r\n    function _getOrCreateNode(Tree storage tree, uint256 index) private returns (bytes32) {\r\n        require(index <= tree.size, \"Out of range\");\r\n        if (tree.hashes[index] == bytes32(0)) {\r\n            (uint256 leftIndex, uint256 rightIndex) = getChildren(index);\r\n            bytes32 leftHash = _getOrCreateNode(tree, leftIndex);\r\n            bytes32 rightHash = _getOrCreateNode(tree, rightIndex);\r\n            tree.hashes[index] = hashParent(index, leftHash, rightHash);\r\n        }\r\n        return tree.hashes[index];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"mountainHeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getPeaks\",\"outputs\":[{\"name\":\"peaks\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getChildren\",\"outputs\":[{\"name\":\"left\",\"type\":\"uint256\"},{\"name\":\"right\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"heightAt\",\"outputs\":[{\"name\":\"height\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"hashLeaf\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"root\",\"type\":\"bytes32\"},{\"name\":\"size\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"bytes\"},{\"name\":\"peakBagging\",\"type\":\"bytes32[]\"},{\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"name\":\"inclusionProof\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"left\",\"type\":\"bytes32\"},{\"name\":\"right\",\"type\":\"bytes32\"}],\"name\":\"hashParent\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isLeaf\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"MMR","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://00feefa2e6940482f45d4265567d5a2b57e175cbc0834820d7aa7466fd4b45f9"}]}