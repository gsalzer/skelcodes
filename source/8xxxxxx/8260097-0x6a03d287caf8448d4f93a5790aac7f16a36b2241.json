{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n\r\n//Functions for retrieving min and Max in 51 length array (requestQ)\r\n//Taken partly from: https://github.com/modular-network/ethereum-libraries-array-utils/blob/master/contracts/Array256Lib.sol\r\n\r\nlibrary Utilities{\r\n\r\n    /**\r\n    * @dev Returns the minimum value in an array.\r\n    */\r\n    function getMax(uint[51] memory data) internal pure returns(uint256 max,uint256 maxIndex) {\r\n        max = data[1];\r\n        maxIndex;\r\n        for(uint i=1;i < data.length;i++){\r\n            if(data[i] > max){\r\n                max = data[i];\r\n                maxIndex = i;\r\n                }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the minimum value in an array.\r\n    */\r\n    function getMin(uint[51] memory data) internal pure returns(uint256 min,uint256 minIndex) {\r\n        minIndex = data.length - 1;\r\n        min = data[minIndex];\r\n        for(uint i = data.length-1;i > 0;i--) {\r\n            if(data[i] < min) {\r\n                min = data[i];\r\n                minIndex = i;\r\n            }\r\n        }\r\n  }\r\n\r\n\r\n\r\n\r\n  // /// @dev Returns the minimum value and position in an array.\r\n  // //@note IT IGNORES THE 0 INDEX\r\n  //   function getMin(uint[51] memory arr) internal pure returns (uint256 min, uint256 minIndex) {\r\n  //     assembly {\r\n  //         minIndex := 50\r\n  //         min := mload(add(arr, mul(minIndex , 0x20)))\r\n  //         for {let i := 49 } gt(i,0) { i := sub(i, 1) } {\r\n  //             let item := mload(add(arr, mul(i, 0x20)))\r\n  //             if lt(item,min){\r\n  //                 min := item\r\n  //                 minIndex := i\r\n  //             }\r\n  //         }\r\n  //     }\r\n  //   }\r\n\r\n\r\n  \r\n  // function getMax(uint256[51] memory arr) internal pure returns (uint256 max, uint256 maxIndex) {\r\n  //     assembly {\r\n  //         for { let i := 0 } lt(i,51) { i := add(i, 1) } {\r\n  //             let item := mload(add(arr, mul(i, 0x20)))\r\n  //             if lt(max, item) {\r\n  //                 max := item\r\n  //                 maxIndex := i\r\n  //             }\r\n  //         }\r\n  //     }\r\n  //   }\r\n\r\n\r\n\r\n\r\n\r\n  }\r\n\r\n\r\n/**\r\n* @title Tellor Getters Library\r\n* @dev This is the getter library for all variables in the Tellor Tributes system. TellorGetters references this \r\n* libary for the getters logic\r\n*/\r\nlibrary TellorGettersLibrary{\r\n    using SafeMath for uint256;\r\n\r\n    event NewTellorAddress(address _newTellor); //emmited when a proposed fork is voted true\r\n\r\n    /*Functions*/\r\n\r\n    //The next two functions are onlyOwner functions.  For Tellor to be truly decentralized, we will need to transfer the Deity to the 0 address.\r\n    //Only needs to be in library\r\n    /**\r\n    * @dev This function allows us to set a new Deity (or remove it) \r\n    * @param _newDeity address of the new Deity of the tellor system \r\n    */\r\n    function changeDeity(TellorStorage.TellorStorageStruct storage self, address _newDeity) internal{\r\n        require(self.addressVars[keccak256(\"_deity\")] == msg.sender);\r\n        self.addressVars[keccak256(\"_deity\")] =_newDeity;\r\n    }\r\n\r\n\r\n    //Only needs to be in library\r\n    /**\r\n    * @dev This function allows the deity to upgrade the Tellor System\r\n    * @param _tellorContract address of new updated TellorCore contract\r\n    */\r\n    function changeTellorContract(TellorStorage.TellorStorageStruct storage self,address _tellorContract) internal{\r\n        require(self.addressVars[keccak256(\"_deity\")] == msg.sender);\r\n        self.addressVars[keccak256(\"tellorContract\")]= _tellorContract;\r\n        emit NewTellorAddress(_tellorContract);\r\n    }\r\n\r\n\r\n    /*Tellor Getters*/\r\n\r\n    /**\r\n    * @dev This function tells you if a given challenge has been completed by a given miner\r\n    * @param _challenge the challenge to search for\r\n    * @param _miner address that you want to know if they solved the challenge\r\n    * @return true if the _miner address provided solved the \r\n    */\r\n    function didMine(TellorStorage.TellorStorageStruct storage self, bytes32 _challenge,address _miner) internal view returns(bool){\r\n        return self.minersByChallenge[_challenge][_miner];\r\n    }\r\n    \r\n\r\n    /**\r\n    * @dev Checks if an address voted in a dispute\r\n    * @param _disputeId to look up\r\n    * @param _address of voting party to look up\r\n    * @return bool of whether or not party voted\r\n    */\r\n    function didVote(TellorStorage.TellorStorageStruct storage self,uint _disputeId, address _address) internal view returns(bool){\r\n        return self.disputesById[_disputeId].voted[_address];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev allows Tellor to read data from the addressVars mapping\r\n    * @param _data is the keccak256(\"variable_name\") of the variable that is being accessed. \r\n    * These are examples of how the variables are saved within other functions:\r\n    * addressVars[keccak256(\"_owner\")]\r\n    * addressVars[keccak256(\"tellorContract\")]\r\n    */\r\n    function getAddressVars(TellorStorage.TellorStorageStruct storage self, bytes32 _data) view internal returns(address){\r\n        return self.addressVars[_data];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets all dispute variables\r\n    * @param _disputeId to look up\r\n    * @return bytes32 hash of dispute \r\n    * @return bool executed where true if it has been voted on\r\n    * @return bool disputeVotePassed\r\n    * @return bool isPropFork true if the dispute is a proposed fork\r\n    * @return address of reportedMiner\r\n    * @return address of reportingParty\r\n    * @return address of proposedForkAddress\r\n    * @return uint of requestId\r\n    * @return uint of timestamp\r\n    * @return uint of value\r\n    * @return uint of minExecutionDate\r\n    * @return uint of numberOfVotes\r\n    * @return uint of blocknumber\r\n    * @return uint of minerSlot\r\n    * @return uint of quorum\r\n    * @return uint of fee\r\n    * @return int count of the current tally\r\n    */\r\n    function getAllDisputeVars(TellorStorage.TellorStorageStruct storage self,uint _disputeId) internal view returns(bytes32, bool, bool, bool, address, address, address,uint[9] memory, int){\r\n        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\r\n        return(disp.hash,disp.executed, disp.disputeVotePassed, disp.isPropFork, disp.reportedMiner, disp.reportingParty,disp.proposedForkAddress,[disp.disputeUintVars[keccak256(\"requestId\")], disp.disputeUintVars[keccak256(\"timestamp\")], disp.disputeUintVars[keccak256(\"value\")], disp.disputeUintVars[keccak256(\"minExecutionDate\")], disp.disputeUintVars[keccak256(\"numberOfVotes\")], disp.disputeUintVars[keccak256(\"blockNumber\")], disp.disputeUintVars[keccak256(\"minerSlot\")], disp.disputeUintVars[keccak256(\"quorum\")],disp.disputeUintVars[keccak256(\"fee\")]],disp.tally);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\r\n    * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request \r\n    */\r\n    function getCurrentVariables(TellorStorage.TellorStorageStruct storage self) internal view returns(bytes32, uint, uint,string memory,uint,uint){    \r\n        return (self.currentChallenge,self.uintVars[keccak256(\"currentRequestId\")],self.uintVars[keccak256(\"difficulty\")],self.requestDetails[self.uintVars[keccak256(\"currentRequestId\")]].queryString,self.requestDetails[self.uintVars[keccak256(\"currentRequestId\")]].apiUintVars[keccak256(\"granularity\")],self.requestDetails[self.uintVars[keccak256(\"currentRequestId\")]].apiUintVars[keccak256(\"totalTip\")]);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Checks if a given hash of miner,requestId has been disputed\r\n    * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\r\n    * @return uint disputeId\r\n    */\r\n    function getDisputeIdByDisputeHash(TellorStorage.TellorStorageStruct storage self,bytes32 _hash) internal view returns(uint){\r\n        return  self.disputeIdByDisputeHash[_hash];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\r\n    * @param _disputeId is the dispute id;\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is \r\n    * the variables/strings used to save the data in the mapping. The variables names are  \r\n    * commented out under the disputeUintVars under the Dispute struct\r\n    * @return uint value for the bytes32 data submitted\r\n    */\r\n    function getDisputeUintVars(TellorStorage.TellorStorageStruct storage self,uint _disputeId,bytes32 _data) internal view returns(uint){\r\n        return self.disputesById[_disputeId].disputeUintVars[_data];\r\n    }\r\n\r\n    \r\n    /**\r\n    * @dev Gets the a value for the latest timestamp available\r\n    * @return value for timestamp of last proof of work submited\r\n    * @return true if the is a timestamp for the lastNewValue\r\n    */\r\n    function getLastNewValue(TellorStorage.TellorStorageStruct storage self) internal view returns(uint,bool){\r\n        return (retrieveData(self,self.requestIdByTimestamp[self.uintVars[keccak256(\"timeOfLastNewValue\")]], self.uintVars[keccak256(\"timeOfLastNewValue\")]),true);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets the a value for the latest timestamp available\r\n    * @param _requestId being requested\r\n    * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\r\n    */\r\n    function getLastNewValueById(TellorStorage.TellorStorageStruct storage self,uint _requestId) internal view returns(uint,bool){\r\n        TellorStorage.Request storage _request = self.requestDetails[_requestId]; \r\n        if(_request.requestTimestamps.length > 0){\r\n            return (retrieveData(self,_requestId,_request.requestTimestamps[_request.requestTimestamps.length - 1]),true);\r\n        }\r\n        else{\r\n            return (0,false);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets blocknumber for mined timestamp \r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up blocknumber\r\n    * @return uint of the blocknumber which the dispute was mined\r\n    */\r\n    function getMinedBlockNum(TellorStorage.TellorStorageStruct storage self,uint _requestId, uint _timestamp) internal view returns(uint){\r\n        return self.requestDetails[_requestId].minedBlockNum[_timestamp];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp \r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up miners for\r\n    * @return the 5 miners' addresses\r\n    */\r\n    function getMinersByRequestIdAndTimestamp(TellorStorage.TellorStorageStruct storage self, uint _requestId, uint _timestamp) internal view returns(address[5] memory){\r\n        return self.requestDetails[_requestId].minersByValue[_timestamp];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Get the name of the token\r\n    * @return string of the token name\r\n    */\r\n    function getName(TellorStorage.TellorStorageStruct storage self) internal pure returns(string memory){\r\n        return \"Tellor Tributes\";\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Counts the number of values that have been submited for the request \r\n    * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\r\n    * request so far\r\n    * @param _requestId the requestId to look up\r\n    * @return uint count of the number of values received for the requestId\r\n    */\r\n    function getNewValueCountbyRequestId(TellorStorage.TellorStorageStruct storage self, uint _requestId) internal view returns(uint){\r\n        return self.requestDetails[_requestId].requestTimestamps.length;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter function for the specified requestQ index\r\n    * @param _index to look up in the requestQ array\r\n    * @return uint of reqeuestId\r\n    */\r\n    function getRequestIdByRequestQIndex(TellorStorage.TellorStorageStruct storage self, uint _index) internal view returns(uint){\r\n        require(_index <= 50);\r\n        return self.requestIdByRequestQIndex[_index];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter function for requestId based on timestamp \r\n    * @param _timestamp to check requestId\r\n    * @return uint of reqeuestId\r\n    */\r\n    function getRequestIdByTimestamp(TellorStorage.TellorStorageStruct storage self, uint _timestamp) internal view returns(uint){    \r\n        return self.requestIdByTimestamp[_timestamp];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter function for requestId based on the qeuaryHash\r\n    * @param _queryHash hash(of string api and granularity) to check if a request already exists\r\n    * @return uint requestId\r\n    */\r\n    function getRequestIdByQueryHash(TellorStorage.TellorStorageStruct storage self, bytes32 _queryHash) internal view returns(uint){    \r\n        return self.requestIdByQueryHash[_queryHash];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter function for the requestQ array\r\n    * @return the requestQ arrray\r\n    */\r\n    function getRequestQ(TellorStorage.TellorStorageStruct storage self) view internal returns(uint[51] memory){\r\n        return self.requestQ;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\r\n    * for the requestId specified\r\n    * @param _requestId to look up\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is \r\n    * the variables/strings used to save the data in the mapping. The variables names are  \r\n    * commented out under the apiUintVars under the requestDetails struct\r\n    * @return uint value of the apiUintVars specified in _data for the requestId specified\r\n    */\r\n    function getRequestUintVars(TellorStorage.TellorStorageStruct storage self,uint _requestId,bytes32 _data) internal view returns(uint){\r\n        return self.requestDetails[_requestId].apiUintVars[_data];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets the API struct variables that are not mappings\r\n    * @param _requestId to look up\r\n    * @return string of api to query\r\n    * @return string of symbol of api to query\r\n    * @return bytes32 hash of string\r\n    * @return bytes32 of the granularity(decimal places) requested\r\n    * @return uint of index in requestQ array\r\n    * @return uint of current payout/tip for this requestId\r\n    */\r\n    function getRequestVars(TellorStorage.TellorStorageStruct storage self,uint _requestId) internal view returns(string memory,string memory, bytes32,uint, uint, uint) {\r\n        TellorStorage.Request storage _request = self.requestDetails[_requestId]; \r\n        return (_request.queryString,_request.dataSymbol,_request.queryHash, _request.apiUintVars[keccak256(\"granularity\")],_request.apiUintVars[keccak256(\"requestQPosition\")],_request.apiUintVars[keccak256(\"totalTip\")]);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev This function allows users to retireve all information about a staker\r\n    * @param _staker address of staker inquiring about\r\n    * @return uint current state of staker\r\n    * @return uint startDate of staking\r\n    */\r\n    function getStakerInfo(TellorStorage.TellorStorageStruct storage self,address _staker) internal view returns(uint,uint){\r\n        return (self.stakerDetails[_staker].currentStatus,self.stakerDetails[_staker].startDate);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp \r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestampt to look up miners for\r\n    * @return address[5] array of 5 addresses ofminers that mined the requestId\r\n    */\r\n    function getSubmissionsByTimestamp(TellorStorage.TellorStorageStruct storage self, uint _requestId, uint _timestamp) internal view returns(uint[5] memory){\r\n        return self.requestDetails[_requestId].valuesByTimestamp[_timestamp];\r\n    }\r\n\r\n    /**\r\n    * @dev Get the symbol of the token\r\n    * @return string of the token symbol\r\n    */\r\n    function getSymbol(TellorStorage.TellorStorageStruct storage self) internal pure returns(string memory){\r\n        return \"TT\";\r\n    } \r\n\r\n\r\n    /**\r\n    * @dev Gets the timestamp for the value based on their index\r\n    * @param _requestID is the requestId to look up\r\n    * @param _index is the value index to look up\r\n    * @return uint timestamp\r\n    */\r\n    function getTimestampbyRequestIDandIndex(TellorStorage.TellorStorageStruct storage self,uint _requestID, uint _index) internal view returns(uint){\r\n        return self.requestDetails[_requestID].requestTimestamps[_index];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is \r\n    * the variables/strings used to save the data in the mapping. The variables names are  \r\n    * commented out under the uintVars under the TellorStorageStruct struct\r\n    * This is an example of how data is saved into the mapping within other functions: \r\n    * self.uintVars[keccak256(\"stakerCount\")]\r\n    * @return uint of specified variable  \r\n    */ \r\n    function getUintVar(TellorStorage.TellorStorageStruct storage self,bytes32 _data) view internal returns(uint){\r\n        return self.uintVars[_data];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\r\n    * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\r\n    */\r\n    function getVariablesOnDeck(TellorStorage.TellorStorageStruct storage self) internal view returns(uint, uint,string memory){ \r\n        uint newRequestId = getTopRequestID(self);\r\n        return (newRequestId,self.requestDetails[newRequestId].apiUintVars[keccak256(\"totalTip\")],self.requestDetails[newRequestId].queryString);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter function for the request with highest payout. This function is used within the getVariablesOnDeck function\r\n    * @return uint _requestId of request with highest payout at the time the function is called\r\n    */\r\n    function getTopRequestID(TellorStorage.TellorStorageStruct storage self) internal view returns(uint _requestId){\r\n            uint _max;\r\n            uint _index;\r\n            (_max,_index) = Utilities.getMax(self.requestQ);\r\n             _requestId = self.requestIdByRequestQIndex[_index];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp \r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up miners for\r\n    * @return bool true if requestId/timestamp is under dispute\r\n    */\r\n    function isInDispute(TellorStorage.TellorStorageStruct storage self, uint _requestId, uint _timestamp) internal view returns(bool){\r\n        return self.requestDetails[_requestId].inDispute[_timestamp];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Retreive value from oracle based on requestId/timestamp\r\n    * @param _requestId being requested\r\n    * @param _timestamp to retreive data/value from\r\n    * @return uint value for requestId/timestamp submitted\r\n    */\r\n    function retrieveData(TellorStorage.TellorStorageStruct storage self, uint _requestId, uint _timestamp) internal view returns (uint) {\r\n        return self.requestDetails[_requestId].finalValues[_timestamp];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter for the total_supply of oracle tokens\r\n    * @return uint total supply\r\n    */\r\n    function totalSupply(TellorStorage.TellorStorageStruct storage self) internal view returns (uint) {\r\n       return self.uintVars[keccak256(\"total_supply\")];\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\npragma solidity ^0.5.0;\r\n\r\n//Slightly modified SafeMath library - includes a min and max function, removes useless div function\r\nlibrary SafeMath {\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function add(int256 a, int256 b) internal pure returns (int256 c) {\r\n    if(b > 0){\r\n      c = a + b;\r\n      assert(c >= a);\r\n    }\r\n    else{\r\n      c = a + b;\r\n      assert(c <= a);\r\n    }\r\n\r\n  }\r\n\r\n  function max(uint a, uint b) internal pure returns (uint256) {\r\n    return a > b ? a : b;\r\n  }\r\n\r\n  function max(int256 a, int256 b) internal pure returns (uint256) {\r\n    return a > b ? uint(a) : uint(b);\r\n  }\r\n\r\n  function min(uint a, uint b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n  \r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function sub(int256 a, int256 b) internal pure returns (int256 c) {\r\n    if(b > 0){\r\n      c = a - b;\r\n      assert(c <= a);\r\n    }\r\n    else{\r\n      c = a - b;\r\n      assert(c >= a);\r\n    }\r\n\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Tellor Oracle Storage Library\r\n * @dev Contains all the variables/structs used by Tellor\r\n */\r\n\r\nlibrary TellorStorage {\r\n    //Internal struct for use in proof-of-work submission\r\n    struct Details {\r\n        uint value;\r\n        address miner;\r\n    }\r\n\r\n    struct Dispute {\r\n        bytes32 hash;//unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\r\n        int tally;//current tally of votes for - against measure\r\n        bool executed;//is the dispute settled\r\n        bool disputeVotePassed;//did the vote pass?\r\n        bool isPropFork; //true for fork proposal NEW\r\n        address reportedMiner; //miner who alledgedly submitted the 'bad value' will get disputeFee if dispute vote fails\r\n        address reportingParty;//miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\r\n        address proposedForkAddress;//new fork address (if fork proposal)\r\n        mapping(bytes32 => uint) disputeUintVars;\r\n        //Each of the variables below is saved in the mapping disputeUintVars for each disputeID\r\n        //e.g. TellorStorageStruct.DisputeById[disputeID].disputeUintVars[keccak256(\"requestId\")]\r\n        //These are the variables saved in this mapping:\r\n            // uint keccak256(\"requestId\");//apiID of disputed value\r\n            // uint keccak256(\"timestamp\");//timestamp of distputed value\r\n            // uint keccak256(\"value\"); //the value being disputed\r\n            // uint keccak256(\"minExecutionDate\");//7 days from when dispute initialized\r\n            // uint keccak256(\"numberOfVotes\");//the number of parties who have voted on the measure\r\n            // uint keccak256(\"blockNumber\");// the blocknumber for which votes will be calculated from\r\n            // uint keccak256(\"minerSlot\"); //index in dispute array\r\n            // uint keccak256(\"quorum\"); //quorum for dispute vote NEW\r\n            // uint keccak256(\"fee\"); //fee paid corresponding to dispute\r\n        mapping (address => bool) voted; //mapping of address to whether or not they voted\r\n    }\r\n\r\n    struct StakeInfo {\r\n        uint currentStatus;//0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute\r\n        uint startDate; //stake start date\r\n    }\r\n\r\n    //Internal struct to allow balances to be queried by blocknumber for voting purposes\r\n    struct  Checkpoint {\r\n        uint128 fromBlock;// fromBlock is the block number that the value was generated from\r\n        uint128 value;// value is the amount of tokens at a specific block number\r\n    }\r\n\r\n    struct Request {\r\n        string queryString;//id to string api\r\n        string dataSymbol;//short name for api request\r\n        bytes32 queryHash;//hash of api string and granularity e.g. keccak256(abi.encodePacked(_sapi,_granularity))\r\n        uint[]  requestTimestamps; //array of all newValueTimestamps requested\r\n        mapping(bytes32 => uint) apiUintVars;\r\n        //Each of the variables below is saved in the mapping apiUintVars for each api request\r\n        //e.g. requestDetails[_requestId].apiUintVars[keccak256(\"totalTip\")]\r\n        //These are the variables saved in this mapping:\r\n            // uint keccak256(\"granularity\"); //multiplier for miners\r\n            // uint keccak256(\"requestQPosition\"); //index in requestQ\r\n            // uint keccak256(\"totalTip\");//bonus portion of payout\r\n        mapping(uint => uint) minedBlockNum;//[apiId][minedTimestamp]=>block.number\r\n        mapping(uint => uint) finalValues;//This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\r\n        mapping(uint => bool) inDispute;//checks if API id is in dispute or finalized.\r\n        mapping(uint => address[5]) minersByValue;\r\n        mapping(uint => uint[5])valuesByTimestamp;\r\n    }\r\n\r\n    struct TellorStorageStruct {\r\n        bytes32 currentChallenge; //current challenge to be solved\r\n        uint[51]  requestQ; //uint50 array of the top50 requests by payment amount\r\n        uint[]  newValueTimestamps; //array of all timestamps requested\r\n        Details[5]  currentMiners; //This struct is for organizing the five mined values to find the median\r\n        mapping(bytes32 => address) addressVars;\r\n        //Address fields in the Tellor contract are saved the addressVars mapping\r\n        //e.g. addressVars[keccak256(\"tellorContract\")] = address\r\n        //These are the variables saved in this mapping:\r\n            // address keccak256(\"tellorContract\");//Tellor address\r\n            // address  keccak256(\"_owner\");//Tellor Owner address\r\n            // address  keccak256(\"_deity\");//Tellor Owner that can do things at will\r\n        mapping(bytes32 => uint) uintVars; \r\n        //uint fields in the Tellor contract are saved the uintVars mapping\r\n        //e.g. uintVars[keccak256(\"decimals\")] = uint\r\n        //These are the variables saved in this mapping:\r\n            // keccak256(\"decimals\");    //18 decimal standard ERC20\r\n            // keccak256(\"disputeFee\");//cost to dispute a mined value\r\n            // keccak256(\"disputeCount\");//totalHistoricalDisputes\r\n            // keccak256(\"total_supply\"); //total_supply of the token in circulation\r\n            // keccak256(\"stakeAmount\");//stakeAmount for miners (we can cut gas if we just hardcode it in...or should it be variable?)\r\n            // keccak256(\"stakerCount\"); //number of parties currently staked\r\n            // keccak256(\"timeOfLastNewValue\"); // time of last challenge solved\r\n            // keccak256(\"difficulty\"); // Difficulty of current block\r\n            // keccak256(\"currentTotalTips\"); //value of highest api/timestamp PayoutPool\r\n            // keccak256(\"currentRequestId\"); //API being mined--updates with the ApiOnQ Id\r\n            // keccak256(\"requestCount\"); // total number of requests through the system\r\n            // keccak256(\"slotProgress\");//Number of miners who have mined this value so far\r\n            // keccak256(\"miningReward\");//Mining Reward in PoWo tokens given to all miners per value\r\n            // keccak256(\"timeTarget\"); //The time between blocks (mined Oracle values)\r\n        mapping(bytes32 => mapping(address=>bool)) minersByChallenge;//This is a boolean that tells you if a given challenge has been completed by a given miner\r\n        mapping(uint => uint) requestIdByTimestamp;//minedTimestamp to apiId\r\n        mapping(uint => uint) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\r\n        mapping(uint => Dispute) disputesById;//disputeId=> Dispute details\r\n        mapping (address => Checkpoint[]) balances; //balances of a party given blocks\r\n        mapping(address => mapping (address => uint)) allowed; //allowance for a given party and approver\r\n        mapping(address => StakeInfo)  stakerDetails;//mapping from a persons address to their staking info\r\n        mapping(uint => Request) requestDetails;//mapping of apiID to details\r\n        mapping(bytes32 => uint) requestIdByQueryHash;// api bytes32 gets an id = to count of requests array\r\n        mapping(bytes32 => uint) disputeIdByDisputeHash;//maps a hash to an ID for each dispute\r\n    }\r\n}\r\n\r\n\r\n/**\r\n* @title Tellor Transfer\r\n* @dev Contais the methods related to transfers and ERC20. Tellor.sol and TellorGetters.sol\r\n* reference this library for function's logic.\r\n*/\r\nlibrary TellorTransfer {\r\n    using SafeMath for uint256;\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);//ERC20 Approval event\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);//ERC20 Transfer Event\r\n\r\n    /*Functions*/\r\n    \r\n    /**\r\n    * @dev Allows for a transfer of tokens to _to\r\n    * @param _to The address to send tokens to\r\n    * @param _amount The amount of tokens to send\r\n    * @return true if transfer is successful\r\n    */\r\n    function transfer(TellorStorage.TellorStorageStruct storage self, address _to, uint256 _amount) public returns (bool success) {\r\n        doTransfer(self,msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @notice Send _amount tokens to _to from _from on the condition it\r\n    * is approved by _from\r\n    * @param _from The address holding the tokens being transferred\r\n    * @param _to The address of the recipient\r\n    * @param _amount The amount of tokens to be transferred\r\n    * @return True if the transfer was successful\r\n    */\r\n    function transferFrom(TellorStorage.TellorStorageStruct storage self, address _from, address _to, uint256 _amount) public returns (bool success) {\r\n        require(self.allowed[_from][msg.sender] >= _amount);\r\n        self.allowed[_from][msg.sender] -= _amount;\r\n        doTransfer(self,_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev This function approves a _spender an _amount of tokens to use\r\n    * @param _spender address\r\n    * @param _amount amount the spender is being approved for\r\n    * @return true if spender appproved successfully\r\n    */\r\n    function approve(TellorStorage.TellorStorageStruct storage self, address _spender, uint _amount) public returns (bool) {\r\n        require(allowedToTrade(self,msg.sender,_amount));\r\n        require(_spender != address(0));\r\n        self.allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @param _user address of party with the balance\r\n    * @param _spender address of spender of parties said balance\r\n    * @return Returns the remaining allowance of tokens granted to the _spender from the _user\r\n    */\r\n    function allowance(TellorStorage.TellorStorageStruct storage self,address _user, address _spender) public view returns (uint) {\r\n       return self.allowed[_user][_spender]; \r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Completes POWO transfers by updating the balances on the current block number\r\n    * @param _from address to transfer from\r\n    * @param _to addres to transfer to\r\n    * @param _amount to transfer\r\n    */\r\n    function doTransfer(TellorStorage.TellorStorageStruct storage self, address _from, address _to, uint _amount) public {\r\n        require(_amount > 0);\r\n        require(_to != address(0));\r\n        require(allowedToTrade(self,_from,_amount)); //allowedToTrade checks the stakeAmount is removed from balance if the _user is staked\r\n        uint previousBalance = balanceOfAt(self,_from, block.number);\r\n        updateBalanceAtNow(self.balances[_from], previousBalance - _amount);\r\n        previousBalance = balanceOfAt(self,_to, block.number);\r\n        require(previousBalance + _amount >= previousBalance); // Check for overflow\r\n        updateBalanceAtNow(self.balances[_to], previousBalance + _amount);\r\n        emit Transfer(_from, _to, _amount);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets balance of owner specified\r\n    * @param _user is the owner address used to look up the balance\r\n    * @return Returns the balance associated with the passed in _user\r\n    */\r\n    function balanceOf(TellorStorage.TellorStorageStruct storage self,address _user) public view returns (uint) {\r\n        return balanceOfAt(self,_user, block.number);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Queries the balance of _user at a specific _blockNumber\r\n    * @param _user The address from which the balance will be retrieved\r\n    * @param _blockNumber The block number when the balance is queried\r\n    * @return The balance at _blockNumber specified\r\n    */\r\n    function balanceOfAt(TellorStorage.TellorStorageStruct storage self,address _user, uint _blockNumber) public view returns (uint) {\r\n        if ((self.balances[_user].length == 0) || (self.balances[_user][0].fromBlock > _blockNumber)) {\r\n                return 0;\r\n        }\r\n     else {\r\n        return getBalanceAt(self.balances[_user], _blockNumber);\r\n     }\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter for balance for owner on the specified _block number\r\n    * @param checkpoints gets the mapping for the balances[owner]\r\n    * @param _block is the block number to search the balance on\r\n    * @return the balance at the checkpoint\r\n    */\r\n    function getBalanceAt(TellorStorage.Checkpoint[] storage checkpoints, uint _block) view public returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n        // Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev This function returns whether or not a given user is allowed to trade a given amount \r\n    * and removing the staked amount from their balance if they are staked\r\n    * @param _user address of user\r\n    * @param _amount to check if the user can spend\r\n    * @return true if they are allowed to spend the amount being checked\r\n    */\r\n    function allowedToTrade(TellorStorage.TellorStorageStruct storage self,address _user,uint _amount) public view returns(bool) {\r\n        if(self.stakerDetails[_user].currentStatus >0){\r\n            //Removes the stakeAmount from balance if the _user is staked\r\n            if(balanceOf(self,_user).sub(self.uintVars[keccak256(\"stakeAmount\")]).sub(_amount) >= 0){\r\n                return true;\r\n            }\r\n        }\r\n        else if(balanceOf(self,_user).sub(_amount) >= 0){\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n\r\n    /**\r\n    * @dev Updates balance for from and to on the current block number via doTransfer\r\n    * @param checkpoints gets the mapping for the balances[owner]\r\n    * @param _value is the new balance\r\n    */\r\n    function updateBalanceAtNow(TellorStorage.Checkpoint[] storage checkpoints, uint _value) public {\r\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               TellorStorage.Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n        } else {\r\n               TellorStorage.Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n//import \"./SafeMath.sol\";\r\n\r\n/**\r\n* @title Tellor Dispute\r\n* @dev Contais the methods related to disputes. Tellor.sol references this library for function's logic.\r\n*/\r\n\r\n\r\nlibrary TellorDispute {\r\n    using SafeMath for uint256;\r\n    using SafeMath for int256;\r\n\r\n    event NewDispute(uint indexed _disputeId, uint indexed _requestId, uint _timestamp, address _miner);//emitted when a new dispute is initialized\r\n    event Voted(uint indexed _disputeID, bool _position, address indexed _voter);//emitted when a new vote happens\r\n    event DisputeVoteTallied(uint indexed _disputeID, int _result,address indexed _reportedMiner,address _reportingParty, bool _active);//emitted upon dispute tally\r\n    event NewTellorAddress(address _newTellor); //emmited when a proposed fork is voted true\r\n\r\n    /*Functions*/\r\n    \r\n    /**\r\n    * @dev Helps initialize a dispute by assigning it a disputeId\r\n    * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\r\n    * invalidated value information to POS voting\r\n    * @param _requestId being disputed\r\n    * @param _timestamp being disputed\r\n    * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\r\n    * requires 5 miners to submit a value.\r\n    */\r\n    function beginDispute(TellorStorage.TellorStorageStruct storage self,uint _requestId, uint _timestamp,uint _minerIndex) public {\r\n        TellorStorage.Request storage _request = self.requestDetails[_requestId];\r\n        //require that no more than a day( (24 hours * 60 minutes)/10minutes=144 blocks) has gone by since the value was \"mined\"\r\n        require(block.number- _request.minedBlockNum[_timestamp]<= 144);\r\n        require(_request.minedBlockNum[_timestamp] > 0);\r\n        require(_minerIndex < 5);\r\n        \r\n        //_miner is the miner being disputed. For every mined value 5 miners are saved in an array and the _minerIndex\r\n        //provided by the party initiating the dispute\r\n        address _miner = _request.minersByValue[_timestamp][_minerIndex];\r\n        bytes32 _hash = keccak256(abi.encodePacked(_miner,_requestId,_timestamp));\r\n        \r\n        //Ensures that a dispute is not already open for the that miner, requestId and timestamp\r\n        require(self.disputeIdByDisputeHash[_hash] == 0);\r\n        TellorTransfer.doTransfer(self, msg.sender,address(this), self.uintVars[keccak256(\"disputeFee\")]);\r\n        \r\n        //Increase the dispute count by 1\r\n        self.uintVars[keccak256(\"disputeCount\")] =  self.uintVars[keccak256(\"disputeCount\")] + 1;\r\n        \r\n        //Sets the new disputeCount as the disputeId\r\n        uint disputeId = self.uintVars[keccak256(\"disputeCount\")];\r\n        \r\n        //maps the dispute hash to the disputeId\r\n        self.disputeIdByDisputeHash[_hash] = disputeId;\r\n        //maps the dispute to the Dispute struct\r\n        self.disputesById[disputeId] = TellorStorage.Dispute({\r\n            hash:_hash,\r\n            isPropFork: false,\r\n            reportedMiner: _miner,\r\n            reportingParty: msg.sender,\r\n            proposedForkAddress:address(0),\r\n            executed: false,\r\n            disputeVotePassed: false,\r\n            tally: 0\r\n            });\r\n        \r\n        //Saves all the dispute variables for the disputeId\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"requestId\")] = _requestId;\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"timestamp\")] = _timestamp;\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"value\")] = _request.valuesByTimestamp[_timestamp][_minerIndex];\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"minExecutionDate\")] = now + 7 days;\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"blockNumber\")] = block.number;\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"minerSlot\")] = _minerIndex;\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"fee\")]  = self.uintVars[keccak256(\"disputeFee\")];\r\n        \r\n        //Values are sorted as they come in and the official value is the median of the first five\r\n        //So the \"official value\" miner is always minerIndex==2. If the official value is being \r\n        //disputed, it sets its status to inDispute(currentStatus = 3) so that users are made aware it is under dispute\r\n        if(_minerIndex == 2){\r\n            self.requestDetails[_requestId].inDispute[_timestamp] = true;\r\n        }\r\n        self.stakerDetails[_miner].currentStatus = 3;\r\n        emit NewDispute(disputeId,_requestId,_timestamp,_miner);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Allows token holders to vote\r\n    * @param _disputeId is the dispute id\r\n    * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\r\n    */\r\n    function vote(TellorStorage.TellorStorageStruct storage self, uint _disputeId, bool _supportsDispute) public {\r\n        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\r\n        \r\n        //Get the voteWeight or the balance of the user at the time/blockNumber the disupte began\r\n        uint voteWeight = TellorTransfer.balanceOfAt(self,msg.sender,disp.disputeUintVars[keccak256(\"blockNumber\")]);\r\n        \r\n        //Require that the msg.sender has not voted\r\n        require(disp.voted[msg.sender] != true);\r\n        \r\n        //Requre that the user had a balance >0 at time/blockNumber the disupte began\r\n        require(voteWeight > 0);\r\n        \r\n        //ensures miners that are under dispute cannot vote\r\n        require(self.stakerDetails[msg.sender].currentStatus != 3);\r\n        \r\n        //Update user voting status to true\r\n        disp.voted[msg.sender] = true;\r\n        \r\n        //Update the number of votes for the dispute\r\n        disp.disputeUintVars[keccak256(\"numberOfVotes\")] += 1;\r\n        \r\n        //Update the quorum by adding the voteWeight\r\n        disp.disputeUintVars[keccak256(\"quorum\")] += voteWeight; \r\n        \r\n        //If the user supports the dispute increase the tally for the dispute by the voteWeight\r\n        //otherwise decrease it\r\n        if (_supportsDispute) {\r\n            disp.tally = disp.tally.add(int(voteWeight));\r\n        } else {\r\n            disp.tally = disp.tally.sub(int(voteWeight));\r\n        }\r\n        \r\n        //Let the network know the user has voted on the dispute and their casted vote\r\n        emit Voted(_disputeId,_supportsDispute,msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev tallies the votes.\r\n    * @param _disputeId is the dispute id\r\n    */\r\n    function tallyVotes(TellorStorage.TellorStorageStruct storage self, uint _disputeId) public {\r\n        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\r\n        TellorStorage.Request storage _request = self.requestDetails[disp.disputeUintVars[keccak256(\"requestId\")]];\r\n\r\n        //Ensure this has not already been executed/tallied\r\n        require(disp.executed == false);\r\n\r\n        //Ensure the time for voting has elapsed\r\n        require(now > disp.disputeUintVars[keccak256(\"minExecutionDate\")]);  \r\n\r\n        //If the vote is not a proposed fork \r\n        if (disp.isPropFork== false){\r\n        TellorStorage.StakeInfo storage stakes = self.stakerDetails[disp.reportedMiner];  \r\n            //If the vote for disputing a value is succesful(disp.tally >0) then unstake the reported \r\n            // miner and transfer the stakeAmount and dispute fee to the reporting party \r\n            if (disp.tally > 0 ) { \r\n\r\n                //Changing the currentStatus and startDate unstakes the reported miner and allows for the\r\n                //transfer of the stakeAmount\r\n                stakes.currentStatus = 0;\r\n                stakes.startDate = now -(now % 86400);\r\n\r\n                //Decreases the stakerCount since the miner's stake is being slashed\r\n                self.uintVars[keccak256(\"stakerCount\")]--;\r\n                updateDisputeFee(self);\r\n\r\n                //Transfers the StakeAmount from the reporded miner to the reporting party\r\n                TellorTransfer.doTransfer(self, disp.reportedMiner,disp.reportingParty, self.uintVars[keccak256(\"stakeAmount\")]);\r\n                \r\n                //Returns the dispute fee to the reportingParty\r\n                TellorTransfer.doTransfer(self, address(this),disp.reportingParty,disp.disputeUintVars[keccak256(\"fee\")]);\r\n                \r\n                //Set the dispute state to passed/true\r\n                disp.disputeVotePassed = true;\r\n\r\n                //If the dispute was succeful(miner found guilty) then update the timestamp value to zero\r\n                //so that users don't use this datapoint\r\n                if(_request.inDispute[disp.disputeUintVars[keccak256(\"timestamp\")]] == true){\r\n                    _request.finalValues[disp.disputeUintVars[keccak256(\"timestamp\")]] = 0;\r\n                }\r\n\r\n            //If the vote for disputing a value is unsuccesful then update the miner status from being on \r\n            //dispute(currentStatus=3) to staked(currentStatus =1) and tranfer the dispute fee to the miner\r\n            } else {\r\n                //Update the miner's current status to staked(currentStatus = 1)\r\n                stakes.currentStatus = 1;              \r\n                //tranfer the dispute fee to the miner\r\n                TellorTransfer.doTransfer(self,address(this),disp.reportedMiner,disp.disputeUintVars[keccak256(\"fee\")]);\r\n                if(_request.inDispute[disp.disputeUintVars[keccak256(\"timestamp\")]] == true){\r\n                    _request.inDispute[disp.disputeUintVars[keccak256(\"timestamp\")]] = false;\r\n                }\r\n            }\r\n        //If the vote is for a proposed fork require a 20% quorum before excecuting the update to the new tellor contract address\r\n        } else {\r\n            if(disp.tally > 0 ){\r\n                require(disp.disputeUintVars[keccak256(\"quorum\")] >  (self.uintVars[keccak256(\"total_supply\")] * 20 / 100));\r\n                self.addressVars[keccak256(\"tellorContract\")] = disp.proposedForkAddress;\r\n                disp.disputeVotePassed = true;\r\n                emit NewTellorAddress(disp.proposedForkAddress);\r\n            }\r\n        }\r\n        \r\n        //update the dispute status to executed\r\n        disp.executed = true;\r\n        emit DisputeVoteTallied(_disputeId,disp.tally,disp.reportedMiner,disp.reportingParty,disp.disputeVotePassed);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Allows for a fork to be proposed\r\n    * @param _propNewTellorAddress address for new proposed Tellor\r\n    */\r\n    function proposeFork(TellorStorage.TellorStorageStruct storage self, address _propNewTellorAddress) public {\r\n        bytes32 _hash = keccak256(abi.encodePacked(_propNewTellorAddress));\r\n        require(self.disputeIdByDisputeHash[_hash] == 0);\r\n        TellorTransfer.doTransfer(self, msg.sender,address(this), self.uintVars[keccak256(\"disputeFee\")]);//This is the fork fee\r\n        self.uintVars[keccak256(\"disputeCount\")]++;\r\n        uint disputeId = self.uintVars[keccak256(\"disputeCount\")];\r\n        self.disputeIdByDisputeHash[_hash] = disputeId;\r\n        self.disputesById[disputeId] = TellorStorage.Dispute({\r\n            hash: _hash,\r\n            isPropFork: true,\r\n            reportedMiner: msg.sender, \r\n            reportingParty: msg.sender, \r\n            proposedForkAddress: _propNewTellorAddress,\r\n            executed: false,\r\n            disputeVotePassed: false,\r\n            tally: 0\r\n            }); \r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"blockNumber\")] = block.number;\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"fee\")]  = self.uintVars[keccak256(\"disputeFee\")];\r\n        self.disputesById[disputeId].disputeUintVars[keccak256(\"minExecutionDate\")] = now + 7 days;\r\n    }\r\n    \r\n\r\n    /**\r\n    * @dev this function allows the dispute fee to fluctuate based on the number of miners on the system.\r\n    * The floor for the fee is 15e18.\r\n    */\r\n    function updateDisputeFee(TellorStorage.TellorStorageStruct storage self) public {\r\n            //if the number of staked miners divided by the target count of staked miners is less than 1\r\n            if(self.uintVars[keccak256(\"stakerCount\")]*1000/self.uintVars[keccak256(\"targetMiners\")] < 1000){\r\n                //Set the dispute fee at stakeAmt * (1- stakerCount/targetMiners)\r\n                //or at the its minimum of 15e18 \r\n                self.uintVars[keccak256(\"disputeFee\")] = SafeMath.max(15e18,self.uintVars[keccak256(\"stakeAmount\")].mul(1000 - self.uintVars[keccak256(\"stakerCount\")]*1000/self.uintVars[keccak256(\"targetMiners\")])/1000);\r\n            }\r\n            else{\r\n                //otherwise set the dispute fee at 15e18 (the floor/minimum fee allowed)\r\n                self.uintVars[keccak256(\"disputeFee\")] = 15e18;\r\n            }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n* itle Tellor Dispute\r\n* @dev Contais the methods related to miners staking and unstaking. Tellor.sol \r\n* references this library for function's logic.\r\n*/\r\n\r\nlibrary TellorStake {\r\n    event NewStake(address indexed _sender);//Emits upon new staker\r\n    event StakeWithdrawn(address indexed _sender);//Emits when a staker is now no longer staked\r\n    event StakeWithdrawRequested(address indexed _sender);//Emits when a staker begins the 7 day withdraw period\r\n\r\n    /*Functions*/\r\n    \r\n    /**\r\n    * @dev This function stakes the five initial miners, sets the supply and all the constant variables.\r\n    * This function is called by the constructor function on TellorMaster.sol\r\n    */\r\n    function init(TellorStorage.TellorStorageStruct storage self) public{\r\n        require(self.uintVars[keccak256(\"decimals\")] == 0);\r\n        //Give this contract 6000 Tellor Tributes so that it can stake the initial 6 miners\r\n        TellorTransfer.updateBalanceAtNow(self.balances[address(this)], 2**256-1 - 6000e18);\r\n\r\n        // //the initial 5 miner addresses are specfied below\r\n        // //changed payable[5] to 6\r\n        address payable[6] memory _initalMiners = [address(0xE037EC8EC9ec423826750853899394dE7F024fee),\r\n        address(0xcdd8FA31AF8475574B8909F135d510579a8087d3),\r\n        address(0xb9dD5AfD86547Df817DA2d0Fb89334A6F8eDd891),\r\n        address(0x230570cD052f40E14C14a81038c6f3aa685d712B),\r\n        address(0x3233afA02644CCd048587F8ba6e99b3C00A34DcC),\r\n        address(0xe010aC6e0248790e08F42d5F697160DEDf97E024)];\r\n        //Stake each of the 5 miners specified above\r\n        for(uint i=0;i<6;i++){//6th miner to allow for dispute\r\n            //Miner balance is set at 1000e18 at the block that this function is ran\r\n            TellorTransfer.updateBalanceAtNow(self.balances[_initalMiners[i]],1000e18);\r\n\r\n            newStake(self, _initalMiners[i]);\r\n        }\r\n\r\n        //update the total suppply\r\n        self.uintVars[keccak256(\"total_supply\")] += 6000e18;//6th miner to allow for dispute\r\n        //set Constants\r\n        self.uintVars[keccak256(\"decimals\")] = 18;\r\n        self.uintVars[keccak256(\"targetMiners\")] = 200;\r\n        self.uintVars[keccak256(\"stakeAmount\")] = 1000e18;\r\n        self.uintVars[keccak256(\"disputeFee\")] = 970e18;\r\n        self.uintVars[keccak256(\"timeTarget\")]= 600;\r\n        self.uintVars[keccak256(\"timeOfLastNewValue\")] = now - now  % self.uintVars[keccak256(\"timeTarget\")];\r\n        self.uintVars[keccak256(\"difficulty\")] = 1;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev This function allows stakers to request to withdraw their stake (no longer stake)\r\n    * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\r\n    * can withdraw the deposit\r\n    */\r\n    function requestStakingWithdraw(TellorStorage.TellorStorageStruct storage self) public {\r\n        TellorStorage.StakeInfo storage stakes = self.stakerDetails[msg.sender];\r\n        //Require that the miner is staked\r\n        require(stakes.currentStatus == 1);\r\n\r\n        //Change the miner staked to locked to be withdrawStake\r\n        stakes.currentStatus = 2;\r\n\r\n        //Change the startDate to now since the lock up period begins now\r\n        //and the miner can only withdraw 7 days later from now(check the withdraw function)\r\n        stakes.startDate = now -(now % 86400);\r\n\r\n        //Reduce the staker count\r\n        self.uintVars[keccak256(\"stakerCount\")] -= 1;\r\n        TellorDispute.updateDisputeFee(self);\r\n        emit StakeWithdrawRequested(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev This function allows users to withdraw their stake after a 7 day waiting period from request \r\n    */\r\n    function withdrawStake(TellorStorage.TellorStorageStruct storage self) public {\r\n        TellorStorage.StakeInfo storage stakes = self.stakerDetails[msg.sender];\r\n        //Require the staker has locked for withdraw(currentStatus ==2) and that 7 days have \r\n        //passed by since they locked for withdraw\r\n        require(now - (now % 86400) - stakes.startDate >= 7 days);\r\n        require(stakes.currentStatus == 2);\r\n        stakes.currentStatus = 0;\r\n        emit StakeWithdrawn(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev This function allows miners to deposit their stake.\r\n    */\r\n    function depositStake(TellorStorage.TellorStorageStruct storage self) public {\r\n      newStake(self, msg.sender);\r\n      //self adjusting disputeFee\r\n      TellorDispute.updateDisputeFee(self);\r\n    }\r\n\r\n    /**\r\n    * @dev This function is used by the init function to succesfully stake the initial 5 miners.\r\n    * The function updates their status/state and status start date so they are locked it so they can't withdraw\r\n    * and updates the number of stakers in the system.\r\n    */\r\n    function newStake(TellorStorage.TellorStorageStruct storage self, address staker) internal {\r\n        require(TellorTransfer.balanceOf(self,staker) >= self.uintVars[keccak256(\"stakeAmount\")]);\r\n        //Ensure they can only stake if they are not currrently staked or if their stake time frame has ended\r\n        //and they are currently locked for witdhraw\r\n        require(self.stakerDetails[staker].currentStatus == 0 || self.stakerDetails[staker].currentStatus == 2);\r\n        self.uintVars[keccak256(\"stakerCount\")] += 1;\r\n        self.stakerDetails[staker] = TellorStorage.StakeInfo({\r\n            currentStatus: 1,\r\n            //this resets their stake start date to today\r\n            startDate: now - (now % 86400)\r\n        });\r\n        emit NewStake(staker);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n* @title Tellor Getters\r\n* @dev Oracle contract with all tellor getter functions. The logic for the functions on this contract \r\n* is saved on the TellorGettersLibrary, TellorTransfer, TellorGettersLibrary, and TellorStake\r\n*/\r\ncontract TellorGetters{\r\n    using SafeMath for uint256;\r\n\r\n    using TellorTransfer for TellorStorage.TellorStorageStruct;\r\n    using TellorGettersLibrary for TellorStorage.TellorStorageStruct;\r\n    using TellorStake for TellorStorage.TellorStorageStruct;\r\n\r\n    TellorStorage.TellorStorageStruct tellor;\r\n    \r\n    /**\r\n    * @param _user address\r\n    * @param _spender address\r\n    * @return Returns the remaining allowance of tokens granted to the _spender from the _user\r\n    */\r\n    function allowance(address _user, address _spender) external view returns (uint) {\r\n       return tellor.allowance(_user,_spender);\r\n    }\r\n\r\n    /**\r\n    * @dev This function returns whether or not a given user is allowed to trade a given amount  \r\n    * @param _user address\r\n    * @param _amount uint of amount\r\n    * @return true if the user is alloed to trade the amount specified\r\n    */\r\n    function allowedToTrade(address _user,uint _amount) external view returns(bool){\r\n        return tellor.allowedToTrade(_user,_amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets balance of owner specified\r\n    * @param _user is the owner address used to look up the balance\r\n    * @return Returns the balance associated with the passed in _user\r\n    */\r\n    function balanceOf(address _user) external view returns (uint) { \r\n        return tellor.balanceOf(_user);\r\n    }\r\n\r\n    /**\r\n    * @dev Queries the balance of _user at a specific _blockNumber\r\n    * @param _user The address from which the balance will be retrieved\r\n    * @param _blockNumber The block number when the balance is queried\r\n    * @return The balance at _blockNumber\r\n    */\r\n    function balanceOfAt(address _user, uint _blockNumber) external view returns (uint) {\r\n        return tellor.balanceOfAt(_user,_blockNumber);\r\n    }\r\n\r\n    /**\r\n    * @dev This function tells you if a given challenge has been completed by a given miner\r\n    * @param _challenge the challenge to search for\r\n    * @param _miner address that you want to know if they solved the challenge\r\n    * @return true if the _miner address provided solved the \r\n    */\r\n    function didMine(bytes32 _challenge, address _miner) external view returns(bool){\r\n        return tellor.didMine(_challenge,_miner);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Checks if an address voted in a given dispute\r\n    * @param _disputeId to look up\r\n    * @param _address to look up\r\n    * @return bool of whether or not party voted\r\n    */\r\n    function didVote(uint _disputeId, address _address) external view returns(bool){\r\n        return tellor.didVote(_disputeId,_address);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev allows Tellor to read data from the addressVars mapping\r\n    * @param _data is the keccak256(\"variable_name\") of the variable that is being accessed. \r\n    * These are examples of how the variables are saved within other functions:\r\n    * addressVars[keccak256(\"_owner\")]\r\n    * addressVars[keccak256(\"tellorContract\")]\r\n    */\r\n    function getAddressVars(bytes32 _data) view external returns(address){\r\n        return tellor.getAddressVars(_data);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets all dispute variables\r\n    * @param _disputeId to look up\r\n    * @return bytes32 hash of dispute \r\n    * @return bool executed where true if it has been voted on\r\n    * @return bool disputeVotePassed\r\n    * @return bool isPropFork true if the dispute is a proposed fork\r\n    * @return address of reportedMiner\r\n    * @return address of reportingParty\r\n    * @return address of proposedForkAddress\r\n    * @return uint of requestId\r\n    * @return uint of timestamp\r\n    * @return uint of value\r\n    * @return uint of minExecutionDate\r\n    * @return uint of numberOfVotes\r\n    * @return uint of blocknumber\r\n    * @return uint of minerSlot\r\n    * @return uint of quorum\r\n    * @return uint of fee\r\n    * @return int count of the current tally\r\n    */\r\n    function getAllDisputeVars(uint _disputeId) public view returns(bytes32, bool, bool, bool, address, address, address,uint[9] memory, int){\r\n        return tellor.getAllDisputeVars(_disputeId);\r\n    }\r\n    \r\n\r\n    /**\r\n    * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\r\n    * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request \r\n    */\r\n    function getCurrentVariables() external view returns(bytes32, uint, uint,string memory,uint,uint){    \r\n        return tellor.getCurrentVariables();\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if a given hash of miner,requestId has been disputed\r\n    * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\r\n    * @return uint disputeId\r\n    */\r\n    function getDisputeIdByDisputeHash(bytes32 _hash) external view returns(uint){\r\n        return  tellor.getDisputeIdByDisputeHash(_hash);\r\n    }\r\n    \r\n\r\n    /**\r\n    * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\r\n    * @param _disputeId is the dispute id;\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is \r\n    * the variables/strings used to save the data in the mapping. The variables names are  \r\n    * commented out under the disputeUintVars under the Dispute struct\r\n    * @return uint value for the bytes32 data submitted\r\n    */\r\n    function getDisputeUintVars(uint _disputeId,bytes32 _data) external view returns(uint){\r\n        return tellor.getDisputeUintVars(_disputeId,_data);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets the a value for the latest timestamp available\r\n    * @return value for timestamp of last proof of work submited\r\n    * @return true if the is a timestamp for the lastNewValue\r\n    */\r\n    function getLastNewValue() external view returns(uint,bool){\r\n        return tellor.getLastNewValue();\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets the a value for the latest timestamp available\r\n    * @param _requestId being requested\r\n    * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\r\n    */\r\n    function getLastNewValueById(uint _requestId) external view returns(uint,bool){\r\n        return tellor.getLastNewValueById(_requestId);\r\n    }\r\n        \r\n\r\n    /**\r\n    * @dev Gets blocknumber for mined timestamp \r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up blocknumber\r\n    * @return uint of the blocknumber which the dispute was mined\r\n    */\r\n    function getMinedBlockNum(uint _requestId, uint _timestamp) external view returns(uint){\r\n        return tellor.getMinedBlockNum(_requestId,_timestamp);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp \r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up miners for\r\n    * @return the 5 miners' addresses\r\n    */\r\n    function getMinersByRequestIdAndTimestamp(uint _requestId, uint _timestamp) external view returns(address[5] memory){\r\n        return tellor.getMinersByRequestIdAndTimestamp(_requestId,_timestamp);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Get the name of the token\r\n    * return string of the token name\r\n    */\r\n    function getName() external view returns(string memory){\r\n        return tellor.getName();\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Counts the number of values that have been submited for the request \r\n    * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\r\n    * request so far\r\n    * @param _requestId the requestId to look up\r\n    * @return uint count of the number of values received for the requestId\r\n    */\r\n    function getNewValueCountbyRequestId(uint _requestId) external view returns(uint){\r\n        return tellor.getNewValueCountbyRequestId(_requestId);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter function for the specified requestQ index\r\n    * @param _index to look up in the requestQ array\r\n    * @return uint of reqeuestId\r\n    */\r\n    function getRequestIdByRequestQIndex(uint _index) external view returns(uint){\r\n        return tellor.getRequestIdByRequestQIndex(_index);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter function for requestId based on timestamp \r\n    * @param _timestamp to check requestId\r\n    * @return uint of reqeuestId\r\n    */\r\n    function getRequestIdByTimestamp(uint _timestamp) external view returns(uint){    \r\n        return tellor.getRequestIdByTimestamp(_timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev Getter function for requestId based on the queryHash\r\n    * @param _request is the hash(of string api and granularity) to check if a request already exists\r\n    * @return uint requestId\r\n    */\r\n    function getRequestIdByQueryHash(bytes32 _request) external view returns(uint){    \r\n        return tellor.getRequestIdByQueryHash(_request);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter function for the requestQ array\r\n    * @return the requestQ arrray\r\n    */\r\n    function getRequestQ() view public returns(uint[51] memory){\r\n        return tellor.getRequestQ();\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\r\n    * for the requestId specified\r\n    * @param _requestId to look up\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is \r\n    * the variables/strings used to save the data in the mapping. The variables names are  \r\n    * commented out under the apiUintVars under the requestDetails struct\r\n    * @return uint value of the apiUintVars specified in _data for the requestId specified\r\n    */\r\n    function getRequestUintVars(uint _requestId,bytes32 _data) external view returns(uint){\r\n        return tellor.getRequestUintVars(_requestId,_data);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets the API struct variables that are not mappings\r\n    * @param _requestId to look up\r\n    * @return string of api to query\r\n    * @return string of symbol of api to query\r\n    * @return bytes32 hash of string\r\n    * @return bytes32 of the granularity(decimal places) requested\r\n    * @return uint of index in requestQ array\r\n    * @return uint of current payout/tip for this requestId\r\n    */\r\n    function getRequestVars(uint _requestId) external view returns(string memory, string memory,bytes32,uint, uint, uint) {\r\n        return tellor.getRequestVars(_requestId);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev This function allows users to retireve all information about a staker\r\n    * @param _staker address of staker inquiring about\r\n    * @return uint current state of staker\r\n    * @return uint startDate of staking\r\n    */\r\n    function getStakerInfo(address _staker) external view returns(uint,uint){\r\n        return tellor.getStakerInfo(_staker);\r\n    }\r\n    \r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp \r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestampt to look up miners for\r\n    * @return address[5] array of 5 addresses ofminers that mined the requestId\r\n    */    \r\n    function getSubmissionsByTimestamp(uint _requestId, uint _timestamp) external view returns(uint[5] memory){\r\n        return tellor.getSubmissionsByTimestamp(_requestId,_timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev Get the symbol of the token\r\n    * return string of the token symbol\r\n    */\r\n    function getSymbol() external view returns(string memory){\r\n        return tellor.getSymbol();\r\n    } \r\n\r\n    /**\r\n    * @dev Gets the timestamp for the value based on their index\r\n    * @param _requestID is the requestId to look up\r\n    * @param _index is the value index to look up\r\n    * @return uint timestamp\r\n    */\r\n    function getTimestampbyRequestIDandIndex(uint _requestID, uint _index) external view returns(uint){\r\n        return tellor.getTimestampbyRequestIDandIndex(_requestID,_index);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is \r\n    * the variables/strings used to save the data in the mapping. The variables names are  \r\n    * commented out under the uintVars under the TellorStorageStruct struct\r\n    * This is an example of how data is saved into the mapping within other functions: \r\n    * self.uintVars[keccak256(\"stakerCount\")]\r\n    * @return uint of specified variable  \r\n    */ \r\n    function getUintVar(bytes32 _data) view public returns(uint){\r\n        return tellor.getUintVar(_data);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\r\n    * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\r\n    */\r\n    function getVariablesOnDeck() external view returns(uint, uint,string memory){    \r\n        return tellor.getVariablesOnDeck();\r\n    }\r\n\r\n    \r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp \r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up miners for\r\n    * @return bool true if requestId/timestamp is under dispute\r\n    */\r\n    function isInDispute(uint _requestId, uint _timestamp) external view returns(bool){\r\n        return tellor.isInDispute(_requestId,_timestamp);\r\n    }\r\n    \r\n\r\n    /**\r\n    * @dev Retreive value from oracle based on timestamp\r\n    * @param _requestId being requested\r\n    * @param _timestamp to retreive data/value from\r\n    * @return value for timestamp submitted\r\n    */\r\n    function retrieveData(uint _requestId, uint _timestamp) external view returns (uint) {\r\n        return tellor.retrieveData(_requestId,_timestamp);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Getter for the total_supply of oracle tokens\r\n    * @return uint total supply\r\n    */\r\n    function totalSupply() external view returns (uint) {\r\n       return tellor.totalSupply();\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n* @title Tellor Master\r\n* @dev This is the Master contract with all tellor getter functions and delegate call to Tellor. \r\n* The logic for the functions on this contract is saved on the TellorGettersLibrary, TellorTransfer, \r\n* TellorGettersLibrary, and TellorStake\r\n*/\r\ncontract TellorMaster is TellorGetters{\r\n    \r\n    event NewTellorAddress(address _newTellor);\r\n\r\n    /**\r\n    * @dev The constructor sets the original `tellorStorageOwner` of the contract to the sender\r\n    * account, the tellor contract to the Tellor master address and owner to the Tellor master owner address \r\n    * @param _tellorContract is the address for the tellor contract\r\n    */\r\n    constructor (address _tellorContract)  public{\r\n        tellor.init();\r\n        tellor.addressVars[keccak256(\"_owner\")] = msg.sender;\r\n        tellor.addressVars[keccak256(\"_deity\")] = msg.sender;\r\n        tellor.addressVars[keccak256(\"tellorContract\")]= _tellorContract;\r\n        emit NewTellorAddress(_tellorContract);\r\n    }\r\n    \r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp \r\n    * @dev Only needs to be in library\r\n    * @param _newDeity the new Deity in the contract\r\n    */\r\n\r\n    function changeDeity(address _newDeity) external{\r\n        tellor.changeDeity(_newDeity);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev  allows for the deity to make fast upgrades.  Deity should be 0 address if decentralized\r\n    * @param _tellorContract the address of the new Tellor Contract\r\n    */\r\n    function changeTellorContract(address _tellorContract) external{\r\n        tellor.changeTellorContract(_tellorContract);\r\n    }\r\n  \r\n\r\n    /**\r\n    * @dev This is the fallback function that allows contracts to call the tellor contract at the address stored\r\n    */\r\n    function () external payable {\r\n        address addr = tellor.addressVars[keccak256(\"tellorContract\")];\r\n        bytes memory _calldata = msg.data;\r\n        assembly {\r\n            let result := delegatecall(not(0), addr, add(_calldata, 0x20), mload(_calldata), 0, 0)\r\n            let size := returndatasize\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n            // if the call returned error data, forward it\r\n            switch result case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getRequestIdByTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"uint256\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getSubmissionsByTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getAddressVars\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSymbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVariablesOnDeck\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_request\",\"type\":\"bytes32\"}],\"name\":\"getRequestIdByQueryHash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getLastNewValueById\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"uint256\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"isInDispute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getNewValueCountbyRequestId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDeity\",\"type\":\"address\"}],\"name\":\"changeDeity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getUintVar\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getRequestIdByRequestQIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_challenge\",\"type\":\"bytes32\"},{\"name\":\"_miner\",\"type\":\"address\"}],\"name\":\"didMine\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"uint256\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getMinersByRequestIdAndTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"address[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getStakerInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_requestID\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTimestampbyRequestIDandIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getDisputeUintVars\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"uint256\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"retrieveData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"allowedToTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentVariables\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"didVote\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tellorContract\",\"type\":\"address\"}],\"name\":\"changeTellorContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"getAllDisputeVars\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256[9]\"},{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRequestQ\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[51]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"uint256\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getMinedBlockNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"getDisputeIdByDisputeHash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getRequestUintVars\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getRequestVars\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastNewValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tellorContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newTellor\",\"type\":\"address\"}],\"name\":\"NewTellorAddress\",\"type\":\"event\"}]","ContractName":"TellorMaster","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000e72ef1b7bb0b089d7481f22d3f6b57da7aaf849","Library":"TellorTransfer:9bd8080d5758def80ac25d111d0a2859efd42935;TellorStake:11b83894f3d57c5864160de900fd790b314863f9","SwarmSource":"bzzr://de19597b9c63c19caec09141a2133b225ca56283bc9133d268b32f7dab0d34db"}]}