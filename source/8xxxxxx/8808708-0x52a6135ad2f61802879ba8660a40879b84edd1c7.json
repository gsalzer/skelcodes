{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address who) external view returns (uint);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n}\r\n\r\ncontract ERC20AtomicSwapper {\r\n\r\n    struct Swap {\r\n        uint256 outAmount;\r\n        uint256 expireHeight;\r\n        bytes32 randomNumberHash;\r\n        uint64  timestamp;\r\n        address sender;\r\n        address recipientAddr;\r\n    }\r\n\r\n    enum States {\r\n        INVALID,\r\n        OPEN,\r\n        COMPLETED,\r\n        EXPIRED\r\n    }\r\n\r\n    // Events\r\n    event HTLT(address indexed _msgSender, address indexed _recipientAddr, bytes32 indexed _swapID, bytes32 _randomNumberHash, uint64 _timestamp, bytes20 _bep2Addr, uint256 _expireHeight, uint256 _outAmount, uint256 _bep2Amount);\r\n    event Refunded(address indexed _msgSender, address indexed _recipientAddr, bytes32 indexed _swapID, bytes32 _randomNumberHash);\r\n    event Claimed(address indexed _msgSender, address indexed _recipientAddr, bytes32 indexed _swapID, bytes32 _randomNumberHash, bytes32 _randomNumber);\r\n\r\n    // Storage\r\n    mapping (bytes32 => Swap) private swaps;\r\n    mapping (bytes32 => States) private swapStates;\r\n\r\n    address public ERC20ContractAddr;\r\n\r\n    /// @notice Throws if the swap is not open.\r\n    modifier onlyOpenSwaps(bytes32 _swapID) {\r\n        require(swapStates[_swapID] == States.OPEN, \"swap is not opened\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Throws if the swap is already expired.\r\n    modifier onlyAfterExpireHeight(bytes32 _swapID) {\r\n        require(block.number >= swaps[_swapID].expireHeight, \"swap is not expired\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Throws if the expireHeight is reached\r\n    modifier onlyBeforeExpireHeight(bytes32 _swapID) {\r\n        require(block.number < swaps[_swapID].expireHeight, \"swap is already expired\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Throws if the random number is not valid.\r\n    modifier onlyWithRandomNumber(bytes32 _swapID, bytes32 _randomNumber) {\r\n        require(swaps[_swapID].randomNumberHash == sha256(abi.encodePacked(_randomNumber, swaps[_swapID].timestamp)), \"invalid randomNumber\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        ERC20ContractAddr = address(0x1b22C32cD936cB97C28C5690a0695a82Abf688e6);\r\n    }\r\n\r\n    /// @notice htlt locks asset to contract address and create an atomic swap.\r\n    ///\r\n    /// @param _randomNumberHash The hash of the random number and timestamp\r\n    /// @param _timestamp Counted by second\r\n    /// @param _heightSpan The number of blocks to wait before the asset can be returned to sender\r\n    /// @param _recipientAddr The ethereum address of the swap counterpart.\r\n    /// @param _bep2SenderAddr the swap sender address on Binance Chain\r\n    /// @param _bep2RecipientAddr The recipient address on Binance Chain\r\n    /// @param _outAmount ERC20 asset to swap out.\r\n    /// @param _bep2Amount BEP2 asset to swap in.\r\n    function htlt(\r\n        bytes32 _randomNumberHash,\r\n        uint64  _timestamp,\r\n        uint256 _heightSpan,\r\n        address _recipientAddr,\r\n        bytes20 _bep2SenderAddr,\r\n        bytes20 _bep2RecipientAddr,\r\n        uint256 _outAmount,\r\n        uint256 _bep2Amount\r\n    ) external returns (bool) {\r\n        bytes32 swapID = calSwapID(_randomNumberHash, msg.sender, _bep2SenderAddr);\r\n        require(swapStates[swapID] == States.INVALID, \"swap is opened previously\");\r\n        // Assume average block time interval is 10 second\r\n        // The heightSpan period should be more than 10 minutes and less than one week\r\n        require(_heightSpan >= 60 && _heightSpan <= 60480, \"_heightSpan should be in [60, 60480]\");\r\n        require(_recipientAddr != address(0), \"_recipientAddr should not be zero\");\r\n        require(_outAmount > 0, \"_outAmount must be more than 0\");\r\n        require(_timestamp > now - 1800 && _timestamp < now + 900, \"Timestamp can neither be 15 minutes ahead of the current time, nor 30 minutes later\");\r\n        // Store the details of the swap.\r\n        Swap memory swap = Swap({\r\n            outAmount: _outAmount,\r\n            expireHeight: _heightSpan + block.number,\r\n            randomNumberHash: _randomNumberHash,\r\n            timestamp: _timestamp,\r\n            sender: msg.sender,\r\n            recipientAddr: _recipientAddr\r\n        });\r\n\r\n        swaps[swapID] = swap;\r\n        swapStates[swapID] = States.OPEN;\r\n\r\n        // Transfer ERC20 token to the swap contract\r\n        require(ERC20(ERC20ContractAddr).transferFrom(msg.sender, address(this), _outAmount), \"failed to transfer client asset to swap contract address\");\r\n\r\n        // Emit initialization event\r\n        emit HTLT(\r\n            msg.sender,\r\n            _recipientAddr,\r\n            swapID,\r\n            _randomNumberHash,\r\n            _timestamp,\r\n            _bep2RecipientAddr,\r\n            swap.expireHeight,\r\n            _outAmount,\r\n            _bep2Amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice claim claims the previously locked asset.\r\n    ///\r\n    /// @param _swapID The hash of randomNumberHash, swap creator and swap recipient\r\n    /// @param _randomNumber The random number\r\n    function claim(bytes32 _swapID, bytes32 _randomNumber) external onlyOpenSwaps(_swapID) onlyBeforeExpireHeight(_swapID) onlyWithRandomNumber(_swapID, _randomNumber) returns (bool) {\r\n        // Complete the swap.\r\n        swapStates[_swapID] = States.COMPLETED;\r\n\r\n        address recipientAddr = swaps[_swapID].recipientAddr;\r\n        uint256 outAmount = swaps[_swapID].outAmount;\r\n        bytes32 randomNumberHash = swaps[_swapID].randomNumberHash;\r\n        // delete closed swap\r\n        delete swaps[_swapID];\r\n\r\n        // Pay erc20 token to recipient\r\n        require(ERC20(ERC20ContractAddr).transfer(recipientAddr, outAmount), \"Failed to transfer locked asset to recipient\");\r\n\r\n        // Emit completion event\r\n        emit Claimed(msg.sender, recipientAddr, _swapID, randomNumberHash, _randomNumber);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice refund refunds the previously locked asset.\r\n    ///\r\n    /// @param _swapID The hash of randomNumberHash, swap creator and swap recipient\r\n    function refund(bytes32 _swapID) external onlyOpenSwaps(_swapID) onlyAfterExpireHeight(_swapID) returns (bool) {\r\n        // Expire the swap.\r\n        swapStates[_swapID] = States.EXPIRED;\r\n\r\n        address swapSender = swaps[_swapID].sender;\r\n        uint256 outAmount = swaps[_swapID].outAmount;\r\n        bytes32 randomNumberHash = swaps[_swapID].randomNumberHash;\r\n        // delete closed swap\r\n        delete swaps[_swapID];\r\n\r\n        // refund erc20 token to swap creator\r\n        require(ERC20(ERC20ContractAddr).transfer(swapSender, outAmount), \"Failed to transfer locked asset back to swap creator\");\r\n\r\n        // Emit expire event\r\n        emit Refunded(msg.sender, swapSender, _swapID, randomNumberHash);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice query an atomic swap by randomNumberHash\r\n    ///\r\n    /// @param _swapID The hash of randomNumberHash, swap creator and swap recipient\r\n    function queryOpenSwap(bytes32 _swapID) external view returns(bytes32 _randomNumberHash, uint64 _timestamp, uint256 _expireHeight, uint256 _outAmount, address _sender, address _recipient) {\r\n        Swap memory swap = swaps[_swapID];\r\n        return (\r\n            swap.randomNumberHash,\r\n            swap.timestamp,\r\n            swap.expireHeight,\r\n            swap.outAmount,\r\n            swap.sender,\r\n            swap.recipientAddr\r\n        );\r\n    }\r\n\r\n    /// @notice Checks whether a swap with specified swapID exist\r\n    ///\r\n    /// @param _swapID The hash of randomNumberHash, swap creator and swap recipient\r\n    function isSwapExist(bytes32 _swapID) external view returns (bool) {\r\n        return (swapStates[_swapID] != States.INVALID);\r\n    }\r\n\r\n    /// @notice Checks whether a swap is refundable or not.\r\n    ///\r\n    /// @param _swapID The hash of randomNumberHash, swap creator and swap recipient\r\n    function refundable(bytes32 _swapID) external view returns (bool) {\r\n        return (block.number >= swaps[_swapID].expireHeight && swapStates[_swapID] == States.OPEN);\r\n    }\r\n\r\n    /// @notice Checks whether a swap is claimable or not.\r\n    ///\r\n    /// @param _swapID The hash of randomNumberHash, swap creator and swap recipient\r\n    function claimable(bytes32 _swapID) external view returns (bool) {\r\n        return (block.number < swaps[_swapID].expireHeight && swapStates[_swapID] == States.OPEN);\r\n    }\r\n\r\n    /// @notice Calculate the swapID from randomNumberHash and swapCreator\r\n    ///\r\n    /// @param _randomNumberHash The hash of random number and timestamp.\r\n    /// @param _swapSender The creator of swap.\r\n    /// @param _bep2SenderAddr The sender of swap on Binance Chain.\r\n    function calSwapID(bytes32 _randomNumberHash, address _swapSender, bytes20 _bep2SenderAddr) public pure returns (bytes32) {\r\n        if (_bep2SenderAddr == bytes20(0)) {\r\n            return sha256(abi.encodePacked(_randomNumberHash, _swapSender));\r\n        }\r\n        return sha256(abi.encodePacked(_randomNumberHash, _swapSender, _bep2SenderAddr));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ERC20ContractAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"isSwapExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_randomNumberHash\",\"type\":\"bytes32\"},{\"name\":\"_swapSender\",\"type\":\"address\"},{\"name\":\"_bep2SenderAddr\",\"type\":\"bytes20\"}],\"name\":\"calSwapID\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"name\":\"_randomNumber\",\"type\":\"bytes32\"}],\"name\":\"claim\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_randomNumberHash\",\"type\":\"bytes32\"},{\"name\":\"_timestamp\",\"type\":\"uint64\"},{\"name\":\"_heightSpan\",\"type\":\"uint256\"},{\"name\":\"_recipientAddr\",\"type\":\"address\"},{\"name\":\"_bep2SenderAddr\",\"type\":\"bytes20\"},{\"name\":\"_bep2RecipientAddr\",\"type\":\"bytes20\"},{\"name\":\"_outAmount\",\"type\":\"uint256\"},{\"name\":\"_bep2Amount\",\"type\":\"uint256\"}],\"name\":\"htlt\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"claimable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"refundable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"queryOpenSwap\",\"outputs\":[{\"name\":\"_randomNumberHash\",\"type\":\"bytes32\"},{\"name\":\"_timestamp\",\"type\":\"uint64\"},{\"name\":\"_expireHeight\",\"type\":\"uint256\"},{\"name\":\"_outAmount\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_msgSender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_recipientAddr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_randomNumberHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"_bep2Addr\",\"type\":\"bytes20\"},{\"indexed\":false,\"name\":\"_expireHeight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_outAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_bep2Amount\",\"type\":\"uint256\"}],\"name\":\"HTLT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_msgSender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_recipientAddr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_randomNumberHash\",\"type\":\"bytes32\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_msgSender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_recipientAddr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_randomNumberHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_randomNumber\",\"type\":\"bytes32\"}],\"name\":\"Claimed\",\"type\":\"event\"}]","ContractName":"ERC20AtomicSwapper","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv2","SwarmSource":"bzzr://c631c88f5efd5e76a670050b3a705f08e7e9bad4768a2f0ba2c6cbe73045a2fb"}]}