{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.25 <0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract Modifiable {\r\n    \r\n    \r\n    \r\n    modifier notNullAddress(address _address) {\r\n        require(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier notThisAddress(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    modifier notNullOrThisAddress(address _address) {\r\n        require(_address != address(0));\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    modifier notSameAddresses(address _address1, address _address2) {\r\n        if (_address1 != _address2)\r\n            _;\r\n    }\r\n}\r\n\r\ncontract SelfDestructible {\r\n    \r\n    \r\n    \r\n    bool public selfDestructionDisabled;\r\n\r\n    \r\n    \r\n    \r\n    event SelfDestructionDisabledEvent(address wallet);\r\n    event TriggerSelfDestructionEvent(address wallet);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function destructor()\r\n    public\r\n    view\r\n    returns (address);\r\n\r\n    \r\n    \r\n    function disableSelfDestruction()\r\n    public\r\n    {\r\n        \r\n        require(destructor() == msg.sender);\r\n\r\n        \r\n        selfDestructionDisabled = true;\r\n\r\n        \r\n        emit SelfDestructionDisabledEvent(msg.sender);\r\n    }\r\n\r\n    \r\n    function triggerSelfDestruction()\r\n    public\r\n    {\r\n        \r\n        require(destructor() == msg.sender);\r\n\r\n        \r\n        require(!selfDestructionDisabled);\r\n\r\n        \r\n        emit TriggerSelfDestructionEvent(msg.sender);\r\n\r\n        \r\n        selfdestruct(msg.sender);\r\n    }\r\n}\r\n\r\ncontract Ownable is Modifiable, SelfDestructible {\r\n    \r\n    \r\n    \r\n    address public deployer;\r\n    address public operator;\r\n\r\n    \r\n    \r\n    \r\n    event SetDeployerEvent(address oldDeployer, address newDeployer);\r\n    event SetOperatorEvent(address oldOperator, address newOperator);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address _deployer) internal notNullOrThisAddress(_deployer) {\r\n        deployer = _deployer;\r\n        operator = _deployer;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function destructor()\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        return deployer;\r\n    }\r\n\r\n    \r\n    \r\n    function setDeployer(address newDeployer)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(newDeployer)\r\n    {\r\n        if (newDeployer != deployer) {\r\n            \r\n            address oldDeployer = deployer;\r\n            deployer = newDeployer;\r\n\r\n            \r\n            emit SetDeployerEvent(oldDeployer, newDeployer);\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    function setOperator(address newOperator)\r\n    public\r\n    onlyOperator\r\n    notNullOrThisAddress(newOperator)\r\n    {\r\n        if (newOperator != operator) {\r\n            \r\n            address oldOperator = operator;\r\n            operator = newOperator;\r\n\r\n            \r\n            emit SetOperatorEvent(oldOperator, newOperator);\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    function isDeployer()\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return msg.sender == deployer;\r\n    }\r\n\r\n    \r\n    \r\n    function isOperator()\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return msg.sender == operator;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isDeployerOrOperator()\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return isDeployer() || isOperator();\r\n    }\r\n\r\n    \r\n    \r\n    modifier onlyDeployer() {\r\n        require(isDeployer());\r\n        _;\r\n    }\r\n\r\n    modifier notDeployer() {\r\n        require(!isDeployer());\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(isOperator());\r\n        _;\r\n    }\r\n\r\n    modifier notOperator() {\r\n        require(!isOperator());\r\n        _;\r\n    }\r\n\r\n    modifier onlyDeployerOrOperator() {\r\n        require(isDeployerOrOperator());\r\n        _;\r\n    }\r\n\r\n    modifier notDeployerOrOperator() {\r\n        require(!isDeployerOrOperator());\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Servable is Ownable {\r\n    \r\n    \r\n    \r\n    struct ServiceInfo {\r\n        bool registered;\r\n        uint256 activationTimestamp;\r\n        mapping(bytes32 => bool) actionsEnabledMap;\r\n        bytes32[] actionsList;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    mapping(address => ServiceInfo) internal registeredServicesMap;\r\n    uint256 public serviceActivationTimeout;\r\n\r\n    \r\n    \r\n    \r\n    event ServiceActivationTimeoutEvent(uint256 timeoutInSeconds);\r\n    event RegisterServiceEvent(address service);\r\n    event RegisterServiceDeferredEvent(address service, uint256 timeout);\r\n    event DeregisterServiceEvent(address service);\r\n    event EnableServiceActionEvent(address service, string action);\r\n    event DisableServiceActionEvent(address service, string action);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setServiceActivationTimeout(uint256 timeoutInSeconds)\r\n    public\r\n    onlyDeployer\r\n    {\r\n        serviceActivationTimeout = timeoutInSeconds;\r\n\r\n        \r\n        emit ServiceActivationTimeoutEvent(timeoutInSeconds);\r\n    }\r\n\r\n    \r\n    \r\n    function registerService(address service)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        _registerService(service, 0);\r\n\r\n        \r\n        emit RegisterServiceEvent(service);\r\n    }\r\n\r\n    \r\n    \r\n    function registerServiceDeferred(address service)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        _registerService(service, serviceActivationTimeout);\r\n\r\n        \r\n        emit RegisterServiceDeferredEvent(service, serviceActivationTimeout);\r\n    }\r\n\r\n    \r\n    \r\n    function deregisterService(address service)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        require(registeredServicesMap[service].registered);\r\n\r\n        registeredServicesMap[service].registered = false;\r\n\r\n        \r\n        emit DeregisterServiceEvent(service);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function enableServiceAction(address service, string memory action)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        require(registeredServicesMap[service].registered);\r\n\r\n        bytes32 actionHash = hashString(action);\r\n\r\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\r\n\r\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\r\n        registeredServicesMap[service].actionsList.push(actionHash);\r\n\r\n        \r\n        emit EnableServiceActionEvent(service, action);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function disableServiceAction(address service, string memory action)\r\n    public\r\n    onlyDeployer\r\n    notNullOrThisAddress(service)\r\n    {\r\n        bytes32 actionHash = hashString(action);\r\n\r\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\r\n\r\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\r\n\r\n        \r\n        emit DisableServiceActionEvent(service, action);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isRegisteredService(address service)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return registeredServicesMap[service].registered;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isRegisteredActiveService(address service)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return isRegisteredService(service) && block.timestamp >= registeredServicesMap[service].activationTimestamp;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function isEnabledServiceAction(address service, string memory action)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        bytes32 actionHash = hashString(action);\r\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function hashString(string memory _string)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_string));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function _registerService(address service, uint256 timeout)\r\n    private\r\n    {\r\n        if (!registeredServicesMap[service].registered) {\r\n            registeredServicesMap[service].registered = true;\r\n            registeredServicesMap[service].activationTimestamp = block.timestamp + timeout;\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier onlyActiveService() {\r\n        require(isRegisteredActiveService(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier onlyEnabledServiceAction(string memory action) {\r\n        require(isEnabledServiceAction(msg.sender, action));\r\n        _;\r\n    }\r\n}\r\n\r\nlibrary SafeMathIntLib {\r\n    int256 constant INT256_MIN = int256((uint256(1) << 255));\r\n    int256 constant INT256_MAX = int256(~((uint256(1) << 255)));\r\n\r\n    \r\n    \r\n    \r\n    function div(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a != INT256_MIN || b != - 1);\r\n        return a / b;\r\n    }\r\n\r\n    function mul(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a != - 1 || b != INT256_MIN);\r\n        \r\n        require(b != - 1 || a != INT256_MIN);\r\n        \r\n        int256 c = a * b;\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    function sub(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\r\n        return a - b;\r\n    }\r\n\r\n    function add(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function div_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b > 0);\r\n        return a / b;\r\n    }\r\n\r\n    function mul_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b >= 0);\r\n        int256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        require(c >= 0);\r\n        return c;\r\n    }\r\n\r\n    function sub_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b >= 0 && b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add_nn(int256 a, int256 b)\r\n    internal\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && b >= 0);\r\n        int256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function abs(int256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return a < 0 ? neg(a) : a;\r\n    }\r\n\r\n    function neg(int256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return mul(a, - 1);\r\n    }\r\n\r\n    function toNonZeroInt256(uint256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a > 0 && a < (uint256(1) << 255));\r\n        return int256(a);\r\n    }\r\n\r\n    function toInt256(uint256 a)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        require(a >= 0 && a < (uint256(1) << 255));\r\n        return int256(a);\r\n    }\r\n\r\n    function toUInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        require(a >= 0);\r\n        return uint256(a);\r\n    }\r\n\r\n    function isNonZeroPositiveInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a > 0);\r\n    }\r\n\r\n    function isPositiveInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a >= 0);\r\n    }\r\n\r\n    function isNonZeroNegativeInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a < 0);\r\n    }\r\n\r\n    function isNegativeInt256(int256 a)\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        return (a <= 0);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function clamp(int256 a, int256 min, int256 max)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        if (a < min)\r\n            return min;\r\n        return (a > max) ? max : a;\r\n    }\r\n\r\n    function clampMin(int256 a, int256 min)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return (a < min) ? min : a;\r\n    }\r\n\r\n    function clampMax(int256 a, int256 max)\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return (a > max) ? max : a;\r\n    }\r\n}\r\n\r\nlibrary BlockNumbUintsLib {\r\n    \r\n    \r\n    \r\n    struct Entry {\r\n        uint256 blockNumber;\r\n        uint256 value;\r\n    }\r\n\r\n    struct BlockNumbUints {\r\n        Entry[] entries;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function currentValue(BlockNumbUints storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return valueAt(self, block.number);\r\n    }\r\n\r\n    function currentEntry(BlockNumbUints storage self)\r\n    internal\r\n    view\r\n    returns (Entry memory)\r\n    {\r\n        return entryAt(self, block.number);\r\n    }\r\n\r\n    function valueAt(BlockNumbUints storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return entryAt(self, _blockNumber).value;\r\n    }\r\n\r\n    function entryAt(BlockNumbUints storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (Entry memory)\r\n    {\r\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\r\n    }\r\n\r\n    function addEntry(BlockNumbUints storage self, uint256 blockNumber, uint256 value)\r\n    internal\r\n    {\r\n        require(\r\n            0 == self.entries.length ||\r\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\r\n            \"Later entry found [BlockNumbUintsLib.sol:62]\"\r\n        );\r\n\r\n        self.entries.push(Entry(blockNumber, value));\r\n    }\r\n\r\n    function count(BlockNumbUints storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.entries.length;\r\n    }\r\n\r\n    function entries(BlockNumbUints storage self)\r\n    internal\r\n    view\r\n    returns (Entry[] memory)\r\n    {\r\n        return self.entries;\r\n    }\r\n\r\n    function indexByBlockNumber(BlockNumbUints storage self, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(0 < self.entries.length, \"No entries found [BlockNumbUintsLib.sol:92]\");\r\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\r\n            if (blockNumber >= self.entries[i].blockNumber)\r\n                return i;\r\n        revert();\r\n    }\r\n}\r\n\r\nlibrary BlockNumbIntsLib {\r\n    \r\n    \r\n    \r\n    struct Entry {\r\n        uint256 blockNumber;\r\n        int256 value;\r\n    }\r\n\r\n    struct BlockNumbInts {\r\n        Entry[] entries;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function currentValue(BlockNumbInts storage self)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return valueAt(self, block.number);\r\n    }\r\n\r\n    function currentEntry(BlockNumbInts storage self)\r\n    internal\r\n    view\r\n    returns (Entry memory)\r\n    {\r\n        return entryAt(self, block.number);\r\n    }\r\n\r\n    function valueAt(BlockNumbInts storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return entryAt(self, _blockNumber).value;\r\n    }\r\n\r\n    function entryAt(BlockNumbInts storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (Entry memory)\r\n    {\r\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\r\n    }\r\n\r\n    function addEntry(BlockNumbInts storage self, uint256 blockNumber, int256 value)\r\n    internal\r\n    {\r\n        require(\r\n            0 == self.entries.length ||\r\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\r\n            \"Later entry found [BlockNumbIntsLib.sol:62]\"\r\n        );\r\n\r\n        self.entries.push(Entry(blockNumber, value));\r\n    }\r\n\r\n    function count(BlockNumbInts storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.entries.length;\r\n    }\r\n\r\n    function entries(BlockNumbInts storage self)\r\n    internal\r\n    view\r\n    returns (Entry[] memory)\r\n    {\r\n        return self.entries;\r\n    }\r\n\r\n    function indexByBlockNumber(BlockNumbInts storage self, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(0 < self.entries.length, \"No entries found [BlockNumbIntsLib.sol:92]\");\r\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\r\n            if (blockNumber >= self.entries[i].blockNumber)\r\n                return i;\r\n        revert();\r\n    }\r\n}\r\n\r\nlibrary ConstantsLib {\r\n    \r\n    function PARTS_PER()\r\n    public\r\n    pure\r\n    returns (int256)\r\n    {\r\n        return 1e18;\r\n    }\r\n}\r\n\r\nlibrary BlockNumbDisdIntsLib {\r\n    using SafeMathIntLib for int256;\r\n\r\n    \r\n    \r\n    \r\n    struct Discount {\r\n        int256 tier;\r\n        int256 value;\r\n    }\r\n\r\n    struct Entry {\r\n        uint256 blockNumber;\r\n        int256 nominal;\r\n        Discount[] discounts;\r\n    }\r\n\r\n    struct BlockNumbDisdInts {\r\n        Entry[] entries;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function currentNominalValue(BlockNumbDisdInts storage self)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return nominalValueAt(self, block.number);\r\n    }\r\n\r\n    function currentDiscountedValue(BlockNumbDisdInts storage self, int256 tier)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return discountedValueAt(self, block.number, tier);\r\n    }\r\n\r\n    function currentEntry(BlockNumbDisdInts storage self)\r\n    internal\r\n    view\r\n    returns (Entry memory)\r\n    {\r\n        return entryAt(self, block.number);\r\n    }\r\n\r\n    function nominalValueAt(BlockNumbDisdInts storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return entryAt(self, _blockNumber).nominal;\r\n    }\r\n\r\n    function discountedValueAt(BlockNumbDisdInts storage self, uint256 _blockNumber, int256 tier)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        Entry memory entry = entryAt(self, _blockNumber);\r\n        if (0 < entry.discounts.length) {\r\n            uint256 index = indexByTier(entry.discounts, tier);\r\n            if (0 < index)\r\n                return entry.nominal.mul(\r\n                    ConstantsLib.PARTS_PER().sub(entry.discounts[index - 1].value)\r\n                ).div(\r\n                    ConstantsLib.PARTS_PER()\r\n                );\r\n            else\r\n                return entry.nominal;\r\n        } else\r\n            return entry.nominal;\r\n    }\r\n\r\n    function entryAt(BlockNumbDisdInts storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (Entry memory)\r\n    {\r\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\r\n    }\r\n\r\n    function addNominalEntry(BlockNumbDisdInts storage self, uint256 blockNumber, int256 nominal)\r\n    internal\r\n    {\r\n        require(\r\n            0 == self.entries.length ||\r\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\r\n            \"Later entry found [BlockNumbDisdIntsLib.sol:101]\"\r\n        );\r\n\r\n        self.entries.length++;\r\n        Entry storage entry = self.entries[self.entries.length - 1];\r\n\r\n        entry.blockNumber = blockNumber;\r\n        entry.nominal = nominal;\r\n    }\r\n\r\n    function addDiscountedEntry(BlockNumbDisdInts storage self, uint256 blockNumber, int256 nominal,\r\n        int256[] memory discountTiers, int256[] memory discountValues)\r\n    internal\r\n    {\r\n        require(discountTiers.length == discountValues.length, \"Parameter array lengths mismatch [BlockNumbDisdIntsLib.sol:118]\");\r\n\r\n        addNominalEntry(self, blockNumber, nominal);\r\n\r\n        Entry storage entry = self.entries[self.entries.length - 1];\r\n        for (uint256 i = 0; i < discountTiers.length; i++)\r\n            entry.discounts.push(Discount(discountTiers[i], discountValues[i]));\r\n    }\r\n\r\n    function count(BlockNumbDisdInts storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.entries.length;\r\n    }\r\n\r\n    function entries(BlockNumbDisdInts storage self)\r\n    internal\r\n    view\r\n    returns (Entry[] memory)\r\n    {\r\n        return self.entries;\r\n    }\r\n\r\n    function indexByBlockNumber(BlockNumbDisdInts storage self, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(0 < self.entries.length, \"No entries found [BlockNumbDisdIntsLib.sol:148]\");\r\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\r\n            if (blockNumber >= self.entries[i].blockNumber)\r\n                return i;\r\n        revert();\r\n    }\r\n\r\n    \r\n    function indexByTier(Discount[] memory discounts, int256 tier)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        require(0 < discounts.length, \"No discounts found [BlockNumbDisdIntsLib.sol:161]\");\r\n        for (uint256 i = discounts.length; i > 0; i--)\r\n            if (tier >= discounts[i - 1].tier)\r\n                return i;\r\n        return 0;\r\n    }\r\n}\r\n\r\nlibrary MonetaryTypesLib {\r\n    \r\n    \r\n    \r\n    struct Currency {\r\n        address ct;\r\n        uint256 id;\r\n    }\r\n\r\n    struct Figure {\r\n        int256 amount;\r\n        Currency currency;\r\n    }\r\n\r\n    struct NoncedAmount {\r\n        uint256 nonce;\r\n        int256 amount;\r\n    }\r\n}\r\n\r\nlibrary BlockNumbReferenceCurrenciesLib {\r\n    \r\n    \r\n    \r\n    struct Entry {\r\n        uint256 blockNumber;\r\n        MonetaryTypesLib.Currency currency;\r\n    }\r\n\r\n    struct BlockNumbReferenceCurrencies {\r\n        mapping(address => mapping(uint256 => Entry[])) entriesByCurrency;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function currentCurrency(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Currency storage)\r\n    {\r\n        return currencyAt(self, referenceCurrency, block.number);\r\n    }\r\n\r\n    function currentEntry(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\r\n    internal\r\n    view\r\n    returns (Entry storage)\r\n    {\r\n        return entryAt(self, referenceCurrency, block.number);\r\n    }\r\n\r\n    function currencyAt(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency,\r\n        uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Currency storage)\r\n    {\r\n        return entryAt(self, referenceCurrency, _blockNumber).currency;\r\n    }\r\n\r\n    function entryAt(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency,\r\n        uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (Entry storage)\r\n    {\r\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][indexByBlockNumber(self, referenceCurrency, _blockNumber)];\r\n    }\r\n\r\n    function addEntry(BlockNumbReferenceCurrencies storage self, uint256 blockNumber,\r\n        MonetaryTypesLib.Currency memory referenceCurrency, MonetaryTypesLib.Currency memory currency)\r\n    internal\r\n    {\r\n        require(\r\n            0 == self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length ||\r\n        blockNumber > self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length - 1].blockNumber,\r\n            \"Later entry found for currency [BlockNumbReferenceCurrenciesLib.sol:67]\"\r\n        );\r\n\r\n        self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].push(Entry(blockNumber, currency));\r\n    }\r\n\r\n    function count(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length;\r\n    }\r\n\r\n    function entriesByCurrency(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency)\r\n    internal\r\n    view\r\n    returns (Entry[] storage)\r\n    {\r\n        return self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id];\r\n    }\r\n\r\n    function indexByBlockNumber(BlockNumbReferenceCurrencies storage self, MonetaryTypesLib.Currency memory referenceCurrency, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(0 < self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length, \"No entries found for currency [BlockNumbReferenceCurrenciesLib.sol:97]\");\r\n        for (uint256 i = self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id].length - 1; i >= 0; i--)\r\n            if (blockNumber >= self.entriesByCurrency[referenceCurrency.ct][referenceCurrency.id][i].blockNumber)\r\n                return i;\r\n        revert();\r\n    }\r\n}\r\n\r\nlibrary BlockNumbFiguresLib {\r\n    \r\n    \r\n    \r\n    struct Entry {\r\n        uint256 blockNumber;\r\n        MonetaryTypesLib.Figure value;\r\n    }\r\n\r\n    struct BlockNumbFigures {\r\n        Entry[] entries;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function currentValue(BlockNumbFigures storage self)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Figure storage)\r\n    {\r\n        return valueAt(self, block.number);\r\n    }\r\n\r\n    function currentEntry(BlockNumbFigures storage self)\r\n    internal\r\n    view\r\n    returns (Entry storage)\r\n    {\r\n        return entryAt(self, block.number);\r\n    }\r\n\r\n    function valueAt(BlockNumbFigures storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Figure storage)\r\n    {\r\n        return entryAt(self, _blockNumber).value;\r\n    }\r\n\r\n    function entryAt(BlockNumbFigures storage self, uint256 _blockNumber)\r\n    internal\r\n    view\r\n    returns (Entry storage)\r\n    {\r\n        return self.entries[indexByBlockNumber(self, _blockNumber)];\r\n    }\r\n\r\n    function addEntry(BlockNumbFigures storage self, uint256 blockNumber, MonetaryTypesLib.Figure memory value)\r\n    internal\r\n    {\r\n        require(\r\n            0 == self.entries.length ||\r\n        blockNumber > self.entries[self.entries.length - 1].blockNumber,\r\n            \"Later entry found [BlockNumbFiguresLib.sol:65]\"\r\n        );\r\n\r\n        self.entries.push(Entry(blockNumber, value));\r\n    }\r\n\r\n    function count(BlockNumbFigures storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.entries.length;\r\n    }\r\n\r\n    function entries(BlockNumbFigures storage self)\r\n    internal\r\n    view\r\n    returns (Entry[] storage)\r\n    {\r\n        return self.entries;\r\n    }\r\n\r\n    function indexByBlockNumber(BlockNumbFigures storage self, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        require(0 < self.entries.length, \"No entries found [BlockNumbFiguresLib.sol:95]\");\r\n        for (uint256 i = self.entries.length - 1; i >= 0; i--)\r\n            if (blockNumber >= self.entries[i].blockNumber)\r\n                return i;\r\n        revert();\r\n    }\r\n}\r\n\r\ncontract Configuration is Modifiable, Ownable, Servable {\r\n    using SafeMathIntLib for int256;\r\n    using BlockNumbUintsLib for BlockNumbUintsLib.BlockNumbUints;\r\n    using BlockNumbIntsLib for BlockNumbIntsLib.BlockNumbInts;\r\n    using BlockNumbDisdIntsLib for BlockNumbDisdIntsLib.BlockNumbDisdInts;\r\n    using BlockNumbReferenceCurrenciesLib for BlockNumbReferenceCurrenciesLib.BlockNumbReferenceCurrencies;\r\n    using BlockNumbFiguresLib for BlockNumbFiguresLib.BlockNumbFigures;\r\n\r\n    \r\n    \r\n    \r\n    string constant public OPERATIONAL_MODE_ACTION = \"operational_mode\";\r\n\r\n    \r\n    \r\n    \r\n    enum OperationalMode {Normal, Exit}\r\n\r\n    \r\n    \r\n    \r\n    OperationalMode public operationalMode = OperationalMode.Normal;\r\n\r\n    BlockNumbUintsLib.BlockNumbUints private updateDelayBlocksByBlockNumber;\r\n    BlockNumbUintsLib.BlockNumbUints private confirmationBlocksByBlockNumber;\r\n\r\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private tradeMakerFeeByBlockNumber;\r\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private tradeTakerFeeByBlockNumber;\r\n    BlockNumbDisdIntsLib.BlockNumbDisdInts private paymentFeeByBlockNumber;\r\n    mapping(address => mapping(uint256 => BlockNumbDisdIntsLib.BlockNumbDisdInts)) private currencyPaymentFeeByBlockNumber;\r\n\r\n    BlockNumbIntsLib.BlockNumbInts private tradeMakerMinimumFeeByBlockNumber;\r\n    BlockNumbIntsLib.BlockNumbInts private tradeTakerMinimumFeeByBlockNumber;\r\n    BlockNumbIntsLib.BlockNumbInts private paymentMinimumFeeByBlockNumber;\r\n    mapping(address => mapping(uint256 => BlockNumbIntsLib.BlockNumbInts)) private currencyPaymentMinimumFeeByBlockNumber;\r\n\r\n    BlockNumbReferenceCurrenciesLib.BlockNumbReferenceCurrencies private feeCurrencyByCurrencyBlockNumber;\r\n\r\n    BlockNumbUintsLib.BlockNumbUints private walletLockTimeoutByBlockNumber;\r\n    BlockNumbUintsLib.BlockNumbUints private cancelOrderChallengeTimeoutByBlockNumber;\r\n    BlockNumbUintsLib.BlockNumbUints private settlementChallengeTimeoutByBlockNumber;\r\n\r\n    BlockNumbUintsLib.BlockNumbUints private fraudStakeFractionByBlockNumber;\r\n    BlockNumbUintsLib.BlockNumbUints private walletSettlementStakeFractionByBlockNumber;\r\n    BlockNumbUintsLib.BlockNumbUints private operatorSettlementStakeFractionByBlockNumber;\r\n\r\n    BlockNumbFiguresLib.BlockNumbFigures private operatorSettlementStakeByBlockNumber;\r\n\r\n    uint256 public earliestSettlementBlockNumber;\r\n    bool public earliestSettlementBlockNumberUpdateDisabled;\r\n\r\n    \r\n    \r\n    \r\n    event SetOperationalModeExitEvent();\r\n    event SetUpdateDelayBlocksEvent(uint256 fromBlockNumber, uint256 newBlocks);\r\n    event SetConfirmationBlocksEvent(uint256 fromBlockNumber, uint256 newBlocks);\r\n    event SetTradeMakerFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\r\n    event SetTradeTakerFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\r\n    event SetPaymentFeeEvent(uint256 fromBlockNumber, int256 nominal, int256[] discountTiers, int256[] discountValues);\r\n    event SetCurrencyPaymentFeeEvent(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\r\n        int256[] discountTiers, int256[] discountValues);\r\n    event SetTradeMakerMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\r\n    event SetTradeTakerMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\r\n    event SetPaymentMinimumFeeEvent(uint256 fromBlockNumber, int256 nominal);\r\n    event SetCurrencyPaymentMinimumFeeEvent(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal);\r\n    event SetFeeCurrencyEvent(uint256 fromBlockNumber, address referenceCurrencyCt, uint256 referenceCurrencyId,\r\n        address feeCurrencyCt, uint256 feeCurrencyId);\r\n    event SetWalletLockTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\r\n    event SetCancelOrderChallengeTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\r\n    event SetSettlementChallengeTimeoutEvent(uint256 fromBlockNumber, uint256 timeoutInSeconds);\r\n    event SetWalletSettlementStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\r\n    event SetOperatorSettlementStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\r\n    event SetOperatorSettlementStakeEvent(uint256 fromBlockNumber, int256 stakeAmount, address stakeCurrencyCt,\r\n        uint256 stakeCurrencyId);\r\n    event SetFraudStakeFractionEvent(uint256 fromBlockNumber, uint256 stakeFraction);\r\n    event SetEarliestSettlementBlockNumberEvent(uint256 earliestSettlementBlockNumber);\r\n    event DisableEarliestSettlementBlockNumberUpdateEvent();\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n        updateDelayBlocksByBlockNumber.addEntry(block.number, 0);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setOperationalModeExit()\r\n    public\r\n    onlyEnabledServiceAction(OPERATIONAL_MODE_ACTION)\r\n    {\r\n        operationalMode = OperationalMode.Exit;\r\n        emit SetOperationalModeExitEvent();\r\n    }\r\n\r\n    \r\n    function isOperationalModeNormal()\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return OperationalMode.Normal == operationalMode;\r\n    }\r\n\r\n    \r\n    function isOperationalModeExit()\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return OperationalMode.Exit == operationalMode;\r\n    }\r\n\r\n    \r\n    \r\n    function updateDelayBlocks()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return updateDelayBlocksByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    function updateDelayBlocksCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return updateDelayBlocksByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setUpdateDelayBlocks(uint256 fromBlockNumber, uint256 newUpdateDelayBlocks)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        updateDelayBlocksByBlockNumber.addEntry(fromBlockNumber, newUpdateDelayBlocks);\r\n        emit SetUpdateDelayBlocksEvent(fromBlockNumber, newUpdateDelayBlocks);\r\n    }\r\n\r\n    \r\n    \r\n    function confirmationBlocks()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return confirmationBlocksByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    function confirmationBlocksCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return confirmationBlocksByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setConfirmationBlocks(uint256 fromBlockNumber, uint256 newConfirmationBlocks)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        confirmationBlocksByBlockNumber.addEntry(fromBlockNumber, newConfirmationBlocks);\r\n        emit SetConfirmationBlocksEvent(fromBlockNumber, newConfirmationBlocks);\r\n    }\r\n\r\n    \r\n    function tradeMakerFeesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return tradeMakerFeeByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function tradeMakerFee(uint256 blockNumber, int256 discountTier)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return tradeMakerFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\r\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\r\n    }\r\n\r\n    \r\n    function tradeTakerFeesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return tradeTakerFeeByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function tradeTakerFee(uint256 blockNumber, int256 discountTier)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return tradeTakerFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\r\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\r\n    }\r\n\r\n    \r\n    function paymentFeesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return paymentFeeByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function paymentFee(uint256 blockNumber, int256 discountTier)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return paymentFeeByBlockNumber.discountedValueAt(blockNumber, discountTier);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\r\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function currencyPaymentFeesCount(address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return currencyPaymentFeeByBlockNumber[currencyCt][currencyId].count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function currencyPaymentFee(uint256 blockNumber, address currencyCt, uint256 currencyId, int256 discountTier)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        if (0 < currencyPaymentFeeByBlockNumber[currencyCt][currencyId].count())\r\n            return currencyPaymentFeeByBlockNumber[currencyCt][currencyId].discountedValueAt(\r\n                blockNumber, discountTier\r\n            );\r\n        else\r\n            return paymentFee(blockNumber, discountTier);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\r\n        int256[] memory discountTiers, int256[] memory discountValues)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\r\n            fromBlockNumber, nominal, discountTiers, discountValues\r\n        );\r\n        emit SetCurrencyPaymentFeeEvent(\r\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\r\n        );\r\n    }\r\n\r\n    \r\n    function tradeMakerMinimumFeesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return tradeMakerMinimumFeeByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    function tradeMakerMinimumFee(uint256 blockNumber)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return tradeMakerMinimumFeeByBlockNumber.valueAt(blockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setTradeMakerMinimumFee(uint256 fromBlockNumber, int256 nominal)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        tradeMakerMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\r\n        emit SetTradeMakerMinimumFeeEvent(fromBlockNumber, nominal);\r\n    }\r\n\r\n    \r\n    function tradeTakerMinimumFeesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return tradeTakerMinimumFeeByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    function tradeTakerMinimumFee(uint256 blockNumber)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return tradeTakerMinimumFeeByBlockNumber.valueAt(blockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setTradeTakerMinimumFee(uint256 fromBlockNumber, int256 nominal)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        tradeTakerMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\r\n        emit SetTradeTakerMinimumFeeEvent(fromBlockNumber, nominal);\r\n    }\r\n\r\n    \r\n    function paymentMinimumFeesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return paymentMinimumFeeByBlockNumber.count();\r\n    }\r\n\r\n    \r\n    \r\n    function paymentMinimumFee(uint256 blockNumber)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return paymentMinimumFeeByBlockNumber.valueAt(blockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setPaymentMinimumFee(uint256 fromBlockNumber, int256 nominal)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        paymentMinimumFeeByBlockNumber.addEntry(fromBlockNumber, nominal);\r\n        emit SetPaymentMinimumFeeEvent(fromBlockNumber, nominal);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function currencyPaymentMinimumFeesCount(address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].count();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function currencyPaymentMinimumFee(uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        if (0 < currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].count())\r\n            return currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].valueAt(blockNumber);\r\n        else\r\n            return paymentMinimumFee(blockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setCurrencyPaymentMinimumFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        currencyPaymentMinimumFeeByBlockNumber[currencyCt][currencyId].addEntry(fromBlockNumber, nominal);\r\n        emit SetCurrencyPaymentMinimumFeeEvent(fromBlockNumber, currencyCt, currencyId, nominal);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function feeCurrenciesCount(address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return feeCurrencyByCurrencyBlockNumber.count(MonetaryTypesLib.Currency(currencyCt, currencyId));\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function feeCurrency(uint256 blockNumber, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (address ct, uint256 id)\r\n    {\r\n        MonetaryTypesLib.Currency storage _feeCurrency = feeCurrencyByCurrencyBlockNumber.currencyAt(\r\n            MonetaryTypesLib.Currency(currencyCt, currencyId), blockNumber\r\n        );\r\n        ct = _feeCurrency.ct;\r\n        id = _feeCurrency.id;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setFeeCurrency(uint256 fromBlockNumber, address referenceCurrencyCt, uint256 referenceCurrencyId,\r\n        address feeCurrencyCt, uint256 feeCurrencyId)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        feeCurrencyByCurrencyBlockNumber.addEntry(\r\n            fromBlockNumber,\r\n            MonetaryTypesLib.Currency(referenceCurrencyCt, referenceCurrencyId),\r\n            MonetaryTypesLib.Currency(feeCurrencyCt, feeCurrencyId)\r\n        );\r\n        emit SetFeeCurrencyEvent(fromBlockNumber, referenceCurrencyCt, referenceCurrencyId,\r\n            feeCurrencyCt, feeCurrencyId);\r\n    }\r\n\r\n    \r\n    \r\n    function walletLockTimeout()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletLockTimeoutByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setWalletLockTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        walletLockTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\r\n        emit SetWalletLockTimeoutEvent(fromBlockNumber, timeoutInSeconds);\r\n    }\r\n\r\n    \r\n    \r\n    function cancelOrderChallengeTimeout()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return cancelOrderChallengeTimeoutByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setCancelOrderChallengeTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        cancelOrderChallengeTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\r\n        emit SetCancelOrderChallengeTimeoutEvent(fromBlockNumber, timeoutInSeconds);\r\n    }\r\n\r\n    \r\n    \r\n    function settlementChallengeTimeout()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return settlementChallengeTimeoutByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function setSettlementChallengeTimeout(uint256 fromBlockNumber, uint256 timeoutInSeconds)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        settlementChallengeTimeoutByBlockNumber.addEntry(fromBlockNumber, timeoutInSeconds);\r\n        emit SetSettlementChallengeTimeoutEvent(fromBlockNumber, timeoutInSeconds);\r\n    }\r\n\r\n    \r\n    \r\n    function fraudStakeFraction()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return fraudStakeFractionByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function setFraudStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        fraudStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\r\n        emit SetFraudStakeFractionEvent(fromBlockNumber, stakeFraction);\r\n    }\r\n\r\n    \r\n    \r\n    function walletSettlementStakeFraction()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletSettlementStakeFractionByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function setWalletSettlementStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        walletSettlementStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\r\n        emit SetWalletSettlementStakeFractionEvent(fromBlockNumber, stakeFraction);\r\n    }\r\n\r\n    \r\n    \r\n    function operatorSettlementStakeFraction()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return operatorSettlementStakeFractionByBlockNumber.currentValue();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function setOperatorSettlementStakeFraction(uint256 fromBlockNumber, uint256 stakeFraction)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        operatorSettlementStakeFractionByBlockNumber.addEntry(fromBlockNumber, stakeFraction);\r\n        emit SetOperatorSettlementStakeFractionEvent(fromBlockNumber, stakeFraction);\r\n    }\r\n\r\n    \r\n    \r\n    function operatorSettlementStake()\r\n    public\r\n    view\r\n    returns (int256 amount, address currencyCt, uint256 currencyId)\r\n    {\r\n        MonetaryTypesLib.Figure storage stake = operatorSettlementStakeByBlockNumber.currentValue();\r\n        amount = stake.amount;\r\n        currencyCt = stake.currency.ct;\r\n        currencyId = stake.currency.id;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setOperatorSettlementStake(uint256 fromBlockNumber, int256 stakeAmount,\r\n        address stakeCurrencyCt, uint256 stakeCurrencyId)\r\n    public\r\n    onlyOperator\r\n    onlyDelayedBlockNumber(fromBlockNumber)\r\n    {\r\n        MonetaryTypesLib.Figure memory stake = MonetaryTypesLib.Figure(stakeAmount, MonetaryTypesLib.Currency(stakeCurrencyCt, stakeCurrencyId));\r\n        operatorSettlementStakeByBlockNumber.addEntry(fromBlockNumber, stake);\r\n        emit SetOperatorSettlementStakeEvent(fromBlockNumber, stakeAmount, stakeCurrencyCt, stakeCurrencyId);\r\n    }\r\n\r\n    \r\n    \r\n    function setEarliestSettlementBlockNumber(uint256 _earliestSettlementBlockNumber)\r\n    public\r\n    onlyOperator\r\n    {\r\n        require(!earliestSettlementBlockNumberUpdateDisabled, \"Earliest settlement block number update disabled [Configuration.sol:715]\");\r\n\r\n        earliestSettlementBlockNumber = _earliestSettlementBlockNumber;\r\n        emit SetEarliestSettlementBlockNumberEvent(earliestSettlementBlockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    function disableEarliestSettlementBlockNumberUpdate()\r\n    public\r\n    onlyOperator\r\n    {\r\n        earliestSettlementBlockNumberUpdateDisabled = true;\r\n        emit DisableEarliestSettlementBlockNumberUpdateEvent();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier onlyDelayedBlockNumber(uint256 blockNumber) {\r\n        require(\r\n            0 == updateDelayBlocksByBlockNumber.count() ||\r\n        blockNumber >= block.number + updateDelayBlocksByBlockNumber.currentValue(),\r\n            \"Block number not sufficiently delayed [Configuration.sol:735]\"\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Configurable is Ownable {\r\n    \r\n    \r\n    \r\n    Configuration public configuration;\r\n\r\n    \r\n    \r\n    \r\n    event SetConfigurationEvent(Configuration oldConfiguration, Configuration newConfiguration);\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setConfiguration(Configuration newConfiguration)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(newConfiguration))\r\n    notSameAddresses(address(newConfiguration), address(configuration))\r\n    {\r\n        \r\n        Configuration oldConfiguration = configuration;\r\n        configuration = newConfiguration;\r\n\r\n        \r\n        emit SetConfigurationEvent(oldConfiguration, newConfiguration);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier configurationInitialized() {\r\n        require(address(configuration) != address(0), \"Configuration not initialized [Configurable.sol:52]\");\r\n        _;\r\n    }\r\n}\r\n\r\nlibrary SafeMathUintLib {\r\n    function mul(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        \r\n        uint256 c = a / b;\r\n        \r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function clamp(uint256 a, uint256 min, uint256 max)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return (a > max) ? max : ((a < min) ? min : a);\r\n    }\r\n\r\n    function clampMin(uint256 a, uint256 min)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return (a < min) ? min : a;\r\n    }\r\n\r\n    function clampMax(uint256 a, uint256 max)\r\n    public\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return (a > max) ? max : a;\r\n    }\r\n}\r\n\r\nlibrary CurrenciesLib {\r\n    using SafeMathUintLib for uint256;\r\n\r\n    \r\n    \r\n    \r\n    struct Currencies {\r\n        MonetaryTypesLib.Currency[] currencies;\r\n        mapping(address => mapping(uint256 => uint256)) indexByCurrency;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function add(Currencies storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        \r\n        if (0 == self.indexByCurrency[currencyCt][currencyId]) {\r\n            self.currencies.push(MonetaryTypesLib.Currency(currencyCt, currencyId));\r\n            self.indexByCurrency[currencyCt][currencyId] = self.currencies.length;\r\n        }\r\n    }\r\n\r\n    function removeByCurrency(Currencies storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        \r\n        uint256 index = self.indexByCurrency[currencyCt][currencyId];\r\n        if (0 < index)\r\n            removeByIndex(self, index - 1);\r\n    }\r\n\r\n    function removeByIndex(Currencies storage self, uint256 index)\r\n    internal\r\n    {\r\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:51]\");\r\n\r\n        address currencyCt = self.currencies[index].ct;\r\n        uint256 currencyId = self.currencies[index].id;\r\n\r\n        if (index < self.currencies.length - 1) {\r\n            self.currencies[index] = self.currencies[self.currencies.length - 1];\r\n            self.indexByCurrency[self.currencies[index].ct][self.currencies[index].id] = index + 1;\r\n        }\r\n        self.currencies.length--;\r\n        self.indexByCurrency[currencyCt][currencyId] = 0;\r\n    }\r\n\r\n    function count(Currencies storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.currencies.length;\r\n    }\r\n\r\n    function has(Currencies storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return 0 != self.indexByCurrency[currencyCt][currencyId];\r\n    }\r\n\r\n    function getByIndex(Currencies storage self, uint256 index)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Currency memory)\r\n    {\r\n        require(index < self.currencies.length, \"Index out of bounds [CurrenciesLib.sol:85]\");\r\n        return self.currencies[index];\r\n    }\r\n\r\n    function getByIndices(Currencies storage self, uint256 low, uint256 up)\r\n    internal\r\n    view\r\n    returns (MonetaryTypesLib.Currency[] memory)\r\n    {\r\n        require(0 < self.currencies.length, \"No currencies found [CurrenciesLib.sol:94]\");\r\n        require(low <= up, \"Bounds parameters mismatch [CurrenciesLib.sol:95]\");\r\n\r\n        up = up.clampMax(self.currencies.length - 1);\r\n        MonetaryTypesLib.Currency[] memory _currencies = new MonetaryTypesLib.Currency[](up - low + 1);\r\n        for (uint256 i = low; i <= up; i++)\r\n            _currencies[i - low] = self.currencies[i];\r\n\r\n        return _currencies;\r\n    }\r\n}\r\n\r\nlibrary FungibleBalanceLib {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n    using CurrenciesLib for CurrenciesLib.Currencies;\r\n\r\n    \r\n    \r\n    \r\n    struct Record {\r\n        int256 amount;\r\n        uint256 blockNumber;\r\n    }\r\n\r\n    struct Balance {\r\n        mapping(address => mapping(uint256 => int256)) amountByCurrency;\r\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\r\n\r\n        CurrenciesLib.Currencies inUseCurrencies;\r\n        CurrenciesLib.Currencies everUsedCurrencies;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function get(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        return self.amountByCurrency[currencyCt][currencyId];\r\n    }\r\n\r\n    function getByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (int256)\r\n    {\r\n        (int256 amount,) = recordByBlockNumber(self, currencyCt, currencyId, blockNumber);\r\n        return amount;\r\n    }\r\n\r\n    function set(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = amount;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function setByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\r\n        uint256 blockNumber)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = amount;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function add(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function addByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\r\n        uint256 blockNumber)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function sub(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function subByBlockNumber(Balance storage self, int256 amount, address currencyCt, uint256 currencyId,\r\n        uint256 blockNumber)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], blockNumber)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function transfer(Balance storage _from, Balance storage _to, int256 amount,\r\n        address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        sub(_from, amount, currencyCt, currencyId);\r\n        add(_to, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    function add_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].add_nn(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function sub_nn(Balance storage self, int256 amount, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        self.amountByCurrency[currencyCt][currencyId] = self.amountByCurrency[currencyCt][currencyId].sub_nn(amount);\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.amountByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function transfer_nn(Balance storage _from, Balance storage _to, int256 amount,\r\n        address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        sub_nn(_from, amount, currencyCt, currencyId);\r\n        add_nn(_to, amount, currencyCt, currencyId);\r\n    }\r\n\r\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.recordsByCurrency[currencyCt][currencyId].length;\r\n    }\r\n\r\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (int256, uint256)\r\n    {\r\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\r\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (0, 0);\r\n    }\r\n\r\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\r\n    internal\r\n    view\r\n    returns (int256, uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return (0, 0);\r\n\r\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\r\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\r\n        return (record.amount, record.blockNumber);\r\n    }\r\n\r\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (int256, uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return (0, 0);\r\n\r\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\r\n        return (record.amount, record.blockNumber);\r\n    }\r\n\r\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return self.inUseCurrencies.has(currencyCt, currencyId);\r\n    }\r\n\r\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\r\n    }\r\n\r\n    function updateCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        if (0 == self.amountByCurrency[currencyCt][currencyId] && self.inUseCurrencies.has(currencyCt, currencyId))\r\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\r\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\r\n            self.inUseCurrencies.add(currencyCt, currencyId);\r\n            self.everUsedCurrencies.add(currencyCt, currencyId);\r\n        }\r\n    }\r\n\r\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return 0;\r\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\r\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\r\n                return i;\r\n        return 0;\r\n    }\r\n}\r\n\r\nlibrary NonFungibleBalanceLib {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n    using CurrenciesLib for CurrenciesLib.Currencies;\r\n\r\n    \r\n    \r\n    \r\n    struct Record {\r\n        int256[] ids;\r\n        uint256 blockNumber;\r\n    }\r\n\r\n    struct Balance {\r\n        mapping(address => mapping(uint256 => int256[])) idsByCurrency;\r\n        mapping(address => mapping(uint256 => mapping(int256 => uint256))) idIndexById;\r\n        mapping(address => mapping(uint256 => Record[])) recordsByCurrency;\r\n\r\n        CurrenciesLib.Currencies inUseCurrencies;\r\n        CurrenciesLib.Currencies everUsedCurrencies;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function get(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (int256[] memory)\r\n    {\r\n        return self.idsByCurrency[currencyCt][currencyId];\r\n    }\r\n\r\n    function getByIndices(Balance storage self, address currencyCt, uint256 currencyId, uint256 indexLow, uint256 indexUp)\r\n    internal\r\n    view\r\n    returns (int256[] memory)\r\n    {\r\n        if (0 == self.idsByCurrency[currencyCt][currencyId].length)\r\n            return new int256[](0);\r\n\r\n        indexUp = indexUp.clampMax(self.idsByCurrency[currencyCt][currencyId].length - 1);\r\n\r\n        int256[] memory idsByCurrency = new int256[](indexUp - indexLow + 1);\r\n        for (uint256 i = indexLow; i < indexUp; i++)\r\n            idsByCurrency[i - indexLow] = self.idsByCurrency[currencyCt][currencyId][i];\r\n\r\n        return idsByCurrency;\r\n    }\r\n\r\n    function idsCount(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.idsByCurrency[currencyCt][currencyId].length;\r\n    }\r\n\r\n    function hasId(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return 0 < self.idIndexById[currencyCt][currencyId][id];\r\n    }\r\n\r\n    function recordByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (int256[] memory, uint256)\r\n    {\r\n        uint256 index = indexByBlockNumber(self, currencyCt, currencyId, blockNumber);\r\n        return 0 < index ? recordByIndex(self, currencyCt, currencyId, index - 1) : (new int256[](0), 0);\r\n    }\r\n\r\n    function recordByIndex(Balance storage self, address currencyCt, uint256 currencyId, uint256 index)\r\n    internal\r\n    view\r\n    returns (int256[] memory, uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return (new int256[](0), 0);\r\n\r\n        index = index.clampMax(self.recordsByCurrency[currencyCt][currencyId].length - 1);\r\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][index];\r\n        return (record.ids, record.blockNumber);\r\n    }\r\n\r\n    function lastRecord(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (int256[] memory, uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return (new int256[](0), 0);\r\n\r\n        Record storage record = self.recordsByCurrency[currencyCt][currencyId][self.recordsByCurrency[currencyCt][currencyId].length - 1];\r\n        return (record.ids, record.blockNumber);\r\n    }\r\n\r\n    function recordsCount(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return self.recordsByCurrency[currencyCt][currencyId].length;\r\n    }\r\n\r\n    function set(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        int256[] memory ids = new int256[](1);\r\n        ids[0] = id;\r\n        set(self, ids, currencyCt, currencyId);\r\n    }\r\n\r\n    function set(Balance storage self, int256[] memory ids, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        uint256 i;\r\n        for (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\r\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\r\n\r\n        self.idsByCurrency[currencyCt][currencyId] = ids;\r\n\r\n        for (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\r\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = i + 1;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateInUseCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function reset(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        for (uint256 i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\r\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\r\n\r\n        self.idsByCurrency[currencyCt][currencyId].length = 0;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateInUseCurrencies(self, currencyCt, currencyId);\r\n    }\r\n\r\n    function add(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\r\n    internal\r\n    returns (bool)\r\n    {\r\n        if (0 < self.idIndexById[currencyCt][currencyId][id])\r\n            return false;\r\n\r\n        self.idsByCurrency[currencyCt][currencyId].push(id);\r\n\r\n        self.idIndexById[currencyCt][currencyId][id] = self.idsByCurrency[currencyCt][currencyId].length;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateInUseCurrencies(self, currencyCt, currencyId);\r\n\r\n        return true;\r\n    }\r\n\r\n    function sub(Balance storage self, int256 id, address currencyCt, uint256 currencyId)\r\n    internal\r\n    returns (bool)\r\n    {\r\n        uint256 index = self.idIndexById[currencyCt][currencyId][id];\r\n\r\n        if (0 == index)\r\n            return false;\r\n\r\n        if (index < self.idsByCurrency[currencyCt][currencyId].length) {\r\n            self.idsByCurrency[currencyCt][currencyId][index - 1] = self.idsByCurrency[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId].length - 1];\r\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][index - 1]] = index;\r\n        }\r\n        self.idsByCurrency[currencyCt][currencyId].length--;\r\n        self.idIndexById[currencyCt][currencyId][id] = 0;\r\n\r\n        self.recordsByCurrency[currencyCt][currencyId].push(\r\n            Record(self.idsByCurrency[currencyCt][currencyId], block.number)\r\n        );\r\n\r\n        updateInUseCurrencies(self, currencyCt, currencyId);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(Balance storage _from, Balance storage _to, int256 id,\r\n        address currencyCt, uint256 currencyId)\r\n    internal\r\n    returns (bool)\r\n    {\r\n        return sub(_from, id, currencyCt, currencyId) && add(_to, id, currencyCt, currencyId);\r\n    }\r\n\r\n    function hasInUseCurrency(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return self.inUseCurrencies.has(currencyCt, currencyId);\r\n    }\r\n\r\n    function hasEverUsedCurrency(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return self.everUsedCurrencies.has(currencyCt, currencyId);\r\n    }\r\n\r\n    function updateInUseCurrencies(Balance storage self, address currencyCt, uint256 currencyId)\r\n    internal\r\n    {\r\n        if (0 == self.idsByCurrency[currencyCt][currencyId].length && self.inUseCurrencies.has(currencyCt, currencyId))\r\n            self.inUseCurrencies.removeByCurrency(currencyCt, currencyId);\r\n        else if (!self.inUseCurrencies.has(currencyCt, currencyId)) {\r\n            self.inUseCurrencies.add(currencyCt, currencyId);\r\n            self.everUsedCurrencies.add(currencyCt, currencyId);\r\n        }\r\n    }\r\n\r\n    function indexByBlockNumber(Balance storage self, address currencyCt, uint256 currencyId, uint256 blockNumber)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        if (0 == self.recordsByCurrency[currencyCt][currencyId].length)\r\n            return 0;\r\n        for (uint256 i = self.recordsByCurrency[currencyCt][currencyId].length; i > 0; i--)\r\n            if (self.recordsByCurrency[currencyCt][currencyId][i - 1].blockNumber <= blockNumber)\r\n                return i;\r\n        return 0;\r\n    }\r\n}\r\n\r\ncontract BalanceTracker is Ownable, Servable {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n    using FungibleBalanceLib for FungibleBalanceLib.Balance;\r\n    using NonFungibleBalanceLib for NonFungibleBalanceLib.Balance;\r\n\r\n    \r\n    \r\n    \r\n    string constant public DEPOSITED_BALANCE_TYPE = \"deposited\";\r\n    string constant public SETTLED_BALANCE_TYPE = \"settled\";\r\n    string constant public STAGED_BALANCE_TYPE = \"staged\";\r\n\r\n    \r\n    \r\n    \r\n    struct Wallet {\r\n        mapping(bytes32 => FungibleBalanceLib.Balance) fungibleBalanceByType;\r\n        mapping(bytes32 => NonFungibleBalanceLib.Balance) nonFungibleBalanceByType;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    bytes32 public depositedBalanceType;\r\n    bytes32 public settledBalanceType;\r\n    bytes32 public stagedBalanceType;\r\n\r\n    bytes32[] public _allBalanceTypes;\r\n    bytes32[] public _activeBalanceTypes;\r\n\r\n    bytes32[] public trackedBalanceTypes;\r\n    mapping(bytes32 => bool) public trackedBalanceTypeMap;\r\n\r\n    mapping(address => Wallet) private walletMap;\r\n\r\n    address[] public trackedWallets;\r\n    mapping(address => uint256) public trackedWalletIndexByWallet;\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer)\r\n    public\r\n    {\r\n        depositedBalanceType = keccak256(abi.encodePacked(DEPOSITED_BALANCE_TYPE));\r\n        settledBalanceType = keccak256(abi.encodePacked(SETTLED_BALANCE_TYPE));\r\n        stagedBalanceType = keccak256(abi.encodePacked(STAGED_BALANCE_TYPE));\r\n\r\n        _allBalanceTypes.push(settledBalanceType);\r\n        _allBalanceTypes.push(depositedBalanceType);\r\n        _allBalanceTypes.push(stagedBalanceType);\r\n\r\n        _activeBalanceTypes.push(settledBalanceType);\r\n        _activeBalanceTypes.push(depositedBalanceType);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function get(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        return walletMap[wallet].fungibleBalanceByType[_type].get(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function getByIndices(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\r\n        uint256 indexLow, uint256 indexUp)\r\n    public\r\n    view\r\n    returns (int256[] memory)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].getByIndices(\r\n            currencyCt, currencyId, indexLow, indexUp\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function getAll(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256[] memory)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].get(\r\n            currencyCt, currencyId\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function idsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].idsCount(\r\n            currencyCt, currencyId\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function hasId(address wallet, bytes32 _type, int256 id, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].hasId(\r\n            id, currencyCt, currencyId\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function set(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId, bool fungible)\r\n    public\r\n    onlyActiveService\r\n    {\r\n        \r\n        if (fungible)\r\n            walletMap[wallet].fungibleBalanceByType[_type].set(\r\n                value, currencyCt, currencyId\r\n            );\r\n\r\n        else\r\n            walletMap[wallet].nonFungibleBalanceByType[_type].set(\r\n                value, currencyCt, currencyId\r\n            );\r\n\r\n        \r\n        _updateTrackedBalanceTypes(_type);\r\n\r\n        \r\n        _updateTrackedWallets(wallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setIds(address wallet, bytes32 _type, int256[] memory ids, address currencyCt, uint256 currencyId)\r\n    public\r\n    onlyActiveService\r\n    {\r\n        \r\n        walletMap[wallet].nonFungibleBalanceByType[_type].set(\r\n            ids, currencyCt, currencyId\r\n        );\r\n\r\n        \r\n        _updateTrackedBalanceTypes(_type);\r\n\r\n        \r\n        _updateTrackedWallets(wallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function add(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId,\r\n        bool fungible)\r\n    public\r\n    onlyActiveService\r\n    {\r\n        \r\n        if (fungible)\r\n            walletMap[wallet].fungibleBalanceByType[_type].add(\r\n                value, currencyCt, currencyId\r\n            );\r\n        else\r\n            walletMap[wallet].nonFungibleBalanceByType[_type].add(\r\n                value, currencyCt, currencyId\r\n            );\r\n\r\n        \r\n        _updateTrackedBalanceTypes(_type);\r\n\r\n        \r\n        _updateTrackedWallets(wallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function sub(address wallet, bytes32 _type, int256 value, address currencyCt, uint256 currencyId,\r\n        bool fungible)\r\n    public\r\n    onlyActiveService\r\n    {\r\n        \r\n        if (fungible)\r\n            walletMap[wallet].fungibleBalanceByType[_type].sub(\r\n                value, currencyCt, currencyId\r\n            );\r\n        else\r\n            walletMap[wallet].nonFungibleBalanceByType[_type].sub(\r\n                value, currencyCt, currencyId\r\n            );\r\n\r\n        \r\n        _updateTrackedWallets(wallet);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function hasInUseCurrency(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return walletMap[wallet].fungibleBalanceByType[_type].hasInUseCurrency(currencyCt, currencyId)\r\n        || walletMap[wallet].nonFungibleBalanceByType[_type].hasInUseCurrency(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function hasEverUsedCurrency(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return walletMap[wallet].fungibleBalanceByType[_type].hasEverUsedCurrency(currencyCt, currencyId)\r\n        || walletMap[wallet].nonFungibleBalanceByType[_type].hasEverUsedCurrency(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function fungibleRecordsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletMap[wallet].fungibleBalanceByType[_type].recordsCount(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function fungibleRecordByIndex(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\r\n        uint256 index)\r\n    public\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        return walletMap[wallet].fungibleBalanceByType[_type].recordByIndex(currencyCt, currencyId, index);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function fungibleRecordByBlockNumber(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\r\n        uint256 _blockNumber)\r\n    public\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        return walletMap[wallet].fungibleBalanceByType[_type].recordByBlockNumber(currencyCt, currencyId, _blockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function lastFungibleRecord(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        return walletMap[wallet].fungibleBalanceByType[_type].lastRecord(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function nonFungibleRecordsCount(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordsCount(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function nonFungibleRecordByIndex(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\r\n        uint256 index)\r\n    public\r\n    view\r\n    returns (int256[] memory ids, uint256 blockNumber)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordByIndex(currencyCt, currencyId, index);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function nonFungibleRecordByBlockNumber(address wallet, bytes32 _type, address currencyCt, uint256 currencyId,\r\n        uint256 _blockNumber)\r\n    public\r\n    view\r\n    returns (int256[] memory ids, uint256 blockNumber)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].recordByBlockNumber(currencyCt, currencyId, _blockNumber);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function lastNonFungibleRecord(address wallet, bytes32 _type, address currencyCt, uint256 currencyId)\r\n    public\r\n    view\r\n    returns (int256[] memory ids, uint256 blockNumber)\r\n    {\r\n        return walletMap[wallet].nonFungibleBalanceByType[_type].lastRecord(currencyCt, currencyId);\r\n    }\r\n\r\n    \r\n    \r\n    function trackedBalanceTypesCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return trackedBalanceTypes.length;\r\n    }\r\n\r\n    \r\n    \r\n    function trackedWalletsCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return trackedWallets.length;\r\n    }\r\n\r\n    \r\n    \r\n    function allBalanceTypes()\r\n    public\r\n    view\r\n    returns (bytes32[] memory)\r\n    {\r\n        return _allBalanceTypes;\r\n    }\r\n\r\n    \r\n    \r\n    function activeBalanceTypes()\r\n    public\r\n    view\r\n    returns (bytes32[] memory)\r\n    {\r\n        return _activeBalanceTypes;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function trackedWalletsByIndices(uint256 low, uint256 up)\r\n    public\r\n    view\r\n    returns (address[] memory)\r\n    {\r\n        require(0 < trackedWallets.length, \"No tracked wallets found [BalanceTracker.sol:473]\");\r\n        require(low <= up, \"Bounds parameters mismatch [BalanceTracker.sol:474]\");\r\n\r\n        up = up.clampMax(trackedWallets.length - 1);\r\n        address[] memory _trackedWallets = new address[](up - low + 1);\r\n        for (uint256 i = low; i <= up; i++)\r\n            _trackedWallets[i - low] = trackedWallets[i];\r\n\r\n        return _trackedWallets;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function _updateTrackedBalanceTypes(bytes32 _type)\r\n    private\r\n    {\r\n        if (!trackedBalanceTypeMap[_type]) {\r\n            trackedBalanceTypeMap[_type] = true;\r\n            trackedBalanceTypes.push(_type);\r\n        }\r\n    }\r\n\r\n    function _updateTrackedWallets(address wallet)\r\n    private\r\n    {\r\n        if (0 == trackedWalletIndexByWallet[wallet]) {\r\n            trackedWallets.push(wallet);\r\n            trackedWalletIndexByWallet[wallet] = trackedWallets.length;\r\n        }\r\n    }\r\n}\r\n\r\ncontract BalanceTrackable is Ownable {\r\n    \r\n    \r\n    \r\n    BalanceTracker public balanceTracker;\r\n    bool public balanceTrackerFrozen;\r\n\r\n    \r\n    \r\n    \r\n    event SetBalanceTrackerEvent(BalanceTracker oldBalanceTracker, BalanceTracker newBalanceTracker);\r\n    event FreezeBalanceTrackerEvent();\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setBalanceTracker(BalanceTracker newBalanceTracker)\r\n    public\r\n    onlyDeployer\r\n    notNullAddress(address(newBalanceTracker))\r\n    notSameAddresses(address(newBalanceTracker), address(balanceTracker))\r\n    {\r\n        \r\n        require(!balanceTrackerFrozen, \"Balance tracker frozen [BalanceTrackable.sol:43]\");\r\n\r\n        \r\n        BalanceTracker oldBalanceTracker = balanceTracker;\r\n        balanceTracker = newBalanceTracker;\r\n\r\n        \r\n        emit SetBalanceTrackerEvent(oldBalanceTracker, newBalanceTracker);\r\n    }\r\n\r\n    \r\n    \r\n    function freezeBalanceTracker()\r\n    public\r\n    onlyDeployer\r\n    {\r\n        balanceTrackerFrozen = true;\r\n\r\n        \r\n        emit FreezeBalanceTrackerEvent();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier balanceTrackerInitialized() {\r\n        require(address(balanceTracker) != address(0), \"Balance tracker not initialized [BalanceTrackable.sol:69]\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Upgradable {\r\n    \r\n    \r\n    \r\n    address public upgradeAgent;\r\n    bool public upgradesFrozen;\r\n\r\n    \r\n    \r\n    \r\n    event SetUpgradeAgentEvent(address upgradeAgent);\r\n    event FreezeUpgradesEvent();\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function setUpgradeAgent(address _upgradeAgent)\r\n    public\r\n    onlyWhenUpgradable\r\n    {\r\n        require(address(0) == upgradeAgent, \"Upgrade agent has already been set [Upgradable.sol:37]\");\r\n\r\n        \r\n        upgradeAgent = _upgradeAgent;\r\n\r\n        \r\n        emit SetUpgradeAgentEvent(upgradeAgent);\r\n    }\r\n\r\n    \r\n    \r\n    function freezeUpgrades()\r\n    public\r\n    onlyWhenUpgrading\r\n    {\r\n        \r\n        upgradesFrozen = true;\r\n\r\n        \r\n        emit FreezeUpgradesEvent();\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    modifier onlyWhenUpgrading() {\r\n        require(msg.sender == upgradeAgent, \"Caller is not upgrade agent [Upgradable.sol:63]\");\r\n        require(!upgradesFrozen, \"Upgrades have been frozen [Upgradable.sol:64]\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenUpgradable() {\r\n        require(!upgradesFrozen, \"Upgrades have been frozen [Upgradable.sol:69]\");\r\n        _;\r\n    }\r\n}\r\n\r\nlibrary NahmiiTypesLib {\r\n    \r\n    \r\n    \r\n    enum ChallengePhase {Dispute, Closed}\r\n\r\n    \r\n    \r\n    \r\n    struct OriginFigure {\r\n        uint256 originId;\r\n        MonetaryTypesLib.Figure figure;\r\n    }\r\n\r\n    struct IntendedConjugateCurrency {\r\n        MonetaryTypesLib.Currency intended;\r\n        MonetaryTypesLib.Currency conjugate;\r\n    }\r\n\r\n    struct SingleFigureTotalOriginFigures {\r\n        MonetaryTypesLib.Figure single;\r\n        OriginFigure[] total;\r\n    }\r\n\r\n    struct TotalOriginFigures {\r\n        OriginFigure[] total;\r\n    }\r\n\r\n    struct CurrentPreviousInt256 {\r\n        int256 current;\r\n        int256 previous;\r\n    }\r\n\r\n    struct SingleTotalInt256 {\r\n        int256 single;\r\n        int256 total;\r\n    }\r\n\r\n    struct IntendedConjugateCurrentPreviousInt256 {\r\n        CurrentPreviousInt256 intended;\r\n        CurrentPreviousInt256 conjugate;\r\n    }\r\n\r\n    struct IntendedConjugateSingleTotalInt256 {\r\n        SingleTotalInt256 intended;\r\n        SingleTotalInt256 conjugate;\r\n    }\r\n\r\n    struct WalletOperatorHashes {\r\n        bytes32 wallet;\r\n        bytes32 operator;\r\n    }\r\n\r\n    struct Signature {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n    }\r\n\r\n    struct Seal {\r\n        bytes32 hash;\r\n        Signature signature;\r\n    }\r\n\r\n    struct WalletOperatorSeal {\r\n        Seal wallet;\r\n        Seal operator;\r\n    }\r\n}\r\n\r\nlibrary SettlementChallengeTypesLib {\r\n    \r\n    \r\n    \r\n    enum Status {Qualified, Disqualified}\r\n\r\n    struct Proposal {\r\n        address wallet;\r\n        uint256 nonce;\r\n        uint256 referenceBlockNumber;\r\n        uint256 definitionBlockNumber;\r\n\r\n        uint256 expirationTime;\r\n\r\n        \r\n        Status status;\r\n\r\n        \r\n        Amounts amounts;\r\n\r\n        \r\n        MonetaryTypesLib.Currency currency;\r\n\r\n        \r\n        Driip challenged;\r\n\r\n        \r\n        bool walletInitiated;\r\n\r\n        \r\n        bool terminated;\r\n\r\n        \r\n        Disqualification disqualification;\r\n    }\r\n\r\n    struct Amounts {\r\n        \r\n        int256 cumulativeTransfer;\r\n\r\n        \r\n        int256 stage;\r\n\r\n        \r\n        int256 targetBalance;\r\n    }\r\n\r\n    struct Driip {\r\n        \r\n        string kind;\r\n\r\n        \r\n        bytes32 hash;\r\n    }\r\n\r\n    struct Disqualification {\r\n        \r\n        address challenger;\r\n        uint256 nonce;\r\n        uint256 blockNumber;\r\n\r\n        \r\n        Driip candidate;\r\n    }\r\n}\r\n\r\ncontract NullSettlementChallengeState is Ownable, Servable, Configurable, BalanceTrackable, Upgradable {\r\n    using SafeMathIntLib for int256;\r\n    using SafeMathUintLib for uint256;\r\n\r\n    \r\n    \r\n    \r\n    string constant public INITIATE_PROPOSAL_ACTION = \"initiate_proposal\";\r\n    string constant public TERMINATE_PROPOSAL_ACTION = \"terminate_proposal\";\r\n    string constant public REMOVE_PROPOSAL_ACTION = \"remove_proposal\";\r\n    string constant public DISQUALIFY_PROPOSAL_ACTION = \"disqualify_proposal\";\r\n\r\n    \r\n    \r\n    \r\n    SettlementChallengeTypesLib.Proposal[] public proposals;\r\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public proposalIndexByWalletCurrency;\r\n\r\n    \r\n    \r\n    \r\n    event InitiateProposalEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated);\r\n    event TerminateProposalEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated);\r\n    event RemoveProposalEvent(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated);\r\n    event DisqualifyProposalEvent(address challengedWallet, uint256 challangedNonce, int256 stageAmount,\r\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency currency, uint256 blockNumber, bool walletInitiated,\r\n        address challengerWallet, uint256 candidateNonce, bytes32 candidateHash, string candidateKind);\r\n    event UpgradeProposalEvent(SettlementChallengeTypesLib.Proposal proposal);\r\n\r\n    \r\n    \r\n    \r\n    constructor(address deployer) Ownable(deployer) public {\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function proposalsCount()\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return proposals.length;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function initiateProposal(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        MonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated)\r\n    public\r\n    onlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        _initiateProposal(\r\n            wallet, nonce, stageAmount, targetBalanceAmount,\r\n            currency, blockNumber, walletInitiated\r\n        );\r\n\r\n        \r\n        emit InitiateProposalEvent(\r\n            wallet, nonce, stageAmount, targetBalanceAmount, currency,\r\n            blockNumber, walletInitiated\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index)\r\n            return;\r\n\r\n        \r\n        proposals[index - 1].terminated = true;\r\n\r\n        \r\n        emit TerminateProposalEvent(\r\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\r\n            proposals[index - 1].amounts.targetBalance, currency,\r\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\r\n    public\r\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index)\r\n            return;\r\n\r\n        \r\n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:145]\");\r\n\r\n        \r\n        proposals[index - 1].terminated = true;\r\n\r\n        \r\n        emit TerminateProposalEvent(\r\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\r\n            proposals[index - 1].amounts.targetBalance, currency,\r\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index)\r\n            return;\r\n\r\n        \r\n        emit RemoveProposalEvent(\r\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\r\n            proposals[index - 1].amounts.targetBalance, currency,\r\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\r\n        );\r\n\r\n        \r\n        _removeProposal(index);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\r\n    public\r\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index)\r\n            return;\r\n\r\n        \r\n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:199]\");\r\n\r\n        \r\n        emit RemoveProposalEvent(\r\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\r\n            proposals[index - 1].amounts.targetBalance, currency,\r\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\r\n        );\r\n\r\n        \r\n        _removeProposal(index);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\r\n        uint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\r\n    public\r\n    onlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\r\n        require(0 != index, \"No settlement found for wallet and currency [NullSettlementChallengeState.sol:228]\");\r\n\r\n        \r\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\r\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\r\n        proposals[index - 1].disqualification.challenger = challengerWallet;\r\n        proposals[index - 1].disqualification.nonce = candidateNonce;\r\n        proposals[index - 1].disqualification.blockNumber = blockNumber;\r\n        proposals[index - 1].disqualification.candidate.hash = candidateHash;\r\n        proposals[index - 1].disqualification.candidate.kind = candidateKind;\r\n\r\n        \r\n        emit DisqualifyProposalEvent(\r\n            challengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\r\n            proposals[index - 1].amounts.targetBalance, currency, proposals[index - 1].referenceBlockNumber,\r\n            proposals[index - 1].walletInitiated, challengerWallet, candidateNonce, candidateHash, candidateKind\r\n        );\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        \r\n        return 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:271]\");\r\n        return proposals[index - 1].terminated;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        \r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:286]\");\r\n        return block.timestamp >= proposals[index - 1].expirationTime;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:300]\");\r\n        return proposals[index - 1].nonce;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:314]\");\r\n        return proposals[index - 1].referenceBlockNumber;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:328]\");\r\n        return proposals[index - 1].definitionBlockNumber;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:342]\");\r\n        return proposals[index - 1].expirationTime;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (SettlementChallengeTypesLib.Status)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:356]\");\r\n        return proposals[index - 1].status;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:370]\");\r\n        return proposals[index - 1].amounts.stage;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (int256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:384]\");\r\n        return proposals[index - 1].amounts.targetBalance;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:398]\");\r\n        return proposals[index - 1].walletInitiated;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:412]\");\r\n        return proposals[index - 1].disqualification.challenger;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:426]\");\r\n        return proposals[index - 1].disqualification.blockNumber;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:440]\");\r\n        return proposals[index - 1].disqualification.nonce;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (bytes32)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:454]\");\r\n        return proposals[index - 1].disqualification.candidate.hash;\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\r\n    public\r\n    view\r\n    returns (string memory)\r\n    {\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n        require(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:468]\");\r\n        return proposals[index - 1].disqualification.candidate.kind;\r\n    }\r\n\r\n    \r\n    \r\n    function upgradeProposal(SettlementChallengeTypesLib.Proposal memory proposal)\r\n    public\r\n    onlyWhenUpgrading\r\n    {\r\n        \r\n        require(\r\n            0 == proposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id],\r\n            \"Proposal exists for wallet and currency [NullSettlementChallengeState.sol:479]\"\r\n        );\r\n\r\n        \r\n        proposals.push(proposal);\r\n\r\n        \r\n        uint256 index = proposals.length;\r\n\r\n        \r\n        proposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id] = index;\r\n\r\n        \r\n        emit UpgradeProposalEvent(proposal);\r\n    }\r\n\r\n\r\n    \r\n    \r\n    \r\n    function _initiateProposal(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\r\n        MonetaryTypesLib.Currency memory currency, uint256 referenceBlockNumber, bool walletInitiated)\r\n    private\r\n    {\r\n        \r\n        require(stageAmount.isPositiveInt256(), \"Stage amount not positive [NullSettlementChallengeState.sol:506]\");\r\n        require(targetBalanceAmount.isPositiveInt256(), \"Target balance amount not positive [NullSettlementChallengeState.sol:507]\");\r\n\r\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\r\n\r\n        \r\n        if (0 == index) {\r\n            index = ++(proposals.length);\r\n            proposalIndexByWalletCurrency[wallet][currency.ct][currency.id] = index;\r\n        }\r\n\r\n        \r\n        proposals[index - 1].wallet = wallet;\r\n        proposals[index - 1].nonce = nonce;\r\n        proposals[index - 1].referenceBlockNumber = referenceBlockNumber;\r\n        proposals[index - 1].definitionBlockNumber = block.number;\r\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\r\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\r\n        proposals[index - 1].currency = currency;\r\n        proposals[index - 1].amounts.stage = stageAmount;\r\n        proposals[index - 1].amounts.targetBalance = targetBalanceAmount;\r\n        proposals[index - 1].walletInitiated = walletInitiated;\r\n        proposals[index - 1].terminated = false;\r\n    }\r\n\r\n    function _removeProposal(uint256 index)\r\n    private\r\n    returns (bool)\r\n    {\r\n        \r\n        proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = 0;\r\n        if (index < proposals.length) {\r\n            proposals[index - 1] = proposals[proposals.length - 1];\r\n            proposalIndexByWalletCurrency[proposals[index - 1].wallet][proposals[index - 1].currency.ct][proposals[index - 1].currency.id] = index;\r\n        }\r\n        proposals.length--;\r\n    }\r\n\r\n    function _activeBalanceLogEntry(address wallet, address currencyCt, uint256 currencyId)\r\n    private\r\n    view\r\n    returns (int256 amount, uint256 blockNumber)\r\n    {\r\n        \r\n        (int256 depositedAmount, uint256 depositedBlockNumber) = balanceTracker.lastFungibleRecord(\r\n            wallet, balanceTracker.depositedBalanceType(), currencyCt, currencyId\r\n        );\r\n        (int256 settledAmount, uint256 settledBlockNumber) = balanceTracker.lastFungibleRecord(\r\n            wallet, balanceTracker.settledBalanceType(), currencyCt, currencyId\r\n        );\r\n\r\n        \r\n        amount = depositedAmount.add(settledAmount);\r\n\r\n        \r\n        blockNumber = depositedBlockNumber > settledBlockNumber ? depositedBlockNumber : settledBlockNumber;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referenceBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"definitionBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"enum SettlementChallengeTypesLib.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"cumulativeTransfer\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"stage\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"targetBalance\",\"type\":\"int256\"}],\"internalType\":\"struct SettlementChallengeTypesLib.Amounts\",\"name\":\"amounts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"kind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"internalType\":\"struct SettlementChallengeTypesLib.Driip\",\"name\":\"challenged\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"walletInitiated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"terminated\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"kind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"internalType\":\"struct SettlementChallengeTypesLib.Driip\",\"name\":\"candidate\",\"type\":\"tuple\"}],\"internalType\":\"struct SettlementChallengeTypesLib.Disqualification\",\"name\":\"disqualification\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeUpgrades\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredActiveService\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceTracker\",\"outputs\":[{\"internalType\":\"contract BalanceTracker\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalDisqualificationCandidateHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"removeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"}],\"name\":\"enableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredService\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalDisqualificationCandidateKind\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructionDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"hasProposal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"}],\"name\":\"disableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceActivationTimeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceTrackerFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destructor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"deregisterService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"walletTerminated\",\"type\":\"bool\"}],\"name\":\"removeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalDefinitionBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"hasProposalExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalDisqualificationNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalDisqualificationChallenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalExpirationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract BalanceTracker\",\"name\":\"newBalanceTracker\",\"type\":\"address\"}],\"name\":\"setBalanceTracker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradeAgent\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"}],\"name\":\"isEnabledServiceAction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalStageAmount\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Configuration\",\"name\":\"newConfiguration\",\"type\":\"address\"}],\"name\":\"setConfiguration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"challengedWallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"challengerWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"candidateNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"candidateHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"candidateKind\",\"type\":\"string\"}],\"name\":\"disqualifyProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalIndexByWalletCurrency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"configuration\",\"outputs\":[{\"internalType\":\"contract Configuration\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradesFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalReferenceBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"setServiceActivationTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"hasProposalTerminated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TERMINATE_PROPOSAL_ACTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalDisqualificationBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerServiceDeferred\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REMOVE_PROPOSAL_ACTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIATE_PROPOSAL_ACTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"walletTerminated\",\"type\":\"bool\"}],\"name\":\"terminateProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"terminateProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freezeBalanceTracker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalStatus\",\"outputs\":[{\"internalType\":\"enum SettlementChallengeTypesLib.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"walletInitiated\",\"type\":\"bool\"}],\"name\":\"initiateProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalTargetBalanceAmount\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"}],\"name\":\"proposalWalletInitiated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upgradeAgent\",\"type\":\"address\"}],\"name\":\"setUpgradeAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DISQUALIFY_PROPOSAL_ACTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referenceBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"definitionBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"enum SettlementChallengeTypesLib.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"cumulativeTransfer\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"stage\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"targetBalance\",\"type\":\"int256\"}],\"internalType\":\"struct SettlementChallengeTypesLib.Amounts\",\"name\":\"amounts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"kind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"internalType\":\"struct SettlementChallengeTypesLib.Driip\",\"name\":\"challenged\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"walletInitiated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"terminated\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"kind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"internalType\":\"struct SettlementChallengeTypesLib.Driip\",\"name\":\"candidate\",\"type\":\"tuple\"}],\"internalType\":\"struct SettlementChallengeTypesLib.Disqualification\",\"name\":\"disqualification\",\"type\":\"tuple\"}],\"internalType\":\"struct SettlementChallengeTypesLib.Proposal\",\"name\":\"proposal\",\"type\":\"tuple\"}],\"name\":\"upgradeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"walletInitiated\",\"type\":\"bool\"}],\"name\":\"InitiateProposalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"walletInitiated\",\"type\":\"bool\"}],\"name\":\"TerminateProposalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"walletInitiated\",\"type\":\"bool\"}],\"name\":\"RemoveProposalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengedWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"challangedNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"stageAmount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"targetBalanceAmount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"walletInitiated\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengerWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"candidateNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"candidateHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"candidateKind\",\"type\":\"string\"}],\"name\":\"DisqualifyProposalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referenceBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"definitionBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"enum SettlementChallengeTypesLib.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"cumulativeTransfer\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"stage\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"targetBalance\",\"type\":\"int256\"}],\"internalType\":\"struct SettlementChallengeTypesLib.Amounts\",\"name\":\"amounts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"ct\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct MonetaryTypesLib.Currency\",\"name\":\"currency\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"kind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"internalType\":\"struct SettlementChallengeTypesLib.Driip\",\"name\":\"challenged\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"walletInitiated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"terminated\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"kind\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"internalType\":\"struct SettlementChallengeTypesLib.Driip\",\"name\":\"candidate\",\"type\":\"tuple\"}],\"internalType\":\"struct SettlementChallengeTypesLib.Disqualification\",\"name\":\"disqualification\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct SettlementChallengeTypesLib.Proposal\",\"name\":\"proposal\",\"type\":\"tuple\"}],\"name\":\"UpgradeProposalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"upgradeAgent\",\"type\":\"address\"}],\"name\":\"SetUpgradeAgentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeUpgradesEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract BalanceTracker\",\"name\":\"oldBalanceTracker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract BalanceTracker\",\"name\":\"newBalanceTracker\",\"type\":\"address\"}],\"name\":\"SetBalanceTrackerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FreezeBalanceTrackerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract Configuration\",\"name\":\"oldConfiguration\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract Configuration\",\"name\":\"newConfiguration\",\"type\":\"address\"}],\"name\":\"SetConfigurationEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"ServiceActivationTimeoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"RegisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"RegisterServiceDeferredEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"DeregisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"}],\"name\":\"EnableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"}],\"name\":\"DisableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDeployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"SetDeployerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"SetOperatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SelfDestructionDisabledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TriggerSelfDestructionEvent\",\"type\":\"event\"}]","ContractName":"NullSettlementChallengeState","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000f05179bac3d1fbef58a2fcd7ad0f769840027cc6","Library":"SafeMathIntLib:2fcb98529d58669e229c453de4b4705bb6b2d414","SwarmSource":"bzzr://31838e7e9142965a5ea028b60a083a582a97a6c28b3300933fcbcd8269274056"}]}