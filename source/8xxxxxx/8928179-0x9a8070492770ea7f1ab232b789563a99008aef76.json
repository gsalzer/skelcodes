{"status":"1","message":"OK","result":[{"SourceCode":"{\"HipToken.sol\":{\"content\":\"pragma solidity ^0.5.0;\\nimport \\u0027./SafeMathLib.sol\\u0027;\\n\\n\\ncontract HipToken {\\n    using SafeMathLib for uint;\\n\\n    mapping (address =\\u003e uint) balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint)) allowed;\\n    mapping (uint =\\u003e FrozenTokens) public frozenTokensMap;\\n\\n    event Transfer(address indexed sender, address indexed receiver, uint value);\\n    event Approval(address approver, address spender, uint value);\\n    event TokensFrozen(address indexed freezer, uint amount, uint id, uint lengthFreezeDays);\\n    event TokensUnfrozen(address indexed unfreezer, uint amount, uint id);\\n    event TokensBurned(address burner, uint amount);\\n\\n    uint8 constant public decimals = 18;\\n    string constant public symbol = \\\"HIP\\\";\\n    string constant public name = \\\"HiP Token\\\";\\n    uint public totalSupply;\\n    uint numFrozenStructs;\\n\\n    struct FrozenTokens {\\n        uint id;\\n        uint dateFrozen;\\n        uint lengthFreezeDays;\\n        uint amount;\\n        bool frozen;\\n        address owner;\\n    }\\n\\n    // simple initialization, giving complete token supply to one address\\n    constructor(address bank, uint initialBalance) public {\\n        require(bank != address(0), \\u0027Must initialize with nonzero address\\u0027);\\n        balances[bank] = initialBalance;\\n        totalSupply = initialBalance;\\n        emit Transfer(address(0), bank, initialBalance);\\n    }\\n\\n    // freeze tokens for a certain number of days\\n    function freeze(uint amount, uint freezeDays) public {\\n        require(amount \\u003e 0, \\u0027Cannot freeze 0 tokens\\u0027);\\n        // move tokens into this contract\\u0027s address from sender\\n        balances[msg.sender] = balances[msg.sender].minus(amount);\\n        balances[address(this)] = balances[address(this)].plus(amount);\\n        numFrozenStructs = numFrozenStructs.plus(1);\\n        frozenTokensMap[numFrozenStructs] = FrozenTokens(numFrozenStructs, now, freezeDays, amount, true, msg.sender);\\n        emit Transfer(msg.sender, address(this), amount);\\n        emit TokensFrozen(msg.sender, amount, numFrozenStructs, freezeDays);\\n    }\\n\\n    // unfreeze frozen tokens\\n    function unFreeze(uint id) public {\\n        FrozenTokens storage f = frozenTokensMap[id];\\n        require(f.dateFrozen + (f.lengthFreezeDays * 1 days) \\u003c now, \\u0027May not unfreeze until freeze time is up\\u0027);\\n        require(f.frozen, \\u0027Can only unfreeze frozen tokens\\u0027);\\n        f.frozen = false;\\n        // move tokens back into owner\\u0027s address from this contract\\u0027s address\\n        balances[f.owner] = balances[f.owner].plus(f.amount);\\n        balances[address(this)] = balances[address(this)].minus(f.amount);\\n        emit Transfer(address(this), msg.sender, f.amount);\\n        emit TokensUnfrozen(f.owner, f.amount, id);\\n    }\\n\\n    // burn tokens, taking them out of supply\\n    function burn(uint amount) public {\\n        balances[msg.sender] = balances[msg.sender].minus(amount);\\n        totalSupply = totalSupply.minus(amount);\\n        emit Transfer(msg.sender, address(0), amount);\\n        emit TokensBurned(msg.sender, amount);\\n    }\\n\\n    // transfer tokens\\n    function transfer(address to, uint value) public returns (bool success)\\n    {\\n        require(to != address(0), \\u0027Cannot send to zero address, please use burn function if that is your intention\\u0027);\\n        // deduct\\n        balances[msg.sender] = balances[msg.sender].minus(value);\\n        // add\\n        balances[to] = balances[to].plus(value);\\n\\n        emit Transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    // transfer someone else\\u0027s tokens, subject to approval\\n    function transferFrom(address from, address to, uint value) public returns (bool success)\\n    {\\n        require(to != address(0), \\u0027Cannot send to zero address, please use burn function if that is your intention\\u0027);\\n        uint allowance = allowed[from][msg.sender];\\n\\n        // deduct\\n        balances[from] = balances[from].minus(value);\\n\\n        // add\\n        balances[to] = balances[to].plus(value);\\n\\n        // adjust allowance\\n        allowed[from][msg.sender] = allowance.minus(value);\\n\\n        emit Transfer(from, to, value);\\n        return true;\\n    }\\n\\n    // retrieve the balance of address\\n    function balanceOf(address owner) public view returns (uint balance) {\\n        return balances[owner];\\n    }\\n\\n    // approve another address to transfer a specific amount of tokens\\n    function approve(address spender, uint value) public returns (bool success) {\\n        allowed[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    // incrementally increase approval, see https://github.com/ethereum/EIPs/issues/738\\n    function increaseApproval(address spender, uint value) public returns (bool success) {\\n        allowed[msg.sender][spender] = allowed[msg.sender][spender].plus(value);\\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    // incrementally decrease approval, see https://github.com/ethereum/EIPs/issues/738\\n    function decreaseApproval(address spender, uint decreaseValue) public returns (bool success) {\\n        uint oldValue = allowed[msg.sender][spender];\\n        // allow decreasing too much, to prevent griefing via front-running\\n        if (decreaseValue \\u003e= oldValue) {\\n            allowed[msg.sender][spender] = 0;\\n        } else {\\n            allowed[msg.sender][spender] = oldValue.minus(decreaseValue);\\n        }\\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    // retrieve allowance for a given owner, spender pair of addresses\\n    function allowance(address owner, address spender) public view returns (uint remaining) {\\n        return allowed[owner][spender];\\n    }\\n\\n    function numCoinsFrozen() public view returns (uint) {\\n        return balances[address(this)];\\n    }\\n}\\n\"},\"SafeMathLib.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nlibrary SafeMathLib {\\n  function times(uint a, uint b) public pure returns (uint) {\\n    uint c = a * b;\\n    require(a == 0 || c / a == b, \\u0027Overflow detected\\u0027);\\n    return c;\\n  }\\n\\n  function minus(uint a, uint b) public pure returns (uint) {\\n    require(b \\u003c= a, \\u0027Underflow detected\\u0027);\\n    return a - b;\\n  }\\n\\n  function plus(uint a, uint b) public pure returns (uint) {\\n    uint c = a + b;\\n    require(c\\u003e=a \\u0026\\u0026 c\\u003e=b, \\u0027Overflow detected\\u0027);\\n    return c;\\n  }\\n\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"freezeDays\",\"type\":\"uint256\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"frozenTokensMap\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"dateFrozen\",\"type\":\"uint256\"},{\"name\":\"lengthFreezeDays\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"frozen\",\"type\":\"bool\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"decreaseValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numCoinsFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"unFreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"bank\",\"type\":\"address\"},{\"name\":\"initialBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"approver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"freezer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lengthFreezeDays\",\"type\":\"uint256\"}],\"name\":\"TokensFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"unfreezer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"TokensUnfrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensBurned\",\"type\":\"event\"}]","ContractName":"HipToken","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b793faf25bfdc5214d26111a7741e48a81af1bd80000000000000000000000000000000000000000033b2e3c9fd0803ce8000000","Library":"SafeMathLib:951aed5e3554332bc2624d988c9c70d002d3dba0","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://974a703bc2907af9b70951031bb50bc80fbaa4be05362b3d03ad34f543fe65fe"}]}