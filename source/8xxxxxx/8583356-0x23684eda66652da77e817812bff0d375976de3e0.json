{"status":"1","message":"OK","result":[{"SourceCode":"// File: browser/Oracle.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\ncontract Oracle {\r\n\r\n    /** Contract Constructor\r\n    * @param ethPrice the starting price of ETH in USD, represented as 150000000 = 150.00 USD\r\n    * @dev The message sender is assigned as the contract administrator\r\n    */\r\n    constructor (uint ethPrice) public {\r\n        admins[msg.sender] = true;\r\n        addAsset(\"ETHUSD\", ethPrice);\r\n    }\r\n    Asset[] public assets;\r\n    uint[8][] private prices;\r\n    mapping(address => bool) public admins;\r\n    mapping(address => bool) public readers;\r\n    //  This prevents the Oracle from sneaking in an unexpected settlement price, especially a rapid succession of them\r\n    // it is 20 hours to accomodate a situation where there is an exogenous circumstance preventing the update, eg, network problems\r\n    uint public constant UPDATE_TIME_MIN = 0 hours;\r\n    // this gives time for players to cure their margins, burn\r\n    uint public constant SETTLE_TIME_MIN1 = 0 days;    // 1 day\r\n    // this prevents addition of new prices before settlements are completed\r\n    uint public constant SETTLE_TIME_MIN2 = 46 hours;   // 46\r\n    // this allows the oracle to rectify honest errors that might accidentally be posted\r\n    uint public constant EDIT_TIME_MAX = 30 minutes;  // 90 min\r\n\r\n    struct Asset {\r\n        bytes32 name;\r\n        uint8 currentDay;\r\n        uint lastUpdateTime;\r\n        uint lastSettleTime;\r\n        bool isFinalDay;\r\n    }\r\n\r\n    event PriceUpdated(\r\n        uint indexed id,\r\n        bytes32 indexed name,\r\n        uint price,\r\n        uint timestamp,\r\n        uint8 dayNumber,\r\n        bool isCorrection\r\n    );\r\n\r\n        modifier onlyAdmin()\r\n    {\r\n        require(admins[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /** Grant administrator priviledges to a user,\r\n    * mainly intended for when the admin wants to switch accounts, ie, paired with a removal\r\n    * @param newAdmin the address to promote\r\n    */\r\n    function addAdmin(address newAdmin)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        admins[newAdmin] = true;\r\n    }\r\n\r\n    /** Add a new asset tracked by the Oracle\r\n    * @param _name the hexadecimal version of the simple name\r\n    * plaintext name of the asset, eg, SPXUSD = 0x5350585553440000000000000000000000000000000000000000000000000000\r\n    * @param _startPrice the starting price of the asset in USD * 10^2, eg 1200 = $12.00\r\n    * @dev this should usually be called on a Settlement Day\r\n    * @return id the newly assigned ID of the asset\r\n    */\r\n    function addAsset(bytes32 _name, uint _startPrice)\r\n        public\r\n        returns (uint _assetID)\r\n    {\r\n        require (admins[msg.sender] || msg.sender == address(this));\r\n        // Fill the asset struct\r\n        Asset memory asset;\r\n        asset.name = _name;\r\n        asset.currentDay = 0;\r\n        asset.lastUpdateTime = now;\r\n        asset.lastSettleTime = now - 5 days;\r\n        assets.push(asset);\r\n        uint[8] memory _prices;\r\n        _prices[0] = _startPrice;\r\n        prices.push(_prices);\r\n        return assets.length - 1;\r\n    }\r\n    /** Quickly fix an erroneous price\r\n    * @param _assetID the id of the asset to change\r\n    * @param _newPrice the new price to change to\r\n    * @dev this must be called within 30 minutes of the lates price update occurence\r\n    */\r\n\r\n    function editPrice(uint _assetID, uint _newPrice)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        Asset storage asset = assets[_assetID];\r\n        require(now < asset.lastUpdateTime + EDIT_TIME_MAX);\r\n        prices[_assetID][asset.currentDay] = _newPrice;\r\n        emit PriceUpdated(_assetID, asset.name, _newPrice, now, asset.currentDay, true);\r\n    }\r\n\r\n    /** Grant an address permision to access private information about the assets\r\n    * @param newReader the address of the account to grant reading priviledges,\r\n    * any new contract the Oracle services would thus need the Oracle's permission\r\n    * @dev this allows the reader to use the getCurrentPricesFunction\r\n    */\r\n    function addReader(address newReader)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        readers[newReader] = true;\r\n    }\r\n\r\n    /** Return the entire current price array for a given asset\r\n    * @param _assetID the asset id of the desired asset\r\n    * @return _priceHist the price array for the asset\r\n    * @dev only the admin and addresses granted readership may call this function\r\n    */\r\n    function getPrices(uint _assetID)\r\n        public\r\n        view\r\n        returns (uint[8] memory _priceHist)\r\n    {\r\n        require (admins[msg.sender] || readers[msg.sender]);\r\n        _priceHist = prices[_assetID];\r\n    }\r\n\r\n    /** Return the current prices array for a given asset\r\n     * excepting the last one. This is useful for users trying to calculate their PNL, as holidays can make\r\n     * inferences about the settlement or start date ambiguous. Anyone trying to use this contract as an oracle, however,\r\n     * would have a day lag\r\n    * @param _assetID the asset id of the desired asset\r\n    * @return _priceHist the price array for the asset excluding the most recent observation\r\n    * @dev only the admin and addresses granted readership may call this function\r\n    */\r\n    function getStalePrices(uint _assetID)\r\n        public\r\n        view\r\n        returns (uint[8] memory _priceHist)\r\n    {\r\n        _priceHist = prices[_assetID];\r\n        _priceHist[assets[_assetID].currentDay]=0;\r\n    }\r\n\r\n    /** Return only the latest prices\r\n    * @param _assetID the asset id of the desired asset\r\n    * @return _price the latest price of the given asset\r\n    * @dev only the admin or a designated reader may call this function\r\n    */\r\n    function getCurrentPrice(uint _assetID)\r\n        public\r\n        view\r\n        returns (uint _price)\r\n    {\r\n        require (admins[msg.sender] || readers[msg.sender]);\r\n        _price =  prices[_assetID][assets[_assetID].currentDay];\r\n    }\r\n\r\n    /** Get the timestamp of the last price update time\r\n    * @param _assetID the asset id of the desired asset\r\n    * @return timestamp the price update timestamp\r\n    */\r\n    function getLastUpdateTime(uint _assetID)\r\n        public\r\n        view\r\n        returns (uint timestamp)\r\n    {\r\n        timestamp = assets[_assetID].lastUpdateTime;\r\n    }\r\n\r\n    /** Get the timestamp of the last settle update time\r\n    * @param _assetID the asset id of the desired asset\r\n    * @return timestamp the settle timestamp\r\n    * this is useful for knowing when to run the WeeklyReturns function, and that settlement is soon\r\n    */\r\n    function getLastSettleTime(uint _assetID)\r\n        public\r\n        view\r\n        returns (uint timestamp)\r\n    {\r\n        timestamp = assets[_assetID].lastSettleTime;\r\n    }\r\n\r\n    /**\r\n    * @param _assetID the asset id of the desired asset\r\n    * pulls the day relevant for new AssetSwap takes\r\n    */\r\n    function getStartDay(uint _assetID)\r\n        public\r\n        view\r\n        returns (uint8 _startDay)\r\n    {\r\n        if (assets[_assetID].isFinalDay) _startDay = 7;\r\n        else if (assets[_assetID].currentDay == 7) _startDay = 1;\r\n        else _startDay = assets[_assetID].currentDay + 1;\r\n    }\r\n\r\n     /** Show if the current day is the final price update before settle\r\n    * @param _assetID the asset id of the desired asset\r\n    * @return true if it is the final day, false otherwise\r\n    * This makes sure the oracle cannot sneak it a settlement unaware, as when flagged false a user knows that a\r\n    * settlement cannot occur for at least 2 days. When set to false it lets a user know the next price update will be a\r\n    * settlement price and they need to potentially cure or cancel\r\n    */\r\n    function isFinalDay(uint _assetID)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return assets[_assetID].isFinalDay;\r\n    }\r\n\r\n    /** Show if the last price update was a settle price update\r\n    * @param _assetID the asset id of the desired asset\r\n    * @return true if the last update was a settle, false otherwise\r\n    * This tells LPs they need to settle their books, and that all parties must  cure their margin if needed\r\n    */\r\n    function isSettleDay(uint _assetID)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (assets[_assetID].currentDay == 7);\r\n    }\r\n\r\n    /** Remove administrator priviledges from a user\r\n    * @param toRemove the address to demote\r\n    * @notice you may not remove yourself. This allows the oracle to deprecate old addresses\r\n    */\r\n    function removeAdmin(address toRemove)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(toRemove != msg.sender);\r\n        admins[toRemove] = false;\r\n    }\r\n\r\n     /** Publishes an asset price. Does not initiate a settlement.\r\n    * @param _assetID the ID of the asset to update\r\n    * @param _price the current price of the asset * 10^2\r\n    * @param finalDayStatus true if this is the last intraweek price update (the next will be a settle)\r\n    * @dev this can only be called after the required time has elapsed since the most recent price update\r\n    * @dev if finalDayStatus is true this function cannot be called again until after settle\r\n    */\r\n    function setIntraWeekPrice(uint _assetID, uint _price, bool finalDayStatus)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        Asset storage asset = assets[_assetID];\r\n        // Prevent a quick succession of price updates\r\n        require(now > asset.lastUpdateTime + UPDATE_TIME_MIN);\r\n        // the price update follawing the isFinalDay=true must be a settlement price\r\n        require(!asset.isFinalDay);\r\n        if (asset.currentDay == 7) {\r\n            require(now > asset.lastSettleTime + SETTLE_TIME_MIN2,\r\n                \"Sufficient time must pass after settlement update.\");\r\n             asset.currentDay = 1;\r\n             uint[8] memory newPrices;\r\n             // the start price for each week is the settlement price of the prior week\r\n             newPrices[0] = prices[_assetID][7];\r\n             newPrices[1] = _price;\r\n             prices[_assetID] = newPrices;\r\n        } else {\r\n            asset.currentDay = asset.currentDay + 1;\r\n            prices[_assetID][asset.currentDay] = _price;\r\n            asset.isFinalDay = finalDayStatus;\r\n        }\r\n        asset.lastUpdateTime = now;\r\n        emit PriceUpdated(_assetID, asset.name, _price, now, asset.currentDay, false);\r\n    }\r\n\r\n    /** Publishes an asset price. Does not initiate a settlement.\r\n    * @param _assetID the ID of the asset to update\r\n    * @param _price the current price of the asset * 10^2\r\n    * @dev this can only be called after the required time has elapsed since the most recent price update\r\n    * @dev if finalDayStatus is true this function cannot be called again until after settle\r\n    */\r\n    function setSettlePrice(uint _assetID, uint _price)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        Asset storage asset = assets[_assetID];\r\n        // Prevent price update too early\r\n        require(now > asset.lastUpdateTime + UPDATE_TIME_MIN);\r\n        // can only be set when the last update signalled as such\r\n        require(asset.isFinalDay);\r\n        // need at least 5 days between settlements\r\n        require(now > asset.lastSettleTime + SETTLE_TIME_MIN1,\r\n            \"Sufficient time must pass between weekly price updates.\");\r\n            // settlement prices are set to slot 7 in the prices array\r\n             asset.currentDay = 7;\r\n             prices[_assetID][7] = _price;\r\n             asset.lastSettleTime = now;\r\n             asset.isFinalDay = false;\r\n        asset.lastUpdateTime = now;\r\n        emit PriceUpdated(_assetID, asset.name, _price, now, 7, false);\r\n\r\n    }\r\n\r\n}\r\n\r\n// File: browser/Book.sol\r\n\r\n\r\npragma solidity ^0.5.11;\r\n\r\ncontract Book {\r\n\r\n    /** Sets up a new Book for an LP.\r\n    * @notice each LP should have only one book\r\n    * @dev the minumum take size is established here and never changes\r\n    * @param user the address of the LP the new book should belong to\r\n    * @param admin gives the AssetSwap contract the right to read and write to this contract\r\n    * @param minBalance the minimum balance size in finney\r\n    */\r\n     constructor(address user, address  admin, uint minBalance)\r\n        public\r\n    {\r\n        assetSwap = AssetSwap(admin);\r\n        lp = user;\r\n        minRM = minBalance * 1 finney;\r\n        lastBookSettleTime = now - 7 days;\r\n    }\r\n\r\n    address public lp;\r\n    AssetSwap public assetSwap;\r\n    bool public bookDefaulted;\r\n    uint public settleNum;\r\n    uint public LPMargin;\r\n    uint public LPLongMargin;    // total RM of all subks where lp is long\r\n    uint public LPShortMargin;   // total RM of all subks where lp is short\r\n    uint public LPRequiredMargin;   // ajusted by take, reset at settle\r\n    uint public lastBookSettleTime;\r\n    uint public minRM;\r\n    uint public debitAcct;\r\n    uint internal constant BURN_DEF_FEE = 2; // burn and default fee, applied as RM/BURN_DEF_FEE\r\n    //  after 9 days without an Oracle settlement, all players can redeem their contracts\r\n    //  after one player executes the invactiveOracle function, which uses this constant, the book is in default allowing\r\n    // anyone to redeem their subcontracts and withdraw their margin\r\n    uint internal constant ORACLE_MAX_ABSENCE = 1 days;\r\n    // as long and short settlements are executed separately, prevents the oracle\r\n    // from settling either side twice on settlement day\r\n    uint internal constant NO_DOUBLE_SETTLES = 1 days;\r\n    // settlement uses gas, and so this max prevents the accumulation of so many subcontracts the Book could never settle\r\n    uint internal constant MAX_SUBCONTRACTS = 225;\r\n    uint internal constant CLOSE_FEE = 200;\r\n    uint internal constant LP_MAX_SETTLE = 0 days;\r\n    bytes32[] public shortTakerContracts; // note this implies the lp is long\r\n    bytes32[] public longTakerContracts;  // and here the  lp is short\r\n    mapping(bytes32 => Subcontract) public subcontracts;\r\n    address payable internal constant BURN_ADDRESS = address(0xdead);  // address payable\r\n\r\n    struct Subcontract {\r\n        uint index;\r\n\t\taddress taker;\r\n\t\tuint takerMargin;   // in wei\r\n\t\tuint reqMargin;     // in wei\r\n        uint8 startDay;     // 0 for initial price on settlement, 1 for day after, etc, though 7 implies settlement day\r\n        bool takerCloseDisc;\r\n\t\tbool LPSide;        // true for LP long, taker Short\r\n\t\tbool isCancelled;\r\n\t\tbool takerBurned;\r\n\t\tbool LPBurned;\r\n\t\tbool takerDefaulted;\r\n        bool isActive;\r\n\t}\r\n\r\n\r\n    modifier onlyAdmin()\r\n    {\r\n        require(msg.sender == address(assetSwap));\r\n        _;\r\n    }\r\n\r\n    /** Allow the LP to change the minimum take size in their book\r\n    * @param _min the minimum take size in ETH for the book\r\n    */\r\n    function adjustMinRM(uint _min)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        minRM = _min * 1 finney;\r\n    }\r\n\r\n    /** Allow the OracleSwap admin to cancel any  subcontract\r\n    * @param subkID the subcontract to cancel\r\n    */\r\n    function adminCancel(bytes32 subkID)\r\n        public\r\n        payable\r\n        onlyAdmin\r\n    {\r\n        Subcontract storage k = subcontracts[subkID];\r\n        k.isCancelled = true;\r\n    }\r\n\r\n    /** Allow the OracleSwap admin to cancel any  subcontract\r\n    */\r\n    function adminStop()\r\n        public\r\n        payable\r\n        onlyAdmin\r\n    {\r\n        bookDefaulted = true;\r\n        LPRequiredMargin = 0;\r\n    }\r\n\r\n    /** Function to send balances back to the Assetswap contract\r\n    * @param amount the amount in wei to send\r\n    * @param recipient the address to credit the balance to\r\n    */\r\n    function balanceSend(uint amount, address recipient)\r\n        internal\r\n    {\r\n        assetSwap.balanceTransfer.value(amount)(recipient);\r\n    }\r\n\r\n    /** Burn a subcontract\r\n    * @param subkID the subcontract id\r\n    * @param sender who called the function in AssetSwap\r\n    * @param amount the message value\r\n    */\r\n    function bookBurn( bytes32 subkID, address sender, uint amount)\r\n        public\r\n        payable\r\n        onlyAdmin\r\n        returns (uint)\r\n    {\r\n        Subcontract storage k = subcontracts[subkID];\r\n        require(sender == lp || sender == k.taker, \"must by party to his subcontract\");\r\n        // cost to burn\r\n\t\tuint burnFee = k.reqMargin / BURN_DEF_FEE;\r\n\t\trequire (amount >= burnFee);\r\n\t\tif (sender == lp)\r\n\t\t    k.LPBurned = true;\r\n\t\telse\r\n\t\t    k.takerBurned = true;\r\n\t\treturn burnFee;\r\n    }\r\n\r\n     /** Cancel a subcontract\r\n    * @param lastOracleSettleTime the last settle price timestamp\r\n    * @param subkID the subcontract id\r\n    */\r\n    function bookCancel(uint lastOracleSettleTime, bytes32 subkID, address sender)\r\n        public\r\n        payable\r\n        onlyAdmin\r\n    {\r\n        Subcontract storage k = subcontracts[subkID];\r\n        require(lastOracleSettleTime < lastBookSettleTime, \"Cannot do during settle period\");\r\n\t\trequire(sender == k.taker || sender == lp, \"Canceller not LP or taker\");\r\n        require(!k.isCancelled, \"Subcontract already cancelled\");\r\n        uint fee;\r\n        fee =(k.reqMargin * CLOSE_FEE)/1e4 ;\r\n        if (k.takerCloseDisc || (sender == lp))\r\n           fee = 3 * fee / 2;\r\n\t\trequire(msg.value >= fee, \"Insufficient cancel fee\");\r\n        k.isCancelled = true;\r\n        balanceSend(msg.value - fee, sender);\r\n        balanceSend(fee, assetSwap.feeAddress());\r\n    }\r\n\r\n    /** Deposit ETH into the LP margin\r\n    * @notice the message value is directly deposited\r\n    */\r\n    function fundLPMargin()\r\n        public\r\n        payable\r\n    {\r\n        LPMargin = add(LPMargin,msg.value);\r\n    }\r\n\r\n    /** Deposit ETH into a taker's margin\r\n    * @param subkID the id of the subcontract to deposit into\r\n    * @notice the message value is directly deposited.\r\n    */\r\n    function fundTakerMargin(bytes32 subkID)\r\n        public\r\n        payable\r\n    {\r\n        Subcontract storage k = subcontracts[subkID];\r\n        require (k.reqMargin > 0);\r\n        k.takerMargin= add(k.takerMargin,msg.value);\r\n    }\r\n\r\n    /** This function returns the stored values of a subcontract\r\n    * @param subkID the subcontract id\r\n    * @return takerMargin the takers actual margin balance\r\n    * @return reqMargin the required margin for both parties for the subcontract\r\n    * @return startDay the integer value corresponding to the index (day) for retrieving prices\r\n    * @return LPSide, the side of the contract in terms of the LP, eg, true implies lp is long, taker is short\r\n    * @return takerCloseFee, as these depend on the size of the LP book when taken relative to the AssetSwap's Global_size_discout\r\n    * that distinguishes between large and small lps for this assetswap, where larger LP books have half the closing fee that\r\n    * small LP books have\r\n    *\r\n    */\r\n        function getSubkData(bytes32 subkID)\r\n        public\r\n        view\r\n        returns (uint _takerMargin, uint _reqMargin,\r\n          bool _lpside, bool isCancelled, bool isActive, uint8 _startDay)\r\n    {\r\n        Subcontract storage k = subcontracts[subkID];\r\n        _takerMargin = k.takerMargin;\r\n        _reqMargin = k.reqMargin;\r\n        _lpside = k.LPSide;\r\n        isCancelled = k.isCancelled;\r\n        isActive = k.isActive;\r\n        _startDay = k.startDay;\r\n    }\r\n\r\n\r\n    /** This function returns the stored values of a subcontract\r\n    *\r\n    */\r\n\r\n      function getSubkDetail(bytes32 subkID)\r\n        public\r\n        view\r\n        returns (bool closeDisc, bool takerBurned, bool LPBurned, bool takerDefaulted)\r\n    {\r\n        Subcontract storage k = subcontracts[subkID];\r\n        closeDisc = k.takerCloseDisc;\r\n        takerBurned = k.takerBurned;\r\n        LPBurned = k.LPBurned;\r\n        takerDefaulted = k.takerDefaulted;\r\n    }\r\n\r\n\r\n    /** if the Oracle neglects the OracleContract, any player can set the book into default by executing this function\r\n     * then all players can redeem their subcontracts\r\n     *\r\n     */\r\n\r\n     function inactiveOracle()\r\n        public\r\n        {\r\n          require(now > (lastBookSettleTime + ORACLE_MAX_ABSENCE));\r\n\r\n          bookDefaulted = true;\r\n          LPRequiredMargin = 0;\r\n        }\r\n\r\n    /** if the book was not settled, the LP is held accountable\r\n     * the first counterparty to execute this function will then get a bonus credit of their RM from the LP\r\n     * if the LP's total margin is zero, they will get whatever is there\r\n     * after the book is in default all players can redeem their subcontracts\r\n     * After a book is in default, this cannot be executed\r\n     */\r\n\r\n    function inactiveLP(uint _lastOracleSettleTime, bytes32 subkID)\r\n        public\r\n    {\r\n          require(_lastOracleSettleTime > lastBookSettleTime);\r\n          require( now > (_lastOracleSettleTime + LP_MAX_SETTLE));\r\n          require(!bookDefaulted);\r\n          Subcontract storage k = subcontracts[subkID];\r\n          uint LPfee = min(LPMargin,k.reqMargin);\r\n          uint defPay = subzero(LPRequiredMargin/2,LPfee);\r\n          LPMargin = subzero(LPMargin,add(LPfee,defPay));\r\n          k.takerMargin = add(k.takerMargin,LPfee);\r\n          bookDefaulted = true;\r\n          LPRequiredMargin = 0;\r\n    }\r\n    /** Refund the balances and remove from storage a subcontract that has been defaulted, cancelled,\r\n    * burned, or expired.\r\n    * @param subkID the id of the subcontract\r\n    * this is done separately from settlement because it requires a modest amount of gas\r\n    * and would otherwise severely reduce the number of potential long and short contracts\r\n    */\r\n    function redeemSubcontract(bytes32 subkID)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        Subcontract storage k = subcontracts[subkID];\r\n        require(!k.isActive || bookDefaulted);\r\n        uint tMargin = k.takerMargin;\r\n        if (k.takerDefaulted) {\r\n            uint defPay = k.reqMargin / BURN_DEF_FEE;\r\n            tMargin = subzero(tMargin,defPay);\r\n        BURN_ADDRESS.transfer(defPay);\r\n        }\r\n        k.takerMargin = 0;\r\n        balanceSend(tMargin, k.taker);\r\n        uint index = k.index;\r\n        if (k.LPSide) {\r\n            Subcontract storage lastShort = subcontracts[shortTakerContracts[shortTakerContracts.length - 1]];\r\n            lastShort.index = index;\r\n            shortTakerContracts[index] = shortTakerContracts[shortTakerContracts.length - 1];\r\n            shortTakerContracts.pop();\r\n        } else {\r\n            Subcontract storage lastLong = subcontracts[longTakerContracts[longTakerContracts.length - 1]];\r\n            lastLong.index = index;\r\n            longTakerContracts[index] = longTakerContracts[longTakerContracts.length - 1];\r\n            longTakerContracts.pop();\r\n        }\r\n        Subcontract memory blank;\r\n        subcontracts[subkID] = blank;\r\n    }\r\n\r\n    /** Settle the taker long sukcontracts\r\n    * @param takerLongRets the returns for a long contract for a taker for each potential startDay\r\n    * */\r\n  function settleLong(int[8] memory takerLongRets, uint topLoop)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        // long settle can only be done once at settlement\r\n       require(settleNum < longTakerContracts.length);\r\n       // settlement can only be done at least 5 days since the last settlement\r\n       require(now > lastBookSettleTime + NO_DOUBLE_SETTLES);\r\n       topLoop = min(longTakerContracts.length, topLoop);\r\n        LPRequiredMargin = add(LPLongMargin,LPShortMargin);\r\n         for (settleNum; settleNum < topLoop; settleNum++) {\r\n             settleSubcontract(longTakerContracts[settleNum], takerLongRets);\r\n        }\r\n    }\r\n\r\n    /** Settle the taker long sukcontracts\r\n    * @param takerShortRets the returns for a long contract for a taker for each potential startDay\r\n    * */\r\n function settleShort(int[8] memory takerShortRets, uint topLoop)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum >= longTakerContracts.length);\r\n        topLoop = min(shortTakerContracts.length, topLoop);\r\n        for (uint i = settleNum - longTakerContracts.length; i < topLoop; i++) {\r\n             settleSubcontract(shortTakerContracts[i], takerShortRets);\r\n        }\r\n        settleNum = topLoop + longTakerContracts.length;\r\n        \r\n        if (settleNum == longTakerContracts.length + shortTakerContracts.length) {\r\n            LPMargin = subzero(LPMargin,debitAcct);\r\n            if (LPShortMargin > LPLongMargin) LPRequiredMargin = subzero(LPShortMargin,LPLongMargin);\r\n                else LPRequiredMargin = subzero(LPLongMargin,LPShortMargin);\r\n            debitAcct = 0;\r\n            lastBookSettleTime = now;\r\n            settleNum = 0;\r\n            if (LPMargin < LPRequiredMargin) {\r\n                bookDefaulted = true;\r\n                uint defPay = min(LPMargin, LPRequiredMargin/BURN_DEF_FEE);\r\n                LPMargin = subzero(LPMargin,defPay);\r\n            }\r\n        }\r\n    }\r\n\r\n     function MarginCheck()\r\n        public\r\n        view\r\n        returns (uint playerMargin, uint bookETH)\r\n    {\r\n        playerMargin = 0;\r\n\r\n            for (uint i = 0; i < longTakerContracts.length; i++) {\r\n             Subcontract storage k = subcontracts[longTakerContracts[i]];\r\n             playerMargin = playerMargin + k.takerMargin ;\r\n            }\r\n             for (uint i = 0; i < shortTakerContracts.length; i++) {\r\n             Subcontract storage k = subcontracts[shortTakerContracts[i]];\r\n             playerMargin = playerMargin + k.takerMargin ;\r\n            }\r\n\r\n            playerMargin  = playerMargin + LPMargin;\r\n            bookETH = address(this).balance;\r\n\r\n\r\n    }\r\n\r\n      /** Internal fn to settle an individual subcontract\r\n    * @param subkID the id of the subcontract\r\n    * @param subkRets the taker returns for a contract of that position for each day of the week\r\n    */\r\n\r\n\r\n    function settleSubcontract(bytes32 subkID, int[8] memory subkRets)\r\n     internal\r\n    {\r\n        Subcontract storage k = subcontracts[subkID];\r\n        // Don't settle terminated contracts or just starting subcontracts\r\n        if (k.isActive && (k.startDay != 7)) {\r\n\r\n            uint absolutePNL;\r\n\r\n            bool lpprof;\r\n            if (subkRets[k.startDay] < 0) {\r\n                lpprof = true;\r\n                absolutePNL = uint(-1 * subkRets[k.startDay]) * k.reqMargin / 1 finney;\r\n            }\r\n            else {\r\n                absolutePNL = uint(subkRets[k.startDay]) * k.reqMargin / 1 finney;\r\n            }\r\n            absolutePNL = min(k.reqMargin,absolutePNL);\r\n            if (lpprof) {\r\n                k.takerMargin = subzero(k.takerMargin,absolutePNL);\r\n                if (!k.takerBurned) LPMargin = add(LPMargin,absolutePNL);\r\n            } else {\r\n                if (absolutePNL>LPMargin) debitAcct = add(debitAcct,subzero(absolutePNL,LPMargin));\r\n                LPMargin = subzero(LPMargin,absolutePNL);\r\n                if (!k.LPBurned) k.takerMargin = add(k.takerMargin,absolutePNL);\r\n            }\r\n            if (k.LPBurned || k.takerBurned || k.isCancelled) {\r\n                if (k.LPSide) LPLongMargin = subzero(LPLongMargin,k.reqMargin);\r\n                else LPShortMargin = subzero(LPShortMargin,k.reqMargin);\r\n                k.isActive = false;\r\n            } else if (k.takerMargin < k.reqMargin)\r\n            {\r\n                if (k.LPSide) LPLongMargin = subzero(LPLongMargin,k.reqMargin);\r\n                else LPShortMargin = subzero(LPShortMargin,k.reqMargin);\r\n                k.isActive = false;\r\n                k.takerDefaulted = true;\r\n            }\r\n        }\r\n        k.startDay = 0;\r\n    }\r\n\r\n\r\n      /** Create a new Taker long subcontract of the given parameters\r\n    * @param taker the address of the party on the other side of the contract\r\n    * @param amount the amount in ETH to create the subcontract for\r\n    * @param sizeDiscCut is level below which the taker pays a double closeing fee r\r\n    * @param startDay is the first day of the initial week used to get the starting price\r\n    * @param lastOracleSettleTime makes sure takes do not happen in settlement period\r\n    * @return subkID the id of the newly created subcontract\r\n\t*/\r\n\t function take(address taker, uint amount, uint sizeDiscCut, uint8 startDay, uint lastOracleSettleTime, bool takerLong)\r\n        public\r\n        payable\r\n        onlyAdmin\r\n        returns (bytes32 subkID)\r\n    {\r\n        require(amount * 1 finney >= minRM, \"must be greater than book min\");\r\n        require(lastOracleSettleTime < lastBookSettleTime, \"Cannot do during settle period\");\r\n        Subcontract memory order;\r\n        order.reqMargin = amount * 1 finney;\r\n        order.takerMargin = msg.value;\r\n        order.taker = taker;\r\n        order.isActive = true;\r\n        order.startDay = startDay;\r\n        if (!takerLong) order.LPSide = true;\r\n        if (takerLong) {\r\n            require(longTakerContracts.length < MAX_SUBCONTRACTS, \"bookMaxedOut\");\r\n            subkID = keccak256(abi.encodePacked(lp, now, longTakerContracts.length));  // need to add now\r\n            order.index = longTakerContracts.length;\r\n            longTakerContracts.push(subkID);\r\n            LPShortMargin = add(LPShortMargin,order.reqMargin);\r\n            if (subzero(LPShortMargin,LPLongMargin) > LPRequiredMargin)\r\n                LPRequiredMargin = subzero(LPShortMargin,LPLongMargin);\r\n            } else {\r\n            require(shortTakerContracts.length < MAX_SUBCONTRACTS, \"bookMaxedOut\");\r\n            subkID = keccak256(abi.encodePacked(shortTakerContracts.length,lp, now));  // need to add now\r\n            order.index = shortTakerContracts.length;\r\n            shortTakerContracts.push(subkID);\r\n            LPLongMargin = add(LPLongMargin,order.reqMargin);\r\n             if (subzero(LPLongMargin,LPShortMargin) > LPRequiredMargin)\r\n            LPRequiredMargin = subzero(LPLongMargin,LPShortMargin);\r\n             }\r\n        if (add(LPLongMargin,LPShortMargin) >= sizeDiscCut) order.takerCloseDisc = true;\r\n        subcontracts[subkID] = order;\r\n        return subkID;\r\n    }\r\n\r\n\r\n     /** Withdraw margin from the LP margin\r\n    * @param amount the amount of margin to move\r\n    * @param lastOracleSettleTime timestamp of the last oracle setlement time\r\n    * @notice reverts if during the settle period\r\n    */\r\n    function withdrawalLP(uint amount, uint lastOracleSettleTime)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        if (bookDefaulted) {\r\n            require (LPMargin >= amount, \"Cannot withdraw more than the margin\");\r\n        } else {\r\n            require (LPMargin >= add(LPRequiredMargin,amount),\"Cannot to w/d more than excess margin\");\r\n            require(lastOracleSettleTime < lastBookSettleTime, \"Cannot do during settle period\");\r\n        }\r\n        LPMargin = subzero(LPMargin,amount);\r\n        balanceSend(amount, lp);\r\n    }\r\n\r\n    /** Allow a taker to withdraw margin\r\n    * @param subkID the subcontract id\r\n    * @param lastOracleSettleTime the block timestamp of the last oracle settle price\r\n    * @param sender who sent this message to AssetSwap\r\n    * @notice reverts during settle period\r\n    */\r\n    function withdrawalTaker(bytes32 subkID, uint amount, uint lastOracleSettleTime, address sender)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(lastOracleSettleTime < lastBookSettleTime, \"Cannot do during settle period\");\r\n        Subcontract storage k = subcontracts[subkID];\r\n        require(k.takerMargin >= add(k.reqMargin,amount),\"must have sufficient margin\");\r\n        require(sender == k.taker, \"Must be taker to call this function\");\r\n        k.takerMargin = subzero(k.takerMargin,amount);\r\n        balanceSend(amount, k.taker);\r\n    }\r\n\r\n\r\n    /** Utility function to find the minimum of two unsigned values\r\n    * @notice returns the first parameter if they are equal\r\n    */\r\n    function min(uint a, uint b)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        if (a <= b)\r\n            return a;\r\n        else\r\n            return b;\r\n    }\r\n\r\n\r\n    function subzero(uint _a, uint _b)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        if (_b >= _a)\r\n            return 0;\r\n        else\r\n            return _a - _b;\r\n    }\r\n\r\n    function add(uint _a, uint _b)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n        {\r\n        uint c = _a + _b;\r\n        assert(c >= _a);\r\n        return c;\r\n        }\r\n\r\n}\r\n\r\n// File: browser/AssetSwap.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\ncontract AssetSwap {\r\n\r\n    /** Sets up a new SwapMarket contract\r\n    * The creator can administrate the contract, including transferring this contract to someone else\r\n    * Admin functions include executing th eWeekly Returns function used at settlement, and also adjusting target and basis RatesUpdated\r\n    * adjusting for DaylightSavings (so takers cannot take during the 4 PM hour)\r\n    *  other changes are basically for faciilitating an efficient shut down: pausing new takers, cancelling existing contracts.\r\n    * None of these variables can be altered once created\r\n    */\r\n\r\n    constructor (address priceOracle)\r\n        public\r\n    {\r\n        admins[msg.sender] = true;\r\n        feeAddress = msg.sender;\r\n        oracle = Oracle(priceOracle);\r\n    }\r\n\r\n    Oracle public oracle;\r\n\r\n    bool public _isDST;  // Daylight savings dummy, is 1 if summer\r\n    bool public _isFreeMargin; // used in intraWeek LP RM adjustment\r\n    int public _LongRate; // in hundredths of a %\r\n    int public _ShortRate; // in hundredths of a %\r\n    uint public GLOBAL_SIZE_DISC; // set by Oracle to incent Takers towards the larger LPs\r\n    uint public GLOBAL_RM_MIN;   // avoids nuisance accounts of trivial size\r\n    int public constant TOP_BASIS = 200; //Basis rate is capped on low and high end to prevent Oracle shenanigans\r\n    uint public constant MIN_SETTLE_TIME = 0 hours;  // requires at least 24 hours to pass after Oracle settlement update until book settlement can occur\r\n    uint public constant NO_TAKE_HOUR = 1;  // no takes from 4-5 PM NYC time\r\n    uint public constant TOP_TARGET = 100;  // caps Target rate to prevent Oracle mischief\r\n    uint public constant ASSET_ID = 1; // this contract's asset ID, used for referencing price array in Oracle contract\r\n    uint public constant _leverageRatio = 1000; // this translates to 10x leverage\r\n    uint public _lastWeeklyReturnsTime;\r\n    int[8] private takerLongReturns;\r\n    int[8] private takerShortReturns;\r\n    mapping(address => address) public _books;  // LP eth address to book contract address\r\n    mapping(address => uint) public _withdrawBalances;  // how ETH is ultimately withdrawn\r\n    mapping(address => bool) public admins;  // gives user right to key functions\r\n    address payable public feeAddress;   // address for oracle fees PAYABLE!!\r\n    address payable constant constant BURN_ADDRESS = address(0xdead);  // address payable\r\n\r\n\r\n    event subkTracker(\r\n        address indexed e_lp,\r\n        address indexed e_taker,\r\n        bytes32 e_subkID,\r\n        bool e_open);\r\n    event BurnHist(\r\n        address e_lp,\r\n        bytes32 e_subkID,\r\n        address e_sender,\r\n        uint e_time);\r\n    event RatesUpdated(\r\n        uint e_target,\r\n        int e_basis);\r\n    event LPNewBook(\r\n        address e_lp,\r\n        address e_lpBook);\r\n    event SizeDiscUpdated(\r\n        uint e_minLPGrossForDisc);\r\n\r\n\r\n    modifier onlyAdmin()\r\n    {\r\n        require(admins[msg.sender], \"admin only\");\r\n        _;\r\n    }\r\n\r\n    /** Grant administrator priviledges to a user\r\n    * @param newAdmin the address to promote\r\n    */\r\n    function addAdmin(address newAdmin)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        admins[newAdmin] = true;\r\n    }\r\n\r\n    /* hour of day is used for cutting off when takers can take, when LPs can withdraw.\r\n    Time is based on New York City, USA ET, which has daylight savings, so this is needed\r\n    */\r\n     function adjDST(bool _isDaylightSav)\r\n        public\r\n        onlyAdmin\r\n    {\r\n       _isDST = _isDaylightSav;\r\n    }\r\n\r\n     /* This parameter puts a floor on the size of subcontracts, and can be used\r\n     to prevent new takes by setting it at absurdly high levels\r\n    */\r\n     function adjRMMin(uint _RMMin)\r\n        public\r\n        onlyAdmin\r\n    {\r\n       GLOBAL_RM_MIN = _RMMin;\r\n    }\r\n\r\n       /* this prevents edge cases where an LP might not have enough RM to cover\r\n       its liabilities. It should only be invoked when there is a price change\r\n       implying PNLs greater than the RM intraweek, and should be reset to false at\r\n       the subsequent settlement update\r\n    */\r\n     function adjisFreeMargin(bool _freeMargin)\r\n        public\r\n        onlyAdmin\r\n    {\r\n       _isFreeMargin = _freeMargin;\r\n    }\r\n\r\n     /** Allow the LP to change the minimum take size in their book\r\n    * @param _min the minimum take size in ETH for the book\r\n    */\r\n    function adjustMinRM(uint _min)\r\n        public\r\n    {\r\n        require (_books[msg.sender] != address(0), \"User must have a book\");\r\n        require (_min > GLOBAL_RM_MIN);\r\n        Book b = Book(_books[msg.sender]);\r\n        b.adjustMinRM(_min);\r\n    }\r\n\r\n    /* the Oracle/admin may cancel all outstanding contracts, say if the contract was being deprecated.\r\n    Such a cancel generates no fees, and just terminates the subcontracts at the next settlement\r\n    */\r\n    function adminCancel(address _lp, bytes32 subkID)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        Book b = Book(_books[_lp]);\r\n        b.adminCancel(subkID);\r\n    }\r\n\r\n       /* the Oracle/admin may cancel all outstanding contracts, say if the contract was being deprecated.\r\n    Such a cancel generates no fees, and just terminates the subcontracts at the next settlement\r\n    */\r\n    function adminKill(address _lp)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        Book b = Book(_books[_lp]);\r\n        b.adminStop();\r\n    }\r\n\r\n      /** Credit a users balance with the message value\r\n    * @param recipient the user to get balance\r\n    * @dev used by the Book when it needs to give players value\r\n    */\r\n    function balanceTransfer(address recipient)\r\n        public\r\n        payable\r\n    {\r\n        _withdrawBalances[recipient] = add(_withdrawBalances[recipient],msg.value);\r\n    }\r\n\r\n    /** Change the address that can withdraw the collected fees\r\n    * @param newAddress the new address to change to\r\n    */\r\n    function changeFeeAddress(address payable newAddress)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        feeAddress = newAddress;\r\n    }\r\n\r\n    /** Allow the LP to create a new book\r\n     * @param _min is the minimum take size in ETH\r\n     * @return newBook the address of the lp book\r\n    */\r\n        function createBook(uint _min)\r\n        public\r\n        payable\r\n        returns (address newBook)\r\n    {\r\n        require (_books[msg.sender] == address(0), \"User must not have a preexisting book\");\r\n        require (msg.value >= _min * 2 finney, \"Must prep for 2-sided book\");\r\n        _books[msg.sender] = address(new Book(msg.sender, address(this), _min));\r\n        Book b = Book(_books[msg.sender]);\r\n        b.fundLPMargin.value(msg.value)();\r\n        emit LPNewBook(msg.sender, _books[msg.sender]);\r\n        return _books[msg.sender];\r\n    }\r\n\r\n        /**\r\n    * @param _lp the lp who owns the book\r\n    * @return book the address of the lp book\r\n    * @return lpMargin the lp's current margin\r\n    * @return totalLong the total RM of all long contracts the LP is engaged in\r\n    * @return totalShort the total RM of all short contracts the LP is engaged in\r\n    * @return lpRM the margin required for the LP\r\n    * @return numLongTakerKs the number of taker long subcontracts that the lp has in their book\r\n    * @return numShortTakerKs the number of taker short subcontracts that the lp has in their book\r\n    * @return bookMinimum the minimum size in wei to make a subcontract with this book\r\n    * @return bookDefaulted if the book is defaulted\r\n    * @return settle1done to tell LP they can now run settlement on their shorts\r\n    */\r\n    function getBookData(address _lp)\r\n        public\r\n        view\r\n        returns (address _book,\r\n            uint _lpMargin,\r\n            uint _totalLpLong,\r\n            uint _totalLpShort,\r\n            uint _lpRM,\r\n            uint _bookMinimum,\r\n            uint _lastBookSettleTime,\r\n            uint _settleNum,\r\n            bool _bookDefaulted\r\n            )\r\n    {\r\n            _book = _books[_lp];\r\n            Book b = Book(_book);\r\n            _lpMargin = b.LPMargin();\r\n            _totalLpLong = b.LPLongMargin();\r\n            _totalLpShort = b.LPShortMargin();\r\n            _lpRM = b.LPRequiredMargin();\r\n            _bookMinimum = b.minRM();\r\n            _lastBookSettleTime = b.lastBookSettleTime();\r\n            _settleNum = b.settleNum();\r\n            _bookDefaulted = b.bookDefaulted();\r\n    }\r\n\r\n    /** Function to easily get specific take information about a subcontract\r\n    * @param _lp the address of the lp with the subcontract\r\n    * @param subkID the id of the subcontract\r\n    * @return takerMargin the taker's margin\r\n    * @return reqMargin the required margin of the subcontract\r\n    * @return startDay the day of the week the contract was started on\r\n    * @return lpSide the LP's side for the contract\r\n    * @return takerCloseDiscount if the takers close fee will be lowered\r\n    */\r\n\r\n\r\n    function getSubcontractData(address _lp, bytes32 subkID)\r\n        public\r\n        view\r\n        returns (\r\n            uint _takerMargin,\r\n            uint _reqMargin,\r\n            bool _lpSide,\r\n            bool _isCancelled,\r\n            bool _isActive,\r\n            uint8 _startDay)\r\n    {\r\n        address book = _books[_lp];\r\n        if (book != address(0)) {\r\n            Book b = Book(book);\r\n            (_takerMargin, _reqMargin, _lpSide, _isCancelled, _isActive, _startDay) = b.getSubkData(subkID);\r\n        }\r\n    }\r\n\r\n      /** Function to get specific status information about a subcontract\r\n    * @param _lp the address of the lp with the subcontract\r\n    * @param subkID the id of the subcontract\r\n    * @return isCancelled the status of if the subcontract is cancelled\r\n    * @return takerBurned the status of if the subcontract is burned by taker\r\n    * @return lpBurned the status of if the subcontract is burned by LP\r\n    * @return takerDefaulted the status of if the taker Defaulted, and so the contract is dead and the taker should redeem it to get whatever marginis remaiing\r\n    * @return isActive if the subcontract is redeemable or is involved in settlement\r\n    */\r\n\r\n    function getSubcontractStatus(address _lp, bytes32 subkID)\r\n        public\r\n        view\r\n        returns (\r\n            bool _closeDisc,\r\n            bool _takerBurned,\r\n            bool _lpBurned,\r\n            bool _takerDefaulted)\r\n    {\r\n        address book = _books[_lp];\r\n        if (book != address(0)) {\r\n            Book b = Book(book);\r\n            (_closeDisc, _takerBurned, _lpBurned, _takerDefaulted) = b.getSubkDetail(subkID);\r\n        }\r\n    }\r\n\r\n     function getBookBalance(address _lp)\r\n        public\r\n        view\r\n        returns (\r\n            uint playerMargin,\r\n            uint bookETH\r\n            )\r\n    {\r\n        address book = _books[_lp];\r\n        if (book != address(0)) {\r\n            Book b = Book(book);\r\n            (playerMargin, bookETH) = b.MarginCheck();\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /** Function to get specific status information about a subcontract\r\n\r\n\r\n    function getSubcontractStatus(address _lp, bytes32 subkID)\r\n        public\r\n        view\r\n        returns (\r\n            bool isCancelled,\r\n            bool takerBurned,\r\n            bool lpBurned,\r\n            bool takerDefaulted,\r\n            bool isActive)\r\n    {\r\n        address book = _books[_lp];\r\n        if (book != address(0)) {\r\n            Book b = Book(book);\r\n            (isCancelled, takerBurned, lpBurned, takerDefaulted, isActive) = b.getSubkStatus(subkID);\r\n        }\r\n    }\r\n    */\r\n\r\n     /** Adds value to the lp's margin for their whole book\r\n    * @param _lp the address of the lp to add margin to\r\n    */\r\n    function lpFund(address _lp)\r\n        public\r\n        payable\r\n    {\r\n        require(msg.sender == _lp);\r\n        require(_books[_lp] != address(0));\r\n        Book b = Book(_books[_lp]);\r\n        b.fundLPMargin.value(msg.value)();\r\n    }\r\n\r\n    /** Burn a specific subcontract at a cost\r\n    * @param _lp the address of the LP with the subcontract\r\n    * @param subkID the id of the subcontract to burn\r\n    */\r\n    function burn(address _lp, bytes32 subkID)\r\n        public\r\n        payable\r\n    {\r\n        Book b = Book(_books[_lp]);\r\n        uint fee = b.bookBurn(subkID, msg.sender, msg.value);\r\n        if (msg.value > fee) {\r\n            BURN_ADDRESS.transfer(fee);\r\n            _withdrawBalances[msg.sender] = add(_withdrawBalances[msg.sender],msg.value - fee);\r\n            emit BurnHist(_lp, subkID, msg.sender, now);\r\n         }\r\n    }\r\n\r\n    /** Sets the contract to terminate at the end of the week\r\n    * @param _lp the address of the lp with the subcontract\r\n    * @param subkID the id of the subcontract to cancel\r\n    */\r\n    function cancel(address _lp, bytes32 subkID)\r\n        public\r\n        payable\r\n    {\r\n        Book b = Book(_books[_lp]);\r\n        uint lastSettleTime = oracle.getLastSettleTime(ASSET_ID);\r\n        b.bookCancel.value(msg.value)(lastSettleTime, subkID, msg.sender);\r\n    }\r\n    /** sets the LP book into default after 9 days of no Oracle settlement price\r\n    * @param _lp the address of the lp with the subcontract\r\n    */\r\n    function inactiveOracle(address _lp)\r\n        public\r\n    {\r\n        require(_books[_lp] != address(0));\r\n        Book b = Book(_books[_lp]);\r\n        b.inactiveOracle();\r\n    }\r\n    /** sets the LP book into default if  of no Oracle settlement price\r\n    * @param _lp the address of the lp with the subcontract\r\n    */\r\n     function inactiveLP(address _lp, bytes32 subkID)\r\n        public\r\n    {\r\n        require(_books[_lp] != address(0));\r\n        Book b = Book(_books[_lp]);\r\n        uint lastSettleTime = oracle.getLastSettleTime(ASSET_ID);\r\n        b.inactiveLP(lastSettleTime, subkID);\r\n    }\r\n    /** Refund the balances and remove from storage a subcontract that has been defaulted, cancelled,\r\n    * burned, or expired.\r\n    * @param _lp is the AssetSwap contracts identifier of the LP's book\r\n    * @param subkID the id of the subcontract with the LP's book contract\r\n    */\r\n\r\n    function redeem(address _lp, bytes32 subkID)\r\n        public\r\n    {\r\n        require(_books[_lp] != address(0));\r\n        Book b = Book(_books[_lp]);\r\n        b.redeemSubcontract(subkID);\r\n        emit subkTracker(_lp, msg.sender, subkID, false);\r\n    }\r\n\r\n    /** Remove administrator priviledges from a user\r\n    * @param toRemove the address to demote\r\n    * @notice you may not remove yourself\r\n    */\r\n    function removeAdmin(address toRemove)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(toRemove != msg.sender, \"You may not remove yourself as an admin.\");\r\n        admins[toRemove] = false;\r\n    }\r\n\r\n      function setSizeDiscCut(uint sizeDiscCut)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        // sets the cutoff that determines takers pay 2x to close\r\n        GLOBAL_SIZE_DISC = sizeDiscCut * 1 finney;\r\n        emit SizeDiscUpdated(sizeDiscCut);\r\n    }\r\n\r\n     /** Adjust the Long and Short rates for all contracts\r\n    * @param target the new target rate in hundredths of a percent\r\n    * @param basis the new basis rate in hundredths of a percent\r\n    * @dev the \"long rate\" is target - basis, the \"short rate\" is target + basis\r\n    * @dev the new rates won't go into effect until the following week after WeeklyReturns is called\r\n    */\r\n\r\n    function setRates(uint target, int basis)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        // target between 0 and 1 % per week\r\n        // basis between -2 and 2 % per week\r\n        // not allowed on Settlement Day, which is tthe 24 hours from settlement price update to the next price update\r\n        require(target <= TOP_TARGET, \"Target must be between 0 and 1%\");\r\n        require(-TOP_BASIS <= basis && basis <= TOP_BASIS, \"Basis must be between -2 and 2%\");\r\n        require(!oracle.isSettleDay(ASSET_ID));\r\n        _LongRate = int(target) + basis;\r\n        _ShortRate = int(target) - basis;\r\n        emit RatesUpdated(target, basis);\r\n    }\r\n\r\n    /** Settle subcontracts for this lp\r\n    * @param _lp the lp to settle\r\n    * must be done twice. first with the bool set to true (long takers), then with the bool set to false (short takers)\r\n    */\r\n\r\n    function settle(address _lp, bool _settleLong, uint _topLoop)\r\n        public\r\n    {\r\n        require(_books[_lp] != address(0));\r\n        Book b = Book(_books[_lp]);\r\n        // can only be run on settlement day, if missed all subcontracts can redeem\r\n         require(oracle.isSettleDay(ASSET_ID));\r\n        uint _lastSettle = oracle.getLastSettleTime(ASSET_ID);\r\n        // must use WeeklyReturns that used recent Settlement prices\r\n        require(_lastWeeklyReturnsTime > _lastSettle);\r\n         // must wait at least 24 hours from the Oracle update\r\n        require (now > _lastSettle + MIN_SETTLE_TIME, \"Give players more time\");\r\n        if (_settleLong) b.settleLong(takerLongReturns, _topLoop); else b.settleShort(takerShortReturns, _topLoop);\r\n    }\r\n\r\n    /** Adds value to the taker's margin\r\n    * @param _lp the address of the lp with the subcontract\r\n    * @param subkID the id of the subcontract to add margin to\r\n    */\r\n    function takerFund(address _lp, bytes32 subkID)\r\n        public\r\n        payable\r\n    {\r\n        require(_books[_lp] != address(0));\r\n        Book b = Book(_books[_lp]);\r\n        b.fundTakerMargin.value(msg.value)(subkID);\r\n    }\r\n\r\n    /** Take a new subcontract with an LP\r\n    * @param _lp the LP to take from\r\n    * @param amount the amount IN finney to set the RM of the subcontract\r\n    */\r\n    function take(address _lp, uint amount, bool isTakerLong)\r\n        public\r\n        payable\r\n    {\r\n        require(msg.value >= amount * (1 finney), \"Insuffient ETH for this RM\"); // allow only whole number amounts\r\n        require(hourOfDay() != NO_TAKE_HOUR, \"Cannot take during 4 PM ET hour\");  // cannot take from 4-5 PM ET   16\r\n        require(amount > GLOBAL_RM_MIN);\r\n        Book book = Book(_books[_lp]);\r\n        uint lpLong = book.LPLongMargin();\r\n        uint lpShort = book.LPShortMargin();\r\n        uint freeMargin = 0;\r\n        uint8 startDay = oracle.getStartDay(ASSET_ID);\r\n        uint lastOracleSettleTime = oracle.getLastSettleTime(ASSET_ID);\r\n        if (_isFreeMargin) {\r\n        if (isTakerLong) freeMargin = subzero(lpLong,lpShort);\r\n        else freeMargin = subzero(lpShort,lpLong);\r\n        }\r\n        require(amount * 1 finney <= subzero(book.LPMargin(),book.LPRequiredMargin())/2 + freeMargin, \"RM to large for this LP on this side\");\r\n        bytes32 newsubkID = book.take.value(msg.value)(msg.sender, amount, GLOBAL_SIZE_DISC, startDay, lastOracleSettleTime, isTakerLong);\r\n        emit subkTracker(_lp, msg.sender, newsubkID,true);\r\n    }\r\n\r\n\r\n//    Upon the Oracle Settlement Update, the weekly returns are calculated so that LPs can settle their _books\r\n//    There is a minimum amount of time between the Oracle Contract update and the calculation of the Weekly Returns to give players\r\n//    time to burn their PNLs if the Oracle applies fraudulent prices\r\n    function weeklyReturns()\r\n        public\r\n        onlyAdmin\r\n    {\r\n        // only compute returns after settle price posted\r\n       require(oracle.isSettleDay(ASSET_ID));\r\n\r\n        uint[8] memory assetPrice  = oracle.getPrices(ASSET_ID);\r\n        uint[8] memory ethPrice = oracle.getPrices(0);\r\n\r\n        for (uint i = 0; i < 7; i++)\r\n        {\r\n            if (assetPrice[i] == 0 || ethPrice[i] == 0) continue;\r\n            int assetReturn = int((assetPrice[7] * (1 finney)) / assetPrice[i] ) - 1 finney;\r\n            takerLongReturns[i] = assetReturn - ((1 finney) * int(_LongRate))/1e4;\r\n            takerShortReturns[i] = (-1 * assetReturn) - ((1 finney) * int(_ShortRate))/1e4;\r\n            takerLongReturns[i] = (takerLongReturns[i] * int(_leverageRatio * ethPrice[i]))/int(ethPrice[7] * 100);\r\n            takerShortReturns[i] = (takerShortReturns[i] * int(_leverageRatio * ethPrice[i]))/int(ethPrice[7] * 100);\r\n        }\r\n         _lastWeeklyReturnsTime = now;\r\n\r\n    }\r\n\r\n\r\n\r\n    /** Moves value out of the lp margin into the withdraw balance\r\n    * @param amount the amount to move in wei\r\n    */\r\n    function withdrawalLP(uint amount)\r\n        public\r\n    {\r\n        require(_books[msg.sender] != address(0));\r\n        Book b = Book(_books[msg.sender]);\r\n        uint lastOracleSettleTime= oracle.getLastSettleTime(ASSET_ID);\r\n        // Will revert if during settle period, oraclesettle after last Book settle time\r\n        b.withdrawalLP(amount, lastOracleSettleTime);\r\n    }\r\n\r\n    /** Moves value out of the taker margin into the withdraw balance\r\n    * @param amount the amount to move in wei\r\n    * @param _lp the lp with the subcontract to move balance from the taker margin\r\n    * @param subkID the id of the subcontract\r\n    */\r\n    function withdrawalTaker(uint amount, address _lp, bytes32 subkID)\r\n        public\r\n    {\r\n        require(_books[_lp] != address(0));\r\n        Book b = Book(_books[_lp]);\r\n        uint lastOracleSettleTime = oracle.getLastSettleTime(ASSET_ID);\r\n        // will revert if during settle period\r\n        b.withdrawalTaker(subkID, amount, lastOracleSettleTime, msg.sender);\r\n    }\r\n\r\n    /** Sends the owed balance to a user stored on this contract to an external address\r\n    */\r\n    function withdrawBalance()\r\n        public\r\n    {\r\n        uint amount = _withdrawBalances[msg.sender];\r\n        _withdrawBalances[msg.sender] = 0;\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    /** we do not want users taking in the 16 hour (4 PM) because there is a slight delay in between when\r\n    *  the price is recorded and poosted, so we do not want takers to exploit this option\r\n    *  @return hour1 of NYC time\r\n     */\r\n    function hourOfDay()\r\n        public\r\n        view\r\n        returns(uint hour1)\r\n    {\r\n        hour1= (now  % 86400) / 3600 - 5;\r\n        if (_isDST) hour1=hour1 + 1;\r\n    }\r\n    /**\r\n     * truncated subtraction, where result <0 is set to 0\r\n    */\r\n\r\n    function subzero(uint _a, uint _b)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        if (_b >= _a) {\r\n        return 0;\r\n    }\r\n        return _a - _b;\r\n    }\r\n    /**\r\n    * adding and protecting against overflow errors\r\n    */\r\n\r\n    function add(uint _a, uint _b)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        uint c = _a + _b;\r\n        assert(c >= _a);\r\n        return c;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"_leverageRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"subkID\",\"type\":\"bytes32\"}],\"name\":\"takerFund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toRemove\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"subkID\",\"type\":\"bytes32\"}],\"name\":\"getSubcontractData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_takerMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reqMargin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_lpSide\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isCancelled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"_startDay\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"}],\"name\":\"getBookBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"playerMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bookETH\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeFeeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isDaylightSav\",\"type\":\"bool\"}],\"name\":\"adjDST\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_SETTLE_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_settleLong\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_topLoop\",\"type\":\"uint256\"}],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawalLP\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sizeDiscCut\",\"type\":\"uint256\"}],\"name\":\"setSizeDiscCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_withdrawBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"subkID\",\"type\":\"bytes32\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_books\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_min\",\"type\":\"uint256\"}],\"name\":\"adjustMinRM\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"subkID\",\"type\":\"bytes32\"}],\"name\":\"inactiveLP\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_ShortRate\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hourOfDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hour1\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_LongRate\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract Oracle\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"subkID\",\"type\":\"bytes32\"}],\"name\":\"adminCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"balanceTransfer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GLOBAL_SIZE_DISC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"subkID\",\"type\":\"bytes32\"}],\"name\":\"withdrawalTaker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NO_TAKE_HOUR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ASSET_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"subkID\",\"type\":\"bytes32\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"}],\"name\":\"inactiveOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"basis\",\"type\":\"int256\"}],\"name\":\"setRates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"}],\"name\":\"lpFund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_isFreeMargin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_min\",\"type\":\"uint256\"}],\"name\":\"createBook\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newBook\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_isDST\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"subkID\",\"type\":\"bytes32\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOP_TARGET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isTakerLong\",\"type\":\"bool\"}],\"name\":\"take\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_freeMargin\",\"type\":\"bool\"}],\"name\":\"adjisFreeMargin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"}],\"name\":\"adminKill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_lastWeeklyReturnsTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOP_BASIS\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_RMMin\",\"type\":\"uint256\"}],\"name\":\"adjRMMin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"subkID\",\"type\":\"bytes32\"}],\"name\":\"getSubcontractStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_closeDisc\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_takerBurned\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_lpBurned\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_takerDefaulted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GLOBAL_RM_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"weeklyReturns\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"}],\"name\":\"getBookData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_book\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lpMargin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalLpLong\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalLpShort\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpRM\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bookMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastBookSettleTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_settleNum\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_bookDefaulted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"priceOracle\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"e_lp\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"e_taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"e_subkID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"e_open\",\"type\":\"bool\"}],\"name\":\"subkTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"e_lp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"e_subkID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"e_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"e_time\",\"type\":\"uint256\"}],\"name\":\"BurnHist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"e_target\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"e_basis\",\"type\":\"int256\"}],\"name\":\"RatesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"e_lp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"e_lpBook\",\"type\":\"address\"}],\"name\":\"LPNewBook\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"e_minLPGrossForDisc\",\"type\":\"uint256\"}],\"name\":\"SizeDiscUpdated\",\"type\":\"event\"}]","ContractName":"AssetSwap","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001bBC92bDF7cE2bA8E2cAd9c5cEcDBB2eb5a8D968","Library":"","LicenseType":"None","SwarmSource":"bzzr://78b6dd0016fcb2e0c48936fb09697ec12b7c9e8f3257ee1010a5da2c5218d017"}]}