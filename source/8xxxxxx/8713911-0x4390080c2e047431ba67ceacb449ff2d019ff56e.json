{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/* Interface for ERC20 Tokens */\r\ncontract Token {\r\n    bytes32 public standard;\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    uint8 public decimals;\r\n    bool public allowTransactions;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n}\r\n\r\n/* Interface for the DMEX base contract */\r\ncontract DMEX_Base {\r\n    function getReserve(address token, address user) returns (uint256);\r\n    function setReserve(address token, address user, uint256 amount) returns (bool);\r\n\r\n    function availableBalanceOf(address token, address user) returns (uint256);\r\n    function balanceOf(address token, address user) returns (uint256);\r\n\r\n\r\n    function setBalance(address token, address user, uint256 amount) returns (bool);\r\n    function getAffiliate(address user) returns (address);\r\n    function getInactivityReleasePeriod() returns (uint256);\r\n    function getMakerTakerBalances(address token, address maker, address taker) returns (uint256[4]);\r\n\r\n    function getEtmTokenAddress() returns (address);\r\n\r\n    function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) returns (bool);\r\n    function subBalanceSubReserve(address token, address user, uint256 subBalance, uint256 subReserve) returns (bool);\r\n    function addBalanceSubReserve(address token, address user, uint256 addBalance, uint256 subReserve) returns (bool);\r\n    \r\n}\r\n\r\n\r\n\r\n// The DMEX Futures Contract\r\ncontract Exchange {\r\n    function assert(bool assertion) pure {\r\n        \r\n        if (!assertion) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    // Safe Multiply Function - prevents integer overflow \r\n    function safeMul(uint a, uint b) pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    // Safe Subtraction Function - prevents integer overflow \r\n    function safeSub(uint a, uint b) pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    // Safe Addition Function - prevents integer overflow \r\n    function safeAdd(uint a, uint b) pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n    address public owner; // holds the address of the contract owner\r\n\r\n    // Event fired when the owner of the contract is changed\r\n    event SetOwner(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // Allows only the owner of the contract to execute the function\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    // Allows only the owner of the contract to execute the function\r\n    modifier onlyOracle {\r\n        assert(msg.sender == DmexOracleContract);\r\n        _;\r\n    }\r\n\r\n    // Changes the owner of the contract\r\n    function setOwner(address newOwner) onlyOwner {\r\n        emit SetOwner(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    // Owner getter function\r\n    function getOwner() view returns (address out) {\r\n        return owner;\r\n    }\r\n\r\n    mapping (address => bool) public admins;                    // mapping of admin addresses\r\n    mapping (address => bool) public pools;                     // mapping of liquidity pool addresses\r\n    mapping (address => uint256) public lastActiveTransaction;  // mapping of user addresses to last transaction block\r\n    mapping (bytes32 => uint256) public orderFills;             // mapping of orders to filled qunatity\r\n    mapping (bytes32 => mapping(uint256 => uint256)) public assetPrices; // mapping of assetHashes to block numbers to prices\r\n\r\n\r\n    address public feeAccount;          // the account that receives the trading fees\r\n    address public exchangeContract;    // the address of the main DMEX_Base contract\r\n    address public DmexOracleContract;    // the address of the DMEX math contract used for some calculations\r\n\r\n    uint256 public makerFee;            // maker fee in percent expressed as a fraction of 1 ether (0.1 ETH = 10%)\r\n    uint256 public takerFee;            // taker fee in percent expressed as a fraction of 1 ether (0.1 ETH = 10%)\r\n    \r\n    struct FuturesAsset {\r\n        string name;                    // the name of the traded asset (ex. ETHUSD)\r\n        address baseToken;              // the token for collateral\r\n        string priceUrl;                // the url where the price of the asset will be taken for settlement\r\n        string pricePath;               // price path in the returned JSON from the priceUrl (ex. path \"last\" will return tha value last from the json: {\"high\": \"156.49\", \"last\": \"154.31\", \"timestamp\": \"1556522201\", \"bid\": \"154.22\", \"vwap\": \"154.65\", \"volume\": \"25578.79138868\", \"low\": \"152.33\", \"ask\": \"154.26\", \"open\": \"152.99\"})\r\n        bool disabled;                  // if true, the asset cannot be used in contract creation (when price url no longer valid)\r\n        uint256 maintenanceMargin;      // the maintenance margin 1e8\r\n        uint256 decimals;               // number of decimals in the price\r\n    }\r\n\r\n    function createFuturesAsset(string name, address baseToken, string priceUrl, string pricePath, uint256 maintenanceMargin, uint256 decimals) onlyAdmin returns (bytes32)\r\n    {    \r\n        bytes32 futuresAsset = keccak256(this, name, baseToken, priceUrl, pricePath, maintenanceMargin, decimals);\r\n        if (futuresAssets[futuresAsset].disabled) throw; // asset already exists and is disabled\r\n\r\n        futuresAssets[futuresAsset] = FuturesAsset({\r\n            name                : name,\r\n            baseToken           : baseToken,\r\n            priceUrl            : priceUrl,\r\n            pricePath           : pricePath,\r\n            disabled            : false,\r\n            maintenanceMargin   : maintenanceMargin,\r\n            decimals            : decimals\r\n        });\r\n\r\n        emit FuturesAssetCreated(futuresAsset, name, baseToken, priceUrl, pricePath);\r\n        return futuresAsset;\r\n    }\r\n    \r\n    struct FuturesContract {\r\n        bytes32 asset;                  // the hash of the underlying asset object\r\n        uint256 expirationBlock;        // futures contract expiration block\r\n        uint256 closingPrice;           // the closing price for the futures contract\r\n        bool closed;                    // is the futures contract closed (0 - false, 1 - true)c\r\n        bool broken;                    // if someone has forced release of funds the contract is marked as broken and can no longer close positions (0-false, 1-true)\r\n        uint256 multiplier;             // the multiplier price, normally the ETHUSD price * 1e8\r\n        uint256 fundingRate;            // funding rate expressed as proportion per block * 1e18\r\n        uint256 closingBlock;           // the block in which the contract was closed\r\n        bool perpetual;                 // true if contract is perpetual\r\n    }\r\n\r\n    function createFuturesContract(bytes32 asset, uint256 expirationBlock, uint256 multiplier, uint256 fundingRate, bool perpetual) onlyAdmin returns (bytes32)\r\n    {    \r\n        bytes32 futuresContract = keccak256(this, asset, expirationBlock, multiplier, fundingRate, perpetual);\r\n        if (futuresContracts[futuresContract].expirationBlock > 0) return futuresContract; // contract already exists\r\n\r\n        futuresContracts[futuresContract] = FuturesContract({\r\n            asset           : asset,\r\n            expirationBlock : expirationBlock,\r\n            closingPrice    : 0,\r\n            closed          : false,\r\n            broken          : false,\r\n            multiplier      : multiplier,\r\n            fundingRate     : fundingRate,\r\n            closingBlock    : 0,\r\n            perpetual       : perpetual\r\n        });\r\n\r\n        emit FuturesContractCreated(futuresContract, asset, expirationBlock, multiplier);\r\n\r\n        return futuresContract;\r\n    }\r\n\r\n    function getContractExpiration (bytes32 futuresContractHash) view returns (uint256)\r\n    {\r\n        return futuresContracts[futuresContractHash].expirationBlock;\r\n    }\r\n\r\n    function getContractClosed (bytes32 futuresContractHash) returns (bool)\r\n    {\r\n        return futuresContracts[futuresContractHash].closed;\r\n    }\r\n\r\n    function getAssetDecimals (bytes32 futuresContractHash) returns (uint256)\r\n    {\r\n        return futuresAssets[futuresContracts[futuresContractHash].asset].decimals;\r\n    }\r\n\r\n    function assetPriceUrl (bytes32 assetHash) public view returns (string)\r\n    {\r\n        return futuresAssets[assetHash].priceUrl;\r\n    }\r\n\r\n    function assetPricePath (bytes32 assetHash) public view returns (string)\r\n    {\r\n        return futuresAssets[assetHash].pricePath;\r\n    }\r\n\r\n    function assetDecimals (bytes32 assetHash) returns (uint256)\r\n    {\r\n        return futuresAssets[assetHash].decimals;\r\n    }\r\n\r\n    function getContractPriceUrl (bytes32 futuresContractHash) returns (string)\r\n    {\r\n        return futuresAssets[futuresContracts[futuresContractHash].asset].priceUrl;\r\n    }\r\n\r\n    function getContractPricePath (bytes32 futuresContractHash) returns (string)\r\n    {\r\n        return futuresAssets[futuresContracts[futuresContractHash].asset].pricePath;\r\n    }\r\n\r\n    function getMaintenanceMargin (bytes32 futuresContractHash) returns (uint256)\r\n    {\r\n        return futuresAssets[futuresContracts[futuresContractHash].asset].maintenanceMargin;\r\n    }\r\n\r\n    function setClosingPrice (bytes32 futuresContractHash, uint256 price) onlyOracle returns (bool) {\r\n        if (futuresContracts[futuresContractHash].closingPrice != 0) revert();\r\n        futuresContracts[futuresContractHash].closingPrice = price;\r\n        futuresContracts[futuresContractHash].closed = true;\r\n        futuresContracts[futuresContractHash].closingBlock = min(block.number,futuresContracts[futuresContractHash].expirationBlock);\r\n\r\n        return true;\r\n    }\r\n\r\n    function recordLatestAssetPrice (bytes32 futuresContractHash, uint256 price) onlyOracle returns (bool) {\r\n        assetPrices[futuresContracts[futuresContractHash].asset][block.number] = price;\r\n    }\r\n\r\n    mapping (bytes32 => FuturesAsset)       public futuresAssets;      // mapping of futuresAsset hash to FuturesAsset structs\r\n    mapping (bytes32 => FuturesContract)    public futuresContracts;   // mapping of futuresContract hash to FuturesContract structs\r\n    mapping (bytes32 => uint256)            public positions;          // mapping of user addresses to position hashes to position\r\n\r\n\r\n    enum Errors {\r\n        /*  0 */INVALID_PRICE,                 \r\n        /*  1 */INVALID_SIGNATURE,              \r\n        /*  2 */ORDER_ALREADY_FILLED,           \r\n        /*  3 */GAS_TOO_HIGH,                  \r\n        /*  4 */OUT_OF_BALANCE,                 \r\n        /*  5 */FUTURES_CONTRACT_EXPIRED,       \r\n        /*  6 */FLOOR_OR_CAP_PRICE_REACHED,     \r\n        /*  7 */POSITION_ALREADY_EXISTS,        \r\n        /*  8 */UINT48_VALIDATION,              \r\n        /*  9 */FAILED_ASSERTION,               \r\n        /* 10 */NOT_A_POOL,\r\n        /* 11 */POSITION_EMPTY,\r\n        /* 12 */OLD_CONTRACT_OPEN,\r\n        /* 13 */OLD_CONTRACT_IN_RANGE,\r\n        /* 14 */NEW_CONTRACT_NOT_FOUND,\r\n        /* 15 */DIFF_EXPIRATIONS,\r\n        /* 16 */DIFF_ASSETS,\r\n        /* 17 */WRONG_RANGE,\r\n        /* 18 */IDENTICAL_CONTRACTS,\r\n        /* 19 */USER_NOT_IN_PROFIT,\r\n        /* 20 */WRONG_MULTIPLIER,\r\n        /* 21 */USER_POSITION_GREATER,\r\n        /* 22 */WRONG_FUNDING_RATE,\r\n        /* 23 */MUST_BE_LIQUIDATED,\r\n        /* 24 */LIQUIDATION_PRICE_NOT_TOUCHED\r\n    }\r\n\r\n    event FuturesTrade(bool side, uint256 size, uint256 price, bytes32 indexed futuresContract, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\r\n    event FuturesPositionClosed(bytes32 indexed positionHash, uint256 closingPrice);\r\n    event FuturesForcedRelease(bytes32 indexed futuresContract, bool side, address user);\r\n    event FuturesAssetCreated(bytes32 indexed futuresAsset, string name, address baseToken, string priceUrl, string pricePath);\r\n    event FuturesContractCreated(bytes32 indexed futuresContract, bytes32 asset, uint256 expirationBlock, uint256 multiplier);\r\n    event PositionLiquidated(bytes32 indexed positionHash, uint256 price);\r\n    event FuturesMarginAdded(address indexed user, bytes32 indexed futuresContract, bool side, uint64 marginToAdd);\r\n \r\n    // Fee change event\r\n    event FeeChange(uint256 indexed makerFee, uint256 indexed takerFee);\r\n\r\n    // Log event, logs errors in contract execution (for internal use)\r\n    event LogError(uint8 indexed errorId, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\r\n    //event LogErrorLight(uint8 errorId);\r\n    event LogUint(uint8 id, uint256 value);\r\n    event LogBytes(uint8 id, bytes32 value);\r\n    //event LogBool(uint8 id, bool value);\r\n    //event LogAddress(uint8 id, address value);\r\n\r\n\r\n    // Constructor function, initializes the contract and sets the core variables\r\n    function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, address exchangeContract_, address DmexOracleContract_, address poolAddress) {\r\n        owner               = msg.sender;\r\n        feeAccount          = feeAccount_;\r\n        makerFee            = makerFee_;\r\n        takerFee            = takerFee_;\r\n\r\n        exchangeContract    = exchangeContract_;\r\n        DmexOracleContract    = DmexOracleContract_;\r\n\r\n        pools[poolAddress] = true;\r\n    }\r\n\r\n    // Changes the fees\r\n    function setFees(uint256 makerFee_, uint256 takerFee_) onlyOwner {\r\n        require(makerFee_       < 10 finney && takerFee_ < 10 finney); // The fees cannot be set higher then 1%\r\n        makerFee                = makerFee_;\r\n        takerFee                = takerFee_;\r\n\r\n        emit FeeChange(makerFee, takerFee);\r\n    }\r\n\r\n    // Adds or disables an admin account\r\n    function setAdmin(address admin, bool isAdmin) onlyOwner {\r\n        admins[admin] = isAdmin;\r\n    }\r\n\r\n    // Adds or disables a liquidity pool address\r\n    function setPool(address user, bool enabled) onlyOwner public {\r\n        pools[user] = enabled;\r\n    }\r\n\r\n    // Allows for admins only to call the function\r\n    modifier onlyAdmin {\r\n        if (msg.sender != owner && !admins[msg.sender]) throw;\r\n        _;\r\n    }\r\n\r\n    function() external {\r\n        throw;\r\n    }   \r\n\r\n\r\n    function validateUint48(uint256 val) returns (bool)\r\n    {\r\n        if (val != uint48(val)) return false;\r\n        return true;\r\n    }\r\n\r\n    function validateUint64(uint256 val) returns (bool)\r\n    {\r\n        if (val != uint64(val)) return false;\r\n        return true;\r\n    }\r\n\r\n    function validateUint128(uint256 val) returns (bool)\r\n    {\r\n        if (val != uint128(val)) return false;\r\n        return true;\r\n    }\r\n\r\n\r\n    // Structure that holds order values, used inside the trade() function\r\n    struct FuturesOrderPair {\r\n        uint256 makerNonce;                 // maker order nonce, makes the order unique\r\n        uint256 takerNonce;                 // taker order nonce\r\n        //uint256 takerGasFee;                // taker gas fee, taker pays the gas\r\n        uint256 takerIsBuying;              // true/false taker is the buyer\r\n\r\n        address maker;                      // address of the maker\r\n        address taker;                      // address of the taker\r\n\r\n        bytes32 makerOrderHash;             // hash of the maker order\r\n        bytes32 takerOrderHash;             // has of the taker order\r\n\r\n        uint256 makerAmount;                // trade amount for maker\r\n        uint256 takerAmount;                // trade amount for taker\r\n\r\n        uint256 makerPrice;                 // maker order price in wei (18 decimal precision)\r\n        uint256 takerPrice;                 // taker order price in wei (18 decimal precision)\r\n\r\n        uint256 makerLeverage;              // the amount of collateral provided by maker (8 decimals)\r\n        uint256 takerLeverage;              // the amount of collateral provided by taker (8 decimals)\r\n\r\n        bytes32 futuresContract;            // the futures contract being traded\r\n\r\n        address baseToken;                  // the address of the base token for futures contract\r\n        // uint256 floorPrice;                 // floor price of futures contract\r\n        // uint256 capPrice;                   // cap price of futures contract\r\n\r\n        bytes32 makerPositionHash;          // hash for maker position\r\n        bytes32 makerInversePositionHash;   // hash for inverse maker position \r\n\r\n        bytes32 takerPositionHash;          // hash for taker position\r\n        bytes32 takerInversePositionHash;   // hash for inverse taker position\r\n    }\r\n\r\n    // Structure that holds trade values, used inside the trade() function\r\n    struct FuturesTradeValues {\r\n        uint256 qty;                    // amount to be trade\r\n        uint256 makerProfit;            // holds maker profit value\r\n        uint256 makerLoss;              // holds maker loss value\r\n        uint256 takerProfit;            // holds taker profit value\r\n        uint256 takerLoss;              // holds taker loss value\r\n        uint256 makerBalance;           // holds maker balance value\r\n        uint256 takerBalance;           // holds taker balance value\r\n        uint256 makerReserve;           // holds taker reserved value\r\n        uint256 takerReserve;           // holds taker reserved value\r\n        uint256 makerTradeCollateral;   // holds maker collateral value for trade\r\n        uint256 takerTradeCollateral;   // holds taker collateral value for trade\r\n        uint256 makerFee;\r\n        uint256 takerFee;\r\n    }\r\n\r\n\r\n    function getContractBaseToken(bytes32 futuresContractHash) public view returns (address)\r\n    {\r\n        return futuresAssets[futuresContracts[futuresContractHash].asset].baseToken;\r\n    }\r\n\r\n    function generateOrderHash (bool maker, bool takerIsBuying, address user, bytes32 futuresContractHash, uint256[11] tradeValues) public view returns (bytes32)\r\n    {\r\n        if (maker)\r\n        {\r\n            //                     futuresContract      user  amount          price           side            nonce           leverage\r\n            return keccak256(this, futuresContractHash, user, tradeValues[4], tradeValues[6], !takerIsBuying, tradeValues[0], tradeValues[2]);\r\n        }\r\n        else\r\n        {\r\n            //                     futuresContract      user  amount          price           side            nonce           leverage\r\n            return keccak256(this, futuresContractHash, user, tradeValues[5], tradeValues[7],  takerIsBuying, tradeValues[1], tradeValues[8]);  \r\n        }\r\n    }\r\n\r\n\r\n    /** TO DO **/\r\n    // Send maker/taker fee in futures trade\r\n    // Tets posiiton liquidation\r\n\r\n    // Opens/closes futures positions\r\n    function futuresTrade(\r\n        uint8[2] v,\r\n        bytes32[4] rs,\r\n        uint256[11] tradeValues,\r\n        address[2] tradeAddresses,\r\n        bool takerIsBuying,\r\n        bytes32 futuresContractHash\r\n    ) returns (uint filledTakerTokenAmount)\r\n    {\r\n        /* tradeValues\r\n          [0] makerNonce\r\n          [1] takerNonce\r\n          [2] makerLeverage\r\n          [3] takerIsBuying\r\n          [4] makerAmount\r\n          [5] takerAmount\r\n          [6] makerPrice\r\n          [7] takerPrice\r\n          [8] takerLeverage\r\n          [9] makerFee\r\n          [10] takerFee\r\n\r\n          tradeAddresses\r\n          [0] maker\r\n          [1] taker\r\n        */\r\n\r\n        FuturesOrderPair memory t  = FuturesOrderPair({\r\n            makerNonce      : tradeValues[0],\r\n            takerNonce      : tradeValues[1],\r\n            //takerGasFee     : tradeValues[2],\r\n            takerIsBuying   : tradeValues[3],\r\n            makerAmount     : tradeValues[4],      \r\n            takerAmount     : tradeValues[5],   \r\n            makerPrice      : tradeValues[6],         \r\n            takerPrice      : tradeValues[7],\r\n            makerLeverage   : tradeValues[2],\r\n            takerLeverage   : tradeValues[8],\r\n\r\n            maker           : tradeAddresses[0],\r\n            taker           : tradeAddresses[1],\r\n\r\n            makerOrderHash  : generateOrderHash(true,  takerIsBuying, tradeAddresses[0], futuresContractHash, tradeValues), // keccak256(this, futuresContractHash, tradeAddresses[0], tradeValues[4], tradeValues[6], !takerIsBuying, tradeValues[0], tradeValues[2]),\r\n            takerOrderHash  : generateOrderHash(false, takerIsBuying, tradeAddresses[1], futuresContractHash, tradeValues), // keccak256(this, futuresContractHash, tradeAddresses[1], tradeValues[5], tradeValues[7],  takerIsBuying, tradeValues[1], tradeValues[8]),            \r\n\r\n            futuresContract : futuresContractHash,\r\n\r\n            baseToken       : getContractBaseToken(futuresContractHash),\r\n\r\n            //                                            user               futuresContractHash   side           \r\n            makerPositionHash           : keccak256(this, tradeAddresses[0], futuresContractHash, !takerIsBuying),\r\n            makerInversePositionHash    : keccak256(this, tradeAddresses[0], futuresContractHash,  takerIsBuying),\r\n\r\n            takerPositionHash           : keccak256(this, tradeAddresses[1], futuresContractHash,  takerIsBuying),\r\n            takerInversePositionHash    : keccak256(this, tradeAddresses[1], futuresContractHash, !takerIsBuying)\r\n\r\n        });\r\n\r\n\r\n       \r\n\r\n//--> 44 000\r\n    \r\n        // Valifate size and price values\r\n        if (!validateUint128(t.makerAmount) || !validateUint128(t.takerAmount) || !validateUint64(t.makerPrice) || !validateUint64(t.takerPrice))\r\n        {            \r\n            emit LogError(uint8(Errors.UINT48_VALIDATION), t.makerOrderHash, t.takerOrderHash);\r\n            return 0; \r\n        }\r\n\r\n\r\n        // Check if futures contract has expired already\r\n        if ((!futuresContracts[t.futuresContract].perpetual && block.number > futuresContracts[t.futuresContract].expirationBlock) || futuresContracts[t.futuresContract].closed == true || futuresContracts[t.futuresContract].broken == true)\r\n        {\r\n            emit LogError(uint8(Errors.FUTURES_CONTRACT_EXPIRED), t.makerOrderHash, t.takerOrderHash);\r\n            return 0; // futures contract is expired\r\n        }\r\n\r\n\r\n\r\n        // Checks the signature for the maker order\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", t.makerOrderHash), v[0], rs[0], rs[1]) != t.maker)\r\n        {\r\n            emit LogError(uint8(Errors.INVALID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n\r\n        // Checks the signature for the taker order\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", t.takerOrderHash), v[1], rs[2], rs[3]) != t.taker)\r\n        {\r\n            emit LogError(uint8(Errors.INVALID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n\r\n        // check prices\r\n        if ((!takerIsBuying && t.makerPrice < t.takerPrice) || (takerIsBuying && t.takerPrice < t.makerPrice))\r\n        {\r\n            emit LogError(uint8(Errors.INVALID_PRICE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0; // prices don't match\r\n        }      \r\n\r\n//--> 54 000         \r\n        \r\n\r\n        uint256[4] memory balances = DMEX_Base(exchangeContract).getMakerTakerBalances(t.baseToken, t.maker, t.taker);\r\n\r\n        // Initializing trade values structure \r\n        FuturesTradeValues memory tv = FuturesTradeValues({\r\n            qty                 : 0,\r\n            makerProfit         : 0,\r\n            makerLoss           : 0,\r\n            takerProfit         : 0,\r\n            takerLoss           : 0,\r\n            makerBalance        : balances[0], \r\n            takerBalance        : balances[1],  \r\n            makerReserve        : balances[2],  \r\n            takerReserve        : balances[3],\r\n            makerTradeCollateral: 0,\r\n            takerTradeCollateral: 0,\r\n            makerFee            : min(makerFee, tradeValues[9]),\r\n            takerFee            : min(takerFee, tradeValues[10])\r\n        });\r\n\r\n//--> 60 000\r\n\r\n\r\n\r\n\r\n\r\n        // traded quantity is the smallest quantity between the maker and the taker, takes into account amounts already filled on the orders\r\n        // and open inverse positions\r\n        tv.qty = min(safeSub(t.makerAmount, orderFills[t.makerOrderHash]), safeSub(t.takerAmount, orderFills[t.takerOrderHash]));\r\n        \r\n        if (positionExists(t.makerInversePositionHash) && positionExists(t.takerInversePositionHash))\r\n        {\r\n            tv.qty = min(tv.qty, min(retrievePosition(t.makerInversePositionHash)[0], retrievePosition(t.takerInversePositionHash)[0]));\r\n        }\r\n        else if (positionExists(t.makerInversePositionHash))\r\n        {\r\n            tv.qty = min(tv.qty, retrievePosition(t.makerInversePositionHash)[0]);\r\n        }\r\n        else if (positionExists(t.takerInversePositionHash))\r\n        {\r\n            tv.qty = min(tv.qty, retrievePosition(t.takerInversePositionHash)[0]);\r\n        }\r\n\r\n        tv.makerTradeCollateral = calculateCollateral(tv.qty, t.makerPrice, t.makerLeverage, t.futuresContract);\r\n        tv.takerTradeCollateral = calculateCollateral(tv.qty, t.makerPrice, t.takerLeverage, t.futuresContract);\r\n\r\n\r\n//--> 64 000       \r\n        \r\n        if (tv.qty == 0)\r\n        {\r\n            // no qty left on orders\r\n            emit LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n\r\n        // Cheks that gas fee is not higher than 10%\r\n        // if (safeMul(t.takerGasFee, 20) > calculateTradeValue(tv.qty, t.makerPrice, t.futuresContract))\r\n        // {\r\n        //     emit LogError(uint8(Errors.GAS_TOO_HIGH), t.makerOrderHash, t.takerOrderHash);\r\n        //     return 0;\r\n        // } // takerGasFee too high\r\n\r\n\r\n//--> 66 000\r\n        \r\n\r\n       \r\n\r\n        /*------------- Maker long, Taker short -------------*/\r\n        if (!takerIsBuying)\r\n        {     \r\n            \r\n      \r\n            // position actions for maker\r\n            if (!positionExists(t.makerInversePositionHash) && !positionExists(t.makerPositionHash))\r\n            {\r\n\r\n\r\n                // check if maker has enough balance   \r\n                if (safeSub(tv.makerBalance,tv.makerReserve) < safeMul(tv.makerTradeCollateral, 1e10))\r\n                {\r\n                    // maker out of balance\r\n                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                    return 0; \r\n                }\r\n\r\n                updateBalances(\r\n                    t.futuresContract, \r\n                    [\r\n                        t.baseToken, // base token\r\n                        t.maker // make address\r\n                    ], \r\n                    t.makerPositionHash,  // position hash\r\n                    [\r\n                        tv.qty, // qty\r\n                        t.makerPrice,  // price\r\n                        tv.makerFee, // fee\r\n                        0, // profit\r\n                        0, // loss\r\n                        tv.makerBalance, // balance\r\n                        0, // gasFee\r\n                        tv.makerReserve, // reserve\r\n                        t.makerLeverage // leverage\r\n                    ], \r\n                    [\r\n                        true, // newPostion (if true position is new)\r\n                        true, // side (if true - long)\r\n                        false // increase position (if true)\r\n                    ]\r\n                );\r\n\r\n            } else {               \r\n                \r\n                if (positionExists(t.makerPositionHash))\r\n                {\r\n                    // check if maker has enough balance            \r\n                    if (safeSub(tv.makerBalance,tv.makerReserve) < safeMul(tv.makerTradeCollateral, 1e10))\r\n                    {\r\n                        // maker out of balance\r\n                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                        return 0; \r\n                    }\r\n\r\n                    // increase position size\r\n                    // updatePositionSize(t.makerPositionHash, safeAdd(retrievePosition(t.makerPositionHash)[0], tv.qty), t.makerPrice);\r\n                \r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken,  // base token\r\n                            t.maker // make address\r\n                        ], \r\n                        t.makerPositionHash, // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            tv.makerFee, // fee\r\n                            0, // profit\r\n                            0, // loss\r\n                            tv.makerBalance, // balance\r\n                            0, // gasFee\r\n                            tv.makerReserve, // reserve\r\n                            t.makerLeverage // leverage\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            true, // side (if true - long)\r\n                            true // increase position (if true)\r\n                        ]\r\n                    );\r\n                }\r\n                else\r\n                {\r\n\r\n                    // close/partially close existing position\r\n                    // updatePositionSize(t.makerInversePositionHash, safeSub(retrievePosition(t.makerInversePositionHash)[0], tv.qty), 0);\r\n                    \r\n                    \r\n\r\n                    if (t.makerPrice < retrievePosition(t.makerInversePositionHash)[1])\r\n                    {\r\n                        // user has made a profit\r\n                        //tv.makerProfit                    = safeMul(safeSub(retrievePosition(t.makerInversePositionHash)[1], t.makerPrice), tv.qty) / t.makerPrice;\r\n                        tv.makerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, true);\r\n                    }\r\n                    else\r\n                    {\r\n                        // user has made a loss\r\n                        //tv.makerLoss                      = safeMul(safeSub(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1]), tv.qty) / t.makerPrice;    \r\n                        tv.makerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, true);                                        \r\n                    }\r\n\r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken, // base token\r\n                            t.maker // make address\r\n                        ], \r\n                        t.makerInversePositionHash, // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            tv.makerFee, // fee\r\n                            tv.makerProfit,  // profit\r\n                            tv.makerLoss,  // loss\r\n                            tv.makerBalance, // balance\r\n                            0, // gasFee\r\n                            tv.makerReserve, // reserve\r\n                            t.makerLeverage // leverage\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            true, // side (if true - long)\r\n                            false // increase position (if true)\r\n                        ]\r\n                    );\r\n                }                \r\n            }\r\n\r\n           \r\n\r\n\r\n            // position actions for taker\r\n            if (!positionExists(t.takerInversePositionHash) && !positionExists(t.takerPositionHash))\r\n            {\r\n                \r\n                // check if taker has enough balance\r\n                if (safeSub(tv.takerBalance,tv.takerReserve) < safeMul(tv.takerTradeCollateral, 1e10))\r\n                {\r\n                    // maker out of balance\r\n                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                    return 0; \r\n                }\r\n                \r\n                // create new position\r\n                //recordNewPosition(t.takerPositionHash, tv.qty, t.makerPrice, 0, block.number);\r\n                \r\n                updateBalances(\r\n                    t.futuresContract, \r\n                    [\r\n                        t.baseToken, // base token\r\n                        t.taker // make address\r\n                    ], \r\n                    t.takerPositionHash, // position hash\r\n                    [\r\n                        tv.qty, // qty\r\n                        t.makerPrice,  // price\r\n                        tv.takerFee, // fee\r\n                        0, // profit\r\n                        0,  // loss\r\n                        tv.takerBalance,  // balance\r\n                        0, // gasFee\r\n                        tv.takerReserve, // reserve\r\n                        t.takerLeverage // leverage\r\n                    ], \r\n                    [\r\n                        true, // newPostion (if true position is new)\r\n                        false, // side (if true - long)\r\n                        false // increase position (if true)\r\n                    ]\r\n                );\r\n\r\n            } else {\r\n                if (positionExists(t.takerPositionHash))\r\n                {\r\n                    // check if taker has enough balance\r\n                    //if (safeAdd(safeAdd(safeMul(safeSub(t.capPrice, t.makerPrice), tv.qty)  / t.capPrice, safeMul(tv.qty, takerFee) / (1 ether))  * 1e10, t.takerGasFee) > safeSub(balances[1],tv.takerReserve))\r\n                    if (safeSub(tv.takerBalance,tv.takerReserve) < safeMul(tv.takerTradeCollateral, 1e10))\r\n                    {\r\n                        // maker out of balance\r\n                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                        return 0; \r\n                    }\r\n\r\n                    // increase position size\r\n                    //updatePositionSize(t.takerPositionHash, safeAdd(retrievePosition(t.takerPositionHash)[0], tv.qty), t.makerPrice);\r\n                \r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken,  // base token\r\n                            t.taker // make address\r\n                        ], \r\n                        t.takerPositionHash, // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            tv.takerFee, // fee\r\n                            0, // profit\r\n                            0, // loss\r\n                            tv.takerBalance, // balance\r\n                            0, // gasFee\r\n                            tv.takerReserve, // reserve\r\n                            t.takerLeverage // leverage\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            false, // side (if true - long)\r\n                            true // increase position (if true)\r\n                        ]\r\n                    );\r\n                }\r\n                else\r\n                {    \r\n                    // close/partially close existing position\r\n                    //updatePositionSize(t.takerInversePositionHash, safeSub(retrievePosition(t.takerInversePositionHash)[0], tv.qty), 0);\r\n                    \r\n                    if (t.makerPrice > retrievePosition(t.takerInversePositionHash)[1])\r\n                    {\r\n                        // user has made a profit\r\n                        tv.takerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, false);\r\n                    }\r\n                    else\r\n                    {\r\n                        // user has made a loss\r\n                        tv.takerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, false); \r\n                    }\r\n\r\n                  \r\n\r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken, // base token\r\n                            t.taker // make address\r\n                        ], \r\n                        t.takerInversePositionHash, // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            tv.takerFee, // fee\r\n                            tv.takerProfit, // profit\r\n                            tv.takerLoss, // loss\r\n                            tv.takerBalance,  // balance\r\n                            0,  // gasFee\r\n                            tv.takerReserve, // reserve\r\n                            t.takerLeverage // leverage\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            false, // side (if true - long)\r\n                            false // increase position (if true)\r\n                        ]\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        /*------------- Maker short, Taker long -------------*/\r\n\r\n        else\r\n        {      \r\n            // position actions for maker\r\n            if (!positionExists(t.makerInversePositionHash) && !positionExists(t.makerPositionHash))\r\n            {\r\n                // check if maker has enough balance\r\n                if (safeSub(tv.makerBalance,tv.makerReserve) < safeMul(tv.makerTradeCollateral, 1e10))\r\n                {\r\n                    // maker out of balance\r\n                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                    return 0; \r\n                }\r\n\r\n                // create new position\r\n                //recordNewPosition(t.makerPositionHash, tv.qty, t.makerPrice, 0, block.number);\r\n                updateBalances(\r\n                    t.futuresContract, \r\n                    [\r\n                        t.baseToken,   // base token\r\n                        t.maker // make address\r\n                    ], \r\n                    t.makerPositionHash, // position hash\r\n                    [\r\n                        tv.qty, // qty\r\n                        t.makerPrice, // price\r\n                        tv.makerFee, // fee\r\n                        0, // profit\r\n                        0, // loss\r\n                        tv.makerBalance, // balance\r\n                        0, // gasFee\r\n                        tv.makerReserve, // reserve\r\n                        t.makerLeverage // leverage\r\n                    ], \r\n                    [\r\n                        true, // newPostion (if true position is new)\r\n                        false, // side (if true - long)\r\n                        false // increase position (if true)\r\n                    ]\r\n                );\r\n\r\n            } else {\r\n                if (positionExists(t.makerPositionHash))\r\n                {\r\n                    // check if maker has enough balance\r\n                    if (safeSub(tv.makerBalance,tv.makerReserve) < safeMul(tv.makerTradeCollateral, 1e10))\r\n                    {\r\n                        // maker out of balance\r\n                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                        return 0; \r\n                    }\r\n\r\n                    // increase position size\r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken,  // base token\r\n                            t.maker // make address\r\n                        ], \r\n                        t.makerPositionHash, // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            tv.makerFee, // fee\r\n                            0, // profit\r\n                            0, // loss\r\n                            tv.makerBalance, // balance\r\n                            0, // gasFee\r\n                            tv.makerReserve, // reserve\r\n                            t.makerLeverage // leverage\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            false, // side (if true - long)\r\n                            true // increase position (if true)\r\n                        ]\r\n                    );\r\n                }\r\n                else\r\n                {\r\n\r\n\r\n                    // close/partially close existing position\r\n                    if (t.makerPrice > retrievePosition(t.makerInversePositionHash)[1])\r\n                    {\r\n                        // user has made a profit\r\n                        tv.makerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, false);\r\n                    }\r\n                    else\r\n                    {\r\n                        // user has made a loss\r\n                        tv.makerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, false);                               \r\n                    }\r\n\r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken, // base token\r\n                            t.maker // user address\r\n                        ], \r\n                        t.makerInversePositionHash, // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            tv.makerFee, // fee\r\n                            tv.makerProfit,  // profit\r\n                            tv.makerLoss, // loss\r\n                            tv.makerBalance, // balance\r\n                            0, // gasFee\r\n                            tv.makerReserve, // reserve\r\n                            t.makerLeverage // leverage\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            false, // side (if true - long)\r\n                            false // increase position (if true)\r\n                        ]\r\n                    );\r\n                }\r\n            }\r\n\r\n            // position actions for taker\r\n            if (!positionExists(t.takerInversePositionHash) && !positionExists(t.takerPositionHash))\r\n            {\r\n                // check if taker has enough balance\r\n                if (safeSub(tv.takerBalance,tv.takerReserve) < safeMul(tv.takerTradeCollateral, 1e10))\r\n                {\r\n                    // maker out of balance\r\n                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                    return 0; \r\n                }\r\n\r\n                updateBalances(\r\n                    t.futuresContract, \r\n                    [\r\n                        t.baseToken,  // base token\r\n                        t.taker // user address\r\n                    ], \r\n                    t.takerPositionHash, // position hash\r\n                    [\r\n                        tv.qty, // qty\r\n                        t.makerPrice, // price\r\n                        tv.takerFee, // fee\r\n                        0,  // profit\r\n                        0,  // loss\r\n                        tv.takerBalance, // balance\r\n                        0, // gasFee\r\n                        tv.takerReserve, // reserve\r\n                        t.takerLeverage // leverage\r\n                    ], \r\n                    [\r\n                        true, // newPostion (if true position is new)\r\n                        true, // side (if true - long)\r\n                        false // increase position (if true)\r\n                    ]\r\n                );\r\n\r\n            } else {\r\n                if (positionExists(t.takerPositionHash))\r\n                {\r\n                    // check if taker has enough balance\r\n                    if (safeSub(tv.takerBalance,tv.takerReserve) < safeMul(tv.takerTradeCollateral, 1e10))\r\n                    {\r\n                        // maker out of balance\r\n                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                        return 0; \r\n                    }\r\n                    \r\n                    // increase position size\r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken,  // base token\r\n                            t.taker // user address\r\n                        ], \r\n                        t.takerPositionHash, // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            tv.takerFee, // fee\r\n                            0, // profit\r\n                            0, // loss\r\n                            tv.takerBalance, // balance\r\n                            0, // gasFee\r\n                            tv.takerReserve, // reserve\r\n                            t.takerLeverage // leverage\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            true, // side (if true - long)\r\n                            true // increase position (if true)\r\n                        ]\r\n                    );\r\n                }\r\n                else\r\n                {\r\n\r\n                    // close/partially close existing position\r\n                    if (t.makerPrice < retrievePosition(t.takerInversePositionHash)[1])\r\n                    {\r\n                        // user has made a profit\r\n                        tv.takerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, true);\r\n                    }\r\n                    else\r\n                    {\r\n                        // user has made a loss\r\n                        tv.takerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, true);                                  \r\n                    }                   \r\n\r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken,   // base toke\r\n                            t.taker // user address\r\n                        ], \r\n                        t.takerInversePositionHash,  // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            tv.takerFee, // fee\r\n                            tv.takerProfit, // profit\r\n                            tv.takerLoss, // loss\r\n                            tv.takerBalance, // balance\r\n                            0, // gasFee\r\n                            tv.takerReserve, // reserve\r\n                            t.takerLeverage // leverage\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            true, // side (if true - long) \r\n                            false // increase position (if true)\r\n                        ]\r\n                    );\r\n                }\r\n            }           \r\n        }\r\n\r\n//--> 220 000\r\n        orderFills[t.makerOrderHash]            = safeAdd(orderFills[t.makerOrderHash], tv.qty); // increase the maker order filled amount\r\n        orderFills[t.takerOrderHash]            = safeAdd(orderFills[t.takerOrderHash], tv.qty); // increase the taker order filled amount\r\n\r\n//--> 264 000\r\n        emit FuturesTrade(takerIsBuying, tv.qty, t.makerPrice, t.futuresContract, t.makerOrderHash, t.takerOrderHash);\r\n\r\n        return tv.qty;\r\n    }\r\n\r\n\r\n    function calculateProfit(uint256 closingPrice, uint256 entryPrice, uint256 qty, bytes32 futuresContractHash, bool side) public view returns (uint256)\r\n    {\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n\r\n        if (side)\r\n        {           \r\n            return safeMul(safeMul(safeSub(entryPrice, closingPrice), qty), multiplier )  / 1e16;            \r\n        }\r\n        else\r\n        {\r\n            return safeMul(safeMul(safeSub(closingPrice, entryPrice), qty), multiplier )  / 1e16; \r\n        }       \r\n    }\r\n\r\n    function calculateTradeValue(uint256 qty, uint256 price, bytes32 futuresContractHash)  public view returns (uint256)\r\n    {\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n        return safeMul(safeMul(safeMul(qty, price), 1e2), multiplier) / 1e8 ;\r\n    }\r\n\r\n\r\n\r\n    function calculateLoss(uint256 closingPrice, uint256 entryPrice, uint256 qty,  bytes32 futuresContractHash, bool side) public view returns (uint256)\r\n    {\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n\r\n        if (side)\r\n        {\r\n            return safeMul(safeMul(safeSub(closingPrice, entryPrice), qty), multiplier) / 1e16 ;\r\n        }\r\n        else\r\n        {\r\n            return safeMul(safeMul(safeSub(entryPrice, closingPrice), qty), multiplier) / 1e16 ; \r\n        }\r\n        \r\n    }\r\n\r\n    function calculateCollateral (uint256 qty, uint256 price, uint256 leverage, bytes32 futuresContractHash) view returns (uint256) // 1e8\r\n    {\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n        uint256 collateral;\r\n            \r\n        collateral = safeMul(safeMul(price, qty), multiplier) / 1e16 / leverage;\r\n\r\n        return collateral;               \r\n    }\r\n\r\n    function calculateProportionalMargin(uint256 currQty, uint256 newQty, uint256 margin) view returns (uint256) // 1e8\r\n    {\r\n        uint256 proportionalMargin = safeMul(margin, newQty)/currQty;\r\n        return proportionalMargin;          \r\n    }\r\n\r\n    function calculateFundingCost (uint256 price, uint256 qty, uint256 fundingBlocks, bytes32 futuresContractHash)  public view returns (uint256) // 1e8\r\n    {\r\n        uint256 fundingRate = futuresContracts[futuresContractHash].fundingRate;\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n\r\n        uint256 fundingCost = safeMul(safeMul(safeMul(fundingBlocks, fundingRate), safeMul(qty, price)/1e8)/1e18, multiplier)/1e8;\r\n\r\n        return fundingCost;  \r\n    }\r\n\r\n    function calculateFee (uint256 qty, uint256 tradePrice, uint256 fee, bytes32 futuresContractHash)  public view returns (uint256)\r\n    {\r\n        return safeMul(calculateTradeValue(qty, tradePrice, futuresContractHash), fee / 1e10) / 1e18;\r\n    }\r\n     \r\n\r\n    // Executes multiple trades in one transaction, saves gas fees\r\n    function batchFuturesTrade(\r\n        uint8[2][] v,\r\n        bytes32[4][] rs,\r\n        uint256[11][] tradeValues,\r\n        address[2][] tradeAddresses,\r\n        bool[2][] boolValues,\r\n        bytes32[] assetHash,\r\n        uint256[3][] contractValues\r\n    ) onlyAdmin\r\n    {\r\n        // perform trades\r\n        for (uint i = 0; i < tradeAddresses.length; i++) {\r\n            futuresTrade(\r\n                v[i],\r\n                rs[i],\r\n                tradeValues[i],\r\n                tradeAddresses[i],\r\n                boolValues[i][0],\r\n                createFuturesContract(assetHash[i], contractValues[i][0], contractValues[i][1], contractValues[i][2], boolValues[i][1])\r\n            );\r\n        }\r\n    }\r\n\r\n    \r\n\r\n\r\n    // Update user balance\r\n    function updateBalances (bytes32 futuresContract, address[2] addressValues, bytes32 positionHash, uint256[9] uintValues, bool[3] boolValues) private\r\n    {\r\n        /*\r\n            addressValues\r\n            [0] baseToken\r\n            [1] user\r\n\r\n            uintValues\r\n            [0] qty\r\n            [1] price\r\n            [2] fee\r\n            [3] profit\r\n            [4] loss\r\n            [5] balance\r\n            [6] gasFee\r\n            [7] reserve\r\n            [8] leverage\r\n\r\n            boolValues\r\n            [0] newPostion\r\n            [1] side\r\n            [2] increase position\r\n\r\n        */\r\n\r\n        // pam = [fee value, collateral, fundignCost, payableFundingCost]               \r\n        uint256[3] memory pam = [\r\n            safeAdd(safeMul(calculateFee(uintValues[0], uintValues[1], uintValues[2], futuresContract), 1e10), uintValues[6]), \r\n            calculateCollateral(uintValues[0], uintValues[1], uintValues[8], futuresContract),\r\n            0\r\n        ];\r\n               \r\n        if (boolValues[0] || boolValues[2])  \r\n        {\r\n            // Position is new or position is increased\r\n            if (boolValues[0])\r\n            {\r\n                // new position\r\n                recordNewPosition(positionHash, uintValues[0], uintValues[1], boolValues[1] ? 1 : 0, block.number, pam[1]);\r\n            }\r\n            else\r\n            {\r\n                // increase position\r\n                updatePositionSize(positionHash, safeAdd(retrievePosition(positionHash)[0], uintValues[0]), uintValues[1], safeAdd(retrievePosition(positionHash)[4], pam[1]));\r\n            }\r\n\r\n            \r\n            if (!pools[addressValues[1]])\r\n            {\r\n                subBalanceAddReserve(addressValues[0], addressValues[1], pam[0], pam[1]);                    \r\n            }\r\n            else\r\n            {\r\n                pam[0] = 0;\r\n            }\r\n            pam[2] = 0;\r\n        } \r\n        else \r\n        {\r\n            // Position exists, decreasing\r\n            //pam[1] = calculateCollateral(uintValues[0], retrievePosition(positionHash)[1], uintValues[8], futuresContract)-1;                          \r\n            pam[1] = calculateProportionalMargin(retrievePosition(positionHash)[0], uintValues[0], retrievePosition(positionHash)[4]);\r\n            \r\n            updatePositionSize(positionHash, safeSub(retrievePosition(positionHash)[0], uintValues[0]),  uintValues[1], safeSub(retrievePosition(positionHash)[4], pam[1]));\r\n\r\n            pam[2] = calculateFundingCost(retrievePosition(positionHash)[1], uintValues[0], safeSub(block.number, retrievePosition(positionHash)[3]), futuresContract);   \r\n            \r\n\r\n            if (pools[addressValues[1]]) {\r\n                pam[0] = 0;\r\n                pam[1] = 0;\r\n                pam[2] = 0;\r\n            }\r\n\r\n            if (uintValues[3] > 0) \r\n            {\r\n                // profit > 0\r\n                if (safeAdd(pam[0], pam[2]*1e10) <= safeMul(uintValues[3],1e10))\r\n                {\r\n                    addBalanceSubReserve(addressValues[0], addressValues[1], safeSub(safeMul(uintValues[3],1e10), safeAdd(pam[0], pam[2]*1e10)), pam[1]);\r\n                }\r\n                else\r\n                {\r\n                    // LogUint(13, safeSub(safeAdd(pam[0], pam[2]*1e10), safeMul(uintValues[3],1e10)));\r\n                    // return;\r\n                    subBalanceSubReserve(addressValues[0], addressValues[1], safeSub(safeAdd(pam[0], pam[2]*1e10), safeMul(uintValues[3],1e10)), pam[1]);\r\n                }                \r\n            } \r\n            else \r\n            {   \r\n                // loss >= 0\r\n                subBalanceSubReserve(addressValues[0], addressValues[1], safeAdd(safeMul(uintValues[4],1e10), safeAdd(pam[0], pam[2]*1e10)), pam[1]); // deduct loss from user balance\r\n            }     \r\n\r\n        }          \r\n        \r\n        if (safeAdd(pam[0], pam[2]*1e10) > 0)\r\n        {\r\n            addBalance(addressValues[0], feeAccount, DMEX_Base(exchangeContract).balanceOf(addressValues[0], feeAccount), safeAdd(pam[0], pam[2]*1e10)); // send fee to feeAccount\r\n        }\r\n        \r\n    }\r\n\r\n    function recordNewPosition (bytes32 positionHash, uint256 size, uint256 price, uint256 side, uint256 block, uint256 collateral) private\r\n    {\r\n        if (!validateUint64(size) || !validateUint64(price) || !validateUint64(collateral)) \r\n        {\r\n            throw;\r\n        }\r\n\r\n        uint256 character = uint64(size);\r\n        character |= price<<64;\r\n        character |= collateral<<128;\r\n        character |= side<<192;\r\n        character |= block<<208;\r\n\r\n        positions[positionHash] = character;\r\n    }\r\n\r\n    function retrievePosition (bytes32 positionHash) public view returns (uint256[5])\r\n    {\r\n        uint256 character = positions[positionHash];\r\n        uint256 size = uint256(uint64(character));\r\n        uint256 price = uint256(uint64(character>>64));\r\n        uint256 collateral = uint256(uint64(character>>128));\r\n        uint256 side = uint256(uint16(character>>192));\r\n        uint256 entryBlock = uint256(uint48(character>>208));\r\n\r\n        return [size, price, side, entryBlock, collateral];\r\n    }\r\n\r\n    function updatePositionSize(bytes32 positionHash, uint256 size, uint256 price, uint256 collateral) private\r\n    {\r\n        uint256[5] memory pos = retrievePosition(positionHash);\r\n\r\n        if (size > pos[0])\r\n        {\r\n            uint256 totalValue = safeAdd(safeMul(pos[0], pos[1]), safeMul(price, safeSub(size, pos[0])));\r\n            uint256 newSize = safeSub(size, pos[0]);\r\n            // position is increasing in size\r\n            recordNewPosition(\r\n                positionHash, \r\n                size, \r\n                totalValue / size, \r\n                pos[2], \r\n                safeAdd(safeMul(safeMul(pos[0], pos[1]), pos[3]), safeMul(safeMul(price, newSize), block.number)) / totalValue, // pos[3]\r\n                collateral\r\n            );\r\n        }\r\n        else\r\n        {\r\n            // position is decreasing in size\r\n            recordNewPosition(\r\n                positionHash, \r\n                size, \r\n                pos[1], \r\n                pos[2], \r\n                pos[3],\r\n                collateral\r\n            );\r\n        }        \r\n    }\r\n\r\n    function positionExists (bytes32 positionHash) internal view returns (bool)\r\n    {\r\n        if (retrievePosition(positionHash)[0] == 0)\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n    // This function allows the user to manually release collateral in case the oracle service does not provide the price during the inactivityReleasePeriod\r\n    function forceReleaseReserve (bytes32 futuresContract, bool side, address user) public\r\n    {   \r\n        if (futuresContracts[futuresContract].expirationBlock == 0) throw;       \r\n        if (futuresContracts[futuresContract].expirationBlock > block.number) throw;\r\n        if (safeAdd(futuresContracts[futuresContract].expirationBlock, DMEX_Base(exchangeContract).getInactivityReleasePeriod()) > block.number) throw;  \r\n        \r\n\r\n        bytes32 positionHash = keccak256(this, user, futuresContract, side);\r\n        if (retrievePosition(positionHash)[1] == 0) throw;    \r\n  \r\n\r\n        futuresContracts[futuresContract].broken = true;\r\n\r\n        uint256[5] memory pos = retrievePosition(positionHash);\r\n        FuturesContract cont = futuresContracts[futuresContract];\r\n        address baseToken = futuresAssets[cont.asset].baseToken;\r\n\r\n        subReserve(\r\n            baseToken, \r\n            user, \r\n            DMEX_Base(exchangeContract).getReserve(baseToken, user), \r\n            pos[4]\r\n        );        \r\n\r\n        updatePositionSize(positionHash, 0, 0, 0);\r\n\r\n        emit FuturesForcedRelease(futuresContract, side, user);\r\n\r\n    }\r\n\r\n    function addBalance(address token, address user, uint256 balance, uint256 amount) private\r\n    {\r\n        DMEX_Base(exchangeContract).setBalance(token, user, safeAdd(balance, amount));\r\n    }\r\n\r\n    function subBalance(address token, address user, uint256 balance, uint256 amount) private\r\n    {\r\n        DMEX_Base(exchangeContract).setBalance(token, user, safeSub(balance, amount));\r\n    }\r\n\r\n    function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) private\r\n    {\r\n        DMEX_Base(exchangeContract).subBalanceAddReserve(token, user, subBalance, safeMul(addReserve, 1e10));\r\n    }\r\n\r\n    function addBalanceSubReserve(address token, address user, uint256 addBalance, uint256 subReserve) private\r\n    {\r\n        DMEX_Base(exchangeContract).addBalanceSubReserve(token, user, addBalance, safeMul(subReserve, 1e10));\r\n    }\r\n\r\n    function subBalanceSubReserve(address token, address user, uint256 subBalance, uint256 subReserve) private\r\n    {\r\n        DMEX_Base(exchangeContract).subBalanceSubReserve(token, user, subBalance, safeMul(subReserve, 1e10));\r\n    }\r\n\r\n    function subReserve(address token, address user, uint256 reserve, uint256 amount) private \r\n    {\r\n        DMEX_Base(exchangeContract).setReserve(token, user, safeSub(reserve, safeMul(amount, 1e10)));\r\n    }\r\n\r\n    function getMakerTakerPositions(bytes32 makerPositionHash, bytes32 makerInversePositionHash, bytes32 takerPosition, bytes32 takerInversePosition) public view returns (uint256[5][4])\r\n    {\r\n        return [\r\n            retrievePosition(makerPositionHash),\r\n            retrievePosition(makerInversePositionHash),\r\n            retrievePosition(takerPosition),\r\n            retrievePosition(takerInversePosition)\r\n        ];\r\n    }\r\n\r\n\r\n    struct FuturesClosePositionValues {\r\n        address baseToken;\r\n        uint256 reserve;                // amount to be trade\r\n        uint256 balance;                // holds maker profit value\r\n        uint256 closingPrice;           // holds taker loss value\r\n        bytes32 futuresContract;        // the futures contract hash\r\n        uint256 expirationBlock;        // the expiration block for the contract\r\n        uint256 entryBlock;             // the entry block for the position\r\n        uint256 collateral;             // reserved collateral\r\n        uint256 totalPayable;\r\n        uint256 closingBlock;\r\n        uint256 liquidationPrice;\r\n        uint256 closingFee;\r\n        bool perpetual;\r\n    }\r\n\r\n\r\n    function closeFuturesPosition(bytes32 futuresContract, bool side, address poolAddress)\r\n    {\r\n\r\n        closeFuturesPositionInternal(futuresContract, side, msg.sender, poolAddress);\r\n    }\r\n\r\n    function closeFuturesPositionInternal (bytes32 futuresContract, bool side, address user, address poolAddress) private returns (bool)\r\n    {\r\n        bytes32 positionHash = keccak256(this, user, futuresContract, side);        \r\n        bytes32 poolPositionHash = keccak256(this, poolAddress, futuresContract, !side);        \r\n\r\n        if (futuresContracts[futuresContract].closed == false && futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled\r\n        if (retrievePosition(positionHash)[1] == 0) throw; // position not found\r\n        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed\r\n        if (pools[user]) return;\r\n        if (!pools[poolAddress]) return;\r\n\r\n        uint256 profit;\r\n        uint256 loss;\r\n\r\n        FuturesClosePositionValues memory v = FuturesClosePositionValues({\r\n            baseToken       : futuresAssets[futuresContracts[futuresContract].asset].baseToken,\r\n            reserve         : 0,\r\n            balance         : 0,\r\n            closingPrice    : futuresContracts[futuresContract].closingPrice,\r\n            futuresContract : futuresContract,\r\n            expirationBlock : futuresContracts[futuresContract].expirationBlock,\r\n            entryBlock      : retrievePosition(positionHash)[3],\r\n            collateral      : 0,\r\n            totalPayable    : 0,\r\n            closingBlock    : futuresContracts[futuresContract].closingBlock,\r\n            liquidationPrice: calculateLiquidationPriceFromPositionHash(futuresContract, side, user),\r\n            closingFee      : calculateFee(retrievePosition(positionHash)[0], retrievePosition(positionHash)[1], takerFee, futuresContract),\r\n            perpetual       : futuresContracts[futuresContract].perpetual\r\n        });\r\n\r\n        v.reserve = DMEX_Base(exchangeContract).getReserve(v.baseToken, user);\r\n        v.balance = DMEX_Base(exchangeContract).balanceOf(v.baseToken, user);\r\n        \r\n\r\n        if (( side && v.closingPrice <= v.liquidationPrice) ||\r\n            (!side && v.closingPrice >= v.liquidationPrice) )\r\n        {\r\n            liquidatePositionWithClosingPrice(futuresContract, user, side, poolAddress);\r\n            return;\r\n        }\r\n\r\n        v.collateral = retrievePosition(positionHash)[4];         \r\n        v.totalPayable = safeAdd(v.closingFee, calculateFundingCost(retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], safeSub(v.closingBlock, v.entryBlock+1), futuresContract));\r\n\r\n        subReserve(\r\n            v.baseToken, \r\n            user, \r\n            v.reserve, \r\n            v.collateral\r\n        );             \r\n\r\n        if (( side && v.closingPrice > retrievePosition(positionHash)[1]) ||\r\n            (!side && v.closingPrice < retrievePosition(positionHash)[1]))\r\n        {   \r\n            // user made a profit\r\n            profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, !side);\r\n      \r\n            if (profit > v.totalPayable)\r\n            {\r\n                addBalance(v.baseToken, user, v.balance, safeSub(safeMul(profit, 1e10), safeMul(v.totalPayable, 1e10))); \r\n            }\r\n            else\r\n            {\r\n                subBalance(v.baseToken, user, v.balance, safeMul(min(v.collateral, safeSub(v.totalPayable, profit)), 1e10)); \r\n            }\r\n\r\n            subBalance(v.baseToken, poolAddress, DMEX_Base(exchangeContract).balanceOf(v.baseToken, poolAddress), safeMul(profit, 1e10)); \r\n        }\r\n        else\r\n        {\r\n            // user made a loss\r\n            loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, !side);  \r\n            \r\n            subBalance(v.baseToken, user, v.balance, safeMul(min(v.collateral, safeAdd(loss, v.totalPayable)), 1e10)); \r\n            addBalance(v.baseToken, poolAddress, DMEX_Base(exchangeContract).balanceOf(v.baseToken, poolAddress), safeMul(loss, 1e10)); \r\n        } \r\n\r\n        addBalance(v.baseToken, feeAccount, DMEX_Base(exchangeContract).balanceOf(v.baseToken, feeAccount), safeMul(v.totalPayable, 1e10)); // send fee to feeAccount\r\n        \r\n\r\n        updatePositionSize(positionHash, 0, 0, 0); \r\n        updatePositionSize(poolPositionHash, 0, 0, 0); \r\n\r\n\r\n\r\n        emit FuturesPositionClosed(positionHash, v.closingPrice);\r\n\r\n        return true;\r\n    }\r\n\r\n    function generatePositionHash (address user, bytes32 futuresContractHash, bool side) public view returns (bytes32)\r\n    {\r\n        return keccak256(this, user, futuresContractHash, side);\r\n    }\r\n\r\n    // closes position for user\r\n    function closeFuturesPositionForUser (bytes32 futuresContract, bool side, address user, address poolAddress) onlyAdmin\r\n    {\r\n        closeFuturesPositionInternal(futuresContract, side, user, poolAddress);\r\n    }\r\n\r\n    function addMargin (bytes32 futuresContractHash, address user, bool side, uint8 v, bytes32 r, bytes32 s, uint64 marginToAdd)\r\n    {\r\n        bytes32 positionHash = generatePositionHash(user, futuresContractHash, side);        \r\n        uint256[5] memory pos = retrievePosition(positionHash);\r\n        if (pos[0] == 0) revert();\r\n\r\n        // check the signature is correct\r\n        bytes32 addMarginHash = keccak256(this, user, futuresContractHash, side, marginToAdd);\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", addMarginHash), v, r, s) != user) revert();\r\n        \r\n        uint256 addMarginFee = calculateFee(pos[0], pos[1], takerFee, futuresContractHash);\r\n        bytes32 assetHash = futuresContracts[futuresContractHash].asset;\r\n\r\n        // check user has enough available balance\r\n        if (DMEX_Base(exchangeContract).availableBalanceOf(futuresAssets[assetHash].baseToken, user) < safeMul(safeAdd(marginToAdd, addMarginFee), 1e10)) revert();\r\n\r\n        // reserve additional margin and subtract fee from user\r\n        subBalanceAddReserve(futuresAssets[assetHash].baseToken, user, safeMul(addMarginFee, 1e10), marginToAdd);\r\n\r\n        // add margin to position\r\n        updatePositionSize(positionHash, pos[0], pos[1], safeAdd(pos[4], marginToAdd));\r\n\r\n        // add fee to feeAccount\r\n        addBalance(futuresAssets[assetHash].baseToken, feeAccount, DMEX_Base(exchangeContract).balanceOf(futuresAssets[assetHash].baseToken, feeAccount), safeMul(addMarginFee, 1e10));\r\n    \r\n        emit FuturesMarginAdded(user, futuresContractHash, side, marginToAdd);\r\n    }\r\n\r\n    // Settle positions for closed contracts\r\n    function batchSettlePositions (\r\n        bytes32[] futuresContracts,\r\n        bool[] sides,\r\n        address[] users,\r\n        address[] pools\r\n    ) onlyAdmin {\r\n        \r\n        for (uint i = 0; i < futuresContracts.length; i++) \r\n        {\r\n            closeFuturesPositionForUser(futuresContracts[i], sides[i], users[i], pools[i]);\r\n        }\r\n    }\r\n\r\n    // // Liquidate positions\r\n    // function batchLiquidatePositions (\r\n    //     bytes32[] futuresContracts,\r\n    //     address[] users,\r\n    //     bool[] side,\r\n    //     uint256[] priceBlockNumber,\r\n    //     address[] poolAddress\r\n    // ) onlyAdmin {        \r\n    //     for (uint i = 0; i < futuresContracts.length; i++) \r\n    //     {\r\n    //         liquidatePositionWithAssetPrice(futuresContracts[i], users[i], side[i], priceBlockNumber[i], poolAddress[i]);\r\n    //     }\r\n    // }\r\n\r\n    function liquidatePositionWithClosingPrice(bytes32 futuresContractHash, address user, bool side, address poolAddress) private\r\n    {\r\n        bytes32 positionHash = generatePositionHash(user, futuresContractHash, side);\r\n        liquidatePosition(positionHash, futuresContractHash, user, side, futuresContracts[futuresContractHash].closingPrice, poolAddress, futuresContracts[futuresContractHash].closingBlock);\r\n    }\r\n\r\n    function liquidatePositionWithAssetPrice(bytes32 futuresContractHash, address user, bool side, uint256 priceBlockNumber, address poolAddress) onlyAdmin\r\n    {\r\n        bytes32 assetHash = futuresContracts[futuresContractHash].asset;\r\n        if (assetPrices[assetHash][priceBlockNumber] == 0) return;\r\n\r\n        bytes32 positionHash = generatePositionHash(user, futuresContractHash, side);\r\n\r\n        // check that the price is older than postion\r\n        if (priceBlockNumber < retrievePosition(positionHash)[3]) return;  \r\n\r\n        liquidatePosition(positionHash, futuresContractHash, user, side, assetPrices[assetHash][priceBlockNumber], poolAddress, priceBlockNumber);\r\n    }\r\n\r\n    function liquidatePosition (bytes32 positionHash, bytes32 futuresContractHash, address user, bool side, uint256 price, address poolAddress, uint256 block) private\r\n    {\r\n        uint256[5] memory pos = retrievePosition(positionHash);\r\n        if (pos[0] == 0) return;\r\n        if (!pools[poolAddress]) return;      \r\n\r\n        bytes32 assetHash = futuresContracts[futuresContractHash].asset;  \r\n\r\n\r\n        uint256 collateral = pos[4];\r\n        uint256 fundingBlocks = safeSub(block, pos[3]);\r\n        \r\n        uint256 maintenanceMargin = futuresAssets[assetHash].maintenanceMargin;\r\n        uint256 fundingRate = futuresContracts[futuresContractHash].fundingRate;\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n\r\n        uint256 liquidationPrice = calculateLiquidationPrice(pos, [fundingBlocks, fundingRate, maintenanceMargin, multiplier]);\r\n\r\n        //LogUint(5, liquidationPrice);\r\n\r\n        // get block price\r\n        if (( side && price > liquidationPrice)\r\n        ||  (!side && price < liquidationPrice))\r\n        {\r\n            emit LogError(uint8(Errors.LIQUIDATION_PRICE_NOT_TOUCHED), futuresContractHash, positionHash);\r\n            return; \r\n        }\r\n\r\n        // deduct collateral from user account\r\n        subBalanceSubReserve(futuresAssets[assetHash].baseToken, user, safeMul(collateral, 1e10), collateral);\r\n\r\n        // send collateral to pool address\r\n        addBalance(futuresAssets[assetHash].baseToken, poolAddress, DMEX_Base(exchangeContract).balanceOf(futuresAssets[assetHash].baseToken, poolAddress), safeMul(collateral, 1e10));\r\n    \r\n        updatePositionSize(positionHash, 0, 0, 0); \r\n\r\n        emit PositionLiquidated(positionHash, price);\r\n    }\r\n\r\n    struct LiquidationPriceValues {\r\n        uint256 size;\r\n        uint256 price;\r\n        uint256 baseCollateral;\r\n    }\r\n\r\n    function calculateLiquidationPriceFromPositionHash (bytes32 futuresContractHash, bool side, address user) returns (uint256)\r\n    {\r\n        bytes32 positionHash = keccak256(this, user, futuresContractHash, side);      \r\n        uint256[5] memory pos = retrievePosition(positionHash);\r\n\r\n        if (pos[0] == 0) return;\r\n\r\n        uint256 fundingRate = futuresContracts[futuresContractHash].fundingRate;\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n        uint256 maintenanceMargin = futuresAssets[futuresContracts[futuresContractHash].asset].maintenanceMargin;\r\n\r\n        return calculateLiquidationPrice (pos, [safeSub(block.number, pos[3]), fundingRate, maintenanceMargin, multiplier]);\r\n    }\r\n\r\n    function calculateLiquidationPrice(uint256[5] pos, uint256[4] values) public view returns (uint256)\r\n    {\r\n    \r\n        /*\r\n            values\r\n            [0] fundingBlocks \r\n            [1] fundingRate\r\n            [2] maintenanceMargin \r\n            [3] multiplier\r\n        */\r\n        LiquidationPriceValues memory v = LiquidationPriceValues({\r\n            size: pos[0],\r\n            price: pos[1],\r\n            baseCollateral: pos[4]\r\n        });\r\n        \r\n        uint256 collateral = safeMul(v.baseCollateral, 1e8) / values[3];\r\n        \r\n        \r\n        uint256 leverage = safeMul(v.price,v.size)/collateral/1e8;\r\n        uint256 coef = safeMul(values[2], 1e10)/leverage;\r\n        \r\n        uint256 fundingCost = safeMul(safeMul(safeMul(v.size, v.price)/1e8, values[0]), values[1])/1e18;\r\n        \r\n        uint256 netLiqPrice;\r\n        uint256 liquidationPrice;\r\n        \r\n        uint256 movement = safeMul(safeSub(collateral, fundingCost), 1e8)/v.size;\r\n        \r\n        \r\n        if (pos[2] == 0)\r\n        {\r\n        \r\n            netLiqPrice = safeAdd(v.price, movement);\r\n            liquidationPrice = safeSub(netLiqPrice, safeMul(v.price, coef)/1e18); \r\n        }\r\n        else\r\n        {\r\n            netLiqPrice = safeSub(v.price, movement);\r\n            liquidationPrice = safeAdd(netLiqPrice, safeMul(v.price, coef)/1e18); \r\n        }        \r\n        \r\n        return liquidationPrice;\r\n    }\r\n\r\n\r\n    // Returns the smaller of two values\r\n    function min(uint a, uint b) private pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    // Returns the largest of the two values\r\n    function max(uint a, uint b) private pure returns (uint) {\r\n        return a > b ? a : b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"assertion\",\"type\":\"bool\"}],\"name\":\"assert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getContractPriceUrl\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DmexOracleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"makerFee_\",\"type\":\"uint256\"},{\"name\":\"takerFee_\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"calculateLiquidationPriceFromPositionHash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"recordLatestAssetPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"baseToken\",\"type\":\"address\"},{\"name\":\"priceUrl\",\"type\":\"string\"},{\"name\":\"pricePath\",\"type\":\"string\"},{\"name\":\"maintenanceMargin\",\"type\":\"uint256\"},{\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"createFuturesAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getContractPricePath\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastActiveTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetHash\",\"type\":\"bytes32\"}],\"name\":\"assetPricePath\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getAssetDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"validateUint48\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"takerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"futuresContracts\",\"outputs\":[{\"name\":\"asset\",\"type\":\"bytes32\"},{\"name\":\"expirationBlock\",\"type\":\"uint256\"},{\"name\":\"closingPrice\",\"type\":\"uint256\"},{\"name\":\"closed\",\"type\":\"bool\"},{\"name\":\"broken\",\"type\":\"bool\"},{\"name\":\"multiplier\",\"type\":\"uint256\"},{\"name\":\"fundingRate\",\"type\":\"uint256\"},{\"name\":\"closingBlock\",\"type\":\"uint256\"},{\"name\":\"perpetual\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"positions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"validateUint128\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"marginToAdd\",\"type\":\"uint64\"}],\"name\":\"addMargin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"closeFuturesPositionForUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getContractClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"priceBlockNumber\",\"type\":\"uint256\"},{\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"liquidatePositionWithAssetPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetHash\",\"type\":\"bytes32\"}],\"name\":\"assetPriceUrl\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"fundingBlocks\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"calculateFundingCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"out\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"asset\",\"type\":\"bytes32\"},{\"name\":\"expirationBlock\",\"type\":\"uint256\"},{\"name\":\"multiplier\",\"type\":\"uint256\"},{\"name\":\"fundingRate\",\"type\":\"uint256\"},{\"name\":\"perpetual\",\"type\":\"bool\"}],\"name\":\"createFuturesContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assetPrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getContractExpiration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContracts\",\"type\":\"bytes32[]\"},{\"name\":\"sides\",\"type\":\"bool[]\"},{\"name\":\"users\",\"type\":\"address[]\"},{\"name\":\"pools\",\"type\":\"address[]\"}],\"name\":\"batchSettlePositions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setClosingPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8[2]\"},{\"name\":\"rs\",\"type\":\"bytes32[4]\"},{\"name\":\"tradeValues\",\"type\":\"uint256[11]\"},{\"name\":\"tradeAddresses\",\"type\":\"address[2]\"},{\"name\":\"takerIsBuying\",\"type\":\"bool\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"futuresTrade\",\"outputs\":[{\"name\":\"filledTakerTokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getMaintenanceMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pools\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"makerPositionHash\",\"type\":\"bytes32\"},{\"name\":\"makerInversePositionHash\",\"type\":\"bytes32\"},{\"name\":\"takerPosition\",\"type\":\"bytes32\"},{\"name\":\"takerInversePosition\",\"type\":\"bytes32\"}],\"name\":\"getMakerTakerPositions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[5][4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"forceReleaseReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"closingPrice\",\"type\":\"uint256\"},{\"name\":\"entryPrice\",\"type\":\"uint256\"},{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"}],\"name\":\"calculateLoss\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"}],\"name\":\"generatePositionHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"closeFuturesPosition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"closingPrice\",\"type\":\"uint256\"},{\"name\":\"entryPrice\",\"type\":\"uint256\"},{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"}],\"name\":\"calculateProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"calculateTradeValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getContractBaseToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8[2][]\"},{\"name\":\"rs\",\"type\":\"bytes32[4][]\"},{\"name\":\"tradeValues\",\"type\":\"uint256[11][]\"},{\"name\":\"tradeAddresses\",\"type\":\"address[2][]\"},{\"name\":\"boolValues\",\"type\":\"bool[2][]\"},{\"name\":\"assetHash\",\"type\":\"bytes32[]\"},{\"name\":\"contractValues\",\"type\":\"uint256[3][]\"}],\"name\":\"batchFuturesTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"leverage\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"calculateCollateral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"validateUint64\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"currQty\",\"type\":\"uint256\"},{\"name\":\"newQty\",\"type\":\"uint256\"},{\"name\":\"margin\",\"type\":\"uint256\"}],\"name\":\"calculateProportionalMargin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"futuresAssets\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"baseToken\",\"type\":\"address\"},{\"name\":\"priceUrl\",\"type\":\"string\"},{\"name\":\"pricePath\",\"type\":\"string\"},{\"name\":\"disabled\",\"type\":\"bool\"},{\"name\":\"maintenanceMargin\",\"type\":\"uint256\"},{\"name\":\"decimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"tradePrice\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"calculateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetHash\",\"type\":\"bytes32\"}],\"name\":\"assetDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"positionHash\",\"type\":\"bytes32\"}],\"name\":\"retrievePosition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"maker\",\"type\":\"bool\"},{\"name\":\"takerIsBuying\",\"type\":\"bool\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"tradeValues\",\"type\":\"uint256[11]\"}],\"name\":\"generateOrderHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pos\",\"type\":\"uint256[5]\"},{\"name\":\"values\",\"type\":\"uint256[4]\"}],\"name\":\"calculateLiquidationPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"makerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"feeAccount_\",\"type\":\"address\"},{\"name\":\"makerFee_\",\"type\":\"uint256\"},{\"name\":\"takerFee_\",\"type\":\"uint256\"},{\"name\":\"exchangeContract_\",\"type\":\"address\"},{\"name\":\"DmexOracleContract_\",\"type\":\"address\"},{\"name\":\"poolAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"SetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"side\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"size\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"makerOrderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"takerOrderHash\",\"type\":\"bytes32\"}],\"name\":\"FuturesTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"positionHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"closingPrice\",\"type\":\"uint256\"}],\"name\":\"FuturesPositionClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"side\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"FuturesForcedRelease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"futuresAsset\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"baseToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"priceUrl\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"pricePath\",\"type\":\"string\"}],\"name\":\"FuturesAssetCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"asset\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"expirationBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"multiplier\",\"type\":\"uint256\"}],\"name\":\"FuturesContractCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"positionHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PositionLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"side\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"marginToAdd\",\"type\":\"uint64\"}],\"name\":\"FuturesMarginAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"makerFee\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"takerFee\",\"type\":\"uint256\"}],\"name\":\"FeeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"errorId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"makerOrderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"takerOrderHash\",\"type\":\"bytes32\"}],\"name\":\"LogError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogUint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"bytes32\"}],\"name\":\"LogBytes\",\"type\":\"event\"}]","ContractName":"Exchange","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000095445852148540acb6fcb9e39856d15f1c41638100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008e1bc9bf0400000000000000000000000000090689d78b9515ffeed347f129ff48dffe2e7cc40000000000000000000000000dae01b18387824e4abf3d7569548965350ef70ca0000000000000000000000000a24bde9d7618f9b745036fe0a7b57c7451ed724","Library":"","LicenseType":"GNU GPLv2","SwarmSource":"bzzr://4b7d266e9d0f9188853ef8d79272ad3aacd49639a85e52ed787c9e7046f6e675"}]}