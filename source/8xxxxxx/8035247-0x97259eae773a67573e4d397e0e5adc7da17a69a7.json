{"status":"1","message":"OK","result":[{"SourceCode":"{\"Blacklistable.sol\":{\"content\":\"pragma solidity ^0.5.1;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Blacklistable Token\\n * @dev Allows accounts to be blacklisted by a \\\"blacklister\\\" role\\n*/\\ncontract Blacklistable is Ownable {\\n\\n    address public blacklister;\\n    mapping(address =\\u003e bool) internal blacklisted;\\n\\n    event Blacklisted(address indexed _account);\\n    event UnBlacklisted(address indexed _account);\\n    event BlacklisterChanged(address indexed newBlacklister);\\n\\n    /**\\n     * @dev Throws if called by any account other than the blacklister\\n    */\\n    modifier onlyBlacklister() {\\n        require(msg.sender == blacklister);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if argument account is blacklisted\\n     * @param _account The address to check\\n    */\\n    modifier notBlacklisted(address _account) {\\n        require(blacklisted[_account] == false);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Checks if account is blacklisted\\n     * @param _account The address to check\\n    */\\n    function isBlacklisted(address _account) public view returns (bool) {\\n        return blacklisted[_account];\\n    }\\n\\n    /**\\n     * @dev Adds account to blacklist\\n     * @param _account The address to blacklist\\n    */\\n    function blacklist(address _account) public onlyBlacklister {\\n        blacklisted[_account] = true;\\n        emit Blacklisted(_account);\\n    }\\n\\n    /**\\n     * @dev Removes account from blacklist\\n     * @param _account The address to remove from the blacklist\\n    */\\n    function unBlacklist(address _account) public onlyBlacklister {\\n        blacklisted[_account] = false;\\n        emit UnBlacklisted(_account);\\n    }\\n\\n    function updateBlacklister(address _newBlacklister) public onlyOwner {\\n        require(_newBlacklister != address(0));\\n        blacklister = _newBlacklister;\\n        emit BlacklisterChanged(blacklister);\\n    }\\n}\\n\"},\"ECDSA.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * (.note) This call _does not revert_ if the signature is invalid, or\\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\\n     * the zero address is returned.\\n     *\\n     * (.warning) `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise)\\n     * be too long), and then calling `toEthSignedMessageHash` on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            return (address(0));\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 \\u003c s \\u003c secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) \\u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return address(0);\\n        }\\n\\n        if (v != 27 \\u0026\\u0026 v != 28) {\\n            return address(0);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        return ecrecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * [`eth_sign`](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign)\\n     * JSON-RPC method.\\n     *\\n     * See `recover`.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.1;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     * @notice Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"Pausable.sol\":{\"content\":\"pragma solidity ^0.5.1;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Pausable\\n * @dev Base contract which allows children to implement an emergency stop mechanism.\\n * Based on openzeppelin tag v1.10.0 commit: feb665136c0dae9912e08397c1a21c4af3651ef3\\n * Modifications:\\n * 1) Added pauser role, switched pause/unpause to be onlyPauser (6/14/2018)\\n * 2) Removed whenNotPause/whenPaused from pause/unpause (6/14/2018)\\n * 3) Removed whenPaused (6/14/2018)\\n * 4) Switches ownable library to use zeppelinos (7/12/18)\\n * 5) Remove constructor (7/13/18)\\n */\\ncontract Pausable is Ownable {\\n  event Pause();\\n  event Unpause();\\n  event PauserChanged(address indexed newAddress);\\n\\n\\n  address public pauser;\\n  bool public paused = false;\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev throws if called by any account other than the pauser\\n   */\\n  modifier onlyPauser() {\\n    require(msg.sender == pauser);\\n    _;\\n  }\\n\\n  /**\\n   * @dev called by the owner to pause, triggers stopped state\\n   */\\n  function pause() onlyPauser public {\\n    paused = true;\\n    emit Pause();\\n  }\\n\\n  /**\\n   * @dev called by the owner to unpause, returns to normal state\\n   */\\n  function unpause() onlyPauser public {\\n    paused = false;\\n    emit Unpause();\\n  }\\n\\n  /**\\n   * @dev update the pauser role\\n   */\\n  function updatePauser(address _newPauser) onlyOwner public {\\n    require(_newPauser != address(0));\\n    pauser = _newPauser;\\n    emit PauserChanged(pauser);\\n  }\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * lopiddyuirt\\n * Math` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\"},\"uCAD.sol\":{\"content\":\"/**\\nuCAD is a Canadian Dollar Fiat Token developed and released by uFiats,\\na UCASH Network initiative.  uCAD and other uFiats are used as\\ntokenized gift certificate currency units which are purchasable\\nand sellable through a global converter network.\\n\\nUCASH Network partners, smart-contract Dapps, services,\\ninitiatives and other 3rd parties can use uFiats to provide\\na range of digital financial services.\\n*/\\n\\npragma solidity ^0.5.1;\\n\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./Ownable.sol\\u0027;\\nimport \\u0027./Blacklistable.sol\\u0027;\\nimport \\u0027./Pausable.sol\\u0027;\\nimport \\u0027./ECDSA.sol\\u0027;\\n\\n/**\\n * @title uCAD Fiat Token\\n * @dev ERC20 Token backed by fiat reserves\\n */\\n\\n\\ncontract uCAD is IERC20, Ownable, Pausable, Blacklistable {\\n    using SafeMath for uint256;\\n\\n    string public name = \\\"uCAD Fiat Token\\\";\\n    string public symbol = \\\"uCAD\\\";\\n    uint8 public decimals = 18;\\n    string public currency = \\\"CAD\\\";\\n    address public masterCreator;\\n\\n    mapping(address =\\u003e uint256) private balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private allowed;\\n    uint256 public totalSupply = 0;\\n\\n    mapping(address =\\u003e bool) internal creators;\\n    mapping(address =\\u003e uint256) internal creatorAllowed;\\n\\n    mapping(address=\\u003e uint256) internal metaNonces;\\n\\n    event Create(address indexed creator, address indexed to, uint256 amount);\\n    event Destroy(address indexed destroyer, uint256 amount);\\n    event CreatorConfigured(address indexed creator, uint256 creatorAllowedAmount);\\n    event CreatorRemoved(address indexed oldCreator);\\n    event MasterCreatorChanged(address indexed newMasterCreator);\\n\\n    constructor() public {\\n        masterCreator = msg.sender;\\n        pauser = msg.sender;\\n        blacklister = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than a creator\\n    */\\n    modifier onlyCreators() {\\n        require(creators[msg.sender] == true);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Function to create tokens\\n     * @param _to The address that will receive the createed tokens.\\n     * @param _amount The amount of tokens to create. Must be less than or equal to the creatorAllowance of the caller.\\n     * @return A boolean that indicates if the operation was successful.\\n    */\\n    function create(address _to, uint256 _amount) whenNotPaused onlyCreators notBlacklisted(msg.sender) notBlacklisted(_to) public returns (bool) {\\n        require(_to != address(0));\\n        require(_amount \\u003e 0);\\n\\n        uint256 creatingAllowedAmount = creatorAllowed[msg.sender];\\n        require(_amount \\u003c= creatingAllowedAmount);\\n\\n        totalSupply = totalSupply.add(_amount);\\n        balances[_to] = balances[_to].add(_amount);\\n        creatorAllowed[msg.sender] = creatingAllowedAmount.sub(_amount);\\n        emit Create(msg.sender, _to, _amount);\\n        emit Transfer(address(0x0), _to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the masterCreator\\n    */\\n    modifier onlyMasterCreator() {\\n        require(msg.sender == masterCreator);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Get creator allowance for an account\\n     * @param creator The address of the creator\\n    */\\n    function creatorAllowance(address creator) public view returns (uint256) {\\n        return creatorAllowed[creator];\\n    }\\n\\n    /**\\n     * @dev Checks if account is a creator\\n     * @param account The address to check\\n    */\\n    function isCreator(address account) public view returns (bool) {\\n        return creators[account];\\n    }\\n\\n    /**\\n     * @dev Function to add/update a new creator\\n     * @param creator The address of the creator\\n     * @param creatorAllowedAmount The reatingc amount allowed for the creator\\n     * @return True if the operation was successful.\\n    */\\n    function configureCreator(address creator, uint256 creatorAllowedAmount) whenNotPaused onlyMasterCreator public returns (bool) {\\n        creators[creator] = true;\\n        creatorAllowed[creator] = creatorAllowedAmount;\\n        emit CreatorConfigured(creator, creatorAllowedAmount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to remove a creator\\n     * @param creator The address of the creator to remove\\n     * @return True if the operation was successful.\\n    */\\n    function removeCreator(address creator) onlyMasterCreator public returns (bool) {\\n        creators[creator] = false;\\n        creatorAllowed[creator] = 0;\\n        emit CreatorRemoved(creator);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev allows a creator to destroy some of its own tokens\\n     * Validates that caller is a creator and that sender is not blacklisted\\n     * amount is less than or equal to the creator\\u0027s account balance\\n     * @param _amount uint256 the amount of tokens to be destroyed\\n    */\\n    function destroy(uint256 _amount) whenNotPaused onlyCreators notBlacklisted(msg.sender) public {\\n        uint256 balance = balances[msg.sender];\\n        require(_amount \\u003e 0);\\n        require(balance \\u003e= _amount);\\n\\n        totalSupply = totalSupply.sub(_amount);\\n        balances[msg.sender] = balance.sub(_amount);\\n        emit Destroy(msg.sender, _amount);\\n        emit Transfer(msg.sender, address(0), _amount);\\n    }\\n\\n  /**\\n     * @dev allows masterCreator to allocate role to another address\\n     * Validates that caller is the current masterCreator\\n     * @param _newMasterCreator address the address to allocate role to\\n   */\\n\\n    function updateMasterCreator(address _newMasterCreator) onlyOwner public {\\n        require(_newMasterCreator != address(0));\\n        masterCreator = _newMasterCreator;\\n        emit MasterCreatorChanged(masterCreator);\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param owner The address to query the balance of.\\n     * @return A uint256 representing the amount owned by the passed address.\\n     */\\n    function balanceOf(address owner) public view returns (uint256) {\\n        return balances[owner];\\n    }\\n\\n    /**\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n     * @param owner address The address which owns the funds.\\n     * @param spender address The address which will spend the funds.\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return allowed[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Transfer token to a specified address.\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function transfer(address to, uint256 value) public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n     * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Transfer tokens from one address to another.\\n     * Note that while this function emits an Approval event, this is not required as per the specification,\\n     * and other compliant implementations may not emit the event.\\n     * @param from address The address which you want to send tokens from\\n     * @param to address The address which you want to transfer to\\n     * @param value uint256 the amount of tokens to be transferred\\n     */\\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n        _transfer(from, to, value);\\n        _approve(from, msg.sender, allowed[from][msg.sender].sub(value));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param addedValue The amount of tokens to increase the allowance by.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, allowed[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\n     * the first transaction is mined)\\n     * From MonolithDAO Token.sol\\n     * Emits an Approval event.\\n     * @param spender The address which will spend the funds.\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, allowed[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev gets the payload to sign when a user wants to do a metaTransfer\\n     * @param _from uint256 address of the transferer\\n     * @param _to uint256 address of the recipient\\n     * @param value uint256 the amount of tokens to be transferred\\n     * @param fee uint256 the fee paid to the relayer in uCAD\\n     * @param nonce uint256 the metaNonce of the usere\\u0027s metatransaction\\n    */\\n  function getTransferPayload(\\n        address _from,\\n        address _to,\\n        uint256 value,\\n        uint256 fee,\\n        uint256 nonce\\n    ) public\\n    view\\n    returns (bytes32 payload)\\n  {\\n    return ECDSA.toEthSignedMessageHash(\\n      keccak256(abi.encodePacked(\\n        \\\"transfer\\\",     // function specfic text\\n        _from,          // transferer.\\n        _to,            // recipient\\n        address(this),  // Token address (replay protection).\\n        value,          // Number of tokens.\\n        fee,            // fee paid to metaTransfer relayer, in uCAD\\n        nonce           // Local sender specific nonce (replay protection).\\n      ))\\n    );\\n  }\\n\\n\\n/**\\n     * @dev gets the payload to sign when a user wants to do a metaApprove\\n     * @param _from uint256 address of the approver\\n     * @param _to uint256 address of the approvee\\n     * @param value uint256 the amount of tokens to be approved\\n     * @param fee uint256 the fee paid to the relayer in uCAD\\n     * @param metaNonce uint256 the metaNonce of the usere\\u0027s metatransaction\\n    */\\n    function getApprovePayload(\\n        address _from,\\n        address _to,\\n        uint256 value,\\n        uint256 fee,\\n        uint256 metaNonce\\n    ) public\\n    view\\n    returns (bytes32 payload)\\n  {\\n    return ECDSA.toEthSignedMessageHash(\\n      keccak256(abi.encodePacked(\\n        \\\"approve\\\",      // function specfic text\\n        _from,          // Approver.\\n        _to,            // Approvee\\n        address(this),  // Token address (replay protection).\\n        value,          // Number of tokens.\\n        fee,            // Local sender specific nonce (replay protection).\\n        metaNonce       // fee paid to metaApprove relayer, in uCAD\\n      ))\\n    );\\n  }\\n\\n\\n/**\\n     * @dev gets the payload to sign when a user wants to do a metaTransferFrom\\n     * @param _from uint256 the from address of the approver\\n     * @param _to uint256 address of the recipient\\n     * @param _by uint256 by address of the approvee\\n     * @param value uint256 the amount of tokens to be transferred\\n     * @param fee uint256 the fee paid to the relayer in uCAD\\n     * @param metaNonce uint256 the metaNonce of the usere\\u0027s metatransaction\\n    */\\n    function getTransferFromPayload(\\n        address _from,\\n        address _to,\\n        address _by,\\n        uint256 value,\\n        uint256 fee,\\n        uint256 metaNonce\\n    ) public\\n    view\\n    returns (bytes32 payload)\\n  {\\n    return ECDSA.toEthSignedMessageHash(\\n      keccak256(abi.encodePacked(\\n        \\\"transferFrom\\\",     // function specfic text\\n        _from,              // Approver\\n        _to,                // Recipient\\n        _by,                // Approvee\\n        address(this),      // Token address (replay protection).\\n        value,              // Number of tokens.\\n        fee,                // fee paid to metaApprove relayer, in uCAD\\n        metaNonce           // Local sender specific nonce (replay protection).\\n      ))\\n    );\\n  }\\n\\n  /**\\n     * @dev gets the current metaNonce of an address\\n     * @param sender address of the metaTransaction sender\\n **/\\n  function getMetaNonce(address sender) public view returns (uint256) {\\n    return metaNonces[sender];\\n  }\\n\\n   /**\\n     * @dev extra getter function to potentially satisfy ERC1776\\n     * @param _from address of the metaTransaction sender\\n **/\\n\\n  function meta_nonce(address _from) external view returns (uint256 nonce) {\\n        return metaNonces[_from];\\n    }\\n\\n\\n  /**\\n     * @dev function to validate a signiture with a given address and payload that has been signed\\n **/\\n  function isValidSignature(\\n    address _signer,\\n    bytes32 payload,\\n    bytes memory signature\\n  )\\n    public\\n    pure\\n    returns (bool)\\n  {\\n    return (_signer == ECDSA.recover(\\n      ECDSA.toEthSignedMessageHash(payload),\\n      signature\\n    ));\\n  }\\n /**\\n     * @dev Emitted when metaTransfer is successfully executed\\n     */\\n      event MetaTransfer(address indexed relayer, address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when metaApprove is successfully executed\\n     */\\n    event MetaApproval(address indexed relayer, address indexed owner, address indexed spender, uint256 value);\\n\\n\\n    /**\\n     * @dev metaTransfer function called by relayer which executes a token transfer\\n     * on behalf of the original sender who provided a vaild signature.\\n     * @param _from address of the original sender\\n     * @param _to address of the  recipient\\n     * @param value uint256 amount of uCAD being sent\\n     * @param fee uint256 uCAD fee rewarded to the relayer\\n     * @param metaNonce uint256 metaNonce of the original sender\\n     * @param signature bytes signature provided by original sender\\n     */\\n  function metaTransfer(\\n        address _from,\\n        address _to,\\n        uint256 value,\\n        uint256 fee,\\n        uint256 metaNonce,\\n        bytes memory signature\\n  ) public returns (bool success) {\\n\\n\\n    // Verify and increment nonce.\\n    require(getMetaNonce(_from) == metaNonce);\\n    metaNonces[_from] = metaNonces[_from].add(1);\\n    // Verify signature.\\n    bytes32 payload = getTransferPayload(_from,_to, value, fee, metaNonce);\\n    require(isValidSignature(_from,payload,signature));\\n\\n    require(_from != address(0));\\n\\n    //_transfer(sender,receiver,value);\\n    _transfer(_from,_to,value);\\n    //send Fee to metaTx miner\\n    _transfer(_from,msg.sender,fee);\\n\\n    emit MetaTransfer(msg.sender, _from,_to,value);\\n    return true;\\n  }\\n\\n/**\\n     * @dev metaApprove function called by relayer which executes a token approval\\n     * on behalf of the original sender who provided a vaild signature.\\n     * @param _from address of the original approver\\n     * @param _to address of the  recipient\\n     * @param value uint256 amount of uCAD being sent\\n     * @param fee uint256 uCAD fee rewarded to the relayer\\n     * @param metaNonce uint256 metaNonce of the original approver\\n     * @param signature bytes signature provided by original approver\\n     */\\n    function metaApprove(\\n        address _from,\\n        address _to,\\n        uint256 value,\\n        uint256 fee,\\n        uint256 metaNonce,\\n        bytes memory signature\\n    ) public returns (bool success) {\\n    // Verify and increment nonce.\\n    require(getMetaNonce(_from) == metaNonce);\\n    metaNonces[_from] = metaNonces[_from].add(1);\\n\\n    // Verify signature.\\n    bytes32 payload = getApprovePayload(_from,_to, value, fee,metaNonce);\\n    require(isValidSignature(_from, payload, signature));\\n\\n    require(_from != address(0));\\n\\n    //_approve(sender,receiver,value);\\n    _approve(_from,_to,value);\\n\\n    //send Fee to metaTx miner\\n    _transfer(_from,msg.sender,fee);\\n\\n    emit MetaApproval(msg.sender,_from,_to,value);\\n    return true;\\n    }\\n\\n\\n/**\\n     * @dev metaTransferFrom function called by relayer which executes a token transferFrom\\n     * on behalf of the original sender who provided a vaild signature.\\n     * @param _from address of the original sender\\n     * @param _to address of the  recipient\\n     * @param value uint256 amount of uCAD being sent\\n     * @param fee uint256 uCAD fee rewarded to the relayer\\n     * @param metaNonce uint256 metaNonce of the original sender\\n     * @param signature bytes signature provided by original sender\\n     */\\n    function metaTransferFrom(\\n        address _from,\\n        address _to,\\n        address _by,\\n        uint256 value,\\n        uint256 fee,\\n        uint256 metaNonce,\\n        bytes memory signature\\n        ) public returns(bool){\\n    // Verify and increment nonce.\\n    require(getMetaNonce(_by) == metaNonce);\\n    metaNonces[_by] = metaNonces[_by].add(1);\\n\\n    // Verify signature.\\n    bytes32 payload = getTransferFromPayload(_from,_to,_by, value,fee, metaNonce);\\n    require(isValidSignature(_by, payload, signature));\\n\\n    require(_by != address(0));\\n\\n    //_transfer(sender,receiver,value);\\n    _transfer(_from,_to,value);\\n\\n      //send Fee to metaTx miner\\n    _transfer(_by,msg.sender,fee);\\n\\n    //subtract approved amount by value+fee\\n    _approve(_from, _by, allowed[_from][_by].sub(value));\\n\\n    emit MetaTransfer(msg.sender, _from,_to,value);\\n\\n    return true;\\n    }\\n\\n       /**\\n     * @dev Transfer token for a specified addresses.\\n     * @param from The address to transfer from.\\n     * @param to The address to transfer to.\\n     * @param value The amount to be transferred.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(to != address(0));\\n\\n        balances[from] = balances[from].sub(value);\\n        balances[to] = balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Approve an address to spend another addresses\\u0027 tokens.\\n     * @param owner The address that owns the tokens.\\n     * @param spender The address that will spend the tokens.\\n     * @param value The number of tokens that can be spent.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(spender != address(0));\\n        require(owner != address(0));\\n\\n        allowed[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"meta_nonce\",\"outputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"unBlacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"getTransferPayload\",\"outputs\":[{\"name\":\"payload\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_signer\",\"type\":\"address\"},{\"name\":\"payload\",\"type\":\"bytes32\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPauser\",\"type\":\"address\"}],\"name\":\"updatePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getMetaNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMasterCreator\",\"type\":\"address\"}],\"name\":\"updateMasterCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"metaNonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"metaTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"metaNonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"metaApprove\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_by\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"metaNonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"metaTransferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"creatorAllowedAmount\",\"type\":\"uint256\"}],\"name\":\"configureCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"creatorAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBlacklister\",\"type\":\"address\"}],\"name\":\"updateBlacklister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blacklister\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"removeCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currency\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_by\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"metaNonce\",\"type\":\"uint256\"}],\"name\":\"getTransferFromPayload\",\"outputs\":[{\"name\":\"payload\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"metaNonce\",\"type\":\"uint256\"}],\"name\":\"getApprovePayload\",\"outputs\":[{\"name\":\"payload\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"destroyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Destroy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"creatorAllowedAmount\",\"type\":\"uint256\"}],\"name\":\"CreatorConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldCreator\",\"type\":\"address\"}],\"name\":\"CreatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newMasterCreator\",\"type\":\"address\"}],\"name\":\"MasterCreatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"MetaTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"MetaApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"Blacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"UnBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newBlacklister\",\"type\":\"address\"}],\"name\":\"BlacklisterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"PauserChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"uCAD","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e1e80b295fda89a509d8e06aa74f591ad8d62211018d366a6e2ab3da1d92c741"}]}