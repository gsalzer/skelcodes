{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.5.6 <0.6.0;\r\n\r\n/// @title Shared constants used throughout the Cheeze Wizards contracts\r\ncontract WizardConstants {\r\n    // Wizards normally have their affinity set when they are first created,\r\n    // but for example Exclusive Wizards can be created with no set affinity.\r\n    // In this case the affinity can be set by the owner.\r\n    uint8 internal constant ELEMENT_NOTSET = 0; //000\r\n    // A neutral Wizard has no particular strength or weakness with specific\r\n    // elements.\r\n    uint8 internal constant ELEMENT_NEUTRAL = 1; //001\r\n    // The fire, water and wind elements are used both to reflect an affinity\r\n    // of Elemental Wizards for a specific element, and as the moves a\r\n    // Wizard can make during a duel.\r\n    // Note that if these values change then `moveMask` and `moveDelta` in\r\n    // ThreeAffinityDuelResolver would need to be updated accordingly.\r\n    uint8 internal constant ELEMENT_FIRE = 2; //010\r\n    uint8 internal constant ELEMENT_WATER = 3; //011\r\n    uint8 internal constant ELEMENT_WIND = 4; //100\r\n    uint8 internal constant MAX_ELEMENT = ELEMENT_WIND;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://eips.ethereum.org/EIPS/eip-165\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n\r\ncontract WizardGuildInterfaceId {\r\n    bytes4 internal constant _INTERFACE_ID_WIZARDGUILD = 0x41d4d437;\r\n}\r\n\r\n/// @title The public interface of the Wizard Guild\r\n/// @notice The methods listed in this interface (including the inherited ERC-721 interface),\r\n///         make up the public interface of the Wizard Guild contract. Any contracts that wish\r\n///         to make use of Cheeze Wizard NFTs (such as Cheeze Wizards Tournaments!) should use\r\n///         these methods to ensure they are working correctly with the base NFTs.\r\ncontract WizardGuildInterface is IERC721, WizardGuildInterfaceId {\r\n\r\n    /// @notice Returns the information associated with the given Wizard\r\n    ///         owner - The address that owns this Wizard\r\n    ///         innatePower - The innate power level of this Wizard, set when minted and entirely\r\n    ///               immutable\r\n    ///         affinity - The Elemental Affinity of this Wizard. For most Wizards, this is set\r\n    ///               when they are minted, but some exclusive Wizards are minted with an affinity\r\n    ///               of 0 (ELEMENT_NOTSET). A Wizard with an NOTSET affinity should NOT be able\r\n    ///               to participate in Tournaments. Once the affinity of a Wizard is set to a non-zero\r\n    ///               value, it can never be changed again.\r\n    ///         metadata - A 256-bit hash of the Wizard's metadata, which is stored off chain. This\r\n    ///               contract doesn't specify format of this hash, nor the off-chain storage mechanism\r\n    ///               but, let's be honest, it's probably an IPFS SHA-256 hash.\r\n    ///\r\n    ///         NOTE: Series zero Wizards have one of four Affinities:  Neutral (1), Fire (2), Water (3)\r\n    ///               or Air (4, sometimes called \"Wind\" in the code). Future Wizard Series may have\r\n    ///               additional Affinities, and clients of this API should be prepared for that\r\n    ///               eventuality.\r\n    function getWizard(uint256 id) external view returns (address owner, uint88 innatePower, uint8 affinity, bytes32 metadata);\r\n\r\n    /// @notice Sets the affinity for a Wizard that doesn't already have its elemental affinity chosen.\r\n    ///         Only usable for Exclusive Wizards (all non-Exclusives must have their affinity chosen when\r\n    ///         conjured.) Even Exclusives can't change their affinity once it's been chosen.\r\n    ///\r\n    ///         NOTE: This function can only be called by the series minter, and (therefore) only while the\r\n    ///         series is open. A Wizard that has no affinity when a series is closed will NEVER have an Affinity.\r\n    ///         BTW- This implies that a minter is responsible for either never minting ELEMENT_NOTSET\r\n    ///         Wizards, or having some public mechanism for a Wizard owner to set the Affinity after minting.\r\n    /// @param wizardId The id of the wizard\r\n    /// @param newAffinity The new affinity of the wizard\r\n    function setAffinity(uint256 wizardId, uint8 newAffinity) external;\r\n\r\n    /// @notice A function to be called that conjures a whole bunch of Wizards at once! You know how\r\n    ///         there's \"a pride of lions\", \"a murder of crows\", and \"a parliament of owls\"? Well, with this\r\n    ///         here function you can conjure yourself \"a stench of Cheeze Wizards\"!\r\n    ///\r\n    ///         Unsurprisingly, this method can only be called by the registered minter for a Series.\r\n    /// @param powers the power level of each wizard\r\n    /// @param affinities the Elements of the wizards to create\r\n    /// @param owner the address that will own the newly created Wizards\r\n    function mintWizards(\r\n        uint88[] calldata powers,\r\n        uint8[] calldata affinities,\r\n        address owner\r\n        ) external returns (uint256[] memory wizardIds);\r\n\r\n    /// @notice A function to be called that conjures a series of Wizards in the reserved ID range.\r\n    /// @param wizardIds the ID values to use for each Wizard, must be in the reserved range of the current Series\r\n    /// @param affinities the Elements of the wizards to create\r\n    /// @param powers the power level of each wizard\r\n    /// @param owner the address that will own the newly created Wizards\r\n    function mintReservedWizards(\r\n        uint256[] calldata wizardIds,\r\n        uint88[] calldata powers,\r\n        uint8[] calldata affinities,\r\n        address owner\r\n        ) external;\r\n\r\n    /// @notice Sets the metadata values for a list of Wizards. The metadata for a Wizard can only be set once,\r\n    ///         can only be set by the COO or Minter, and can only be set while the Series is still open. Once\r\n    ///         a Series is closed, the metadata is locked forever!\r\n    /// @param wizardIds the ID values of the Wizards to apply metadata changes to.\r\n    /// @param metadata the raw metadata values for each Wizard. This contract does not define how metadata\r\n    ///         should be interpreted, but it is likely to be a 256-bit hash of a complete metadata package\r\n    ///         accessible via IPFS or similar.\r\n    function setMetadata(uint256[] calldata wizardIds, bytes32[] calldata metadata) external;\r\n\r\n    /// @notice Returns true if the given \"spender\" address is allowed to manipulate the given token\r\n    ///         (either because it is the owner of that token, has been given approval to manage that token)\r\n    function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\r\n\r\n    /// @notice Verifies that a given signature represents authority to control the given Wizard ID,\r\n    ///         reverting otherwise. It handles three cases:\r\n    ///             - The simplest case: The signature was signed with the private key associated with\r\n    ///               an external address that is the owner of this Wizard.\r\n    ///             - The signature was generated with the private key associated with an external address\r\n    ///               that is \"approved\" for working with this Wizard ID. (See the Wizard Guild and/or\r\n    ///               the ERC-721 spec for more information on \"approval\".)\r\n    ///             - The owner or approval address (as in cases one or two) is a smart contract\r\n    ///               that conforms to ERC-1654, and accepts the given signature as being valid\r\n    ///               using its own internal logic.\r\n    ///\r\n    ///        NOTE: This function DOES NOT accept a signature created by an address that was given \"operator\r\n    ///               status\" (as granted by ERC-721's setApprovalForAll() functionality). Doing so is\r\n    ///               considered an extreme edge case that can be worked around where necessary.\r\n    /// @param wizardId The Wizard ID whose control is in question\r\n    /// @param hash The message hash we are authenticating against\r\n    /// @param sig the signature data; can be longer than 65 bytes for ERC-1654\r\n    function verifySignature(uint256 wizardId, bytes32 hash, bytes calldata sig) external view;\r\n\r\n    /// @notice Convenience function that verifies signatures for two wizards using equivalent logic to\r\n    ///         verifySignature(). Included to save on cross-contract calls in the common case where we\r\n    ///         are verifying the signatures of two Wizards who wish to enter into a Duel.\r\n    /// @param wizardId1 The first Wizard ID whose control is in question\r\n    /// @param wizardId2 The second Wizard ID whose control is in question\r\n    /// @param hash1 The message hash we are authenticating against for the first Wizard\r\n    /// @param hash2 The message hash we are authenticating against for the first Wizard\r\n    /// @param sig1 the signature data corresponding to the first Wizard; can be longer than 65 bytes for ERC-1654\r\n    /// @param sig2 the signature data corresponding to the second Wizard; can be longer than 65 bytes for ERC-1654\r\n    function verifySignatures(\r\n        uint256 wizardId1,\r\n        uint256 wizardId2,\r\n        bytes32 hash1,\r\n        bytes32 hash2,\r\n        bytes calldata sig1,\r\n        bytes calldata sig2) external view;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title ERC165Interface\r\n/// @dev https://eips.ethereum.org/EIPS/eip-165\r\ninterface ERC165Interface {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceId The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///      uses less than 30,000 gas.\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// This is kind of a hacky way to expose this constant, but it's the best that Solidity offers!\r\ncontract TournamentInterfaceId {\r\n    bytes4 internal constant _INTERFACE_ID_TOURNAMENT = 0xbd059098;\r\n}\r\n\r\n/// @title Tournament interface, known to GateKeeper\r\ncontract TournamentInterface is TournamentInterfaceId, ERC165Interface {\r\n\r\n    // function enter(uint256 tokenId, uint96 power, uint8 affinity) external payable;\r\n    function revive(uint256 wizardId) external payable;\r\n\r\n    function enterWizards(uint256[] calldata wizardIds, uint88[] calldata powers) external payable;\r\n\r\n    // Returns true if the Tournament is currently running and active.\r\n    function isActive() external view returns (bool);\r\n\r\n    function powerScale() external view returns (uint256);\r\n\r\n    function destroy() external;\r\n}\r\n\r\n\r\n\r\n/// @title Contract that manages addresses and access modifiers for certain operations.\r\n/// @author Dapper Labs Inc. (https://www.dapperlabs.com)\r\ncontract AccessControl {\r\n\r\n    /// @dev The address of the master administrator account that has the power to\r\n    ///      update itself and all of the other administrator addresses.\r\n    ///      The CEO account is not expected to be used regularly, and is intended to\r\n    ///      be stored offline (i.e. a hardware device kept in a safe).\r\n    address public ceoAddress;\r\n\r\n    /// @dev The address of the \"day-to-day\" operator of various privileged\r\n    ///      functions inside the smart contract. Although the CEO has the power\r\n    ///      to replace the COO, the CEO address doesn't actually have the power\r\n    ///      to do \"COO-only\" operations. This is to discourage the regular use\r\n    ///      of the CEO account.\r\n    address public cooAddress;\r\n\r\n    /// @dev The address that is allowed to move money around. Kept separate from\r\n    ///      the COO because the COO address typically lives on an internet-connected\r\n    ///      computer.\r\n    address payable public cfoAddress;\r\n\r\n    // Events to indicate when access control role addresses are updated.\r\n    event CEOTransferred(address previousCeo, address newCeo);\r\n    event COOTransferred(address previousCoo, address newCoo);\r\n    event CFOTransferred(address previousCfo, address newCfo);\r\n\r\n    /// @dev The AccessControl constructor sets the `ceoAddress` to the sender account. Also\r\n    ///      initializes the COO and CFO to the passed values (CFO is optional and can be address(0)).\r\n    /// @param newCooAddress The initial COO address to set\r\n    /// @param newCfoAddress The initial CFO to set (optional)\r\n    constructor(address newCooAddress, address payable newCfoAddress) public {\r\n        _setCeo(msg.sender);\r\n        setCoo(newCooAddress);\r\n\r\n        if (newCfoAddress != address(0)) {\r\n            setCfo(newCfoAddress);\r\n        }\r\n    }\r\n\r\n    /// @notice Access modifier for CEO-only functionality\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress, \"Only CEO\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Access modifier for COO-only functionality\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress, \"Only COO\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Access modifier for CFO-only functionality\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress, \"Only CFO\");\r\n        _;\r\n    }\r\n\r\n    function checkControlAddress(address newController) internal view {\r\n        require(newController != address(0) && newController != ceoAddress, \"Invalid CEO address\");\r\n    }\r\n\r\n    /// @notice Assigns a new address to act as the CEO. Only available to the current CEO.\r\n    /// @param newCeo The address of the new CEO\r\n    function setCeo(address newCeo) external onlyCEO {\r\n        checkControlAddress(newCeo);\r\n        _setCeo(newCeo);\r\n    }\r\n\r\n    /// @dev An internal utility function that updates the CEO variable and emits the\r\n    ///      transfer event. Used from both the public setCeo function and the constructor.\r\n    function _setCeo(address newCeo) private {\r\n        emit CEOTransferred(ceoAddress, newCeo);\r\n        ceoAddress = newCeo;\r\n    }\r\n\r\n    /// @notice Assigns a new address to act as the COO. Only available to the current CEO.\r\n    /// @param newCoo The address of the new COO\r\n    function setCoo(address newCoo) public onlyCEO {\r\n        checkControlAddress(newCoo);\r\n        emit COOTransferred(cooAddress, newCoo);\r\n        cooAddress = newCoo;\r\n    }\r\n\r\n    /// @notice Assigns a new address to act as the CFO. Only available to the current CEO.\r\n    /// @param newCfo The address of the new CFO\r\n    function setCfo(address payable newCfo) public onlyCEO {\r\n        checkControlAddress(newCfo);\r\n        emit CFOTransferred(cfoAddress, newCfo);\r\n        cfoAddress = newCfo;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/// @title WizardPresaleInterface\r\n/// @notice This interface represents the single method that the final tournament and master Wizard contracts\r\n///         will use to import the presale wizards when those contracts have been finalized a released on\r\n///         mainnet. Once all presale Wizards have been absorbed, this temporary pre-sale contract can be\r\n///         destroyed.\r\ncontract WizardPresaleInterface {\r\n\r\n    // See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md on how\r\n    // to calculate this\r\n    bytes4 public constant _INTERFACE_ID_WIZARDPRESALE = 0x4df71efb;\r\n\r\n    /// @notice This function is used to bring a presale Wizard into the final contracts. It can\r\n    ///         ONLY be called by the official gatekeeper contract (as set by the Owner of the presale\r\n    ///         contract). It does a number of things:\r\n    ///            1. Check that the presale Wizard exists, and has not already been absorbed\r\n    ///            2. Transfer the Eth used to create the presale Wizard to the caller\r\n    ///            3. Mark the Wizard as having been absorbed, reclaiming the storage used by the presale info\r\n    ///            4. Return the Wizard information (its owner, minting price, and elemental alignment)\r\n    /// @param id the id of the presale Wizard to be absorbed\r\n    function absorbWizard(uint256 id) external returns (address owner, uint256 power, uint8 affinity);\r\n\r\n    /// @notice A convenience function that allows multiple Wizards to be moved to the final contracts\r\n    ///         simultaneously, works the same as the previous function, but in a batch.\r\n    /// @param ids An array of ids indicating which presale Wizards are to be absorbed\r\n    function absorbWizardMulti(uint256[] calldata ids) external\r\n        returns (address[] memory owners, uint256[] memory powers, uint8[] memory affinities);\r\n\r\n    function powerToCost(uint256 power) public pure returns (uint256 cost);\r\n    function costToPower(uint256 cost) public pure returns (uint256 power);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n\r\n\r\n/// Utility library of inline functions on address payables.\r\n/// Modified from original by OpenZeppelin.\r\ncontract Address {\r\n    /// @notice Returns whether the target address is a contract.\r\n    /// @dev This function will return false if invoked during the constructor of a contract,\r\n    /// as the code is not actually created until after the constructor finishes.\r\n    /// @param account address of the account to check\r\n    /// @return whether the target address is a contract\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) } // solium-disable-line security/no-inline-assembly\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n/// @title The Inaugural Cheeze Wizards Gate Keeper contract\r\n/// @notice The GateKeeper is responsible for determining which Wizards are allowed to enter into\r\n///         a Tournament. This particular GateKeeper is designed to manage the first, official\r\n///         Cheeze Wizards Tournament! It's much more complicated than a typical GateKeeper\r\n///         implementation because it needs to juggle two additional issues that most GateKeepers\r\n///         don't need to deal with: Importing Wizards from the Presale contract and minting tokens\r\n///         to represent newly conjured Wizards.\r\ncontract InauguralGateKeeper is AccessControl, WizardConstants, Address, WizardGuildInterfaceId, TournamentInterfaceId {\r\n    // The Tournament contract.\r\n    TournamentInterface public tournament;\r\n\r\n    // The Wizard guild contract.\r\n    // TODO: Replace with the address of the contract once it's deployed.\r\n    WizardGuildInterface public constant WIZARD_GUILD = WizardGuildInterface(address(0x0d8c864DA1985525e0af0acBEEF6562881827bd5));\r\n\r\n    // The Wizard presale contract.\r\n    WizardPresaleInterface public constant WIZARD_PRESALE = WizardPresaleInterface(address(0));\r\n\r\n    /// @dev The ratio between the cost of a Wizard (in wei) and the power of the Wizard.\r\n    ///      power = cost / MAX_POWER_SCALE\r\n    ///      cost = power * MAX_POWER_SCALE\r\n    uint256 internal constant MAX_POWER_SCALE = 1000;\r\n    uint256 internal tournamentPowerScale;\r\n\r\n    function getTournamentPowerScale() external view returns (uint256) {\r\n        return tournamentPowerScale;\r\n    }\r\n\r\n    /// @dev The constant conversion factor used for elementalWizardIncrement\r\n    uint256 private constant TENTH_BASIS_POINTS = 100000;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // We pack these values together to save storage costs (and since they are all access together)\r\n    struct WizardCosts {\r\n        /// @dev The cost of Neutral Wizards (in wei).\r\n        uint96 neutralWizardCost;\r\n\r\n        /// @dev The cost of the _next_ Elemental Wizard (in wei); increases with each Elemental Wizard\r\n        ///      sold, at the rate defined in `elementalWizardIncrement`\r\n        uint96 elementalWizardCost;\r\n\r\n        /// @dev The increment ratio in cost between sequential Elemental Wizards, multiplied by 100k for\r\n        ///      greater granularity (TENTH_BASIS_POINTS)\r\n        uint32 elementalWizardIncrement;\r\n    }\r\n\r\n    WizardCosts public wizardCosts;\r\n\r\n    /// @param setCooAddress The initial COO address.\r\n    /// @param setCfoAddress The initial CFO address.\r\n    /// @param setNeutralWizardCost The cost of the Neutral Wizards, in wei.\r\n    /// @param setElementalWizardCost The starting cost of the Elemental Wizards, in wei.\r\n    /// @param setElementalWizardIncrement The rate at which the Elemental Wizards cost increases.\r\n    constructor(\r\n        address setCooAddress,\r\n        address payable setCfoAddress,\r\n        uint256 setNeutralWizardCost,\r\n        uint256 setElementalWizardCost,\r\n        uint256 setElementalWizardIncrement)\r\n        public AccessControl(setCooAddress, setCfoAddress)\r\n    {\r\n        wizardCosts = WizardCosts ({\r\n            neutralWizardCost: uint96(setNeutralWizardCost),\r\n            elementalWizardCost: uint96(setElementalWizardCost),\r\n            elementalWizardIncrement: uint32(setElementalWizardIncrement)\r\n        });\r\n    }\r\n\r\n    modifier onlyWizardController(uint256 wizardId) {\r\n        require(WIZARD_GUILD.isApprovedOrOwner(msg.sender, wizardId), \"Must be Wizard controller\");\r\n        _;\r\n    }\r\n\r\n    /// @dev The presale contract will be sending Ether directly to this contract,\r\n    ///      so we need it to have a payable fallback.\r\n    function() external payable {\r\n        require(msg.sender == address(WIZARD_PRESALE) || msg.sender == address(tournament), \"Don't send funds to GateKeeper\");\r\n    }\r\n\r\n    /// @notice Registers the address of the Tournament with the GateKeeper. This can't be passed\r\n    ///         into the constructor, because the Tournament itself needs a reference to the GateKeeper\r\n    ///         in its constructor!\r\n    ///\r\n    ///         NOTE: Technically, most of the functions below should have some kind of modifier\r\n    ///               that ensures that the Tournament is set before they are called, but that\r\n    ///               just adds gas. In practice, multiple draft Gatekeeper contracts may be\r\n    ///               deployed, so what matters is that we call this function before sharing\r\n    ///               the address of this contract publicly. No need to enforce that on chain,\r\n    ///               with its associated gas costs!\r\n    function registerTournament(address setTournament) external onlyCOO {\r\n        require(address(tournament) == address(0), \"Tournament already registered\");\r\n        tournament = TournamentInterface(setTournament);\r\n        require(\r\n            (setTournament != address(0)) &&\r\n            tournament.supportsInterface(_INTERFACE_ID_TOURNAMENT), \"Invalid Tournament\");\r\n\r\n        tournamentPowerScale = tournament.powerScale();\r\n        require(tournamentPowerScale <= MAX_POWER_SCALE, \"Power scale too high\");\r\n    }\r\n\r\n    /// @notice This is it folks, the main event! The way for the world to get new Wizards! Does\r\n    ///         pretty much what it says on the box; let's you conjure a new Wizard with a specified\r\n    ///         elemental affinity. The call must include enough Ether to cover the cost of the new\r\n    ///         Wizard, and any excess is refunded. The power of the Wizard is derived from\r\n    ///         the cost. YOU CAN NOT PAY EXTRA TO RAISE INITIAL POWER LATER. Returns the ID\r\n    ///         of the newly conjured Wizard.\r\n    ///\r\n    ///         While you cannot increase power later, you can conjure some more Wizards!\r\n    /// @param affinity The elemental affinity you want for the Wizard. Valid elements are\r\n    ///        defined in `WizardConstants`, see the constants with names starting `ELEMENT_`.\r\n    ///        ELEMENT_NOTSET is not valid for regular Wizards (unlike Exclusive Wizards).\r\n    function conjureWizard(uint8 affinity) external payable returns (uint256) {\r\n        uint8[] memory affinities = new uint8[](1);\r\n\r\n        affinities[0] = affinity;\r\n\r\n        uint256[] memory wizardIds = conjureWizardMulti(affinities);\r\n\r\n        return wizardIds[0];\r\n    }\r\n\r\n    /// @notice A convenience function that allows you to conjure a whole bunch of Wizards at once! You know how\r\n    ///         there's \"a pride of lions\", \"a murder of crows\", and \"a parliament of owls\"? Well, with this\r\n    ///         here function you can conjure yourself \"a stench of Cheeze Wizards\"!\r\n    /// @dev This function is careful to bundle all of the external calls (_transferRefund() and onERC721Received())\r\n    ///         at the end of the function to limit the risk of reentrancy attacks.\r\n    /// @param affinities The elemental affinities of the Wizards, can mix and match any valid types.\r\n    ///        Valid elements are defined in `WizardConstants`, see the constants with names starting\r\n    ///        `ELEMENT_`. ELEMENT_NOTSET is not valid for regular Wizards (unlike Exclusive Wizards).\r\n    function conjureWizardMulti(uint8[] memory affinities) public payable\r\n            returns (uint256[] memory wizardIds)\r\n    {\r\n        (uint256 totalCost, uint256 contribution, uint88[] memory powers) = _computeWizardPowers(affinities);\r\n\r\n        require(msg.value >= totalCost, \"Insufficient funds\");\r\n\r\n        // Mint the requested Wizards in the guild contract, assigning ownership to the sender\r\n        wizardIds = WIZARD_GUILD.mintWizards(powers, affinities, msg.sender);\r\n\r\n        // Enter the new Wizards into the Tournament\r\n        tournament.enterWizards.value(contribution)(wizardIds, powers);\r\n\r\n        // Ensure the Wizards are being assigned to an ERC-721 aware address (either an external address,\r\n        // or a smart contract that implements onERC721Received()). We must call onERC721Received() for\r\n        // each token minted because it's allowed for an ERC-721 receiving contract to reject the\r\n        // transfer based on the properties of the token.\r\n        if (isContract(msg.sender)) {\r\n            for (uint256 i = 0; i < wizardIds.length; i++) {\r\n                bytes4 transferAccepted = IERC721Receiver(msg.sender).onERC721Received(msg.sender, address(0), wizardIds[i], \"\");\r\n                require(transferAccepted == _ERC721_RECEIVED, \"Contract owner didn't accept ERC721 transfer\");\r\n            }\r\n        }\r\n\r\n        // NOTE: _transferRefund() is only safe if msg.value >= totalCost. See the require() near the\r\n        //       beginning of the function to feel better about this fact.\r\n        _transferRefund(totalCost);\r\n    }\r\n\r\n    /// @notice Allows for the creation of Exclusive Wizards. This can only be done by the COO, who still has\r\n    ///         to pay for the power imbued in these Wizards! Reverts if the owner address is a smart contract\r\n    ///         that is not ERC-721 aware.\r\n    /// @param wizardIds An array of IDs of the Wizards being conjured.\r\n    /// @param powers The power levels of the Wizards, corresponding 1:1 to Wizard IDs.\r\n    /// @param affinities The elemental affinities of the Wizards, corresponding 1:1 to Wizard IDs.\r\n    ///                   Valid elements are defined in `WizardConstants`, see the constants with\r\n    ///                   names starting `ELEMENT_`. ELEMENT_NOTSET is valid for Exclusive Wizards,\r\n    ///                   unlike regular Wizards.\r\n    /// @param owner The recipient address of the newly conjured Cheeze Wizards.\r\n    function conjureExclusiveMulti(\r\n        uint256[] calldata wizardIds,\r\n        uint256[] calldata powers,\r\n        uint8[] calldata affinities,\r\n        address owner\r\n    )\r\n        external payable onlyCOO\r\n    {\r\n        // Ensure the arrays are all of the same length\r\n        require(wizardIds.length == powers.length && powers.length == affinities.length, \"Inconsistent parameter lengths\");\r\n\r\n        uint256 totalCost = 0;\r\n        uint256 contribution = 0;\r\n        uint88[] memory localPowers = new uint88[](powers.length);\r\n\r\n        for (uint256 i = 0; i < powers.length; i++) {\r\n            require(affinities[i] <= MAX_ELEMENT, \"Invalid affinity\");\r\n\r\n            require(powers[i] < (1 << 88), \"Invalid power level\");\r\n            localPowers[i] = uint88(powers[i]);\r\n            uint256 wizardCost = powerToCost(localPowers[i]);\r\n\r\n            totalCost += wizardCost;\r\n            contribution += _potContribution(localPowers[i]);\r\n        }\r\n\r\n        require(msg.value >= totalCost, \"Insufficient funds\");\r\n\r\n        // Mint the requested Wizards via the guild contract\r\n        WIZARD_GUILD.mintReservedWizards(wizardIds, localPowers, affinities, owner);\r\n\r\n        // Enter the new Wizards into the Tournament\r\n        tournament.enterWizards.value(contribution)(wizardIds, localPowers);\r\n\r\n        // Ensure the Wizards are being assigned to an ERC-721 aware address (either an external address,\r\n        // or a smart contract that implements onERC721Received()). We must call onERC721Received for\r\n        // each token minted because it's allowed for an ERC-721 receiving contract to reject the\r\n        // transfer based on the properties of the token.\r\n        if (isContract(owner)) {\r\n            for (uint256 i = 0; i < wizardIds.length; i++) {\r\n                bytes4 transferAccepted = IERC721Receiver(owner).onERC721Received(msg.sender, address(0), wizardIds[i], \"\");\r\n                require(transferAccepted == _ERC721_RECEIVED, \"Contract owner didn't accept ERC721 transfer\");\r\n            }\r\n        }\r\n\r\n        // NOTE: _transferRefund() is only safe if msg.value >= totalCost. See the require() near the\r\n        //       middle of the function to feel better about this fact.\r\n        _transferRefund(totalCost);\r\n    }\r\n\r\n    /// @notice Computes the powers, total cost, and prize pot contribution for an array of new Wizards\r\n    ///         based on the provided affinities. This also checks that the affinity values are valid\r\n    ///         for the Tournament, and updates the elementalWizardCost storage variable as relevant.\r\n    function _computeWizardPowers(uint8[] memory affinities) internal\r\n            returns(uint256 totalCost, uint256 contribution, uint88[] memory powers)\r\n    {\r\n        // Cache the Wizard costs in order to reduce the gas costs from reads and writes to storage.\r\n        uint256 neutralWizardCost = wizardCosts.neutralWizardCost;\r\n        uint256 elementalWizardCost = wizardCosts.elementalWizardCost;\r\n        uint256 elementalWizardIncrement = wizardCosts.elementalWizardIncrement;\r\n\r\n        totalCost = 0;\r\n        contribution = 0;\r\n        powers = new uint88[](affinities.length);\r\n\r\n        for (uint256 i = 0; i < affinities.length; i++) {\r\n            uint8 affinity = affinities[i];\r\n            uint256 wizardCost;\r\n\r\n            require(affinity > ELEMENT_NOTSET && affinity <= MAX_ELEMENT, \"Invalid affinity\");\r\n\r\n            // Determine the price of the Wizard\r\n            if (affinity == ELEMENT_NEUTRAL) {\r\n                wizardCost = neutralWizardCost;\r\n            } else {\r\n                wizardCost = elementalWizardCost;\r\n\r\n                // Update the cost of the next Elemental Wizard\r\n                // NOTE: This math can't overflow because the total Ether supply in wei is well less than\r\n                //       2^128. Multiplying a valid cost in wei by some number <100k\r\n                //       cannot possibly overflow 256 bits. As cost is calculated\r\n                //       ourselves (rather than user provided) we know it must\r\n                //       be in the valid range.\r\n                elementalWizardCost += (elementalWizardCost * elementalWizardIncrement) / TENTH_BASIS_POINTS;\r\n            }\r\n\r\n            powers[i] = costToPower(wizardCost);\r\n\r\n            // IMPORTANT! Mathematically, you'd think we could just compute the pot contribution at the\r\n            // end of the loop, but this risks rounding differences between\r\n            // conjuring Wizards individually compared to conjuring them as a stench.\r\n            contribution += _potContribution(powers[i]);\r\n            totalCost += wizardCost;\r\n        }\r\n\r\n        // Update the cached elemental cost to storage. Conveniently this costs very little if\r\n        // the value isn't actually changed.\r\n        wizardCosts.elementalWizardCost = uint96(elementalWizardCost);\r\n    }\r\n\r\n    /// @notice Absorbs a number of presale Wizards into the final NFT contract, while also entering them into\r\n    ///         the Tournament. Can handle any number of Wizards in a batch BUT THEY MUST ALL HAVE THE SAME OWNER.\r\n    ///         Callable by anyone.\r\n    /// @param wizardIds The IDs of the presale Wizards; note that all Wizards MUST have the same owner.\r\n    function absorbPresaleWizards(uint256[] calldata wizardIds) external {\r\n        // Bulk fetch the Wizards from the presale contract. Note that this will also delete those Wizards from the\r\n        // presale contract, and will also transfer the funds used to purchase those Wizards to this contract.\r\n        // Obviously, a failed require() statement later in this function will undo that transfer and those deletes.\r\n        (\r\n            address[] memory owners,\r\n             uint256[] memory powers,\r\n             uint8[] memory affinities\r\n        ) = WIZARD_PRESALE.absorbWizardMulti(wizardIds);\r\n\r\n        uint256 contribution = 0;\r\n        address theOwner = owners[0];\r\n        uint88[] memory localPowers = new uint88[](powers.length);\r\n\r\n        for (uint256 i = 0; i < powers.length; i++) {\r\n            require(owners[i] == theOwner, \"All Wizards must have same owner\");\r\n            localPowers[i] = uint88(powers[i]);\r\n            contribution += _potContribution(localPowers[i]);\r\n        }\r\n\r\n        // Mint the requested Wizards in the guild contract\r\n        WIZARD_GUILD.mintReservedWizards(wizardIds, localPowers, affinities, theOwner);\r\n\r\n        // Enter the new Wizards into the Tournament\r\n        tournament.enterWizards.value(contribution)(wizardIds, localPowers);\r\n    }\r\n\r\n    /// @notice Revive a tired Wizard so they can duel again. The caller must own\r\n    ///         the Wizard.\r\n    /// @param wizardId The ID of the Wizard to revive.\r\n    function revive(uint256 wizardId) external payable onlyWizardController(wizardId) {\r\n        // We don't need to do any validation here, we can let the Tournament decide\r\n        // if the pot contribution amount derived from msg.value represents a valid\r\n        // power level to use for reviving this Wizard.\r\n        uint88 purchasedPower = costToPower(msg.value);\r\n        uint256 potContributionValue = _potContribution(purchasedPower);\r\n\r\n        tournament.revive.value(potContributionValue)(wizardId);\r\n    }\r\n\r\n    /// @notice Sets the affinity for a Wizard that doesn't already have its elemental affinity chosen.\r\n    ///         As a rule this is only ever expected to apply to Exclusive Wizards, as regular wizards\r\n    ///         have their affinity set when they are conjured.\r\n    function setAffinity(uint256 wizardId, uint8 newAffinity) external onlyWizardController(wizardId) {\r\n        require(newAffinity > ELEMENT_NOTSET && newAffinity <= MAX_ELEMENT, \"Must choose a valid affinity\");\r\n\r\n        // The guild will enforce the Wizard doesn't already have an affinity set.\r\n        WIZARD_GUILD.setAffinity(wizardId, newAffinity);\r\n    }\r\n\r\n    /// @notice Determine the power of a Wizard based on their price.\r\n    /// @param cost The price of the Wizard in wei.\r\n    /// @return The power of the Wizard (cast to uint88).\r\n    function costToPower(uint256 cost) public pure returns (uint88 power) {\r\n        return uint88(cost / MAX_POWER_SCALE);\r\n    }\r\n\r\n    /// @param power The power of the Wizard.\r\n    /// @return The cost of the Wizard in wei.\r\n    function powerToCost(uint88 power) public pure returns (uint256 cost) {\r\n        return power * MAX_POWER_SCALE;\r\n    }\r\n\r\n    /// @notice Computes the number of wei required to be sent to the Tournament\r\n    ///         in order to match a given power level.\r\n    /// @param wizardPower The power level\r\n    /// @return The prize pot contribution necessary to match the given power\r\n    function _potContribution(uint88 wizardPower) internal view returns (uint256) {\r\n        return wizardPower * tournamentPowerScale;\r\n    }\r\n\r\n    /// @notice Allows the CFO to withdraw funds from this contract.\r\n    function withdraw() external onlyCFO {\r\n        // All of the pot contributions go directly into the Tournament contract, so\r\n        // we can safely withdraw everything, with no hold-backs.\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n\r\n    /// @notice Allows the COO to destroy this contract if it's not needed anymore.\r\n    /// @notice Can't be destoryed if the Tournament still exists.\r\n    function destroy() external onlyCOO {\r\n        require(address(this).balance == 0, \"Drain the funds first\");\r\n        require(address(tournament) == address(0), \"Destroy Tournament first\");\r\n\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    /// @notice Allow the COO to destroy the Tournament contract.\r\n    function destroyTournament() external onlyCOO {\r\n        if (address(tournament) != address(0)) {\r\n            require(tournament.isActive() == false, \"Tournament active\");\r\n            tournament.destroy();\r\n            tournament = TournamentInterface(0);\r\n        }\r\n    }\r\n\r\n    /// @notice Utility function that refunds any overpayment to the sender; smart\r\n    ///      enough to only send the excess if the amount we are returning is more than the\r\n    ///      cost of sending it!\r\n    /// @dev Warning! This does not check for underflows (msg.value < actualPrice) - so\r\n    ///      be sure to call this with correct values!\r\n    /// @param actualPrice The actual price owed for the conjured Wizards.\r\n    function _transferRefund(uint256 actualPrice) private {\r\n        uint256 refund = msg.value - actualPrice;\r\n\r\n        // Make sure the amount we're trying to refund is less than the actual cost of sending it!\r\n        // See https://github.com/ethereum/wiki/wiki/Subtleties for magic values costs.  We can\r\n        // safely ignore the 25000 additional gas cost for new accounts, as msg.sender is\r\n        // guaranteed to exist at this point!\r\n        if (refund > (tx.gasprice * (9000+700))) {\r\n            msg.sender.transfer(refund);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wizardIds\",\"type\":\"uint256[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"affinities\",\"type\":\"uint8[]\"},{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"conjureExclusiveMulti\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tournament\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"power\",\"type\":\"uint88\"}],\"name\":\"powerToCost\",\"outputs\":[{\"name\":\"cost\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCfo\",\"type\":\"address\"}],\"name\":\"setCfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WIZARD_PRESALE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"affinity\",\"type\":\"uint8\"}],\"name\":\"conjureWizard\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCeo\",\"type\":\"address\"}],\"name\":\"setCeo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wizardId\",\"type\":\"uint256\"}],\"name\":\"revive\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wizardId\",\"type\":\"uint256\"},{\"name\":\"newAffinity\",\"type\":\"uint8\"}],\"name\":\"setAffinity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"setTournament\",\"type\":\"address\"}],\"name\":\"registerTournament\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCoo\",\"type\":\"address\"}],\"name\":\"setCoo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTournamentPowerScale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wizardCosts\",\"outputs\":[{\"name\":\"neutralWizardCost\",\"type\":\"uint96\"},{\"name\":\"elementalWizardCost\",\"type\":\"uint96\"},{\"name\":\"elementalWizardIncrement\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyTournament\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WIZARD_GUILD\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"affinities\",\"type\":\"uint8[]\"}],\"name\":\"conjureWizardMulti\",\"outputs\":[{\"name\":\"wizardIds\",\"type\":\"uint256[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"costToPower\",\"outputs\":[{\"name\":\"power\",\"type\":\"uint88\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wizardIds\",\"type\":\"uint256[]\"}],\"name\":\"absorbPresaleWizards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"setCooAddress\",\"type\":\"address\"},{\"name\":\"setCfoAddress\",\"type\":\"address\"},{\"name\":\"setNeutralWizardCost\",\"type\":\"uint256\"},{\"name\":\"setElementalWizardCost\",\"type\":\"uint256\"},{\"name\":\"setElementalWizardIncrement\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousCeo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newCeo\",\"type\":\"address\"}],\"name\":\"CEOTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousCoo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newCoo\",\"type\":\"address\"}],\"name\":\"COOTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousCfo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newCfo\",\"type\":\"address\"}],\"name\":\"CFOTransferred\",\"type\":\"event\"}]","ContractName":"InauguralGateKeeper","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d880d895ce716afc1e5e21cb901b5093701842e4000000000000000000000000c09f4f0eae0b92ec1e3d93baeac46d8a5391483b00000000000000000000000000000000000000000000000000f8b0a10e470000000000000000000000000000000000000000000000000000105e7bea83b0908e0000000000000000000000000000000000000000000000000000000000000082","Library":"","LicenseType":"None","SwarmSource":"bzzr://ba3368783d58445cfa9dcff4274ab528423d2cd8e2b2937dc1ade7150f362dc9"}]}