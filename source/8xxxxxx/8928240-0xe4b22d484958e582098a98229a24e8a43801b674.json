{"status":"1","message":"OK","result":[{"SourceCode":"// hevm: flattened sources of /nix/store/nrmi9gk7q94ba1fbhq9bphlbpqd1y8hw-scd-mcd-migration-e730e63/src/MigrationProxyActions.sol\r\npragma solidity =0.5.12 >0.4.13;\r\n\r\n////// /nix/store/nrmi9gk7q94ba1fbhq9bphlbpqd1y8hw-scd-mcd-migration-e730e63/src/Interfaces.sol\r\n/* pragma solidity 0.5.12; */\r\n\r\ncontract GemLike {\r\n    function allowance(address, address) public returns (uint);\r\n    function approve(address, uint) public;\r\n    function transfer(address, uint) public returns (bool);\r\n    function transferFrom(address, address, uint) public returns (bool);\r\n}\r\n\r\ncontract ValueLike {\r\n    function peek() public returns (uint, bool);\r\n}\r\n\r\ncontract SaiTubLike {\r\n    function skr() public view returns (GemLike);\r\n    function gem() public view returns (GemLike);\r\n    function gov() public view returns (GemLike);\r\n    function sai() public view returns (GemLike);\r\n    function pep() public view returns (ValueLike);\r\n    function vox() public view returns (VoxLike);\r\n    function bid(uint) public view returns (uint);\r\n    function ink(bytes32) public view returns (uint);\r\n    function tag() public view returns (uint);\r\n    function tab(bytes32) public returns (uint);\r\n    function rap(bytes32) public returns (uint);\r\n    function draw(bytes32, uint) public;\r\n    function shut(bytes32) public;\r\n    function exit(uint) public;\r\n    function give(bytes32, address) public;\r\n}\r\n\r\ncontract VoxLike {\r\n    function par() public returns (uint);\r\n}\r\n\r\ncontract JoinLike {\r\n    function ilk() public returns (bytes32);\r\n    function gem() public returns (GemLike);\r\n    function dai() public returns (GemLike);\r\n    function join(address, uint) public;\r\n    function exit(address, uint) public;\r\n}\r\ncontract VatLike {\r\n    function ilks(bytes32) public view returns (uint, uint, uint, uint, uint);\r\n    function hope(address) public;\r\n    function frob(bytes32, address, address, address, int, int) public;\r\n}\r\n\r\ncontract ManagerLike {\r\n    function vat() public view returns (address);\r\n    function urns(uint) public view returns (address);\r\n    function open(bytes32, address) public returns (uint);\r\n    function frob(uint, int, int) public;\r\n    function give(uint, address) public;\r\n    function move(uint, address, uint) public;\r\n}\r\n\r\ncontract OtcLike {\r\n    function getPayAmount(address, address, uint) public view returns (uint);\r\n    function buyAllAmount(address, uint, address, uint) public;\r\n}\r\n\r\n////// /nix/store/nrmi9gk7q94ba1fbhq9bphlbpqd1y8hw-scd-mcd-migration-e730e63/src/ScdMcdMigration.sol\r\n/* pragma solidity 0.5.12; */\r\n\r\n/* import { JoinLike, ManagerLike, SaiTubLike, VatLike } from \"./Interfaces.sol\"; */\r\n\r\ncontract ScdMcdMigration {\r\n    SaiTubLike                  public tub;\r\n    VatLike                     public vat;\r\n    ManagerLike                 public cdpManager;\r\n    JoinLike                    public saiJoin;\r\n    JoinLike                    public wethJoin;\r\n    JoinLike                    public daiJoin;\r\n\r\n    constructor(\r\n        address tub_,           // SCD tub contract address\r\n        address cdpManager_,    // MCD manager contract address\r\n        address saiJoin_,       // MCD SAI collateral adapter contract address\r\n        address wethJoin_,      // MCD ETH collateral adapter contract address\r\n        address daiJoin_        // MCD DAI adapter contract address\r\n    ) public {\r\n        tub = SaiTubLike(tub_);\r\n        cdpManager = ManagerLike(cdpManager_);\r\n        vat = VatLike(cdpManager.vat());\r\n        saiJoin = JoinLike(saiJoin_);\r\n        wethJoin = JoinLike(wethJoin_);\r\n        daiJoin = JoinLike(daiJoin_);\r\n\r\n        require(wethJoin.gem() == tub.gem(), \"non-matching-weth\");\r\n        require(saiJoin.gem() == tub.sai(), \"non-matching-sai\");\r\n\r\n        tub.gov().approve(address(tub), uint(-1));\r\n        tub.skr().approve(address(tub), uint(-1));\r\n        tub.sai().approve(address(tub), uint(-1));\r\n        tub.sai().approve(address(saiJoin), uint(-1));\r\n        wethJoin.gem().approve(address(wethJoin), uint(-1));\r\n        daiJoin.dai().approve(address(daiJoin), uint(-1));\r\n        vat.hope(address(daiJoin));\r\n    }\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"add-overflow\");\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"sub-underflow\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\r\n    }\r\n\r\n    function toInt(uint x) internal pure returns (int y) {\r\n        y = int(x);\r\n        require(y >= 0, \"int-overflow\");\r\n    }\r\n\r\n    // Function to swap SAI to DAI\r\n    // This function is to be used by users that want to get new DAI in exchange of old one (aka SAI)\r\n    // wad amount has to be <= the value pending to reach the debt ceiling (the minimum between general and ilk one)\r\n    function swapSaiToDai(\r\n        uint wad\r\n    ) external {\r\n        // Get wad amount of SAI from user's wallet:\r\n        saiJoin.gem().transferFrom(msg.sender, address(this), wad);\r\n        // Join the SAI wad amount to the `vat`:\r\n        saiJoin.join(address(this), wad);\r\n        // Lock the SAI wad amount to the CDP and generate the same wad amount of DAI\r\n        vat.frob(saiJoin.ilk(), address(this), address(this), address(this), toInt(wad), toInt(wad));\r\n        // Send DAI wad amount as a ERC20 token to the user's wallet\r\n        daiJoin.exit(msg.sender, wad);\r\n    }\r\n\r\n    // Function to swap DAI to SAI\r\n    // This function is to be used by users that want to get SAI in exchange of DAI\r\n    // wad amount has to be <= the amount of SAI locked (and DAI generated) in the migration contract SAI CDP\r\n    function swapDaiToSai(\r\n        uint wad\r\n    ) external {\r\n        // Get wad amount of DAI from user's wallet:\r\n        daiJoin.dai().transferFrom(msg.sender, address(this), wad);\r\n        // Join the DAI wad amount to the vat:\r\n        daiJoin.join(address(this), wad);\r\n        // Payback the DAI wad amount and unlocks the same value of SAI collateral\r\n        vat.frob(saiJoin.ilk(), address(this), address(this), address(this), -toInt(wad), -toInt(wad));\r\n        // Send SAI wad amount as a ERC20 token to the user's wallet\r\n        saiJoin.exit(msg.sender, wad);\r\n    }\r\n\r\n    // Function to migrate a SCD CDP to MCD one (needs to be used via a proxy so the code can be kept simpler). Check MigrationProxyActions.sol code for usage.\r\n    // In order to use migrate function, SCD CDP debtAmt needs to be <= SAI previously deposited in the SAI CDP * (100% - Collateralization Ratio)\r\n    function migrate(\r\n        bytes32 cup\r\n    ) external returns (uint cdp) {\r\n        // Get values\r\n        uint debtAmt = tub.tab(cup);    // CDP SAI debt\r\n        uint pethAmt = tub.ink(cup);    // CDP locked collateral\r\n        uint ethAmt = tub.bid(pethAmt); // CDP locked collateral equiv in ETH\r\n\r\n        // Take SAI out from MCD SAI CDP. For this operation is necessary to have a very low collateralization ratio\r\n        // This is not actually a problem as this ilk will only be accessed by this migration contract,\r\n        // which will make sure to have the amounts balanced out at the end of the execution.\r\n        vat.frob(\r\n            bytes32(saiJoin.ilk()),\r\n            address(this),\r\n            address(this),\r\n            address(this),\r\n            -toInt(debtAmt),\r\n            0\r\n        );\r\n        saiJoin.exit(address(this), debtAmt); // SAI is exited as a token\r\n\r\n        // Shut SAI CDP and gets WETH back\r\n        tub.shut(cup);      // CDP is closed using the SAI just exited and the MKR previously sent by the user (via the proxy call)\r\n        tub.exit(pethAmt);  // Converts PETH to WETH\r\n\r\n        // Open future user's CDP in MCD\r\n        cdp = cdpManager.open(wethJoin.ilk(), address(this));\r\n\r\n        // Join WETH to Adapter\r\n        wethJoin.join(cdpManager.urns(cdp), ethAmt);\r\n\r\n        // Lock WETH in future user's CDP and generate debt to compensate the SAI used to paid the SCD CDP\r\n        (, uint rate,,,) = vat.ilks(wethJoin.ilk());\r\n        cdpManager.frob(\r\n            cdp,\r\n            toInt(ethAmt),\r\n            toInt(mul(debtAmt, 10 ** 27) / rate + 1) // To avoid rounding issues we add an extra wei of debt\r\n        );\r\n        // Move DAI generated to migration contract (to recover the used funds)\r\n        cdpManager.move(cdp, address(this), mul(debtAmt, 10 ** 27));\r\n        // Re-balance MCD SAI migration contract's CDP\r\n        vat.frob(\r\n            bytes32(saiJoin.ilk()),\r\n            address(this),\r\n            address(this),\r\n            address(this),\r\n            0,\r\n            -toInt(debtAmt)\r\n        );\r\n\r\n        // Set ownership of CDP to the user\r\n        cdpManager.give(cdp, msg.sender);\r\n    }\r\n}\r\n\r\n////// /nix/store/s6vv2mwc272ak68b4aibr7fhpa85ikw8-ds-math/dapp/ds-math/src/math.sol\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity >0.4.13; */\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n////// /nix/store/nrmi9gk7q94ba1fbhq9bphlbpqd1y8hw-scd-mcd-migration-e730e63/src/MigrationProxyActions.sol\r\n/* pragma solidity 0.5.12; */\r\n\r\n/* import \"ds-math/math.sol\"; */\r\n\r\n/* import { GemLike, JoinLike, OtcLike, SaiTubLike } from \"./Interfaces.sol\"; */\r\n/* import { ScdMcdMigration } from \"./ScdMcdMigration.sol\"; */\r\n\r\n// This contract is intended to be executed via the Profile proxy of a user (DSProxy) which owns the SCD CDP\r\ncontract MigrationProxyActions is DSMath {\r\n    function swapSaiToDai(\r\n        address scdMcdMigration,            // Migration contract address\r\n        uint wad                            // Amount to swap\r\n    ) external {\r\n        GemLike sai = SaiTubLike(ScdMcdMigration(scdMcdMigration).tub()).sai();\r\n        GemLike dai = JoinLike(ScdMcdMigration(scdMcdMigration).daiJoin()).dai();\r\n        sai.transferFrom(msg.sender, address(this), wad);\r\n        if (sai.allowance(address(this), scdMcdMigration) < wad) {\r\n            sai.approve(scdMcdMigration, wad);\r\n        }\r\n        ScdMcdMigration(scdMcdMigration).swapSaiToDai(wad);\r\n        dai.transfer(msg.sender, wad);\r\n    }\r\n\r\n    function swapDaiToSai(\r\n        address scdMcdMigration,            // Migration contract address\r\n        uint wad                            // Amount to swap\r\n    ) external {\r\n        GemLike sai = SaiTubLike(ScdMcdMigration(scdMcdMigration).tub()).sai();\r\n        GemLike dai = JoinLike(ScdMcdMigration(scdMcdMigration).daiJoin()).dai();\r\n        dai.transferFrom(msg.sender, address(this), wad);\r\n        if (dai.allowance(address(this), scdMcdMigration) < wad) {\r\n            dai.approve(scdMcdMigration, wad);\r\n        }\r\n        ScdMcdMigration(scdMcdMigration).swapDaiToSai(wad);\r\n        sai.transfer(msg.sender, wad);\r\n    }\r\n\r\n    function migrate(\r\n        address scdMcdMigration,            // Migration contract address\r\n        bytes32 cup                         // SCD CDP Id to migrate\r\n    ) external returns (uint cdp) {\r\n        SaiTubLike tub = ScdMcdMigration(scdMcdMigration).tub();\r\n        // Get necessary MKR fee and move it to the migration contract\r\n        (uint val, bool ok) = tub.pep().peek();\r\n        if (ok && val != 0) {\r\n            // Calculate necessary value of MKR to pay the govFee\r\n            uint govFee = wdiv(tub.rap(cup), val);\r\n\r\n            // Get MKR from the user's wallet and transfer to Migration contract\r\n            tub.gov().transferFrom(msg.sender, address(scdMcdMigration), govFee);\r\n        }\r\n        // Transfer ownership of SCD CDP to the migration contract\r\n        tub.give(cup, address(scdMcdMigration));\r\n        // Execute migrate function\r\n        cdp = ScdMcdMigration(scdMcdMigration).migrate(cup);\r\n    }\r\n\r\n    function migratePayFeeWithGem(\r\n        address scdMcdMigration,            // Migration contract address\r\n        bytes32 cup,                        // SCD CDP Id to migrate\r\n        address otc,                        // Otc address\r\n        address payGem,                     // Token address to be used for purchasing govFee MKR\r\n        uint maxPayAmt                      // Max amount of payGem to sell for govFee MKR needed\r\n    ) external returns (uint cdp) {\r\n        SaiTubLike tub = ScdMcdMigration(scdMcdMigration).tub();\r\n        // Get necessary MKR fee and move it to the migration contract\r\n        (uint val, bool ok) = tub.pep().peek();\r\n        if (ok && val != 0) {\r\n            // Calculate necessary value of MKR to pay the govFee\r\n            uint govFee = wdiv(tub.rap(cup), val);\r\n\r\n            // Calculate how much payGem is needed for getting govFee value\r\n            uint payAmt = OtcLike(otc).getPayAmount(payGem, address(tub.gov()), govFee);\r\n            // Fails if exceeds maximum\r\n            require(maxPayAmt >= payAmt, \"maxPayAmt-exceeded\");\r\n            // Set allowance, if necessary\r\n            if (GemLike(payGem).allowance(address(this), otc) < payAmt) {\r\n                GemLike(payGem).approve(otc, payAmt);\r\n            }\r\n            // Get payAmt of payGem from user's wallet\r\n            require(GemLike(payGem).transferFrom(msg.sender, address(this), payAmt), \"transfer-failed\");\r\n            // Trade it for govFee amount of MKR\r\n            OtcLike(otc).buyAllAmount(address(tub.gov()), govFee, payGem, payAmt);\r\n            // Transfer govFee amount of MKR to Migration contract\r\n            tub.gov().transfer(address(scdMcdMigration), govFee);\r\n        }\r\n        // Transfer ownership of SCD CDP to the migration contract\r\n        tub.give(cup, address(scdMcdMigration));\r\n        // Execute migrate function\r\n        cdp = ScdMcdMigration(scdMcdMigration).migrate(cup);\r\n    }\r\n\r\n    function _getRatio(\r\n        SaiTubLike tub,\r\n        bytes32 cup\r\n    ) internal returns (uint ratio) {\r\n        ratio = rdiv(\r\n                        rmul(tub.tag(), tub.ink(cup)),\r\n                        rmul(tub.vox().par(), tub.tab(cup))\r\n                    );\r\n    }\r\n\r\n    function migratePayFeeWithDebt(\r\n        address scdMcdMigration,            // Migration contract address\r\n        bytes32 cup,                        // SCD CDP Id to migrate\r\n        address otc,                        // Otc address\r\n        uint maxPayAmt,                     // Max amount of SAI to generate to sell for govFee MKR needed\r\n        uint minRatio                       // Min collateralization ratio after generating new debt (e.g. 180% = 1.8 RAY)\r\n    ) external returns (uint cdp) {\r\n        SaiTubLike tub = ScdMcdMigration(scdMcdMigration).tub();\r\n        // Get necessary MKR fee and move it to the migration contract\r\n        (uint val, bool ok) = tub.pep().peek();\r\n        if (ok && val != 0) {\r\n            // Calculate necessary value of MKR to pay the govFee\r\n            uint govFee = wdiv(tub.rap(cup), val) + 1; // 1 extra wei MKR to avoid any possible rounding issue after drawing new SAI\r\n\r\n            // Calculate how much SAI is needed for getting govFee value\r\n            uint payAmt = OtcLike(otc).getPayAmount(address(tub.sai()), address(tub.gov()), govFee);\r\n            // Fails if exceeds maximum\r\n            require(maxPayAmt >= payAmt, \"maxPayAmt-exceeded\");\r\n            // Get payAmt of SAI from user's CDP\r\n            tub.draw(cup, payAmt);\r\n\r\n            require(_getRatio(tub, cup) > minRatio, \"minRatio-failed\");\r\n\r\n            // Set allowance, if necessary\r\n            if (GemLike(address(tub.sai())).allowance(address(this), otc) < payAmt) {\r\n                GemLike(address(tub.sai())).approve(otc, payAmt);\r\n            }\r\n            // Trade it for govFee amount of MKR\r\n            OtcLike(otc).buyAllAmount(address(tub.gov()), govFee, address(tub.sai()), payAmt);\r\n            // Transfer real needed govFee amount of MKR to Migration contract (it might leave some MKR dust in the proxy contract)\r\n            govFee = wdiv(tub.rap(cup), val);\r\n            tub.gov().transfer(address(scdMcdMigration), govFee);\r\n        }\r\n        // Transfer ownership of SCD CDP to the migration contract\r\n        tub.give(cup, address(scdMcdMigration));\r\n        // Execute migrate function\r\n        cdp = ScdMcdMigration(scdMcdMigration).migrate(cup);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"scdMcdMigration\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"cup\",\"type\":\"bytes32\"}],\"name\":\"migrate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cdp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"scdMcdMigration\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"cup\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"otc\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxPayAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRatio\",\"type\":\"uint256\"}],\"name\":\"migratePayFeeWithDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cdp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"scdMcdMigration\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"cup\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"otc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payGem\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxPayAmt\",\"type\":\"uint256\"}],\"name\":\"migratePayFeeWithGem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cdp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"scdMcdMigration\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"swapDaiToSai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"scdMcdMigration\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"swapSaiToDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MigrationProxyActions","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://3fa449832b0e00300274c9b28c5b21cd213063975397da72a588b0a71fc0b6f4"}]}