{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/interface/ICelerWallet.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n/**\r\n * @title CelerWallet interface\r\n */\r\ninterface ICelerWallet {\r\n    function create(address[] calldata _owners, address _operator, bytes32 _nonce) external returns(bytes32);\r\n\r\n    function depositETH(bytes32 _walletId) external payable;\r\n\r\n    function depositERC20(bytes32 _walletId, address _tokenAddress, uint _amount) external;\r\n    \r\n    function withdraw(bytes32 _walletId, address _tokenAddress, address _receiver, uint _amount) external;\r\n\r\n    function transferToWallet(bytes32 _fromWalletId, bytes32 _toWalletId, address _tokenAddress, address _receiver, uint _amount) external;\r\n\r\n    function transferOperatorship(bytes32 _walletId, address _newOperator) external;\r\n\r\n    function proposeNewOperator(bytes32 _walletId, address _newOperator) external;\r\n\r\n    function drainToken(address _tokenAddress, address _receiver, uint _amount) external;\r\n\r\n    function getWalletOwners(bytes32 _walletId) external view returns(address[] memory);\r\n\r\n    function getOperator(bytes32 _walletId) external view returns(address);\r\n\r\n    function getBalance(bytes32 _walletId, address _tokenAddress) external view returns(uint);\r\n\r\n    function getProposedNewOperator(bytes32 _walletId) external view returns(address);\r\n\r\n    function getProposalVote(bytes32 _walletId, address _owner) external view returns(bool);\r\n\r\n    event CreateWallet(bytes32 indexed walletId, address[] indexed owners, address indexed operator);\r\n\r\n    event DepositToWallet(bytes32 indexed walletId, address indexed tokenAddress, uint amount);\r\n\r\n    event WithdrawFromWallet(bytes32 indexed walletId, address indexed tokenAddress, address indexed receiver, uint amount);\r\n\r\n    event TransferToWallet(bytes32 indexed fromWalletId, bytes32 indexed toWalletId, address indexed tokenAddress, address receiver, uint amount);\r\n\r\n    event ChangeOperator(bytes32 indexed walletId, address indexed oldOperator, address indexed newOperator);\r\n\r\n    event ProposeNewOperator(bytes32 indexed walletId, address indexed newOperator, address indexed proposer);\r\n\r\n    event DrainToken(address indexed tokenAddress, address indexed receiver, uint amount);\r\n}\r\n\r\n// File: contracts/lib/interface/IEthPool.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n/**\r\n * @title EthPool interface\r\n */\r\ninterface IEthPool {\r\n    function deposit(address _receiver) external payable;\r\n\r\n    function withdraw(uint _value) external;\r\n\r\n    function approve(address _spender, uint _value) external returns (bool);\r\n\r\n    function transferFrom(address _from, address payable _to, uint _value) external returns (bool);\r\n\r\n    function transferToCelerWallet(address _from, address _walletAddr, bytes32 _walletId, uint _value) external returns (bool);\r\n\r\n    function increaseAllowance(address _spender, uint _addedValue) external returns (bool);\r\n\r\n    function decreaseAllowance(address _spender, uint _subtractedValue) external returns (bool);\r\n\r\n    function balanceOf(address _owner) external view returns (uint);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint);\r\n\r\n    event Deposit(address indexed receiver, uint value);\r\n    \r\n    // transfer from \"from\" account inside EthPool to real \"to\" address outside EthPool\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n// File: contracts/lib/interface/IPayRegistry.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n/**\r\n * @title PayRegistry interface\r\n */\r\ninterface IPayRegistry {\r\n    function calculatePayId(bytes32 _payHash, address _setter) external pure returns(bytes32);\r\n\r\n    function setPayAmount(bytes32 _payHash, uint _amt) external;\r\n\r\n    function setPayDeadline(bytes32 _payHash, uint _deadline) external;\r\n\r\n    function setPayInfo(bytes32 _payHash, uint _amt, uint _deadline) external;\r\n\r\n    function setPayAmounts(bytes32[] calldata _payHashes, uint[] calldata _amts) external;\r\n\r\n    function setPayDeadlines(bytes32[] calldata _payHashes, uint[] calldata _deadlines) external;\r\n\r\n    function setPayInfos(bytes32[] calldata _payHashes, uint[] calldata _amts, uint[] calldata _deadlines) external;\r\n\r\n    function getPayAmounts(\r\n        bytes32[] calldata _payIds,\r\n        uint _lastPayResolveDeadline\r\n    ) external view returns(uint[] memory);\r\n\r\n    function getPayInfo(bytes32 _payId) external view returns(uint, uint);\r\n\r\n    event PayInfoUpdate(bytes32 indexed payId, uint amount, uint resolveDeadline);\r\n}\r\n\r\n// File: contracts/lib/data/Pb.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// runtime proto sol library\r\nlibrary Pb {\r\n    enum WireType { Varint, Fixed64, LengthDelim, StartGroup, EndGroup, Fixed32 }\r\n\r\n    struct Buffer {\r\n        uint idx;  // the start index of next read. when idx=b.length, we're done\r\n        bytes b;   // hold serialized proto msg, readonly\r\n    }\r\n\r\n    // create a new in-memory Buffer object from raw msg bytes\r\n    function fromBytes(bytes memory raw) internal pure returns (Buffer memory buf) {\r\n        buf.b = raw;\r\n        buf.idx = 0;\r\n    }\r\n\r\n    // whether there are unread bytes\r\n    function hasMore(Buffer memory buf) internal pure returns (bool) {\r\n        return buf.idx < buf.b.length;\r\n    }\r\n\r\n    // decode current field number and wiretype\r\n    function decKey(Buffer memory buf) internal pure returns (uint tag, WireType wiretype) {\r\n        uint v = decVarint(buf);\r\n        tag = v / 8;\r\n        wiretype = WireType(v & 7);\r\n    }\r\n\r\n    // count tag occurrences, return an array due to no memory map support\r\n\t// have to create array for (maxtag+1) size. cnts[tag] = occurrences\r\n\t// should keep buf.idx unchanged because this is only a count function\r\n    function cntTags(Buffer memory buf, uint maxtag) internal pure returns (uint[] memory cnts) {\r\n        uint originalIdx = buf.idx;\r\n        cnts = new uint[](maxtag+1);  // protobuf's tags are from 1 rather than 0\r\n        uint tag;\r\n        WireType wire;\r\n        while (hasMore(buf)) {\r\n            (tag, wire) = decKey(buf);\r\n            cnts[tag] += 1;\r\n            skipValue(buf, wire);\r\n        }\r\n        buf.idx = originalIdx;\r\n    }\r\n\r\n    // read varint from current buf idx, move buf.idx to next read, return the int value\r\n    function decVarint(Buffer memory buf) internal pure returns (uint v) {\r\n        bytes10 tmp;  // proto int is at most 10 bytes (7 bits can be used per byte)\r\n        bytes memory bb = buf.b;  // get buf.b mem addr to use in assembly\r\n        v = buf.idx;  // use v to save one additional uint variable\r\n        assembly {\r\n            tmp := mload(add(add(bb, 32), v)) // load 10 bytes from buf.b[buf.idx] to tmp\r\n        }\r\n        uint b; // store current byte content\r\n        v = 0; // reset to 0 for return value\r\n        for (uint i=0; i<10; i++) {\r\n            assembly {\r\n                b := byte(i, tmp)  // don't use tmp[i] because it does bound check and costs extra\r\n            }\r\n            v |= (b & 0x7F) << (i * 7);\r\n            if (b & 0x80 == 0) {\r\n                buf.idx += i + 1;\r\n                return v;\r\n            }\r\n        }\r\n        revert(); // i=10, invalid varint stream\r\n    }\r\n\r\n    // read length delimited field and return bytes\r\n    function decBytes(Buffer memory buf) internal pure returns (bytes memory b) {\r\n        uint len = decVarint(buf);\r\n        uint end = buf.idx + len;\r\n        require(end <= buf.b.length);  // avoid overflow\r\n        b = new bytes(len);\r\n        bytes memory bufB = buf.b;  // get buf.b mem addr to use in assembly\r\n        uint bStart;\r\n        uint bufBStart = buf.idx;\r\n        assembly {\r\n            bStart := add(b, 32)\r\n            bufBStart := add(add(bufB, 32), bufBStart)\r\n        }\r\n        for (uint i=0; i<len; i+=32) {\r\n            assembly{\r\n                mstore(add(bStart, i), mload(add(bufBStart, i)))\r\n            }\r\n        }\r\n        buf.idx = end;\r\n    }\r\n\r\n    // return packed ints\r\n    function decPacked(Buffer memory buf) internal pure returns (uint[] memory t) {\r\n        uint len = decVarint(buf);\r\n        uint end = buf.idx + len;\r\n        require(end <= buf.b.length);  // avoid overflow\r\n        // array in memory must be init w/ known length\r\n        // so we have to create a tmp array w/ max possible len first\r\n        uint[] memory tmp = new uint[](len);\r\n        uint i = 0; // count how many ints are there\r\n        while (buf.idx < end) {\r\n            tmp[i] = decVarint(buf);\r\n            i++;\r\n        }\r\n        t = new uint[](i); // init t with correct length\r\n        for (uint j=0; j<i; j++) {\r\n            t[j] = tmp[j];\r\n        }\r\n        return t;\r\n    }\r\n\r\n    // move idx pass current value field, to beginning of next tag or msg end\r\n    function skipValue(Buffer memory buf, WireType wire) internal pure {\r\n        if (wire == WireType.Varint) { decVarint(buf); }\r\n        else if (wire == WireType.LengthDelim) {\r\n            uint len = decVarint(buf);\r\n            buf.idx += len; // skip len bytes value data\r\n            require(buf.idx <= buf.b.length);  // avoid overflow\r\n        } else { revert(); }  // unsupported wiretype\r\n    }\r\n\r\n    // type conversion help utils\r\n    function _bool(uint x) internal pure returns (bool v) {\r\n        return x != 0;\r\n    }\r\n\r\n    function _uint256(bytes memory b) internal pure returns (uint256 v) {\r\n        require(b.length <= 32);  // b's length must be smaller than or equal to 32\r\n        assembly { v := mload(add(b, 32)) }  // load all 32bytes to v\r\n        v = v >> (8 * (32 - b.length));  // only first b.length is valid\r\n    }\r\n\r\n    function _address(bytes memory b) internal pure returns (address v) {\r\n        v = _addressPayable(b);\r\n    }\r\n\r\n    function _addressPayable(bytes memory b) internal pure returns (address payable v) {\r\n        require(b.length == 20);\r\n        //load 32bytes then shift right 12 bytes\r\n        assembly { v := div(mload(add(b, 32)), 0x1000000000000000000000000) }\r\n    }\r\n\r\n    function _bytes32(bytes memory b) internal pure returns (bytes32 v) {\r\n        require(b.length == 32);\r\n        assembly { v := mload(add(b, 32)) }\r\n    }\r\n\r\n    // uint[] to uint8[]\r\n    function uint8s(uint[] memory arr) internal pure returns (uint8[] memory t) {\r\n        t = new uint8[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = uint8(arr[i]); }\r\n    }\r\n\r\n    function uint32s(uint[] memory arr) internal pure returns (uint32[] memory t) {\r\n        t = new uint32[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = uint32(arr[i]); }\r\n    }\r\n\r\n    function uint64s(uint[] memory arr) internal pure returns (uint64[] memory t) {\r\n        t = new uint64[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = uint64(arr[i]); }\r\n    }\r\n\r\n    function bools(uint[] memory arr) internal pure returns (bool[] memory t) {\r\n        t = new bool[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = arr[i]!=0; }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/data/PbEntity.sol\r\n\r\n// Code generated by protoc-gen-sol. DO NOT EDIT.\r\n// source: entity.proto\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary PbEntity {\r\n    using Pb for Pb.Buffer;  // so we can call Pb funcs on Buffer obj\r\n\r\n    enum TokenType { INVALID, ETH, ERC20 }\r\n\r\n    // TokenType[] decode function\r\n    function TokenTypes(uint[] memory arr) internal pure returns (TokenType[] memory t) {\r\n        t = new TokenType[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = TokenType(arr[i]); }\r\n    }\r\n\r\n    enum TransferFunctionType { BOOLEAN_AND, BOOLEAN_OR, BOOLEAN_CIRCUIT, NUMERIC_ADD, NUMERIC_MAX, NUMERIC_MIN }\r\n\r\n    // TransferFunctionType[] decode function\r\n    function TransferFunctionTypes(uint[] memory arr) internal pure returns (TransferFunctionType[] memory t) {\r\n        t = new TransferFunctionType[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = TransferFunctionType(arr[i]); }\r\n    }\r\n\r\n    enum ConditionType { HASH_LOCK, DEPLOYED_CONTRACT, VIRTUAL_CONTRACT }\r\n\r\n    // ConditionType[] decode function\r\n    function ConditionTypes(uint[] memory arr) internal pure returns (ConditionType[] memory t) {\r\n        t = new ConditionType[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = ConditionType(arr[i]); }\r\n    }\r\n\r\n    struct AccountAmtPair {\r\n        address account;   // tag: 1\r\n        uint256 amt;   // tag: 2\r\n    } // end struct AccountAmtPair\r\n\r\n    function decAccountAmtPair(bytes memory raw) internal pure returns (AccountAmtPair memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.account = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.amt = Pb._uint256(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder AccountAmtPair\r\n\r\n    struct TokenInfo {\r\n        TokenType tokenType;   // tag: 1\r\n        address tokenAddress;   // tag: 2\r\n    } // end struct TokenInfo\r\n\r\n    function decTokenInfo(bytes memory raw) internal pure returns (TokenInfo memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.tokenType = TokenType(buf.decVarint());\r\n            }\r\n            else if (tag == 2) {\r\n                m.tokenAddress = Pb._address(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder TokenInfo\r\n\r\n    struct TokenDistribution {\r\n        TokenInfo token;   // tag: 1\r\n        AccountAmtPair[] distribution;   // tag: 2\r\n    } // end struct TokenDistribution\r\n\r\n    function decTokenDistribution(bytes memory raw) internal pure returns (TokenDistribution memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.distribution = new AccountAmtPair[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.token = decTokenInfo(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.distribution[cnts[2]] = decAccountAmtPair(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder TokenDistribution\r\n\r\n    struct TokenTransfer {\r\n        TokenInfo token;   // tag: 1\r\n        AccountAmtPair receiver;   // tag: 2\r\n    } // end struct TokenTransfer\r\n\r\n    function decTokenTransfer(bytes memory raw) internal pure returns (TokenTransfer memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.token = decTokenInfo(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.receiver = decAccountAmtPair(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder TokenTransfer\r\n\r\n    struct SimplexPaymentChannel {\r\n        bytes32 channelId;   // tag: 1\r\n        address peerFrom;   // tag: 2\r\n        uint seqNum;   // tag: 3\r\n        TokenTransfer transferToPeer;   // tag: 4\r\n        PayIdList pendingPayIds;   // tag: 5\r\n        uint lastPayResolveDeadline;   // tag: 6\r\n        uint256 totalPendingAmount;   // tag: 7\r\n    } // end struct SimplexPaymentChannel\r\n\r\n    function decSimplexPaymentChannel(bytes memory raw) internal pure returns (SimplexPaymentChannel memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.channelId = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.peerFrom = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 3) {\r\n                m.seqNum = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 4) {\r\n                m.transferToPeer = decTokenTransfer(buf.decBytes());\r\n            }\r\n            else if (tag == 5) {\r\n                m.pendingPayIds = decPayIdList(buf.decBytes());\r\n            }\r\n            else if (tag == 6) {\r\n                m.lastPayResolveDeadline = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 7) {\r\n                m.totalPendingAmount = Pb._uint256(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder SimplexPaymentChannel\r\n\r\n    struct PayIdList {\r\n        bytes32[] payIds;   // tag: 1\r\n        bytes32 nextListHash;   // tag: 2\r\n    } // end struct PayIdList\r\n\r\n    function decPayIdList(bytes memory raw) internal pure returns (PayIdList memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.payIds = new bytes32[](cnts[1]);\r\n        cnts[1] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.payIds[cnts[1]] = Pb._bytes32(buf.decBytes());\r\n                cnts[1]++;\r\n            }\r\n            else if (tag == 2) {\r\n                m.nextListHash = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder PayIdList\r\n\r\n    struct TransferFunction {\r\n        TransferFunctionType logicType;   // tag: 1\r\n        TokenTransfer maxTransfer;   // tag: 2\r\n    } // end struct TransferFunction\r\n\r\n    function decTransferFunction(bytes memory raw) internal pure returns (TransferFunction memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.logicType = TransferFunctionType(buf.decVarint());\r\n            }\r\n            else if (tag == 2) {\r\n                m.maxTransfer = decTokenTransfer(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder TransferFunction\r\n\r\n    struct ConditionalPay {\r\n        uint payTimestamp;   // tag: 1\r\n        address src;   // tag: 2\r\n        address dest;   // tag: 3\r\n        Condition[] conditions;   // tag: 4\r\n        TransferFunction transferFunc;   // tag: 5\r\n        uint resolveDeadline;   // tag: 6\r\n        uint resolveTimeout;   // tag: 7\r\n        address payResolver;   // tag: 8\r\n    } // end struct ConditionalPay\r\n\r\n    function decConditionalPay(bytes memory raw) internal pure returns (ConditionalPay memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(8);\r\n        m.conditions = new Condition[](cnts[4]);\r\n        cnts[4] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.payTimestamp = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 2) {\r\n                m.src = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 3) {\r\n                m.dest = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 4) {\r\n                m.conditions[cnts[4]] = decCondition(buf.decBytes());\r\n                cnts[4]++;\r\n            }\r\n            else if (tag == 5) {\r\n                m.transferFunc = decTransferFunction(buf.decBytes());\r\n            }\r\n            else if (tag == 6) {\r\n                m.resolveDeadline = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 7) {\r\n                m.resolveTimeout = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 8) {\r\n                m.payResolver = Pb._address(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder ConditionalPay\r\n\r\n    struct CondPayResult {\r\n        bytes condPay;   // tag: 1\r\n        uint256 amount;   // tag: 2\r\n    } // end struct CondPayResult\r\n\r\n    function decCondPayResult(bytes memory raw) internal pure returns (CondPayResult memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.condPay = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.amount = Pb._uint256(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder CondPayResult\r\n\r\n    struct VouchedCondPayResult {\r\n        bytes condPayResult;   // tag: 1\r\n        bytes sigOfSrc;   // tag: 2\r\n        bytes sigOfDest;   // tag: 3\r\n    } // end struct VouchedCondPayResult\r\n\r\n    function decVouchedCondPayResult(bytes memory raw) internal pure returns (VouchedCondPayResult memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.condPayResult = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigOfSrc = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 3) {\r\n                m.sigOfDest = bytes(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder VouchedCondPayResult\r\n\r\n    struct Condition {\r\n        ConditionType conditionType;   // tag: 1\r\n        bytes32 hashLock;   // tag: 2\r\n        address deployedContractAddress;   // tag: 3\r\n        bytes32 virtualContractAddress;   // tag: 4\r\n        bytes argsQueryFinalization;   // tag: 5\r\n        bytes argsQueryOutcome;   // tag: 6\r\n    } // end struct Condition\r\n\r\n    function decCondition(bytes memory raw) internal pure returns (Condition memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.conditionType = ConditionType(buf.decVarint());\r\n            }\r\n            else if (tag == 2) {\r\n                m.hashLock = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else if (tag == 3) {\r\n                m.deployedContractAddress = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 4) {\r\n                m.virtualContractAddress = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else if (tag == 5) {\r\n                m.argsQueryFinalization = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 6) {\r\n                m.argsQueryOutcome = bytes(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder Condition\r\n\r\n    struct CooperativeWithdrawInfo {\r\n        bytes32 channelId;   // tag: 1\r\n        uint seqNum;   // tag: 2\r\n        AccountAmtPair withdraw;   // tag: 3\r\n        uint withdrawDeadline;   // tag: 4\r\n        bytes32 recipientChannelId;   // tag: 5\r\n    } // end struct CooperativeWithdrawInfo\r\n\r\n    function decCooperativeWithdrawInfo(bytes memory raw) internal pure returns (CooperativeWithdrawInfo memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.channelId = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.seqNum = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 3) {\r\n                m.withdraw = decAccountAmtPair(buf.decBytes());\r\n            }\r\n            else if (tag == 4) {\r\n                m.withdrawDeadline = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 5) {\r\n                m.recipientChannelId = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder CooperativeWithdrawInfo\r\n\r\n    struct PaymentChannelInitializer {\r\n        TokenDistribution initDistribution;   // tag: 1\r\n        uint openDeadline;   // tag: 2\r\n        uint disputeTimeout;   // tag: 3\r\n        uint msgValueReceiver;   // tag: 4\r\n    } // end struct PaymentChannelInitializer\r\n\r\n    function decPaymentChannelInitializer(bytes memory raw) internal pure returns (PaymentChannelInitializer memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.initDistribution = decTokenDistribution(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.openDeadline = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 3) {\r\n                m.disputeTimeout = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 4) {\r\n                m.msgValueReceiver = uint(buf.decVarint());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder PaymentChannelInitializer\r\n\r\n    struct CooperativeSettleInfo {\r\n        bytes32 channelId;   // tag: 1\r\n        uint seqNum;   // tag: 2\r\n        AccountAmtPair[] settleBalance;   // tag: 3\r\n        uint settleDeadline;   // tag: 4\r\n    } // end struct CooperativeSettleInfo\r\n\r\n    function decCooperativeSettleInfo(bytes memory raw) internal pure returns (CooperativeSettleInfo memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(4);\r\n        m.settleBalance = new AccountAmtPair[](cnts[3]);\r\n        cnts[3] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.channelId = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.seqNum = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 3) {\r\n                m.settleBalance[cnts[3]] = decAccountAmtPair(buf.decBytes());\r\n                cnts[3]++;\r\n            }\r\n            else if (tag == 4) {\r\n                m.settleDeadline = uint(buf.decVarint());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder CooperativeSettleInfo\r\n\r\n    struct ChannelMigrationInfo {\r\n        bytes32 channelId;   // tag: 1\r\n        address fromLedgerAddress;   // tag: 2\r\n        address toLedgerAddress;   // tag: 3\r\n        uint migrationDeadline;   // tag: 4\r\n    } // end struct ChannelMigrationInfo\r\n\r\n    function decChannelMigrationInfo(bytes memory raw) internal pure returns (ChannelMigrationInfo memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.channelId = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.fromLedgerAddress = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 3) {\r\n                m.toLedgerAddress = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 4) {\r\n                m.migrationDeadline = uint(buf.decVarint());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder ChannelMigrationInfo\r\n\r\n}\r\n\r\n// File: contracts/lib/ledgerlib/LedgerStruct.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Ledger Struct Library\r\n * @notice CelerLedger library defining all used structs\r\n */\r\nlibrary LedgerStruct {\r\n    enum ChannelStatus { Uninitialized, Operable, Settling, Closed, Migrated }\r\n\r\n    struct PeerState {\r\n        uint seqNum;\r\n        // balance sent out to the other peer of the channel, no need to record amtIn\r\n        uint transferOut;\r\n        bytes32 nextPayIdListHash;\r\n        uint lastPayResolveDeadline;\r\n        uint pendingPayOut;\r\n    }\r\n\r\n    struct PeerProfile {\r\n        address peerAddr;\r\n        // the (monotone increasing) amount that this peer deposit into this channel\r\n        uint deposit;\r\n        // the (monotone increasing) amount that this peer withdraw from this channel\r\n        uint withdrawal;\r\n        PeerState state;\r\n    }\r\n\r\n    struct WithdrawIntent {\r\n        address receiver;\r\n        uint amount;\r\n        uint requestTime;\r\n        bytes32 recipientChannelId;\r\n    }\r\n\r\n    // Channel is a representation of the state channel between peers which puts the funds\r\n    // in CelerWallet and is hosted by a CelerLedger. The status of a state channel can\r\n    // be migrated from one CelerLedger instance to another CelerLedger instance with probably\r\n    // different operation logic.\r\n    struct Channel {\r\n        // the time after which peers can confirmSettle and before which peers can intendSettle\r\n        uint settleFinalizedTime;\r\n        uint disputeTimeout;\r\n        PbEntity.TokenInfo token;\r\n        ChannelStatus status;\r\n        // record the new CelerLedger address after channel migration\r\n        address migratedTo;\r\n        // only support 2-peer channel for now\r\n        PeerProfile[2] peerProfiles;\r\n        uint cooperativeWithdrawSeqNum;\r\n        WithdrawIntent withdrawIntent;\r\n    }\r\n\r\n    // Ledger is a host to record and operate the activities of many state\r\n    // channels with specific operation logic.\r\n    struct Ledger {\r\n        // ChannelStatus => number of channels\r\n        mapping(uint => uint) channelStatusNums;\r\n        IEthPool ethPool;\r\n        IPayRegistry payRegistry;\r\n        ICelerWallet celerWallet;\r\n        // per channel deposit limits for different tokens\r\n        mapping(address => uint) balanceLimits;\r\n        // whether deposit limits of all tokens have been enabled\r\n        bool balanceLimitsEnabled;\r\n        mapping(bytes32 => Channel) channelMap;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/interface/ICelerLedger.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n\r\n\r\n/**\r\n * @title CelerLedger interface\r\n * @dev any changes in this interface must be synchronized to corresponding libraries\r\n * @dev events in this interface must be exactly same in corresponding used libraries\r\n */\r\ninterface ICelerLedger {\r\n    /********** LedgerOperation related functions and events **********/\r\n    function openChannel(bytes calldata _openChannelRequest) external payable;\r\n\r\n    function deposit(bytes32 _channelId, address _receiver, uint _transferFromAmount) external payable;\r\n\r\n    function depositInBatch(\r\n        bytes32[] calldata _channelIds,\r\n        address[] calldata _receivers,\r\n        uint[] calldata _transferFromAmounts\r\n    ) external;\r\n\r\n    function snapshotStates(bytes calldata _signedSimplexStateArray) external;\r\n\r\n    function intendWithdraw(bytes32 _channelId, uint _amount, bytes32 _recipientChannelId) external;\r\n    \r\n    function confirmWithdraw(bytes32 _channelId) external;\r\n\r\n    function vetoWithdraw(bytes32 _channelId) external;\r\n    \r\n    function cooperativeWithdraw(bytes calldata _cooperativeWithdrawRequest) external;\r\n    \r\n    function intendSettle(bytes calldata _signedSimplexStateArray) external;\r\n    \r\n    function clearPays(bytes32 _channelId, address _peerFrom, bytes calldata _payIdList) external;\r\n    \r\n    function confirmSettle(bytes32 _channelId) external;\r\n    \r\n    function cooperativeSettle(bytes calldata _settleRequest) external;\r\n    \r\n    function getChannelStatusNum(uint _channelStatus) external view returns(uint);\r\n\r\n    function getEthPool() external view returns(address);\r\n\r\n    function getPayRegistry() external view returns(address);\r\n\r\n    function getCelerWallet() external view returns(address);\r\n\r\n    event OpenChannel(\r\n        bytes32 indexed channelId,\r\n        uint tokenType,\r\n        address indexed tokenAddress,\r\n        // TODO: there is an issue of setting address[2] as indexed. Need to fix and make this indexed\r\n        address[2] peerAddrs,\r\n        uint[2] initialDeposits\r\n    );\r\n\r\n    // TODO: there is an issue of setting address[2] as indexed. Need to fix and make this indexed\r\n    event Deposit(bytes32 indexed channelId, address[2] peerAddrs, uint[2] deposits, uint[2] withdrawals);\r\n\r\n    event SnapshotStates(bytes32 indexed channelId, uint[2] seqNums);\r\n\r\n    event IntendSettle(bytes32 indexed channelId, uint[2] seqNums);\r\n\r\n    event ClearOnePay(bytes32 indexed channelId, bytes32 indexed payId, address indexed peerFrom, uint amount);\r\n\r\n    event ConfirmSettle(bytes32 indexed channelId, uint[2] settleBalance);\r\n\r\n    event ConfirmSettleFail(bytes32 indexed channelId);\r\n\r\n    event IntendWithdraw(bytes32 indexed channelId, address indexed receiver, uint amount);\r\n\r\n    event ConfirmWithdraw(\r\n        bytes32 indexed channelId,\r\n        uint withdrawnAmount,\r\n        address indexed receiver,\r\n        bytes32 indexed recipientChannelId,\r\n        uint[2] deposits,\r\n        uint[2] withdrawals\r\n    );\r\n\r\n    event VetoWithdraw(bytes32 indexed channelId);\r\n\r\n    event CooperativeWithdraw(\r\n        bytes32 indexed channelId,\r\n        uint withdrawnAmount,\r\n        address indexed receiver,\r\n        bytes32 indexed recipientChannelId,\r\n        uint[2] deposits,\r\n        uint[2] withdrawals,\r\n        uint seqNum\r\n    );\r\n\r\n    event CooperativeSettle(bytes32 indexed channelId, uint[2] settleBalance);\r\n    /********** End of LedgerOperation related functions and events **********/\r\n\r\n\r\n    /********** LedgerChannel related functions and events **********/\r\n    function getSettleFinalizedTime(bytes32 _channelId) external view returns(uint);\r\n\r\n    function getTokenContract(bytes32 _channelId) external view returns(address);\r\n\r\n    function getTokenType(bytes32 _channelId) external view returns(PbEntity.TokenType);\r\n\r\n    function getChannelStatus(bytes32 _channelId) external view returns(LedgerStruct.ChannelStatus);\r\n\r\n    function getCooperativeWithdrawSeqNum(bytes32 _channelId) external view returns(uint);\r\n\r\n    function getTotalBalance(bytes32 _channelId) external view returns(uint);\r\n\r\n    function getBalanceMap(bytes32 _channelId) external view returns(address[2] memory, uint[2] memory, uint[2] memory);\r\n\r\n    function getChannelMigrationArgs(bytes32 _channelId) external view returns(uint, uint, address, uint);\r\n\r\n    function getPeersMigrationInfo(bytes32 _channelId) external view returns(\r\n        address[2] memory,\r\n        uint[2] memory,\r\n        uint[2] memory,\r\n        uint[2] memory,\r\n        uint[2] memory,\r\n        uint[2] memory\r\n    );\r\n\r\n    function getDisputeTimeout(bytes32 _channelId) external view returns(uint);\r\n\r\n    function getMigratedTo(bytes32 _channelId) external view returns(address);\r\n\r\n    function getStateSeqNumMap(bytes32 _channelId) external view returns(address[2] memory, uint[2] memory);\r\n\r\n    function getTransferOutMap(bytes32 _channelId) external view returns(\r\n        address[2] memory,\r\n        uint[2] memory\r\n    );\r\n\r\n    function getNextPayIdListHashMap(bytes32 _channelId) external view returns(\r\n        address[2] memory,\r\n        bytes32[2] memory\r\n    );\r\n\r\n    function getLastPayResolveDeadlineMap(bytes32 _channelId) external view returns(\r\n        address[2] memory,\r\n        uint[2] memory\r\n    );\r\n\r\n    function getPendingPayOutMap(bytes32 _channelId) external view returns(\r\n        address[2] memory,\r\n        uint[2] memory\r\n    );\r\n\r\n    function getWithdrawIntent(bytes32 _channelId) external view returns(address, uint, uint, bytes32);\r\n    /********** End of LedgerChannel related functions and events **********/\r\n\r\n\r\n    /********** LedgerBalanceLimit related functions and events **********/\r\n    function setBalanceLimits(address[] calldata _tokenAddrs, uint[] calldata _limits) external;\r\n\r\n    function disableBalanceLimits() external;\r\n\r\n    function enableBalanceLimits() external;\r\n\r\n    function getBalanceLimit(address _tokenAddr) external view returns(uint);\r\n\r\n    function getBalanceLimitsEnabled() external view returns(bool);\r\n    /********** End of LedgerBalanceLimit related functions and events **********/\r\n\r\n\r\n    /********** LedgerMigrate related functions and events **********/\r\n    function migrateChannelTo(bytes calldata _migrationRequest) external returns(bytes32);\r\n\r\n    function migrateChannelFrom(address _fromLedgerAddr, bytes calldata _migrationRequest) external;\r\n\r\n    event MigrateChannelTo(bytes32 indexed channelId, address indexed newLedgerAddr);\r\n\r\n    event MigrateChannelFrom(bytes32 indexed channelId, address indexed oldLedgerAddr);\r\n    /********** End of LedgerMigrate related functions and events **********/\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Elliptic curve signature operations\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n */\r\n\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * toEthSignedMessageHash\r\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n     * and hash the result\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ledgerlib/LedgerChannel.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Ledger Channel Library\r\n * @notice CelerLedger library about Channel struct\r\n * @dev this can be included in LedgerOperation to save some gas,\r\n *   however, keep this for now for clearness.\r\n */\r\nlibrary LedgerChannel {\r\n    using SafeMath for uint;\r\n    using ECDSA for bytes32;\r\n\r\n    /**\r\n     * @notice Get channel confirm settle open time\r\n     * @param _c the channel being used\r\n     * @return channel confirm settle open time\r\n     */\r\n    function getSettleFinalizedTime(LedgerStruct.Channel storage _c) public view returns(uint) {\r\n        return _c.settleFinalizedTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Get channel token contract address\r\n     * @param _c the channel being used\r\n     * @return channel token contract address\r\n     */\r\n    function getTokenContract(LedgerStruct.Channel storage _c) public view returns(address) {\r\n        return _c.token.tokenAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Get channel token type\r\n     * @param _c the channel being used\r\n     * @return channel token type\r\n     */\r\n    function getTokenType(LedgerStruct.Channel storage _c) public view returns(PbEntity.TokenType) {\r\n        return _c.token.tokenType;\r\n    }\r\n\r\n    /**\r\n     * @notice Get channel status\r\n     * @param _c the channel being used\r\n     * @return channel status\r\n     */\r\n    function getChannelStatus(\r\n        LedgerStruct.Channel storage _c\r\n    )\r\n        public\r\n        view\r\n        returns(LedgerStruct.ChannelStatus)\r\n    {\r\n        return _c.status;\r\n    }\r\n\r\n    /**\r\n     * @notice Get cooperative withdraw seqNum\r\n     * @param _c the channel being used\r\n     * @return cooperative withdraw seqNum\r\n     */\r\n    function getCooperativeWithdrawSeqNum(LedgerStruct.Channel storage _c) public view returns(uint) {\r\n        return _c.cooperativeWithdrawSeqNum;\r\n    }\r\n\r\n    /**\r\n     * @notice Return one channel's total balance amount\r\n     * @param _c the channel\r\n     * @return channel's balance amount\r\n     */\r\n    function getTotalBalance(LedgerStruct.Channel storage _c) public view returns(uint) {\r\n        uint balance = _c.peerProfiles[0].deposit\r\n            .add(_c.peerProfiles[1].deposit)\r\n            .sub(_c.peerProfiles[0].withdrawal)\r\n            .sub(_c.peerProfiles[1].withdrawal);\r\n        return balance;\r\n    }\r\n\r\n    /**\r\n     * @notice Return one channel's balance info (depositMap and withdrawalMap)\r\n     * @dev Solidity can't directly return an array of struct for now\r\n     * @param _c the channel\r\n     * @return addresses of peers in the channel\r\n     * @return corresponding deposits of the peers (with matched index)\r\n     * @return corresponding withdrawals of the peers (with matched index)\r\n     */\r\n    function getBalanceMap(LedgerStruct.Channel storage _c) public view\r\n        returns(address[2] memory, uint[2] memory, uint[2] memory)\r\n    {\r\n        address[2] memory peerAddrs = [_c.peerProfiles[0].peerAddr, _c.peerProfiles[1].peerAddr];\r\n        uint[2] memory deposits = [_c.peerProfiles[0].deposit, _c.peerProfiles[1].deposit];\r\n        uint[2] memory withdrawals = [_c.peerProfiles[0].withdrawal, _c.peerProfiles[1].withdrawal];\r\n        return (peerAddrs, deposits, withdrawals);\r\n    }\r\n\r\n    /**\r\n     * @notice Return channel-level migration arguments\r\n     * @param _c the channel to be viewed\r\n     * @return channel dispute timeout\r\n     * @return channel tokey type converted to uint\r\n     * @return channel token address\r\n     * @return sequence number of cooperative withdraw\r\n     * @dev related to Ledger Migration\r\n     */\r\n    function getChannelMigrationArgs(\r\n        LedgerStruct.Channel storage _c\r\n    )\r\n        external\r\n        view\r\n        returns(uint, uint, address, uint)\r\n    {\r\n        return (\r\n            _c.disputeTimeout,\r\n            uint(_c.token.tokenType),\r\n            _c.token.tokenAddress,\r\n            _c.cooperativeWithdrawSeqNum\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Return migration info of the peers in the channel\r\n     * @param _c the channel to be viewed\r\n     * @return peers' addresses\r\n     * @return peers' deposits\r\n     * @return peers' withdrawals\r\n     * @return peers' state sequence numbers\r\n     * @return peers' transferOut map\r\n     * @return peers' pendingPayOut map\r\n     * @dev related to Ledger Migration\r\n     */\r\n    function getPeersMigrationInfo(\r\n        LedgerStruct.Channel storage _c\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n        address[2] memory,\r\n        uint[2] memory,\r\n        uint[2] memory,\r\n        uint[2] memory,\r\n        uint[2] memory,\r\n        uint[2] memory\r\n    )\r\n    {\r\n        LedgerStruct.PeerProfile[2] memory peerProfiles = _c.peerProfiles;\r\n        return (\r\n            [peerProfiles[0].peerAddr, peerProfiles[1].peerAddr],\r\n            [peerProfiles[0].deposit, peerProfiles[1].deposit],\r\n            [peerProfiles[0].withdrawal, peerProfiles[1].withdrawal],\r\n            [peerProfiles[0].state.seqNum, peerProfiles[1].state.seqNum],\r\n            [peerProfiles[0].state.transferOut, peerProfiles[1].state.transferOut],\r\n            [peerProfiles[0].state.pendingPayOut, peerProfiles[1].state.pendingPayOut]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Return channel's dispute timeout\r\n     * @param _c the channel to be viewed\r\n     * @return channel's dispute timeout\r\n     */\r\n    function getDisputeTimeout(LedgerStruct.Channel storage _c) external view returns(uint) {\r\n        return _c.disputeTimeout;\r\n    }\r\n\r\n    /**\r\n     * @notice Return channel's migratedTo address\r\n     * @param _c the channel to be viewed\r\n     * @return channel's migratedTo address\r\n     */\r\n    function getMigratedTo(LedgerStruct.Channel storage _c) external view returns(address) {\r\n        return _c.migratedTo;\r\n    }\r\n\r\n    /**\r\n     * @notice Return state seqNum map of a duplex channel\r\n     * @param _c the channel to be viewed\r\n     * @return peers' addresses\r\n     * @return two simplex state sequence numbers\r\n     */\r\n    function getStateSeqNumMap(\r\n        LedgerStruct.Channel storage _c\r\n    )\r\n        external\r\n        view\r\n        returns(address[2] memory, uint[2] memory)\r\n    {\r\n        LedgerStruct.PeerProfile[2] memory peerProfiles = _c.peerProfiles;\r\n        return (\r\n            [peerProfiles[0].peerAddr, peerProfiles[1].peerAddr],\r\n            [peerProfiles[0].state.seqNum, peerProfiles[1].state.seqNum]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Return transferOut map of a duplex channel\r\n     * @param _c the channel to be viewed\r\n     * @return peers' addresses\r\n     * @return transferOuts of two simplex channels\r\n     */\r\n    function getTransferOutMap(\r\n        LedgerStruct.Channel storage _c\r\n    )\r\n        external\r\n        view\r\n        returns(address[2] memory, uint[2] memory)\r\n    {\r\n        LedgerStruct.PeerProfile[2] memory peerProfiles = _c.peerProfiles;\r\n        return (\r\n            [peerProfiles[0].peerAddr, peerProfiles[1].peerAddr],\r\n            [peerProfiles[0].state.transferOut, peerProfiles[1].state.transferOut]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Return nextPayIdListHash map of a duplex channel\r\n     * @param _c the channel to be viewed\r\n     * @return peers' addresses\r\n     * @return nextPayIdListHashes of two simplex channels\r\n     */\r\n    function getNextPayIdListHashMap(\r\n        LedgerStruct.Channel storage _c\r\n    )\r\n        external\r\n        view\r\n        returns(address[2] memory, bytes32[2] memory)\r\n    {\r\n        LedgerStruct.PeerProfile[2] memory peerProfiles = _c.peerProfiles;\r\n        return (\r\n            [peerProfiles[0].peerAddr, peerProfiles[1].peerAddr],\r\n            [peerProfiles[0].state.nextPayIdListHash, peerProfiles[1].state.nextPayIdListHash]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Return lastPayResolveDeadline map of a duplex channel\r\n     * @param _c the channel to be viewed\r\n     * @return peers' addresses\r\n     * @return lastPayResolveDeadlines of two simplex channels\r\n     */\r\n    function getLastPayResolveDeadlineMap(\r\n        LedgerStruct.Channel storage _c\r\n    )\r\n        external\r\n        view\r\n        returns(address[2] memory, uint[2] memory)\r\n    {\r\n        LedgerStruct.PeerProfile[2] memory peerProfiles = _c.peerProfiles;\r\n        return (\r\n            [peerProfiles[0].peerAddr, peerProfiles[1].peerAddr],\r\n            [peerProfiles[0].state.lastPayResolveDeadline, peerProfiles[1].state.lastPayResolveDeadline]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Return pendingPayOut map of a duplex channel\r\n     * @param _c the channel to be viewed\r\n     * @return peers' addresses\r\n     * @return pendingPayOuts of two simplex channels\r\n     */\r\n    function getPendingPayOutMap(\r\n        LedgerStruct.Channel storage _c\r\n    )\r\n        external\r\n        view\r\n        returns(address[2] memory, uint[2] memory)\r\n    {\r\n        LedgerStruct.PeerProfile[2] memory peerProfiles = _c.peerProfiles;\r\n        return (\r\n            [peerProfiles[0].peerAddr, peerProfiles[1].peerAddr],\r\n            [peerProfiles[0].state.pendingPayOut, peerProfiles[1].state.pendingPayOut]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Return the withdraw intent info of the channel\r\n     * @param _c the channel to be viewed\r\n     * @return receiver of the withdraw intent\r\n     * @return amount of the withdraw intent\r\n     * @return requestTime of the withdraw intent\r\n     * @return recipientChannelId of the withdraw intent\r\n     */\r\n    function getWithdrawIntent(\r\n        LedgerStruct.Channel storage _c\r\n    )\r\n        external\r\n        view\r\n        returns(address, uint, uint, bytes32)\r\n    {\r\n        LedgerStruct.WithdrawIntent memory withdrawIntent = _c.withdrawIntent;\r\n        return (\r\n            withdrawIntent.receiver,\r\n            withdrawIntent.amount,\r\n            withdrawIntent.requestTime,\r\n            withdrawIntent.recipientChannelId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Import channel migration arguments from old CelerLedger contract\r\n     * @param _c the channel to be viewed\r\n     * @param _fromLedgerAddr old ledger address to import channel config from\r\n     * @param _channelId ID of the channel to be viewed\r\n     * @dev related to Ledger Migration\r\n     */\r\n    function _importChannelMigrationArgs(\r\n        LedgerStruct.Channel storage _c,\r\n        address payable _fromLedgerAddr,\r\n        bytes32 _channelId\r\n    )\r\n        internal\r\n    {\r\n        uint tokenType;\r\n        (\r\n            _c.disputeTimeout,\r\n            tokenType,\r\n            _c.token.tokenAddress,\r\n            _c.cooperativeWithdrawSeqNum\r\n        ) = ICelerLedger(_fromLedgerAddr).getChannelMigrationArgs(_channelId);\r\n        _c.token.tokenType = PbEntity.TokenType(tokenType);\r\n    }\r\n\r\n    /**\r\n     * @notice import channel peers' migration info from old CelerLedger contract\r\n     * @param _c the channel to be viewed\r\n     * @param _fromLedgerAddr old ledger address to import channel config from\r\n     * @param _channelId ID of the channel to be viewed\r\n     * @dev related to Ledger Migration\r\n     */\r\n    function _importPeersMigrationInfo(\r\n        LedgerStruct.Channel storage _c,\r\n        address payable _fromLedgerAddr,\r\n        bytes32 _channelId\r\n    )\r\n        internal\r\n    {\r\n        (\r\n            address[2] memory peersAddrs,\r\n            uint[2] memory deposits,\r\n            uint[2] memory withdrawals,\r\n            uint[2] memory seqNums,\r\n            uint[2] memory transferOuts,\r\n            uint[2] memory pendingPayOuts\r\n        ) = ICelerLedger(_fromLedgerAddr).getPeersMigrationInfo(_channelId);\r\n\r\n        for (uint i = 0; i < 2; i++) {\r\n            LedgerStruct.PeerProfile storage peerProfile = _c.peerProfiles[i];\r\n            peerProfile.peerAddr = peersAddrs[i];\r\n            peerProfile.deposit = deposits[i];\r\n            peerProfile.withdrawal = withdrawals[i];\r\n            peerProfile.state.seqNum = seqNums[i];\r\n            peerProfile.state.transferOut = transferOuts[i];\r\n            peerProfile.state.pendingPayOut = pendingPayOuts[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the seqNums of two simplex channel states\r\n     * @param _c the channel\r\n     */\r\n    function _getStateSeqNums(LedgerStruct.Channel storage _c) internal view returns(uint[2] memory) {\r\n        return [_c.peerProfiles[0].state.seqNum, _c.peerProfiles[1].state.seqNum];\r\n    }\r\n\r\n    /**\r\n     * @notice Check if _addr is one of the peers in channel _c\r\n     * @param _c the channel\r\n     * @param _addr the address to check\r\n     * @return is peer or not\r\n     */\r\n    function _isPeer(LedgerStruct.Channel storage _c, address _addr) internal view returns(bool) {\r\n        return _addr == _c.peerProfiles[0].peerAddr || _addr == _c.peerProfiles[1].peerAddr;\r\n    }\r\n\r\n    /**\r\n     * @notice Get peer's ID\r\n     * @param _c the channel\r\n     * @param _peer address of peer\r\n     * @return peer's ID\r\n     */\r\n     function _getPeerId(LedgerStruct.Channel storage _c, address _peer) internal view returns(uint) {\r\n        if (_peer == _c.peerProfiles[0].peerAddr) {\r\n            return 0;\r\n        } else if (_peer == _c.peerProfiles[1].peerAddr) {\r\n            return 1;\r\n        } else {\r\n            revert(\"Nonexist peer\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Check the correctness of one peer's signature\r\n     * @param _c the channel\r\n     * @param _h the hash of the message signed by the peer\r\n     * @param _sig signature of the peer\r\n     * @return message is signed by one of the peers or not\r\n     */\r\n    function _checkSingleSignature(\r\n        LedgerStruct.Channel storage _c,\r\n        bytes32 _h,\r\n        bytes memory _sig\r\n    )\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        address addr = _h.toEthSignedMessageHash().recover(_sig);\r\n        return _isPeer(_c, addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Check the correctness of the co-signatures\r\n     * @param _c the channel\r\n     * @param _h the hash of the message signed by the peers\r\n     * @param _sigs signatures of the peers\r\n     * @return message are signed by both peers or not\r\n     */\r\n    function _checkCoSignatures(\r\n        LedgerStruct.Channel storage _c,\r\n        bytes32 _h,\r\n        bytes[] memory _sigs\r\n    )\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        if (_sigs.length != 2) {\r\n            return false;\r\n        }\r\n\r\n        // check signature\r\n        bytes32 hash = _h.toEthSignedMessageHash();\r\n        address addr;\r\n        for (uint i = 0; i < 2; i++) {\r\n            addr = hash.recover(_sigs[i]);\r\n            // enforce the order of sigs consistent with ascending addresses\r\n            if (addr != _c.peerProfiles[i].peerAddr) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Validate channel final balance\r\n     * @dev settleBalance = deposit - withdrawal + transferIn - transferOut\r\n     * @param _c the channel\r\n     * @return (balance is valid, settle balance)\r\n     */\r\n    function _validateSettleBalance(LedgerStruct.Channel storage _c)\r\n        internal\r\n        view\r\n        returns(bool, uint[2] memory)\r\n    {\r\n        LedgerStruct.PeerProfile[2] memory peerProfiles = _c.peerProfiles;\r\n        uint[2] memory settleBalance = [\r\n            peerProfiles[0].deposit.add(peerProfiles[1].state.transferOut),\r\n            peerProfiles[1].deposit.add(peerProfiles[0].state.transferOut)\r\n        ];\r\n        for (uint i = 0; i < 2; i++) {\r\n            uint subAmt = peerProfiles[i].state.transferOut.add(peerProfiles[i].withdrawal);\r\n            if (settleBalance[i] < subAmt) {\r\n                return (false, [uint(0), uint(0)]);\r\n            }\r\n\r\n            settleBalance[i] = settleBalance[i].sub(subAmt);\r\n        }\r\n\r\n        return (true, settleBalance);\r\n    }\r\n\r\n    /**\r\n     * @notice Update record of one peer's withdrawal amount\r\n     * @param _c the channel\r\n     * @param _receiver receiver of this new withdrawal\r\n     * @param _amount amount of this new withdrawal\r\n     * @param _checkBalance check the balance if this is true\r\n     */\r\n    function _addWithdrawal(\r\n        LedgerStruct.Channel storage _c,\r\n        address _receiver,\r\n        uint _amount,\r\n        bool _checkBalance\r\n    )\r\n        internal\r\n    {\r\n        // this implicitly require receiver be a peer\r\n        uint rid = _getPeerId(_c, _receiver);\r\n        _c.peerProfiles[rid].withdrawal = _c.peerProfiles[rid].withdrawal.add(_amount);\r\n        if (_checkBalance) {\r\n            require(getTotalBalance(_c) >= 0);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/data/PbChain.sol\r\n\r\n// Code generated by protoc-gen-sol. DO NOT EDIT.\r\n// source: chain.proto\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary PbChain {\r\n    using Pb for Pb.Buffer;  // so we can call Pb funcs on Buffer obj\r\n\r\n    struct OpenChannelRequest {\r\n        bytes channelInitializer;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct OpenChannelRequest\r\n\r\n    function decOpenChannelRequest(bytes memory raw) internal pure returns (OpenChannelRequest memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.channelInitializer = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder OpenChannelRequest\r\n\r\n    struct CooperativeWithdrawRequest {\r\n        bytes withdrawInfo;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct CooperativeWithdrawRequest\r\n\r\n    function decCooperativeWithdrawRequest(bytes memory raw) internal pure returns (CooperativeWithdrawRequest memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.withdrawInfo = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder CooperativeWithdrawRequest\r\n\r\n    struct CooperativeSettleRequest {\r\n        bytes settleInfo;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct CooperativeSettleRequest\r\n\r\n    function decCooperativeSettleRequest(bytes memory raw) internal pure returns (CooperativeSettleRequest memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.settleInfo = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder CooperativeSettleRequest\r\n\r\n    struct ResolvePayByConditionsRequest {\r\n        bytes condPay;   // tag: 1\r\n        bytes[] hashPreimages;   // tag: 2\r\n    } // end struct ResolvePayByConditionsRequest\r\n\r\n    function decResolvePayByConditionsRequest(bytes memory raw) internal pure returns (ResolvePayByConditionsRequest memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.hashPreimages = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.condPay = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.hashPreimages[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder ResolvePayByConditionsRequest\r\n\r\n    struct SignedSimplexState {\r\n        bytes simplexState;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct SignedSimplexState\r\n\r\n    function decSignedSimplexState(bytes memory raw) internal pure returns (SignedSimplexState memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.simplexState = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder SignedSimplexState\r\n\r\n    struct SignedSimplexStateArray {\r\n        SignedSimplexState[] signedSimplexStates;   // tag: 1\r\n    } // end struct SignedSimplexStateArray\r\n\r\n    function decSignedSimplexStateArray(bytes memory raw) internal pure returns (SignedSimplexStateArray memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(1);\r\n        m.signedSimplexStates = new SignedSimplexState[](cnts[1]);\r\n        cnts[1] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.signedSimplexStates[cnts[1]] = decSignedSimplexState(buf.decBytes());\r\n                cnts[1]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder SignedSimplexStateArray\r\n\r\n    struct ChannelMigrationRequest {\r\n        bytes channelMigrationInfo;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct ChannelMigrationRequest\r\n\r\n    function decChannelMigrationRequest(bytes memory raw) internal pure returns (ChannelMigrationRequest memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.channelMigrationInfo = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder ChannelMigrationRequest\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        require(token.transfer(to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        require(token.transferFrom(from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(msg.sender, spender) == 0));\r\n        require(token.approve(spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ledgerlib/LedgerOperation.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Ledger Operation Library\r\n * @notice CelerLedger library of basic ledger operations\r\n * @dev This library doesn't need \"withdraw pattern\" because both peers must be\r\n *   External Owned Accounts(EOA) since their signatures are required in openChannel.\r\n */\r\nlibrary LedgerOperation {\r\n    using SafeMath for uint;\r\n    using Address for address;\r\n    using SafeERC20 for IERC20;\r\n    using LedgerChannel for LedgerStruct.Channel;\r\n\r\n    /**\r\n     * @notice Open a state channel through auth withdraw message\r\n     * @dev library function can't be payable but can read msg.value in caller's context\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _openRequest bytes of open channel request message\r\n     */\r\n    function openChannel(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes calldata _openRequest\r\n    )\r\n        external\r\n    {\r\n        PbChain.OpenChannelRequest memory openRequest =\r\n            PbChain.decOpenChannelRequest(_openRequest);\r\n        PbEntity.PaymentChannelInitializer memory channelInitializer =\r\n            PbEntity.decPaymentChannelInitializer(openRequest.channelInitializer);\r\n        require(channelInitializer.initDistribution.distribution.length == 2, \"Wrong length\");\r\n        require(block.number <= channelInitializer.openDeadline, \"Open deadline passed\");\r\n        \r\n        PbEntity.TokenInfo memory token = channelInitializer.initDistribution.token;\r\n        uint[2] memory amounts = [\r\n            channelInitializer.initDistribution.distribution[0].amt,\r\n            channelInitializer.initDistribution.distribution[1].amt\r\n        ];\r\n        address[2] memory peerAddrs = [\r\n            channelInitializer.initDistribution.distribution[0].account,\r\n            channelInitializer.initDistribution.distribution[1].account\r\n        ];\r\n        // enforce ascending order of peers' addresses to simplify contract code\r\n        require(peerAddrs[0] < peerAddrs[1], \"Peer addrs are not ascending\");\r\n\r\n        ICelerWallet celerWallet = _self.celerWallet;\r\n        bytes32 h = keccak256(openRequest.channelInitializer);\r\n        (\r\n            bytes32 channelId,\r\n            LedgerStruct.Channel storage c\r\n        ) = _createWallet(_self, celerWallet, peerAddrs, h);\r\n\r\n        c.disputeTimeout = channelInitializer.disputeTimeout;\r\n        _updateChannelStatus(_self, c, LedgerStruct.ChannelStatus.Operable);\r\n        c.token = _validateTokenInfo(token);\r\n        c.peerProfiles[0].peerAddr = peerAddrs[0];\r\n        c.peerProfiles[0].deposit = amounts[0];\r\n        c.peerProfiles[1].peerAddr = peerAddrs[1];\r\n        c.peerProfiles[1].deposit = amounts[1];\r\n\r\n        require(c._checkCoSignatures(h, openRequest.sigs), \"Check co-sigs failed\");\r\n\r\n        emit OpenChannel(channelId, uint(token.tokenType), token.tokenAddress, peerAddrs, amounts);\r\n\r\n        uint amtSum = amounts[0].add(amounts[1]);\r\n        // if total deposit is 0\r\n        if (amtSum == 0) {\r\n            require(msg.value == 0, \"msg.value is not 0\");\r\n            return;\r\n        }\r\n\r\n        // if total deposit is larger than 0\r\n        if (_self.balanceLimitsEnabled) {\r\n            require(amtSum <= _self.balanceLimits[token.tokenAddress], \"Balance exceeds limit\");\r\n        }\r\n\r\n        if (token.tokenType == PbEntity.TokenType.ETH) {\r\n            uint msgValueReceiver = channelInitializer.msgValueReceiver;\r\n            require(msg.value == amounts[msgValueReceiver], \"msg.value mismatch\");\r\n            if (amounts[msgValueReceiver] > 0) {\r\n                celerWallet.depositETH.value(amounts[msgValueReceiver])(channelId);\r\n            }\r\n\r\n            // peer ID of non-msgValueReceiver\r\n            uint pid = uint(1).sub(msgValueReceiver);\r\n            if (amounts[pid] > 0) {\r\n                _self.ethPool.transferToCelerWallet(\r\n                    peerAddrs[pid],\r\n                    address(celerWallet),\r\n                    channelId,\r\n                    amounts[pid]\r\n                );\r\n            }\r\n        } else if (token.tokenType == PbEntity.TokenType.ERC20) {\r\n            require(msg.value == 0, \"msg.value is not 0\");\r\n\r\n            IERC20 erc20Token = IERC20(token.tokenAddress);\r\n            for (uint i = 0; i < 2; i++) {\r\n                if (amounts[i] == 0) { continue; }\r\n\r\n                erc20Token.safeTransferFrom(peerAddrs[i], address(this), amounts[i]);\r\n            }\r\n            erc20Token.safeApprove(address(celerWallet), amtSum);\r\n            celerWallet.depositERC20(channelId, address(erc20Token), amtSum);\r\n        } else {\r\n            assert(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit ETH or ERC20 tokens into the channel\r\n     * @dev total deposit amount = msg.value(must be 0 for ERC20) + _transferFromAmount.\r\n     *   library function can't be payable but can read msg.value in caller's context.\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _channelId ID of the channel\r\n     * @param _receiver address of the receiver\r\n     * @param _transferFromAmount amount of funds to be transfered from EthPool for ETH\r\n     *   or ERC20 contract for ERC20 tokens\r\n     */\r\n    function deposit(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes32 _channelId,\r\n        address _receiver,\r\n        uint _transferFromAmount\r\n    )\r\n        external\r\n    {\r\n        uint msgValue = msg.value;\r\n        // this implicitly require _receiver be a peer\r\n        _addDeposit(_self, _channelId, _receiver, _transferFromAmount.add(msgValue));\r\n        \r\n        LedgerStruct.Channel storage c = _self.channelMap[_channelId];\r\n        if (c.token.tokenType == PbEntity.TokenType.ETH) {\r\n            if (msgValue > 0) {\r\n                _self.celerWallet.depositETH.value(msgValue)(_channelId);\r\n            }\r\n            if (_transferFromAmount > 0) {\r\n                _self.ethPool.transferToCelerWallet(\r\n                    msg.sender,\r\n                    address(_self.celerWallet),\r\n                    _channelId,\r\n                    _transferFromAmount\r\n                );\r\n            }\r\n        } else if (c.token.tokenType == PbEntity.TokenType.ERC20) {\r\n            require(msgValue == 0, \"msg.value is not 0\");\r\n\r\n            IERC20 erc20Token = IERC20(c.token.tokenAddress);\r\n            erc20Token.safeTransferFrom(msg.sender, address(this), _transferFromAmount);\r\n            erc20Token.safeApprove(address(_self.celerWallet), _transferFromAmount);\r\n            _self.celerWallet.depositERC20(_channelId, address(erc20Token), _transferFromAmount);\r\n        } else {\r\n            assert(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Store signed simplex states on-chain as checkpoints\r\n     * @dev simplex states in this array are not necessarily in the same channel,\r\n     *   which means snapshotStates natively supports multi-channel batch processing.\r\n     *   This function only updates seqNum, transferOut, pendingPayOut of each on-chain\r\n     *   simplex state. It can't ensure that the pending pays will be cleared during\r\n     *   settling the channel, which requires users call intendSettle with the same state.\r\n     *   TODO: wait for Solidity's support to replace SignedSimplexStateArray with bytes[].\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _signedSimplexStateArray bytes of SignedSimplexStateArray message\r\n     */\r\n    function snapshotStates(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes calldata _signedSimplexStateArray\r\n    )\r\n        external\r\n    {\r\n        PbChain.SignedSimplexStateArray memory signedSimplexStateArray =\r\n            PbChain.decSignedSimplexStateArray(_signedSimplexStateArray);\r\n        uint simplexStatesNum = signedSimplexStateArray.signedSimplexStates.length;\r\n\r\n        // snapshot each state\r\n        PbEntity.SimplexPaymentChannel memory simplexState =\r\n            PbEntity.decSimplexPaymentChannel(signedSimplexStateArray.signedSimplexStates[0].simplexState);\r\n        for (uint i = 0; i < simplexStatesNum; i++) {\r\n            bytes32 currentChannelId = simplexState.channelId;\r\n            LedgerStruct.Channel storage c = _self.channelMap[currentChannelId];\r\n\r\n            require(c.status == LedgerStruct.ChannelStatus.Operable, \"Channel status error\");\r\n\r\n            bytes32 stateHash = keccak256(signedSimplexStateArray.signedSimplexStates[i].simplexState);\r\n            bytes[] memory sigs = signedSimplexStateArray.signedSimplexStates[i].sigs;\r\n            require(c._checkCoSignatures(stateHash, sigs), \"Check co-sigs failed\");\r\n            uint peerFromId = c._getPeerId(simplexState.peerFrom);\r\n            LedgerStruct.PeerState storage state = c.peerProfiles[peerFromId].state;\r\n            require(simplexState.seqNum > state.seqNum, \"seqNum error\");\r\n\r\n            // no need to update nextPayIdListHash and lastPayResolveDeadline for snapshot purpose\r\n            state.seqNum = simplexState.seqNum;\r\n            state.transferOut = simplexState.transferToPeer.receiver.amt;\r\n            state.pendingPayOut = simplexState.totalPendingAmount;\r\n\r\n            if (i == simplexStatesNum.sub(1)) {\r\n                emit SnapshotStates(currentChannelId, c._getStateSeqNums());\r\n            } else if (i < simplexStatesNum.sub(1)) {\r\n                simplexState = PbEntity.decSimplexPaymentChannel(\r\n                    signedSimplexStateArray.signedSimplexStates[i+1].simplexState\r\n                );\r\n                // enforce channelIds of simplex states are ascending\r\n                require(currentChannelId <= simplexState.channelId, \"Non-ascending channelIds\");\r\n                if (currentChannelId < simplexState.channelId) {\r\n                    emit SnapshotStates(currentChannelId, c._getStateSeqNums());\r\n                }\r\n            } else {\r\n                assert(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Intend to withdraw funds from channel\r\n     * @dev only peers can call intendWithdraw\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _channelId ID of the channel\r\n     * @param _amount amount of funds to withdraw\r\n     * @param _recipientChannelId withdraw to receiver address if 0,\r\n     *   otherwise deposit to receiver address in the recipient channel\r\n     */\r\n    function intendWithdraw(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes32 _channelId,\r\n        uint _amount,\r\n        bytes32 _recipientChannelId\r\n    )\r\n        external\r\n    {\r\n        LedgerStruct.Channel storage c = _self.channelMap[_channelId];\r\n        LedgerStruct.PeerProfile[2] storage peerProfiles = c.peerProfiles;\r\n        LedgerStruct.WithdrawIntent storage withdrawIntent = c.withdrawIntent;\r\n        address receiver = msg.sender;\r\n        require(c.status == LedgerStruct.ChannelStatus.Operable, \"Channel status error\");\r\n        // withdrawIntent.receiver is address(0) if and only if there is no pending WithdrawIntent,\r\n        // because withdrawIntent.receiver may only be set as msg.sender which can't be address(0).\r\n        require(withdrawIntent.receiver == address(0), \"Pending withdraw intent exists\");\r\n\r\n        // check withdraw limit\r\n        // this implicitly requires receiver be a peer\r\n        uint rid = c._getPeerId(receiver);\r\n        uint pid = uint(1).sub(rid);\r\n        uint withdrawLimit = peerProfiles[rid].deposit\r\n            .add(peerProfiles[pid].state.transferOut)\r\n            .sub(peerProfiles[rid].withdrawal)\r\n            .sub(peerProfiles[rid].state.transferOut)\r\n            .sub(peerProfiles[rid].state.pendingPayOut);\r\n        require(_amount <= withdrawLimit, \"Exceed withdraw limit\");\r\n\r\n        withdrawIntent.receiver = receiver;\r\n        withdrawIntent.amount = _amount;\r\n        withdrawIntent.requestTime = block.number;\r\n        withdrawIntent.recipientChannelId = _recipientChannelId;\r\n\r\n        emit IntendWithdraw(_channelId, receiver, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Confirm channel withdrawal\r\n     * @dev anyone can confirm a withdrawal intent\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _channelId ID of the channel\r\n     */\r\n    function confirmWithdraw(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes32 _channelId\r\n    )\r\n        external\r\n    {\r\n        LedgerStruct.Channel storage c = _self.channelMap[_channelId];\r\n        require(c.status == LedgerStruct.ChannelStatus.Operable, \"Channel status error\");\r\n        require(c.withdrawIntent.receiver != address(0), \"No pending withdraw intent\");\r\n        require(\r\n            block.number >= c.withdrawIntent.requestTime.add(c.disputeTimeout),\r\n            \"Dispute not timeout\"\r\n        );\r\n\r\n        address receiver = c.withdrawIntent.receiver;\r\n        uint amount = c.withdrawIntent.amount;\r\n        bytes32 recipientChannelId = c.withdrawIntent.recipientChannelId;\r\n        delete c.withdrawIntent;\r\n\r\n        // don't need to check balance because intendWithdraw() has already checked withdraw limit\r\n        // this implicitly require receiver be a peer\r\n        c._addWithdrawal(receiver, amount, false);\r\n        \r\n        (, uint[2] memory deposits, uint[2] memory withdrawals) = c.getBalanceMap();\r\n        emit ConfirmWithdraw(_channelId, amount, receiver, recipientChannelId, deposits, withdrawals);\r\n\r\n        _withdrawFunds(_self, _channelId, receiver, amount, recipientChannelId);\r\n    }\r\n\r\n    /**\r\n     * @notice Veto current withdrawal intent\r\n     * @dev only peers can veto a withdrawal intent;\r\n     *   peers can veto a withdrawal intent even after (requestTime + disputeTimeout)\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _channelId ID of the channel\r\n     */\r\n    function vetoWithdraw(LedgerStruct.Ledger storage _self, bytes32 _channelId) external {\r\n        LedgerStruct.Channel storage c = _self.channelMap[_channelId];\r\n        require(c.status == LedgerStruct.ChannelStatus.Operable, \"Channel status error\");\r\n        require(c.withdrawIntent.receiver != address(0), \"No pending withdraw intent\");\r\n        require(c._isPeer(msg.sender), \"msg.sender is not peer\");\r\n\r\n        delete c.withdrawIntent;\r\n\r\n        emit VetoWithdraw(_channelId);\r\n    }\r\n\r\n    /**\r\n     * @notice Cooperatively withdraw specific amount of deposit\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _cooperativeWithdrawRequest bytes of cooperative withdraw request message\r\n     */\r\n    function cooperativeWithdraw(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes calldata _cooperativeWithdrawRequest\r\n    )\r\n        external\r\n    {\r\n        PbChain.CooperativeWithdrawRequest memory cooperativeWithdrawRequest =\r\n            PbChain.decCooperativeWithdrawRequest(_cooperativeWithdrawRequest);\r\n        PbEntity.CooperativeWithdrawInfo memory withdrawInfo =\r\n            PbEntity.decCooperativeWithdrawInfo(cooperativeWithdrawRequest.withdrawInfo);\r\n        bytes32 channelId = withdrawInfo.channelId;\r\n        bytes32 recipientChannelId = withdrawInfo.recipientChannelId;\r\n        LedgerStruct.Channel storage c = _self.channelMap[channelId];\r\n\r\n        require(c.status == LedgerStruct.ChannelStatus.Operable, \"Channel status error\");\r\n        bytes32 h = keccak256(cooperativeWithdrawRequest.withdrawInfo);\r\n        require(\r\n            c._checkCoSignatures(h, cooperativeWithdrawRequest.sigs),\r\n            \"Check co-sigs failed\"\r\n        );\r\n        // require an increment of exactly 1 for seqNum of each cooperative withdraw request\r\n        require(\r\n            withdrawInfo.seqNum.sub(c.cooperativeWithdrawSeqNum) == 1,\r\n            \"seqNum error\"\r\n        );\r\n        require(block.number <= withdrawInfo.withdrawDeadline, \"Withdraw deadline passed\");\r\n\r\n        address receiver = withdrawInfo.withdraw.account;\r\n        c.cooperativeWithdrawSeqNum = withdrawInfo.seqNum;\r\n        uint amount = withdrawInfo.withdraw.amt;\r\n\r\n        // this implicitly require receiver be a peer\r\n        c._addWithdrawal(receiver, amount, true);\r\n\r\n        (, uint[2] memory deposits, uint[2] memory withdrawals) = c.getBalanceMap();\r\n        emit CooperativeWithdraw(\r\n            channelId,\r\n            amount,\r\n            receiver,\r\n            recipientChannelId,\r\n            deposits,\r\n            withdrawals,\r\n            withdrawInfo.seqNum\r\n        );\r\n\r\n        _withdrawFunds(_self, channelId, receiver, amount, recipientChannelId);\r\n    }\r\n\r\n    /**\r\n     * @notice Intend to settle channel(s) with an array of signed simplex states\r\n     * @dev simplex states in this array are not necessarily in the same channel,\r\n     *   which means intendSettle natively supports multi-channel batch processing.\r\n     *   A simplex state with non-zero seqNum (non-null state) must be co-signed by both peers,\r\n     *   while a simplex state with seqNum=0 (null state) only needs to be signed by one peer.\r\n     *   TODO: wait for Solidity's support to replace SignedSimplexStateArray with bytes[].\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _signedSimplexStateArray bytes of SignedSimplexStateArray message\r\n     */\r\n    function intendSettle(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes calldata _signedSimplexStateArray\r\n    )\r\n        external\r\n    {\r\n        PbChain.SignedSimplexStateArray memory signedSimplexStateArray =\r\n            PbChain.decSignedSimplexStateArray(_signedSimplexStateArray);\r\n        uint simplexStatesNum = signedSimplexStateArray.signedSimplexStates.length;\r\n\r\n        PbEntity.SimplexPaymentChannel memory simplexState =\r\n            PbEntity.decSimplexPaymentChannel(signedSimplexStateArray.signedSimplexStates[0].simplexState);\r\n        for (uint i = 0; i < simplexStatesNum; i++) {\r\n            bytes32 currentChannelId = simplexState.channelId;\r\n            LedgerStruct.Channel storage c = _self.channelMap[currentChannelId];\r\n            require(\r\n                c.status == LedgerStruct.ChannelStatus.Operable ||\r\n                c.status == LedgerStruct.ChannelStatus.Settling,\r\n                \"Channel status error\"\r\n            );\r\n            require(\r\n                c.settleFinalizedTime == 0 || block.number < c.settleFinalizedTime,\r\n                \"Settle has already finalized\"\r\n            );\r\n            \r\n            bytes32 stateHash = keccak256(signedSimplexStateArray.signedSimplexStates[i].simplexState);\r\n            bytes[] memory sigs = signedSimplexStateArray.signedSimplexStates[i].sigs;\r\n\r\n            if (simplexState.seqNum > 0) {  // non-null state\r\n                require(c._checkCoSignatures(stateHash, sigs), \"Check co-sigs failed\");\r\n                uint peerFromId = c._getPeerId(simplexState.peerFrom);\r\n                LedgerStruct.PeerState storage state = c.peerProfiles[peerFromId].state;\r\n                // ensure each state can be intendSettle at most once\r\n                if (c.status == LedgerStruct.ChannelStatus.Operable) {\r\n                    // \"==\" is the case of cooperative on-chain checkpoint\r\n                    require(simplexState.seqNum >= state.seqNum, \"seqNum error\");\r\n                } else if (c.status == LedgerStruct.ChannelStatus.Settling) {\r\n                    require(simplexState.seqNum > state.seqNum, \"seqNum error\");\r\n                } else {\r\n                    assert(false);\r\n                }\r\n\r\n                // update simplexState-dependent fields\r\n                // no need to update pendingPayOut since channel settle process doesn't use it\r\n                state.seqNum = simplexState.seqNum;\r\n                state.transferOut = simplexState.transferToPeer.receiver.amt;\r\n                state.nextPayIdListHash = simplexState.pendingPayIds.nextListHash;\r\n                state.lastPayResolveDeadline = simplexState.lastPayResolveDeadline;\r\n                _clearPays(_self, currentChannelId, peerFromId, simplexState.pendingPayIds.payIds);\r\n            } else if (simplexState.seqNum == 0) {  // null state\r\n                // this implies both stored seqNums are 0\r\n                require(c.settleFinalizedTime == 0, \"intendSettle before\");\r\n                require(\r\n                    sigs.length == 1 && c._checkSingleSignature(stateHash, sigs[0]),\r\n                    \"Check sig failed\"\r\n                );\r\n            } else {\r\n                assert(false);\r\n            }\r\n\r\n            if (i == simplexStatesNum.sub(1)) {\r\n                _updateOverallStatesByIntendState(_self, currentChannelId);\r\n            } else if (i < simplexStatesNum.sub(1)) {\r\n                simplexState = PbEntity.decSimplexPaymentChannel(\r\n                    signedSimplexStateArray.signedSimplexStates[i+1].simplexState\r\n                );\r\n                // enforce channelIds of simplex states are ascending\r\n                require(currentChannelId <= simplexState.channelId, \"Non-ascending channelIds\");\r\n                if (currentChannelId < simplexState.channelId) {\r\n                    _updateOverallStatesByIntendState(_self, currentChannelId);\r\n                }\r\n            } else {\r\n                assert(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Read payment results and add results to corresponding simplex payment channel\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _channelId ID of the channel\r\n     * @param _peerFrom address of the peer who send out funds\r\n     * @param _payIdList bytes of a pay id list\r\n     */\r\n    function clearPays(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes32 _channelId,\r\n        address _peerFrom,\r\n        bytes calldata _payIdList\r\n    )\r\n        external\r\n    {\r\n        LedgerStruct.Channel storage c = _self.channelMap[_channelId];\r\n        require(c.status == LedgerStruct.ChannelStatus.Settling, \"Channel status error\");\r\n        uint peerFromId = c._getPeerId(_peerFrom);\r\n\r\n        bytes32 listHash = keccak256(_payIdList);\r\n        LedgerStruct.PeerState storage state = c.peerProfiles[peerFromId].state;\r\n        require(state.nextPayIdListHash == listHash, \"List hash mismatch\");\r\n\r\n        PbEntity.PayIdList memory payIdList = PbEntity.decPayIdList(_payIdList);\r\n        state.nextPayIdListHash = payIdList.nextListHash;\r\n        _clearPays(_self, _channelId, peerFromId, payIdList.payIds);\r\n    }\r\n\r\n    /**\r\n     * @notice Confirm channel settlement\r\n     * @dev This must be alled after settleFinalizedTime\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _channelId ID of the channel\r\n     */\r\n    function confirmSettle(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes32 _channelId\r\n    )\r\n        external\r\n    {\r\n        LedgerStruct.Channel storage c = _self.channelMap[_channelId];\r\n        LedgerStruct.PeerProfile[2] storage peerProfiles = c.peerProfiles;\r\n        uint blockNumber = block.number;\r\n        require(c.status == LedgerStruct.ChannelStatus.Settling, \"Channel status error\");\r\n        // require no new intendSettle can be called\r\n        require(blockNumber >= c.settleFinalizedTime, \"Settle is not finalized\");\r\n\r\n        // require channel status of current intendSettle has been finalized,\r\n        // namely all payments have already been either cleared or expired\r\n        // TODO: here we should use (lastPayResolveDeadline + clear safe margin)\r\n        //   instead of lastPayResolveDeadline to avoid race condition between clearPays\r\n        //   and confirmSettle, which may lead to different settle balance. Add this safe\r\n        //   margin to the value of lastPayResolveDeadline for now as a temporary solution.\r\n        require(\r\n            (peerProfiles[0].state.nextPayIdListHash == bytes32(0) ||\r\n                blockNumber > peerProfiles[0].state.lastPayResolveDeadline) &&\r\n            (peerProfiles[1].state.nextPayIdListHash == bytes32(0) ||\r\n                blockNumber > peerProfiles[1].state.lastPayResolveDeadline),\r\n            \"Payments are not finalized\"\r\n        );\r\n\r\n        (bool validBalance, uint[2] memory settleBalance) = c._validateSettleBalance();\r\n        if (!validBalance) {\r\n            _resetDuplexState(_self, c);\r\n            emit ConfirmSettleFail(_channelId);\r\n            return;\r\n        }\r\n\r\n        _updateChannelStatus(_self, c, LedgerStruct.ChannelStatus.Closed);\r\n\r\n        emit ConfirmSettle(_channelId, settleBalance);\r\n\r\n        // Withdrawal from Contracts pattern is needless here,\r\n        // because peers need to sign messages which implies that they can't be contracts\r\n        _batchTransferOut(\r\n            _self,\r\n            _channelId,\r\n            c.token.tokenAddress,\r\n            [peerProfiles[0].peerAddr, peerProfiles[1].peerAddr],\r\n            settleBalance\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Cooperatively settle the channel\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _settleRequest bytes of cooperative settle request message\r\n     */\r\n    function cooperativeSettle(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes calldata _settleRequest\r\n    )\r\n        external\r\n    {\r\n        PbChain.CooperativeSettleRequest memory settleRequest =\r\n            PbChain.decCooperativeSettleRequest(_settleRequest);\r\n        PbEntity.CooperativeSettleInfo memory settleInfo =\r\n            PbEntity.decCooperativeSettleInfo(settleRequest.settleInfo);\r\n        bytes32 channelId = settleInfo.channelId;\r\n        LedgerStruct.Channel storage c = _self.channelMap[channelId];\r\n        require(\r\n            c.status == LedgerStruct.ChannelStatus.Operable ||\r\n            c.status == LedgerStruct.ChannelStatus.Settling,\r\n            \"Channel status error\"\r\n        );\r\n\r\n        bytes32 h = keccak256(settleRequest.settleInfo);\r\n        require(c._checkCoSignatures(h, settleRequest.sigs), \"Check co-sigs failed\");\r\n\r\n        address[2] memory peerAddrs = [c.peerProfiles[0].peerAddr, c.peerProfiles[1].peerAddr];\r\n        require(\r\n            settleInfo.seqNum > c.peerProfiles[0].state.seqNum &&\r\n                settleInfo.seqNum > c.peerProfiles[1].state.seqNum,\r\n            \"seqNum error\"\r\n        );\r\n        require(settleInfo.settleDeadline >= block.number, \"Settle deadline passed\");\r\n        // require distribution is consistent with the order of peerAddrs in channel\r\n        require(\r\n            settleInfo.settleBalance[0].account == peerAddrs[0] &&\r\n                settleInfo.settleBalance[1].account == peerAddrs[1],\r\n            \"Settle accounts mismatch\"\r\n        );\r\n\r\n        uint[2] memory settleBalance = [\r\n            settleInfo.settleBalance[0].amt,\r\n            settleInfo.settleBalance[1].amt\r\n        ];\r\n        require(settleBalance[0].add(settleBalance[1]) == c.getTotalBalance(), \"Balance sum mismatch\");\r\n\r\n        _updateChannelStatus(_self, c, LedgerStruct.ChannelStatus.Closed);\r\n\r\n        emit CooperativeSettle(channelId, settleBalance);\r\n\r\n        _batchTransferOut(_self, channelId, c.token.tokenAddress, peerAddrs, settleBalance);\r\n    }\r\n\r\n    /**\r\n     * @notice Return channel number of given status in this contract\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _channelStatus query channel status converted to uint\r\n     * @return channel number of the status\r\n     */\r\n    function getChannelStatusNum(\r\n        LedgerStruct.Ledger storage _self,\r\n        uint _channelStatus\r\n    )\r\n        external\r\n        view\r\n        returns(uint)\r\n    {\r\n        return _self.channelStatusNums[_channelStatus];\r\n    }\r\n\r\n    /**\r\n     * @notice Return EthPool used by this CelerLedger contract\r\n     * @param _self storage data of CelerLedger contract\r\n     * @return EthPool address\r\n     */\r\n    function getEthPool(LedgerStruct.Ledger storage _self) external view returns(address) {\r\n        return address(_self.ethPool);\r\n    }\r\n\r\n    /**\r\n     * @notice Return PayRegistry used by this CelerLedger contract\r\n     * @param _self storage data of CelerLedger contract\r\n     * @return PayRegistry address\r\n     */\r\n    function getPayRegistry(LedgerStruct.Ledger storage _self) external view returns(address) {\r\n        return address(_self.payRegistry);\r\n    }\r\n\r\n    /**\r\n     * @notice Return CelerWallet used by this CelerLedger contract\r\n     * @param _self storage data of CelerLedger contract\r\n     * @return CelerWallet address\r\n     */\r\n    function getCelerWallet(LedgerStruct.Ledger storage _self) external view returns(address) {\r\n        return address(_self.celerWallet);\r\n    }\r\n\r\n    /**\r\n     * @notice create a wallet for a new channel\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _w celer wallet\r\n     * @param _peers peers of the new channel\r\n     * @param _nonce nonce for creating the wallet\r\n     * @return channel id, which is same as the created wallet id\r\n     * @return storage pointer of the channel\r\n     */\r\n    function _createWallet(\r\n        LedgerStruct.Ledger storage _self,\r\n        ICelerWallet _w,\r\n        address[2] memory _peers,\r\n        bytes32 _nonce\r\n    )\r\n        internal\r\n        returns(bytes32, LedgerStruct.Channel storage)\r\n    {\r\n        address[] memory owners = new address[](2);\r\n        owners[0] = _peers[0];\r\n        owners[1] = _peers[1];\r\n        // it is safe to use abi.encodePacked() with only one dynamic variable\r\n        // use walletId as channelId\r\n        bytes32 channelId = _w.create(owners, address(this), _nonce);\r\n        // 0 is reserved for non-channel indication\r\n        require(channelId != bytes32(0), \"channelId gets 0\");\r\n        LedgerStruct.Channel storage c = _self.channelMap[channelId];\r\n        // No harm in having this check in case of keccak256 being broken \r\n        require(c.status == LedgerStruct.ChannelStatus.Uninitialized, \"Occupied channelId\");\r\n\r\n        return (channelId, c);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to add deposit of a channel\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _channelId ID of the channel\r\n     * @param _receiver address of the receiver\r\n     * @param _amount the amount to be deposited\r\n     */\r\n    function _addDeposit(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes32 _channelId,\r\n        address _receiver,\r\n        uint _amount\r\n    )\r\n        internal\r\n    {\r\n        LedgerStruct.Channel storage c = _self.channelMap[_channelId];\r\n        require(c.status == LedgerStruct.ChannelStatus.Operable, \"Channel status error\");\r\n\r\n        // this implicitly require _receiver be a peer\r\n        uint rid = c._getPeerId(_receiver);\r\n        if (_self.balanceLimitsEnabled) {\r\n            require(\r\n                _amount.add(c.getTotalBalance()) <= _self.balanceLimits[c.token.tokenAddress],\r\n                \"Balance exceeds limit\"\r\n            );\r\n        }\r\n\r\n        c.peerProfiles[rid].deposit = c.peerProfiles[rid].deposit.add(_amount);\r\n\r\n        (\r\n            address[2] memory peerAddrs,\r\n            uint[2] memory deposits,\r\n            uint[2] memory withdrawals\r\n        ) = c.getBalanceMap();\r\n        emit Deposit(_channelId, peerAddrs, deposits, withdrawals);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to transfer funds out in batch\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _channelId ID of the channel\r\n     * @param _tokenAddr address of tokens to be transferred out\r\n     * @param _receivers the addresses of token receivers\r\n     * @param _amounts the amounts to be transferred\r\n     */\r\n    function _batchTransferOut(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes32 _channelId,\r\n        address _tokenAddr,\r\n        address[2] memory _receivers,\r\n        uint[2] memory _amounts\r\n    )\r\n        internal\r\n    {\r\n        for (uint i = 0; i < 2; i++) {\r\n            if (_amounts[i] == 0) { continue; }\r\n\r\n            _self.celerWallet.withdraw(_channelId, _tokenAddr, _receivers[i], _amounts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to withdraw funds out of the channel\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _channelId ID of the channel\r\n     * @param _receiver address of the receiver of the withdrawn funds\r\n     * @param _amount the amount of the withdrawn funds\r\n     * @param _recipientChannelId ID of the recipient channel\r\n     */\r\n    function _withdrawFunds(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes32 _channelId,\r\n        address _receiver,\r\n        uint _amount,\r\n        bytes32 _recipientChannelId\r\n    )\r\n        internal\r\n    {\r\n        if (_amount == 0) { return; }\r\n\r\n        LedgerStruct.Channel storage c = _self.channelMap[_channelId];\r\n        if (_recipientChannelId == bytes32(0)) {\r\n            _self.celerWallet.withdraw(_channelId, c.token.tokenAddress, _receiver, _amount);\r\n        } else {\r\n            LedgerStruct.Channel storage recipientChannel = _self.channelMap[_recipientChannelId];\r\n            require(\r\n                c.token.tokenType == recipientChannel.token.tokenType &&\r\n                    c.token.tokenAddress == recipientChannel.token.tokenAddress,\r\n                \"Token mismatch of recipient channel\"\r\n            );\r\n            _addDeposit(_self, _recipientChannelId, _receiver, _amount);\r\n\r\n            // move funds from one channel's wallet to another channel's wallet\r\n            _self.celerWallet.transferToWallet(\r\n                _channelId,\r\n                _recipientChannelId,\r\n                c.token.tokenAddress,\r\n                _receiver,\r\n                _amount\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Reset the state of the channel\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _c the channel\r\n     */\r\n    function _resetDuplexState(\r\n        LedgerStruct.Ledger storage _self,\r\n        LedgerStruct.Channel storage _c\r\n    )\r\n        internal\r\n    {\r\n        delete _c.settleFinalizedTime;\r\n        _updateChannelStatus(_self, _c, LedgerStruct.ChannelStatus.Operable);\r\n        delete _c.peerProfiles[0].state;\r\n        delete _c.peerProfiles[1].state;\r\n        // reset possibly remaining WithdrawIntent freezed by previous intendSettle()\r\n        delete _c.withdrawIntent;\r\n    }\r\n\r\n    /**\r\n     * @notice Clear payments by their hash array\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _channelId the channel ID\r\n     * @param _peerId ID of the peer who sends out funds\r\n     * @param _payIds array of pay ids to clear\r\n     */\r\n    function _clearPays(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes32 _channelId,\r\n        uint _peerId,\r\n        bytes32[] memory _payIds\r\n    )\r\n        internal\r\n    {\r\n        LedgerStruct.Channel storage c = _self.channelMap[_channelId];\r\n        uint[] memory outAmts = _self.payRegistry.getPayAmounts(\r\n            _payIds,\r\n            c.peerProfiles[_peerId].state.lastPayResolveDeadline\r\n        );\r\n\r\n        uint totalAmtOut = 0;\r\n        for (uint i = 0; i < outAmts.length; i++) {\r\n            totalAmtOut = totalAmtOut.add(outAmts[i]);\r\n            emit ClearOnePay(_channelId, _payIds[i], c.peerProfiles[_peerId].peerAddr, outAmts[i]);\r\n        }\r\n        c.peerProfiles[_peerId].state.transferOut =\r\n            c.peerProfiles[_peerId].state.transferOut.add(totalAmtOut);\r\n    }\r\n\r\n    /**\r\n     * @notice Update overall states of a duplex channel\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _channelId the channel ID\r\n     */\r\n    function _updateOverallStatesByIntendState(\r\n        LedgerStruct.Ledger storage _self,\r\n        bytes32 _channelId\r\n    )\r\n        internal\r\n    {\r\n        LedgerStruct.Channel storage c = _self.channelMap[_channelId];\r\n        c.settleFinalizedTime = block.number.add(c.disputeTimeout);\r\n        _updateChannelStatus(_self, c, LedgerStruct.ChannelStatus.Settling);\r\n\r\n        emit IntendSettle(_channelId, c._getStateSeqNums());\r\n    }\r\n\r\n    /**\r\n     * @notice Update status of a channel\r\n     * @param _self storage data of CelerLedger contract\r\n     * @param _c the channel\r\n     * @param _newStatus new channel status\r\n     */\r\n    function _updateChannelStatus(\r\n        LedgerStruct.Ledger storage _self,\r\n        LedgerStruct.Channel storage _c,\r\n        LedgerStruct.ChannelStatus _newStatus\r\n    )\r\n        internal\r\n    {\r\n        if (_c.status == _newStatus) {\r\n            return;\r\n        }\r\n\r\n        // update counter of old status\r\n        if (_c.status != LedgerStruct.ChannelStatus.Uninitialized) {\r\n            _self.channelStatusNums[uint(_c.status)] = _self.channelStatusNums[uint(_c.status)].sub(1);\r\n        }\r\n\r\n        // update counter of new status\r\n        _self.channelStatusNums[uint(_newStatus)] = _self.channelStatusNums[uint(_newStatus)].add(1);\r\n\r\n        _c.status = _newStatus;\r\n    }\r\n\r\n    /**\r\n     * @notice Validate token info\r\n     * @param _token token info to be validated\r\n     * @return validated token info\r\n     */\r\n    function _validateTokenInfo(PbEntity.TokenInfo memory _token)\r\n        internal\r\n        view\r\n        returns(PbEntity.TokenInfo memory)\r\n    {\r\n        if (_token.tokenType == PbEntity.TokenType.ETH) {\r\n            require(_token.tokenAddress == address(0));\r\n        } else if (_token.tokenType == PbEntity.TokenType.ERC20) {\r\n            require(_token.tokenAddress != address(0));\r\n            require(_token.tokenAddress.isContract());\r\n        } else {\r\n            assert(false);\r\n        }\r\n\r\n        return _token;\r\n    }\r\n\r\n    event OpenChannel(\r\n        bytes32 indexed channelId,\r\n        uint tokenType,\r\n        address indexed tokenAddress,\r\n        // TODO: there is an issue of setting address[2] as indexed. Need to fix and make this indexed\r\n        address[2] peerAddrs,\r\n        uint[2] initialDeposits\r\n    );\r\n\r\n    // TODO: there is an issue of setting address[2] as indexed. Need to fix and make this indexed\r\n    event Deposit(bytes32 indexed channelId, address[2] peerAddrs, uint[2] deposits, uint[2] withdrawals);\r\n\r\n    event SnapshotStates(bytes32 indexed channelId, uint[2] seqNums);\r\n\r\n    event IntendSettle(bytes32 indexed channelId, uint[2] seqNums);\r\n\r\n    event ClearOnePay(bytes32 indexed channelId, bytes32 indexed payId, address indexed peerFrom, uint amount);\r\n\r\n    event ConfirmSettle(bytes32 indexed channelId, uint[2] settleBalance);\r\n\r\n    event ConfirmSettleFail(bytes32 indexed channelId);\r\n\r\n    event IntendWithdraw(bytes32 indexed channelId, address indexed receiver, uint amount);\r\n\r\n    event ConfirmWithdraw(\r\n        bytes32 indexed channelId,\r\n        uint withdrawnAmount,\r\n        address indexed receiver,\r\n        bytes32 indexed recipientChannelId,\r\n        uint[2] deposits,\r\n        uint[2] withdrawals\r\n    );\r\n\r\n    event VetoWithdraw(bytes32 indexed channelId);\r\n\r\n    event CooperativeWithdraw(\r\n        bytes32 indexed channelId,\r\n        uint withdrawnAmount,\r\n        address indexed receiver,\r\n        bytes32 indexed recipientChannelId,\r\n        uint[2] deposits,\r\n        uint[2] withdrawals,\r\n        uint seqNum\r\n    );\r\n\r\n    event CooperativeSettle(bytes32 indexed channelId, uint[2] settleBalance);\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"tokenType\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"peerAddrs\",\"type\":\"address[2]\"},{\"indexed\":false,\"name\":\"initialDeposits\",\"type\":\"uint256[2]\"}],\"name\":\"OpenChannel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"peerAddrs\",\"type\":\"address[2]\"},{\"indexed\":false,\"name\":\"deposits\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"withdrawals\",\"type\":\"uint256[2]\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"seqNums\",\"type\":\"uint256[2]\"}],\"name\":\"SnapshotStates\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"seqNums\",\"type\":\"uint256[2]\"}],\"name\":\"IntendSettle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"payId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"peerFrom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClearOnePay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"settleBalance\",\"type\":\"uint256[2]\"}],\"name\":\"ConfirmSettle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"}],\"name\":\"ConfirmSettleFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"IntendWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipientChannelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"deposits\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"withdrawals\",\"type\":\"uint256[2]\"}],\"name\":\"ConfirmWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"}],\"name\":\"VetoWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipientChannelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"deposits\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"withdrawals\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"seqNum\",\"type\":\"uint256\"}],\"name\":\"CooperativeWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"settleBalance\",\"type\":\"uint256[2]\"}],\"name\":\"CooperativeSettle\",\"type\":\"event\"}]","ContractName":"LedgerOperation","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"byzantium","Library":"LedgerChannel:3e7a98b71fbacbca632bc52033d6057e142a0b33","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://3f605fcdde5b8e3b2c33d675a8aaca3c915650e08053f63cd20bb4ff7f818151"}]}