{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/interface/IPayRegistry.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n/**\r\n * @title PayRegistry interface\r\n */\r\ninterface IPayRegistry {\r\n    function calculatePayId(bytes32 _payHash, address _setter) external pure returns(bytes32);\r\n\r\n    function setPayAmount(bytes32 _payHash, uint _amt) external;\r\n\r\n    function setPayDeadline(bytes32 _payHash, uint _deadline) external;\r\n\r\n    function setPayInfo(bytes32 _payHash, uint _amt, uint _deadline) external;\r\n\r\n    function setPayAmounts(bytes32[] calldata _payHashes, uint[] calldata _amts) external;\r\n\r\n    function setPayDeadlines(bytes32[] calldata _payHashes, uint[] calldata _deadlines) external;\r\n\r\n    function setPayInfos(bytes32[] calldata _payHashes, uint[] calldata _amts, uint[] calldata _deadlines) external;\r\n\r\n    function getPayAmounts(\r\n        bytes32[] calldata _payIds,\r\n        uint _lastPayResolveDeadline\r\n    ) external view returns(uint[] memory);\r\n\r\n    function getPayInfo(bytes32 _payId) external view returns(uint, uint);\r\n\r\n    event PayInfoUpdate(bytes32 indexed payId, uint amount, uint resolveDeadline);\r\n}\r\n\r\n// File: contracts/PayRegistry.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n\r\n/**\r\n * @title Pay Registry contract\r\n * @notice Implementation of a global registry to record payment results\r\n *   reported by different PayResolvers.\r\n */\r\ncontract PayRegistry is IPayRegistry {\r\n    struct PayInfo {\r\n        uint amount;\r\n        uint resolveDeadline;\r\n    }\r\n\r\n    // bytes32 payId => PayInfo payInfo\r\n    mapping(bytes32 => PayInfo) public payInfoMap;\r\n\r\n    /**\r\n     * @notice Calculate pay id\r\n     * @param _payHash hash of serialized condPay\r\n     * @param _setter payment info setter, i.e. pay resolver\r\n     * @return calculated pay id\r\n     */\r\n    function calculatePayId(bytes32 _payHash, address _setter) public pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(_payHash, _setter));\r\n    }\r\n\r\n    function setPayAmount(bytes32 _payHash, uint _amt) external {\r\n        bytes32 payId = calculatePayId(_payHash, msg.sender);\r\n        PayInfo storage payInfo = payInfoMap[payId];\r\n        payInfo.amount = _amt;\r\n\r\n        emit PayInfoUpdate(payId, _amt, payInfo.resolveDeadline);\r\n    }\r\n\r\n    function setPayDeadline(bytes32 _payHash, uint _deadline) external {\r\n        bytes32 payId = calculatePayId(_payHash, msg.sender);\r\n        PayInfo storage payInfo = payInfoMap[payId];\r\n        payInfo.resolveDeadline = _deadline;\r\n\r\n        emit PayInfoUpdate(payId, payInfo.amount, _deadline);\r\n    }\r\n\r\n    function setPayInfo(bytes32 _payHash, uint _amt, uint _deadline) external {\r\n        bytes32 payId = calculatePayId(_payHash, msg.sender);\r\n        PayInfo storage payInfo = payInfoMap[payId];\r\n        payInfo.amount = _amt;\r\n        payInfo.resolveDeadline = _deadline;\r\n\r\n        emit PayInfoUpdate(payId, _amt, _deadline);\r\n    }\r\n\r\n    function setPayAmounts(bytes32[] calldata _payHashes, uint[] calldata _amts) external {\r\n        require(_payHashes.length == _amts.length, \"Lengths do not match\");\r\n\r\n        bytes32 payId;\r\n        address msgSender = msg.sender;\r\n        for (uint i = 0; i < _payHashes.length; i++) {\r\n            payId = calculatePayId(_payHashes[i], msgSender);\r\n            PayInfo storage payInfo = payInfoMap[payId];\r\n            payInfo.amount = _amts[i];\r\n\r\n            emit PayInfoUpdate(payId, _amts[i], payInfo.resolveDeadline);\r\n        }\r\n    }\r\n\r\n    function setPayDeadlines(bytes32[] calldata _payHashes, uint[] calldata _deadlines) external {\r\n        require(_payHashes.length == _deadlines.length, \"Lengths do not match\");\r\n\r\n        bytes32 payId;\r\n        address msgSender = msg.sender;\r\n        for (uint i = 0; i < _payHashes.length; i++) {\r\n            payId = calculatePayId(_payHashes[i], msgSender);\r\n            PayInfo storage payInfo = payInfoMap[payId];\r\n            payInfo.resolveDeadline = _deadlines[i];\r\n\r\n            emit PayInfoUpdate(payId, payInfo.amount, _deadlines[i]);\r\n        }\r\n    }\r\n\r\n    function setPayInfos(bytes32[] calldata _payHashes, uint[] calldata _amts, uint[] calldata _deadlines) external {\r\n        require(\r\n            _payHashes.length == _amts.length && _payHashes.length == _deadlines.length,\r\n            \"Lengths do not match\"\r\n        );\r\n\r\n        bytes32 payId;\r\n        address msgSender = msg.sender;\r\n        for (uint i = 0; i < _payHashes.length; i++) {\r\n            payId = calculatePayId(_payHashes[i], msgSender);\r\n            PayInfo storage payInfo = payInfoMap[payId];\r\n            payInfo.amount = _amts[i];\r\n            payInfo.resolveDeadline = _deadlines[i];\r\n\r\n            emit PayInfoUpdate(payId, _amts[i], _deadlines[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the amounts of a list of queried pays\r\n     * @dev pay results must have been unchangable before calling this function.\r\n     *   This API is for CelerLedger\r\n     * @param _payIds ids of queried pays\r\n     * @param _lastPayResolveDeadline the last pay resolve deadline of all queried pays\r\n     * @return queried pay amounts\r\n     */\r\n    function getPayAmounts(\r\n        bytes32[] calldata _payIds,\r\n        uint _lastPayResolveDeadline\r\n    )\r\n        external view returns(uint[] memory)\r\n    {\r\n        uint[] memory amounts = new uint[](_payIds.length);\r\n        for (uint i = 0; i < _payIds.length; i++) {\r\n            if (payInfoMap[_payIds[i]].resolveDeadline == 0) {\r\n                // should pass last pay resolve deadline if never resolved\r\n                require(block.number > _lastPayResolveDeadline, \"Payment is not finalized\");\r\n            } else {\r\n                // should pass resolve deadline if resolved\r\n                require(\r\n                    block.number > payInfoMap[_payIds[i]].resolveDeadline,\r\n                    \"Payment is not finalized\"\r\n                );\r\n            }\r\n            amounts[i] = payInfoMap[_payIds[i]].amount;\r\n        }\r\n        return amounts;\r\n    }\r\n\r\n    function getPayInfo(bytes32 _payId) external view returns(uint, uint) {\r\n        PayInfo storage payInfo = payInfoMap[_payId];\r\n        return (payInfo.amount, payInfo.resolveDeadline);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_payHashes\",\"type\":\"bytes32[]\"},{\"name\":\"_deadlines\",\"type\":\"uint256[]\"}],\"name\":\"setPayDeadlines\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payHashes\",\"type\":\"bytes32[]\"},{\"name\":\"_amts\",\"type\":\"uint256[]\"}],\"name\":\"setPayAmounts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_payId\",\"type\":\"bytes32\"}],\"name\":\"getPayInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payHashes\",\"type\":\"bytes32[]\"},{\"name\":\"_amts\",\"type\":\"uint256[]\"},{\"name\":\"_deadlines\",\"type\":\"uint256[]\"}],\"name\":\"setPayInfos\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_payIds\",\"type\":\"bytes32[]\"},{\"name\":\"_lastPayResolveDeadline\",\"type\":\"uint256\"}],\"name\":\"getPayAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"payInfoMap\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"resolveDeadline\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_payHash\",\"type\":\"bytes32\"},{\"name\":\"_setter\",\"type\":\"address\"}],\"name\":\"calculatePayId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payHash\",\"type\":\"bytes32\"},{\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"setPayDeadline\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payHash\",\"type\":\"bytes32\"},{\"name\":\"_amt\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"setPayInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payHash\",\"type\":\"bytes32\"},{\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"setPayAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"resolveDeadline\",\"type\":\"uint256\"}],\"name\":\"PayInfoUpdate\",\"type\":\"event\"}]","ContractName":"PayRegistry","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"byzantium","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://7fb2d6e01db7df745dcc11670cc9d62a37205b7774c19a8d372e5d099e892ee1"}]}