{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function _implementation() internal view returns(address);\r\n\r\n    /**\r\n    * @dev Fallback function.\r\n    * Implemented entirely in `_fallback`.\r\n    */\r\n    function _fallback() internal {\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function _delegate(address implementation) internal {\r\n        /*solium-disable-next-line security/no-inline-assembly*/\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize)\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize)\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize) }\r\n            default { return(0, returndatasize) }\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        _fallback();\r\n    }\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n    // Version name of the current implementation\r\n    string internal __version;\r\n\r\n    // Address of the current implementation\r\n    address internal __implementation;\r\n\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param _newVersion representing the version name of the upgraded implementation\r\n    * @param _newImplementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(string _newVersion, address indexed _newImplementation);\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param _newVersion representing the version name of the new implementation to be set\r\n    * @param _newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(string memory _newVersion, address _newImplementation) internal {\r\n        require(\r\n            __implementation != _newImplementation && _newImplementation != address(0),\r\n            \"Old address is not allowed and implementation address should not be 0x\"\r\n        );\r\n        require(Address.isContract(_newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\r\n        require(bytes(_newVersion).length > 0, \"Version should not be empty string\");\r\n        require(keccak256(abi.encodePacked(__version)) != keccak256(abi.encodePacked(_newVersion)), \"New version equals to current\");\r\n        __version = _newVersion;\r\n        __implementation = _newImplementation;\r\n        emit Upgraded(_newVersion, _newImplementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n    // Owner of the contract\r\n    address private __upgradeabilityOwner;\r\n\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param _previousOwner representing the address of the previous owner\r\n    * @param _newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address _previousOwner, address _newOwner);\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier ifOwner() {\r\n        if (msg.sender == _upgradeabilityOwner()) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor() public {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function _upgradeabilityOwner() internal view returns(address) {\r\n        return __upgradeabilityOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the owner\r\n    */\r\n    function _setUpgradeabilityOwner(address _newUpgradeabilityOwner) internal {\r\n        require(_newUpgradeabilityOwner != address(0), \"Address should not be 0x\");\r\n        __upgradeabilityOwner = _newUpgradeabilityOwner;\r\n    }\r\n\r\n    /**\r\n    * @notice Internal function to provide the address of the implementation contract\r\n    */\r\n    function _implementation() internal view returns(address) {\r\n        return __implementation;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the proxy owner\r\n    * @return the address of the proxy owner\r\n    */\r\n    function proxyOwner() external ifOwner returns(address) {\r\n        return _upgradeabilityOwner();\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the version name of the current implementation\r\n    * @return string representing the name of the current version\r\n    */\r\n    function version() external ifOwner returns(string memory) {\r\n        return __version;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() external ifOwner returns(address) {\r\n        return _implementation();\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address _newOwner) external ifOwner {\r\n        require(_newOwner != address(0), \"Address should not be 0x\");\r\n        emit ProxyOwnershipTransferred(_upgradeabilityOwner(), _newOwner);\r\n        _setUpgradeabilityOwner(_newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the upgradeability owner to upgrade the current version of the proxy.\r\n    * @param _newVersion representing the version name of the new implementation to be set.\r\n    * @param _newImplementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(string calldata _newVersion, address _newImplementation) external ifOwner {\r\n        _upgradeTo(_newVersion, _newImplementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the upgradeability owner to upgrade the current version of the proxy and call the new implementation\r\n    * to initialize whatever is needed through a low level call.\r\n    * @param _newVersion representing the version name of the new implementation to be set.\r\n    * @param _newImplementation representing the address of the new implementation to be set.\r\n    * @param _data represents the msg.data to bet sent in the low level call. This parameter may include the function\r\n    * signature of the implementation to be called with the needed payload\r\n    */\r\n    function upgradeToAndCall(string calldata _newVersion, address _newImplementation, bytes calldata _data) external payable ifOwner {\r\n        _upgradeToAndCall(_newVersion, _newImplementation, _data);\r\n    }\r\n\r\n    function _upgradeToAndCall(string memory _newVersion, address _newImplementation, bytes memory _data) internal {\r\n        _upgradeTo(_newVersion, _newImplementation);\r\n        bool success;\r\n        /*solium-disable-next-line security/no-call-value*/\r\n        (success, ) = address(this).call.value(msg.value)(_data);\r\n        require(success, \"Fail in executing the function of implementation contract\");\r\n    }\r\n\r\n}\r\n\r\n/* \r\n * @dev It is the contract that contains the storage items related to the ERC20 contract implementaiton\r\n * of the openzeppelin-solidity. Used to allow the storage declaration of ERC20 to the STGetter contract\r\n*/\r\n\r\ncontract OZStorage {\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    function totalSupply() internal view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _investor) internal view returns(uint256) {\r\n        return _balances[_investor];\r\n    }\r\n\r\n    function _allowance(address owner, address spender) internal view returns(uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n}\r\n\r\ninterface IDataStore {\r\n    /**\r\n     * @dev Changes security token atatched to this data store\r\n     * @param _securityToken address of the security token\r\n     */\r\n    function setSecurityToken(address _securityToken) external;\r\n\r\n    /**\r\n     * @dev Stores a uint256 data against a key\r\n     * @param _key Unique key to identify the data\r\n     * @param _data Data to be stored against the key\r\n     */\r\n    function setUint256(bytes32 _key, uint256 _data) external;\r\n\r\n    function setBytes32(bytes32 _key, bytes32 _data) external;\r\n\r\n    function setAddress(bytes32 _key, address _data) external;\r\n\r\n    function setString(bytes32 _key, string calldata _data) external;\r\n\r\n    function setBytes(bytes32 _key, bytes calldata _data) external;\r\n\r\n    function setBool(bytes32 _key, bool _data) external;\r\n\r\n    /**\r\n     * @dev Stores a uint256 array against a key\r\n     * @param _key Unique key to identify the array\r\n     * @param _data Array to be stored against the key\r\n     */\r\n    function setUint256Array(bytes32 _key, uint256[] calldata _data) external;\r\n\r\n    function setBytes32Array(bytes32 _key, bytes32[] calldata _data) external ;\r\n\r\n    function setAddressArray(bytes32 _key, address[] calldata _data) external;\r\n\r\n    function setBoolArray(bytes32 _key, bool[] calldata _data) external;\r\n\r\n    /**\r\n     * @dev Inserts a uint256 element to the array identified by the key\r\n     * @param _key Unique key to identify the array\r\n     * @param _data Element to push into the array\r\n     */\r\n    function insertUint256(bytes32 _key, uint256 _data) external;\r\n\r\n    function insertBytes32(bytes32 _key, bytes32 _data) external;\r\n\r\n    function insertAddress(bytes32 _key, address _data) external;\r\n\r\n    function insertBool(bytes32 _key, bool _data) external;\r\n\r\n    /**\r\n     * @dev Deletes an element from the array identified by the key.\r\n     * When an element is deleted from an Array, last element of that array is moved to the index of deleted element.\r\n     * @param _key Unique key to identify the array\r\n     * @param _index Index of the element to delete\r\n     */\r\n    function deleteUint256(bytes32 _key, uint256 _index) external;\r\n\r\n    function deleteBytes32(bytes32 _key, uint256 _index) external;\r\n\r\n    function deleteAddress(bytes32 _key, uint256 _index) external;\r\n\r\n    function deleteBool(bytes32 _key, uint256 _index) external;\r\n\r\n    /**\r\n     * @dev Stores multiple uint256 data against respective keys\r\n     * @param _keys Array of keys to identify the data\r\n     * @param _data Array of data to be stored against the respective keys\r\n     */\r\n    function setUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\r\n\r\n    function setBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\r\n\r\n    function setAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\r\n\r\n    function setBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\r\n\r\n    /**\r\n     * @dev Inserts multiple uint256 elements to the array identified by the respective keys\r\n     * @param _keys Array of keys to identify the data\r\n     * @param _data Array of data to be inserted in arrays of the respective keys\r\n     */\r\n    function insertUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\r\n\r\n    function insertBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\r\n\r\n    function insertAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\r\n\r\n    function insertBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\r\n\r\n    function getUint256(bytes32 _key) external view returns(uint256);\r\n\r\n    function getBytes32(bytes32 _key) external view returns(bytes32);\r\n\r\n    function getAddress(bytes32 _key) external view returns(address);\r\n\r\n    function getString(bytes32 _key) external view returns(string memory);\r\n\r\n    function getBytes(bytes32 _key) external view returns(bytes memory);\r\n\r\n    function getBool(bytes32 _key) external view returns(bool);\r\n\r\n    function getUint256Array(bytes32 _key) external view returns(uint256[] memory);\r\n\r\n    function getBytes32Array(bytes32 _key) external view returns(bytes32[] memory);\r\n\r\n    function getAddressArray(bytes32 _key) external view returns(address[] memory);\r\n\r\n    function getBoolArray(bytes32 _key) external view returns(bool[] memory);\r\n\r\n    function getUint256ArrayLength(bytes32 _key) external view returns(uint256);\r\n\r\n    function getBytes32ArrayLength(bytes32 _key) external view returns(uint256);\r\n\r\n    function getAddressArrayLength(bytes32 _key) external view returns(uint256);\r\n\r\n    function getBoolArrayLength(bytes32 _key) external view returns(uint256);\r\n\r\n    function getUint256ArrayElement(bytes32 _key, uint256 _index) external view returns(uint256);\r\n\r\n    function getBytes32ArrayElement(bytes32 _key, uint256 _index) external view returns(bytes32);\r\n\r\n    function getAddressArrayElement(bytes32 _key, uint256 _index) external view returns(address);\r\n\r\n    function getBoolArrayElement(bytes32 _key, uint256 _index) external view returns(bool);\r\n\r\n    function getUint256ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(uint256[] memory);\r\n\r\n    function getBytes32ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bytes32[] memory);\r\n\r\n    function getAddressArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(address[] memory);\r\n\r\n    function getBoolArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bool[] memory);\r\n}\r\n\r\n/**\r\n * @title Interface for the Polymath Module Registry contract\r\n */\r\ninterface IModuleRegistry {\r\n\r\n    ///////////\r\n    // Events\r\n    //////////\r\n\r\n    // Emit when network becomes paused\r\n    event Pause(address account);\r\n    // Emit when network becomes unpaused\r\n    event Unpause(address account);\r\n    // Emit when Module is used by the SecurityToken\r\n    event ModuleUsed(address indexed _moduleFactory, address indexed _securityToken);\r\n    // Emit when the Module Factory gets registered on the ModuleRegistry contract\r\n    event ModuleRegistered(address indexed _moduleFactory, address indexed _owner);\r\n    // Emit when the module gets verified by Polymath\r\n    event ModuleVerified(address indexed _moduleFactory);\r\n    // Emit when the module gets unverified by Polymath or the factory owner\r\n    event ModuleUnverified(address indexed _moduleFactory);\r\n    // Emit when a ModuleFactory is removed by Polymath\r\n    event ModuleRemoved(address indexed _moduleFactory, address indexed _decisionMaker);\r\n    // Emit when ownership gets transferred\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @notice Called by a security token (2.x) to notify the registry it is using a module\r\n     * @param _moduleFactory is the address of the relevant module factory\r\n     */\r\n    function useModule(address _moduleFactory) external;\r\n\r\n    /**\r\n     * @notice Called by a security token to notify the registry it is using a module\r\n     * @param _moduleFactory is the address of the relevant module factory\r\n     * @param _isUpgrade whether the use is part of an existing module upgrade\r\n     */\r\n    function useModule(address _moduleFactory, bool _isUpgrade) external;\r\n\r\n    /**\r\n     * @notice Called by the ModuleFactory owner to register new modules for SecurityToken to use\r\n     * @param _moduleFactory is the address of the module factory to be registered\r\n     */\r\n    function registerModule(address _moduleFactory) external;\r\n\r\n    /**\r\n     * @notice Called by the ModuleFactory owner or registry curator to delete a ModuleFactory\r\n     * @param _moduleFactory is the address of the module factory to be deleted\r\n     */\r\n    function removeModule(address _moduleFactory) external;\r\n\r\n    /**\r\n     * @notice Check that a module and its factory are compatible\r\n     * @param _moduleFactory is the address of the relevant module factory\r\n     * @param _securityToken is the address of the relevant security token\r\n     * @return bool whether module and token are compatible\r\n     */\r\n    function isCompatibleModule(address _moduleFactory, address _securityToken) external view returns(bool isCompatible);\r\n\r\n    /**\r\n    * @notice Called by Polymath to verify modules for SecurityToken to use.\r\n    * @notice A module can not be used by an ST unless first approved/verified by Polymath\r\n    * @notice (The only exception to this is that the author of the module is the owner of the ST - Only if enabled by the FeatureRegistry)\r\n    * @param _moduleFactory is the address of the module factory to be registered\r\n    */\r\n    function verifyModule(address _moduleFactory) external;\r\n\r\n    /**\r\n    * @notice Called by Polymath to unverify modules for SecurityToken to use.\r\n    * @notice A module can not be used by an ST unless first approved/verified by Polymath\r\n    * @notice (The only exception to this is that the author of the module is the owner of the ST - Only if enabled by the FeatureRegistry)\r\n    * @param _moduleFactory is the address of the module factory to be registered\r\n    */\r\n    function unverifyModule(address _moduleFactory) external;\r\n\r\n    /**\r\n     * @notice Returns the verified status, and reputation of the entered Module Factory\r\n     * @param _factoryAddress is the address of the module factory\r\n     * @return bool indicating whether module factory is verified\r\n     * @return address of the factory owner\r\n     * @return address array which contains the list of securityTokens that use that module factory\r\n     */\r\n    function getFactoryDetails(address _factoryAddress) external view returns(bool isVerified, address factoryOwner, address[] memory usingTokens);\r\n\r\n    /**\r\n     * @notice Returns all the tags related to the a module type which are valid for the given token\r\n     * @param _moduleType is the module type\r\n     * @param _securityToken is the token\r\n     * @return list of tags\r\n     * @return corresponding list of module factories\r\n     */\r\n    function getTagsByTypeAndToken(uint8 _moduleType, address _securityToken) external view returns(bytes32[] memory tags, address[] memory factories);\r\n\r\n    /**\r\n     * @notice Returns all the tags related to the a module type which are valid for the given token\r\n     * @param _moduleType is the module type\r\n     * @return list of tags\r\n     * @return corresponding list of module factories\r\n     */\r\n    function getTagsByType(uint8 _moduleType) external view returns(bytes32[] memory tags, address[] memory factories);\r\n\r\n    /**\r\n     * @notice Returns the list of addresses of all Module Factory of a particular type\r\n     * @param _moduleType Type of Module\r\n     * @return address array that contains the list of addresses of module factory contracts.\r\n     */\r\n    function getAllModulesByType(uint8 _moduleType) external view returns(address[] memory factories);\r\n    /**\r\n     * @notice Returns the list of addresses of Module Factory of a particular type\r\n     * @param _moduleType Type of Module\r\n     * @return address array that contains the list of addresses of module factory contracts.\r\n     */\r\n    function getModulesByType(uint8 _moduleType) external view returns(address[] memory factories);\r\n\r\n    /**\r\n     * @notice Returns the list of available Module factory addresses of a particular type for a given token.\r\n     * @param _moduleType is the module type to look for\r\n     * @param _securityToken is the address of SecurityToken\r\n     * @return address array that contains the list of available addresses of module factory contracts.\r\n     */\r\n    function getModulesByTypeAndToken(uint8 _moduleType, address _securityToken) external view returns(address[] memory factories);\r\n\r\n    /**\r\n     * @notice Use to get the latest contract address of the regstries\r\n     */\r\n    function updateFromRegistry() external;\r\n\r\n    /**\r\n     * @notice Get the owner of the contract\r\n     * @return address owner\r\n     */\r\n    function owner() external view returns(address ownerAddress);\r\n\r\n    /**\r\n     * @notice Check whether the contract operations is paused or not\r\n     * @return bool\r\n     */\r\n    function isPaused() external view returns(bool paused);\r\n\r\n    /**\r\n     * @notice Reclaims all ERC20Basic compatible tokens\r\n     * @param _tokenContract The address of the token contract\r\n     */\r\n    function reclaimERC20(address _tokenContract) external;\r\n\r\n    /**\r\n     * @notice Called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() external;\r\n\r\n    /**\r\n     * @notice Called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() external;\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) external;\r\n\r\n}\r\n\r\ninterface IPolymathRegistry {\r\n\r\n    event ChangeAddress(string _nameKey, address indexed _oldAddress, address indexed _newAddress);\r\n    \r\n    /**\r\n     * @notice Returns the contract address\r\n     * @param _nameKey is the key for the contract address mapping\r\n     * @return address\r\n     */\r\n    function getAddress(string calldata _nameKey) external view returns(address registryAddress);\r\n\r\n    /**\r\n     * @notice Changes the contract address\r\n     * @param _nameKey is the key for the contract address mapping\r\n     * @param _newAddress is the new contract address\r\n     */\r\n    function changeAddress(string calldata _nameKey, address _newAddress) external;\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for the Polymath Security Token Registry contract\r\n */\r\ninterface ISecurityTokenRegistry {\r\n\r\n    // Emit when network becomes paused\r\n    event Pause(address account);\r\n    // Emit when network becomes unpaused\r\n    event Unpause(address account);\r\n    // Emit when the ticker is removed from the registry\r\n    event TickerRemoved(string _ticker, address _removedBy);\r\n    // Emit when the token ticker expiry is changed\r\n    event ChangeExpiryLimit(uint256 _oldExpiry, uint256 _newExpiry);\r\n    // Emit when changeSecurityLaunchFee is called\r\n    event ChangeSecurityLaunchFee(uint256 _oldFee, uint256 _newFee);\r\n    // Emit when changeTickerRegistrationFee is called\r\n    event ChangeTickerRegistrationFee(uint256 _oldFee, uint256 _newFee);\r\n    // Emit when Fee currency is changed\r\n    event ChangeFeeCurrency(bool _isFeeInPoly);\r\n    // Emit when ownership gets transferred\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    // Emit when ownership of the ticker gets changed\r\n    event ChangeTickerOwnership(string _ticker, address indexed _oldOwner, address indexed _newOwner);\r\n    // Emit at the time of launching a new security token of version 3.0+\r\n    event NewSecurityToken(\r\n        string _ticker,\r\n        string _name,\r\n        address indexed _securityTokenAddress,\r\n        address indexed _owner,\r\n        uint256 _addedAt,\r\n        address _registrant,\r\n        bool _fromAdmin,\r\n        uint256 _usdFee,\r\n        uint256 _polyFee,\r\n        uint256 _protocolVersion\r\n    );\r\n    // Emit at the time of launching a new security token v2.0.\r\n    // _registrationFee is in poly\r\n    event NewSecurityToken(\r\n        string _ticker,\r\n        string _name,\r\n        address indexed _securityTokenAddress,\r\n        address indexed _owner,\r\n        uint256 _addedAt,\r\n        address _registrant,\r\n        bool _fromAdmin,\r\n        uint256 _registrationFee\r\n    );\r\n    // Emit when new ticker get registers\r\n    event RegisterTicker(\r\n        address indexed _owner,\r\n        string _ticker,\r\n        uint256 indexed _registrationDate,\r\n        uint256 indexed _expiryDate,\r\n        bool _fromAdmin,\r\n        uint256 _registrationFeePoly,\r\n        uint256 _registrationFeeUsd\r\n    );\r\n    // Emit after ticker registration\r\n    // _registrationFee is in poly\r\n    // fee in usd is not being emitted to maintain backwards compatibility\r\n    event RegisterTicker(\r\n        address indexed _owner,\r\n        string _ticker,\r\n        string _name,\r\n        uint256 indexed _registrationDate,\r\n        uint256 indexed _expiryDate,\r\n        bool _fromAdmin,\r\n        uint256 _registrationFee\r\n    );\r\n    // Emit at when issuer refreshes exisiting token\r\n    event SecurityTokenRefreshed(\r\n        string _ticker,\r\n        string _name,\r\n        address indexed _securityTokenAddress,\r\n        address indexed _owner,\r\n        uint256 _addedAt,\r\n        address _registrant,\r\n        uint256 _protocolVersion\r\n    );\r\n    event ProtocolFactorySet(address indexed _STFactory, uint8 _major, uint8 _minor, uint8 _patch);\r\n    event LatestVersionSet(uint8 _major, uint8 _minor, uint8 _patch);\r\n    event ProtocolFactoryRemoved(address indexed _STFactory, uint8 _major, uint8 _minor, uint8 _patch);\r\n\r\n    /**\r\n     * @notice Deploys an instance of a new Security Token of version 2.0 and records it to the registry\r\n     * @dev this function is for backwards compatibilty with 2.0 dApp.\r\n     * @param _name is the name of the token\r\n     * @param _ticker is the ticker symbol of the security token\r\n     * @param _tokenDetails is the off-chain details of the token\r\n     * @param _divisible is whether or not the token is divisible\r\n     */\r\n    function generateSecurityToken(\r\n        string calldata _name,\r\n        string calldata _ticker,\r\n        string calldata _tokenDetails,\r\n        bool _divisible\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * @notice Deploys an instance of a new Security Token and records it to the registry\r\n     * @param _name is the name of the token\r\n     * @param _ticker is the ticker symbol of the security token\r\n     * @param _tokenDetails is the off-chain details of the token\r\n     * @param _divisible is whether or not the token is divisible\r\n     * @param _treasuryWallet Ethereum address which will holds the STs.\r\n     * @param _protocolVersion Version of securityToken contract\r\n     * - `_protocolVersion` is the packed value of uin8[3] array (it will be calculated offchain)\r\n     * - if _protocolVersion == 0 then latest version of securityToken will be generated\r\n     */\r\n    function generateNewSecurityToken(\r\n        string calldata _name,\r\n        string calldata _ticker,\r\n        string calldata _tokenDetails,\r\n        bool _divisible,\r\n        address _treasuryWallet,\r\n        uint256 _protocolVersion\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * @notice Deploys an instance of a new Security Token and replaces the old one in the registry\r\n     * This can be used to upgrade from version 2.0 of ST to 3.0 or in case something goes wrong with earlier ST\r\n     * @dev This function needs to be in STR 3.0. Defined public to avoid stack overflow\r\n     * @param _name is the name of the token\r\n     * @param _ticker is the ticker symbol of the security token\r\n     * @param _tokenDetails is the off-chain details of the token\r\n     * @param _divisible is whether or not the token is divisible\r\n     */\r\n    function refreshSecurityToken(\r\n        string calldata _name,\r\n        string calldata _ticker,\r\n        string calldata _tokenDetails,\r\n        bool _divisible,\r\n        address _treasuryWallet\r\n    )\r\n        external returns (address securityToken);\r\n\r\n    /**\r\n     * @notice Adds a new custom Security Token and saves it to the registry. (Token should follow the ISecurityToken interface)\r\n     * @param _name Name of the token\r\n     * @param _ticker Ticker of the security token\r\n     * @param _owner Owner of the token\r\n     * @param _securityToken Address of the securityToken\r\n     * @param _tokenDetails Off-chain details of the token\r\n     * @param _deployedAt Timestamp at which security token comes deployed on the ethereum blockchain\r\n     */\r\n    function modifySecurityToken(\r\n        string calldata _name,\r\n        string calldata _ticker,\r\n        address _owner,\r\n        address _securityToken,\r\n        string calldata _tokenDetails,\r\n        uint256 _deployedAt\r\n    )\r\n    external;\r\n\r\n    /**\r\n     * @notice Adds a new custom Security Token and saves it to the registry. (Token should follow the ISecurityToken interface)\r\n     * @param _ticker is the ticker symbol of the security token\r\n     * @param _owner is the owner of the token\r\n     * @param _securityToken is the address of the securityToken\r\n     * @param _tokenDetails is the off-chain details of the token\r\n     * @param _deployedAt is the timestamp at which the security token is deployed\r\n     */\r\n    function modifyExistingSecurityToken(\r\n        string calldata _ticker,\r\n        address _owner,\r\n        address _securityToken,\r\n        string calldata _tokenDetails,\r\n        uint256 _deployedAt\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * @notice Modifies the ticker details. Only Polymath has the ability to do so.\r\n     * @notice Only allowed to modify the tickers which are not yet deployed.\r\n     * @param _owner is the owner of the token\r\n     * @param _ticker is the token ticker\r\n     * @param _registrationDate is the date at which ticker is registered\r\n     * @param _expiryDate is the expiry date for the ticker\r\n     * @param _status is the token deployment status\r\n     */\r\n    function modifyExistingTicker(\r\n        address _owner,\r\n        string calldata _ticker,\r\n        uint256 _registrationDate,\r\n        uint256 _expiryDate,\r\n        bool _status\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * @notice Registers the token ticker for its particular owner\r\n     * @notice once the token ticker is registered to its owner then no other issuer can claim\r\n     * @notice its ownership. If the ticker expires and its issuer hasn't used it, then someone else can take it.\r\n     * @param _owner Address of the owner of the token\r\n     * @param _ticker Token ticker\r\n     * @param _tokenName Name of the token\r\n     */\r\n    function registerTicker(address _owner, string calldata _ticker, string calldata _tokenName) external;\r\n\r\n    /**\r\n     * @notice Registers the token ticker to the selected owner\r\n     * @notice Once the token ticker is registered to its owner then no other issuer can claim\r\n     * @notice its ownership. If the ticker expires and its issuer hasn't used it, then someone else can take it.\r\n     * @param _owner is address of the owner of the token\r\n     * @param _ticker is unique token ticker\r\n     */\r\n    function registerNewTicker(address _owner, string calldata _ticker) external;\r\n\r\n    /**\r\n    * @notice Check that Security Token is registered\r\n    * @param _securityToken Address of the Scurity token\r\n    * @return bool\r\n    */\r\n    function isSecurityToken(address _securityToken) external view returns(bool isValid);\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) external;\r\n\r\n    /**\r\n     * @notice Get security token address by ticker name\r\n     * @param _ticker Symbol of the Scurity token\r\n     * @return address\r\n     */\r\n    function getSecurityTokenAddress(string calldata _ticker) external view returns(address tokenAddress);\r\n\r\n    /**\r\n    * @notice Returns the security token data by address\r\n    * @param _securityToken is the address of the security token.\r\n    * @return string is the ticker of the security Token.\r\n    * @return address is the issuer of the security Token.\r\n    * @return string is the details of the security token.\r\n    * @return uint256 is the timestamp at which security Token was deployed.\r\n    */\r\n    function getSecurityTokenData(address _securityToken) external view returns (\r\n        string memory tokenSymbol,\r\n        address tokenAddress,\r\n        string memory tokenDetails,\r\n        uint256 tokenTime\r\n    );\r\n\r\n    /**\r\n     * @notice Get the current STFactory Address\r\n     */\r\n    function getSTFactoryAddress() external view returns(address stFactoryAddress);\r\n\r\n    /**\r\n     * @notice Returns the STFactory Address of a particular version\r\n     * @param _protocolVersion Packed protocol version\r\n     */\r\n    function getSTFactoryAddressOfVersion(uint256 _protocolVersion) external view returns(address stFactory);\r\n\r\n    /**\r\n     * @notice Get Protocol version\r\n     */\r\n    function getLatestProtocolVersion() external view returns(uint8[] memory protocolVersion);\r\n\r\n    /**\r\n     * @notice Used to get the ticker list as per the owner\r\n     * @param _owner Address which owns the list of tickers\r\n     */\r\n    function getTickersByOwner(address _owner) external view returns(bytes32[] memory tickers);\r\n\r\n    /**\r\n     * @notice Returns the list of tokens owned by the selected address\r\n     * @param _owner is the address which owns the list of tickers\r\n     * @dev Intention is that this is called off-chain so block gas limit is not relevant\r\n     */\r\n    function getTokensByOwner(address _owner) external view returns(address[] memory tokens);\r\n\r\n    /**\r\n     * @notice Returns the list of all tokens\r\n     * @dev Intention is that this is called off-chain so block gas limit is not relevant\r\n     */\r\n    function getTokens() external view returns(address[] memory tokens);\r\n\r\n    /**\r\n     * @notice Returns the owner and timestamp for a given ticker\r\n     * @param _ticker ticker\r\n     * @return address\r\n     * @return uint256\r\n     * @return uint256\r\n     * @return string\r\n     * @return bool\r\n     */\r\n    function getTickerDetails(string calldata _ticker) external view returns(address tickerOwner, uint256 tickerRegistration, uint256 tickerExpiry, string memory tokenName, bool tickerStatus);\r\n\r\n    /**\r\n     * @notice Modifies the ticker details. Only polymath account has the ability\r\n     * to do so. Only allowed to modify the tickers which are not yet deployed\r\n     * @param _owner Owner of the token\r\n     * @param _ticker Token ticker\r\n     * @param _tokenName Name of the token\r\n     * @param _registrationDate Date on which ticker get registered\r\n     * @param _expiryDate Expiry date of the ticker\r\n     * @param _status Token deployed status\r\n     */\r\n    function modifyTicker(\r\n        address _owner,\r\n        string calldata _ticker,\r\n        string calldata _tokenName,\r\n        uint256 _registrationDate,\r\n        uint256 _expiryDate,\r\n        bool _status\r\n    )\r\n    external;\r\n\r\n    /**\r\n     * @notice Removes the ticker details and associated ownership & security token mapping\r\n     * @param _ticker Token ticker\r\n     */\r\n    function removeTicker(string calldata _ticker) external;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of the ticker\r\n     * @dev _newOwner Address whom ownership to transfer\r\n     * @dev _ticker Ticker\r\n     */\r\n    function transferTickerOwnership(address _newOwner, string calldata _ticker) external;\r\n\r\n    /**\r\n     * @notice Changes the expiry time for the token ticker\r\n     * @param _newExpiry New time period for token ticker expiry\r\n     */\r\n    function changeExpiryLimit(uint256 _newExpiry) external;\r\n\r\n   /**\r\n    * @notice Sets the ticker registration fee in USD tokens. Only Polymath.\r\n    * @param _tickerRegFee is the registration fee in USD tokens (base 18 decimals)\r\n    */\r\n    function changeTickerRegistrationFee(uint256 _tickerRegFee) external;\r\n\r\n    /**\r\n    * @notice Sets the ticker registration fee in USD tokens. Only Polymath.\r\n    * @param _stLaunchFee is the registration fee in USD tokens (base 18 decimals)\r\n    */\r\n    function changeSecurityLaunchFee(uint256 _stLaunchFee) external;\r\n\r\n    /**\r\n    * @notice Sets the ticker registration and ST launch fee amount and currency\r\n    * @param _tickerRegFee is the ticker registration fee (base 18 decimals)\r\n    * @param _stLaunchFee is the st generation fee (base 18 decimals)\r\n    * @param _isFeeInPoly defines if the fee is in poly or usd\r\n    */\r\n    function changeFeesAmountAndCurrency(uint256 _tickerRegFee, uint256 _stLaunchFee, bool _isFeeInPoly) external;\r\n\r\n    /**\r\n    * @notice Changes the SecurityToken contract for a particular factory version\r\n    * @notice Used only by Polymath to upgrade the SecurityToken contract and add more functionalities to future versions\r\n    * @notice Changing versions does not affect existing tokens.\r\n    * @param _STFactoryAddress is the address of the proxy.\r\n    * @param _major Major version of the proxy.\r\n    * @param _minor Minor version of the proxy.\r\n    * @param _patch Patch version of the proxy\r\n    */\r\n    function setProtocolFactory(address _STFactoryAddress, uint8 _major, uint8 _minor, uint8 _patch) external;\r\n\r\n    /**\r\n    * @notice Removes a STFactory\r\n    * @param _major Major version of the proxy.\r\n    * @param _minor Minor version of the proxy.\r\n    * @param _patch Patch version of the proxy\r\n    */\r\n    function removeProtocolFactory(uint8 _major, uint8 _minor, uint8 _patch) external;\r\n\r\n    /**\r\n    * @notice Changes the default protocol version\r\n    * @notice Used only by Polymath to upgrade the SecurityToken contract and add more functionalities to future versions\r\n    * @notice Changing versions does not affect existing tokens.\r\n    * @param _major Major version of the proxy.\r\n    * @param _minor Minor version of the proxy.\r\n    * @param _patch Patch version of the proxy\r\n    */\r\n    function setLatestVersion(uint8 _major, uint8 _minor, uint8 _patch) external;\r\n\r\n    /**\r\n     * @notice Changes the PolyToken address. Only Polymath.\r\n     * @param _newAddress is the address of the polytoken.\r\n     */\r\n    function updatePolyTokenAddress(address _newAddress) external;\r\n\r\n    /**\r\n     * @notice Used to update the polyToken contract address\r\n     */\r\n    function updateFromRegistry() external;\r\n\r\n    /**\r\n     * @notice Gets the security token launch fee\r\n     * @return Fee amount\r\n     */\r\n    function getSecurityTokenLaunchFee() external returns(uint256 fee);\r\n\r\n    /**\r\n     * @notice Gets the ticker registration fee\r\n     * @return Fee amount\r\n     */\r\n    function getTickerRegistrationFee() external returns(uint256 fee);\r\n\r\n    /**\r\n     * @notice Set the getter contract address\r\n     * @param _getterContract Address of the contract\r\n     */\r\n    function setGetterRegistry(address _getterContract) external;\r\n\r\n    /**\r\n     * @notice Returns the usd & poly fee for a particular feetype\r\n     * @param _feeType Key corresponding to fee type\r\n     */\r\n    function getFees(bytes32 _feeType) external returns (uint256 usdFee, uint256 polyFee);\r\n\r\n    /**\r\n     * @notice Returns the list of tokens to which the delegate has some access\r\n     * @param _delegate is the address for the delegate\r\n     * @dev Intention is that this is called off-chain so block gas limit is not relevant\r\n     */\r\n    function getTokensByDelegate(address _delegate) external view returns(address[] memory tokens);\r\n\r\n    /**\r\n     * @notice Gets the expiry limit\r\n     * @return Expiry limit\r\n     */\r\n    function getExpiryLimit() external view returns(uint256 expiry);\r\n\r\n    /**\r\n     * @notice Gets the status of the ticker\r\n     * @param _ticker Ticker whose status need to determine\r\n     * @return bool\r\n     */\r\n    function getTickerStatus(string calldata _ticker) external view returns(bool status);\r\n\r\n    /**\r\n     * @notice Gets the fee currency\r\n     * @return true = poly, false = usd\r\n     */\r\n    function getIsFeeInPoly() external view returns(bool isInPoly);\r\n\r\n    /**\r\n     * @notice Gets the owner of the ticker\r\n     * @param _ticker Ticker whose owner need to determine\r\n     * @return address Address of the owner\r\n     */\r\n    function getTickerOwner(string calldata _ticker) external view returns(address owner);\r\n\r\n    /**\r\n     * @notice Checks whether the registry is paused or not\r\n     * @return bool\r\n     */\r\n    function isPaused() external view returns(bool paused);\r\n\r\n    /**\r\n    * @notice Called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() external;\r\n\r\n    /**\r\n     * @notice Called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() external;\r\n\r\n    /**\r\n     * @notice Reclaims all ERC20Basic compatible tokens\r\n     * @param _tokenContract is the address of the token contract\r\n     */\r\n    function reclaimERC20(address _tokenContract) external;\r\n\r\n    /**\r\n     * @notice Gets the owner of the contract\r\n     * @return address owner\r\n     */\r\n    function owner() external view returns(address ownerAddress);\r\n\r\n    /**\r\n     * @notice Checks if the entered ticker is registered and has not expired\r\n     * @param _ticker is the token ticker\r\n     * @return bool\r\n     */\r\n    function tickerAvailable(string calldata _ticker) external view returns(bool);\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract SecurityTokenStorage {\r\n\r\n    uint8 internal constant PERMISSION_KEY = 1;\r\n    uint8 internal constant TRANSFER_KEY = 2;\r\n    uint8 internal constant MINT_KEY = 3;\r\n    uint8 internal constant CHECKPOINT_KEY = 4;\r\n    uint8 internal constant BURN_KEY = 5;\r\n    uint8 internal constant DATA_KEY = 6;\r\n    uint8 internal constant WALLET_KEY = 7;\r\n\r\n    bytes32 internal constant INVESTORSKEY = 0xdf3a8dd24acdd05addfc6aeffef7574d2de3f844535ec91e8e0f3e45dba96731; //keccak256(abi.encodePacked(\"INVESTORS\"))\r\n    bytes32 internal constant TREASURY = 0xaae8817359f3dcb67d050f44f3e49f982e0359d90ca4b5f18569926304aaece6; //keccak256(abi.encodePacked(\"TREASURY_WALLET\"))\r\n    bytes32 internal constant LOCKED = \"LOCKED\";\r\n    bytes32 internal constant UNLOCKED = \"UNLOCKED\";\r\n\r\n    //////////////////////////\r\n    /// Document datastructure\r\n    //////////////////////////\r\n\r\n    struct Document {\r\n        bytes32 docHash; // Hash of the document\r\n        uint256 lastModified; // Timestamp at which document details was last modified\r\n        string uri; // URI of the document that exist off-chain\r\n    }\r\n\r\n    // Used to hold the semantic version data\r\n    struct SemanticVersion {\r\n        uint8 major;\r\n        uint8 minor;\r\n        uint8 patch;\r\n    }\r\n\r\n    // Struct for module data\r\n    struct ModuleData {\r\n        bytes32 name;\r\n        address module;\r\n        address moduleFactory;\r\n        bool isArchived;\r\n        uint8[] moduleTypes;\r\n        uint256[] moduleIndexes;\r\n        uint256 nameIndex;\r\n        bytes32 label;\r\n    }\r\n\r\n    // Structures to maintain checkpoints of balances for governance / dividends\r\n    struct Checkpoint {\r\n        uint256 checkpointId;\r\n        uint256 value;\r\n    }\r\n\r\n    //Naming scheme to match Ownable\r\n    address internal _owner;\r\n    address public tokenFactory;\r\n    bool public initialized;\r\n\r\n    // ERC20 Details\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    // Address of the controller which is a delegated entity\r\n    // set by the issuer/owner of the token\r\n    address public controller;\r\n\r\n    IPolymathRegistry public polymathRegistry;\r\n    IModuleRegistry public moduleRegistry;\r\n    ISecurityTokenRegistry public securityTokenRegistry;\r\n    IERC20 public polyToken;\r\n    address public getterDelegate;\r\n    // Address of the data store used to store shared data\r\n    IDataStore public dataStore;\r\n\r\n    uint256 public granularity;\r\n\r\n    // Value of current checkpoint\r\n    uint256 public currentCheckpointId;\r\n\r\n    // off-chain data\r\n    string public tokenDetails;\r\n\r\n    // Used to permanently halt controller actions\r\n    bool public controllerDisabled = false;\r\n\r\n    // Used to temporarily halt all transactions\r\n    bool public transfersFrozen;\r\n\r\n    // Number of investors with non-zero balance\r\n    uint256 public holderCount;\r\n\r\n    // Variable which tells whether issuance is ON or OFF forever\r\n    // Implementers need to implement one more function to reset the value of `issuance` variable\r\n    // to false. That function is not a part of the standard (EIP-1594) as it is depend on the various factors\r\n    // issuer, followed compliance rules etc. So issuers have the choice how they want to close the issuance.\r\n    bool internal issuance = true;\r\n\r\n    // Array use to store all the document name present in the contracts\r\n    bytes32[] _docNames;\r\n\r\n    // Times at which each checkpoint was created\r\n    uint256[] checkpointTimes;\r\n\r\n    SemanticVersion securityTokenVersion;\r\n\r\n    // Records added modules - module list should be order agnostic!\r\n    mapping(uint8 => address[]) modules;\r\n\r\n    // Records information about the module\r\n    mapping(address => ModuleData) modulesToData;\r\n\r\n    // Records added module names - module list should be order agnostic!\r\n    mapping(bytes32 => address[]) names;\r\n\r\n    // Mapping of checkpoints that relate to total supply\r\n    mapping (uint256 => uint256) checkpointTotalSupply;\r\n\r\n    // Map each investor to a series of checkpoints\r\n    mapping(address => Checkpoint[]) checkpointBalances;\r\n\r\n    // mapping to store the documents details in the document\r\n    mapping(bytes32 => Document) internal _documents;\r\n    // mapping to store the document name indexes\r\n    mapping(bytes32 => uint256) internal _docIndexes;\r\n    // Mapping from (investor, partition, operator) to approved status\r\n    mapping (address => mapping (bytes32 => mapping (address => bool))) partitionApprovals;\r\n\r\n}\r\n\r\n/**\r\n * @title USDTiered STO module Proxy\r\n */\r\ncontract SecurityTokenProxy is OZStorage, SecurityTokenStorage, OwnedUpgradeabilityProxy {\r\n\r\n    /**\r\n     * @notice constructor\r\n     * @param _name Name of the SecurityToken\r\n     * @param _symbol Symbol of the Token\r\n     * @param _decimals Decimals for the securityToken\r\n     * @param _granularity granular level of the token\r\n     * @param _tokenDetails Details of the token that are stored off-chain\r\n     * @param _polymathRegistry Contract address of the polymath registry\r\n     */\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        uint256 _granularity,\r\n        string memory _tokenDetails,\r\n        address _polymathRegistry\r\n    )\r\n        public\r\n    {\r\n        //Set storage variables - NB implementation not yet set\r\n        require(_polymathRegistry != address(0), \"Invalid Address\");\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        polymathRegistry = IPolymathRegistry(_polymathRegistry);\r\n        tokenDetails = _tokenDetails;\r\n        granularity = _granularity;\r\n        _owner = msg.sender;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for security token proxy deployment\r\n */\r\ninterface ISTFactory {\r\n\r\n    event LogicContractSet(string _version, address _logicContract, bytes _upgradeData);\r\n    event TokenUpgraded(\r\n        address indexed _securityToken,\r\n        uint256 indexed _version\r\n    );\r\n    event DefaultTransferManagerUpdated(address indexed _oldTransferManagerFactory, address indexed _newTransferManagerFactory);\r\n    event DefaultDataStoreUpdated(address indexed _oldDataStoreFactory, address indexed _newDataStoreFactory);\r\n\r\n    /**\r\n     * @notice Deploys the token and adds default modules like permission manager and transfer manager.\r\n     * Future versions of the proxy can attach different modules or pass some other paramters.\r\n     * @param _name is the name of the Security token\r\n     * @param _symbol is the symbol of the Security Token\r\n     * @param _decimals is the number of decimals of the Security Token\r\n     * @param _tokenDetails is the off-chain data associated with the Security Token\r\n     * @param _issuer is the owner of the Security Token\r\n     * @param _divisible whether the token is divisible or not\r\n     * @param _treasuryWallet Ethereum address which will holds the STs.\r\n     */\r\n    function deployToken(\r\n        string calldata _name,\r\n        string calldata _symbol,\r\n        uint8 _decimals,\r\n        string calldata _tokenDetails,\r\n        address _issuer,\r\n        bool _divisible,\r\n        address _treasuryWallet //In v2.x this is the Polymath Registry\r\n    )\r\n    external\r\n    returns(address tokenAddress);\r\n\r\n    /**\r\n     * @notice Used to set a new token logic contract\r\n     * @param _version Version of upgraded module\r\n     * @param _logicContract Address of deployed module logic contract referenced from proxy\r\n     * @param _initializationData Initialization data that used to intialize value in the securityToken\r\n     * @param _upgradeData Data to be passed in call to upgradeToAndCall when a token upgrades its module\r\n     */\r\n    function setLogicContract(string calldata _version, address _logicContract, bytes calldata _initializationData, bytes calldata _upgradeData) external;\r\n\r\n    /**\r\n     * @notice Used to upgrade a token\r\n     * @param _maxModuleType maximum module type enumeration\r\n     */\r\n    function upgradeToken(uint8 _maxModuleType) external;\r\n\r\n    /**\r\n     * @notice Used to set a new default transfer manager\r\n     * @dev Setting this to address(0) means don't deploy a default TM\r\n     * @param _transferManagerFactory Address of new default transfer manager factory\r\n     */\r\n    function updateDefaultTransferManager(address _transferManagerFactory) external;\r\n\r\n    /**\r\n     * @notice Used to set a new default data store\r\n     * @dev Setting this to address(0) means don't deploy a default data store\r\n     * @param _dataStoreFactory Address of new default data store factory\r\n     */\r\n    function updateDefaultDataStore(address _dataStoreFactory) external;\r\n}\r\n\r\n/**\r\n * @title Interface for all security tokens\r\n */\r\ninterface ISecurityToken {\r\n    // Standard ERC20 interface\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function decimals() external view returns(uint8);\r\n    function totalSupply() external view returns(uint256);\r\n    function balanceOf(address owner) external view returns(uint256);\r\n    function allowance(address owner, address spender) external view returns(uint256);\r\n    function transfer(address to, uint256 value) external returns(bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\r\n    function approve(address spender, uint256 value) external returns(bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\r\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\r\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\r\n     * @return byte Ethereum status code (ESC)\r\n     * @return bytes32 Application specific reason code\r\n     */\r\n    function canTransfer(address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\r\n\r\n    // Emit at the time when module get added\r\n    event ModuleAdded(\r\n        uint8[] _types,\r\n        bytes32 indexed _name,\r\n        address indexed _moduleFactory,\r\n        address _module,\r\n        uint256 _moduleCost,\r\n        uint256 _budget,\r\n        bytes32 _label,\r\n        bool _archived\r\n    );\r\n\r\n    // Emit when the token details get updated\r\n    event UpdateTokenDetails(string _oldDetails, string _newDetails);\r\n    // Emit when the token name get updated\r\n    event UpdateTokenName(string _oldName, string _newName);\r\n    // Emit when the granularity get changed\r\n    event GranularityChanged(uint256 _oldGranularity, uint256 _newGranularity);\r\n    // Emit when is permanently frozen by the issuer\r\n    event FreezeIssuance();\r\n    // Emit when transfers are frozen or unfrozen\r\n    event FreezeTransfers(bool _status);\r\n    // Emit when new checkpoint created\r\n    event CheckpointCreated(uint256 indexed _checkpointId, uint256 _investorLength);\r\n    // Events to log controller actions\r\n    event SetController(address indexed _oldController, address indexed _newController);\r\n    //Event emit when the global treasury wallet address get changed\r\n    event TreasuryWalletChanged(address _oldTreasuryWallet, address _newTreasuryWallet);\r\n    event DisableController();\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event TokenUpgraded(uint8 _major, uint8 _minor, uint8 _patch);\r\n\r\n    // Emit when Module get archived from the securityToken\r\n    event ModuleArchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\r\n    // Emit when Module get unarchived from the securityToken\r\n    event ModuleUnarchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\r\n    // Emit when Module get removed from the securityToken\r\n    event ModuleRemoved(uint8[] _types, address _module); //Event emitted by the tokenLib.\r\n    // Emit when the budget allocated to a module is changed\r\n    event ModuleBudgetChanged(uint8[] _moduleTypes, address _module, uint256 _oldBudget, uint256 _budget); //Event emitted by the tokenLib.\r\n\r\n    // Transfer Events\r\n    event TransferByPartition(\r\n        bytes32 indexed _fromPartition,\r\n        address _operator,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value,\r\n        bytes _data,\r\n        bytes _operatorData\r\n    );\r\n\r\n    // Operator Events\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n\r\n    // Issuance / Redemption Events\r\n    event IssuedByPartition(bytes32 indexed partition, address indexed to, uint256 value, bytes data);\r\n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\r\n\r\n    // Document Events\r\n    event DocumentRemoved(bytes32 indexed _name, string _uri, bytes32 _documentHash);\r\n    event DocumentUpdated(bytes32 indexed _name, string _uri, bytes32 _documentHash);\r\n\r\n    // Controller Events\r\n    event ControllerTransfer(\r\n        address _controller,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value,\r\n        bytes _data,\r\n        bytes _operatorData\r\n    );\r\n\r\n    event ControllerRedemption(\r\n        address _controller,\r\n        address indexed _tokenHolder,\r\n        uint256 _value,\r\n        bytes _data,\r\n        bytes _operatorData\r\n    );\r\n\r\n    // Issuance / Redemption Events\r\n    event Issued(address indexed _operator, address indexed _to, uint256 _value, bytes _data);\r\n    event Redeemed(address indexed _operator, address indexed _from, uint256 _value, bytes _data);\r\n\r\n    /**\r\n     * @notice Initialization function\r\n     * @dev Expected to be called atomically with the proxy being created, by the owner of the token\r\n     * @dev Can only be called once\r\n     */\r\n    function initialize(address _getterDelegate) external;\r\n\r\n    /**\r\n     * @notice The standard provides an on-chain function to determine whether a transfer will succeed,\r\n     * and return details indicating the reason if the transfer is not valid.\r\n     * @param _from The address from whom the tokens get transferred.\r\n     * @param _to The address to which to transfer tokens to.\r\n     * @param _partition The partition from which to transfer tokens\r\n     * @param _value The amount of tokens to transfer from `_partition`\r\n     * @param _data Additional data attached to the transfer of tokens\r\n     * @return ESC (Ethereum Status Code) following the EIP-1066 standard\r\n     * @return Application specific reason codes with additional details\r\n     * @return The partition to which the transferred tokens were allocated for the _to address\r\n     */\r\n    function canTransferByPartition(\r\n        address _from,\r\n        address _to,\r\n        bytes32 _partition,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        view\r\n        returns (byte statusCode, bytes32 reasonCode, bytes32 partition);\r\n\r\n    /**\r\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\r\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\r\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\r\n     * @return byte Ethereum status code (ESC)\r\n     * @return bytes32 Application specific reason code\r\n     */\r\n    function canTransferFrom(address _from, address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\r\n\r\n    /**\r\n     * @notice Used to attach a new document to the contract, or update the URI or hash of an existing attached document\r\n     * @dev Can only be executed by the owner of the contract.\r\n     * @param _name Name of the document. It should be unique always\r\n     * @param _uri Off-chain uri of the document from where it is accessible to investors/advisors to read.\r\n     * @param _documentHash hash (of the contents) of the document.\r\n     */\r\n    function setDocument(bytes32 _name, string calldata _uri, bytes32 _documentHash) external;\r\n\r\n    /**\r\n     * @notice Used to remove an existing document from the contract by giving the name of the document.\r\n     * @dev Can only be executed by the owner of the contract.\r\n     * @param _name Name of the document. It should be unique always\r\n     */\r\n    function removeDocument(bytes32 _name) external;\r\n\r\n    /**\r\n     * @notice Used to return the details of a document with a known name (`bytes32`).\r\n     * @param _name Name of the document\r\n     * @return string The URI associated with the document.\r\n     * @return bytes32 The hash (of the contents) of the document.\r\n     * @return uint256 the timestamp at which the document was last modified.\r\n     */\r\n    function getDocument(bytes32 _name) external view returns (string memory documentUri, bytes32 documentHash, uint256 documentTime);\r\n\r\n    /**\r\n     * @notice Used to retrieve a full list of documents attached to the smart contract.\r\n     * @return bytes32 List of all documents names present in the contract.\r\n     */\r\n    function getAllDocuments() external view returns (bytes32[] memory documentNames);\r\n\r\n    /**\r\n     * @notice In order to provide transparency over whether `controllerTransfer` / `controllerRedeem` are useable\r\n     * or not `isControllable` function will be used.\r\n     * @dev If `isControllable` returns `false` then it always return `false` and\r\n     * `controllerTransfer` / `controllerRedeem` will always revert.\r\n     * @return bool `true` when controller address is non-zero otherwise return `false`.\r\n     */\r\n    function isControllable() external view returns (bool controlled);\r\n\r\n    /**\r\n     * @notice Checks if an address is a module of certain type\r\n     * @param _module Address to check\r\n     * @param _type type to check against\r\n     */\r\n    function isModule(address _module, uint8 _type) external view returns(bool isValid);\r\n\r\n    /**\r\n     * @notice This function must be called to increase the total supply (Corresponds to mint function of ERC20).\r\n     * @dev It only be called by the token issuer or the operator defined by the issuer. ERC1594 doesn't have\r\n     * have the any logic related to operator but its superset ERC1400 have the operator logic and this function\r\n     * is allowed to call by the operator.\r\n     * @param _tokenHolder The account that will receive the created tokens (account should be whitelisted or KYCed).\r\n     * @param _value The amount of tokens need to be issued\r\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\r\n     */\r\n    function issue(address _tokenHolder, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice issue new tokens and assigns them to the target _tokenHolder.\r\n     * @dev Can only be called by the issuer or STO attached to the token.\r\n     * @param _tokenHolders A list of addresses to whom the minted tokens will be dilivered\r\n     * @param _values A list of number of tokens get minted and transfer to corresponding address of the investor from _tokenHolders[] list\r\n     * @return success\r\n     */\r\n    function issueMulti(address[] calldata _tokenHolders, uint256[] calldata _values) external;\r\n\r\n    /**\r\n     * @notice Increases totalSupply and the corresponding amount of the specified owners partition\r\n     * @param _partition The partition to allocate the increase in balance\r\n     * @param _tokenHolder The token holder whose balance should be increased\r\n     * @param _value The amount by which to increase the balance\r\n     * @param _data Additional data attached to the minting of tokens\r\n     */\r\n    function issueByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of msg.sender\r\n     * @param _partition The partition to allocate the decrease in balance\r\n     * @param _value The amount by which to decrease the balance\r\n     * @param _data Additional data attached to the burning of tokens\r\n     */\r\n    function redeemByPartition(bytes32 _partition, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\r\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\r\n     * are out of the scope of the ERC1594.\r\n     * @param _value The amount of tokens need to be redeemed\r\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\r\n     */\r\n    function redeem(uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\r\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\r\n     * are out of the scope of the ERC1594.\r\n     * @dev It is analogy to `transferFrom`\r\n     * @param _tokenHolder The account whose tokens gets redeemed.\r\n     * @param _value The amount of tokens need to be redeemed\r\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\r\n     */\r\n    function redeemFrom(address _tokenHolder, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of tokenHolder\r\n     * @dev This function can only be called by the authorised operator.\r\n     * @param _partition The partition to allocate the decrease in balance.\r\n     * @param _tokenHolder The token holder whose balance should be decreased\r\n     * @param _value The amount by which to decrease the balance\r\n     * @param _data Additional data attached to the burning of tokens\r\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\r\n     */\r\n    function operatorRedeemByPartition(\r\n        bytes32 _partition,\r\n        address _tokenHolder,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\r\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\r\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n     * @param _delegate address of delegate\r\n     * @param _module address of PermissionManager module\r\n     * @param _perm the permissions\r\n     * @return success\r\n     */\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPermission);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _module Address of the module\r\n     * @return bytes32 Name\r\n     * @return address Module address\r\n     * @return address Module factory address\r\n     * @return bool Module archived\r\n     * @return uint8 Array of module types\r\n     * @return bytes32 Module label\r\n     */\r\n    function getModule(address _module) external view returns (bytes32 moduleName, address moduleAddress, address factoryAddress, bool isArchived, uint8[] memory moduleTypes, bytes32 moduleLabel);\r\n\r\n    /**\r\n     * @notice Returns module list for a module name\r\n     * @param _name Name of the module\r\n     * @return address[] List of modules with this name\r\n     */\r\n    function getModulesByName(bytes32 _name) external view returns(address[] memory modules);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _type Type of the module\r\n     * @return address[] List of modules with this type\r\n     */\r\n    function getModulesByType(uint8 _type) external view returns(address[] memory modules);\r\n\r\n    /**\r\n     * @notice use to return the global treasury wallet\r\n     */\r\n    function getTreasuryWallet() external view returns(address treasuryWallet);\r\n\r\n    /**\r\n     * @notice Queries totalSupply at a specified checkpoint\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function totalSupplyAt(uint256 _checkpointId) external view returns(uint256 supply);\r\n\r\n    /**\r\n     * @notice Queries balance at a specified checkpoint\r\n     * @param _investor Investor to query balance for\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns(uint256 balance);\r\n\r\n    /**\r\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\r\n     */\r\n    function createCheckpoint() external returns(uint256 checkpointId);\r\n\r\n    /**\r\n     * @notice Gets list of times that checkpoints were created\r\n     * @return List of checkpoint times\r\n     */\r\n    function getCheckpointTimes() external view returns(uint256[] memory checkpointTimes);\r\n\r\n    /**\r\n     * @notice returns an array of investors\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @return list of addresses\r\n     */\r\n    function getInvestors() external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice returns an array of investors at a given checkpoint\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\r\n     * @return list of investors\r\n     */\r\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice returns an array of investors with non zero balance at a given checkpoint\r\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\r\n     * @param _start Position of investor to start iteration from\r\n     * @param _end Position of investor to stop iteration at\r\n     * @return list of investors\r\n     */\r\n    function getInvestorsSubsetAt(uint256 _checkpointId, uint256 _start, uint256 _end) external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice generates subset of investors\r\n     * NB - can be used in batches if investor list is large\r\n     * @param _start Position of investor to start iteration from\r\n     * @param _end Position of investor to stop iteration at\r\n     * @return list of investors\r\n     */\r\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice Gets current checkpoint ID\r\n     * @return Id\r\n     */\r\n    function currentCheckpointId() external view returns(uint256 checkpointId);\r\n\r\n    /**\r\n     * @notice Determines whether `_operator` is an operator for all partitions of `_tokenHolder`\r\n     * @param _operator The operator to check\r\n     * @param _tokenHolder The token holder to check\r\n     * @return Whether the `_operator` is an operator for all partitions of `_tokenHolder`\r\n     */\r\n    function isOperator(address _operator, address _tokenHolder) external view returns (bool isValid);\r\n\r\n    /**\r\n     * @notice Determines whether `_operator` is an operator for a specified partition of `_tokenHolder`\r\n     * @param _partition The partition to check\r\n     * @param _operator The operator to check\r\n     * @param _tokenHolder The token holder to check\r\n     * @return Whether the `_operator` is an operator for a specified partition of `_tokenHolder`\r\n     */\r\n    function isOperatorForPartition(bytes32 _partition, address _operator, address _tokenHolder) external view returns (bool isValid);\r\n\r\n    /**\r\n     * @notice Return all partitions\r\n     * @param _tokenHolder Whom balance need to queried\r\n     * @return List of partitions\r\n     */\r\n    function partitionsOf(address _tokenHolder) external view returns (bytes32[] memory partitions);\r\n\r\n    /**\r\n     * @notice Gets data store address\r\n     * @return data store address\r\n     */\r\n    function dataStore() external view returns (address dataStoreAddress);\r\n\r\n    /**\r\n    * @notice Allows owner to change data store\r\n    * @param _dataStore Address of the token data store\r\n    */\r\n    function changeDataStore(address _dataStore) external;\r\n\r\n\r\n    /**\r\n     * @notice Allows to change the treasury wallet address\r\n     * @param _wallet Ethereum address of the treasury wallet\r\n     */\r\n    function changeTreasuryWallet(address _wallet) external;\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\r\n     * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\r\n     * @param _tokenContract Address of the ERC20Basic compliance token\r\n     * @param _value Amount of POLY to withdraw\r\n     */\r\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\r\n\r\n    /**\r\n    * @notice Allows owner to increase/decrease POLY approval of one of the modules\r\n    * @param _module Module address\r\n    * @param _change Change in allowance\r\n    * @param _increase True if budget has to be increased, false if decrease\r\n    */\r\n    function changeModuleBudget(address _module, uint256 _change, bool _increase) external;\r\n\r\n    /**\r\n     * @notice Changes the tokenDetails\r\n     * @param _newTokenDetails New token details\r\n     */\r\n    function updateTokenDetails(string calldata _newTokenDetails) external;\r\n\r\n    /**\r\n    * @notice Allows owner to change token name\r\n    * @param _name new name of the token\r\n    */\r\n    function changeName(string calldata _name) external;\r\n\r\n    /**\r\n    * @notice Allows the owner to change token granularity\r\n    * @param _granularity Granularity level of the token\r\n    */\r\n    function changeGranularity(uint256 _granularity) external;\r\n\r\n    /**\r\n     * @notice Freezes all the transfers\r\n     */\r\n    function freezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Un-freezes all the transfers\r\n     */\r\n    function unfreezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Permanently freeze issuance of this security token.\r\n     * @dev It MUST NOT be possible to increase `totalSuppy` after this function is called.\r\n     */\r\n    function freezeIssuance(bytes calldata _signature) external;\r\n\r\n    /**\r\n      * @notice Attachs a module to the SecurityToken\r\n      * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n      * @dev to control restrictions on transfers.\r\n      * @param _moduleFactory is the address of the module factory to be added\r\n      * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n      * @param _maxCost max amount of POLY willing to pay to the module.\r\n      * @param _budget max amount of ongoing POLY willing to assign to the module.\r\n      * @param _label custom module label.\r\n      * @param _archived whether to add the module as an archived module\r\n      */\r\n    function addModuleWithLabel(\r\n        address _moduleFactory,\r\n        bytes calldata _data,\r\n        uint256 _maxCost,\r\n        uint256 _budget,\r\n        bytes32 _label,\r\n        bool _archived\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Function used to attach a module to the security token\r\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n     * @dev to control restrictions on transfers.\r\n     * @dev You are allowed to add a new moduleType if:\r\n     * @dev - there is no existing module of that type yet added\r\n     * @dev - the last member of the module list is replacable\r\n     * @param _moduleFactory is the address of the module factory to be added\r\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\r\n     * @param _budget max amount of ongoing POLY willing to assign to the module.\r\n     * @param _archived whether to add the module as an archived module\r\n     */\r\n    function addModule(address _moduleFactory, bytes calldata _data, uint256 _maxCost, uint256 _budget, bool _archived) external;\r\n\r\n    /**\r\n    * @notice Archives a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function archiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Unarchives a module attached to the SecurityToken\r\n    * @param _module address of module to unarchive\r\n    */\r\n    function unarchiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Removes a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function removeModule(address _module) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to set the controller addresses\r\n     * @param _controller address of the controller\r\n     */\r\n    function setController(address _controller) external;\r\n\r\n    /**\r\n     * @notice This function allows an authorised address to transfer tokens between any two token holders.\r\n     * The transfer must still respect the balances of the token holders (so the transfer must be for at most\r\n     * `balanceOf(_from)` tokens) and potentially also need to respect other transfer restrictions.\r\n     * @dev This function can only be executed by the `controller` address.\r\n     * @param _from Address The address which you want to send tokens from\r\n     * @param _to Address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\r\n     * because use of `_data` parameter is implementation specific).\r\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\r\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\r\n     */\r\n    function controllerTransfer(address _from, address _to, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\r\n\r\n    /**\r\n     * @notice This function allows an authorised address to redeem tokens for any token holder.\r\n     * The redemption must still respect the balances of the token holder (so the redemption must be for at most\r\n     * `balanceOf(_tokenHolder)` tokens) and potentially also need to respect other transfer restrictions.\r\n     * @dev This function can only be executed by the `controller` address.\r\n     * @param _tokenHolder The account whose tokens will be redeemed.\r\n     * @param _value uint256 the amount of tokens need to be redeemed.\r\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\r\n     * because use of `_data` parameter is implementation specific).\r\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\r\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\r\n     */\r\n    function controllerRedeem(address _tokenHolder, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to permanently disable controller functionality\r\n     * @dev enabled via feature switch \"disableControllerAllowed\"\r\n     */\r\n    function disableController(bytes calldata _signature) external;\r\n\r\n    /**\r\n     * @notice Used to get the version of the securityToken\r\n     */\r\n    function getVersion() external view returns(uint8[] memory version);\r\n\r\n    /**\r\n     * @notice Gets the investor count\r\n     */\r\n    function getInvestorCount() external view returns(uint256 investorCount);\r\n\r\n    /**\r\n     * @notice Gets the holder count (investors with non zero balance)\r\n     */\r\n    function holderCount() external view returns(uint256 count);\r\n\r\n    /**\r\n      * @notice Overloaded version of the transfer function\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n    function transferWithData(address _to, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n      * @notice Overloaded version of the transferFrom function\r\n      * @param _from sender of transfer\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n    function transferFromWithData(address _from, address _to, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\r\n     * @param _partition The partition from which to transfer tokens\r\n     * @param _to The address to which to transfer tokens to\r\n     * @param _value The amount of tokens to transfer from `_partition`\r\n     * @param _data Additional data attached to the transfer of tokens\r\n     * @return The partition to which the transferred tokens were allocated for the _to address\r\n     */\r\n    function transferByPartition(bytes32 _partition, address _to, uint256 _value, bytes calldata _data) external returns (bytes32 partition);\r\n\r\n    /**\r\n     * @notice Get the balance according to the provided partitions\r\n     * @param _partition Partition which differentiate the tokens.\r\n     * @param _tokenHolder Whom balance need to queried\r\n     * @return Amount of tokens as per the given partitions\r\n     */\r\n    function balanceOfByPartition(bytes32 _partition, address _tokenHolder) external view returns(uint256 balance);\r\n\r\n    /**\r\n      * @notice Provides the granularity of the token\r\n      * @return uint256\r\n      */\r\n    function granularity() external view returns(uint256 granularityAmount);\r\n\r\n    /**\r\n      * @notice Provides the address of the polymathRegistry\r\n      * @return address\r\n      */\r\n    function polymathRegistry() external view returns(address registryAddress);\r\n\r\n    /**\r\n    * @notice Upgrades a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function upgradeModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Upgrades security token\r\n    */\r\n    function upgradeToken() external;\r\n\r\n    /**\r\n     * @notice A security token issuer can specify that issuance has finished for the token\r\n     * (i.e. no new tokens can be minted or issued).\r\n     * @dev If a token returns FALSE for `isIssuable()` then it MUST always return FALSE in the future.\r\n     * If a token returns FALSE for `isIssuable()` then it MUST never allow additional tokens to be issued.\r\n     * @return bool `true` signifies the minting is allowed. While `false` denotes the end of minting\r\n     */\r\n    function isIssuable() external view returns (bool issuable);\r\n\r\n    /**\r\n     * @notice Authorises an operator for all partitions of `msg.sender`.\r\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\r\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\r\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\r\n     * @param _operator An address which is being authorised.\r\n     */\r\n    function authorizeOperator(address _operator) external;\r\n\r\n    /**\r\n     * @notice Revokes authorisation of an operator previously given for all partitions of `msg.sender`.\r\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\r\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\r\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\r\n     * @param _operator An address which is being de-authorised\r\n     */\r\n    function revokeOperator(address _operator) external;\r\n\r\n    /**\r\n     * @notice Authorises an operator for a given partition of `msg.sender`\r\n     * @param _partition The partition to which the operator is authorised\r\n     * @param _operator An address which is being authorised\r\n     */\r\n    function authorizeOperatorByPartition(bytes32 _partition, address _operator) external;\r\n\r\n    /**\r\n     * @notice Revokes authorisation of an operator previously given for a specified partition of `msg.sender`\r\n     * @param _partition The partition to which the operator is de-authorised\r\n     * @param _operator An address which is being de-authorised\r\n     */\r\n    function revokeOperatorByPartition(bytes32 _partition, address _operator) external;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\r\n     * @param _partition The partition from which to transfer tokens.\r\n     * @param _from The address from which to transfer tokens from\r\n     * @param _to The address to which to transfer tokens to\r\n     * @param _value The amount of tokens to transfer from `_partition`\r\n     * @param _data Additional data attached to the transfer of tokens\r\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\r\n     * @return The partition to which the transferred tokens were allocated for the _to address\r\n     */\r\n    function operatorTransferByPartition(\r\n        bytes32 _partition,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    )\r\n        external\r\n        returns (bytes32 partition);\r\n\r\n    /*\r\n    * @notice Returns if transfers are currently frozen or not\r\n    */\r\n    function transfersFrozen() external view returns (bool isFrozen);\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() external view returns (bool);\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() external view returns (address ownerAddress);\r\n\r\n    function controller() external view returns(address controllerAddress);\r\n\r\n    function moduleRegistry() external view returns(address moduleRegistryAddress);\r\n\r\n    function securityTokenRegistry() external view returns(address securityTokenRegistryAddress);\r\n\r\n    function polyToken() external view returns(address polyTokenAddress);\r\n\r\n    function tokenFactory() external view returns(address tokenFactoryAddress);\r\n\r\n    function getterDelegate() external view returns(address delegate);\r\n\r\n    function controllerDisabled() external view returns(bool isDisabled);\r\n\r\n    function initialized() external view returns(bool isInitialized);\r\n\r\n    function tokenDetails() external view returns(string memory details);\r\n\r\n    function updateFromRegistry() external;\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ninterface IOwnable {\r\n    /**\r\n    * @dev Returns owner\r\n    */\r\n    function owner() external view returns(address ownerAddress);\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    */\r\n    function renounceOwnership() external;\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) external;\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract DataStoreStorage {\r\n    // Address of the current implementation\r\n    address internal __implementation;\r\n\r\n    ISecurityToken public securityToken;\r\n\r\n    mapping (bytes32 => uint256) internal uintData;\r\n    mapping (bytes32 => bytes32) internal bytes32Data;\r\n    mapping (bytes32 => address) internal addressData;\r\n    mapping (bytes32 => string) internal stringData;\r\n    mapping (bytes32 => bytes) internal bytesData;\r\n    mapping (bytes32 => bool) internal boolData;\r\n    mapping (bytes32 => uint256[]) internal uintArrayData;\r\n    mapping (bytes32 => bytes32[]) internal bytes32ArrayData;\r\n    mapping (bytes32 => address[]) internal addressArrayData;\r\n    mapping (bytes32 => bool[]) internal boolArrayData;\r\n\r\n    uint8 internal constant DATA_KEY = 6;\r\n    bytes32 internal constant MANAGEDATA = \"MANAGEDATA\";\r\n}\r\n\r\n/**\r\n * @title DataStoreProxy Proxy\r\n */\r\ncontract DataStoreProxy is DataStoreStorage, Proxy {\r\n\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor(\r\n        address _securityToken,\r\n        address _implementation\r\n    )\r\n        public\r\n    {\r\n        require(_implementation != address(0) && _securityToken != address(0),\r\n            \"Address should not be 0x\"\r\n        );\r\n        securityToken = ISecurityToken(_securityToken);\r\n        __implementation = _implementation;\r\n    }\r\n\r\n    /**\r\n    * @notice Internal function to provide the address of the implementation contract\r\n    */\r\n    function _implementation() internal view returns(address) {\r\n        return __implementation;\r\n    }\r\n\r\n}\r\n\r\ncontract DataStoreFactory {\r\n\r\n    address public implementation;\r\n\r\n    constructor(address _implementation) public {\r\n        require(_implementation != address(0), \"Address should not be 0x\");\r\n        implementation = _implementation;\r\n    }\r\n\r\n    function generateDataStore(address _securityToken) public returns (address) {\r\n        DataStoreProxy dsProxy = new DataStoreProxy(_securityToken, implementation);\r\n        return address(dsProxy);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Proxy for deploying SecurityToken instances\r\n */\r\ncontract STFactory is ISTFactory, Ownable {\r\n\r\n    address public transferManagerFactory;\r\n    DataStoreFactory public dataStoreFactory;\r\n    IPolymathRegistry public polymathRegistry;\r\n\r\n    // Mapping from Security Token address to token upgrade version.\r\n    // A mapping to 0 means a token has not yet been deployed\r\n    mapping (address => uint256) tokenUpgrade;\r\n\r\n    struct LogicContract {\r\n        string version;\r\n        address logicContract;\r\n        bytes initializationData; // Called when first creating token\r\n        bytes upgradeData; // Called when upgrading token from previous version\r\n    }\r\n\r\n    mapping (uint256 => LogicContract) logicContracts;\r\n\r\n    uint256 public latestUpgrade;\r\n\r\n    event LogicContractSet(string _version, uint256 _upgrade, address _logicContract, bytes _initializationData, bytes _upgradeData);\r\n    event TokenUpgraded(\r\n        address indexed _securityToken,\r\n        uint256 indexed _version\r\n    );\r\n    event DefaultTransferManagerUpdated(address indexed _oldTransferManagerFactory, address indexed _newTransferManagerFactory);\r\n    event DefaultDataStoreUpdated(address indexed _oldDataStoreFactory, address indexed _newDataStoreFactory);\r\n\r\n    constructor(\r\n        address _polymathRegistry,\r\n        address _transferManagerFactory,\r\n        address _dataStoreFactory,\r\n        string memory _version,\r\n        address _logicContract,\r\n        bytes memory _initializationData\r\n    )\r\n        public\r\n    {\r\n        require(_logicContract != address(0), \"Invalid Address\");\r\n        require(_transferManagerFactory != address(0), \"Invalid Address\");\r\n        require(_dataStoreFactory != address(0), \"Invalid Address\");\r\n        require(_polymathRegistry != address(0), \"Invalid Address\");\r\n        require(_initializationData.length > 4, \"Invalid Initialization\");\r\n        transferManagerFactory = _transferManagerFactory;\r\n        dataStoreFactory = DataStoreFactory(_dataStoreFactory);\r\n        polymathRegistry = IPolymathRegistry(_polymathRegistry);\r\n\r\n        // Start at 1 so that we can distinguish deployed tokens in tokenUpgrade\r\n        latestUpgrade = 1;\r\n        logicContracts[latestUpgrade].logicContract = _logicContract;\r\n        logicContracts[latestUpgrade].initializationData = _initializationData;\r\n        logicContracts[latestUpgrade].version = _version;\r\n    }\r\n\r\n    /**\r\n     * @notice deploys the token and adds default modules like the GeneralTransferManager.\r\n     * Future versions of the proxy can attach different modules or pass different parameters.\r\n     */\r\n    function deployToken(\r\n        string calldata _name,\r\n        string calldata _symbol,\r\n        uint8 _decimals,\r\n        string calldata _tokenDetails,\r\n        address _issuer,\r\n        bool _divisible,\r\n        address _treasuryWallet\r\n    )\r\n        external\r\n        returns(address)\r\n    {\r\n        address securityToken = _deploy(\r\n            _name,\r\n            _symbol,\r\n            _decimals,\r\n            _tokenDetails,\r\n            _divisible\r\n        );\r\n        //NB When dataStore is generated, the security token address is automatically set via the constructor in DataStoreProxy.\r\n        if (address(dataStoreFactory) != address(0)) {\r\n            ISecurityToken(securityToken).changeDataStore(dataStoreFactory.generateDataStore(securityToken));\r\n        }\r\n        ISecurityToken(securityToken).changeTreasuryWallet(_treasuryWallet);\r\n        if (transferManagerFactory != address(0)) {\r\n            ISecurityToken(securityToken).addModule(transferManagerFactory, \"\", 0, 0, false);\r\n        }\r\n        IOwnable(securityToken).transferOwnership(_issuer);\r\n        return securityToken;\r\n    }\r\n\r\n    function _deploy(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals,\r\n        string memory _tokenDetails,\r\n        bool _divisible\r\n    ) internal returns(address) {\r\n        // Creates proxy contract and sets some initial storage\r\n        SecurityTokenProxy proxy = new SecurityTokenProxy(\r\n            _name,\r\n            _symbol,\r\n            _decimals,\r\n            _divisible ? 1 : uint256(10) ** _decimals,\r\n            _tokenDetails,\r\n            address(polymathRegistry)\r\n        );\r\n        // Sets logic contract\r\n        proxy.upgradeTo(logicContracts[latestUpgrade].version, logicContracts[latestUpgrade].logicContract);\r\n        // Initialises security token contract - needed for functions that can only be called by the\r\n        // owner of the contract, or are specific to this particular logic contract (e.g. setting version)\r\n        (bool success, ) = address(proxy).call(logicContracts[latestUpgrade].initializationData);\r\n        require(success, \"Unsuccessful initialization\");\r\n        tokenUpgrade[address(proxy)] = latestUpgrade;\r\n        return address(proxy);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to set a new token logic contract\r\n     * @param _version Version of upgraded module\r\n     * @param _logicContract Address of deployed module logic contract referenced from proxy\r\n     * @param _initializationData Initialization data that used to intialize value in the securityToken\r\n     * @param _upgradeData Data to be passed in call to upgradeToAndCall when a token upgrades its module\r\n     */\r\n    function setLogicContract(string calldata _version, address _logicContract, bytes calldata _initializationData, bytes calldata _upgradeData) external onlyOwner {\r\n        require(keccak256(abi.encodePacked(_version)) != keccak256(abi.encodePacked(logicContracts[latestUpgrade].version)), \"Same version\");\r\n        require(_logicContract != logicContracts[latestUpgrade].logicContract, \"Same version\");\r\n        require(_logicContract != address(0), \"Invalid address\");\r\n        require(_initializationData.length > 4, \"Invalid Initialization\");\r\n        require(_upgradeData.length > 4, \"Invalid Upgrade\");\r\n        latestUpgrade++;\r\n        _modifyLogicContract(latestUpgrade, _version, _logicContract, _initializationData, _upgradeData);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to update an existing token logic contract\r\n     * @param _upgrade logic contract to upgrade\r\n     * @param _version Version of upgraded module\r\n     * @param _logicContract Address of deployed module logic contract referenced from proxy\r\n     * @param _upgradeData Data to be passed in call to upgradeToAndCall when a token upgrades its module\r\n     */\r\n    function updateLogicContract(uint256 _upgrade, string calldata _version, address _logicContract, bytes calldata _initializationData, bytes calldata _upgradeData) external onlyOwner {\r\n        require(_upgrade <= latestUpgrade, \"Invalid upgrade\");\r\n        require(_upgrade > 0, \"Invalid upgrade\");\r\n        // version & contract must differ from previous version, otherwise upgrade proxy will fail\r\n        if (_upgrade > 1) {\r\n          require(keccak256(abi.encodePacked(_version)) != keccak256(abi.encodePacked(logicContracts[_upgrade - 1].version)), \"Same version\");\r\n          require(_logicContract != logicContracts[_upgrade - 1].logicContract, \"Same version\");\r\n        }\r\n        require(_logicContract != address(0), \"Invalid address\");\r\n        require(_initializationData.length > 4, \"Invalid Initialization\");\r\n        require(_upgradeData.length > 4, \"Invalid Upgrade\");\r\n        _modifyLogicContract(_upgrade, _version, _logicContract, _initializationData, _upgradeData);\r\n    }\r\n\r\n    function _modifyLogicContract(uint256 _upgrade, string memory _version, address _logicContract, bytes memory _initializationData, bytes memory _upgradeData) internal {\r\n        logicContracts[_upgrade].version = _version;\r\n        logicContracts[_upgrade].logicContract = _logicContract;\r\n        logicContracts[_upgrade].upgradeData = _upgradeData;\r\n        logicContracts[_upgrade].initializationData = _initializationData;\r\n        emit LogicContractSet(_version, _upgrade, _logicContract, _initializationData, _upgradeData);\r\n    }\r\n    /**\r\n     * @notice Used to upgrade a token\r\n     * @param _maxModuleType maximum module type enumeration\r\n     */\r\n    function upgradeToken(uint8 _maxModuleType) external {\r\n        // Check the token was created by this factory\r\n        require(tokenUpgrade[msg.sender] != 0, \"Invalid token\");\r\n        uint256 newVersion = tokenUpgrade[msg.sender] + 1;\r\n        require(newVersion <= latestUpgrade, \"Incorrect version\");\r\n        OwnedUpgradeabilityProxy(address(uint160(msg.sender))).upgradeToAndCall(logicContracts[newVersion].version, logicContracts[newVersion].logicContract, logicContracts[newVersion].upgradeData);\r\n        tokenUpgrade[msg.sender] = newVersion;\r\n        // Check that all modules remain valid\r\n        IModuleRegistry moduleRegistry = IModuleRegistry(polymathRegistry.getAddress(\"ModuleRegistry\"));\r\n        address moduleFactory;\r\n        bool isArchived;\r\n        for (uint8 i = 1; i < _maxModuleType; i++) {\r\n            address[] memory modules = ISecurityToken(msg.sender).getModulesByType(i);\r\n            for (uint256 j = 0; j < modules.length; j++) {\r\n                (,, moduleFactory, isArchived,,) = ISecurityToken(msg.sender).getModule(modules[j]);\r\n                if (!isArchived) {\r\n                    require(moduleRegistry.isCompatibleModule(moduleFactory, msg.sender), \"Incompatible Modules\");\r\n                }\r\n            }\r\n        }\r\n        emit TokenUpgraded(msg.sender, newVersion);\r\n    }\r\n\r\n    /**\r\n     * @notice Used to set a new default transfer manager\r\n     * @dev Setting this to address(0) means don't deploy a default TM\r\n     * @param _transferManagerFactory Address of new default transfer manager factory\r\n     */\r\n    function updateDefaultTransferManager(address _transferManagerFactory) external onlyOwner {\r\n        // NB - setting this to address(0) means don't deploy a default TM\r\n        emit DefaultTransferManagerUpdated(transferManagerFactory, _transferManagerFactory);\r\n        transferManagerFactory = _transferManagerFactory;\r\n    }\r\n\r\n    /**\r\n     * @notice Used to set a new default data store\r\n     * @dev Setting this to address(0) means don't deploy a default data store\r\n     * @param _dataStoreFactory Address of new default data store factory\r\n     */\r\n    function updateDefaultDataStore(address _dataStoreFactory) external onlyOwner {\r\n        // NB - setting this to address(0) means don't deploy a default TM\r\n        emit DefaultDataStoreUpdated(address(dataStoreFactory), address(_dataStoreFactory));\r\n        dataStoreFactory = DataStoreFactory(_dataStoreFactory);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"transferManagerFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transferManagerFactory\",\"type\":\"address\"}],\"name\":\"updateDefaultTransferManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_version\",\"type\":\"string\"},{\"name\":\"_logicContract\",\"type\":\"address\"},{\"name\":\"_initializationData\",\"type\":\"bytes\"},{\"name\":\"_upgradeData\",\"type\":\"bytes\"}],\"name\":\"setLogicContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dataStoreFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestUpgrade\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"polymathRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxModuleType\",\"type\":\"uint8\"}],\"name\":\"upgradeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_tokenDetails\",\"type\":\"string\"},{\"name\":\"_issuer\",\"type\":\"address\"},{\"name\":\"_divisible\",\"type\":\"bool\"},{\"name\":\"_treasuryWallet\",\"type\":\"address\"}],\"name\":\"deployToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dataStoreFactory\",\"type\":\"address\"}],\"name\":\"updateDefaultDataStore\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_upgrade\",\"type\":\"uint256\"},{\"name\":\"_version\",\"type\":\"string\"},{\"name\":\"_logicContract\",\"type\":\"address\"},{\"name\":\"_initializationData\",\"type\":\"bytes\"},{\"name\":\"_upgradeData\",\"type\":\"bytes\"}],\"name\":\"updateLogicContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_polymathRegistry\",\"type\":\"address\"},{\"name\":\"_transferManagerFactory\",\"type\":\"address\"},{\"name\":\"_dataStoreFactory\",\"type\":\"address\"},{\"name\":\"_version\",\"type\":\"string\"},{\"name\":\"_logicContract\",\"type\":\"address\"},{\"name\":\"_initializationData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_version\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_upgrade\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_logicContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_initializationData\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"_upgradeData\",\"type\":\"bytes\"}],\"name\":\"LogicContractSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_securityToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"TokenUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_oldTransferManagerFactory\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newTransferManagerFactory\",\"type\":\"address\"}],\"name\":\"DefaultTransferManagerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_oldDataStoreFactory\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newDataStoreFactory\",\"type\":\"address\"}],\"name\":\"DefaultDataStoreUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_version\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_logicContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_upgradeData\",\"type\":\"bytes\"}],\"name\":\"LogicContractSet\",\"type\":\"event\"}]","ContractName":"STFactory","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000dfabf3e4793cd30affb47ab6fa4cf4eef26bbc270000000000000000000000005fafcfc0afd80d2f95133170172b045024ca8fd100000000000000000000000011699345ce26f88be6d6b2de3b62c95ec2a89b5600000000000000000000000000000000000000000000000000000000000000c00000000000000000000000004c95b6e02c8b82f66c21555da72826e4f0b419c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000005332e302e300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024c4d66de8000000000000000000000000813c179533f75824491650b06cad5451e22d349800000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://d0b865f7b951a6f08db800a51391e1e7be5c7d74a817a50075ca37ff68b88da2"}]}