{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\n\ncontract ICards is IERC721 {\n\n    struct Batch {\n        uint48 userID;\n        uint16 size;\n    }\n\n    function batches(uint index) public view returns (uint48 userID, uint16 size);\n\n    function userIDToAddress(uint48 id) public view returns (address);\n\n    function getDetails(\n        uint tokenId\n    )\n        public\n        view\n        returns (\n        uint16 proto,\n        uint8 quality\n    );\n\n    function setQuality(\n        uint tokenId,\n        uint8 quality\n    ) public;\n\n    function mintCards(\n        address to,\n        uint16[] memory _protos,\n        uint8[] memory _qualities\n    )\n        public\n        returns (uint);\n\n    function mintCard(\n        address to,\n        uint16 _proto,\n        uint8 _quality\n    )\n        public\n        returns (uint);\n\n    function burn(uint tokenId) public;\n\n    function batchSize()\n        public\n        view\n        returns (uint);\n}\n\n\ncontract PromoFactory is Ownable {\n\n    ICards public cards;\n\n    mapping(uint16 => Proto) public protos;\n\n    uint16 public maxProto;\n    uint16 public minProto;\n\n    struct Proto {\n        bool isLocked;\n        address minter;\n    }\n\n    /**\n     * Events\n     */\n\n    event ProtoAssigned(\n        uint16 proto,\n        address minter\n    );\n\n    event ProtoLocked(\n        uint16 proto\n    );\n\n    /**\n     * Constructor\n     */\n\n    constructor(\n        ICards _cards,\n        uint16 _minProto,\n        uint16 _maxProto\n    )\n        public\n    {\n        cards = _cards;\n        minProto = _minProto;\n        maxProto = _maxProto;\n    }\n\n    /**\n     * Public functions\n     */\n\n    function mint(\n        address to,\n        uint16[] memory _protos,\n        uint8[] memory _qualities\n    )\n        public\n    {\n        require(\n            _protos.length == _qualities.length,\n            \"Proto Factory: array length mismatch between protos and qualities\"\n        );\n\n        for (uint i; i < _protos.length; i++) {\n            require(\n                protos[_protos[i]].minter == msg.sender,\n                \"Proto Factory: only assigned minter can mint for this proto\"\n            );\n\n            require(\n                protos[_protos[i]].isLocked == false,\n                \"Proto Factory: cannot mint a locked proto\"\n            );\n        }\n\n        cards.mintCards(to, _protos, _qualities);\n    }\n\n    /**\n     * Only Owner functions\n     */\n\n    function assignProtoMinter(\n        address minter,\n        uint16 proto\n    )\n        public\n        onlyOwner\n    {\n        require(\n            proto >= minProto,\n            \"Proto Factory: proto must be greater than min proto\"\n        );\n\n        require(\n            proto <= maxProto,\n            \"Proto Factory: proto must be less than max proto\"\n        );\n\n        require(\n            protos[proto].isLocked == false,\n            \"Proto Factory: proto already locked\"\n        );\n\n        protos[proto].minter = minter;\n\n        emit ProtoAssigned(proto, minter);\n\n    }\n\n    function lock(\n        uint16 proto\n    )\n        public\n        onlyOwner\n    {\n        require(\n            protos[proto].minter != address(0),\n            \"Proto Factory: must be an assigned proto\"\n        );\n\n        require(\n            protos[proto].isLocked == false,\n            \"Proto Factory: cannot lock a locked proto\"\n        );\n\n        protos[proto].isLocked = true;\n\n        emit ProtoLocked(proto);\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"maxProto\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"protos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isLocked\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minProto\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"}],\"name\":\"assignProtoMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cards\",\"outputs\":[{\"internalType\":\"contract ICards\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint16[]\",\"name\":\"_protos\",\"type\":\"uint16[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_qualities\",\"type\":\"uint8[]\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICards\",\"name\":\"_cards\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_minProto\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_maxProto\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"ProtoAssigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"}],\"name\":\"ProtoLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PromoFactory","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000e3a2a1f2146d86a604adc220b4967a898d7fe07000000000000000000000000000000000000000000000000000000000000019000000000000000000000000000000000000000000000000000000000000001f4","Library":"","LicenseType":"","SwarmSource":"bzzr://4c39c53bb0d1b1cdb39c1038e6212c994806187c24a3303f5dccbaedb10512e9"}]}