{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/iface/IBrokerRegistry.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity 0.5.7;\r\n\r\n/// @title IBrokerRegistry\r\n/// @dev A broker is an account that can submit orders on behalf of other\r\n///      accounts. When registering a broker, the owner can also specify a\r\n///      pre-deployed BrokerInterceptor to hook into the exchange smart contracts.\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\ncontract IBrokerRegistry {\r\n    event BrokerRegistered(\r\n        address owner,\r\n        address broker,\r\n        address interceptor\r\n    );\r\n\r\n    event BrokerUnregistered(\r\n        address owner,\r\n        address broker,\r\n        address interceptor\r\n    );\r\n\r\n    event AllBrokersUnregistered(\r\n        address owner\r\n    );\r\n\r\n    /// @dev   Validates if the broker was registered for the order owner and\r\n    ///        returns the possible BrokerInterceptor to be used.\r\n    /// @param owner The owner of the order\r\n    /// @param broker The broker of the order\r\n    /// @return True if the broker was registered for the owner\r\n    ///         and the BrokerInterceptor to use.\r\n    function getBroker(\r\n        address owner,\r\n        address broker\r\n        )\r\n        external\r\n        view\r\n        returns(\r\n            bool registered,\r\n            address interceptor\r\n        );\r\n\r\n    /// @dev   Gets all registered brokers for an owner.\r\n    /// @param owner The owner\r\n    /// @param start The start index of the list of brokers\r\n    /// @param count The number of brokers to return\r\n    /// @return The list of requested brokers and corresponding BrokerInterceptors\r\n    function getBrokers(\r\n        address owner,\r\n        uint    start,\r\n        uint    count\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            address[] memory brokers,\r\n            address[] memory interceptors\r\n        );\r\n\r\n    /// @dev   Registers a broker for msg.sender and an optional\r\n    ///        corresponding BrokerInterceptor.\r\n    /// @param broker The broker to register\r\n    /// @param interceptor The optional BrokerInterceptor to use (0x0 allowed)\r\n    function registerBroker(\r\n        address broker,\r\n        address interceptor\r\n        )\r\n        external;\r\n\r\n    /// @dev   Unregisters a broker for msg.sender\r\n    /// @param broker The broker to unregister\r\n    function unregisterBroker(\r\n        address broker\r\n        )\r\n        external;\r\n\r\n    /// @dev   Unregisters all brokers for msg.sender\r\n    function unregisterAllBrokers(\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/iface/IBurnRateTable.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @title IBurnRateTable - A contract for managing burn rates for tokens\r\ncontract IBurnRateTable {\r\n\r\n    struct TokenData {\r\n        uint    tier;\r\n        uint    validUntil;\r\n    }\r\n\r\n    mapping(address => TokenData) public tokens;\r\n\r\n    uint public constant YEAR_TO_SECONDS = 31556952;\r\n\r\n    // Tiers\r\n    uint8 public constant TIER_4 = 0;\r\n    uint8 public constant TIER_3 = 1;\r\n    uint8 public constant TIER_2 = 2;\r\n    uint8 public constant TIER_1 = 3;\r\n\r\n    uint16 public constant BURN_BASE_PERCENTAGE           =                 100 * 10; // 100%\r\n\r\n    // Cost of upgrading the tier level of a token in a percentage of the total LRC supply\r\n    uint16 public constant TIER_UPGRADE_COST_PERCENTAGE   =                        1; // 0.1%\r\n\r\n    // Burn rates\r\n    // Matching\r\n    uint16 public constant BURN_MATCHING_TIER1            =                       25; // 2.5%\r\n    uint16 public constant BURN_MATCHING_TIER2            =                  15 * 10; //  15%\r\n    uint16 public constant BURN_MATCHING_TIER3            =                  30 * 10; //  30%\r\n    uint16 public constant BURN_MATCHING_TIER4            =                  50 * 10; //  50%\r\n    // P2P\r\n    uint16 public constant BURN_P2P_TIER1                 =                       25; // 2.5%\r\n    uint16 public constant BURN_P2P_TIER2                 =                  15 * 10; //  15%\r\n    uint16 public constant BURN_P2P_TIER3                 =                  30 * 10; //  30%\r\n    uint16 public constant BURN_P2P_TIER4                 =                  50 * 10; //  50%\r\n\r\n    event TokenTierUpgraded(\r\n        address indexed addr,\r\n        uint            tier\r\n    );\r\n\r\n    /// @dev   Returns the P2P and matching burn rate for the token.\r\n    /// @param token The token to get the burn rate for.\r\n    /// @return The burn rate. The P2P burn rate and matching burn rate\r\n    ///         are packed together in the lowest 4 bytes.\r\n    ///         (2 bytes P2P, 2 bytes matching)\r\n    function getBurnRate(\r\n        address token\r\n        )\r\n        external\r\n        view\r\n        returns (uint32 burnRate);\r\n\r\n    /// @dev   Returns the tier of a token.\r\n    /// @param token The token to get the token tier for.\r\n    /// @return The tier of the token\r\n    function getTokenTier(\r\n        address token\r\n        )\r\n        public\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev   Upgrades the tier of a token. Before calling this function,\r\n    ///        msg.sender needs to approve this contract for the neccessary funds.\r\n    /// @param token The token to upgrade the tier for.\r\n    /// @return True if successful, false otherwise.\r\n    function upgradeTokenTier(\r\n        address token\r\n        )\r\n        external\r\n        returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/iface/IFeeHolder.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/// @author Kongliang Zhong - <kongliang@loopring.org>\r\n/// @title IFeeHolder - A contract holding fees.\r\ncontract IFeeHolder {\r\n\r\n    event TokenWithdrawn(\r\n        address owner,\r\n        address token,\r\n        uint value\r\n    );\r\n\r\n    // A map of all fee balances\r\n    mapping(address => mapping(address => uint)) public feeBalances;\r\n\r\n    /// @dev   Allows withdrawing the tokens to be burned by\r\n    ///        authorized contracts.\r\n    /// @param token The token to be used to burn buy and burn LRC\r\n    /// @param value The amount of tokens to withdraw\r\n    function withdrawBurned(\r\n        address token,\r\n        uint value\r\n        )\r\n        external\r\n        returns (bool success);\r\n\r\n    /// @dev   Allows withdrawing the fee payments funds\r\n    ///        msg.sender is the recipient of the fee and the address\r\n    ///        to which the tokens will be sent.\r\n    /// @param token The token to withdraw\r\n    /// @param value The amount of tokens to withdraw\r\n    function withdrawToken(\r\n        address token,\r\n        uint value\r\n        )\r\n        external\r\n        returns (bool success);\r\n\r\n    function batchAddFeeBalances(\r\n        bytes32[] calldata batch\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/iface/IOrderBook.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/// @title IOrderBook\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\n/// @author Kongliang Zhong - <kongliang@loopring.org>.\r\ncontract IOrderBook {\r\n    // The map of registered order hashes\r\n    mapping(bytes32 => bool) public orderSubmitted;\r\n\r\n    /// @dev  Event emitted when an order was successfully submitted\r\n    ///        orderHash      The hash of the order\r\n    ///        orderData      The data of the order as passed to submitOrder()\r\n    event OrderSubmitted(\r\n        bytes32 orderHash,\r\n        bytes   orderData\r\n    );\r\n\r\n    /// @dev   Submits an order to the on-chain order book.\r\n    ///        No signature is needed. The order can only be sumbitted by its\r\n    ///        owner or its broker (the owner can be the address of a contract).\r\n    /// @param orderData The data of the order. Contains all fields that are used\r\n    ///        for the order hash calculation.\r\n    ///        See OrderHelper.updateHash() for detailed information.\r\n    function submitOrder(\r\n        bytes calldata orderData\r\n        )\r\n        external\r\n        returns (bytes32);\r\n}\r\n\r\n// File: contracts/iface/IOrderRegistry.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/// @title IOrderRegistry\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\ncontract IOrderRegistry {\r\n\r\n    /// @dev   Returns wether the order hash was registered in the registry.\r\n    /// @param broker The broker of the order\r\n    /// @param orderHash The hash of the order\r\n    /// @return True if the order hash was registered, else false.\r\n    function isOrderHashRegistered(\r\n        address broker,\r\n        bytes32 orderHash\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev   Registers an order in the registry.\r\n    ///        msg.sender needs to be the broker of the order.\r\n    /// @param orderHash The hash of the order\r\n    function registerOrderHash(\r\n        bytes32 orderHash\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/iface/ITradeDelegate.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/// @title ITradeDelegate\r\n/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different\r\n/// versions of Loopring protocol to avoid ERC20 re-authorization.\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\ncontract ITradeDelegate {\r\n\r\n    function batchTransfer(\r\n        bytes32[] calldata batch\r\n        )\r\n        external;\r\n\r\n\r\n    /// @dev Add a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function authorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    /// @dev Remove a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function deauthorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    function isAddressAuthorized(\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n\r\n    function suspend()\r\n        external;\r\n\r\n    function resume()\r\n        external;\r\n\r\n    function kill()\r\n        external;\r\n}\r\n\r\n// File: contracts/iface/ITradeHistory.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/// @title ITradeHistory\r\n/// @dev Stores the trade history and cancelled data of orders\r\n/// @author Brecht Devos - <brecht@loopring.org>.\r\ncontract ITradeHistory {\r\n\r\n    // The following map is used to keep trace of order fill and cancellation\r\n    // history.\r\n    mapping (bytes32 => uint) public filled;\r\n\r\n    // This map is used to keep trace of order's cancellation history.\r\n    mapping (address => mapping (bytes32 => bool)) public cancelled;\r\n\r\n    // A map from a broker to its cutoff timestamp.\r\n    mapping (address => uint) public cutoffs;\r\n\r\n    // A map from a broker to its trading-pair cutoff timestamp.\r\n    mapping (address => mapping (bytes20 => uint)) public tradingPairCutoffs;\r\n\r\n    // A map from a broker to an order owner to its cutoff timestamp.\r\n    mapping (address => mapping (address => uint)) public cutoffsOwner;\r\n\r\n    // A map from a broker to an order owner to its trading-pair cutoff timestamp.\r\n    mapping (address => mapping (address => mapping (bytes20 => uint))) public tradingPairCutoffsOwner;\r\n\r\n\r\n    function batchUpdateFilled(\r\n        bytes32[] calldata filledInfo\r\n        )\r\n        external;\r\n\r\n    function setCancelled(\r\n        address broker,\r\n        bytes32 orderHash\r\n        )\r\n        external;\r\n\r\n    function setCutoffs(\r\n        address broker,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function setTradingPairCutoffs(\r\n        address broker,\r\n        bytes20 tokenPair,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function setCutoffsOfOwner(\r\n        address broker,\r\n        address owner,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function setTradingPairCutoffsOfOwner(\r\n        address broker,\r\n        address owner,\r\n        bytes20 tokenPair,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function batchGetFilledAndCheckCancelled(\r\n        bytes32[] calldata orderInfo\r\n        )\r\n        external\r\n        view\r\n        returns (uint[] memory fills);\r\n\r\n\r\n    /// @dev Add a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function authorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    /// @dev Remove a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function deauthorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    function isAddressAuthorized(\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n\r\n    function suspend()\r\n        external;\r\n\r\n    function resume()\r\n        external;\r\n\r\n    function kill()\r\n        external;\r\n}\r\n\r\n// File: contracts/impl/Data.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary Data {\r\n\r\n    enum TokenType { ERC20 }\r\n\r\n    struct Header {\r\n        uint version;\r\n        uint numOrders;\r\n        uint numRings;\r\n        uint numSpendables;\r\n    }\r\n\r\n    struct BrokerAction {\r\n        bytes32 hash;\r\n        address broker;\r\n        uint[] orderIndices;\r\n        uint numOrders;\r\n        uint[] transferIndices;\r\n        uint numTransfers;\r\n        address tokenS;\r\n        address tokenB;\r\n        address feeToken;\r\n    }\r\n\r\n    struct BrokerTransfer {\r\n        bytes32 hash;\r\n        address token;\r\n        uint amount;\r\n        address recipient;\r\n    }\r\n\r\n    struct BrokerOrder {\r\n        address owner;\r\n        bytes32 orderHash;\r\n        uint fillAmountB;\r\n        uint requestedAmountS;\r\n        uint requestedFeeAmount;\r\n        address tokenRecipient;\r\n        bytes extraData;\r\n    }\r\n\r\n    struct BrokerApprovalRequest {\r\n        BrokerOrder[] orders;\r\n        address tokenS;\r\n        address tokenB;\r\n        address feeToken;\r\n        uint totalFillAmountB;\r\n        uint totalRequestedAmountS;\r\n        uint totalRequestedFeeAmount;\r\n    }\r\n\r\n    struct BrokerInterceptorReport {\r\n        address owner;\r\n        address broker;\r\n        bytes32 orderHash;\r\n        address tokenB;\r\n        address tokenS;\r\n        address feeToken;\r\n        uint fillAmountB;\r\n        uint spentAmountS;\r\n        uint spentFeeAmount;\r\n        address tokenRecipient;\r\n        bytes extraData;\r\n    }\r\n\r\n    struct Context {\r\n        address lrcTokenAddress;\r\n        ITradeDelegate  delegate;\r\n        ITradeHistory   tradeHistory;\r\n        IBrokerRegistry orderBrokerRegistry;\r\n        IOrderRegistry  orderRegistry;\r\n        IFeeHolder feeHolder;\r\n        IOrderBook orderBook;\r\n        IBurnRateTable burnRateTable;\r\n        uint64 ringIndex;\r\n        uint feePercentageBase;\r\n        bytes32[] tokenBurnRates;\r\n        uint feeData;\r\n        uint feePtr;\r\n        uint transferData;\r\n        uint transferPtr;\r\n        BrokerOrder[] brokerOrders;\r\n        BrokerAction[] brokerActions;\r\n        BrokerTransfer[] brokerTransfers;\r\n        uint numBrokerOrders;\r\n        uint numBrokerActions;\r\n        uint numBrokerTransfers;\r\n    }\r\n\r\n    struct Mining {\r\n        // required fields\r\n        address feeRecipient;\r\n\r\n        // optional fields\r\n        address miner;\r\n        bytes   sig;\r\n\r\n        // computed fields\r\n        bytes32 hash;\r\n        address interceptor;\r\n    }\r\n\r\n    struct Spendable {\r\n        bool initialized;\r\n        uint amount;\r\n        uint reserved;\r\n    }\r\n\r\n    struct Order {\r\n        uint      version;\r\n\r\n        // required fields\r\n        address   owner;\r\n        address   tokenS;\r\n        address   tokenB;\r\n        uint      amountS;\r\n        uint      amountB;\r\n        uint      validSince;\r\n        Spendable tokenSpendableS;\r\n        Spendable tokenSpendableFee;\r\n\r\n        // optional fields\r\n        address   dualAuthAddr;\r\n        address   broker;\r\n        Spendable brokerSpendableS;\r\n        Spendable brokerSpendableFee;\r\n        address   orderInterceptor;\r\n        address   wallet;\r\n        uint      validUntil;\r\n        bytes     sig;\r\n        bytes     dualAuthSig;\r\n        bool      allOrNone;\r\n        address   feeToken;\r\n        uint      feeAmount;\r\n        int16     waiveFeePercentage;\r\n        uint16    tokenSFeePercentage;    // Pre-trading\r\n        uint16    tokenBFeePercentage;   // Post-trading\r\n        address   tokenRecipient;\r\n        uint16    walletSplitPercentage;\r\n\r\n        // computed fields\r\n        bool    P2P;\r\n        bytes32 hash;\r\n        address brokerInterceptor;\r\n        uint    filledAmountS;\r\n        uint    initialFilledAmountS;\r\n        bool    valid;\r\n\r\n        TokenType tokenTypeS;\r\n        TokenType tokenTypeB;\r\n        TokenType tokenTypeFee;\r\n        bytes32 trancheS;\r\n        bytes32 trancheB;\r\n        bytes   transferDataS;\r\n    }\r\n\r\n    struct Participation {\r\n        // required fields\r\n        Order order;\r\n\r\n        // computed fields\r\n        uint splitS;\r\n        uint feeAmount;\r\n        uint feeAmountS;\r\n        uint feeAmountB;\r\n        uint rebateFee;\r\n        uint rebateS;\r\n        uint rebateB;\r\n        uint fillAmountS;\r\n        uint fillAmountB;\r\n    }\r\n\r\n    struct Ring {\r\n        uint size;\r\n        Participation[] participations;\r\n        bytes32 hash;\r\n        uint minerFeesToOrdersPercentage;\r\n        bool valid;\r\n    }\r\n\r\n    struct FeeContext {\r\n        Data.Ring ring;\r\n        Data.Context ctx;\r\n        address feeRecipient;\r\n        uint walletPercentage;\r\n        int16 waiveFeePercentage;\r\n        address owner;\r\n        address wallet;\r\n        bool P2P;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ERC20.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/// @title ERC20 Token Interface\r\n/// @dev see https://github.com/ethereum/EIPs/issues/20\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract ERC20 {\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOf(\r\n        address who\r\n        )\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n        )\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n        )\r\n        public\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n        )\r\n        public\r\n        returns (bool);\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 value\r\n        )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n// File: contracts/lib/MathUint.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/// @title Utility Functions for uint\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary MathUint {\r\n\r\n    function mul(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"INVALID_VALUE\");\r\n    }\r\n\r\n    function sub(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        require(b <= a, \"INVALID_VALUE\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"INVALID_VALUE\");\r\n    }\r\n\r\n    function hasRoundingError(\r\n        uint value,\r\n        uint numerator,\r\n        uint denominator\r\n        )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint multiplied = mul(value, numerator);\r\n        uint remainder = multiplied % denominator;\r\n        // Return true if the rounding error is larger than 1%\r\n        return mul(remainder, 100) > multiplied;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/BytesUtil.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/// @title Utility Functions for bytes\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary BytesUtil {\r\n    function bytesToBytes32(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return bytes32(bytesToUintX(b, offset, 32));\r\n    }\r\n\r\n    function bytesToUint(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        return bytesToUintX(b, offset, 32);\r\n    }\r\n\r\n    function bytesToAddress(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        return address(bytesToUintX(b, offset, 20) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    }\r\n\r\n    function bytesToUint16(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint16)\r\n    {\r\n        return uint16(bytesToUintX(b, offset, 2) & 0xFFFF);\r\n    }\r\n\r\n    function bytesToUintX(\r\n        bytes memory b,\r\n        uint offset,\r\n        uint numBytes\r\n        )\r\n        private\r\n        pure\r\n        returns (uint data)\r\n    {\r\n        require(b.length >= offset + numBytes, \"INVALID_SIZE\");\r\n        assembly {\r\n            data := mload(add(add(b, numBytes), offset))\r\n        }\r\n    }\r\n\r\n    function subBytes(\r\n        bytes memory b,\r\n        uint offset\r\n        )\r\n        internal\r\n        pure\r\n        returns (bytes memory data)\r\n    {\r\n        require(b.length >= offset + 32, \"INVALID_SIZE\");\r\n        assembly {\r\n            data := add(add(b, 32), offset)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/MultihashUtil.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title Utility Functions for Multihash signature verificaiton\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\n/// For more information:\r\n///   - https://github.com/saurfang/ipfs-multihash-on-solidity\r\n///   - https://github.com/multiformats/multihash\r\n///   - https://github.com/multiformats/js-multihash\r\nlibrary MultihashUtil {\r\n\r\n    enum HashAlgorithm { Ethereum, EIP712 }\r\n\r\n    string public constant SIG_PREFIX = \"\\x19Ethereum Signed Message:\\n32\";\r\n\r\n    function verifySignature(\r\n        address signer,\r\n        bytes32 plaintext,\r\n        bytes memory multihash\r\n        )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint length = multihash.length;\r\n        require(length >= 2, \"invalid multihash format\");\r\n        uint8 algorithm;\r\n        uint8 size;\r\n        assembly {\r\n            algorithm := mload(add(multihash, 1))\r\n            size := mload(add(multihash, 2))\r\n        }\r\n        require(length == (2 + size), \"bad multihash size\");\r\n\r\n        if (algorithm == uint8(HashAlgorithm.Ethereum)) {\r\n            require(signer != address(0x0), \"invalid signer address\");\r\n            require(size == 65, \"bad Ethereum multihash size\");\r\n            bytes32 hash;\r\n            uint8 v;\r\n            bytes32 r;\r\n            bytes32 s;\r\n            assembly {\r\n                let data := mload(0x40)\r\n                mstore(data, 0x19457468657265756d205369676e6564204d6573736167653a0a333200000000) // SIG_PREFIX\r\n                mstore(add(data, 28), plaintext)                                                 // plaintext\r\n                hash := keccak256(data, 60)                                                      // 28 + 32\r\n                // Extract v, r and s from the multihash data\r\n                v := mload(add(multihash, 3))\r\n                r := mload(add(multihash, 35))\r\n                s := mload(add(multihash, 67))\r\n            }\r\n            return signer == ecrecover(\r\n                hash,\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n        } else if (algorithm == uint8(HashAlgorithm.EIP712)) {\r\n            require(signer != address(0x0), \"invalid signer address\");\r\n            require(size == 65, \"bad EIP712 multihash size\");\r\n            uint8 v;\r\n            bytes32 r;\r\n            bytes32 s;\r\n            assembly {\r\n                // Extract v, r and s from the multihash data\r\n                v := mload(add(multihash, 3))\r\n                r := mload(add(multihash, 35))\r\n                s := mload(add(multihash, 67))\r\n            }\r\n            return signer == ecrecover(\r\n                plaintext,\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/iface/IBrokerDelegate.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title IBrokerDelegate\r\n * @author Zack Rubenstein\r\n */\r\ninterface IBrokerDelegate {\r\n\r\n  /*\r\n   * Loopring requests an allowance be set on a given token for a specified amount. Order details\r\n   * are provided (tokenS, totalAmountS, tokenB, totalAmountB, orderTokenRecipient, extraOrderData)\r\n   * to aid in any calculations or on-chain exchange of assets that may be required. The last 4\r\n   * parameters concern the actual token approval being requested of the broker.\r\n   *\r\n   * @returns Whether or not onOrderFillReport should be called for orders using this broker\r\n   */\r\n  function brokerRequestAllowance(Data.BrokerApprovalRequest calldata request) external returns (bool);\r\n\r\n  /*\r\n   * After Loopring performs all of the transfers necessary to complete all the submitted\r\n   * rings it will call this function for every order's brokerInterceptor (if set) passing\r\n   * along the final fill counts for tokenB, tokenS and feeToken. This allows actions to be\r\n   * performed on a per-order basis after all tokenS/feeToken funds have left the order owner's\r\n   * possesion and the tokenB funds have been transfered to the order owner's intended recipient\r\n   */\r\n  function onOrderFillReport(Data.BrokerInterceptorReport calldata fillReport) external;\r\n\r\n  /*\r\n   * Get the available token balance controlled by the broker on behalf of an address (owner)\r\n   */\r\n  function brokerBalanceOf(address owner, address token) external view returns (uint);\r\n}\r\n\r\n// File: contracts/helper/OrderHelper.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title OrderHelper\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\nlibrary OrderHelper {\r\n    using MathUint      for uint;\r\n\r\n    string constant internal EIP191_HEADER = \"\\x19\\x01\";\r\n    string constant internal EIP712_DOMAIN_NAME = \"Loopring Protocol\";\r\n    string constant internal EIP712_DOMAIN_VERSION = \"2\";\r\n    bytes32 constant internal EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(\r\n        abi.encodePacked(\r\n            \"EIP712Domain(\",\r\n            \"string name,\",\r\n            \"string version\",\r\n            \")\"\r\n        )\r\n    );\r\n    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(\r\n        abi.encodePacked(\r\n            \"Order(\",\r\n            \"uint amountS,\",\r\n            \"uint amountB,\",\r\n            \"uint feeAmount,\",\r\n            \"uint validSince,\",\r\n            \"uint validUntil,\",\r\n            \"address owner,\",\r\n            \"address tokenS,\",\r\n            \"address tokenB,\",\r\n            \"address dualAuthAddr,\",\r\n            \"address broker,\",\r\n            \"address orderInterceptor,\",\r\n            \"address wallet,\",\r\n            \"address tokenRecipient,\",\r\n            \"address feeToken,\",\r\n            \"uint16 walletSplitPercentage,\",\r\n            \"uint16 tokenSFeePercentage,\",\r\n            \"uint16 tokenBFeePercentage,\",\r\n            \"bool allOrNone,\",\r\n            \"uint8 tokenTypeS,\",\r\n            \"uint8 tokenTypeB,\",\r\n            \"uint8 tokenTypeFee,\",\r\n            \"bytes32 trancheS,\",\r\n            \"bytes32 trancheB,\",\r\n            \"bytes transferDataS\",\r\n            \")\"\r\n        )\r\n    );\r\n    bytes32 constant internal EIP712_DOMAIN_HASH = keccak256(\r\n        abi.encodePacked(\r\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\r\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\r\n            keccak256(bytes(EIP712_DOMAIN_VERSION))\r\n        )\r\n    );\r\n\r\n    function updateHash(Data.Order memory order)\r\n        internal\r\n        pure\r\n    {\r\n        /* bytes32 message = keccak256( */\r\n        /*     abi.encode( */\r\n        /*         EIP712_ORDER_SCHEMA_HASH, */\r\n        /*         order.amountS, */\r\n        /*         order.amountB, */\r\n        /*         order.feeAmount, */\r\n        /*         order.validSince, */\r\n        /*         order.validUntil, */\r\n        /*         order.owner, */\r\n        /*         order.tokenS, */\r\n        /*         order.tokenB, */\r\n        /*         order.dualAuthAddr, */\r\n        /*         order.broker, */\r\n        /*         order.orderInterceptor, */\r\n        /*         order.wallet, */\r\n        /*         order.tokenRecipient */\r\n        /*         order.feeToken, */\r\n        /*         order.walletSplitPercentage, */\r\n        /*         order.tokenSFeePercentage, */\r\n        /*         order.tokenBFeePercentage, */\r\n        /*         order.allOrNone, */\r\n        /*         order.tokenTypeS, */\r\n        /*         order.tokenTypeB, */\r\n        /*         order.tokenTypeFee, */\r\n        /*         order.trancheS, */\r\n        /*         order.trancheB, */\r\n        /*         order.transferDataS */\r\n        /*     ) */\r\n        /* ); */\r\n        /* order.hash = keccak256( */\r\n        /*    abi.encodePacked( */\r\n        /*        EIP191_HEADER, */\r\n        /*        EIP712_DOMAIN_HASH, */\r\n        /*        message */\r\n        /*    ) */\r\n        /*); */\r\n\r\n        // Precalculated EIP712_ORDER_SCHEMA_HASH amd EIP712_DOMAIN_HASH because\r\n        // the solidity compiler doesn't correctly precalculate them for us.\r\n        bytes32 _EIP712_ORDER_SCHEMA_HASH = 0x40b942178d2a51f1f61934268590778feb8114db632db7d88537c98d2b05c5f2;\r\n        bytes32 _EIP712_DOMAIN_HASH = 0xaea25658c273c666156bd427f83a666135fcde6887a6c25fc1cd1562bc4f3f34;\r\n\r\n        bytes32 hash;\r\n        assembly {\r\n            // Calculate the hash for transferDataS separately\r\n            let transferDataS := mload(add(order, 1184))              // order.transferDataS\r\n            let transferDataSHash := keccak256(add(transferDataS, 32), mload(transferDataS))\r\n\r\n            let ptr := mload(64)\r\n            mstore(add(ptr,   0), _EIP712_ORDER_SCHEMA_HASH)     // EIP712_ORDER_SCHEMA_HASH\r\n            mstore(add(ptr,  32), mload(add(order, 128)))        // order.amountS\r\n            mstore(add(ptr,  64), mload(add(order, 160)))        // order.amountB\r\n            mstore(add(ptr,  96), mload(add(order, 640)))        // order.feeAmount\r\n            mstore(add(ptr, 128), mload(add(order, 192)))        // order.validSince\r\n            mstore(add(ptr, 160), mload(add(order, 480)))        // order.validUntil\r\n            mstore(add(ptr, 192), mload(add(order,  32)))        // order.owner\r\n            mstore(add(ptr, 224), mload(add(order,  64)))        // order.tokenS\r\n            mstore(add(ptr, 256), mload(add(order,  96)))        // order.tokenB\r\n            mstore(add(ptr, 288), mload(add(order, 288)))        // order.dualAuthAddr\r\n            mstore(add(ptr, 320), mload(add(order, 320)))        // order.broker\r\n            mstore(add(ptr, 352), mload(add(order, 416)))        // order.orderInterceptor\r\n            mstore(add(ptr, 384), mload(add(order, 448)))        // order.wallet\r\n            mstore(add(ptr, 416), mload(add(order, 768)))        // order.tokenRecipient\r\n            mstore(add(ptr, 448), mload(add(order, 608)))        // order.feeToken\r\n            mstore(add(ptr, 480), mload(add(order, 800)))        // order.walletSplitPercentage\r\n            mstore(add(ptr, 512), mload(add(order, 704)))        // order.tokenSFeePercentage\r\n            mstore(add(ptr, 544), mload(add(order, 736)))        // order.tokenBFeePercentage\r\n            mstore(add(ptr, 576), mload(add(order, 576)))        // order.allOrNone\r\n            mstore(add(ptr, 608), mload(add(order, 1024)))       // order.tokenTypeS\r\n            mstore(add(ptr, 640), mload(add(order, 1056)))       // order.tokenTypeB\r\n            mstore(add(ptr, 672), mload(add(order, 1088)))       // order.tokenTypeFee\r\n            mstore(add(ptr, 704), mload(add(order, 1120)))       // order.trancheS\r\n            mstore(add(ptr, 736), mload(add(order, 1152)))       // order.trancheB\r\n            mstore(add(ptr, 768), transferDataSHash)             // keccak256(order.transferDataS)\r\n            let message := keccak256(ptr, 800)                   // 25 * 32\r\n\r\n            mstore(add(ptr,  0), 0x1901)                         // EIP191_HEADER\r\n            mstore(add(ptr, 32), _EIP712_DOMAIN_HASH)            // EIP712_DOMAIN_HASH\r\n            mstore(add(ptr, 64), message)                        // message\r\n            hash := keccak256(add(ptr, 30), 66)                  // 2 + 32 + 32\r\n        }\r\n        order.hash = hash;\r\n    }\r\n\r\n    function check(\r\n        Data.Order memory order,\r\n        Data.Context memory ctx\r\n        )\r\n        internal\r\n        view\r\n    {\r\n        // If the order was already partially filled\r\n        // we don't have to check all of the infos and the signature again\r\n        if(order.filledAmountS == 0) {\r\n            validateAllInfo(order, ctx);\r\n            checkOwnerSignature(order, ctx);\r\n        } else {\r\n            validateUnstableInfo(order, ctx);\r\n        }\r\n\r\n        checkP2P(order);\r\n    }\r\n\r\n    function validateAllInfo(\r\n        Data.Order memory order,\r\n        Data.Context memory ctx\r\n        )\r\n        internal\r\n        view\r\n    {\r\n        bool valid = true;\r\n        valid = valid && (order.version == 0); // unsupported order version\r\n        valid = valid && (order.owner != address(0x0)); // invalid order owner\r\n        valid = valid && (order.tokenS != address(0x0)); // invalid order tokenS\r\n        valid = valid && (order.tokenB != address(0x0)); // invalid order tokenB\r\n        valid = valid && (order.amountS != 0); // invalid order amountS\r\n        valid = valid && (order.amountB != 0); // invalid order amountB\r\n        valid = valid && (order.feeToken != address(0x0)); // invalid fee token\r\n\r\n        valid = valid && (order.tokenSFeePercentage < ctx.feePercentageBase); // invalid tokenS percentage\r\n        valid = valid && (order.tokenBFeePercentage < ctx.feePercentageBase); // invalid tokenB percentage\r\n        valid = valid && (order.walletSplitPercentage <= 100); // invalid wallet split percentage\r\n\r\n        // We only support ERC20 for now\r\n        valid = valid && (order.tokenTypeS == Data.TokenType.ERC20 && order.trancheS == 0x0);\r\n        valid = valid && (order.tokenTypeFee == Data.TokenType.ERC20);\r\n\r\n        // NOTICE: replaced to allow orders to specify market's primary token (to denote order side)\r\n        // valid = valid && (order.tokenTypeB == Data.TokenType.ERC20 && order.trancheB == 0x0);\r\n        valid = valid && (order.tokenTypeB == Data.TokenType.ERC20) && (\r\n            bytes32ToAddress(order.trancheB) == order.tokenB ||\r\n            bytes32ToAddress(order.trancheB) == order.tokenS\r\n        );\r\n\r\n        // NOTICE: commented to allow order.transferDataS to be used for dApps building on Loopring\r\n        // valid = valid && (order.transferDataS.length == 0);\r\n\r\n        valid = valid && (order.validSince <= now); // order is too early to match\r\n\r\n        order.valid = order.valid && valid;\r\n\r\n        validateUnstableInfo(order, ctx);\r\n    }\r\n\r\n\r\n    function validateUnstableInfo(\r\n        Data.Order memory order,\r\n        Data.Context memory ctx\r\n        )\r\n        internal\r\n        view\r\n    {\r\n        bool valid = true;\r\n        valid = valid && (order.validUntil == 0 || order.validUntil > now);  // order is expired\r\n        valid = valid && (order.waiveFeePercentage <= int16(ctx.feePercentageBase)); // invalid waive percentage\r\n        valid = valid && (order.waiveFeePercentage >= -int16(ctx.feePercentageBase)); // invalid waive percentage\r\n        if (order.dualAuthAddr != address(0x0)) { // if dualAuthAddr exists, dualAuthSig must be exist.\r\n            valid = valid && (order.dualAuthSig.length > 0);\r\n        }\r\n        order.valid = order.valid && valid;\r\n    }\r\n\r\n\r\n    function checkP2P(\r\n        Data.Order memory order\r\n        )\r\n        internal\r\n        pure\r\n    {\r\n        order.P2P = (order.tokenSFeePercentage > 0 || order.tokenBFeePercentage > 0);\r\n    }\r\n\r\n    function isBuy(Data.Order memory order) internal pure returns (bool) {\r\n        return bytes32ToAddress(order.trancheB) == order.tokenB;\r\n    }\r\n\r\n    function checkOwnerSignature(\r\n        Data.Order memory order,\r\n        Data.Context memory ctx\r\n        )\r\n        internal\r\n        view\r\n    {\r\n        if (order.sig.length == 0) {\r\n            bool registered = ctx.orderRegistry.isOrderHashRegistered(\r\n                order.owner,\r\n                order.hash\r\n            );\r\n\r\n            if (!registered) {\r\n                order.valid = order.valid && ctx.orderBook.orderSubmitted(order.hash);\r\n            }\r\n        } else {\r\n            order.valid = order.valid && MultihashUtil.verifySignature(\r\n                order.owner,\r\n                order.hash,\r\n                order.sig\r\n            );\r\n            require(order.valid, 'INVALID_SIGNATURE');\r\n        }\r\n    }\r\n\r\n    function checkDualAuthSignature(\r\n        Data.Order memory order,\r\n        bytes32 miningHash\r\n        )\r\n        internal\r\n        pure\r\n    {\r\n        if (order.dualAuthSig.length != 0) {\r\n            order.valid = order.valid && MultihashUtil.verifySignature(\r\n                order.dualAuthAddr,\r\n                miningHash,\r\n                order.dualAuthSig\r\n            );\r\n            require(order.valid, 'INVALID_DUAL_AUTH_SIGNATURE');\r\n        }\r\n    }\r\n\r\n    function validateAllOrNone(\r\n        Data.Order memory order\r\n        )\r\n        internal\r\n        pure\r\n    {\r\n        // Check if this order needs to be completely filled\r\n        if(order.allOrNone) {\r\n            order.valid = order.valid && (order.filledAmountS == order.amountS);\r\n        }\r\n    }\r\n\r\n    function getBrokerHash(Data.Order memory order) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(order.broker, order.tokenS, order.tokenB, order.feeToken));\r\n    }\r\n\r\n    function getSpendableS(\r\n        Data.Order memory order,\r\n        Data.Context memory ctx\r\n        )\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        return getSpendable(\r\n            order,\r\n            ctx.delegate,\r\n            order.tokenS,\r\n            order.owner,\r\n            order.tokenSpendableS\r\n        );\r\n    }\r\n\r\n    function getSpendableFee(\r\n        Data.Order memory order,\r\n        Data.Context memory ctx\r\n        )\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        return getSpendable(\r\n            order,\r\n            ctx.delegate,\r\n            order.feeToken,\r\n            order.owner,\r\n            order.tokenSpendableFee\r\n        );\r\n    }\r\n\r\n    function reserveAmountS(\r\n        Data.Order memory order,\r\n        uint amount\r\n        )\r\n        internal\r\n        pure\r\n    {\r\n        order.tokenSpendableS.reserved += amount;\r\n    }\r\n\r\n    function reserveAmountFee(\r\n        Data.Order memory order,\r\n        uint amount\r\n        )\r\n        internal\r\n        pure\r\n    {\r\n        order.tokenSpendableFee.reserved += amount;\r\n    }\r\n\r\n    function resetReservations(\r\n        Data.Order memory order\r\n        )\r\n        internal\r\n        pure\r\n    {\r\n        order.tokenSpendableS.reserved = 0;\r\n        order.tokenSpendableFee.reserved = 0;\r\n    }\r\n\r\n    /// @return Amount of ERC20 token that can be spent by this contract.\r\n    function getERC20Spendable(\r\n        Data.Order memory order,\r\n        ITradeDelegate delegate,\r\n        address tokenAddress,\r\n        address owner\r\n        )\r\n        private\r\n        view\r\n        returns (uint spendable)\r\n    {\r\n        if (order.broker == address(0x0)) {\r\n            ERC20 token = ERC20(tokenAddress);\r\n            spendable = token.allowance(\r\n                owner,\r\n                address(delegate)\r\n            );\r\n            if (spendable != 0) {\r\n                uint balance = token.balanceOf(owner);\r\n                spendable = (balance < spendable) ? balance : spendable;\r\n            }\r\n        } else {\r\n            IBrokerDelegate broker = IBrokerDelegate(order.broker);\r\n            spendable = broker.brokerBalanceOf(owner, tokenAddress);\r\n        }\r\n    }\r\n\r\n    function getSpendable(\r\n        Data.Order memory order,\r\n        ITradeDelegate delegate,\r\n        address tokenAddress,\r\n        address owner,\r\n        Data.Spendable memory tokenSpendable\r\n        )\r\n        private\r\n        view\r\n        returns (uint spendable)\r\n    {\r\n        if (!tokenSpendable.initialized) {\r\n            tokenSpendable.amount = getERC20Spendable(\r\n                order,\r\n                delegate,\r\n                tokenAddress,\r\n                owner\r\n            );\r\n            tokenSpendable.initialized = true;\r\n        }\r\n        spendable = tokenSpendable.amount.sub(tokenSpendable.reserved);\r\n    }\r\n\r\n    function bytes32ToAddress(bytes32 data) private pure returns (address) {\r\n        return address(uint160(uint256(data)));\r\n    }\r\n}\r\n\r\n// File: contracts/iface/Errors.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n/// @title Errors\r\ncontract Errors {\r\n    string constant ZERO_VALUE                 = \"ZERO_VALUE\";\r\n    string constant ZERO_ADDRESS               = \"ZERO_ADDRESS\";\r\n    string constant INVALID_VALUE              = \"INVALID_VALUE\";\r\n    string constant INVALID_ADDRESS            = \"INVALID_ADDRESS\";\r\n    string constant INVALID_SIZE               = \"INVALID_SIZE\";\r\n    string constant INVALID_SIG                = \"INVALID_SIG\";\r\n    string constant INVALID_STATE              = \"INVALID_STATE\";\r\n    string constant NOT_FOUND                  = \"NOT_FOUND\";\r\n    string constant ALREADY_EXIST              = \"ALREADY_EXIST\";\r\n    string constant REENTRY                    = \"REENTRY\";\r\n    string constant UNAUTHORIZED               = \"UNAUTHORIZED\";\r\n    string constant UNIMPLEMENTED              = \"UNIMPLEMENTED\";\r\n    string constant UNSUPPORTED                = \"UNSUPPORTED\";\r\n    string constant TRANSFER_FAILURE           = \"TRANSFER_FAILURE\";\r\n    string constant WITHDRAWAL_FAILURE         = \"WITHDRAWAL_FAILURE\";\r\n    string constant BURN_FAILURE               = \"BURN_FAILURE\";\r\n    string constant BURN_RATE_FROZEN           = \"BURN_RATE_FROZEN\";\r\n    string constant BURN_RATE_MINIMIZED        = \"BURN_RATE_MINIMIZED\";\r\n    string constant UNAUTHORIZED_ONCHAIN_ORDER = \"UNAUTHORIZED_ONCHAIN_ORDER\";\r\n    string constant INVALID_CANDIDATE          = \"INVALID_CANDIDATE\";\r\n    string constant ALREADY_VOTED              = \"ALREADY_VOTED\";\r\n    string constant NOT_OWNER                  = \"NOT_OWNER\";\r\n}\r\n\r\n// File: contracts/lib/NoDefaultFunc.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n/// @title NoDefaultFunc\r\n/// @dev Disable default functions.\r\ncontract NoDefaultFunc is Errors {\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n        revert(UNSUPPORTED);\r\n    }\r\n}\r\n\r\n// File: contracts/impl/OrderBook.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title An Implementation of IOrderbook.\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\n/// @author Kongliang Zhong - <kongliang@loopring.org>.\r\ncontract OrderBook is IOrderBook, NoDefaultFunc {\r\n    using OrderHelper     for Data.Order;\r\n    using BytesUtil       for bytes;\r\n\r\n    function submitOrder(\r\n        bytes calldata data\r\n        )\r\n        external\r\n        returns (bytes32)\r\n    {\r\n        require(data.length >= 23 * 32, INVALID_SIZE);\r\n\r\n        Data.Order memory order = Data.Order(\r\n            0,                                                      // version\r\n            address(data.bytesToUint(0 * 32)),                      // owner\r\n            address(data.bytesToUint(1 * 32)),                      // tokenS\r\n            address(data.bytesToUint(2 * 32)),                      // tokenB\r\n            data.bytesToUint(3 * 32),                               // amountS\r\n            data.bytesToUint(4 * 32),                               // amountB\r\n            data.bytesToUint(5 * 32),                               // validSince\r\n            Data.Spendable(true, 0, 0),\r\n            Data.Spendable(true, 0, 0),\r\n            address(0x0),\r\n            address(data.bytesToUint(6 * 32)),                      // broker\r\n            Data.Spendable(true, 0, 0),\r\n            Data.Spendable(true, 0, 0),\r\n            address(data.bytesToUint(7 * 32)),                      // orderInterceptor\r\n            address(data.bytesToUint(8 * 32)),                      // wallet\r\n            uint(data.bytesToUint(9 * 32)),                         // validUtil\r\n            new bytes(0),\r\n            new bytes(0),\r\n            bool(data.bytesToUint(10 * 32) > 0),                    // allOrNone\r\n            address(data.bytesToUint(11 * 32)),                     // feeToken\r\n            data.bytesToUint(12 * 32),                              // feeAmount\r\n            0,\r\n            uint16(data.bytesToUint(13 * 32)),                      // tokenSFeePercentage\r\n            uint16(data.bytesToUint(14 * 32)),                      // tokenBFeePercentage\r\n            address(data.bytesToUint(15 * 32)),                     // tokenRecipient\r\n            uint16(data.bytesToUint(16 * 32)),                      // walletSplitPercentage\r\n            false,\r\n            bytes32(0x0),\r\n            address(0x0),\r\n            0,\r\n            0,\r\n            true,\r\n            Data.TokenType(data.bytesToUint(17 * 32)),              // tokenTypeS\r\n            Data.TokenType(data.bytesToUint(18 * 32)),              // tokenTypeB\r\n            Data.TokenType(data.bytesToUint(19 * 32)),              // tokenTypeFee\r\n            data.bytesToBytes32(20 * 32),                           // trancheS\r\n            data.bytesToBytes32(21 * 32),                           // trancheB\r\n            data.subBytes(22 * 32)                                  // transferDataS\r\n        );\r\n        require(data.length == 23 * 32 + order.transferDataS.length, INVALID_SIZE);\r\n\r\n        /// msg.sender must be order's owner or broker.\r\n        /// no need to check order's broker is registered here. it will be checked during\r\n        /// ring settlement.\r\n        require(\r\n            msg.sender == order.owner || msg.sender == order.broker,\r\n            UNAUTHORIZED_ONCHAIN_ORDER\r\n        );\r\n\r\n        // Calculate the order hash\r\n        order.updateHash();\r\n\r\n        // Register the hash\r\n        require(!orderSubmitted[order.hash], ALREADY_EXIST);\r\n        orderSubmitted[order.hash] = true;\r\n\r\n        // Broadcast the order data\r\n        emit OrderSubmitted(order.hash, data);\r\n\r\n        return order.hash;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderSubmitted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"submitOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"OrderSubmitted\",\"type\":\"event\"}]","ContractName":"OrderBook","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://37403089b4a7a9f3e227b6935a7184b6f13eebec1ca63f6549bbed6ed555837c"}]}