{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\n\n/**\r\n * @title Interface to be implemented by all checkpoint modules\r\n */\r\n/*solium-disable-next-line no-empty-blocks*/\r\ninterface ICheckpoint {\r\n\r\n}\n\n/**\n * @title Holds the storage variable for the DividendCheckpoint modules (i.e ERC20, Ether)\n * @dev abstract contract\n */\ncontract DividendCheckpointStorage {\n\n    // Address to which reclaimed dividends and withholding tax is sent\n    address payable public wallet;\n    uint256 public EXCLUDED_ADDRESS_LIMIT = 150;\n\n    struct Dividend {\n        uint256 checkpointId;\n        uint256 created; // Time at which the dividend was created\n        uint256 maturity; // Time after which dividend can be claimed - set to 0 to bypass\n        uint256 expiry;  // Time until which dividend can be claimed - after this time any remaining amount can be withdrawn by issuer -\n                         // set to very high value to bypass\n        uint256 amount; // Dividend amount in WEI\n        uint256 claimedAmount; // Amount of dividend claimed so far\n        uint256 totalSupply; // Total supply at the associated checkpoint (avoids recalculating this)\n        bool reclaimed;  // True if expiry has passed and issuer has reclaimed remaining dividend\n        uint256 totalWithheld;\n        uint256 totalWithheldWithdrawn;\n        mapping (address => bool) claimed; // List of addresses which have claimed dividend\n        mapping (address => bool) dividendExcluded; // List of addresses which cannot claim dividends\n        mapping (address => uint256) withheld; // Amount of tax withheld from claim\n        bytes32 name; // Name/title - used for identification\n    }\n\n    // List of all dividends\n    Dividend[] public dividends;\n\n    // List of addresses which cannot claim dividends\n    address[] public excluded;\n\n    // Mapping from address to withholding tax as a percentage * 10**16\n    mapping (address => uint256) public withholdingTax;\n\n    // Total amount of ETH withheld per investor\n    mapping(address => uint256) public investorWithheld;\n\n}\n\n/**\n * @title Interface that every module contract should implement\n */\ninterface IModule {\n    /**\n     * @notice This function returns the signature of configure function\n     */\n    function getInitFunction() external pure returns(bytes4 initFunction);\n\n    /**\n     * @notice Return the permission flags that are associated with a module\n     */\n    function getPermissions() external view returns(bytes32[] memory permissions);\n\n}\n\n/**\n * @title Utility contract to allow pausing and unpausing of certain functions\n */\ncontract Pausable {\n    event Pause(address account);\n    event Unpause(address account);\n\n    bool public paused = false;\n\n    /**\n    * @notice Modifier to make a function callable only when the contract is not paused.\n    */\n    modifier whenNotPaused() {\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n\n    /**\n    * @notice Modifier to make a function callable only when the contract is paused.\n    */\n    modifier whenPaused() {\n        require(paused, \"Contract is not paused\");\n        _;\n    }\n\n    /**\n    * @notice Called by the owner to pause, triggers stopped state\n    */\n    function _pause() internal whenNotPaused {\n        paused = true;\n        /*solium-disable-next-line security/no-block-members*/\n        emit Pause(msg.sender);\n    }\n\n    /**\n    * @notice Called by the owner to unpause, returns to normal state\n    */\n    function _unpause() internal whenPaused {\n        paused = false;\n        /*solium-disable-next-line security/no-block-members*/\n        emit Unpause(msg.sender);\n    }\n\n}\n\n/**\n * @title Interface that every module factory contract should implement\n */\ninterface IModuleFactory {\n    event ChangeSetupCost(uint256 _oldSetupCost, uint256 _newSetupCost);\n    event ChangeCostType(bool _isOldCostInPoly, bool _isNewCostInPoly);\n    event GenerateModuleFromFactory(\n        address _module,\n        bytes32 indexed _moduleName,\n        address indexed _moduleFactory,\n        address _creator,\n        uint256 _setupCost,\n        uint256 _setupCostInPoly\n    );\n    event ChangeSTVersionBound(string _boundType, uint8 _major, uint8 _minor, uint8 _patch);\n\n    //Should create an instance of the Module, or throw\n    function deploy(bytes calldata _data) external returns(address moduleAddress);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function version() external view returns(string memory moduleVersion);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function name() external view returns(bytes32 moduleName);\n\n    /**\n     * @notice Returns the title associated with the module\n     */\n    function title() external view returns(string memory moduleTitle);\n\n    /**\n     * @notice Returns the description associated with the module\n     */\n    function description() external view returns(string memory moduleDescription);\n\n    /**\n     * @notice Get the setup cost of the module in USD\n     */\n    function setupCost() external returns(uint256 usdSetupCost);\n\n    /**\n     * @notice Type of the Module factory\n     */\n    function getTypes() external view returns(uint8[] memory moduleTypes);\n\n    /**\n     * @notice Get the tags related to the module factory\n     */\n    function getTags() external view returns(bytes32[] memory moduleTags);\n\n    /**\n     * @notice Used to change the setup fee\n     * @param _newSetupCost New setup fee\n     */\n    function changeSetupCost(uint256 _newSetupCost) external;\n\n    /**\n     * @notice Used to change the currency and amount setup cost\n     * @param _setupCost new setup cost\n     * @param _isCostInPoly new setup cost currency. USD or POLY\n     */\n    function changeCostAndType(uint256 _setupCost, bool _isCostInPoly) external;\n\n    /**\n     * @notice Function use to change the lower and upper bound of the compatible version st\n     * @param _boundType Type of bound\n     * @param _newVersion New version array\n     */\n    function changeSTVersionBounds(string calldata _boundType, uint8[] calldata _newVersion) external;\n\n    /**\n     * @notice Get the setup cost of the module\n     */\n    function setupCostInPoly() external returns (uint256 polySetupCost);\n\n    /**\n     * @notice Used to get the lower bound\n     * @return Lower bound\n     */\n    function getLowerSTVersionBounds() external view returns(uint8[] memory lowerBounds);\n\n    /**\n     * @notice Used to get the upper bound\n     * @return Upper bound\n     */\n    function getUpperSTVersionBounds() external view returns(uint8[] memory upperBounds);\n\n    /**\n     * @notice Updates the tags of the ModuleFactory\n     * @param _tagsData New list of tags\n     */\n    function changeTags(bytes32[] calldata _tagsData) external;\n\n    /**\n     * @notice Updates the name of the ModuleFactory\n     * @param _name New name that will replace the old one.\n     */\n    function changeName(bytes32 _name) external;\n\n    /**\n     * @notice Updates the description of the ModuleFactory\n     * @param _description New description that will replace the old one.\n     */\n    function changeDescription(string calldata _description) external;\n\n    /**\n     * @notice Updates the title of the ModuleFactory\n     * @param _title New Title that will replace the old one.\n     */\n    function changeTitle(string calldata _title) external;\n\n}\n\ninterface IDataStore {\n    /**\n     * @dev Changes security token atatched to this data store\n     * @param _securityToken address of the security token\n     */\n    function setSecurityToken(address _securityToken) external;\n\n    /**\n     * @dev Stores a uint256 data against a key\n     * @param _key Unique key to identify the data\n     * @param _data Data to be stored against the key\n     */\n    function setUint256(bytes32 _key, uint256 _data) external;\n\n    function setBytes32(bytes32 _key, bytes32 _data) external;\n\n    function setAddress(bytes32 _key, address _data) external;\n\n    function setString(bytes32 _key, string calldata _data) external;\n\n    function setBytes(bytes32 _key, bytes calldata _data) external;\n\n    function setBool(bytes32 _key, bool _data) external;\n\n    /**\n     * @dev Stores a uint256 array against a key\n     * @param _key Unique key to identify the array\n     * @param _data Array to be stored against the key\n     */\n    function setUint256Array(bytes32 _key, uint256[] calldata _data) external;\n\n    function setBytes32Array(bytes32 _key, bytes32[] calldata _data) external ;\n\n    function setAddressArray(bytes32 _key, address[] calldata _data) external;\n\n    function setBoolArray(bytes32 _key, bool[] calldata _data) external;\n\n    /**\n     * @dev Inserts a uint256 element to the array identified by the key\n     * @param _key Unique key to identify the array\n     * @param _data Element to push into the array\n     */\n    function insertUint256(bytes32 _key, uint256 _data) external;\n\n    function insertBytes32(bytes32 _key, bytes32 _data) external;\n\n    function insertAddress(bytes32 _key, address _data) external;\n\n    function insertBool(bytes32 _key, bool _data) external;\n\n    /**\n     * @dev Deletes an element from the array identified by the key.\n     * When an element is deleted from an Array, last element of that array is moved to the index of deleted element.\n     * @param _key Unique key to identify the array\n     * @param _index Index of the element to delete\n     */\n    function deleteUint256(bytes32 _key, uint256 _index) external;\n\n    function deleteBytes32(bytes32 _key, uint256 _index) external;\n\n    function deleteAddress(bytes32 _key, uint256 _index) external;\n\n    function deleteBool(bytes32 _key, uint256 _index) external;\n\n    /**\n     * @dev Stores multiple uint256 data against respective keys\n     * @param _keys Array of keys to identify the data\n     * @param _data Array of data to be stored against the respective keys\n     */\n    function setUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\n\n    function setBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\n\n    function setAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\n\n    function setBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\n\n    /**\n     * @dev Inserts multiple uint256 elements to the array identified by the respective keys\n     * @param _keys Array of keys to identify the data\n     * @param _data Array of data to be inserted in arrays of the respective keys\n     */\n    function insertUint256Multi(bytes32[] calldata _keys, uint256[] calldata _data) external;\n\n    function insertBytes32Multi(bytes32[] calldata _keys, bytes32[] calldata _data) external;\n\n    function insertAddressMulti(bytes32[] calldata _keys, address[] calldata _data) external;\n\n    function insertBoolMulti(bytes32[] calldata _keys, bool[] calldata _data) external;\n\n    function getUint256(bytes32 _key) external view returns(uint256);\n\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    function getAddress(bytes32 _key) external view returns(address);\n\n    function getString(bytes32 _key) external view returns(string memory);\n\n    function getBytes(bytes32 _key) external view returns(bytes memory);\n\n    function getBool(bytes32 _key) external view returns(bool);\n\n    function getUint256Array(bytes32 _key) external view returns(uint256[] memory);\n\n    function getBytes32Array(bytes32 _key) external view returns(bytes32[] memory);\n\n    function getAddressArray(bytes32 _key) external view returns(address[] memory);\n\n    function getBoolArray(bytes32 _key) external view returns(bool[] memory);\n\n    function getUint256ArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getBytes32ArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getAddressArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getBoolArrayLength(bytes32 _key) external view returns(uint256);\n\n    function getUint256ArrayElement(bytes32 _key, uint256 _index) external view returns(uint256);\n\n    function getBytes32ArrayElement(bytes32 _key, uint256 _index) external view returns(bytes32);\n\n    function getAddressArrayElement(bytes32 _key, uint256 _index) external view returns(address);\n\n    function getBoolArrayElement(bytes32 _key, uint256 _index) external view returns(bool);\n\n    function getUint256ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(uint256[] memory);\n\n    function getBytes32ArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bytes32[] memory);\n\n    function getAddressArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(address[] memory);\n\n    function getBoolArrayElements(bytes32 _key, uint256 _startIndex, uint256 _endIndex) external view returns(bool[] memory);\n}\n\n/**\n * @title Interface for all security tokens\n */\ninterface ISecurityToken {\n    // Standard ERC20 interface\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function decimals() external view returns(uint8);\n    function totalSupply() external view returns(uint256);\n    function balanceOf(address owner) external view returns(uint256);\n    function allowance(address owner, address spender) external view returns(uint256);\n    function transfer(address to, uint256 value) external returns(bool);\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\n    function approve(address spender, uint256 value) external returns(bool);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     * @return byte Ethereum status code (ESC)\n     * @return bytes32 Application specific reason code\n     */\n    function canTransfer(address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\n\n    // Emit at the time when module get added\n    event ModuleAdded(\n        uint8[] _types,\n        bytes32 indexed _name,\n        address indexed _moduleFactory,\n        address _module,\n        uint256 _moduleCost,\n        uint256 _budget,\n        bytes32 _label,\n        bool _archived\n    );\n\n    // Emit when the token details get updated\n    event UpdateTokenDetails(string _oldDetails, string _newDetails);\n    // Emit when the token name get updated\n    event UpdateTokenName(string _oldName, string _newName);\n    // Emit when the granularity get changed\n    event GranularityChanged(uint256 _oldGranularity, uint256 _newGranularity);\n    // Emit when is permanently frozen by the issuer\n    event FreezeIssuance();\n    // Emit when transfers are frozen or unfrozen\n    event FreezeTransfers(bool _status);\n    // Emit when new checkpoint created\n    event CheckpointCreated(uint256 indexed _checkpointId, uint256 _investorLength);\n    // Events to log controller actions\n    event SetController(address indexed _oldController, address indexed _newController);\n    //Event emit when the global treasury wallet address get changed\n    event TreasuryWalletChanged(address _oldTreasuryWallet, address _newTreasuryWallet);\n    event DisableController();\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event TokenUpgraded(uint8 _major, uint8 _minor, uint8 _patch);\n\n    // Emit when Module get archived from the securityToken\n    event ModuleArchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when Module get unarchived from the securityToken\n    event ModuleUnarchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when Module get removed from the securityToken\n    event ModuleRemoved(uint8[] _types, address _module); //Event emitted by the tokenLib.\n    // Emit when the budget allocated to a module is changed\n    event ModuleBudgetChanged(uint8[] _moduleTypes, address _module, uint256 _oldBudget, uint256 _budget); //Event emitted by the tokenLib.\n\n    // Transfer Events\n    event TransferByPartition(\n        bytes32 indexed _fromPartition,\n        address _operator,\n        address indexed _from,\n        address indexed _to,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    // Operator Events\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n\n    // Issuance / Redemption Events\n    event IssuedByPartition(bytes32 indexed partition, address indexed to, uint256 value, bytes data);\n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\n\n    // Document Events\n    event DocumentRemoved(bytes32 indexed _name, string _uri, bytes32 _documentHash);\n    event DocumentUpdated(bytes32 indexed _name, string _uri, bytes32 _documentHash);\n\n    // Controller Events\n    event ControllerTransfer(\n        address _controller,\n        address indexed _from,\n        address indexed _to,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    event ControllerRedemption(\n        address _controller,\n        address indexed _tokenHolder,\n        uint256 _value,\n        bytes _data,\n        bytes _operatorData\n    );\n\n    // Issuance / Redemption Events\n    event Issued(address indexed _operator, address indexed _to, uint256 _value, bytes _data);\n    event Redeemed(address indexed _operator, address indexed _from, uint256 _value, bytes _data);\n\n    /**\n     * @notice Initialization function\n     * @dev Expected to be called atomically with the proxy being created, by the owner of the token\n     * @dev Can only be called once\n     */\n    function initialize(address _getterDelegate) external;\n\n    /**\n     * @notice The standard provides an on-chain function to determine whether a transfer will succeed,\n     * and return details indicating the reason if the transfer is not valid.\n     * @param _from The address from whom the tokens get transferred.\n     * @param _to The address to which to transfer tokens to.\n     * @param _partition The partition from which to transfer tokens\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @return ESC (Ethereum Status Code) following the EIP-1066 standard\n     * @return Application specific reason codes with additional details\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function canTransferByPartition(\n        address _from,\n        address _to,\n        bytes32 _partition,\n        uint256 _value,\n        bytes calldata _data\n    )\n        external\n        view\n        returns (byte statusCode, bytes32 reasonCode, bytes32 partition);\n\n    /**\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     * @return byte Ethereum status code (ESC)\n     * @return bytes32 Application specific reason code\n     */\n    function canTransferFrom(address _from, address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\n\n    /**\n     * @notice Used to attach a new document to the contract, or update the URI or hash of an existing attached document\n     * @dev Can only be executed by the owner of the contract.\n     * @param _name Name of the document. It should be unique always\n     * @param _uri Off-chain uri of the document from where it is accessible to investors/advisors to read.\n     * @param _documentHash hash (of the contents) of the document.\n     */\n    function setDocument(bytes32 _name, string calldata _uri, bytes32 _documentHash) external;\n\n    /**\n     * @notice Used to remove an existing document from the contract by giving the name of the document.\n     * @dev Can only be executed by the owner of the contract.\n     * @param _name Name of the document. It should be unique always\n     */\n    function removeDocument(bytes32 _name) external;\n\n    /**\n     * @notice Used to return the details of a document with a known name (`bytes32`).\n     * @param _name Name of the document\n     * @return string The URI associated with the document.\n     * @return bytes32 The hash (of the contents) of the document.\n     * @return uint256 the timestamp at which the document was last modified.\n     */\n    function getDocument(bytes32 _name) external view returns (string memory documentUri, bytes32 documentHash, uint256 documentTime);\n\n    /**\n     * @notice Used to retrieve a full list of documents attached to the smart contract.\n     * @return bytes32 List of all documents names present in the contract.\n     */\n    function getAllDocuments() external view returns (bytes32[] memory documentNames);\n\n    /**\n     * @notice In order to provide transparency over whether `controllerTransfer` / `controllerRedeem` are useable\n     * or not `isControllable` function will be used.\n     * @dev If `isControllable` returns `false` then it always return `false` and\n     * `controllerTransfer` / `controllerRedeem` will always revert.\n     * @return bool `true` when controller address is non-zero otherwise return `false`.\n     */\n    function isControllable() external view returns (bool controlled);\n\n    /**\n     * @notice Checks if an address is a module of certain type\n     * @param _module Address to check\n     * @param _type type to check against\n     */\n    function isModule(address _module, uint8 _type) external view returns(bool isValid);\n\n    /**\n     * @notice This function must be called to increase the total supply (Corresponds to mint function of ERC20).\n     * @dev It only be called by the token issuer or the operator defined by the issuer. ERC1594 doesn't have\n     * have the any logic related to operator but its superset ERC1400 have the operator logic and this function\n     * is allowed to call by the operator.\n     * @param _tokenHolder The account that will receive the created tokens (account should be whitelisted or KYCed).\n     * @param _value The amount of tokens need to be issued\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\n     */\n    function issue(address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice issue new tokens and assigns them to the target _tokenHolder.\n     * @dev Can only be called by the issuer or STO attached to the token.\n     * @param _tokenHolders A list of addresses to whom the minted tokens will be dilivered\n     * @param _values A list of number of tokens get minted and transfer to corresponding address of the investor from _tokenHolders[] list\n     * @return success\n     */\n    function issueMulti(address[] calldata _tokenHolders, uint256[] calldata _values) external;\n\n    /**\n     * @notice Increases totalSupply and the corresponding amount of the specified owners partition\n     * @param _partition The partition to allocate the increase in balance\n     * @param _tokenHolder The token holder whose balance should be increased\n     * @param _value The amount by which to increase the balance\n     * @param _data Additional data attached to the minting of tokens\n     */\n    function issueByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of msg.sender\n     * @param _partition The partition to allocate the decrease in balance\n     * @param _value The amount by which to decrease the balance\n     * @param _data Additional data attached to the burning of tokens\n     */\n    function redeemByPartition(bytes32 _partition, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\n     * are out of the scope of the ERC1594.\n     * @param _value The amount of tokens need to be redeemed\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\n     */\n    function redeem(uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\n     * are out of the scope of the ERC1594.\n     * @dev It is analogy to `transferFrom`\n     * @param _tokenHolder The account whose tokens gets redeemed.\n     * @param _value The amount of tokens need to be redeemed\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\n     */\n    function redeemFrom(address _tokenHolder, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of tokenHolder\n     * @dev This function can only be called by the authorised operator.\n     * @param _partition The partition to allocate the decrease in balance.\n     * @param _tokenHolder The token holder whose balance should be decreased\n     * @param _value The amount by which to decrease the balance\n     * @param _data Additional data attached to the burning of tokens\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\n     */\n    function operatorRedeemByPartition(\n        bytes32 _partition,\n        address _tokenHolder,\n        uint256 _value,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    ) external;\n\n    /**\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n     * @param _delegate address of delegate\n     * @param _module address of PermissionManager module\n     * @param _perm the permissions\n     * @return success\n     */\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPermission);\n\n    /**\n     * @notice Returns module list for a module type\n     * @param _module Address of the module\n     * @return bytes32 Name\n     * @return address Module address\n     * @return address Module factory address\n     * @return bool Module archived\n     * @return uint8 Array of module types\n     * @return bytes32 Module label\n     */\n    function getModule(address _module) external view returns (bytes32 moduleName, address moduleAddress, address factoryAddress, bool isArchived, uint8[] memory moduleTypes, bytes32 moduleLabel);\n\n    /**\n     * @notice Returns module list for a module name\n     * @param _name Name of the module\n     * @return address[] List of modules with this name\n     */\n    function getModulesByName(bytes32 _name) external view returns(address[] memory modules);\n\n    /**\n     * @notice Returns module list for a module type\n     * @param _type Type of the module\n     * @return address[] List of modules with this type\n     */\n    function getModulesByType(uint8 _type) external view returns(address[] memory modules);\n\n    /**\n     * @notice use to return the global treasury wallet\n     */\n    function getTreasuryWallet() external view returns(address treasuryWallet);\n\n    /**\n     * @notice Queries totalSupply at a specified checkpoint\n     * @param _checkpointId Checkpoint ID to query as of\n     */\n    function totalSupplyAt(uint256 _checkpointId) external view returns(uint256 supply);\n\n    /**\n     * @notice Queries balance at a specified checkpoint\n     * @param _investor Investor to query balance for\n     * @param _checkpointId Checkpoint ID to query as of\n     */\n    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns(uint256 balance);\n\n    /**\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\n     */\n    function createCheckpoint() external returns(uint256 checkpointId);\n\n    /**\n     * @notice Gets list of times that checkpoints were created\n     * @return List of checkpoint times\n     */\n    function getCheckpointTimes() external view returns(uint256[] memory checkpointTimes);\n\n    /**\n     * @notice returns an array of investors\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\n     * @return list of addresses\n     */\n    function getInvestors() external view returns(address[] memory investors);\n\n    /**\n     * @notice returns an array of investors at a given checkpoint\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\n     * @return list of investors\n     */\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[] memory investors);\n\n    /**\n     * @notice returns an array of investors with non zero balance at a given checkpoint\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\n     * @param _start Position of investor to start iteration from\n     * @param _end Position of investor to stop iteration at\n     * @return list of investors\n     */\n    function getInvestorsSubsetAt(uint256 _checkpointId, uint256 _start, uint256 _end) external view returns(address[] memory investors);\n\n    /**\n     * @notice generates subset of investors\n     * NB - can be used in batches if investor list is large\n     * @param _start Position of investor to start iteration from\n     * @param _end Position of investor to stop iteration at\n     * @return list of investors\n     */\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[] memory investors);\n\n    /**\n     * @notice Gets current checkpoint ID\n     * @return Id\n     */\n    function currentCheckpointId() external view returns(uint256 checkpointId);\n\n    /**\n     * @notice Determines whether `_operator` is an operator for all partitions of `_tokenHolder`\n     * @param _operator The operator to check\n     * @param _tokenHolder The token holder to check\n     * @return Whether the `_operator` is an operator for all partitions of `_tokenHolder`\n     */\n    function isOperator(address _operator, address _tokenHolder) external view returns (bool isValid);\n\n    /**\n     * @notice Determines whether `_operator` is an operator for a specified partition of `_tokenHolder`\n     * @param _partition The partition to check\n     * @param _operator The operator to check\n     * @param _tokenHolder The token holder to check\n     * @return Whether the `_operator` is an operator for a specified partition of `_tokenHolder`\n     */\n    function isOperatorForPartition(bytes32 _partition, address _operator, address _tokenHolder) external view returns (bool isValid);\n\n    /**\n     * @notice Return all partitions\n     * @param _tokenHolder Whom balance need to queried\n     * @return List of partitions\n     */\n    function partitionsOf(address _tokenHolder) external view returns (bytes32[] memory partitions);\n\n    /**\n     * @notice Gets data store address\n     * @return data store address\n     */\n    function dataStore() external view returns (address dataStoreAddress);\n\n    /**\n    * @notice Allows owner to change data store\n    * @param _dataStore Address of the token data store\n    */\n    function changeDataStore(address _dataStore) external;\n\n\n    /**\n     * @notice Allows to change the treasury wallet address\n     * @param _wallet Ethereum address of the treasury wallet\n     */\n    function changeTreasuryWallet(address _wallet) external;\n\n    /**\n     * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\n     * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\n     * @param _tokenContract Address of the ERC20Basic compliance token\n     * @param _value Amount of POLY to withdraw\n     */\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\n\n    /**\n    * @notice Allows owner to increase/decrease POLY approval of one of the modules\n    * @param _module Module address\n    * @param _change Change in allowance\n    * @param _increase True if budget has to be increased, false if decrease\n    */\n    function changeModuleBudget(address _module, uint256 _change, bool _increase) external;\n\n    /**\n     * @notice Changes the tokenDetails\n     * @param _newTokenDetails New token details\n     */\n    function updateTokenDetails(string calldata _newTokenDetails) external;\n\n    /**\n    * @notice Allows owner to change token name\n    * @param _name new name of the token\n    */\n    function changeName(string calldata _name) external;\n\n    /**\n    * @notice Allows the owner to change token granularity\n    * @param _granularity Granularity level of the token\n    */\n    function changeGranularity(uint256 _granularity) external;\n\n    /**\n     * @notice Freezes all the transfers\n     */\n    function freezeTransfers() external;\n\n    /**\n     * @notice Un-freezes all the transfers\n     */\n    function unfreezeTransfers() external;\n\n    /**\n     * @notice Permanently freeze issuance of this security token.\n     * @dev It MUST NOT be possible to increase `totalSuppy` after this function is called.\n     */\n    function freezeIssuance(bytes calldata _signature) external;\n\n    /**\n      * @notice Attachs a module to the SecurityToken\n      * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\n      * @dev to control restrictions on transfers.\n      * @param _moduleFactory is the address of the module factory to be added\n      * @param _data is data packed into bytes used to further configure the module (See STO usage)\n      * @param _maxCost max amount of POLY willing to pay to the module.\n      * @param _budget max amount of ongoing POLY willing to assign to the module.\n      * @param _label custom module label.\n      * @param _archived whether to add the module as an archived module\n      */\n    function addModuleWithLabel(\n        address _moduleFactory,\n        bytes calldata _data,\n        uint256 _maxCost,\n        uint256 _budget,\n        bytes32 _label,\n        bool _archived\n    ) external;\n\n    /**\n     * @notice Function used to attach a module to the security token\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\n     * @dev to control restrictions on transfers.\n     * @dev You are allowed to add a new moduleType if:\n     * @dev - there is no existing module of that type yet added\n     * @dev - the last member of the module list is replacable\n     * @param _moduleFactory is the address of the module factory to be added\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\n     * @param _budget max amount of ongoing POLY willing to assign to the module.\n     * @param _archived whether to add the module as an archived module\n     */\n    function addModule(address _moduleFactory, bytes calldata _data, uint256 _maxCost, uint256 _budget, bool _archived) external;\n\n    /**\n    * @notice Archives a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function archiveModule(address _module) external;\n\n    /**\n    * @notice Unarchives a module attached to the SecurityToken\n    * @param _module address of module to unarchive\n    */\n    function unarchiveModule(address _module) external;\n\n    /**\n    * @notice Removes a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function removeModule(address _module) external;\n\n    /**\n     * @notice Used by the issuer to set the controller addresses\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) external;\n\n    /**\n     * @notice This function allows an authorised address to transfer tokens between any two token holders.\n     * The transfer must still respect the balances of the token holders (so the transfer must be for at most\n     * `balanceOf(_from)` tokens) and potentially also need to respect other transfer restrictions.\n     * @dev This function can only be executed by the `controller` address.\n     * @param _from Address The address which you want to send tokens from\n     * @param _to Address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\n     * because use of `_data` parameter is implementation specific).\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\n     */\n    function controllerTransfer(address _from, address _to, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\n\n    /**\n     * @notice This function allows an authorised address to redeem tokens for any token holder.\n     * The redemption must still respect the balances of the token holder (so the redemption must be for at most\n     * `balanceOf(_tokenHolder)` tokens) and potentially also need to respect other transfer restrictions.\n     * @dev This function can only be executed by the `controller` address.\n     * @param _tokenHolder The account whose tokens will be redeemed.\n     * @param _value uint256 the amount of tokens need to be redeemed.\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\n     * because use of `_data` parameter is implementation specific).\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\n     */\n    function controllerRedeem(address _tokenHolder, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\n\n    /**\n     * @notice Used by the issuer to permanently disable controller functionality\n     * @dev enabled via feature switch \"disableControllerAllowed\"\n     */\n    function disableController(bytes calldata _signature) external;\n\n    /**\n     * @notice Used to get the version of the securityToken\n     */\n    function getVersion() external view returns(uint8[] memory version);\n\n    /**\n     * @notice Gets the investor count\n     */\n    function getInvestorCount() external view returns(uint256 investorCount);\n\n    /**\n     * @notice Gets the holder count (investors with non zero balance)\n     */\n    function holderCount() external view returns(uint256 count);\n\n    /**\n      * @notice Overloaded version of the transfer function\n      * @param _to receiver of transfer\n      * @param _value value of transfer\n      * @param _data data to indicate validation\n      * @return bool success\n      */\n    function transferWithData(address _to, uint256 _value, bytes calldata _data) external;\n\n    /**\n      * @notice Overloaded version of the transferFrom function\n      * @param _from sender of transfer\n      * @param _to receiver of transfer\n      * @param _value value of transfer\n      * @param _data data to indicate validation\n      * @return bool success\n      */\n    function transferFromWithData(address _from, address _to, uint256 _value, bytes calldata _data) external;\n\n    /**\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\n     * @param _partition The partition from which to transfer tokens\n     * @param _to The address to which to transfer tokens to\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function transferByPartition(bytes32 _partition, address _to, uint256 _value, bytes calldata _data) external returns (bytes32 partition);\n\n    /**\n     * @notice Get the balance according to the provided partitions\n     * @param _partition Partition which differentiate the tokens.\n     * @param _tokenHolder Whom balance need to queried\n     * @return Amount of tokens as per the given partitions\n     */\n    function balanceOfByPartition(bytes32 _partition, address _tokenHolder) external view returns(uint256 balance);\n\n    /**\n      * @notice Provides the granularity of the token\n      * @return uint256\n      */\n    function granularity() external view returns(uint256 granularityAmount);\n\n    /**\n      * @notice Provides the address of the polymathRegistry\n      * @return address\n      */\n    function polymathRegistry() external view returns(address registryAddress);\n\n    /**\n    * @notice Upgrades a module attached to the SecurityToken\n    * @param _module address of module to archive\n    */\n    function upgradeModule(address _module) external;\n\n    /**\n    * @notice Upgrades security token\n    */\n    function upgradeToken() external;\n\n    /**\n     * @notice A security token issuer can specify that issuance has finished for the token\n     * (i.e. no new tokens can be minted or issued).\n     * @dev If a token returns FALSE for `isIssuable()` then it MUST always return FALSE in the future.\n     * If a token returns FALSE for `isIssuable()` then it MUST never allow additional tokens to be issued.\n     * @return bool `true` signifies the minting is allowed. While `false` denotes the end of minting\n     */\n    function isIssuable() external view returns (bool issuable);\n\n    /**\n     * @notice Authorises an operator for all partitions of `msg.sender`.\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\n     * @param _operator An address which is being authorised.\n     */\n    function authorizeOperator(address _operator) external;\n\n    /**\n     * @notice Revokes authorisation of an operator previously given for all partitions of `msg.sender`.\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\n     * @param _operator An address which is being de-authorised\n     */\n    function revokeOperator(address _operator) external;\n\n    /**\n     * @notice Authorises an operator for a given partition of `msg.sender`\n     * @param _partition The partition to which the operator is authorised\n     * @param _operator An address which is being authorised\n     */\n    function authorizeOperatorByPartition(bytes32 _partition, address _operator) external;\n\n    /**\n     * @notice Revokes authorisation of an operator previously given for a specified partition of `msg.sender`\n     * @param _partition The partition to which the operator is de-authorised\n     * @param _operator An address which is being de-authorised\n     */\n    function revokeOperatorByPartition(bytes32 _partition, address _operator) external;\n\n    /**\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\n     * @param _partition The partition from which to transfer tokens.\n     * @param _from The address from which to transfer tokens from\n     * @param _to The address to which to transfer tokens to\n     * @param _value The amount of tokens to transfer from `_partition`\n     * @param _data Additional data attached to the transfer of tokens\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\n     * @return The partition to which the transferred tokens were allocated for the _to address\n     */\n    function operatorTransferByPartition(\n        bytes32 _partition,\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    )\n        external\n        returns (bytes32 partition);\n\n    /*\n    * @notice Returns if transfers are currently frozen or not\n    */\n    function transfersFrozen() external view returns (bool isFrozen);\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) external;\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() external view returns (bool);\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() external view returns (address ownerAddress);\n\n    function controller() external view returns(address controllerAddress);\n\n    function moduleRegistry() external view returns(address moduleRegistryAddress);\n\n    function securityTokenRegistry() external view returns(address securityTokenRegistryAddress);\n\n    function polyToken() external view returns(address polyTokenAddress);\n\n    function tokenFactory() external view returns(address tokenFactoryAddress);\n\n    function getterDelegate() external view returns(address delegate);\n\n    function controllerDisabled() external view returns(bool isDisabled);\n\n    function initialized() external view returns(bool isInitialized);\n\n    function tokenDetails() external view returns(string memory details);\n\n    function updateFromRegistry() external;\n\n}\n\ninterface ICheckPermission {\n    /**\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n     * @param _delegate address of delegate\n     * @param _module address of PermissionManager module\n     * @param _perm the permissions\n     * @return success\n     */\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPerm);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Storage for Module contract\n * @notice Contract is abstract\n */\ncontract ModuleStorage {\n    address public factory;\n\n    ISecurityToken public securityToken;\n\n    // Permission flag\n    bytes32 public constant ADMIN = \"ADMIN\";\n    bytes32 public constant OPERATOR = \"OPERATOR\";\n\n    bytes32 internal constant TREASURY = 0xaae8817359f3dcb67d050f44f3e49f982e0359d90ca4b5f18569926304aaece6; // keccak256(abi.encodePacked(\"TREASURY_WALLET\"))\n\n    IERC20 public polyToken;\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     * @param _polyAddress Address of the polytoken\n     */\n    constructor(address _securityToken, address _polyAddress) public {\n        securityToken = ISecurityToken(_securityToken);\n        factory = msg.sender;\n        polyToken = IERC20(_polyAddress);\n    }\n\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     * @notice Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @title Interface that any module contract should implement\n * @notice Contract is abstract\n */\ncontract Module is IModule, ModuleStorage, Pausable {\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     */\n    constructor (address _securityToken, address _polyAddress) public\n    ModuleStorage(_securityToken, _polyAddress)\n    {\n    }\n\n    //Allows owner, factory or permissioned delegate\n    modifier withPerm(bytes32 _perm) {\n        require(_checkPerm(_perm, msg.sender), \"Invalid permission\");\n        _;\n    }\n\n    function _checkPerm(bytes32 _perm, address _caller) internal view returns (bool) {\n        bool isOwner = _caller == Ownable(address(securityToken)).owner();\n        bool isFactory = _caller == factory;\n        return isOwner || isFactory || ICheckPermission(address(securityToken)).checkPermission(_caller, address(this), _perm);\n    }\n\n    function _onlySecurityTokenOwner() internal view {\n        require(msg.sender == Ownable(address(securityToken)).owner(), \"Sender is not owner\");\n    }\n\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Sender is not factory\");\n        _;\n    }\n\n    /**\n     * @notice Pause (overridden function)\n     */\n    function pause() public {\n        _onlySecurityTokenOwner();\n        super._pause();\n    }\n\n    /**\n     * @notice Unpause (overridden function)\n     */\n    function unpause() public {\n        _onlySecurityTokenOwner();\n        super._unpause();\n    }\n\n    /**\n     * @notice used to return the data store address of securityToken\n     */\n    function getDataStore() public view returns(IDataStore) {\n        return IDataStore(securityToken.dataStore());\n    }\n\n    /**\n    * @notice Reclaims ERC20Basic compatible tokens\n    * @dev We duplicate here due to the overriden owner & onlyOwner\n    * @param _tokenContract The address of the token contract\n    */\n    function reclaimERC20(address _tokenContract) external {\n        _onlySecurityTokenOwner();\n        require(_tokenContract != address(0), \"Invalid address\");\n        IERC20 token = IERC20(_tokenContract);\n        uint256 balance = token.balanceOf(address(this));\n        require(token.transfer(msg.sender, balance), \"Transfer failed\");\n    }\n\n   /**\n    * @notice Reclaims ETH\n    * @dev We duplicate here due to the overriden owner & onlyOwner\n    */\n    function reclaimETH() external {\n        _onlySecurityTokenOwner();\n        msg.sender.transfer(address(this).balance);\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n/**\n * @title Math\n * @dev Assorted math operations\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Calculates the average of two numbers. Since these are integers,\n     * averages of an even and odd number cannot be represented, and will be\n     * rounded down.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n/**\n * DISCLAIMER: Under certain conditions, the function pushDividendPayment\n * may fail due to block gas limits.\n * If the total number of investors that ever held tokens is greater than ~15,000 then\n * the function may fail. If this happens investors can pull their dividends, or the Issuer\n * can use pushDividendPaymentToAddresses to provide an explict address list in batches\n */\n\n\n\n\n\n\n\n\n/**\n * @title Checkpoint module for issuing ether dividends\n * @dev abstract contract\n */\ncontract DividendCheckpoint is DividendCheckpointStorage, ICheckpoint, Module {\n    using SafeMath for uint256;\n    uint256 internal constant e18 = uint256(10) ** uint256(18);\n\n    event SetDefaultExcludedAddresses(address[] _excluded);\n    event SetWithholding(address[] _investors, uint256[] _withholding);\n    event SetWithholdingFixed(address[] _investors, uint256 _withholding);\n    event SetWallet(address indexed _oldWallet, address indexed _newWallet);\n    event UpdateDividendDates(uint256 indexed _dividendIndex, uint256 _maturity, uint256 _expiry);\n\n    function _validDividendIndex(uint256 _dividendIndex) internal view {\n        require(_dividendIndex < dividends.length, \"Invalid dividend\");\n        require(!dividends[_dividendIndex].reclaimed, \"Dividend reclaimed\");\n        /*solium-disable-next-line security/no-block-members*/\n        require(now >= dividends[_dividendIndex].maturity, \"Dividend maturity in future\");\n        /*solium-disable-next-line security/no-block-members*/\n        require(now < dividends[_dividendIndex].expiry, \"Dividend expiry in past\");\n    }\n\n    /**\n     * @notice Function used to intialize the contract variables\n     * @param _wallet Ethereum account address to receive reclaimed dividends and tax\n     */\n    function configure(\n        address payable _wallet\n    ) public onlyFactory {\n        _setWallet(_wallet);\n    }\n\n    /**\n    * @notice Init function i.e generalise function to maintain the structure of the module contract\n    * @return bytes4\n    */\n    function getInitFunction() public pure returns(bytes4) {\n        return this.configure.selector;\n    }\n\n    /**\n     * @notice Function used to change wallet address\n     * @param _wallet Ethereum account address to receive reclaimed dividends and tax\n     */\n    function changeWallet(address payable _wallet) external {\n        _onlySecurityTokenOwner();\n        _setWallet(_wallet);\n    }\n\n    function _setWallet(address payable _wallet) internal {\n        emit SetWallet(wallet, _wallet);\n        wallet = _wallet;\n    }\n\n    /**\n     * @notice Return the default excluded addresses\n     * @return List of excluded addresses\n     */\n    function getDefaultExcluded() external view returns(address[] memory) {\n        return excluded;\n    }\n\n    /**\n     * @notice Returns the treasury wallet address\n     */\n    function getTreasuryWallet() public view returns(address payable) {\n        if (wallet == address(0)) {\n            address payable treasuryWallet = address(uint160(IDataStore(getDataStore()).getAddress(TREASURY)));\n            require(address(treasuryWallet) != address(0), \"Invalid address\");\n            return treasuryWallet;\n        }\n        else\n            return wallet;\n    }\n\n    /**\n     * @notice Creates a checkpoint on the security token\n     * @return Checkpoint ID\n     */\n    function createCheckpoint() public withPerm(OPERATOR) returns(uint256) {\n        return securityToken.createCheckpoint();\n    }\n\n    /**\n     * @notice Function to clear and set list of excluded addresses used for future dividends\n     * @param _excluded Addresses of investors\n     */\n    function setDefaultExcluded(address[] memory _excluded) public withPerm(ADMIN) {\n        require(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, \"Too many excluded addresses\");\n        for (uint256 j = 0; j < _excluded.length; j++) {\n            require(_excluded[j] != address(0), \"Invalid address\");\n            for (uint256 i = j + 1; i < _excluded.length; i++) {\n                require(_excluded[j] != _excluded[i], \"Duplicate exclude address\");\n            }\n        }\n        excluded = _excluded;\n        /*solium-disable-next-line security/no-block-members*/\n        emit SetDefaultExcludedAddresses(excluded);\n    }\n\n    /**\n     * @notice Function to set withholding tax rates for investors\n     * @param _investors Addresses of investors\n     * @param _withholding Withholding tax for individual investors (multiplied by 10**16)\n     */\n    function setWithholding(address[] memory _investors, uint256[] memory _withholding) public withPerm(ADMIN) {\n        require(_investors.length == _withholding.length, \"Mismatched input lengths\");\n        /*solium-disable-next-line security/no-block-members*/\n        emit SetWithholding(_investors, _withholding);\n        for (uint256 i = 0; i < _investors.length; i++) {\n            require(_withholding[i] <= e18, \"Incorrect withholding tax\");\n            withholdingTax[_investors[i]] = _withholding[i];\n        }\n    }\n\n    /**\n     * @notice Function to set withholding tax rates for investors\n     * @param _investors Addresses of investor\n     * @param _withholding Withholding tax for all investors (multiplied by 10**16)\n     */\n    function setWithholdingFixed(address[] memory _investors, uint256 _withholding) public withPerm(ADMIN) {\n        require(_withholding <= e18, \"Incorrect withholding tax\");\n        /*solium-disable-next-line security/no-block-members*/\n        emit SetWithholdingFixed(_investors, _withholding);\n        for (uint256 i = 0; i < _investors.length; i++) {\n            withholdingTax[_investors[i]] = _withholding;\n        }\n    }\n\n    /**\n     * @notice Issuer can push dividends to provided addresses\n     * @param _dividendIndex Dividend to push\n     * @param _payees Addresses to which to push the dividend\n     */\n    function pushDividendPaymentToAddresses(\n        uint256 _dividendIndex,\n        address payable[] memory _payees\n    )\n        public\n        withPerm(OPERATOR)\n    {\n        _validDividendIndex(_dividendIndex);\n        Dividend storage dividend = dividends[_dividendIndex];\n        for (uint256 i = 0; i < _payees.length; i++) {\n            if ((!dividend.claimed[_payees[i]]) && (!dividend.dividendExcluded[_payees[i]])) {\n                _payDividend(_payees[i], dividend, _dividendIndex);\n            }\n        }\n    }\n\n    /**\n     * @notice Issuer can push dividends using the investor list from the security token\n     * @param _dividendIndex Dividend to push\n     * @param _start Index in investor list at which to start pushing dividends\n     * @param _end Index in investor list at which to stop pushing dividends\n     */\n    function pushDividendPayment(\n        uint256 _dividendIndex,\n        uint256 _start,\n        uint256 _end\n    )\n        public\n        withPerm(OPERATOR)\n    {\n        //NB If possible, please use pushDividendPaymentToAddresses as it is cheaper than this function\n        _validDividendIndex(_dividendIndex);\n        Dividend storage dividend = dividends[_dividendIndex];\n        uint256 checkpointId = dividend.checkpointId;\n        address[] memory investors = securityToken.getInvestorsSubsetAt(checkpointId, _start, _end);\n        // The investors list maybe smaller than _end - _start becuase it only contains addresses that had a positive balance\n        // the _start and _end used here are for the address list stored in the dataStore\n        for (uint256 i = 0; i < investors.length; i++) {\n            address payable payee = address(uint160(investors[i]));\n            if ((!dividend.claimed[payee]) && (!dividend.dividendExcluded[payee])) {\n                _payDividend(payee, dividend, _dividendIndex);\n            }\n        }\n    }\n\n    /**\n     * @notice Investors can pull their own dividends\n     * @param _dividendIndex Dividend to pull\n     */\n    function pullDividendPayment(uint256 _dividendIndex) public whenNotPaused {\n        _validDividendIndex(_dividendIndex);\n        Dividend storage dividend = dividends[_dividendIndex];\n        require(!dividend.claimed[msg.sender], \"Dividend already claimed\");\n        require(!dividend.dividendExcluded[msg.sender], \"msg.sender excluded from Dividend\");\n        _payDividend(msg.sender, dividend, _dividendIndex);\n    }\n\n    /**\n     * @notice Internal function for paying dividends\n     * @param _payee Address of investor\n     * @param _dividend Storage with previously issued dividends\n     * @param _dividendIndex Dividend to pay\n     */\n    function _payDividend(address payable _payee, Dividend storage _dividend, uint256 _dividendIndex) internal;\n\n    /**\n     * @notice Issuer can reclaim remaining unclaimed dividend amounts, for expired dividends\n     * @param _dividendIndex Dividend to reclaim\n     */\n    function reclaimDividend(uint256 _dividendIndex) external;\n\n    /**\n     * @notice Calculate amount of dividends claimable\n     * @param _dividendIndex Dividend to calculate\n     * @param _payee Affected investor address\n     * @return claim, withheld amounts\n     */\n    function calculateDividend(uint256 _dividendIndex, address _payee) public view returns(uint256, uint256) {\n        require(_dividendIndex < dividends.length, \"Invalid dividend\");\n        Dividend storage dividend = dividends[_dividendIndex];\n        if (dividend.claimed[_payee] || dividend.dividendExcluded[_payee]) {\n            return (0, 0);\n        }\n        uint256 balance = securityToken.balanceOfAt(_payee, dividend.checkpointId);\n        uint256 claim = balance.mul(dividend.amount).div(dividend.totalSupply);\n        uint256 withheld = claim.mul(withholdingTax[_payee]).div(e18);\n        return (claim, withheld);\n    }\n\n    /**\n     * @notice Get the index according to the checkpoint id\n     * @param _checkpointId Checkpoint id to query\n     * @return uint256[]\n     */\n    function getDividendIndex(uint256 _checkpointId) public view returns(uint256[] memory) {\n        uint256 counter = 0;\n        for (uint256 i = 0; i < dividends.length; i++) {\n            if (dividends[i].checkpointId == _checkpointId) {\n                counter++;\n            }\n        }\n\n        uint256[] memory index = new uint256[](counter);\n        counter = 0;\n        for (uint256 j = 0; j < dividends.length; j++) {\n            if (dividends[j].checkpointId == _checkpointId) {\n                index[counter] = j;\n                counter++;\n            }\n        }\n        return index;\n    }\n\n    /**\n     * @notice Allows issuer to withdraw withheld tax\n     * @param _dividendIndex Dividend to withdraw from\n     */\n    function withdrawWithholding(uint256 _dividendIndex) external;\n\n    /**\n     * @notice Allows issuer to change maturity / expiry dates for dividends\n     * @dev NB - setting the maturity of a currently matured dividend to a future date\n     * @dev will effectively refreeze claims on that dividend until the new maturity date passes\n     * @ dev NB - setting the expiry date to a past date will mean no more payments can be pulled\n     * @dev or pushed out of a dividend\n     * @param _dividendIndex Dividend to withdraw from\n     * @param _maturity updated maturity date\n     * @param _expiry updated expiry date\n     */\n    function updateDividendDates(uint256 _dividendIndex, uint256 _maturity, uint256 _expiry) external withPerm(ADMIN) {\n        require(_dividendIndex < dividends.length, \"Invalid dividend\");\n        require(_expiry > _maturity, \"Expiry before maturity\");\n        Dividend storage dividend = dividends[_dividendIndex];\n        require(dividend.expiry > now, \"Dividend already expired\");\n        dividend.expiry = _expiry;\n        dividend.maturity = _maturity;\n        emit UpdateDividendDates(_dividendIndex, _maturity, _expiry);\n    }\n\n    /**\n     * @notice Get static dividend data\n     * @return uint256[] timestamp of dividends creation\n     * @return uint256[] timestamp of dividends maturity\n     * @return uint256[] timestamp of dividends expiry\n     * @return uint256[] amount of dividends\n     * @return uint256[] claimed amount of dividends\n     * @return bytes32[] name of dividends\n     */\n    function getDividendsData() external view returns (\n        uint256[] memory createds,\n        uint256[] memory maturitys,\n        uint256[] memory expirys,\n        uint256[] memory amounts,\n        uint256[] memory claimedAmounts,\n        bytes32[] memory names)\n    {\n        createds = new uint256[](dividends.length);\n        maturitys = new uint256[](dividends.length);\n        expirys = new uint256[](dividends.length);\n        amounts = new uint256[](dividends.length);\n        claimedAmounts = new uint256[](dividends.length);\n        names = new bytes32[](dividends.length);\n        for (uint256 i = 0; i < dividends.length; i++) {\n            (createds[i], maturitys[i], expirys[i], amounts[i], claimedAmounts[i], names[i]) = getDividendData(i);\n        }\n    }\n\n    /**\n     * @notice Get static dividend data\n     * @return uint256 timestamp of dividend creation\n     * @return uint256 timestamp of dividend maturity\n     * @return uint256 timestamp of dividend expiry\n     * @return uint256 amount of dividend\n     * @return uint256 claimed amount of dividend\n     * @return bytes32 name of dividend\n     */\n    function getDividendData(uint256 _dividendIndex) public view returns (\n        uint256 created,\n        uint256 maturity,\n        uint256 expiry,\n        uint256 amount,\n        uint256 claimedAmount,\n        bytes32 name)\n    {\n        created = dividends[_dividendIndex].created;\n        maturity = dividends[_dividendIndex].maturity;\n        expiry = dividends[_dividendIndex].expiry;\n        amount = dividends[_dividendIndex].amount;\n        claimedAmount = dividends[_dividendIndex].claimedAmount;\n        name = dividends[_dividendIndex].name;\n    }\n\n    /**\n     * @notice Retrieves list of investors, their claim status and whether they are excluded\n     * @param _dividendIndex Dividend to withdraw from\n     * @return address[] list of investors\n     * @return bool[] whether investor has claimed\n     * @return bool[] whether investor is excluded\n     * @return uint256[] amount of withheld tax (estimate if not claimed)\n     * @return uint256[] amount of claim (estimate if not claimeed)\n     * @return uint256[] investor balance\n     */\n    function getDividendProgress(uint256 _dividendIndex) external view returns (\n        address[] memory investors,\n        bool[] memory resultClaimed,\n        bool[] memory resultExcluded,\n        uint256[] memory resultWithheld,\n        uint256[] memory resultAmount,\n        uint256[] memory resultBalance)\n    {\n        require(_dividendIndex < dividends.length, \"Invalid dividend\");\n        //Get list of Investors\n        Dividend storage dividend = dividends[_dividendIndex];\n        uint256 checkpointId = dividend.checkpointId;\n        investors = securityToken.getInvestorsAt(checkpointId);\n        resultClaimed = new bool[](investors.length);\n        resultExcluded = new bool[](investors.length);\n        resultWithheld = new uint256[](investors.length);\n        resultAmount = new uint256[](investors.length);\n        resultBalance = new uint256[](investors.length);\n        for (uint256 i; i < investors.length; i++) {\n            resultClaimed[i] = dividend.claimed[investors[i]];\n            resultExcluded[i] = dividend.dividendExcluded[investors[i]];\n            resultBalance[i] = securityToken.balanceOfAt(investors[i], dividend.checkpointId);\n            if (!resultExcluded[i]) {\n                if (resultClaimed[i]) {\n                    resultWithheld[i] = dividend.withheld[investors[i]];\n                    resultAmount[i] = resultBalance[i].mul(dividend.amount).div(dividend.totalSupply).sub(resultWithheld[i]);\n                } else {\n                    (uint256 claim, uint256 withheld) = calculateDividend(_dividendIndex, investors[i]);\n                    resultWithheld[i] = withheld;\n                    resultAmount[i] = claim.sub(withheld);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Retrieves list of investors, their balances, and their current withholding tax percentage\n     * @param _checkpointId Checkpoint Id to query for\n     * @return address[] list of investors\n     * @return uint256[] investor balances\n     * @return uint256[] investor withheld percentages\n     */\n    function getCheckpointData(uint256 _checkpointId) external view returns (address[] memory investors, uint256[] memory balances, uint256[] memory withholdings) {\n        require(_checkpointId <= securityToken.currentCheckpointId(), \"Invalid checkpoint\");\n        investors = securityToken.getInvestorsAt(_checkpointId);\n        balances = new uint256[](investors.length);\n        withholdings = new uint256[](investors.length);\n        for (uint256 i; i < investors.length; i++) {\n            balances[i] = securityToken.balanceOfAt(investors[i], _checkpointId);\n            withholdings[i] = withholdingTax[investors[i]];\n        }\n    }\n\n    /**\n     * @notice Checks whether an address is excluded from claiming a dividend\n     * @param _dividendIndex Dividend to withdraw from\n     * @return bool whether the address is excluded\n     */\n    function isExcluded(address _investor, uint256 _dividendIndex) external view returns (bool) {\n        require(_dividendIndex < dividends.length, \"Invalid dividend\");\n        return dividends[_dividendIndex].dividendExcluded[_investor];\n    }\n\n    /**\n     * @notice Checks whether an address has claimed a dividend\n     * @param _dividendIndex Dividend to withdraw from\n     * @return bool whether the address has claimed\n     */\n    function isClaimed(address _investor, uint256 _dividendIndex) external view returns (bool) {\n        require(_dividendIndex < dividends.length, \"Invalid dividend\");\n        return dividends[_dividendIndex].claimed[_investor];\n    }\n\n    /**\n     * @notice Return the permissions flag that are associated with this module\n     * @return bytes32 array\n     */\n    function getPermissions() public view returns(bytes32[] memory) {\n        bytes32[] memory allPermissions = new bytes32[](2);\n        allPermissions[0] = ADMIN;\n        allPermissions[1] = OPERATOR;\n        return allPermissions;\n    }\n\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ninterface IOwnable {\n    /**\n    * @dev Returns owner\n    */\n    function owner() external view returns(address ownerAddress);\n\n    /**\n    * @dev Allows the current owner to relinquish control of the contract.\n    */\n    function renounceOwnership() external;\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address _newOwner) external;\n\n}\n\n/**\n * @title Checkpoint module for issuing ether dividends\n */\ncontract EtherDividendCheckpoint is DividendCheckpoint {\n    using SafeMath for uint256;\n\n    event EtherDividendDeposited(\n        address indexed _depositor,\n        uint256 _checkpointId,\n        uint256 _maturity,\n        uint256 _expiry,\n        uint256 _amount,\n        uint256 _totalSupply,\n        uint256 indexed _dividendIndex,\n        bytes32 indexed _name\n    );\n    event EtherDividendClaimed(address indexed _payee, uint256 indexed _dividendIndex, uint256 _amount, uint256 _withheld);\n    event EtherDividendReclaimed(address indexed _claimer, uint256 indexed _dividendIndex, uint256 _claimedAmount);\n    event EtherDividendClaimFailed(address indexed _payee, uint256 indexed _dividendIndex, uint256 _amount, uint256 _withheld);\n    event EtherDividendWithholdingWithdrawn(address indexed _claimer, uint256 indexed _dividendIndex, uint256 _withheldAmount);\n\n    /**\n     * @notice Constructor\n     * @param _securityToken Address of the security token\n     */\n    constructor(address _securityToken, address _polyToken) public Module(_securityToken, _polyToken) {\n\n    }\n\n    /**\n     * @notice Creates a dividend and checkpoint for the dividend, using global list of excluded addresses\n     * @param _maturity Time from which dividend can be paid\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\n     * @param _name Name/title for identification\n     */\n    function createDividend(uint256 _maturity, uint256 _expiry, bytes32 _name) external payable withPerm(ADMIN) {\n        createDividendWithExclusions(_maturity, _expiry, excluded, _name);\n    }\n\n    /**\n     * @notice Creates a dividend with a provided checkpoint, using global list of excluded addresses\n     * @param _maturity Time from which dividend can be paid\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\n     * @param _checkpointId Id of the checkpoint from which to issue dividend\n     * @param _name Name/title for identification\n     */\n    function createDividendWithCheckpoint(\n        uint256 _maturity,\n        uint256 _expiry,\n        uint256 _checkpointId,\n        bytes32 _name\n    )\n        external\n        payable\n        withPerm(ADMIN)\n    {\n        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _checkpointId, excluded, _name);\n    }\n\n    /**\n     * @notice Creates a dividend and checkpoint for the dividend, specifying explicit excluded addresses\n     * @param _maturity Time from which dividend can be paid\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\n     * @param _excluded List of addresses to exclude\n     * @param _name Name/title for identification\n     */\n    function createDividendWithExclusions(\n        uint256 _maturity,\n        uint256 _expiry,\n        address[] memory _excluded,\n        bytes32 _name\n    )\n        public\n        payable\n        withPerm(ADMIN)\n    {\n        uint256 checkpointId = securityToken.createCheckpoint();\n        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, checkpointId, _excluded, _name);\n    }\n\n    /**\n     * @notice Creates a dividend with a provided checkpoint, specifying explicit excluded addresses\n     * @param _maturity Time from which dividend can be paid\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\n     * @param _checkpointId Id of the checkpoint from which to issue dividend\n     * @param _excluded List of addresses to exclude\n     * @param _name Name/title for identification\n     */\n    function createDividendWithCheckpointAndExclusions(\n        uint256 _maturity,\n        uint256 _expiry,\n        uint256 _checkpointId,\n        address[] memory _excluded,\n        bytes32 _name\n    )\n        public\n        payable\n        withPerm(ADMIN)\n    {\n        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, _checkpointId, _excluded, _name);\n    }\n\n    /**\n     * @notice Creates a dividend with a provided checkpoint, specifying explicit excluded addresses\n     * @param _maturity Time from which dividend can be paid\n     * @param _expiry Time until dividend can no longer be paid, and can be reclaimed by issuer\n     * @param _checkpointId Id of the checkpoint from which to issue dividend\n     * @param _excluded List of addresses to exclude\n     * @param _name Name/title for identification\n     */\n    function _createDividendWithCheckpointAndExclusions(\n        uint256 _maturity,\n        uint256 _expiry,\n        uint256 _checkpointId,\n        address[] memory _excluded,\n        bytes32 _name\n    )\n        internal\n    {\n        require(_excluded.length <= EXCLUDED_ADDRESS_LIMIT, \"Too many addresses excluded\");\n        require(_expiry > _maturity, \"Expiry is before maturity\");\n        /*solium-disable-next-line security/no-block-members*/\n        require(_expiry > now, \"Expiry is in the past\");\n        require(msg.value > 0, \"No dividend sent\");\n        require(_checkpointId <= securityToken.currentCheckpointId());\n        require(_name[0] != bytes32(0));\n        uint256 dividendIndex = dividends.length;\n        uint256 currentSupply = securityToken.totalSupplyAt(_checkpointId);\n        require(currentSupply > 0, \"Invalid supply\");\n        uint256 excludedSupply = 0;\n        dividends.push(\n            Dividend(\n                _checkpointId,\n                now, /*solium-disable-line security/no-block-members*/\n                _maturity,\n                _expiry,\n                msg.value,\n                0,\n                0,\n                false,\n                0,\n                0,\n                _name\n            )\n        );\n\n        for (uint256 j = 0; j < _excluded.length; j++) {\n            require(_excluded[j] != address(0), \"Invalid address\");\n            require(!dividends[dividendIndex].dividendExcluded[_excluded[j]], \"duped exclude address\");\n            excludedSupply = excludedSupply.add(securityToken.balanceOfAt(_excluded[j], _checkpointId));\n            dividends[dividendIndex].dividendExcluded[_excluded[j]] = true;\n        }\n        require(currentSupply > excludedSupply, \"Invalid supply\");\n        dividends[dividendIndex].totalSupply = currentSupply - excludedSupply;\n        /*solium-disable-next-line security/no-block-members*/\n        emit EtherDividendDeposited(msg.sender, _checkpointId, _maturity, _expiry, msg.value, currentSupply, dividendIndex, _name);\n    }\n\n    /**\n     * @notice Internal function for paying dividends\n     * @param _payee address of investor\n     * @param _dividend storage with previously issued dividends\n     * @param _dividendIndex Dividend to pay\n     */\n    function _payDividend(address payable _payee, Dividend storage _dividend, uint256 _dividendIndex) internal {\n        (uint256 claim, uint256 withheld) = calculateDividend(_dividendIndex, _payee);\n        _dividend.claimed[_payee] = true;\n        uint256 claimAfterWithheld = claim.sub(withheld);\n        /*solium-disable-next-line security/no-send*/\n        if (_payee.send(claimAfterWithheld)) {\n            _dividend.claimedAmount = _dividend.claimedAmount.add(claim);\n            if (withheld > 0) {\n                _dividend.totalWithheld = _dividend.totalWithheld.add(withheld);\n                _dividend.withheld[_payee] = withheld;\n            }\n            emit EtherDividendClaimed(_payee, _dividendIndex, claim, withheld);\n        } else {\n            _dividend.claimed[_payee] = false;\n            emit EtherDividendClaimFailed(_payee, _dividendIndex, claim, withheld);\n        }\n    }\n\n    /**\n     * @notice Issuer can reclaim remaining unclaimed dividend amounts, for expired dividends\n     * @param _dividendIndex Dividend to reclaim\n     */\n    function reclaimDividend(uint256 _dividendIndex) external withPerm(OPERATOR) {\n        require(_dividendIndex < dividends.length, \"Incorrect dividend index\");\n        /*solium-disable-next-line security/no-block-members*/\n        require(now >= dividends[_dividendIndex].expiry, \"Dividend expiry is in the future\");\n        require(!dividends[_dividendIndex].reclaimed, \"Dividend is already claimed\");\n        Dividend storage dividend = dividends[_dividendIndex];\n        dividend.reclaimed = true;\n        uint256 remainingAmount = dividend.amount.sub(dividend.claimedAmount);\n        address payable wallet = getTreasuryWallet();\n        wallet.transfer(remainingAmount);\n        emit EtherDividendReclaimed(wallet, _dividendIndex, remainingAmount);\n    }\n\n    /**\n     * @notice Allows issuer to withdraw withheld tax\n     * @param _dividendIndex Dividend to withdraw from\n     */\n    function withdrawWithholding(uint256 _dividendIndex) external withPerm(OPERATOR) {\n        require(_dividendIndex < dividends.length, \"Incorrect dividend index\");\n        Dividend storage dividend = dividends[_dividendIndex];\n        uint256 remainingWithheld = dividend.totalWithheld.sub(dividend.totalWithheldWithdrawn);\n        dividend.totalWithheldWithdrawn = dividend.totalWithheld;\n        address payable wallet = getTreasuryWallet();\n        wallet.transfer(remainingWithheld);\n        emit EtherDividendWithholdingWithdrawn(wallet, _dividendIndex, remainingWithheld);\n    }\n\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"},{\"name\":\"_withholding\",\"type\":\"uint256\"}],\"name\":\"setWithholdingFixed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EXCLUDED_ADDRESS_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitFunction\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_dividendIndex\",\"type\":\"uint256\"}],\"name\":\"getDividendData\",\"outputs\":[{\"name\":\"created\",\"type\":\"uint256\"},{\"name\":\"maturity\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"claimedAmount\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTreasuryWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dividendIndex\",\"type\":\"uint256\"}],\"name\":\"pullDividendPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dividendIndex\",\"type\":\"uint256\"}],\"name\":\"withdrawWithholding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investorWithheld\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dividendIndex\",\"type\":\"uint256\"},{\"name\":\"_payees\",\"type\":\"address[]\"}],\"name\":\"pushDividendPaymentToAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_dividendIndex\",\"type\":\"uint256\"}],\"name\":\"isClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_dividendIndex\",\"type\":\"uint256\"},{\"name\":\"_payee\",\"type\":\"address\"}],\"name\":\"calculateDividend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_checkpointId\",\"type\":\"uint256\"}],\"name\":\"getDividendIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"polyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dividendIndex\",\"type\":\"uint256\"},{\"name\":\"_maturity\",\"type\":\"uint256\"},{\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"updateDividendDates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"configure\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withholdingTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_checkpointId\",\"type\":\"uint256\"}],\"name\":\"getCheckpointData\",\"outputs\":[{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"balances\",\"type\":\"uint256[]\"},{\"name\":\"withholdings\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dividends\",\"outputs\":[{\"name\":\"checkpointId\",\"type\":\"uint256\"},{\"name\":\"created\",\"type\":\"uint256\"},{\"name\":\"maturity\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"claimedAmount\",\"type\":\"uint256\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"reclaimed\",\"type\":\"bool\"},{\"name\":\"totalWithheld\",\"type\":\"uint256\"},{\"name\":\"totalWithheldWithdrawn\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_dividendIndex\",\"type\":\"uint256\"}],\"name\":\"isExcluded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"},{\"name\":\"_withholding\",\"type\":\"uint256[]\"}],\"name\":\"setWithholding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"reclaimERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OPERATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"changeWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dividendIndex\",\"type\":\"uint256\"}],\"name\":\"reclaimDividend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDividendsData\",\"outputs\":[{\"name\":\"createds\",\"type\":\"uint256[]\"},{\"name\":\"maturitys\",\"type\":\"uint256[]\"},{\"name\":\"expirys\",\"type\":\"uint256[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"claimedAmounts\",\"type\":\"uint256[]\"},{\"name\":\"names\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"securityToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maturity\",\"type\":\"uint256\"},{\"name\":\"_expiry\",\"type\":\"uint256\"},{\"name\":\"_checkpointId\",\"type\":\"uint256\"},{\"name\":\"_excluded\",\"type\":\"address[]\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"createDividendWithCheckpointAndExclusions\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"excluded\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPermissions\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_excluded\",\"type\":\"address[]\"}],\"name\":\"setDefaultExcluded\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maturity\",\"type\":\"uint256\"},{\"name\":\"_expiry\",\"type\":\"uint256\"},{\"name\":\"_checkpointId\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"createDividendWithCheckpoint\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dividendIndex\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"pushDividendPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultExcluded\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maturity\",\"type\":\"uint256\"},{\"name\":\"_expiry\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"createDividend\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maturity\",\"type\":\"uint256\"},{\"name\":\"_expiry\",\"type\":\"uint256\"},{\"name\":\"_excluded\",\"type\":\"address[]\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"createDividendWithExclusions\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_dividendIndex\",\"type\":\"uint256\"}],\"name\":\"getDividendProgress\",\"outputs\":[{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"resultClaimed\",\"type\":\"bool[]\"},{\"name\":\"resultExcluded\",\"type\":\"bool[]\"},{\"name\":\"resultWithheld\",\"type\":\"uint256[]\"},{\"name\":\"resultAmount\",\"type\":\"uint256[]\"},{\"name\":\"resultBalance\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDataStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createCheckpoint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_securityToken\",\"type\":\"address\"},{\"name\":\"_polyToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_checkpointId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_expiry\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_dividendIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"EtherDividendDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_payee\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_dividendIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_withheld\",\"type\":\"uint256\"}],\"name\":\"EtherDividendClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_claimer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_dividendIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_claimedAmount\",\"type\":\"uint256\"}],\"name\":\"EtherDividendReclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_payee\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_dividendIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_withheld\",\"type\":\"uint256\"}],\"name\":\"EtherDividendClaimFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_claimer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_dividendIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_withheldAmount\",\"type\":\"uint256\"}],\"name\":\"EtherDividendWithholdingWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_excluded\",\"type\":\"address[]\"}],\"name\":\"SetDefaultExcludedAddresses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_investors\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"_withholding\",\"type\":\"uint256[]\"}],\"name\":\"SetWithholding\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_investors\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"_withholding\",\"type\":\"uint256\"}],\"name\":\"SetWithholdingFixed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_oldWallet\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"SetWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_dividendIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"UpdateDividendDates\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"EtherDividendCheckpoint","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://224c07420b1a9606109af0b36437eeb86393f9c1ca92b04932022fca62a7dbe8"}]}