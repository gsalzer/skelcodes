{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.9;\r\n\r\n// File: contracts/FrozenToken.sol\r\n\r\n/**\r\n * Source Code first verified at https://etherscan.io on Wednesday, October 11, 2017\r\n (UTC) */\r\n\r\n//! FrozenToken ECR20-compliant token contract\r\n//! By Parity Technologies, 2017.\r\n//! Released under the Apache Licence 2.\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// Owned contract.\r\ncontract Owned {\r\n\tmodifier only_owner { require (msg.sender == owner, \"Only owner\"); _; }\r\n\r\n\tevent NewOwner(address indexed old, address indexed current);\r\n\r\n\tfunction setOwner(address _new) public only_owner { emit NewOwner(owner, _new); owner = _new; }\r\n\r\n\taddress public owner;\r\n}\r\n\r\n// FrozenToken, a bit like an ECR20 token (though not - as it doesn't\r\n// implement most of the API).\r\n// All token balances are generally non-transferable.\r\n// All \"tokens\" belong to the owner (who is uniquely liquid) at construction.\r\n// Liquid accounts can make other accounts liquid and send their tokens\r\n// to other axccounts.\r\ncontract FrozenToken is Owned {\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t// this is as basic as can be, only the associated balance & allowances\r\n\tstruct Account {\r\n\t\tuint balance;\r\n\t\tbool liquid;\r\n\t}\r\n\r\n\t// constructor sets the parameters of execution, _totalSupply is all units\r\n\tconstructor(uint _totalSupply, address _owner)\r\n        public\r\n\t\twhen_non_zero(_totalSupply)\r\n\t{\r\n\t\ttotalSupply = _totalSupply;\r\n\t\towner = _owner;\r\n\t\taccounts[_owner].balance = totalSupply;\r\n\t\taccounts[_owner].liquid = true;\r\n\t}\r\n\r\n\t// balance of a specific address\r\n\tfunction balanceOf(address _who) public view returns (uint256) {\r\n\t\treturn accounts[_who].balance;\r\n\t}\r\n\r\n\t// make an account liquid: only liquid accounts can do this.\r\n\tfunction makeLiquid(address _to)\r\n\t\tpublic\r\n\t\twhen_liquid(msg.sender)\r\n\t\treturns(bool)\r\n\t{\r\n\t\taccounts[_to].liquid = true;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// transfer\r\n\tfunction transfer(address _to, uint256 _value)\r\n\t\tpublic\r\n\t\twhen_owns(msg.sender, _value)\r\n\t\twhen_liquid(msg.sender)\r\n\t\treturns(bool)\r\n\t{\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\taccounts[msg.sender].balance -= _value;\r\n\t\taccounts[_to].balance += _value;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// no default function, simple contract only, entry-level users\r\n\tfunction() external {\r\n\t\tassert(false);\r\n\t}\r\n\r\n\t// the balance should be available\r\n\tmodifier when_owns(address _owner, uint _amount) {\r\n\t\trequire (accounts[_owner].balance >= _amount);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier when_liquid(address who) {\r\n\t\trequire (accounts[who].liquid);\r\n\t\t_;\r\n\t}\r\n\r\n\t// a value should be > 0\r\n\tmodifier when_non_zero(uint _value) {\r\n\t\trequire (_value > 0);\r\n\t\t_;\r\n\t}\r\n\r\n\t// Available token supply\r\n\tuint public totalSupply;\r\n\r\n\t// Storage and mapping of all balances & allowances\r\n\tmapping (address => Account) accounts;\r\n\r\n\t// Conventional metadata.\r\n\tstring public constant name = \"DOT Allocation Indicator\";\r\n\tstring public constant symbol = \"DOT\";\r\n\tuint8 public constant decimals = 3;\r\n}\r\n\r\n// File: contracts/Claims.sol\r\n\r\n/// @author Web3 Foundation\r\n/// @title  Claims\r\n///         Allows allocations to be claimed to Polkadot public keys.\r\ncontract Claims is Owned {\r\n\r\n    struct Claim {\r\n        uint    index;          // Index for short address.\r\n        bytes32 pubKey;         // Ed25519/SR25519 public key.\r\n        bool    hasIndex;       // Has the index been set?\r\n        uint    vested;         // Amount of allocation that is vested.\r\n    }\r\n\r\n    // The address of the allocation indicator contract.\r\n    FrozenToken public allocationIndicator; // 0xb59f67A8BfF5d8Cd03f6AC17265c550Ed8F33907\r\n\r\n    // The next index to be assigned.\r\n    uint public nextIndex;\r\n\r\n    // Maps allocations to `Claim` data.\r\n    mapping (address => Claim) public claims;\r\n\r\n    // Addresses that already claimed so we can easily grab them from state.\r\n    address[] public claimed;\r\n\r\n    // Amended keys, old address => new address. New address is allowed to claim for old address.\r\n    mapping (address => address) public amended;\r\n\r\n    // Event for when an allocation address amendment is made.\r\n    event Amended(address indexed original, address indexed amendedTo);\r\n    // Event for when an allocation is claimed to a Polkadot address.\r\n    event Claimed(address indexed eth, bytes32 indexed dot, uint indexed idx);\r\n    // Event for when an index is assigned to an allocation.\r\n    event IndexAssigned(address indexed eth, uint indexed idx);\r\n    // Event for when vesting is set on an allocation.\r\n    event Vested(address indexed eth, uint amount);\r\n\r\n    constructor(address _owner, address _allocations) public {\r\n        require(_owner != address(0x0), \"Must provide an owner address\");\r\n        require(_allocations != address(0x0), \"Must provide an allocations address\");\r\n\r\n        owner = _owner;\r\n        allocationIndicator = FrozenToken(_allocations);\r\n    }\r\n\r\n    /// Allows owner to manually amend allocations to a new address that can claim.\r\n    /// @dev The given arrays must be same length and index must map directly.\r\n    /// @param _origs An array of original (allocation) addresses.\r\n    /// @param _amends An array of the new addresses which can claim those allocations.\r\n    function amend(address[] calldata _origs, address[] calldata _amends)\r\n        external\r\n        only_owner\r\n    {\r\n        require(\r\n            _origs.length == _amends.length,\r\n            \"Must submit arrays of equal length.\"\r\n        );\r\n\r\n        for (uint i = 0; i < _amends.length; i++) {\r\n            require(!hasClaimed(_origs[i]), \"Address has already claimed\");\r\n            amended[_origs[i]] = _amends[i];\r\n            emit Amended(_origs[i], _amends[i]);\r\n        }\r\n    }\r\n\r\n    /// Allows owner to manually toggle vesting onto allocations.\r\n    /// @param _eths The addresses for which to set vesting.\r\n    /// @param _vestingAmts The amounts that the accounts are vested.\r\n    function setVesting(address[] calldata _eths, uint[] calldata _vestingAmts)\r\n        external\r\n        only_owner\r\n    {\r\n        require(_eths.length == _vestingAmts.length, \"Must submit arrays of equal length\");\r\n\r\n        for (uint i = 0; i < _eths.length; i++) {\r\n            Claim storage claimData = claims[_eths[i]];\r\n            require(!hasClaimed(_eths[i]), \"Account must not be claimed\");\r\n            require(claimData.vested == 0, \"Account must not be vested already\");\r\n            require(_vestingAmts[i] != 0, \"Vesting amount must be greater than zero\");\r\n            claimData.vested = _vestingAmts[i];\r\n            emit Vested(_eths[i], _vestingAmts[i]);\r\n        }\r\n    }\r\n\r\n    /// Allows anyone to assign a batch of indices onto unassigned and unclaimed allocations.\r\n    /// @dev This function is safe because all the necessary checks are made on `assignNextIndex`.\r\n    /// @param _eths An array of allâ‚¬ocation addresses to assign indices for.\r\n    /// @return bool True is successful.\r\n    function assignIndices(address[] calldata _eths)\r\n        external\r\n    {\r\n        for (uint i = 0; i < _eths.length; i++) {\r\n            require(assignNextIndex(_eths[i]), \"Assigning the next index failed\");\r\n        }\r\n    }\r\n\r\n    /// Claims an allocation associated with an `_eth` address to a `_pubKey` public key.\r\n    /// @dev Can only be called by the `_eth` address or the amended address for the allocation.\r\n    /// @param _eth The allocation address to claim.\r\n    /// @param _pubKey The Polkadot public key to claim.\r\n    /// @return True if successful.\r\n    function claim(address _eth, bytes32 _pubKey)\r\n        external\r\n        has_allocation(_eth)\r\n        not_claimed(_eth)\r\n    {\r\n        require(_pubKey != bytes32(0), \"Failed to provide an Ed25519 or SR25519 public key\");\r\n        \r\n        if (amended[_eth] != address(0x0)) {\r\n            require(amended[_eth] == msg.sender, \"Address is amended and sender is not the amendment\");\r\n        } else {\r\n            require(_eth == msg.sender, \"Sender is not the allocation address\");\r\n        }\r\n\r\n        if (claims[_eth].index == 0 && !claims[_eth].hasIndex) {\r\n            require(assignNextIndex(_eth), \"Assigning the next index failed\");\r\n        }\r\n\r\n        claims[_eth].pubKey = _pubKey;\r\n        claimed.push(_eth);\r\n\r\n        emit Claimed(_eth, _pubKey, claims[_eth].index);\r\n    }\r\n\r\n    /// Get the length of `claimed`.\r\n    /// @return uint The number of accounts that have claimed.\r\n    function claimedLength()\r\n        external view returns (uint)\r\n    {   \r\n        return claimed.length;\r\n    }\r\n\r\n    /// Get whether an allocation has been claimed.\r\n    /// @return bool True if claimed.\r\n    function hasClaimed(address _eth)\r\n        has_allocation(_eth)\r\n        public view returns (bool)\r\n    {\r\n        return claims[_eth].pubKey != bytes32(0);\r\n    }\r\n\r\n    /// Assings an index to an allocation address.\r\n    /// @dev Public function.\r\n    /// @param _eth The allocation address.\r\n    function assignNextIndex(address _eth)\r\n        has_allocation(_eth)\r\n        not_claimed(_eth)\r\n        internal returns (bool)\r\n    {\r\n        require(claims[_eth].index == 0, \"Cannot reassign an index.\");\r\n        require(!claims[_eth].hasIndex, \"Address has already been assigned an index\");\r\n        uint idx = nextIndex;\r\n        nextIndex++;\r\n        claims[_eth].index = idx;\r\n        claims[_eth].hasIndex = true;\r\n        emit IndexAssigned(_eth, idx);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Requires that `_eth` address has DOT allocation.\r\n    modifier has_allocation(address _eth) {\r\n        uint bal = allocationIndicator.balanceOf(_eth);\r\n        require(\r\n            bal > 0,\r\n            \"Ethereum address has no DOT allocation\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Requires that `_eth` address has not claimed.\r\n    modifier not_claimed(address _eth) {\r\n        require(\r\n            claims[_eth].pubKey == bytes32(0),\r\n            \"Account has already claimed.\"\r\n        );\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocationIndicator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_origs\",\"type\":\"address[]\"},{\"name\":\"_amends\",\"type\":\"address[]\"}],\"name\":\"amend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_eth\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimedLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_eths\",\"type\":\"address[]\"},{\"name\":\"_vestingAmts\",\"type\":\"uint256[]\"}],\"name\":\"setVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_eths\",\"type\":\"address[]\"}],\"name\":\"assignIndices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claims\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"pubKey\",\"type\":\"bytes32\"},{\"name\":\"hasIndex\",\"type\":\"bool\"},{\"name\":\"vested\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_eth\",\"type\":\"address\"},{\"name\":\"_pubKey\",\"type\":\"bytes32\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimed\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"amended\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_allocations\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"original\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amendedTo\",\"type\":\"address\"}],\"name\":\"Amended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"eth\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dot\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"eth\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"IndexAssigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"eth\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Vested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"old\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"current\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"}]","ContractName":"Claims","CompilerVersion":"v0.5.9+commit.e560f70d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000444c3281dadacb6e7c55357e5a7bbd92c2dc34000000000000000000000000b59f67a8bff5d8cd03f6ac17265c550ed8f33907","Library":"","SwarmSource":"bzzr://10c8ae3ea26c0301e9bfad943a96f770f81567830694ef0ba13a8fceafce83c7"}]}