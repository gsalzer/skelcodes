{"status":"1","message":"OK","result":[{"SourceCode":"// =================================================================================================\r\n//                                    CTOKEN INTERFACE\r\n// =================================================================================================\r\n\r\npragma solidity 0.5.8; // use same version as Compound's contract\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP, plus additional\r\n * functions for cDAI contract interactions. Does not include the optional\r\n * functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface ICERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function mint(uint mintAmount) external returns (uint);\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for the underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemTokens The number of cTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n\r\n    /**\r\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\r\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\r\n     * @param redeemAmount The amount of underlying to redeem\r\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\r\n     */\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n}\r\n\r\n// =================================================================================================\r\n//                                    OPEN ZEPPELIN CONTRACTS\r\n// =================================================================================================\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract FloatifyAccount is Ownable {\r\n    using SafeMath for uint256;\r\n    // =============================================================================================\r\n    //                                    STORAGE VARIABLES\r\n    // =============================================================================================\r\n\r\n    // Amount of DAI used to mint cDAI\r\n    // If DAI was sent to the contract but not used to mint cDAI, it will not be counted here\r\n    // Therefore, this value should be updated when the deposit function is called\r\n    uint256 public totalDeposited;\r\n\r\n    // Amount of deposited DAI which was redeemed and withdrawn\r\n    // If DAI was sent to the contract and withdrawn without minting cDAI, it will not be counted here\r\n    // Therefore, this value should be updated when the redeemAndWithdraw functions are callled\r\n    uint256 public totalWithdrawn;\r\n\r\n    // DAI and CDAI interface variables\r\n    ICERC20 private daiContract; // interface to call functions from DAI contract\r\n    ICERC20 private cdaiContract; // interface to call functions from cDAI contract\r\n\r\n\r\n    // =============================================================================================\r\n    //                                        EVENTS\r\n    // =============================================================================================\r\n\r\n    /**\r\n     * @dev Emitted when cDAI is successfully minted from DAI held by the contract\r\n     */\r\n    event Deposit(uint256 indexed daiAmount);\r\n\r\n    /**\r\n     * @dev Emitted on withdrawal of DAI to an external account\r\n     */\r\n    event Withdraw(address indexed destinationAddress, uint256 indexed daiAmount);\r\n\r\n     /**\r\n      * @dev Emitted on redemption of cDAI for DAI by specifying cDAI amount\r\n      */\r\n    event RedeemMax(uint256 indexed daiAmount, uint256 indexed cdaiAmount, address indexed withdrawalAddress);\r\n\r\n    /**\r\n     * @dev Emitted on redemption of cDAI for DAI by specifying DAI amount\r\n     */\r\n    event RedeemPartial(uint256 indexed daiAmount, uint256 indexed cdaiAmount, address indexed withdrawalAddress);\r\n\r\n    // =============================================================================================\r\n    //                                   MAIN OPERATION FUNCTIONS\r\n    // =============================================================================================\r\n\r\n    // CONSTRUCTOR FUNCTION AND HELPERS ============================================================\r\n    /**\r\n     * @dev Approve cDAI contract upon deployment, throws error if fails\r\n     */\r\n    constructor() public {\r\n\r\n        // Configure the ICERC20 state variables\r\n        address _daiAddress = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359; // mainnet DAI address\r\n        address _cdaiAddress = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC; // mainnet cDAI address\r\n        daiContract = ICERC20(_daiAddress);\r\n        cdaiContract = ICERC20(_cdaiAddress);\r\n\r\n        // Approve the cDAI contract to spend our DAI balance\r\n        bool daiApprovalResult = daiContract.approve(_cdaiAddress, 2**256-1);\r\n        require(daiApprovalResult, \"Failed to approve cDAI contract to spend DAI\");\r\n    }\r\n\r\n\r\n    // DEPOSIT FUNCTION ============================================================================\r\n    /**\r\n     * @notice Deposits all DAI in this contract and mints cDAI to start earning interest\r\n     */\r\n    function deposit() external onlyOwner {\r\n        uint _daiBalance = daiContract.balanceOf(address(this));\r\n        totalDeposited = _daiBalance.add(totalDeposited);\r\n        emit Deposit(_daiBalance);\r\n        require(cdaiContract.mint(_daiBalance) == 0, \"Call to mint function failed\");\r\n    }\r\n\r\n    // WITHDRAWAL PROCESS FUNCTIONS ================================================================\r\n    // There are two supported flows:\r\n    //        1. Redeem everything:\r\n    //                a. Specify address to withdraw to\r\n    //                b. Get the cDAI balance of this contract\r\n    //                c. Call redeem() with the balance from step 1b\r\n    //                d. Withdraw DAI to the address specified in step 1a\r\n    //        2. Redeem a specified amount of DAI\r\n    //                a. Specify address to withdraw to and an amount of DAI to withdraw\r\n    //                b. Call redeemUnderlying() with the amount of DAI specified in step 2a\r\n    //                c. Withdraw DAI to the address specified in step 2a\r\n\r\n    /**\r\n     * @notice Withdraws all DAI from this contract to a specified address\r\n     * @dev We keep this as `public onlyOwner` in case there is ever a need to Withdraw DAI without\r\n     * depositing it in Compound first\r\n     * @param _withdrawalAddress Address to send DAI to\r\n     */\r\n    function withdraw(address _withdrawalAddress) public onlyOwner {\r\n        require(_withdrawalAddress != address(0), \"Cannot withdraw to the zero address\");\r\n        uint256 _daiBalance = daiContract.balanceOf(address(this));\r\n        emit Withdraw(_withdrawalAddress, _daiBalance);\r\n        require(daiContract.transfer(_withdrawalAddress, _daiBalance), \"Withrawal of DAI failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Redeems all cDAI held by this contract for DAI and sends it to a specified address\r\n     * @dev This corresponds to flow 1 above\r\n     * @param _withdrawalAddress Address to send DAI to\r\n     */\r\n    function redeemAndWithdrawMax(address _withdrawalAddress) external onlyOwner {\r\n        // 1a. Destination address specified as an input\r\n        require(_withdrawalAddress != address(0), \"Cannot withdraw to the zero address\");\r\n        // 1b. Get the cDAI balance of this contract\r\n        uint256 _cdaiBalance = cdaiContract.balanceOf(address(this));\r\n        // 1c. Call redeem() with the balance from step 1b\r\n        // EXTERNAL CONTRACT CALL -- state updates must happen after this call\r\n        //   This is bad practice, but because (1) this function is onlyOwner, and (2) we\r\n        //   trust the DAI and cDAI contracts to be secure, the risk is mitigated\r\n        require(cdaiContract.redeem(_cdaiBalance) == 0, \"Redemption of all cDAI for DAI failed\");\r\n        uint256 _daiBalance = daiContract.balanceOf(address(this));\r\n        emit RedeemMax(_daiBalance, _cdaiBalance, _withdrawalAddress);\r\n        totalWithdrawn = _daiBalance.add(totalWithdrawn); // right after this line we withdraw the full DAI balance\r\n        // 1d. Withdraw all DAI to the address specified in step 1a\r\n        withdraw(_withdrawalAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Takes an amount of DAI and redeems the equivalent amount of cDAI\r\n     * @dev This corresponds to flow 2 above\r\n     * @param _withdrawalAddress Address to send DAI to\r\n     * @param _daiAmount Amount of DAI to redeem\r\n     */\r\n    function redeemAndWithdrawPartial(address _withdrawalAddress, uint256 _daiAmount) external onlyOwner {\r\n        // 2a. Address to withdraw to and amount of DAI to withdraw specified as inputs\r\n        require(_withdrawalAddress != address(0), \"Cannot withdraw to the zero address\");\r\n        // 2b. Call redeemUnderlying() with the amount of DAI specified in step 2a\r\n        uint256 _initialCdaiBalance = cdaiContract.balanceOf(address(this));\r\n        require(cdaiContract.redeemUnderlying(_daiAmount) == 0, \"Redemption of some cDAI for DAI failed\");\r\n        uint256 _finalCdaiBalance = cdaiContract.balanceOf(address(this));\r\n        // EXTERNAL CONTRACT CALL -- state updates must happen after this call\r\n        //   This is bad practice, but because (1) this function is onlyOwner, and (2) we\r\n        //   trust the DAI and cDAI contracts to be secure, the risk is mitigated\r\n        uint256 _daiBalance = daiContract.balanceOf(address(this));\r\n        uint256 _cdaiBalance = _initialCdaiBalance.sub(_finalCdaiBalance);\r\n        emit RedeemPartial(_daiAmount, _cdaiBalance, _withdrawalAddress);\r\n        totalWithdrawn = _daiBalance.add(totalWithdrawn); // right after this line we withdraw the full DAI balance\r\n        // 2c. Withdraw all DAI to the address specified in step 2a\r\n        withdraw(_withdrawalAddress);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawalAddress\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawalAddress\",\"type\":\"address\"}],\"name\":\"redeemAndWithdrawMax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawalAddress\",\"type\":\"address\"},{\"name\":\"_daiAmount\",\"type\":\"uint256\"}],\"name\":\"redeemAndWithdrawPartial\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeposited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"destinationAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"daiAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"cdaiAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"withdrawalAddress\",\"type\":\"address\"}],\"name\":\"RedeemMax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"daiAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"cdaiAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"withdrawalAddress\",\"type\":\"address\"}],\"name\":\"RedeemPartial\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"FloatifyAccount","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://53315e72266b5343bb4bba114e1b293f53b59e6f3b534fc538662d7dd1826aae"}]}