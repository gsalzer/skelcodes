{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Collection of functions related to the address type,\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract\\u0027s constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * \\u003e It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n}\\n\"},\"CapperRole.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"../Roles.sol\\\";\\n\\ncontract CapperRole {\\n    using Roles for Roles.Role;\\n\\n    event CapperAdded(address indexed account);\\n    event CapperRemoved(address indexed account);\\n\\n    Roles.Role private _cappers;\\n\\n    constructor () internal {\\n        _addCapper(msg.sender);\\n    }\\n\\n    modifier onlyCapper() {\\n        require(isCapper(msg.sender), \\\"CapperRole: caller does not have the Capper role\\\");\\n        _;\\n    }\\n\\n    function isCapper(address account) public view returns (bool) {\\n        return _cappers.has(account);\\n    }\\n\\n    function addCapper(address account) public onlyCapper {\\n        _addCapper(account);\\n    }\\n\\n    function renounceCapper() public {\\n        _removeCapper(msg.sender);\\n    }\\n\\n    function _addCapper(address account) internal {\\n        _cappers.add(account);\\n        emit CapperAdded(account);\\n    }\\n\\n    function _removeCapper(address account) internal {\\n        _cappers.remove(account);\\n        emit CapperRemoved(account);\\n    }\\n}\\n\"},\"CrowdliExchangeVault.sol\":{\"content\":\"pragma solidity 0.5.0;\\n\\nimport \\\"./CrowdliSTO.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\n\\n/**\\n* This contract can be in one of the following states:\\n* - Active      The contract is open to new payment requests\\n* - Closed      No new payments will be accepted nor payments can be rejected though refunds can be claimed for payments that had been prior to closing.\\n*/\\ncontract CrowdliExchangeVault is Ownable, Pausable {\\n\\n    struct EtherPayment {\\n        address from;\\n        uint64 date;\\n        PaymentStatus status;\\n        uint weiAmount;\\n        uint pendingTokens;\\n        uint mintedTokens;\\n        uint exchangeRate;\\n    }\\n\\n    struct ExchangeOrder {\\n        uint256 exchangeRate;\\n        uint64 date;\\n        address exchangeWallet;\\n        ExchangeStatus status;\\n    }\\n    \\n    /**\\n     * Defines the statuses an exchange order can have\\n     */\\n    enum ExchangeStatus { Pending, Confirmed }\\n\\n    /**\\n    * Defines the statuses an payment can have\\n    */\\n    enum PaymentStatus { None, Requested, Accepted, TokensDelivered, Rejected, Refunded, PurchaseFailed }\\n    \\n    /**\\n    * The safe math library for safety math operations provided by Zeppelin\\n    */\\n    using SafeMath for uint256;\\n\\n    /**\\n    * Holds all exchange orders, each of them containing multiple payments\\n    */\\n   \\tExchangeOrder[] public exchangeOrders;\\n   \\n    /**\\n    * Holds all ether payments in different states (PaymentStatu\\n    */\\n    EtherPayment[] public payments;\\n    \\n    /**\\n     * A dictionary holind the number of requested payment per investor\\n     */\\n    mapping(address =\\u003e uint) public nrRequestedPayments; \\n    \\n    /**\\n     * A dictionary to lookup the related payments (paymentsIds: uint[]) for a given exchange order (exchangeOrderId: uint)\\n     */\\n    mapping(uint =\\u003e uint[]) private exchangeOrderForPayments; //exchangeOrderId =\\u003e array of paymentsIds\\n    \\n    \\n    address public paymentConfirmer;\\n    \\n    /**\\n     * Used to process payments once they are confirmed \\n     */\\n    CrowdliSTO private crowdliSTO;\\n    \\n     /**\\n     * Event will be fired whenever payments processing is enabled\\n     * @param sender The account that has enabled the payment processing\\n     */\\n    event PaymentsEnabled(address indexed sender);\\n    \\n    /**\\n     * Event will be fired whenever payments processing is disabled\\n     * @param sender The account that has disabled the payment processing\\n     */\\n    event PaymentsDisabled(address indexed sender);\\n    event EtherPaymentRefunded(address indexed beneficiary, uint256 weiAmount);\\n    event EtherPaymentRequested(address indexed beneficiary, uint256 weiAmount, uint paymentIndex);\\n    event EtherPaymentRejected(address indexed sender, uint etherPaymentIndex);\\n    event LogGasUsed(address indexed sender, uint indexed value);\\n    event EtherPaymentPurchaseFailed(address indexed sender, uint indexed etherPaymentIndex);\\n    event OrderCreated(address indexed sender, uint[] payments);\\n    event OrderConfirmed(address indexed sender, uint indexed etherPaymentIndex);\\n\\n\\tmodifier isInInvestmentState() {\\n         require(crowdliSTO.hasState(CrowdliSTO.States.Investment) || !crowdliSTO.paused(), \\\"bot in state investment\\\");\\n        _;\\n    }\\n\\n    modifier onlyCrowdliSTO() {\\n        require((msg.sender == address(crowdliSTO)), \\\"Sender should be CrowdliSTO\\\");\\n        _;\\n    }\\n    \\n    modifier onlyEtherPaymentConfirmer() {\\n        require((msg.sender == paymentConfirmer), \\\"Sender should be EtherPaymentConfirmer\\\");\\n        _;\\n    }\\n    \\n    constructor(address _paymentConfirmer) public {\\n        paymentConfirmer = _paymentConfirmer; \\n    }\\n    \\n\\tfunction setCrowdliSTO(CrowdliSTO _crowdliSTO) external onlyOwner {\\n    \\tcrowdliSTO = _crowdliSTO;\\n    }\\n\\n\\tfunction initExchangeVault(address _directorsBoard, address _crowdliSTO) external onlyOwner{\\n    \\tcrowdliSTO = CrowdliSTO(_crowdliSTO);\\n    \\ttransferOwnership(_crowdliSTO);\\n    \\taddPauser(_directorsBoard);\\n    \\taddPauser(_crowdliSTO);\\n    }\\n    \\n    function confirmMintedTokensForPayment(uint paymentId, uint _mintedTokens) external onlyOwner {\\n        payments[paymentId].mintedTokens = payments[paymentId].mintedTokens.add(_mintedTokens);\\n    }\\n    /**\\n    * @dev The ether provided by the investor will be collected for a new fiat exchange order will be triggered by the owner\\n    * @dev Since the exact conversion rate that will be used for the fiat exchange is unknown the tokens will be minted AFTER once the order is completed\\n    */\\n\\n    function requestPayment() external whenNotPaused payable  {\\n        uint[] memory tokenStatement = crowdliSTO.calculateTokenStatementEther(msg.sender, msg.value, CrowdliSTO.Currency.ETH, false, 0); \\n        // only process if validation code == OK\\n        require(CrowdliSTO.TokenStatementValidation(tokenStatement[8]) == CrowdliSTO.TokenStatementValidation.OK, crowdliSTO.resolvePaymentError(CrowdliSTO.TokenStatementValidation(tokenStatement[8])));\\n        \\n        payments.push(EtherPayment(msg.sender, uint64(now), PaymentStatus.Requested, msg.value, 0, 0, 0));\\n        nrRequestedPayments[msg.sender] = nrRequestedPayments[msg.sender].add(1);\\n        emit EtherPaymentRequested(msg.sender, msg.value, payments.length.sub(1));\\n    }\\n    \\n    /**\\n    * @dev An investor can be subsequently rejected if the AML and PEP checks were negative\\n    */\\n    function rejectPayment(uint[] calldata _paymentIds) external onlyEtherPaymentConfirmer {\\n        for(uint id = 0; id \\u003c _paymentIds.length; id++){\\n        \\tuint paymentId = _paymentIds[id];\\n            // we only allow payments that have not been confirmed, rejected or refunded yet\\n            require(payments[paymentId].status == PaymentStatus.Requested, \\\"Payment must be in state Requested\\\");\\n    \\n            // mark ether payment as rejected and therby allowing the investor to claim refund\\n            payments[paymentId].status = PaymentStatus.Rejected;\\n            \\n            nrRequestedPayments[payments[paymentId].from] = nrRequestedPayments[payments[paymentId].from].sub(1);\\n            // fire an event so the investor can be informed that his payment was rejected\\n            emit EtherPaymentRejected(payments[paymentId].from, paymentId);\\n        }\\n    }\\n\\n    /**\\n    * @dev Once an investor has been rejected a refund can be claimed\\n    */\\n    function refundPayment(uint index) external {\\n    \\n        EtherPayment storage etherPayment = payments[index];\\n        uint256 depositedValue = etherPayment.weiAmount;\\n\\n        // only allow refund for payments which have been rejected \\n        require((etherPayment.from == msg.sender) || (msg.sender == paymentConfirmer), \\\"Refund are not enabled for sender\\\");\\n        require(etherPayment.status == PaymentStatus.Rejected , \\\"etherPayment.status should be PaymentStatus.Rejected\\\");\\n\\t\\trequire(address(this).balance \\u003e= depositedValue , \\\"Exchange Vault balance doesn\\u0027t have enough funds.\\\");\\n        // mark ether payment status to refunded\\n        etherPayment.status = PaymentStatus.Refunded;\\n\\n        // send the ether back to investors address\\n        msg.sender.transfer(depositedValue);\\n\\n        emit EtherPaymentRefunded(msg.sender, depositedValue);\\n    }\\n\\n    /**\\n     * @param _exchangeWallet The wallet of the exchange provider where the ether will be sent for FIAT exchange\\n     */\\n    function createOrder(address payable _exchangeWallet, uint[] calldata _paymentsToAccept) external whenNotPaused onlyEtherPaymentConfirmer isInInvestmentState {\\n        require(payments.length \\u003e 0, \\\"At least one payment is required to exchange\\\");\\n        ExchangeOrder memory exchangeOrder = ExchangeOrder(0, uint64(now), _exchangeWallet, ExchangeStatus.Pending);\\n        exchangeOrders.push(exchangeOrder);\\n        uint weiAmountForTransfering = 0;\\n        // iterate through all payments which are not assigned to an exchange order\\n       \\tuint[] storage orderForPaymentIds = exchangeOrderForPayments[exchangeOrders.length-1];\\n        for (uint64 i = 0; i \\u003c _paymentsToAccept.length; i++) {\\n            uint paymentId = _paymentsToAccept[i];\\n            EtherPayment storage etherPayment = payments[paymentId];\\n            require(etherPayment.status == PaymentStatus.Requested, \\\"should be in status requested\\\"); \\n            etherPayment.status = PaymentStatus.Accepted;\\n            orderForPaymentIds.push(paymentId);\\n            processPayment(paymentId);\\n            weiAmountForTransfering = weiAmountForTransfering.add(etherPayment.weiAmount);\\n        }\\n        emit OrderCreated(msg.sender, orderForPaymentIds);\\n        _exchangeWallet.transfer(weiAmountForTransfering);\\n    }\\n\\n\\t/**\\n\\t* buy tokens on behalf of the investor\\n\\t*/\\n\\tfunction processPayment(uint _paymentId) internal {\\n\\t\\tEtherPayment storage etherPayment = payments[_paymentId];\\n\\t    nrRequestedPayments[etherPayment.from] = nrRequestedPayments[etherPayment.from].sub(1);\\n\\t    crowdliSTO.processEtherPayment(etherPayment.from, etherPayment.weiAmount, _paymentId);\\n\\t    etherPayment.status = PaymentStatus.TokensDelivered;\\n\\t    etherPayment.exchangeRate = crowdliSTO.exchangeRate();\\n    }\\n    \\n    function confirmOrder(uint64 _orderIndex, uint256 _exchangeRate) external whenNotPaused onlyEtherPaymentConfirmer {\\n        require(_orderIndex \\u003c exchangeOrders.length, \\\"_orderIndex is too high\\\");\\n        ExchangeOrder storage exchangeOrder = exchangeOrders[_orderIndex];\\n        require(exchangeOrder.status != ExchangeStatus.Confirmed, \\\"exchangeOrder.status is confirmed\\\");\\n        exchangeOrder.exchangeRate = _exchangeRate;\\n        exchangeOrder.status = ExchangeStatus.Confirmed;\\n    }\\n    \\n    function hasRequestedPayments(address _beneficiary) public view returns(bool) {\\n        return (nrRequestedPayments[_beneficiary] != 0);\\n    }    \\n        \\n    function getEtherPaymentsCount() external view returns(uint256) {\\n        return payments.length;\\n    }\\n    \\n    function getExchangeOrdersCount() external view returns(uint256) {\\n        return exchangeOrders.length;\\n    }\\n    \\n    function getExchangeOrdersToPayments(uint orderId) external view returns (uint[] memory) {\\n        return exchangeOrderForPayments[orderId];\\n    }     \\n    \\n}\\n\"},\"CrowdliKYCProvider.sol\":{\"content\":\"\\npragma solidity 0.5.0;\\n\\nimport \\\"./Pausable.sol\\\";\\nimport \\\"./WhitelistAdminRole.sol\\\";\\n\\ncontract CrowdliKYCProvider is Pausable, WhitelistAdminRole {\\n\\n\\t/**\\n\\t * The verification levels supported by this ICO\\n\\t */\\n\\tenum VerificationTier { None, KYCAccepted, VideoVerified, ExternalTokenAgent } \\n    \\n    /**\\n     * Defines the max. amount of tokens an investor can purchase for a given verification level (tier)\\n     */\\n\\tmapping (uint =\\u003e uint) public maxTokenAmountPerTier; \\n    \\n    /**\\n    * Dictionary that maps addresses to investors which have successfully been verified by the external KYC process\\n    */\\n    mapping (address =\\u003e VerificationTier) public verificationTiers;\\n\\n    /**\\n    * This event is fired when a user has been successfully verified by the external KYC verification process\\n    */\\n    event LogKYCConfirmation(address indexed sender, VerificationTier verificationTier);\\n\\n\\t/**\\n\\t * This constructor initializes a new  CrowdliKYCProvider initializing the provided token amount threshold for the supported verification tiers\\n\\t */\\n    constructor(address _kycConfirmer, uint _maxTokenForKYCAcceptedTier, uint _maxTokensForVideoVerifiedTier, uint _maxTokensForExternalTokenAgent) public {\\n        addWhitelistAdmin(_kycConfirmer);\\n        // Max token amount for non-verified investors\\n        maxTokenAmountPerTier[uint(VerificationTier.None)] = 0;\\n        \\n        // Max token amount for auto KYC auto verified investors\\n        maxTokenAmountPerTier[uint(VerificationTier.KYCAccepted)] = _maxTokenForKYCAcceptedTier;\\n        \\n        // Max token amount for auto KYC video verified investors\\n        maxTokenAmountPerTier[uint(VerificationTier.VideoVerified)] = _maxTokensForVideoVerifiedTier;\\n        \\n        // Max token amount for external token sell providers\\n        maxTokenAmountPerTier[uint(VerificationTier.ExternalTokenAgent)] = _maxTokensForExternalTokenAgent;\\n    }\\n\\n    function confirmKYC(address _addressId, VerificationTier _verificationTier) public onlyWhitelistAdmin whenNotPaused {\\n        emit LogKYCConfirmation(_addressId, _verificationTier);\\n        verificationTiers[_addressId] = _verificationTier;\\n    }\\n\\n    function hasVerificationLevel(address _investor, VerificationTier _verificationTier) public view returns (bool) {\\n        return (verificationTiers[_investor] == _verificationTier);\\n    }\\n    \\n    function getMaxChfAmountForInvestor(address _investor) public view returns (uint) {\\n        return maxTokenAmountPerTier[uint(verificationTiers[_investor])];\\n    }    \\n}\"},\"CrowdliSTO.sol\":{\"content\":\"pragma solidity 0.5.0;\\n\\nimport \\\"./CrowdliToken.sol\\\";\\nimport \\\"./CrowdliKYCProvider.sol\\\";\\nimport \\\"./CrowdliExchangeVault.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @title Crowdli STO Contract\\n */\\ncontract CrowdliSTO is Pausable, Ownable {\\n    /**\\n     * The safe math library for safety math operations provided by Open Zeppelin\\n     */\\n    using SafeMath for uint;\\n\\n    /**\\n     * Defines all states the STO can be in\\n     */\\n    enum States {\\n        PrepareInvestment,\\n        Investment,\\n        Finalizing,\\n        Finalized\\n    }\\n\\n    struct InvestmentPhase {\\n        bytes32 label;\\n        bool allowManualSwitch;\\n        uint discountBPS;\\n        uint capAmount;\\n        uint tokensSoldAmount;\\n    }\\n\\n    struct TokenAllocation {\\n        bytes32 label;\\n        AllocationActionType actionType;\\n        AllocationValueType valueType;\\n        uint valueAmount;\\n        address beneficiary;\\n        bool isAllocated;\\n    }\\n\\n    struct TokenStatement {\\n        uint requestedBase;\\n        uint requestedCHF;\\n        uint feesCHF;\\n        uint currentPhaseDiscount;\\n        uint earlyBirdCreditTokenAmount;\\n        uint voucherCreditTokenAmount;\\n        uint currentPhaseTokenAmount;\\n        uint nextPhaseBaseAmount;\\n        TokenStatementValidation validationCode;\\n    }\\n\\n    enum Currency {\\n        ETH,\\n        CHF,\\n        EUR\\n    }\\n\\n    enum ExecutionType {\\n        SinglePayment,\\n        SplitPayment\\n    }\\n\\n    enum AllocationActionType {\\n        POST_ALLOCATE\\n    }\\n\\n    enum AllocationValueType {\\n        FIXED_TOKEN_AMOUNT,\\n        BPS_OF_TOKENS_SOLD\\n    }\\n\\n    enum TokenStatementValidation {\\n        OK,\\n        BELOW_MIN_LIMIT,\\n        ABOVE_MAX_LIMIT,\\n        EXCEEDS_HARD_CAP\\n    }\\n\\n    /**\\n     * This event is fired when a ether payment is confirmed by payment confirmer\\n     */\\n    event LogPaymentConfirmation(address indexed beneficiary, uint indexed investment, uint[] paymentDetails, uint id, Currency currency, ExecutionType executionType);\\n    /**\\n     * This event is fired when a new investment sub-phase is registered during the PrepareInvestment phase\\n     */\\n    event LogRegisterInvestmentPhase(address indexed sender, bool allowManualSwitch, bytes32 indexed label, uint indexed discountBPS, uint cap);\\n\\n    /**\\n     * This event is fired when the start date is updated\\n     */\\n    event LogSaleStartUpdated(address indexed sender, uint indexed saleStartDate);\\n\\n    /**\\n     * This event is fired whenever the CrowdliKYCProvider used for the STO is updated\\n     */\\n    event LogKYCProviderUpdated(address indexed sender, address indexed crowdliKycProvider);\\n\\n    /**\\n     * This event is fired when the STO has started\\n     */\\n    event LogStarted(address indexed sender);\\n\\n    /**\\n     * This event is fired when a new investment phase starts\\n     */\\n    event LogInvestmentPhaseSwitched(uint phaseIndex);\\n\\n    /**\\n     * This event is fired when the STO closes\\n     */\\n    event LogEndDateExtended(address indexed sender, uint endDate);\\n\\n    /**\\n     * This event is fired when the STO closes\\n     */\\n    event LogClosed(address indexed sender, bool stoSucessfull);\\n\\n    /**\\n     * This event will be fired when the customer finalizes the STO\\n     */\\n    event LogFinalized(address indexed sender);\\n\\n    /**\\n     * Whenever the state of the contract changes, this event will be fired.\\n     */\\n    event LogStateChanged(States _states);\\n    \\n    /**\\n     * Whenever the investor gets pending voucher.\\n     */\\n    event LogPendingVoucherAdded(address _investor);\\n\\n    /**\\n     * State variable: Defines the state of the STO\\n     */\\n    States public state;\\n\\n    /**\\n     * Only the foundation board is able to finalize the STO.\\n     * Two of four members have to confirm the finalization. Therefore a multisig contract is used.\\n     */\\n    address public directorsBoard;\\n\\n    /**\\n     * This account is authorized to confirm payments\\n     */\\n    address public paymentConfirmer;\\n\\n    /**\\n     * This the wallet where for an external agent all tokens tokens are minted for the incoming payments\\n     */\\n    address public tokenAgentWallet;\\n\\n    /**\\n     * The token we are giving the investors in return for their investments\\n     */\\n    CrowdliToken public token;\\n\\n    /**\\n     * The exchange vault used to exchange ether payments in a restricted an safe manner with the authorized bank into fiat money\\n     */\\n    CrowdliExchangeVault public crowdliExchangeVault;\\n\\n    /**\\n     * The kyc provider used to whitelist the investors for verification tiers\\n     */\\n    CrowdliKYCProvider public crowdliKycProvider;\\n\\n    /**\\n     * STO settings \\u0026 statistics: Pre- and post allocated tokens\\n     */\\n    TokenAllocation[] public tokenAllocations;\\n\\n    /**\\n     * STO settings \\u0026 statistics: Defines the phases for an STO\\n     */\\n    InvestmentPhase[] public investmentPhases;\\n\\n    /**\\n     * STO Setting:  The total amount of tokens sold during the STO(includes all phases)\\n     */\\n    uint public hardCapAmount = 0;\\n\\n    /**\\n     * The lower hardcap threshold allows a bandwith in which the hard cap is regarded as reached\\n     */\\n    uint public hardCapThresholdAmount;\\n\\n    /**\\n     * STO Setting: The min. token amount that have to be sold so that the STO successful\\n     */\\n    uint public softCapAmount;\\n\\n    /**\\n     * STO Setting: Minimum amount of tokens a investor is able to buy\\n     */\\n    uint public minChfAmountPerInvestment;\\n    /**\\n     * STO Setting: The UNIX timestamp (in seconds) defining when 1the STO will start\\n     */\\n    uint public saleStartDate;\\n\\n    /**\\n     * The date the STO Organizer can extend the STO at latest for the defined offset\\n     */\\n    uint public endDateExtensionDecissionDate;\\n\\n    /**\\n     * The endDate can be extended with this offset\\n     */\\n    uint public endDateExtensionOffset;\\n\\n    /**\\n     * STO Setting: \\n     */\\n    uint public endDate;\\n\\n    /**\\n     * STO settings: Video Verification cost\\n     */\\n    uint public videoVerificationCostAmount ;\\n\\n    /**\\n     * STO settings: gas fees used for further processing of payments\\n     */\\n    uint internal gasCostAmount;\\n\\n    /**\\n     * STO state: Defines the index of the current phase\\n     */\\n    uint public investmentPhaseIndex;\\n\\n    /**\\n     * The board of directors can comment the finalization\\n     * Crowdli change: change to bytes32 to reduce gas costs\\n     */\\n    bytes32 public boardComment;\\n\\n    /**\\n     * Threshold to define if the investor should get \\u0027earlyBird\\u0027 status.\\n     */\\n    uint public earlyBirdTokensThresholdAmount;\\n\\n    /**\\n     * Token to be added to the purchased tokens amount.\\n     */\\n    uint public earlyBirdAdditionalTokensAmount;\\n\\n    /**\\n     * Maximum number of the \\u0027earlyBird\\u0027 investors.\\n     */\\n    uint public earlyBirdInvestorsCount;\\n\\n    /**\\n     * First available investment phase for \\u0027earlyBird\\u0027 investor.\\n     */\\n    uint public earlyBirdInvestmentPhase = 0;\\n\\n    /**\\n     * Current number of the \\u0027earlyBird\\u0027 investor.\\n     */\\n    uint public currentEarlyBirdInvestorsCount = 0;\\n\\n    /**\\n     * The token amount an investor receives for redeeming a voucher\\n     */\\n    uint public voucherTokensAmount;\\n\\n    /**\\n     * Investors that have a pending vouchers to be redeemed\\n     */\\n    mapping(address =\\u003e bool) public investorsWithEarlyBird;\\n\\n    /**\\n     * Investors that have pending vouchers.\\n     */\\n    mapping(address =\\u003e bool) public investorsWithPendingVouchers;\\n\\n    /**\\n     * Investors that have paid for the video verification\\n     */\\n    mapping(address =\\u003e bool) public paidForVideoVerification;\\n\\n    /**\\n     * STO Statistic: The total amount of tokens sold\\n     */\\n    uint public tokensSoldAmount;\\n\\n    /**\\n     * STO Statistic: The total amount of WEI invested by this STO\\n     */\\n    uint public weiInvested ;\\n\\n    /**\\n     * STO Statistic: The number of investors that have invested in this STO\\n     */\\n    uint public numberOfInvestors;\\n\\n    /**\\n     * STO Statistic: The total amount of investments (FIAT and ETH) in CHF\\n     */\\n    mapping(address =\\u003e uint) public allInvestmentsInChf;\\n\\n    /**\\n     * STO Statistic: The total amount of WEI\\u0027s per investor\\n     */\\n    mapping(address =\\u003e uint) public weiPerInvestor;\\n\\n    /**\\n     * STO Statistic: The total amount of CHF\\u0027s per investor\\n     */\\n    mapping(address =\\u003e uint) public chfPerInvestor;\\n\\n    /**\\n     * STO Statistic: The total amount of CHF\\u0027s investments\\n     */\\n    uint public chfOverallInvested;\\n\\n    /**\\n     * STO Statistic: The total amount of EUR\\u0027s per investor\\n     */\\n    mapping(address =\\u003e uint) public eurPerInvestor;\\n\\n    /**\\n     * STO Statistic: The total amount of EUR\\u0027s investments\\n     */\\n    uint public eurOverallInvested;\\n\\n    /**\\n     * The exchangeRate that was last used \\n     */\\n    uint public exchangeRate;\\n\\n    uint public exchangeRateDecimals;\\n\\n    /**\\n     * Limit the size of arrays to avoid gas limit deadlocks \\n     */\\n\\tuint constant public arrayMaxEntryLimit = 10;\\n\\t\\n    // ============================================================================================================================================================================================================================   \\n    // All modifiers come here\\n    // ============================================================================================================================================================================================================================\\n    /**\\n     * @dev Throws if called by any account other than the foundation board\\n     */\\n    modifier onlyDirectorsBoard() {\\n        require(msg.sender == directorsBoard, \\\"not directorsBoard\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if sender is not payment confirmer\\n     */\\n    modifier onlyFiatPaymentConfirmer() {\\n        require((msg.sender == paymentConfirmer), \\\"not paymentConfirmer\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if sender is not payment confirmer\\n     */\\n    modifier onlyEtherPaymentProvider() {\\n        require(msg.sender == address(crowdliExchangeVault), \\\"not crowdliExchangeVault\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if sender is not token agent payment confirmer\\n     */\\n    modifier onlyTokenAgentPaymentConfirmer() {\\n        require((msg.sender == paymentConfirmer), \\\"not tokenAgentPaymentConfirmer\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if sender is not in state\\n     */\\n    modifier inState(States _state) {\\n        require(hasState(_state), \\\"not in required state\\\");\\n        _;\\n    }\\n\\n\\n    constructor (CrowdliToken _token, CrowdliKYCProvider _crowdliKycProvider, CrowdliExchangeVault _crowdliExchangeVault, address _directorsBoard, address _paymentConfirmer, address _tokenAgentWallet) public {\\n        token = _token;\\n        crowdliKycProvider = _crowdliKycProvider;\\n        crowdliExchangeVault = _crowdliExchangeVault;\\n        directorsBoard = _directorsBoard;\\n        paymentConfirmer = _paymentConfirmer;\\n        tokenAgentWallet = _tokenAgentWallet;\\n    }\\n\\n    // ============================================================================================================================================================================================================================   \\n    // External functions\\n    // ============================================================================================================================================================================================================================v\\n    function initSTO(uint _saleStartDate, uint _earlyBirdTokensThreshold,\\n        uint _earlyBirdAdditionalTokens,\\n        uint _earlyBirdInvestorsCount,\\n        uint _earlyBirdInvestmentPhase,\\n        uint _voucherTokensAmount,\\n        uint _videoVerificationCost,\\n        uint _softCap,\\n        uint _endDate,\\n        uint _endDateExtensionDecissionDate,\\n        uint _endDateExtensionOffset,\\n        uint _gasCost,\\n        uint _hardCapThresholdAmount,\\n        uint _minChfAmountPerInvestment) external onlyOwner {\\n\\n        // we must disallow any transfers until the end of the STO\\n        token.pause();\\n\\n        saleStartDate = _saleStartDate;\\n        state = States.PrepareInvestment;\\n        earlyBirdTokensThresholdAmount = _earlyBirdTokensThreshold;\\n        earlyBirdInvestorsCount = _earlyBirdInvestorsCount;\\n        earlyBirdAdditionalTokensAmount = _earlyBirdAdditionalTokens;\\n        earlyBirdInvestmentPhase = _earlyBirdInvestmentPhase;\\n        voucherTokensAmount = _voucherTokensAmount;\\n        videoVerificationCostAmount = _videoVerificationCost;\\n        gasCostAmount = _gasCost;\\n        softCapAmount = _softCap;\\n        endDate = _endDate;\\n        endDateExtensionDecissionDate = _endDateExtensionDecissionDate;\\n        endDateExtensionOffset = _endDateExtensionOffset;\\n        hardCapThresholdAmount = _hardCapThresholdAmount;\\n        minChfAmountPerInvestment = _minChfAmountPerInvestment;\\n\\n    }\\n\\n    function registerPostAllocation(bytes32 _label, AllocationValueType _valueType, address _beneficiary, uint _value) external onlyOwner inState(States.PrepareInvestment) {\\n        require(_label != 0, \\\"_label not set\\\");\\n        require(_beneficiary != address(0), \\\"_beneficiary not set\\\");\\n        require(_value \\u003e 0, \\\"_value not set\\\");\\n        require(tokenAllocations.length \\u003c arrayMaxEntryLimit, \\\"tokenAllocations.length is too high\\\");\\n        tokenAllocations.push(TokenAllocation(_label, AllocationActionType.POST_ALLOCATE, _valueType, _value, _beneficiary, false));\\n    }\\n\\n    function updateStartDate(uint _saleStartDate) external onlyOwner inState(States.PrepareInvestment) {\\n        require(_saleStartDate \\u003e= now, \\\"saleStartDate not in future\\\");\\n        saleStartDate = _saleStartDate;\\n        emit LogSaleStartUpdated(msg.sender, _saleStartDate);\\n    }\\n\\n    function updateCrowdliKYCProvider(CrowdliKYCProvider _crowdliKycProvider) external onlyOwner inState(States.PrepareInvestment) {\\n        crowdliKycProvider = _crowdliKycProvider;\\n        emit LogKYCProviderUpdated(msg.sender, address(_crowdliKycProvider));\\n    }\\n\\n    function updateExchangeRate(uint _exchangeRate, uint _exchangeRateDecimals) external onlyOwner {\\n        exchangeRate = _exchangeRate;\\n        exchangeRateDecimals = _exchangeRateDecimals;\\n    }\\n\\n    function registerInvestmentPhase(bytes32 _label, bool allowManualSwitch, uint _discountBPS, uint _cap) external onlyOwner inState(States.PrepareInvestment) {\\n        require(_label != 0, \\\"label should not be empty\\\");\\n        require(investmentPhases.length \\u003c= arrayMaxEntryLimit, \\\"investmentPhases.length is too high\\\");\\n        investmentPhases.push(InvestmentPhase(_label, allowManualSwitch, _discountBPS, _cap, 0));\\n        emit LogRegisterInvestmentPhase(msg.sender, allowManualSwitch, _label, _discountBPS, _cap);\\n        //the hardcap is the sum of all phases caps\\n        hardCapAmount = hardCapAmount.add(_cap);\\n    }\\n\\n    function processEtherPayment(address _beneficiary, uint _weiAmount, uint _paymentId) external whenNotPaused onlyEtherPaymentProvider inState(States.Investment) {\\n        processPayment(_beneficiary, _paymentId, _weiAmount, Currency.ETH, exchangeRate, exchangeRateDecimals, false, true);\\n    }\\n\\n    function processBankPaymentCHF(address _beneficiary, uint _chfAmount, bool _hasRequestedPayments, uint _paymentId) external whenNotPaused onlyFiatPaymentConfirmer inState(States.Investment) {\\n        processPayment(_beneficiary, _paymentId, _chfAmount, Currency.CHF, 1, 1, _hasRequestedPayments, true);\\n    }\\n\\n    function processBankPaymentEUR(address _beneficiary, uint _eurAmount, uint _exchangeRate, uint _exchangeRateDecimals, bool _hasRequestedPayments, uint _paymentId) external whenNotPaused onlyFiatPaymentConfirmer inState(States.Investment) {\\n        processPayment(_beneficiary, _paymentId, _eurAmount, Currency.EUR, _exchangeRate, _exchangeRateDecimals, _hasRequestedPayments, true);\\n    }\\n\\n    function processTokenAgentPaymentCHF(uint _chfAmount, uint _paymentId) external whenNotPaused onlyTokenAgentPaymentConfirmer inState(States.Investment) {\\n        processPayment(tokenAgentWallet, _paymentId, _chfAmount, Currency.CHF, 1, 1, false, true);\\n    }\\n\\n    function addPendingVoucher(address _investor) external onlyOwner whenNotPaused {\\n        investorsWithPendingVouchers[_investor] = true;\\n        emit LogPendingVoucherAdded(_investor);\\n    }\\n\\n    function switchCurrentPhaseManually() external onlyDirectorsBoard inState(States.Investment) {\\n        require(isCurrentPhaseManuallySwitchable(), \\\"manual switch disallowed\\\");\\n\\n        // calculate the gap between current phase and cap amount\\n        InvestmentPhase memory currentInvestmentPhase = investmentPhases[investmentPhaseIndex];\\n        uint phaseDeltaTokenAmount = currentInvestmentPhase.capAmount.sub(currentInvestmentPhase.tokensSoldAmount);\\n\\n        // all tokens which were not sold after manual close will be made available in the last investment phase\\n        uint lastIndex = investmentPhases.length.sub(1);\\n        investmentPhases[lastIndex].capAmount = investmentPhases[lastIndex].capAmount.add(phaseDeltaTokenAmount);\\n        nextInvestmentPhase();\\n    }\\n\\n    function start() external onlyDirectorsBoard inState(States.PrepareInvestment) {\\n        startInternal();\\n    }\\n    \\n    function calculateTokenStatementFiat(address _investor, uint _currencyAmount, Currency _currency, uint256 _exchangeRate, uint256 _exchangeRateDecimals, bool _hasRequestedBankPayments, uint investmentPhaseOffset) external view returns(uint[] memory) {\\n        TokenStatement memory tokenStatement = calculateTokenStatementStruct(_investor, _currencyAmount, _currency, _exchangeRate, _exchangeRateDecimals, _hasRequestedBankPayments, (investmentPhaseOffset == 0), investmentPhaseOffset);\\n        return convertTokenStatementToArray(tokenStatement);\\n    }\\n    \\n    function calculateTokenStatementEther(address _investor, uint _currencyAmount, Currency _currency, bool _hasRequestedBankPayments, uint investmentPhaseOffset) external view returns(uint[] memory) {\\n        //exchangeRate and exchangeRateDecimals will be used from internal parameters\\n        TokenStatement memory tokenStatement = calculateTokenStatementStruct(_investor, _currencyAmount, _currency, exchangeRate, exchangeRateDecimals, _hasRequestedBankPayments, (investmentPhaseOffset == 0), investmentPhaseOffset);\\n        return convertTokenStatementToArray(tokenStatement);\\n    }\\n\\n    function evalTimedStates() external view returns (bool) {\\n        return ((isEndDateReached() \\u0026\\u0026 state == States.Investment) || isStartRequired());\\n    }\\n\\n    function extendEndDate() external inState(States.Investment) onlyDirectorsBoard {\\n        require(isEndDateExtendable(), \\\"isEndDateExtendable() is false\\\");\\n        endDate = endDate.add(endDateExtensionOffset);\\n        endDateExtensionOffset = 0;\\n        emit LogEndDateExtended(msg.sender, endDate);\\n    }\\n\\n    function updateTimedStates() external {\\n        if (isEndDateReached()) {\\n            if (isSoftCapReached()) {\\n                close(true);\\n            } else {\\n                close(false);\\n            }\\n        }\\n        if(isStartRequired()){\\n        \\tstartInternal();\\n        }\\n    }\\n\\n    function closeManually() external onlyDirectorsBoard inState(States.Investment) {\\n        require(isHardCapWithinCapThresholdReached(), \\\"Cap is not reached.\\\");\\n        close(true);\\n    }\\n\\n    /**\\n     * Once the STO is in state Finalizing the directors board account has to finalize in order to make the tokens transferable\\n     * @param _message An official statement why the STO is considered as successful\\n     * \\n     * Visibility: OK\\n     */\\n    function finalize(bytes32 _message) external onlyDirectorsBoard inState(States.Finalizing) {\\n        // the directors board has to give an statement why the STO is successful\\n        setBoardComment(_message);\\n\\n        // Make token transferable otherwise the transfer call used when granting vesting to teams will be rejected.\\n        allocateTokens(AllocationActionType.POST_ALLOCATE);\\n\\n        // release the token so can be transfered or \\n        token.unpause();\\n\\n        // finally the state of the STO is set to the final state \\u0027Finalized\\u0027 \\n        updateState(States.Finalized);\\n\\n        emit LogFinalized(msg.sender);\\n    }\\n\\n    // ============================================================================================================================================================================================================================   \\n    // Public functions\\n    // ============================================================================================================================================================================================================================v\\n    function getInvestmentPhaseCount() public view returns(uint) {\\n        return investmentPhases.length;\\n    }\\n\\n    function  getTokenAllocationsCount() public view returns(uint) {\\n        return tokenAllocations.length;\\n    }\\n\\n    function validate() public view returns (uint) {\\n        uint statusCode = 0;\\n        if (address(token) == address(0)) {\\n            statusCode = 1;\\n        } else if (address(crowdliKycProvider) == address(0)) {\\n            statusCode = 2;\\n        } else if (softCapAmount == 0) {\\n            statusCode = 3;\\n        } else if (hardCapAmount == 0) {\\n            statusCode = 4;\\n        } else if (hardCapAmount \\u003c softCapAmount) {\\n            statusCode = 5;\\n        } else if (minChfAmountPerInvestment == 0) {\\n            statusCode = 6;\\n        } else if (investmentPhases.length == 0) {\\n            statusCode = 9;\\n        }\\n        return statusCode;\\n    }\\n\\n    /**\\n     * @dev there is no direct way to convert an enum to string\\n     */\\n    function resolvePaymentError(TokenStatementValidation validationCode) public pure returns(string memory) {\\n        if (validationCode == TokenStatementValidation.BELOW_MIN_LIMIT) {\\n            return \\\"BELOW_MIN_LIMIT\\\";\\n        } else if (validationCode == TokenStatementValidation.ABOVE_MAX_LIMIT) {\\n            return \\\"ABOVE_MAX_LIMIT\\\";\\n        } else if (validationCode == TokenStatementValidation.EXCEEDS_HARD_CAP) {\\n            return \\\"EXCEEDS_HARD_CAP\\\";\\n        }\\n    }\\n\\n    /**\\n     * @dev access permissions (onlyPauser) is checked in super function\\n     */\\n    function pause() public {\\n        super.pause();\\n        crowdliExchangeVault.pause();\\n        crowdliKycProvider.pause();\\n    }\\n\\n    /**\\n     * @dev access permissions (onlyPauser) is checked in super function\\n     */\\n    function unpause () public {\\n        super.unpause();\\n        crowdliExchangeVault.unpause();\\n        crowdliKycProvider.unpause();\\n    }\\n\\n    function setBoardComment(bytes32 _boardComment) public onlyDirectorsBoard {\\n        boardComment = _boardComment;\\n    }\\n\\n    function hasPendingVideoVerificationFees(address _investor, bool _hasRequestedBankPayments) private view returns (bool) {\\n        return (crowdliKycProvider.hasVerificationLevel(_investor, CrowdliKYCProvider.VerificationTier.VideoVerified) \\u0026\\u0026 (!paidForVideoVerification[_investor]) \\u0026\\u0026 !hasUnconfirmedPayments(_investor, _hasRequestedBankPayments));\\n    }\\n\\n    function isEntitledForEarlyBird(address _investor, uint tokenAmount, uint _investmentPhaseIndex) private view returns (bool) {\\n        return ((tokenAmount \\u003e= earlyBirdTokensThresholdAmount) \\u0026\\u0026 (currentEarlyBirdInvestorsCount \\u003c earlyBirdInvestorsCount) \\u0026\\u0026 !investorsWithEarlyBird[_investor] \\u0026\\u0026 _investmentPhaseIndex \\u003e= earlyBirdInvestmentPhase);\\n    }\\n\\n    function hasPendingVouchers(address _investor, bool _hasRequestedBankPayments) private view returns (bool) {\\n        return (investorsWithPendingVouchers[_investor] \\u0026\\u0026 !hasUnconfirmedPayments(_investor, _hasRequestedBankPayments));\\n    }\\n\\n    function hasUnconfirmedPayments(address _investor, bool _hasRequestedBankPayments) private view returns (bool) {\\n        return (_hasRequestedBankPayments || crowdliExchangeVault.hasRequestedPayments(_investor));\\n    }\\n\\n    function isEndDateExtendable() public view returns (bool) {\\n        return ((endDateExtensionDecissionDate \\u003e= now) \\u0026\\u0026 (endDateExtensionOffset \\u003e 0));\\n    }\\n\\n    function isCurrentPhaseManuallySwitchable() public view returns(bool) {\\n        return investmentPhases[investmentPhaseIndex].allowManualSwitch;\\n    }\\n\\n    function isLastPhase() public view returns (bool) {\\n        return (investmentPhaseIndex.add(1) \\u003e= investmentPhases.length);\\n    }\\n\\n    function isCurrentPhaseCapReached() public view returns(bool) {\\n        InvestmentPhase memory investmentPhase = investmentPhases[investmentPhaseIndex];\\n        return (investmentPhase.tokensSoldAmount \\u003e= investmentPhase.capAmount);\\n    }\\n\\n    function isHardCapWithinCapThresholdReached() public view returns (bool) {\\n        return (isLastPhase() \\u0026\\u0026 (investmentPhases[investmentPhaseIndex].tokensSoldAmount \\u003e= investmentPhases[investmentPhaseIndex].capAmount.sub(hardCapThresholdAmount)));\\n    }\\n\\n \\tfunction isHardCapReached() public view returns (bool) {\\n        return (isLastPhase() \\u0026\\u0026 (investmentPhases[investmentPhaseIndex].tokensSoldAmount \\u003e= investmentPhases[investmentPhaseIndex].capAmount));\\n    }\\n    \\n    function isSoftCapReached() public view returns (bool) {\\n        return (tokensSoldAmount \\u003e= softCapAmount);\\n    }\\n\\n    function isManuallyClosable() public view returns(bool) {\\n        return(hasState(States.Investment) \\u0026\\u0026 isHardCapWithinCapThresholdReached());\\n    }\\n\\n    function isEndDateReached() public view returns (bool) {\\n        return (now \\u003e endDate);\\n    }\\n\\n    function hasState(States _state) public view returns (bool) {\\n        return (state == _state);\\n    }\\n\\n    /**\\n     * Used by the STO user interface to retrieve the STO statistics with a single call\\n     */\\n    function getStatisticsData() public view returns(uint[] memory) {\\n        uint[] memory result= new uint[](7);\\n        result[0] = softCapAmount;\\n        result[1] = hardCapAmount;\\n        result[2] = weiInvested;\\n        result[3] = chfOverallInvested;\\n        result[4] = eurOverallInvested;\\n        result[5] = tokensSoldAmount;\\n        result[6] = numberOfInvestors;\\n        return result;\\n    }\\n\\n    // ============================================================================================================================================================================================================================   \\n    // Private functions\\n    // ============================================================================================================================================================================================================================v\\n    function nextInvestmentPhase() private returns (bool) {\\n        if (!isLastPhase()) {\\n            // there is a next phase, so we can switch\\n            investmentPhaseIndex = investmentPhaseIndex.add(1);\\n            emit LogInvestmentPhaseSwitched(investmentPhaseIndex);\\n            return false;\\n\\n        } else {\\n            revert(\\\"payment exceeds hard cap\\\");\\n        }\\n    }\\n\\n    function confirmMintedTokensForPayment(uint _paymentId, uint tokenAmountToBuy, Currency _currency) private {\\n        if (Currency.ETH == _currency) {\\n            crowdliExchangeVault.confirmMintedTokensForPayment(_paymentId, tokenAmountToBuy);\\n        }\\n    }\\n\\n    function updateState(States _state) private {\\n        require (_state \\u003e state, \\\"the state can never transit backwards\\\");\\n        state = _state;\\n        emit LogStateChanged(state);\\n    }\\n\\n    function close(bool stoSucessfull) private inState(States.Investment) {\\n        require(hasState(States.Investment), \\\"Requires state Investment\\\");\\n        updateState(States.Finalizing);\\n        emit LogClosed(msg.sender, stoSucessfull);\\n    }\\n\\n    function allocateTokens(AllocationActionType _actionType) private {\\n        for (uint i = 0; i \\u003c tokenAllocations.length;i++) {\\n            if (tokenAllocations[i].actionType == _actionType) {\\n                uint tokensToAllocate = 0;\\n                if (tokenAllocations[i].valueType == AllocationValueType.BPS_OF_TOKENS_SOLD) {\\n                    tokensToAllocate = tokensSoldAmount.mul(tokenAllocations[i].valueAmount).div(10000);\\n                } else if (tokenAllocations[i].valueType == AllocationValueType.FIXED_TOKEN_AMOUNT) {\\n                    tokensToAllocate = tokenAllocations[i].valueAmount;\\n                }\\n                token.mint(tokenAllocations[i].beneficiary, tokensToAllocate);\\n                tokenAllocations[i].isAllocated = true;\\n            }\\n        }\\n    }\\n\\n    function processPayment(address _investor, uint _paymentId, uint _currencyAmount, Currency _currency, uint _exchangeRate, uint _exchangeRateDecimals, bool _hasRequestedBankPayments, bool _isFirstPayment) private {\\n        require(crowdliKycProvider.verificationTiers(_investor) \\u003e CrowdliKYCProvider.VerificationTier.None, \\\"Verification tier not \\u003e 0\\\");\\n\\n        InvestmentPhase storage investmentPhase = investmentPhases[investmentPhaseIndex];\\n        // ============================================================================================\\n        // Step 1: Calculate token statement\\n        // ============================================================================================\\n        TokenStatement memory tokenStatement = calculateTokenStatementStruct(_investor, _currencyAmount, _currency, _exchangeRate, _exchangeRateDecimals, _hasRequestedBankPayments, _isFirstPayment, 0);\\n\\n        // only process if validation code == OK\\n        require(tokenStatement.validationCode == TokenStatementValidation.OK, resolvePaymentError(tokenStatement.validationCode));\\n\\n        // ============================================================================================\\n        // Update the STO states and statistics\\n        // ============================================================================================ \\n        // sum up the tokens sold for the current investment phase\\n        investmentPhase.tokensSoldAmount = investmentPhase.tokensSoldAmount.add(tokenStatement.currentPhaseTokenAmount);\\n\\n        // sum up the amount of tokens sold during the STO\\n        tokensSoldAmount = tokensSoldAmount.add(tokenStatement.currentPhaseTokenAmount);\\n\\n        if (_isFirstPayment) {\\n            allInvestmentsInChf[_investor] = allInvestmentsInChf[_investor].add(tokenStatement.requestedCHF);\\n\\n            if (tokenStatement.feesCHF \\u003e gasCostAmount)\\n\\t        \\tpaidForVideoVerification[_investor] = true;\\n\\n            if (Currency.CHF == _currency) {\\n                chfPerInvestor[_investor] = chfPerInvestor[_investor].add(_currencyAmount);\\n                chfOverallInvested = chfOverallInvested.add(_currencyAmount);\\n            } else if (Currency.EUR == _currency) {\\n                eurPerInvestor[_investor] = eurPerInvestor[_investor].add(_currencyAmount);\\n                eurOverallInvested = eurOverallInvested.add(_currencyAmount);\\n            } else if (Currency.ETH == _currency) {\\n                weiPerInvestor[_investor] = weiPerInvestor[_investor].add(_currencyAmount);\\n                weiInvested = weiInvested.add(_currencyAmount);\\n            }\\n\\n            // update the statistic counting the number of investors involved in a token purchase\\n            if (token.balanceOf(_investor) == 0) {\\n                numberOfInvestors = numberOfInvestors.add(1);\\n            }\\n        }\\n\\n        if (tokenStatement.earlyBirdCreditTokenAmount \\u003e 0) { // earlyBird         \\n        // update early bird investor statistics\\n            currentEarlyBirdInvestorsCount = currentEarlyBirdInvestorsCount.add(1);\\n\\n            // store flag that the investor has received early bird tokens\\n            investorsWithEarlyBird[_investor] = true;\\n        }\\n\\n        if (tokenStatement.voucherCreditTokenAmount \\u003e 0) {\\n            // mark voucher as redeemed for investor\\n            investorsWithPendingVouchers[_investor] = false;\\n        }\\n\\n\\n        // ============================================================================================\\n        // Mint the STO tokens\\n        // ============================================================================================        \\n        token.mint(_investor, tokenStatement.currentPhaseTokenAmount);\\n\\n        if (tokenStatement.nextPhaseBaseAmount \\u003e 0) {\\n            ExecutionType executionType;\\n\\n            executionType = ExecutionType.SplitPayment;\\n\\n            emit LogPaymentConfirmation(_investor, tokenStatement.requestedBase, convertTokenStatementToArray(tokenStatement), _paymentId, _currency, executionType);\\n            confirmMintedTokensForPayment(_paymentId, tokenStatement.currentPhaseTokenAmount, _currency);\\n\\n            // switch to next phase\\n            nextInvestmentPhase();\\n\\n            // process payment in the new phase\\n            processPayment(_investor, _paymentId, tokenStatement.nextPhaseBaseAmount, _currency, _exchangeRate, _exchangeRateDecimals, _hasRequestedBankPayments, false);\\n        } else {\\n\\n            // no further payments to process\\n            emit LogPaymentConfirmation(_investor, tokenStatement.requestedBase, convertTokenStatementToArray(tokenStatement), _paymentId, _currency, ExecutionType.SinglePayment);\\n            confirmMintedTokensForPayment(_paymentId, tokenStatement.currentPhaseTokenAmount, _currency);\\n        }\\n    }\\n\\n    function convertTokenStatementToArray(TokenStatement memory tokenStatement) private pure returns(uint[] memory) {\\n        uint[] memory tokenStatementArray = new uint[](9);\\n        tokenStatementArray[0] = tokenStatement.requestedBase;\\n        tokenStatementArray[1] = tokenStatement.requestedCHF;\\n        tokenStatementArray[2] = tokenStatement.feesCHF;\\n        tokenStatementArray[3] = tokenStatement.currentPhaseDiscount;\\n        tokenStatementArray[4] = tokenStatement.earlyBirdCreditTokenAmount;\\n        tokenStatementArray[5] = tokenStatement.voucherCreditTokenAmount;\\n        tokenStatementArray[6] = tokenStatement.currentPhaseTokenAmount;\\n        tokenStatementArray[7] = tokenStatement.nextPhaseBaseAmount;\\n        tokenStatementArray[8] = uint(tokenStatement.validationCode);\\n        return tokenStatementArray;\\n    }\\n\\n    function calculateDiscountUptick(uint _amount, InvestmentPhase memory investmentPhase) private pure returns (uint) {\\n        uint currentRate = uint(10000).sub(investmentPhase.discountBPS);\\n        return _amount.mul(investmentPhase.discountBPS).div(currentRate);\\n    }\\n\\n    function calculateDiscount(uint _amount, InvestmentPhase memory investmentPhase) private pure returns (uint) {\\n        return _amount.mul(investmentPhase.discountBPS).div(10000);\\n    }\\n\\n    function calculateConversionFromBase(uint _currencyAmount, uint _exchangeRate, uint _exchangeRateDecimals) private pure returns (uint) {\\n        return _currencyAmount.mul(_exchangeRate).div(_exchangeRateDecimals);\\n    }\\n\\n    function calculateConversionToBase(uint _currencyAmount, uint _exchangeRate, uint _exchangeRateDecimals) private pure returns (uint) {\\n        return _currencyAmount.mul(_exchangeRateDecimals).div(_exchangeRate);\\n    }\\n\\n    function calculateTokenStatementStruct(address _investor, uint _currencyAmount, Currency _currency, uint256 _exchangeRate, uint256 _exchangeRateDecimals, bool _hasRequestedBankPayments, bool _isFirstPayment, uint _investmentPhaseOffset) private view returns(TokenStatement memory) {\\n        TokenStatement memory tokenStatement;\\n\\n        // the struct containing the data for the current investment phase\\n        uint investmentPhaseWithOffset = investmentPhaseIndex.add(_investmentPhaseOffset);\\n        InvestmentPhase memory investmentPhase = investmentPhases[investmentPhaseWithOffset];\\n\\n        // the requested amount in the currency provided\\n        tokenStatement.requestedBase = _currencyAmount;\\n\\n        // ============================================================================================\\n        // Step 1: Convert requested payment to CHF\\n        // ============================================================================================\\n        if (Currency.CHF == _currency) {\\n            tokenStatement.requestedCHF = tokenStatement.requestedBase;\\n        } else if (Currency.EUR == _currency) {\\n            tokenStatement.requestedCHF = calculateConversionFromBase(tokenStatement.requestedBase, _exchangeRate, _exchangeRateDecimals);\\n        } else if (Currency.ETH == _currency) {\\n            tokenStatement.requestedCHF = calculateConversionFromBase(tokenStatement.requestedBase, _exchangeRate, _exchangeRateDecimals);\\n        } else revert(\\\"Currency not supported\\\");\\n\\n        // the requested amount in the currency provided\\n        tokenStatement.requestedCHF = roundUp(tokenStatement.requestedCHF);\\n\\n        uint investmentNetCHF = tokenStatement.requestedCHF;\\n\\n        // calculate the fees (gas cost always, video verification once, if previously processed)\\n        // we have to make sure that the credits are not recognized twice in case of a split payment\\n        if (_isFirstPayment) {\\n            // ============================================================================================\\n\\t        // Verify/validate investment thresholds\\n\\t        // ============================================================================================\\n\\t        tokenStatement.validationCode = validatePayment(_investor, tokenStatement);\\n \\n            tokenStatement.feesCHF = gasCostAmount;\\n            if (hasPendingVideoVerificationFees(_investor, _hasRequestedBankPayments)) {\\n                tokenStatement.feesCHF = tokenStatement.feesCHF.add(videoVerificationCostAmount);\\n            }\\n            investmentNetCHF = tokenStatement.requestedCHF.sub(tokenStatement.feesCHF);\\n        }\\n\\n        // check whether the payment can be handled in the current phase OR we have to create a second payment to be executed in the next phase\\n        uint phaseDeltaTokenAmount = investmentPhase.capAmount.sub(investmentPhase.tokensSoldAmount);\\n        tokenStatement.currentPhaseDiscount = roundUp(calculateDiscountUptick(investmentNetCHF, investmentPhase));\\n        uint tokenAmountWithCurrentPhaseDiscount = investmentNetCHF.add(tokenStatement.currentPhaseDiscount);\\n\\n\\n\\n        // create second payment (split) if tokens exceed current phase cap\\n        if (tokenAmountWithCurrentPhaseDiscount \\u003e phaseDeltaTokenAmount) {\\n        \\tif (isLastPhase())\\n            \\ttokenStatement.validationCode = TokenStatementValidation.EXCEEDS_HARD_CAP;\\n        \\n            tokenStatement.currentPhaseTokenAmount = roundUp(phaseDeltaTokenAmount);\\n            tokenStatement.currentPhaseDiscount = roundUp(calculateDiscount(phaseDeltaTokenAmount, investmentPhase));\\n            uint currentPhaseNetTokenAmount = phaseDeltaTokenAmount.sub(tokenStatement.currentPhaseDiscount);\\n            tokenStatement.nextPhaseBaseAmount = calculateConversionToBase(investmentNetCHF.sub(currentPhaseNetTokenAmount), _exchangeRate, _exchangeRateDecimals);\\n        } else {\\n            tokenStatement.currentPhaseDiscount = tokenStatement.currentPhaseDiscount;\\n            tokenStatement.currentPhaseTokenAmount = tokenAmountWithCurrentPhaseDiscount;\\n            tokenStatement.nextPhaseBaseAmount = 0;\\n\\n            // we have to make sure that the credits are not recognized twice in case of a split payment\\n            // the first x investors starting from phase y will receive some bonus tokens\\n            if (isEntitledForEarlyBird(_investor, tokenStatement.currentPhaseTokenAmount, investmentPhaseWithOffset)) {\\n                tokenStatement.earlyBirdCreditTokenAmount = earlyBirdAdditionalTokensAmount;\\n                tokenStatement.currentPhaseTokenAmount = tokenStatement.currentPhaseTokenAmount.add(tokenStatement.earlyBirdCreditTokenAmount);\\n            }\\n            // investor receives some bonus tokens if he has previously redeemed a valid STO voucher\\n            if (hasPendingVouchers(_investor, _hasRequestedBankPayments)) {\\n                tokenStatement.voucherCreditTokenAmount = voucherTokensAmount;\\n                tokenStatement.currentPhaseTokenAmount = tokenStatement.currentPhaseTokenAmount.add(tokenStatement.voucherCreditTokenAmount);\\n            }\\n        }\\n        \\n        // the STO requires to round up the decimals\\n        tokenStatement.currentPhaseTokenAmount = roundUp(tokenStatement.currentPhaseTokenAmount);\\n        return tokenStatement;\\n    }\\n\\n    function validatePayment(address _investor, TokenStatement memory tokenStatement) private view returns(TokenStatementValidation) {\\n        if (tokenStatement.requestedCHF \\u003c minChfAmountPerInvestment) {\\n            // a single investment (token purchase) musn\\u0027t be below the defined min. token amount threshold\\n            return TokenStatementValidation.BELOW_MIN_LIMIT; // a single investment (token purchase) musn\\u0027t exceed the max token amount per KYC Verification Tier\\n        } else if (allInvestmentsInChf[_investor].add(tokenStatement.requestedCHF) \\u003e crowdliKycProvider.getMaxChfAmountForInvestor(_investor)) {\\n            // a single investment (token purchase) musn\\u0027t exceed the max token amount per KYC Verification Tier \\n            return TokenStatementValidation.ABOVE_MAX_LIMIT;\\n        } else return TokenStatementValidation.OK;\\n\\n    }\\n    \\n    function isStartRequired() private view returns(bool) {\\n    \\treturn ((now \\u003e saleStartDate) \\u0026\\u0026 state == States.PrepareInvestment);\\n    }\\n    \\n    function startInternal() private {\\n    \\trequire(validate() == 0, \\\"Start validation failed\\\");\\n        saleStartDate = now;\\n        updateState(States.Investment);\\n        emit LogStarted(msg.sender);\\n    }\\n\\n    function roundUp(uint amount) private pure returns(uint) {\\n        uint decimals = 10 ** 18;\\n        uint result = amount;\\n        uint remainder = amount % decimals;\\n        if (remainder \\u003e 0) {\\n            result = amount - remainder + decimals;\\n        }\\n        return result;\\n    }\\n}\\n\"},\"CrowdliToken.sol\":{\"content\":\"pragma solidity 0.5.0;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ERC20Detailed.sol\\\";\\nimport \\\"./ERC20Mintable.sol\\\";\\nimport \\\"./ERC20Pausable.sol\\\";\\n\\n/**\\n* @title CrowdliToken\\n*/\\ncontract CrowdliToken is ERC20Detailed, ERC20Mintable, ERC20Pausable, Ownable {\\n\\t/**\\n\\t * Holds the addresses of the investors\\n\\t */\\n    address[] public investors;\\n\\n    constructor (string memory _name, string memory _symbol, uint8 _decimals) ERC20Detailed(_name,_symbol,_decimals) public {\\n    }\\n    \\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\\n         if (balanceOf(account) == 0) {\\n            investors.push(account);\\n         }\\n         return super.mint(account, amount);\\n    }\\n    \\n    \\n    function initToken(address _directorsBoard,address _crowdliSTO) external onlyOwner{\\n    \\taddMinter(_directorsBoard);\\n    \\taddMinter(_crowdliSTO);\\n    \\taddPauser(_directorsBoard);\\n    \\taddPauser(_crowdliSTO);\\n    }\\n    \\n}\\n\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the `IERC20` interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using `_mint`.\\n * For a generic mechanism see `ERC20Mintable`.\\n *\\n * *For a detailed writeup see our guide [How to implement supply\\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See `IERC20.approve`.\\n */\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See `IERC20.totalSupply`.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.balanceOf`.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transfer`.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.allowance`.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See `IERC20.approve`.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transferFrom`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of `ERC20`;\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `value`.\\n     * - the caller must have allowance for `sender`\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to `transfer`, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a `Transfer` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount);\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a `Transfer` event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n     /**\\n     * @dev Destoys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a `Transfer` event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an `Approval` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller\\u0027s allowance.\\n     *\\n     * See `_burn` and `_approve`.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\\n    }\\n}\\n\"},\"ERC20Capped.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20Mintable.sol\\\";\\n\\n/**\\n * @dev Extension of `ERC20Mintable` that adds a cap to the supply of tokens.\\n */\\ncontract ERC20Capped is ERC20Mintable {\\n    uint256 private _cap;\\n\\n    /**\\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\\n     * set once during construction.\\n     */\\n    constructor (uint256 cap) public {\\n        require(cap \\u003e 0, \\\"ERC20Capped: cap is 0\\\");\\n        _cap = cap;\\n    }\\n\\n    /**\\n     * @dev Returns the cap on the token\\u0027s total supply.\\n     */\\n    function cap() public view returns (uint256) {\\n        return _cap;\\n    }\\n\\n    /**\\n     * @dev See `ERC20Mintable.mint`.\\n     *\\n     * Requirements:\\n     *\\n     * - `value` must not cause the total supply to go over the cap.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        require(totalSupply().add(value) \\u003c= _cap, \\\"ERC20Capped: cap exceeded\\\");\\n        super._mint(account, value);\\n    }\\n}\\n\"},\"ERC20Detailed.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Optional functions from the ERC20 standard.\\n */\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * \\u003e Note that this information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * `IERC20.balanceOf` and `IERC20.transfer`.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"},\"ERC20Mintable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./MinterRole.sol\\\";\\n\\n/**\\n * @dev Extension of `ERC20` that adds a set of accounts with the `MinterRole`,\\n * which have permission to mint (create) new tokens as they see fit.\\n *\\n * At construction, the deployer of the contract is the only minter.\\n */\\ncontract ERC20Mintable is ERC20, MinterRole {\\n    /**\\n     * @dev See `ERC20._mint`.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MinterRole`.\\n     */\\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\\n        _mint(account, amount);\\n        return true;\\n    }\\n}\\n\"},\"ERC20Pausable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\n\\n/**\\n * @title Pausable token\\n * @dev ERC20 modified with pausable transfers.\\n */\\ncontract ERC20Pausable is ERC20, Pausable {\\n    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\\n        return super.transfer(to, value);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\\n        return super.transferFrom(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\\n        return super.approve(spender, value);\\n    }\\n\\n    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool) {\\n        return super.increaseAllowance(spender, addedValue);\\n    }\\n\\n    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool) {\\n        return super.decreaseAllowance(spender, subtractedValue);\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"MinterRole.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Roles.sol\\\";\\n\\ncontract MinterRole {\\n    using Roles for Roles.Role;\\n\\n    event MinterAdded(address indexed account);\\n    event MinterRemoved(address indexed account);\\n\\n    Roles.Role private _minters;\\n\\n    constructor () internal {\\n        _addMinter(msg.sender);\\n    }\\n\\n    modifier onlyMinter() {\\n        require(isMinter(msg.sender), \\\"MinterRole: caller does not have the Minter role\\\");\\n        _;\\n    }\\n\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters.has(account);\\n    }\\n\\n    function addMinter(address account) public onlyMinter {\\n        _addMinter(account);\\n    }\\n\\n    function renounceMinter() public {\\n        _removeMinter(msg.sender);\\n    }\\n\\n    function _addMinter(address account) internal {\\n        _minters.add(account);\\n        emit MinterAdded(account);\\n    }\\n\\n    function _removeMinter(address account) internal {\\n        _minters.remove(account);\\n        emit MinterRemoved(account);\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * \\u003e Note: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"Pausable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./PauserRole.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\ncontract Pausable is PauserRole {\\n    /**\\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\\n     * to the deployer.\\n     */\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!_paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     */\\n    modifier whenPaused() {\\n        require(_paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Called by a pauser to pause, triggers stopped state.\\n     */\\n    function pause() public onlyPauser whenNotPaused {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Called by a pauser to unpause, returns to normal state.\\n     */\\n    function unpause() public onlyPauser whenPaused {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"},\"PauserRole.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Roles.sol\\\";\\n\\ncontract PauserRole {\\n    using Roles for Roles.Role;\\n\\n    event PauserAdded(address indexed account);\\n    event PauserRemoved(address indexed account);\\n\\n    Roles.Role private _pausers;\\n\\n    constructor () internal {\\n        _addPauser(msg.sender);\\n    }\\n\\n    modifier onlyPauser() {\\n        require(isPauser(msg.sender), \\\"PauserRole: caller does not have the Pauser role\\\");\\n        _;\\n    }\\n\\n    function isPauser(address account) public view returns (bool) {\\n        return _pausers.has(account);\\n    }\\n\\n    function addPauser(address account) public onlyPauser {\\n        _addPauser(account);\\n    }\\n\\n    function renouncePauser() public {\\n        _removePauser(msg.sender);\\n    }\\n\\n    function _addPauser(address account) internal {\\n        _pausers.add(account);\\n        emit PauserAdded(account);\\n    }\\n\\n    function _removePauser(address account) internal {\\n        _pausers.remove(account);\\n        emit PauserRemoved(account);\\n    }\\n}\\n\"},\"Roles.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address =\\u003e bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account\\u0027s access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length \\u003e 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\"},\"SignerRole.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Roles.sol\\\";\\n\\ncontract SignerRole {\\n    using Roles for Roles.Role;\\n\\n    event SignerAdded(address indexed account);\\n    event SignerRemoved(address indexed account);\\n\\n    Roles.Role private _signers;\\n\\n    constructor () internal {\\n        _addSigner(msg.sender);\\n    }\\n\\n    modifier onlySigner() {\\n        require(isSigner(msg.sender), \\\"SignerRole: caller does not have the Signer role\\\");\\n        _;\\n    }\\n\\n    function isSigner(address account) public view returns (bool) {\\n        return _signers.has(account);\\n    }\\n\\n    function addSigner(address account) public onlySigner {\\n        _addSigner(account);\\n    }\\n\\n    function renounceSigner() public {\\n        _removeSigner(msg.sender);\\n    }\\n\\n    function _addSigner(address account) internal {\\n        _signers.add(account);\\n        emit SignerAdded(account);\\n    }\\n\\n    function _removeSigner(address account) internal {\\n        _signers.remove(account);\\n        emit SignerRemoved(account);\\n    }\\n}\\n\"},\"WhitelistAdminRole.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Roles.sol\\\";\\n\\n/**\\n * @title WhitelistAdminRole\\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\\n */\\ncontract WhitelistAdminRole {\\n    using Roles for Roles.Role;\\n\\n    event WhitelistAdminAdded(address indexed account);\\n    event WhitelistAdminRemoved(address indexed account);\\n\\n    Roles.Role private _whitelistAdmins;\\n\\n    constructor () internal {\\n        _addWhitelistAdmin(msg.sender);\\n    }\\n\\n    modifier onlyWhitelistAdmin() {\\n        require(isWhitelistAdmin(msg.sender), \\\"WhitelistAdminRole: caller does not have the WhitelistAdmin role\\\");\\n        _;\\n    }\\n\\n    function isWhitelistAdmin(address account) public view returns (bool) {\\n        return _whitelistAdmins.has(account);\\n    }\\n\\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\\n        _addWhitelistAdmin(account);\\n    }\\n\\n    function renounceWhitelistAdmin() public {\\n        _removeWhitelistAdmin(msg.sender);\\n    }\\n\\n    function _addWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.add(account);\\n        emit WhitelistAdminAdded(account);\\n    }\\n\\n    function _removeWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.remove(account);\\n        emit WhitelistAdminRemoved(account);\\n    }\\n}\\n\"},\"WhitelistedRole.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Roles.sol\\\";\\nimport \\\"./WhitelistAdminRole.sol\\\";\\n\\n/**\\n * @title WhitelistedRole\\n * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\\n * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\\n * it), and not Whitelisteds themselves.\\n */\\ncontract WhitelistedRole is WhitelistAdminRole {\\n    using Roles for Roles.Role;\\n\\n    event WhitelistedAdded(address indexed account);\\n    event WhitelistedRemoved(address indexed account);\\n\\n    Roles.Role private _whitelisteds;\\n\\n    modifier onlyWhitelisted() {\\n        require(isWhitelisted(msg.sender), \\\"WhitelistedRole: caller does not have the Whitelisted role\\\");\\n        _;\\n    }\\n\\n    function isWhitelisted(address account) public view returns (bool) {\\n        return _whitelisteds.has(account);\\n    }\\n\\n    function addWhitelisted(address account) public onlyWhitelistAdmin {\\n        _addWhitelisted(account);\\n    }\\n\\n    function removeWhitelisted(address account) public onlyWhitelistAdmin {\\n        _removeWhitelisted(account);\\n    }\\n\\n    function renounceWhitelisted() public {\\n        _removeWhitelisted(msg.sender);\\n    }\\n\\n    function _addWhitelisted(address account) internal {\\n        _whitelisteds.add(account);\\n        emit WhitelistedAdded(account);\\n    }\\n\\n    function _removeWhitelisted(address account) internal {\\n        _whitelisteds.remove(account);\\n        emit WhitelistedRemoved(account);\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getExchangeOrdersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"hasRequestedPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdliSTO\",\"type\":\"address\"}],\"name\":\"setCrowdliSTO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"paymentId\",\"type\":\"uint256\"},{\"name\":\"_mintedTokens\",\"type\":\"uint256\"}],\"name\":\"confirmMintedTokensForPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestPayment\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nrRequestedPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_orderIndex\",\"type\":\"uint64\"},{\"name\":\"_exchangeRate\",\"type\":\"uint256\"}],\"name\":\"confirmOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paymentIds\",\"type\":\"uint256[]\"}],\"name\":\"rejectPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"date\",\"type\":\"uint64\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"name\":\"pendingTokens\",\"type\":\"uint256\"},{\"name\":\"mintedTokens\",\"type\":\"uint256\"},{\"name\":\"exchangeRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEtherPaymentsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getExchangeOrdersToPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeWallet\",\"type\":\"address\"},{\"name\":\"_paymentsToAccept\",\"type\":\"uint256[]\"}],\"name\":\"createOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_directorsBoard\",\"type\":\"address\"},{\"name\":\"_crowdliSTO\",\"type\":\"address\"}],\"name\":\"initExchangeVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"exchangeOrders\",\"outputs\":[{\"name\":\"exchangeRate\",\"type\":\"uint256\"},{\"name\":\"date\",\"type\":\"uint64\"},{\"name\":\"exchangeWallet\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paymentConfirmer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"refundPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_paymentConfirmer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"PaymentsEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"PaymentsDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"EtherPaymentRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"paymentIndex\",\"type\":\"uint256\"}],\"name\":\"EtherPaymentRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherPaymentIndex\",\"type\":\"uint256\"}],\"name\":\"EtherPaymentRejected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogGasUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"etherPaymentIndex\",\"type\":\"uint256\"}],\"name\":\"EtherPaymentPurchaseFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payments\",\"type\":\"uint256[]\"}],\"name\":\"OrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"etherPaymentIndex\",\"type\":\"uint256\"}],\"name\":\"OrderConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CrowdliExchangeVault","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000aa39d13816885c7e8d6d2446e2dced8cbab3c065","Library":"","SwarmSource":"bzzr://01e2c5fc2252eb52e1c397afe1936aece7ffc4b43d0acfa71b87ba959a0f23ab"}]}