{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\n\r\ninterface RegistryInterface {\r\n    function proxies(address) external view returns (address);\r\n}\r\n\r\ninterface UserWalletInterface {\r\n    function owner() external view returns (address);\r\n}\r\n\r\ninterface TubInterface {\r\n    function open() external returns (bytes32);\r\n    function join(uint) external;\r\n    function exit(uint) external;\r\n    function lock(bytes32, uint) external;\r\n    function free(bytes32, uint) external;\r\n    function draw(bytes32, uint) external;\r\n    function wipe(bytes32, uint) external;\r\n    function give(bytes32, address) external;\r\n    function shut(bytes32) external;\r\n    function cups(bytes32) external view returns (address, uint, uint, uint);\r\n    function gem() external view returns (ERC20Interface);\r\n    function gov() external view returns (ERC20Interface);\r\n    function skr() external view returns (ERC20Interface);\r\n    function sai() external view returns (ERC20Interface);\r\n    function ink(bytes32) external view returns (uint);\r\n    function tab(bytes32) external returns (uint);\r\n    function rap(bytes32) external returns (uint);\r\n    function per() external view returns (uint);\r\n    function pep() external view returns (PepInterface);\r\n}\r\n\r\ninterface PepInterface {\r\n    function peek() external returns (bytes32, bool);\r\n}\r\n\r\ninterface ERC20Interface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface UniswapExchange {\r\n    function getEthToTokenOutputPrice(uint256 tokensBought) external view returns (uint256 ethSold);\r\n    function getTokenToEthOutputPrice(uint256 ethBought) external view returns (uint256 tokensSold);\r\n    function tokenToTokenSwapOutput(\r\n        uint256 tokensBought,\r\n        uint256 maxTokensSold,\r\n        uint256 maxEthSold,\r\n        uint256 deadline,\r\n        address tokenAddr\r\n        ) external returns (uint256  tokensSold);\r\n}\r\n\r\ninterface CTokenInterface {\r\n    function mint(uint mintAmount) external returns (uint); // For ERC20\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    function balanceOf(address) external view returns (uint);\r\n}\r\n\r\ninterface CETHInterface {\r\n    function mint() external payable; // For ETH\r\n    function transfer(address, uint) external returns (bool);\r\n}\r\n\r\ninterface CDAIInterface {\r\n    function mint(uint mintAmount) external returns (uint); // For ERC20\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n}\r\n\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        c = a - b;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Helper is DSMath {\r\n\r\n    address public ethAddr = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address public daiAddr = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\r\n    address public registry = 0x498b3BfaBE9F73db90D252bCD4Fa9548Cd0Fd981;\r\n    address public sai = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;\r\n    address public ume = 0x2C4Bd064b998838076fa341A83d007FC2FA50957; // Uniswap Maker Exchange\r\n    address public ude = 0x09cabEC1eAd1c0Ba254B09efb3EE13841712bE14; // Uniswap DAI Exchange\r\n    address public cEth = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\r\n    address public cDai = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;\r\n\r\n    address public feeOne = 0xd8db02A498E9AFbf4A32BC006DC1940495b4e592;\r\n    address public feeTwo = 0xa7615CD307F323172331865181DC8b80a2834324;\r\n\r\n    /**\r\n     * @dev setting allowance to compound for the \"user proxy\" if required\r\n     */\r\n    function setApproval(address erc20, uint srcAmt, address to) internal {\r\n        ERC20Interface erc20Contract = ERC20Interface(erc20);\r\n        uint tokenAllowance = erc20Contract.allowance(address(this), to);\r\n        if (srcAmt > tokenAllowance) {\r\n            erc20Contract.approve(to, 2**255);\r\n        }\r\n    }\r\n\r\n    function setAllowance(ERC20Interface _token, address _spender) internal {\r\n        if (_token.allowance(address(this), _spender) != uint(-1)) {\r\n            _token.approve(_spender, uint(-1));\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract CompoundResolver is Helper {\r\n\r\n    /**\r\n     * @dev Redeem ETH/ERC20 and mint Compound Tokens\r\n     * @param tokenAmt Amount of token To Redeem\r\n     */\r\n    function redeemUnderlying(address cErc20, uint tokenAmt) internal {\r\n        if (tokenAmt > 0) {\r\n            require(CTokenInterface(cErc20).redeemUnderlying(tokenAmt) == 0, \"something went wrong\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit ETH/ERC20 and mint Compound Tokens\r\n     */\r\n    function mintCETH(uint ethAmt) internal {\r\n        if (ethAmt > 0) {\r\n            CETHInterface cToken = CETHInterface(cEth);\r\n            cToken.mint.value(ethAmt)();\r\n            uint exchangeRate = CTokenInterface(cEth).exchangeRateCurrent();\r\n            uint cEthToReturn = wdiv(ethAmt, exchangeRate);\r\n            cEthToReturn = wmul(cEthToReturn, exchangeRate) <= ethAmt ? cEthToReturn : cEthToReturn - 1;\r\n            require(cToken.transfer(msg.sender, cEthToReturn), \"CETH Transfer failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit ETH/ERC20 and mint Compound Tokens\r\n     */\r\n    function fetchCETH(uint ethAmt) internal {\r\n        if (ethAmt > 0) {\r\n            CTokenInterface cToken = CTokenInterface(cEth);\r\n            uint exchangeRate = cToken.exchangeRateCurrent();\r\n            uint cTokenAmt = wdiv(ethAmt, exchangeRate);\r\n            cTokenAmt = wmul(cTokenAmt, exchangeRate) <= ethAmt ? cTokenAmt : cTokenAmt - 1;\r\n            require(ERC20Interface(cEth).transferFrom(msg.sender, address(this), cTokenAmt), \"Contract Approved?\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev If col/debt > user's balance/borrow. Then set max\r\n     */\r\n    function checkCompound(uint ethAmt, uint daiAmt) internal returns (uint ethCol, uint daiDebt) {\r\n        CTokenInterface cEthContract = CTokenInterface(cEth);\r\n        uint cEthBal = cEthContract.balanceOf(msg.sender);\r\n        uint ethExchangeRate = cEthContract.exchangeRateCurrent();\r\n        ethCol = wmul(cEthBal, ethExchangeRate);\r\n        ethCol = wdiv(ethCol, ethExchangeRate) <= cEthBal ? ethCol : ethCol - 1;\r\n        ethCol = ethCol <= ethAmt ? ethCol : ethAmt; // Set Max if amount is greater than the Col user have\r\n\r\n        daiDebt = CDAIInterface(cDai).borrowBalanceCurrent(msg.sender);\r\n        daiDebt = daiDebt <= daiAmt ? daiDebt : daiAmt; // Set Max if amount is greater than the Debt user have\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract MakerResolver is CompoundResolver {\r\n\r\n    event LogOpen(uint cdpNum, address owner);\r\n    event LogWipe(uint cdpNum, uint daiAmt, uint mkrFee, uint daiFee, address owner);\r\n\r\n    function open() internal returns (uint) {\r\n        bytes32 cup = TubInterface(sai).open();\r\n        emit LogOpen(uint(cup), address(this));\r\n        return uint(cup);\r\n    }\r\n\r\n    /**\r\n     * @dev transfer CDP ownership\r\n     */\r\n    function give(uint cdpNum, address nextOwner) internal {\r\n        TubInterface(sai).give(bytes32(cdpNum), nextOwner);\r\n    }\r\n\r\n    function wipe(uint cdpNum, uint _wad) internal returns (uint daiAmt) {\r\n        if (_wad > 0) {\r\n            TubInterface tub = TubInterface(sai);\r\n            UniswapExchange daiEx = UniswapExchange(ude);\r\n            UniswapExchange mkrEx = UniswapExchange(ume);\r\n            ERC20Interface dai = tub.sai();\r\n            ERC20Interface mkr = tub.gov();\r\n\r\n            bytes32 cup = bytes32(cdpNum);\r\n\r\n            (address lad,,,) = tub.cups(cup);\r\n            require(lad == address(this), \"cup-not-owned\");\r\n\r\n            setAllowance(dai, sai);\r\n            setAllowance(mkr, sai);\r\n            setAllowance(dai, ude);\r\n\r\n            (bytes32 val, bool ok) = tub.pep().peek();\r\n\r\n            // MKR required for wipe = Stability fees accrued in Dai / MKRUSD value\r\n            uint mkrFee = wdiv(rmul(_wad, rdiv(tub.rap(cup), tub.tab(cup))), uint(val));\r\n\r\n            uint daiFeeAmt = daiEx.getTokenToEthOutputPrice(mkrEx.getEthToTokenOutputPrice(mkrFee));\r\n            daiAmt = add(_wad, daiFeeAmt);\r\n\r\n            redeemUnderlying(cDai, daiAmt);\r\n\r\n            if (ok && val != 0) {\r\n                daiEx.tokenToTokenSwapOutput(\r\n                    mkrFee,\r\n                    daiAmt,\r\n                    uint(999000000000000000000),\r\n                    uint(1899063809), // 6th March 2030 GMT // no logic\r\n                    address(mkr)\r\n                );\r\n            }\r\n\r\n            tub.wipe(cup, _wad);\r\n\r\n            emit LogWipe(\r\n                cdpNum,\r\n                daiAmt,\r\n                mkrFee,\r\n                daiFeeAmt,\r\n                address(this)\r\n            );\r\n\r\n        }\r\n    }\r\n\r\n    function free(uint cdpNum, uint jam) internal {\r\n        if (jam > 0) {\r\n            bytes32 cup = bytes32(cdpNum);\r\n            address tubAddr = sai;\r\n\r\n            TubInterface tub = TubInterface(tubAddr);\r\n            ERC20Interface peth = tub.skr();\r\n            ERC20Interface weth = tub.gem();\r\n\r\n            uint ink = rdiv(jam, tub.per());\r\n            ink = rmul(ink, tub.per()) <= jam ? ink : ink - 1;\r\n            tub.free(cup, ink);\r\n\r\n            setAllowance(peth, tubAddr);\r\n\r\n            tub.exit(ink);\r\n            uint freeJam = weth.balanceOf(address(this)); // withdraw possible previous stuck WETH as well\r\n            weth.withdraw(freeJam);\r\n        }\r\n    }\r\n\r\n    function lock(uint cdpNum, uint ethAmt) internal {\r\n        if (ethAmt > 0) {\r\n            bytes32 cup = bytes32(cdpNum);\r\n            address tubAddr = sai;\r\n\r\n            TubInterface tub = TubInterface(tubAddr);\r\n            ERC20Interface weth = tub.gem();\r\n            ERC20Interface peth = tub.skr();\r\n\r\n            (address lad,,,) = tub.cups(cup);\r\n            require(lad == address(this), \"cup-not-owned\");\r\n\r\n            weth.deposit.value(ethAmt)();\r\n\r\n            uint ink = rdiv(ethAmt, tub.per());\r\n            ink = rmul(ink, tub.per()) <= ethAmt ? ink : ink - 1;\r\n\r\n            setAllowance(weth, tubAddr);\r\n            tub.join(ink);\r\n\r\n            setAllowance(peth, tubAddr);\r\n            tub.lock(cup, ink);\r\n        }\r\n    }\r\n\r\n    function draw(uint cdpNum, uint _wad) internal {\r\n        bytes32 cup = bytes32(cdpNum);\r\n        if (_wad > 0) {\r\n            TubInterface tub = TubInterface(sai);\r\n\r\n            tub.draw(cup, _wad);\r\n        }\r\n    }\r\n\r\n    function checkCDP(bytes32 cup, uint ethAmt, uint daiAmt) internal returns (uint ethCol, uint daiDebt) {\r\n        TubInterface tub = TubInterface(sai);\r\n        ethCol = rmul(tub.ink(cup), tub.per()); // get ETH col from PETH col\r\n        daiDebt = tub.tab(cup);\r\n        daiDebt = daiAmt < daiDebt ? daiAmt : daiDebt; // if DAI amount > max debt. Set max debt\r\n        ethCol = ethAmt < ethCol ? ethAmt : ethCol; // if ETH amount > max Col. Set max col\r\n    }\r\n\r\n    function wipeAndFree(uint cdpNum, uint jam, uint _wad) internal returns (uint daiAmt) {\r\n        daiAmt = wipe(cdpNum, _wad);\r\n        free(cdpNum, jam);\r\n    }\r\n\r\n    function lockAndDraw(uint cdpNum, uint jam, uint _wad) internal {\r\n        lock(cdpNum, jam);\r\n        draw(cdpNum, _wad);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract BridgeResolver is MakerResolver {\r\n\r\n    event LogMakerToCompound(uint cdpNum, uint ethAmt, uint daiAmt, uint fees, address owner);\r\n    event LogCompoundToMaker(uint cdpNum, uint ethAmt, uint daiAmt, uint fees, address owner);\r\n\r\n    /**\r\n     * @dev initiated from user wallet to reimburse temporary DAI debt\r\n     */\r\n    function refillFunds(uint daiDebt) external {\r\n        if (daiDebt > 0) {\r\n            require(ERC20Interface(daiAddr).transferFrom(msg.sender, address(this), daiDebt), \"Contract Approved?\");\r\n            assert(CDAIInterface(cDai).mint(daiDebt) == 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev paying back users debt\r\n     */\r\n    function payUserDebt(uint daiDebt) internal {\r\n        if (daiDebt > 0) {\r\n            redeemUnderlying(cDai, daiDebt);\r\n            require(CDAIInterface(cDai).repayBorrowBehalf(msg.sender, daiDebt) == 0, \"Enough DAI?\");\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract LiquidityProvider is BridgeResolver {\r\n\r\n    mapping (address => uint) public deposits; // amount of CDAI deposits\r\n    uint public totalDeposits;\r\n\r\n    /**\r\n     * @dev Deposit DAI for liquidity\r\n     */\r\n    function depositDAI(uint amt) public {\r\n        require(ERC20Interface(daiAddr).transferFrom(msg.sender, address(this), amt), \"Nothing to deposit\");\r\n        CTokenInterface cToken = CTokenInterface(cDai);\r\n        assert(cToken.mint(amt) == 0);\r\n        uint exchangeRate = cToken.exchangeRateCurrent();\r\n        uint cDaiAmt = wdiv(amt, exchangeRate);\r\n        cDaiAmt = wmul(cDaiAmt, exchangeRate) <= amt ? cDaiAmt : cDaiAmt - 1;\r\n        deposits[msg.sender] += cDaiAmt;\r\n        totalDeposits += cDaiAmt;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw DAI from liquidity\r\n     */\r\n    function withdrawDAI(uint amt) public {\r\n        require(deposits[msg.sender] != 0, \"Nothing to Withdraw\");\r\n        CTokenInterface cToken = CTokenInterface(cDai);\r\n        uint exchangeRate = cToken.exchangeRateCurrent();\r\n        uint withdrawAmt = wdiv(amt, exchangeRate);\r\n        uint daiAmt = amt;\r\n        if (withdrawAmt > deposits[msg.sender]) {\r\n            withdrawAmt = deposits[msg.sender];\r\n            daiAmt = wmul(withdrawAmt, exchangeRate);\r\n        }\r\n        require(cToken.redeem(withdrawAmt) == 0, \"something went wrong\");\r\n        require(ERC20Interface(daiAddr).transfer(msg.sender, daiAmt), \"Dai Transfer failed\");\r\n        deposits[msg.sender] -= withdrawAmt;\r\n        totalDeposits -= withdrawAmt;\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit CDAI for liquidity\r\n     */\r\n    function depositCDAI(uint amt) public {\r\n        CTokenInterface cToken = CTokenInterface(cDai);\r\n        require(cToken.transferFrom(msg.sender, address(this), amt) == true, \"Nothing to deposit\");\r\n        deposits[msg.sender] += amt;\r\n        totalDeposits += amt;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw CDAI from liquidity\r\n     */\r\n    function withdrawCDAI(uint amt) public {\r\n        require(deposits[msg.sender] != 0, \"Nothing to Withdraw\");\r\n        uint withdrawAmt = amt;\r\n        if (withdrawAmt > deposits[msg.sender]) {\r\n            withdrawAmt = deposits[msg.sender];\r\n        }\r\n        require(CTokenInterface(cDai).transfer(msg.sender, withdrawAmt), \"Dai Transfer failed\");\r\n        deposits[msg.sender] -= withdrawAmt;\r\n        totalDeposits -= withdrawAmt;\r\n    }\r\n\r\n    /**\r\n     * collecting fees generated overtime\r\n     */\r\n    function withdrawFeesInCDai(uint num) public {\r\n        CTokenInterface cToken = CTokenInterface(cDai);\r\n        uint cDaiBal = cToken.balanceOf(address(this));\r\n        uint withdrawAmt = sub(cDaiBal, totalDeposits);\r\n        if (num == 0) {\r\n            require(cToken.transfer(feeOne, withdrawAmt), \"Dai Transfer failed\");\r\n        } else {\r\n            require(cToken.transfer(feeTwo, withdrawAmt), \"Dai Transfer failed\");\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Bridge is LiquidityProvider {\r\n\r\n    /**\r\n     * FOR SECURITY PURPOSE\r\n     * checks if only InstaDApp contract wallets can access the bridge\r\n     */\r\n    modifier isUserWallet {\r\n        address userAdd = UserWalletInterface(msg.sender).owner();\r\n        address walletAdd = RegistryInterface(registry).proxies(userAdd);\r\n        require(walletAdd != address(0), \"not-user-wallet\");\r\n        require(walletAdd == msg.sender, \"not-wallet-owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev MakerDAO to Compound\r\n     */\r\n    function makerToCompound(uint cdpId, uint ethCol, uint daiDebt) public payable isUserWallet returns (uint daiAmt) {\r\n        uint ethAmt;\r\n        (ethAmt, daiAmt) = checkCDP(bytes32(cdpId), ethCol, daiDebt);\r\n        daiAmt = wipeAndFree(cdpId, ethAmt, daiAmt);\r\n        uint fees = wmul(daiAmt, 2000000000000000);\r\n        daiAmt = wmul(daiAmt, 1002000000000000000); // 0.2% fees\r\n        mintCETH(ethAmt);\r\n        give(cdpId, msg.sender);\r\n        emit LogMakerToCompound(\r\n            cdpId,\r\n            ethAmt,\r\n            daiAmt,\r\n            fees,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Compound to MakerDAO\r\n     */\r\n    function compoundToMaker(uint cdpId, uint ethCol, uint daiDebt) public payable isUserWallet {\r\n        (uint ethAmt, uint daiAmt) = checkCompound(ethCol, daiDebt);\r\n        payUserDebt(daiAmt);\r\n        fetchCETH(ethAmt);\r\n        redeemUnderlying(cEth, ethAmt);\r\n        uint cdpNum = cdpId > 0 ? cdpId : open();\r\n        uint fees = wmul(daiAmt, 2000000000000000);\r\n        daiAmt = wmul(daiAmt, 1002000000000000000); // 0.2% fees\r\n        lockAndDraw(cdpNum, ethAmt, daiAmt);\r\n        if (daiAmt > 0) {\r\n            assert(CDAIInterface(cDai).mint(daiAmt) == 0);\r\n        }\r\n        give(cdpNum, msg.sender);\r\n        emit LogCompoundToMaker(\r\n            cdpNum,\r\n            ethAmt,\r\n            daiAmt,\r\n            fees,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract MakerCompoundBridge is Bridge {\r\n\r\n    /**\r\n     * @dev setting up all required token approvals\r\n     */\r\n    constructor() public {\r\n        setApproval(daiAddr, 10**30, cDai);\r\n        setApproval(cDai, 10**30, cDai);\r\n        setApproval(cEth, 10**30, cEth);\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdrawCDAI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"depositDAI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ude\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeOne\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ume\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daiAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"uint256\"},{\"name\":\"ethCol\",\"type\":\"uint256\"},{\"name\":\"daiDebt\",\"type\":\"uint256\"}],\"name\":\"makerToCompound\",\"outputs\":[{\"name\":\"daiAmt\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"depositCDAI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sai\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdrawDAI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cDai\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cEth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cdpId\",\"type\":\"uint256\"},{\"name\":\"ethCol\",\"type\":\"uint256\"},{\"name\":\"daiDebt\",\"type\":\"uint256\"}],\"name\":\"compoundToMaker\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"withdrawFeesInCDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTwo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"daiDebt\",\"type\":\"uint256\"}],\"name\":\"refillFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fees\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogMakerToCompound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fees\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogCompoundToMaker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdpNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mkrFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogWipe\",\"type\":\"event\"}]","ContractName":"MakerCompoundBridge","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://232eef2291f1c5fd8ee1e8822551b4509a30fed64a426f119823a11d308127fd"}]}