{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ncontract MinterRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    constructor () internal {\r\n        _addMinter(msg.sender);\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(msg.sender);\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title ERC1400 security token standard\r\n * @dev ERC1400 logic\r\n */\r\ninterface IERC1400  {\r\n\r\n    // Document Management\r\n    // @leonod commented to save opcodes\r\n    //function getDocument(bytes32 name) external view returns (string memory, bytes32); // 1/9\r\n    // @leonod commented to save opcodes\r\n    //function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external; // 2/9\r\n    // @leonod commented to save opcodes\r\n    //event Document(bytes32 indexed name, string uri, bytes32 documentHash);\r\n\r\n    // Controller Operation\r\n    function isControllable() external view returns (bool); // 3/9\r\n\r\n    // Token Issuance\r\n    function isIssuable() external view returns (bool); // 4/9\r\n    function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data) external; // 5/9\r\n    event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\r\n\r\n    // Token Redemption\r\n    function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data) external; // 6/9\r\n    function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData) external; // 7/9\r\n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\r\n\r\n    // Transfer Validity\r\n    function canTransferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external view returns (byte, bytes32, bytes32); // 8/9\r\n    // @leonod commented to save opcodes\r\n    //function canOperatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external view returns (byte, bytes32, bytes32); // 9/9\r\n\r\n}\r\n\r\n/**\r\n * Reason codes - ERC1066\r\n *\r\n * To improve the token holder experience, canTransfer MUST return a reason byte code\r\n * on success or failure based on the EIP-1066 application-specific status codes specified below.\r\n * An implementation can also return arbitrary data as a bytes32 to provide additional\r\n * information not captured by the reason code.\r\n *\r\n * Code\tReason\r\n * 0xA0\tTransfer Verified - Unrestricted\r\n * 0xA1\tTransfer Verified - On-Chain approval for restricted token\r\n * 0xA2\tTransfer Verified - Off-Chain approval for restricted token\r\n * 0xA3\tTransfer Blocked - Sender lockup period not ended\r\n * 0xA4\tTransfer Blocked - Sender balance insufficient\r\n * 0xA5\tTransfer Blocked - Sender not eligible\r\n * 0xA6\tTransfer Blocked - Receiver not eligible\r\n * 0xA7\tTransfer Blocked - Identity restriction\r\n * 0xA8\tTransfer Blocked - Token restriction\r\n * 0xA9\tTransfer Blocked - Token granularity\r\n */\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400Partition partially fungible token standard\r\n * @dev ERC1400Partition interface\r\n */\r\ninterface IERC1400Partition {\r\n\r\n    // Token Information\r\n    function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256); // 1/10\r\n    function partitionsOf(address tokenHolder) external view returns (bytes32[] memory); // 2/10\r\n\r\n    // Token Transfers\r\n    function transferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external returns (bytes32); // 3/10\r\n    function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32); // 4/10\r\n\r\n    // Default Partition Management\r\n    function getDefaultPartitions() external view returns (bytes32[] memory); // 5/10\r\n    function setDefaultPartitions(bytes32[] calldata partitions) external; // 6/10\r\n\r\n    // Operators\r\n    function controllersByPartition(bytes32 partition) external view returns (address[] memory); // 7/10\r\n    function authorizeOperatorByPartition(bytes32 partition, address operator) external; // 8/10\r\n    function revokeOperatorByPartition(bytes32 partition, address operator) external; // 9/10\r\n    function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool); // 10/10\r\n\r\n    // Transfer Events\r\n    event TransferByPartition(\r\n        bytes32 indexed fromPartition,\r\n        address operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    event ChangedPartition(\r\n        bytes32 indexed fromPartition,\r\n        bytes32 indexed toPartition,\r\n        uint256 value\r\n    );\r\n\r\n    // Operator Events\r\n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\ncontract ERC1820Registry {\r\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\r\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address);\r\n    function setManager(address _addr, address _newManager) external;\r\n    function getManager(address _addr) public view returns (address);\r\n}\r\n\r\n\r\n/// Base client to interact with the registry.\r\ncontract ERC1820Client {\r\n    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    function setInterfaceImplementation(string memory _interfaceLabel, address _implementation) internal {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        ERC1820REGISTRY.setInterfaceImplementer(address(this), interfaceHash, _implementation);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string memory _interfaceLabel) internal view returns(address) {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\r\n    }\r\n\r\n    function delegateManagement(address _newManager) internal {\r\n        ERC1820REGISTRY.setManager(address(this), _newManager);\r\n    }\r\n}\r\n\r\ncontract CertificateController {\r\n\r\n  // Address used by off-chain controller service to sign certificate\r\n  mapping(address => bool) internal _certificateSigners;\r\n\r\n  // A nonce used to ensure a certificate can be used only once\r\n  mapping(address => uint256) internal _checkCount;\r\n\r\n  event Checked(address sender);\r\n\r\n  constructor(address _certificateSigner) public {\r\n    _setCertificateSigner(_certificateSigner, true);\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to protect methods with certificate control\r\n   */\r\n  modifier isValidCertificate(bytes memory data) {\r\n\r\n    require(_certificateSigners[msg.sender] || _checkCertificate(data, msg.sig, bytes32(_checkCount[msg.sender])), \"A3: Transfer Blocked - Sender lockup period not ended\");\r\n\r\n    _checkCount[msg.sender] += 1; // Increment sender check count\r\n\r\n    emit Checked(msg.sender);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Get number of transations already sent to this contract by the sender\r\n   * @param sender Address whom to check the counter of.\r\n   * @return uint256 Number of transaction already sent to this contract.\r\n   */\r\n  function checkCount(address sender) external view returns (uint256) {\r\n    return _checkCount[sender];\r\n  }\r\n\r\n  /**\r\n   * @dev Get certificate signer authorization for an operator.\r\n   * @param operator Address whom to check the certificate signer authorization for.\r\n   * @return bool 'true' if operator is authorized as certificate signer, 'false' if not.\r\n   */\r\n  function certificateSigners(address operator) external view returns (bool) {\r\n    return _certificateSigners[operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Set signer authorization for operator.\r\n   * @param operator Address to add/remove as a certificate signer.\r\n   * @param authorized 'true' if operator shall be accepted as certificate signer, 'false' if not.\r\n   */\r\n  function _setCertificateSigner(address operator, bool authorized) internal {\r\n    require(operator != address(0), \"Action Blocked - Not a valid address\");\r\n    _certificateSigners[operator] = authorized;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if a certificate is correct\r\n   * @param signature The signature for the nonce and the functionID (contains v, r, s)\r\n   * @param function_id The id of the function which use is restricted to certificate owners\r\n   * @param nonce A nonce signed along with the functionID so that the certificate cannot be used twice\r\n   */\r\n   function _checkCertificate(bytes memory signature, bytes4 function_id, bytes32 nonce) internal view returns(bool) {\r\n       require(signature.length == 65, \"A valid signature containing (v, r, s) is needed.\");\r\n\r\n       // ecrecover() expects a message starting with that.. \r\n       bytes32 tmp_hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", function_id, nonce));\r\n       uint8 v = uint8(signature[0]);\r\n       bytes32 r = bytes32(0);\r\n       bytes32 s = bytes32(0);\r\n\r\n       // r is the [1:33] elements of the signature and s the [33:65], so we add 0x20 + 1 to pass the\r\n       // array size (on 32 bytes) + the first element, and another 0x20 to get to the 33th element.\r\n       assembly {\r\n            r := mload(add(signature, 0x21))\r\n            s := mload(add(signature, 0x41))\r\n       }\r\n       assert(r != bytes32(0) && s != bytes32(0));\r\n\r\n       // Cf https://ethereum.github.io/yellowpaper/paper.pdf Appendix F\r\n       if (v != 27 && v != 28) {\r\n           return false;\r\n       }\r\n\r\n       // Cf https://ethereum.github.io/yellowpaper/paper.pdf Appendix F\r\n       if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n           return false;\r\n       }\r\n\r\n       return _certificateSigners[ecrecover(tmp_hash, v, r, s)];\r\n   }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400Raw token standard\r\n * @dev ERC1400Raw interface\r\n */\r\ninterface IERC1400Raw {\r\n\r\n  function name() external view returns (string memory); // 1/13\r\n  function symbol() external view returns (string memory); // 2/13\r\n  function totalSupply() external view returns (uint256); // 3/13\r\n  function balanceOf(address owner) external view returns (uint256); // 4/13\r\n  function granularity() external view returns (uint256); // 5/13\r\n\r\n  function controllers() external view returns (address[] memory); // 6/13\r\n  function authorizeOperator(address operator) external; // 7/13\r\n  function revokeOperator(address operator) external; // 8/13\r\n  function isOperator(address operator, address tokenHolder) external view returns (bool); // 9/13\r\n\r\n  function transferWithData(address to, uint256 value, bytes calldata data) external; // 10/13\r\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external; // 11/13\r\n\r\n  function redeem(uint256 value, bytes calldata data) external; // 12/13\r\n  function redeemFrom(address from, uint256 value, bytes calldata data, bytes calldata operatorData) external; // 13/13\r\n\r\n  event TransferWithData(\r\n    address indexed operator,\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value,\r\n    bytes data,\r\n    bytes operatorData\r\n  );\r\n  event Issued(address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\r\n  event Redeemed(address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\r\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400TokensSender\r\n * @dev ERC1400TokensSender interface\r\n */\r\ninterface IERC1400TokensSender {\r\n\r\n  function canTransfer(\r\n    bytes32 partition,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external view returns(bool);\r\n\r\n  function tokensToTransfer(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external;\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400TokensRecipient\r\n * @dev ERC1400TokensRecipient interface\r\n */\r\ninterface IERC1400TokensRecipient {\r\n\r\n  function canReceive(\r\n    bytes32 partition,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external view returns(bool);\r\n\r\n  function tokensReceived(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  ) external;\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC1400Raw\r\n * @dev ERC1400Raw logic\r\n */\r\ncontract ERC1400Raw is IERC1400Raw, Ownable, ERC1820Client, CertificateController, ReentrancyGuard {\r\n  using SafeMath for uint256;\r\n\r\n  string internal _name;\r\n  string internal _symbol;\r\n  uint256 internal _granularity;\r\n  uint256 internal _totalSupply;\r\n\r\n  // Indicate whether the token can still be controlled by operators or not anymore.\r\n  bool internal _isControllable;\r\n\r\n  // Mapping from tokenHolder to balance.\r\n  mapping(address => uint256) internal _balances;\r\n\r\n  /******************** Mappings related to operator **************************/\r\n  // Mapping from (operator, tokenHolder) to authorized status. [TOKEN-HOLDER-SPECIFIC]\r\n  mapping(address => mapping(address => bool)) internal _authorizedOperator;\r\n\r\n  // Array of controllers. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\r\n  address[] internal _controllers;\r\n\r\n  // Mapping from operator to controller status. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\r\n  mapping(address => bool) internal _isController;\r\n  /****************************************************************************/\r\n\r\n  /**\r\n   * [ERC1400Raw CONSTRUCTOR]\r\n   * @dev Initialize ERC1400Raw and CertificateController parameters + register\r\n   * the contract implementation in ERC1820Registry.\r\n   * @param name Name of the token.\r\n   * @param symbol Symbol of the token.\r\n   * @param granularity Granularity of the token.\r\n   * @param controllers Array of initial controllers.\r\n   * @param certificateSigner Address of the off-chain service which signs the\r\n   * conditional ownership certificates required for token transfers, issuance,\r\n   * redemption (Cf. CertificateController.sol).\r\n   */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 granularity,\r\n    address[] memory controllers,\r\n    address certificateSigner\r\n  )\r\n    public\r\n    CertificateController(certificateSigner)\r\n  {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _totalSupply = 0;\r\n    require(granularity >= 1); // Constructor Blocked - Token granularity can not be lower than 1\r\n    _granularity = granularity;\r\n\r\n    _setControllers(controllers);\r\n  }\r\n\r\n  /********************** ERC1400Raw EXTERNAL FUNCTIONS ***************************/\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (1/13)]\r\n   * @dev Get the name of the token, e.g., \"MyToken\".\r\n   * @return Name of the token.\r\n   */\r\n  function name() external view returns(string memory) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (2/13)]\r\n   * @dev Get the symbol of the token, e.g., \"MYT\".\r\n   * @return Symbol of the token.\r\n   */\r\n  function symbol() external view returns(string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (3/13)]\r\n   * @dev Get the total number of issued tokens.\r\n   * @return Total supply of tokens currently in circulation.\r\n   */\r\n  function totalSupply() external view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (4/13)]\r\n   * @dev Get the balance of the account with address 'tokenHolder'.\r\n   * @param tokenHolder Address for which the balance is returned.\r\n   * @return Amount of token held by 'tokenHolder' in the token contract.\r\n   */\r\n  function balanceOf(address tokenHolder) external view returns (uint256) {\r\n    return _balances[tokenHolder];\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (5/13)]\r\n   * @dev Get the smallest part of the token that’s not divisible.\r\n   * @return The smallest non-divisible part of the token.\r\n   */\r\n  function granularity() external view returns(uint256) {\r\n    return _granularity;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (6/13)]\r\n   * @dev Get the list of controllers as defined by the token contract.\r\n   * @return List of addresses of all the controllers.\r\n   */\r\n  function controllers() external view returns (address[] memory) {\r\n    return _controllers;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (7/13)]\r\n   * @dev Set a third party operator address as an operator of 'msg.sender' to transfer\r\n   * and redeem tokens on its behalf.\r\n   * @param operator Address to set as an operator for 'msg.sender'.\r\n   */\r\n  function authorizeOperator(address operator) external {\r\n    require(operator != msg.sender);\r\n    _authorizedOperator[operator][msg.sender] = true;\r\n    emit AuthorizedOperator(operator, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (8/13)]\r\n   * @dev Remove the right of the operator address to be an operator for 'msg.sender'\r\n   * and to transfer and redeem tokens on its behalf.\r\n   * @param operator Address to rescind as an operator for 'msg.sender'.\r\n   */\r\n  function revokeOperator(address operator) external {\r\n    require(operator != msg.sender);\r\n    _authorizedOperator[operator][msg.sender] = false;\r\n    emit RevokedOperator(operator, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (9/13)]\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder address.\r\n   * @param operator Address which may be an operator of tokenHolder.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator.\r\n   * @return 'true' if operator is an operator of 'tokenHolder' and 'false' otherwise.\r\n   */\r\n  function isOperator(address operator, address tokenHolder) external view returns (bool) {\r\n    return _isOperator(operator, tokenHolder);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (10/13)]\r\n   * @dev Transfer the amount of tokens from the address 'msg.sender' to the address 'to'.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function transferWithData(address to, uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _transferWithData(\"\", msg.sender, msg.sender, to, value, data, \"\", true);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (11/13)]\r\n   * @dev Transfer the amount of tokens on behalf of the address 'from' to the address 'to'.\r\n   * @param from Token holder (or 'address(0)' to set from to 'msg.sender').\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, and intended for the token holder ('from').\r\n   * @param operatorData Information attached to the transfer by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    require(_isOperator(msg.sender, from), \"A7\"); // Transfer Blocked - Identity restriction\r\n\r\n    _transferWithData(\"\", msg.sender, from, to, value, data, operatorData, true);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (12/13)]\r\n   * @dev Redeem the amount of tokens from the address 'msg.sender'.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeem(uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _redeem(\"\", msg.sender, msg.sender, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Raw INTERFACE (13/13)]\r\n   * @dev Redeem the amount of tokens on behalf of the address from.\r\n   * @param from Token holder whose tokens will be redeemed (or address(0) to set from to msg.sender).\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeemFrom(address from, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    require(_isOperator(msg.sender, from), \"A7\"); // Transfer Blocked - Identity restriction\r\n\r\n    _redeem(\"\", msg.sender, from, value, data, operatorData);\r\n  }\r\n\r\n  /********************** ERC1400Raw INTERNAL FUNCTIONS ***************************/\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Check if 'value' is multiple of the granularity.\r\n   * @param value The quantity that want's to be checked.\r\n   * @return 'true' if 'value' is a multiple of the granularity.\r\n   */\r\n  function _isMultiple(uint256 value) internal view returns(bool) {\r\n    return(value.div(_granularity).mul(_granularity) == value);\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Check whether an address is a regular address or not.\r\n   * @param addr Address of the contract that has to be checked.\r\n   * @return 'true' if 'addr' is a regular address (not a contract).\r\n   */\r\n  function _isRegularAddress(address addr) internal view returns(bool) {\r\n    if (addr == address(0)) { return false; }\r\n    uint size;\r\n    assembly { size := extcodesize(addr) } // solhint-disable-line no-inline-assembly\r\n    return size == 0;\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder address.\r\n   * @param operator Address which may be an operator of 'tokenHolder'.\r\n   * @param tokenHolder Address of a token holder which may have the 'operator' address as an operator.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' and 'false' otherwise.\r\n   */\r\n  function _isOperator(address operator, address tokenHolder) internal view returns (bool) {\r\n    return (operator == tokenHolder\r\n      || _authorizedOperator[operator][tokenHolder]\r\n      || (_isControllable && _isController[operator])\r\n    );\r\n  }\r\n\r\n   /**\r\n    * [INTERNAL]\r\n    * @dev Perform the transfer of tokens.\r\n    * @param partition Name of the partition (bytes32 to be left empty for ERC1400Raw transfer).\r\n    * @param operator The address performing the transfer.\r\n    * @param from Token holder.\r\n    * @param to Token recipient.\r\n    * @param value Number of tokens to transfer.\r\n    * @param data Information attached to the transfer.\r\n    * @param operatorData Information attached to the transfer by the operator (if any)..\r\n    * @param preventLocking 'true' if you want this function to throw when tokens are sent to a contract not\r\n    * implementing 'erc777tokenHolder'.\r\n    * ERC1400Raw native transfer functions MUST set this parameter to 'true', and backwards compatible ERC20 transfer\r\n    * functions SHOULD set this parameter to 'false'.\r\n    */\r\n  function _transferWithData(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData,\r\n    bool preventLocking\r\n  )\r\n    internal\r\n    nonReentrant\r\n  {\r\n    require(_isMultiple(value), \"A9\"); // Transfer Blocked - Token granularity\r\n    require(to != address(0), \"A6\"); // Transfer Blocked - Receiver not eligible\r\n    require(_balances[from] >= value, \"A4\"); // Transfer Blocked - Sender balance insufficient\r\n\r\n    _callSender(partition, operator, from, to, value, data, operatorData);\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n\r\n    _callRecipient(partition, operator, from, to, value, data, operatorData, preventLocking);\r\n\r\n    emit TransferWithData(operator, from, to, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Perform the token redemption.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC1400Raw transfer).\r\n   * @param operator The address performing the redemption.\r\n   * @param from Token holder whose tokens will be redeemed.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator (if any).\r\n   */\r\n  function _redeem(bytes32 partition, address operator, address from, uint256 value, bytes memory data, bytes memory operatorData)\r\n    internal\r\n    nonReentrant\r\n  {\r\n    require(_isMultiple(value), \"A9\"); // Transfer Blocked - Token granularity\r\n    require(from != address(0), \"A5\"); // Transfer Blocked - Sender not eligible\r\n    require(_balances[from] >= value, \"A4\"); // Transfer Blocked - Sender balance insufficient\r\n\r\n    _callSender(partition, operator, from, address(0), value, data, operatorData);\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _totalSupply = _totalSupply.sub(value);\r\n\r\n    emit Redeemed(operator, from, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Check for 'ERC1400TokensSender' hook on the sender and call it.\r\n   * May throw according to 'preventLocking'.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC1400Raw transfer).\r\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\r\n   * @param from Token holder.\r\n   * @param to Token recipient for a transfer and 0x for a redemption.\r\n   * @param value Number of tokens the token holder balance is decreased by.\r\n   * @param data Extra information.\r\n   * @param operatorData Extra information, attached by the operator (if any).\r\n   */\r\n  function _callSender(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    address senderImplementation;\r\n    senderImplementation = interfaceAddr(from, \"ERC1400TokensSender\");\r\n\r\n    if (senderImplementation != address(0)) {\r\n      IERC1400TokensSender(senderImplementation).tokensToTransfer(partition, operator, from, to, value, data, operatorData);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Check for 'ERC1400TokensRecipient' hook on the recipient and call it.\r\n   * May throw according to 'preventLocking'.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC1400Raw transfer).\r\n   * @param operator Address which triggered the balance increase (through transfer or issuance).\r\n   * @param from Token holder for a transfer and 0x for an issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens the recipient balance is increased by.\r\n   * @param data Extra information, intended for the token holder ('from').\r\n   * @param operatorData Extra information attached by the operator (if any).\r\n   * @param preventLocking 'true' if you want this function to throw when tokens are sent to a contract not\r\n   * implementing 'ERC1400TokensRecipient'.\r\n   * ERC1400Raw native transfer functions MUST set this parameter to 'true', and backwards compatible ERC20 transfer\r\n   * functions SHOULD set this parameter to 'false'.\r\n   */\r\n  function _callRecipient(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData,\r\n    bool preventLocking\r\n  )\r\n    internal\r\n  {\r\n    address recipientImplementation;\r\n    recipientImplementation = interfaceAddr(to, \"ERC1400TokensRecipient\");\r\n\r\n    if (recipientImplementation != address(0)) {\r\n      IERC1400TokensRecipient(recipientImplementation).tokensReceived(partition, operator, from, to, value, data, operatorData);\r\n    } else if (preventLocking) {\r\n      require(_isRegularAddress(to), \"A6\"); // Transfer Blocked - Receiver not eligible\r\n    }\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Perform the issuance of tokens.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC1400Raw transfer).\r\n   * @param operator Address which triggered the issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance, and intended for the recipient (to).\r\n   * @param operatorData Information attached to the issuance by the operator (if any).\r\n   */\r\n  function _issue(bytes32 partition, address operator, address to, uint256 value, bytes memory data, bytes memory operatorData) internal nonReentrant {\r\n    require(_isMultiple(value), \"A9\"); // Transfer Blocked - Token granularity\r\n    require(to != address(0), \"A6\"); // Transfer Blocked - Receiver not eligible\r\n\r\n    _totalSupply = _totalSupply.add(value);\r\n    _balances[to] = _balances[to].add(value);\r\n\r\n    _callRecipient(partition, operator, address(0), to, value, data, operatorData, true);\r\n\r\n    emit Issued(operator, to, value, data, operatorData);\r\n  }\r\n\r\n  /********************** ERC1400Raw OPTIONAL FUNCTIONS ***************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Raw STANDARD]\r\n   * @dev Set list of token controllers.\r\n   * @param operators Controller addresses.\r\n   */\r\n  function _setControllers(address[] memory operators) internal {\r\n    for (uint i = 0; i<_controllers.length; i++){\r\n      _isController[_controllers[i]] = false;\r\n    }\r\n    for (uint j = 0; j<operators.length; j++){\r\n      _isController[operators[j]] = true;\r\n    }\r\n    _controllers = operators;\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC1400Partition\r\n * @dev ERC1400Partition logic\r\n */\r\ncontract ERC1400Partition is IERC1400Partition, ERC1400Raw {\r\n\r\n  /******************** Mappings to find partition ******************************/\r\n  // List of partitions.\r\n  bytes32[] internal _totalPartitions;\r\n\r\n  // Mapping from partition to their index.\r\n  mapping (bytes32 => uint256) internal _indexOfTotalPartitions;\r\n\r\n  // Mapping from partition to global balance of corresponding partition.\r\n  mapping (bytes32 => uint256) internal _totalSupplyByPartition;\r\n\r\n  // Mapping from tokenHolder to their partitions.\r\n  mapping (address => bytes32[]) internal _partitionsOf;\r\n\r\n  // Mapping from (tokenHolder, partition) to their index.\r\n  mapping (address => mapping (bytes32 => uint256)) internal _indexOfPartitionsOf;\r\n\r\n  // Mapping from (tokenHolder, partition) to balance of corresponding partition.\r\n  mapping (address => mapping (bytes32 => uint256)) internal _balanceOfByPartition;\r\n\r\n  // List of token default partitions (for ERC20 compatibility).\r\n  bytes32[] internal _defaultPartitions;\r\n  /****************************************************************************/\r\n\r\n  /**************** Mappings to find partition operators ************************/\r\n  // Mapping from (tokenHolder, partition, operator) to 'approved for partition' status. [TOKEN-HOLDER-SPECIFIC]\r\n  mapping (address => mapping (bytes32 => mapping (address => bool))) internal _authorizedOperatorByPartition;\r\n\r\n  // Mapping from partition to controllers for the partition. [NOT TOKEN-HOLDER-SPECIFIC]\r\n  mapping (bytes32 => address[]) internal _controllersByPartition;\r\n\r\n  // Mapping from (partition, operator) to PartitionController status. [NOT TOKEN-HOLDER-SPECIFIC]\r\n  mapping (bytes32 => mapping (address => bool)) internal _isControllerByPartition;\r\n  /****************************************************************************/\r\n\r\n  /**\r\n   * [ERC1400Partition CONSTRUCTOR]\r\n   * @dev Initialize ERC1400Partition parameters + register\r\n   * the contract implementation in ERC1820Registry.\r\n   * @param name Name of the token.\r\n   * @param symbol Symbol of the token.\r\n   * @param granularity Granularity of the token.\r\n   * @param controllers Array of initial controllers.\r\n   * @param certificateSigner Address of the off-chain service which signs the\r\n   * conditional ownership certificates required for token transfers, issuance,\r\n   * redemption (Cf. CertificateController.sol).\r\n   */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 granularity,\r\n    address[] memory controllers,\r\n    address certificateSigner,\r\n    bytes32[] memory defaultPartitions\r\n  )\r\n    public\r\n    ERC1400Raw(name, symbol, granularity, controllers, certificateSigner)\r\n  {\r\n    _defaultPartitions = defaultPartitions;\r\n  }\r\n\r\n  /********************** ERC1400Partition EXTERNAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (1/10)]\r\n   * @dev Get balance of a tokenholder for a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which the balance is returned.\r\n   * @return Amount of token of partition 'partition' held by 'tokenHolder' in the token contract.\r\n   */\r\n  function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256) {\r\n    return _balanceOfByPartition[tokenHolder][partition];\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (2/10)]\r\n   * @dev Get partitions index of a tokenholder.\r\n   * @param tokenHolder Address for which the partitions index are returned.\r\n   * @return Array of partitions index of 'tokenHolder'.\r\n   */\r\n  function partitionsOf(address tokenHolder) external view returns (bytes32[] memory) {\r\n    return _partitionsOf[tokenHolder];\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (3/10)]\r\n   * @dev Transfer tokens from a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return Destination partition.\r\n   */\r\n  function transferByPartition(\r\n    bytes32 partition,\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  )\r\n    external\r\n    isValidCertificate(data)\r\n    returns (bytes32)\r\n  {\r\n    return _transferByPartition(partition, msg.sender, msg.sender, to, value, data, \"\", true);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (4/10)]\r\n   * @dev Transfer tokens from a specific partition through an operator.\r\n   * @param partition Name of the partition.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return Destination partition.\r\n   */\r\n  function operatorTransferByPartition(\r\n    bytes32 partition,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data,\r\n    bytes calldata operatorData\r\n  )\r\n    external\r\n    isValidCertificate(operatorData)\r\n    returns (bytes32)\r\n  {\r\n    require(_isOperatorForPartition(partition, msg.sender, from), \"A7\"); // Transfer Blocked - Identity restriction\r\n\r\n    return _transferByPartition(partition, msg.sender, from, to, value, data, operatorData, true);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (5/10)]\r\n   * @dev Get default partitions to transfer from.\r\n   * Function used for ERC1400Raw and ERC20 backwards compatibility.\r\n   * For example, a security token may return the bytes32(\"unrestricted\").\r\n   * @return Array of default partitions.\r\n   */\r\n  function getDefaultPartitions() external view returns (bytes32[] memory) {\r\n    return _defaultPartitions;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (6/10)]\r\n   * @dev Set default partitions to transfer from.\r\n   * Function used for ERC1400Raw and ERC20 backwards compatibility.\r\n   * @param partitions partitions to use by default when not specified.\r\n   */\r\n  function setDefaultPartitions(bytes32[] calldata partitions) external onlyOwner {\r\n    _defaultPartitions = partitions;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (7/10)]\r\n   * @dev Get controllers for a given partition.\r\n   * Function used for ERC1400Raw and ERC20 backwards compatibility.\r\n   * @param partition Name of the partition.\r\n   * @return Array of controllers for partition.\r\n   */\r\n  function controllersByPartition(bytes32 partition) external view returns (address[] memory) {\r\n    return _controllersByPartition[partition];\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (8/10)]\r\n   * @dev Set 'operator' as an operator for 'msg.sender' for a given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address to set as an operator for 'msg.sender'.\r\n   */\r\n  function authorizeOperatorByPartition(bytes32 partition, address operator) external {\r\n    _authorizedOperatorByPartition[msg.sender][partition][operator] = true;\r\n    emit AuthorizedOperatorByPartition(partition, operator, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (9/10)]\r\n   * @dev Remove the right of the operator address to be an operator on a given\r\n   * partition for 'msg.sender' and to transfer and redeem tokens on its behalf.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address to rescind as an operator on given partition for 'msg.sender'.\r\n   */\r\n  function revokeOperatorByPartition(bytes32 partition, address operator) external {\r\n    _authorizedOperatorByPartition[msg.sender][partition][operator] = false;\r\n    emit RevokedOperatorByPartition(partition, operator, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400Partition INTERFACE (10/10)]\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder\r\n   * address for the given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address which may be an operator of tokenHolder for the given partition.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\r\n   */\r\n  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool) {\r\n    return _isOperatorForPartition(partition, operator, tokenHolder);\r\n  }\r\n\r\n  /********************** ERC1400Partition INTERNAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Indicate whether the operator address is an operator of the tokenHolder\r\n   * address for the given partition.\r\n   * @param partition Name of the partition.\r\n   * @param operator Address which may be an operator of tokenHolder for the given partition.\r\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\r\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\r\n   */\r\n   function _isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) internal view returns (bool) {\r\n     return (_isOperator(operator, tokenHolder)\r\n       || _authorizedOperatorByPartition[tokenHolder][partition][operator]\r\n       || (_isControllable && _isControllerByPartition[partition][operator])\r\n     );\r\n   }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Transfer tokens from a specific partition.\r\n   * @param fromPartition Partition of the tokens to transfer.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator (if any).\r\n   * @param preventLocking 'true' if you want this function to throw when tokens are sent to a contract not\r\n   * implementing 'erc777tokenHolder'.\r\n   * @return Destination partition.\r\n   */\r\n  function _transferByPartition(\r\n    bytes32 fromPartition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData,\r\n    bool preventLocking\r\n  )\r\n    internal\r\n    returns (bytes32)\r\n  {\r\n    require(_balanceOfByPartition[from][fromPartition] >= value, \"A4\"); // Transfer Blocked - Sender balance insufficient\r\n\r\n    bytes32 toPartition = fromPartition;\r\n\r\n    if(operatorData.length != 0 && data.length >= 64) {\r\n      toPartition = _getDestinationPartition(fromPartition, data);\r\n    }\r\n\r\n    _removeTokenFromPartition(from, fromPartition, value);\r\n    _transferWithData(fromPartition, operator, from, to, value, data, operatorData, preventLocking);\r\n    _addTokenToPartition(to, toPartition, value);\r\n\r\n    emit TransferByPartition(fromPartition, operator, from, to, value, data, operatorData);\r\n\r\n    if(toPartition != fromPartition) {\r\n      emit ChangedPartition(fromPartition, toPartition, value);\r\n    }\r\n\r\n    return toPartition;\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Remove a token from a specific partition.\r\n   * @param from Token holder.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens to transfer.\r\n   */\r\n  function _removeTokenFromPartition(address from, bytes32 partition, uint256 value) internal {\r\n    _balanceOfByPartition[from][partition] = _balanceOfByPartition[from][partition].sub(value);\r\n    _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition].sub(value);\r\n\r\n    // If the total supply is zero, finds and deletes the partition.\r\n    if(_totalSupplyByPartition[partition] == 0) {\r\n      uint256 index1 = _indexOfTotalPartitions[partition];\r\n      require(index1 > 0, \"A8\"); // Transfer Blocked - Token restriction\r\n\r\n      // move the last item into the index being vacated\r\n      bytes32 lastValue = _totalPartitions[_totalPartitions.length - 1];\r\n      _totalPartitions[index1 - 1] = lastValue; // adjust for 1-based indexing\r\n      _indexOfTotalPartitions[lastValue] = index1;\r\n\r\n      _totalPartitions.length -= 1;\r\n      _indexOfTotalPartitions[partition] = 0;\r\n    }\r\n\r\n    // If the balance of the TokenHolder's partition is zero, finds and deletes the partition.\r\n    if(_balanceOfByPartition[from][partition] == 0) {\r\n      uint256 index2 = _indexOfPartitionsOf[from][partition];\r\n      require(index2 > 0, \"A8\"); // Transfer Blocked - Token restriction\r\n\r\n      // move the last item into the index being vacated\r\n      bytes32 lastValue = _partitionsOf[from][_partitionsOf[from].length - 1];\r\n      _partitionsOf[from][index2 - 1] = lastValue;  // adjust for 1-based indexing\r\n      _indexOfPartitionsOf[from][lastValue] = index2;\r\n\r\n      _partitionsOf[from].length -= 1;\r\n      _indexOfPartitionsOf[from][partition] = 0;\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Add a token to a specific partition.\r\n   * @param to Token recipient.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens to transfer.\r\n   */\r\n  function _addTokenToPartition(address to, bytes32 partition, uint256 value) internal {\r\n    if(value != 0) {\r\n      if (_indexOfPartitionsOf[to][partition] == 0) {\r\n        _partitionsOf[to].push(partition);\r\n        _indexOfPartitionsOf[to][partition] = _partitionsOf[to].length;\r\n      }\r\n      _balanceOfByPartition[to][partition] = _balanceOfByPartition[to][partition].add(value);\r\n\r\n      if (_indexOfTotalPartitions[partition] == 0) {\r\n        _totalPartitions.push(partition);\r\n        _indexOfTotalPartitions[partition] = _totalPartitions.length;\r\n      }\r\n      _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition].add(value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Retrieve the destination partition from the 'data' field.\r\n   * By convention, a partition change is requested ONLY when 'data' starts\r\n   * with the flag: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n   * When the flag is detected, the destination tranche is extracted from the\r\n   * 32 bytes following the flag.\r\n   * @param fromPartition Partition of the tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @return Destination partition.\r\n   */\r\n  function _getDestinationPartition(bytes32 fromPartition, bytes memory data) internal pure returns(bytes32 toPartition) {\r\n    bytes32 changePartitionFlag = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    bytes32 flag;\r\n    assembly {\r\n      flag := mload(add(data, 32))\r\n    }\r\n    if(flag == changePartitionFlag) {\r\n      assembly {\r\n        toPartition := mload(add(data, 64))\r\n      }\r\n    } else {\r\n      toPartition = fromPartition;\r\n    }\r\n  }\r\n\r\n  /********************* ERC1400Partition OPTIONAL FUNCTIONS ***************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD]\r\n   * @dev Get list of existing partitions.\r\n   * @return Array of all exisiting partitions.\r\n   */\r\n  function totalPartitions() external view returns (bytes32[] memory) {\r\n    return _totalPartitions;\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD][SHALL BE CALLED ONLY FROM ERC1400]\r\n   * @dev Set list of token partition controllers.\r\n   * @param partition Name of the partition.\r\n   * @param operators Controller addresses.\r\n   */\r\n   function _setPartitionControllers(bytes32 partition, address[] memory operators) internal {\r\n     for (uint i = 0; i<_controllersByPartition[partition].length; i++){\r\n       _isControllerByPartition[partition][_controllersByPartition[partition][i]] = false;\r\n     }\r\n     for (uint j = 0; j<operators.length; j++){\r\n       _isControllerByPartition[partition][operators[j]] = true;\r\n     }\r\n     _controllersByPartition[partition] = operators;\r\n   }\r\n\r\n  /************** ERC1400Raw BACKWARDS RETROCOMPATIBILITY *************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD][OVERRIDES ERC1400Raw METHOD]\r\n   * @dev Transfer the value of tokens from the address 'msg.sender' to the address 'to'.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function transferWithData(address to, uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, data, \"\", true);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD][OVERRIDES ERC1400Raw METHOD]\r\n   * @dev Transfer the value of tokens on behalf of the address from to the address to.\r\n   * @param from Token holder (or 'address(0)'' to set from to 'msg.sender').\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, and intended for the token holder ('from'). [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    require(_isOperator(msg.sender, from), \"A7\"); // Transfer Blocked - Identity restriction\r\n\r\n    _transferByDefaultPartitions(msg.sender, from, to, value, data, operatorData, true);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD][OVERRIDES ERC1400Raw METHOD]\r\n   * @dev Empty function to erase ERC1400Raw redeem() function since it doesn't handle partitions.\r\n   */\r\n  function redeem(uint256 /*value*/, bytes calldata /*data*/) external { // Comments to avoid compilation warnings for unused variables.\r\n    revert(\"A8: Transfer Blocked - Token restriction\");\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD][OVERRIDES ERC1400Raw METHOD]\r\n   * @dev Empty function to erase ERC1400Raw redeemFrom() function since it doesn't handle partitions.\r\n   */\r\n  function redeemFrom(address /*from*/, uint256 /*value*/, bytes calldata /*data*/, bytes calldata /*operatorData*/) external { // Comments to avoid compilation warnings for unused variables.\r\n    revert(\"A8: Transfer Blocked - Token restriction\");\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400Partition STANDARD]\r\n   * @dev Transfer tokens from default partitions.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, and intended for the token holder ('from') [CAN CONTAIN THE DESTINATION PARTITION].\r\n   * @param operatorData Information attached to the transfer by the operator (if any).\r\n   * @param preventLocking 'true' if you want this function to throw when tokens are sent to a contract not\r\n   * implementing 'erc777tokenHolder'.\r\n   */\r\n  function _transferByDefaultPartitions(\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData,\r\n    bool preventLocking\r\n  )\r\n    internal\r\n  {\r\n    require(_defaultPartitions.length != 0, \"A8\"); // Transfer Blocked - Token restriction\r\n\r\n    uint256 _remainingValue = value;\r\n    uint256 _localBalance;\r\n\r\n    for (uint i = 0; i < _defaultPartitions.length; i++) {\r\n      _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\r\n      if(_remainingValue <= _localBalance) {\r\n        _transferByPartition(_defaultPartitions[i], operator, from, to, _remainingValue, data, operatorData, preventLocking);\r\n        _remainingValue = 0;\r\n        break;\r\n      } else if (_localBalance != 0) {\r\n        _transferByPartition(_defaultPartitions[i], operator, from, to, _localBalance, data, operatorData, preventLocking);\r\n        _remainingValue = _remainingValue - _localBalance;\r\n      }\r\n    }\r\n\r\n    require(_remainingValue == 0, \"A8\"); // Transfer Blocked - Token restriction\r\n  }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC1400\r\n * @dev ERC1400 logic\r\n */\r\ncontract ERC1400 is IERC1400, ERC1400Partition, MinterRole {\r\n\r\n  // @leonod commented to save opcodes\r\n  /*struct Doc {\r\n    string docURI;\r\n    bytes32 docHash;\r\n  }*/\r\n\r\n  // Mapping for token URIs.\r\n  // @leonod commented to save opcodes\r\n  //mapping(bytes32 => Doc) internal _documents;\r\n\r\n  // Indicate whether the token can still be issued by the issuer or not anymore.\r\n  bool internal _isIssuable;\r\n\r\n  /**\r\n   * @dev Modifier to verify if token is issuable.\r\n   */\r\n  modifier issuableToken() {\r\n    require(_isIssuable, \"A8\"); // Transfer Blocked - Token restriction\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 CONSTRUCTOR]\r\n   * @dev Initialize ERC1400 + register\r\n   * the contract implementation in ERC1820Registry.\r\n   * @param name Name of the token.\r\n   * @param symbol Symbol of the token.\r\n   * @param granularity Granularity of the token.\r\n   * @param controllers Array of initial controllers.\r\n   * @param certificateSigner Address of the off-chain service which signs the\r\n   * conditional ownership certificates required for token transfers, issuance,\r\n   * redemption (Cf. CertificateController.sol).\r\n   */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 granularity,\r\n    address[] memory controllers,\r\n    address certificateSigner,\r\n    bytes32[] memory defaultPartitions\r\n  )\r\n    public\r\n    ERC1400Partition(name, symbol, granularity, controllers, certificateSigner, defaultPartitions)\r\n  {\r\n    setInterfaceImplementation(\"ERC1400Token\", address(this));\r\n    _isControllable = true;\r\n    _isIssuable = true;\r\n  }\r\n\r\n  /********************** ERC1400 EXTERNAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (1/9)]\r\n   * @dev Access a document associated with the token.\r\n   * @param name Short name (represented as a bytes32) associated to the document.\r\n   * @return Requested document + document hash.\r\n   */\r\n   // @leonod commented to save opcodes\r\n  /*function getDocument(bytes32 name) external view returns (string memory, bytes32) {\r\n    require(bytes(_documents[name].docURI).length != 0); // Action Blocked - Empty document\r\n    return (\r\n      _documents[name].docURI,\r\n      _documents[name].docHash\r\n    );\r\n  }*/\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (2/9)]\r\n   * @dev Associate a document with the token.\r\n   * @param name Short name (represented as a bytes32) associated to the document.\r\n   * @param uri Document content.\r\n   * @param documentHash Hash of the document [optional parameter].\r\n   */\r\n   // @leonod commented to save opcodes\r\n  /*function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external {\r\n    require(_isController[msg.sender]);\r\n    _documents[name] = Doc({\r\n      docURI: uri,\r\n      docHash: documentHash\r\n    });\r\n    emit Document(name, uri, documentHash);\r\n  }*/\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (3/9)]\r\n   * @dev Know if the token can be controlled by operators.\r\n   * If a token returns 'false' for 'isControllable()'' then it MUST always return 'false' in the future.\r\n   * @return bool 'true' if the token can still be controlled by operators, 'false' if it can't anymore.\r\n   */\r\n  function isControllable() external view returns (bool) {\r\n    return _isControllable;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (4/9)]\r\n   * @dev Know if new tokens can be issued in the future.\r\n   * @return bool 'true' if tokens can still be issued by the issuer, 'false' if they can't anymore.\r\n   */\r\n  function isIssuable() external view returns (bool) {\r\n    return _isIssuable;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (5/9)]\r\n   * @dev Issue tokens from a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which we want to issue tokens.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance, by the issuer. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data)\r\n    external\r\n    onlyMinter\r\n    issuableToken\r\n    isValidCertificate(data)\r\n  {\r\n    _issueByPartition(partition, msg.sender, tokenHolder, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (6/9)]\r\n   * @dev Redeem tokens of a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param value Number of tokens redeemed.\r\n   * @param data Information attached to the redemption, by the redeemer. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _redeemByPartition(partition, msg.sender, msg.sender, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (7/9)]\r\n   * @dev Redeem tokens of a specific partition.\r\n   * @param partition Name of the partition.\r\n   * @param tokenHolder Address for which we want to redeem tokens.\r\n   * @param value Number of tokens redeemed.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    require(_isOperatorForPartition(partition, msg.sender, tokenHolder), \"A7\"); // Transfer Blocked - Identity restriction\r\n\r\n    _redeemByPartition(partition, msg.sender, tokenHolder, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (8/9)]\r\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param partition Name of the partition.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n  function canTransferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data)\r\n    external\r\n    view\r\n    returns (byte, bytes32, bytes32)\r\n  {\r\n    // We don't use the modifier here as we check the certificate validity for another function\r\n    if (!_certificateSigners[msg.sender] && !_checkCertificate(data, 0xf3d490db, bytes32(_checkCount[msg.sender]))) { // 4 first bytes of keccak256(transferByPartition(bytes32,address,uint256,bytes))\r\n      return(hex\"A3\", \"\", partition); // Transfer Blocked - Sender lockup period not ended\r\n    } else {\r\n      return _canTransfer(partition, msg.sender, msg.sender, to, value, data, \"\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * [ERC1400 INTERFACE (9/9)]\r\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param partition Name of the partition.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n   // @leonod commented to save opcodes\r\n  /*function canOperatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    view\r\n    returns (byte, bytes32, bytes32)\r\n  {\r\n     @see https://github.com/LeonodTeam/ERC1400\r\n  }*/\r\n\r\n  /********************** ERC1400 INTERNAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\r\n   * @param partition Name of the partition.\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\r\n   * @param operatorData Information attached to the transfer, by the operator (if any).\r\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\r\n   * @return Additional bytes32 parameter that can be used to define\r\n   * application specific reason codes with additional details (for example the\r\n   * transfer restriction rule responsible for making the transfer operation invalid).\r\n   * @return Destination partition.\r\n   */\r\n   function _canTransfer(bytes32 partition, address operator, address from, address to, uint256 value, bytes memory data, bytes memory operatorData)\r\n     internal\r\n     view\r\n     returns (byte, bytes32, bytes32)\r\n   {\r\n     if(!_isOperatorForPartition(partition, operator, from))\r\n       return(hex\"A7\", \"\", partition); // \"Transfer Blocked - Identity restriction\"\r\n\r\n     if((_balances[from] < value) || (_balanceOfByPartition[from][partition] < value))\r\n       return(hex\"A4\", \"\", partition); // Transfer Blocked - Sender balance insufficient\r\n\r\n     if(to == address(0))\r\n       return(hex\"A6\", \"\", partition); // Transfer Blocked - Receiver not eligible\r\n\r\n     address senderImplementation;\r\n     address recipientImplementation;\r\n     senderImplementation = interfaceAddr(from, \"ERC1400TokensSender\");\r\n     recipientImplementation = interfaceAddr(to, \"ERC1400TokensRecipient\");\r\n\r\n     if((senderImplementation != address(0))\r\n       && !IERC1400TokensSender(senderImplementation).canTransfer(partition, from, to, value, data, operatorData))\r\n       return(hex\"A5\", \"\", partition); // Transfer Blocked - Sender not eligible\r\n\r\n     if((recipientImplementation != address(0))\r\n       && !IERC1400TokensRecipient(recipientImplementation).canReceive(partition, from, to, value, data, operatorData))\r\n       return(hex\"A6\", \"\", partition); // Transfer Blocked - Receiver not eligible\r\n\r\n     if(!_isMultiple(value))\r\n       return(hex\"A9\", \"\", partition); // Transfer Blocked - Token granularity\r\n\r\n     return(hex\"A2\", \"\", partition);  // Transfer Verified - Off-Chain approval for restricted token\r\n   }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Issue tokens from a specific partition.\r\n   * @param toPartition Name of the partition.\r\n   * @param operator The address performing the issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to issue.\r\n   * @param data Information attached to the issuance.\r\n   * @param operatorData Information attached to the issuance, by the operator (if any).\r\n   */\r\n  function _issueByPartition(\r\n    bytes32 toPartition,\r\n    address operator,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    _issue(toPartition, operator, to, value, data, operatorData);\r\n    _addTokenToPartition(to, toPartition, value);\r\n\r\n    emit IssuedByPartition(toPartition, operator, to, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n   * [INTERNAL]\r\n   * @dev Redeem tokens of a specific partition.\r\n   * @param fromPartition Name of the partition.\r\n   * @param operator The address performing the redemption.\r\n   * @param from Token holder whose tokens will be redeemed.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator (if any).\r\n   */\r\n  function _redeemByPartition(\r\n    bytes32 fromPartition,\r\n    address operator,\r\n    address from,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    require(_balanceOfByPartition[from][fromPartition] >= value, \"A4\"); // Transfer Blocked - Sender balance insufficient\r\n\r\n    _removeTokenFromPartition(from, fromPartition, value);\r\n    _redeem(fromPartition, operator, from, value, data, operatorData);\r\n\r\n    emit RedeemedByPartition(fromPartition, operator, from, value, data, operatorData);\r\n  }\r\n\r\n  /********************** ERC1400 OPTIONAL FUNCTIONS **************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Definitely renounce the possibility to control tokens on behalf of tokenHolders.\r\n   * Once set to false, '_isControllable' can never be set to 'true' again.\r\n   */\r\n   // @leonod commented to save opcodes\r\n  /*function renounceControl() external onlyOwner {\r\n    _isControllable = false;\r\n  }*/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Definitely renounce the possibility to issue new tokens.\r\n   * Once set to false, '_isIssuable' can never be set to 'true' again.\r\n   */\r\n   // @leonod commented to save opcodes\r\n  /*function renounceIssuance() external onlyOwner {\r\n    _isIssuable = false;\r\n  }*/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Set list of token controllers.\r\n   * @param operators Controller addresses.\r\n   */\r\n  function setControllers(address[] calldata operators) external onlyOwner {\r\n    _setControllers(operators);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Set list of token partition controllers.\r\n   * @param partition Name of the partition.\r\n   * @param operators Controller addresses.\r\n   */\r\n   function setPartitionControllers(bytes32 partition, address[] calldata operators) external onlyOwner {\r\n     _setPartitionControllers(partition, operators);\r\n   }\r\n\r\n   /**\r\n   * @dev Add a certificate signer for the token.\r\n   * @param operator Address to set as a certificate signer.\r\n   * @param authorized 'true' if operator shall be accepted as certificate signer, 'false' if not.\r\n   */\r\n  function setCertificateSigner(address operator, bool authorized) external onlyOwner {\r\n    _setCertificateSigner(operator, authorized);\r\n  }\r\n\r\n  /************* ERC1400Partition/ERC1400Raw BACKWARDS RETROCOMPATIBILITY ******************/\r\n\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD][OVERRIDES ERC1400Partition METHOD]\r\n   * @dev Redeem the value of tokens from the address 'msg.sender'.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption, by the token holder. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeem(uint256 value, bytes calldata data)\r\n    external\r\n    isValidCertificate(data)\r\n  {\r\n    _redeemByDefaultPartitions(msg.sender, msg.sender, value, data, \"\");\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD][OVERRIDES ERC1400Partition METHOD]\r\n   * @dev Redeem the value of tokens on behalf of the address 'from'.\r\n   * @param from Token holder whose tokens will be redeemed (or 'address(0)' to set from to 'msg.sender').\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator. [CONTAINS THE CONDITIONAL OWNERSHIP CERTIFICATE]\r\n   */\r\n  function redeemFrom(address from, uint256 value, bytes calldata data, bytes calldata operatorData)\r\n    external\r\n    isValidCertificate(operatorData)\r\n  {\r\n    require(_isOperator(msg.sender, from), \"A7\"); // Transfer Blocked - Identity restriction\r\n\r\n    _redeemByDefaultPartitions(msg.sender, from, value, data, operatorData);\r\n  }\r\n\r\n  /**\r\n  * [NOT MANDATORY FOR ERC1400Partition STANDARD]\r\n   * @dev Redeem tokens from a default partitions.\r\n   * @param operator The address performing the redeem.\r\n   * @param from Token holder.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption, by the operator (if any).\r\n   */\r\n  function _redeemByDefaultPartitions(\r\n    address operator,\r\n    address from,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData\r\n  )\r\n    internal\r\n  {\r\n    require(_defaultPartitions.length != 0, \"A8\"); // Transfer Blocked - Token restriction\r\n\r\n    uint256 _remainingValue = value;\r\n    uint256 _localBalance;\r\n\r\n    for (uint i = 0; i < _defaultPartitions.length; i++) {\r\n      _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\r\n      if(_remainingValue <= _localBalance) {\r\n        _redeemByPartition(_defaultPartitions[i], operator, from, _remainingValue, data, operatorData);\r\n        _remainingValue = 0;\r\n        break;\r\n      } else {\r\n        _redeemByPartition(_defaultPartitions[i], operator, from, _localBalance, data, operatorData);\r\n        _remainingValue = _remainingValue - _localBalance;\r\n      }\r\n    }\r\n\r\n    require(_remainingValue == 0, \"A8\"); // Transfer Blocked - Token restriction\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC1400ERC20\r\n * @dev ERC1400 with ERC20 retrocompatibility\r\n */\r\ncontract ERC1400ERC20 is IERC20, ERC1400 {\r\n\r\n  // Mapping from (tokenHolder, spender) to allowed value.\r\n  mapping (address => mapping (address => uint256)) internal _allowed;\r\n\r\n  // Mapping from (tokenHolder) to whitelisted status.\r\n  mapping (address => bool) internal _whitelisted;\r\n\r\n  /**\r\n   * @dev Modifier to verify if sender and recipient are whitelisted.\r\n   */\r\n  modifier areWhitelisted(address sender, address recipient) {\r\n    require(_whitelisted[sender], \"A5\"); // Transfer Blocked - Sender not eligible\r\n    require(_whitelisted[recipient], \"A6\"); // Transfer Blocked - Receiver not eligible\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * [ERC1400ERC20 CONSTRUCTOR]\r\n   * @dev Initialize ERC71400ERC20 and CertificateController parameters + register\r\n   * the contract implementation in ERC1820Registry.\r\n   * @param name Name of the token.\r\n   * @param symbol Symbol of the token.\r\n   * @param granularity Granularity of the token.\r\n   * @param controllers Array of initial controllers.\r\n   * @param certificateSigner Address of the off-chain service which signs the\r\n   * conditional ownership certificates required for token transfers, issuance,\r\n   * redemption (Cf. CertificateController.sol).\r\n   */\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 granularity,\r\n    address[] memory controllers,\r\n    address certificateSigner,\r\n    bytes32[] memory tokenDefaultPartitions\r\n  )\r\n    public\r\n    ERC1400(name, symbol, granularity, controllers, certificateSigner, tokenDefaultPartitions)\r\n  {\r\n    setInterfaceImplementation(\"ERC20Token\", address(this));\r\n  }\r\n\r\n  /**\r\n   * [OVERRIDES ERC1400 METHOD]\r\n   * @dev Perform the transfer of tokens.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC1400Raw transfer).\r\n   * @param operator The address performing the transfer.\r\n   * @param from Token holder.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens to transfer.\r\n   * @param data Information attached to the transfer.\r\n   * @param operatorData Information attached to the transfer by the operator (if any).\r\n   * @param preventLocking 'true' if you want this function to throw when tokens are sent to a contract not\r\n   * implementing 'erc777tokenHolder'.\r\n   * ERC1400Raw native transfer functions MUST set this parameter to 'true', and backwards compatible ERC20 transfer\r\n   * functions SHOULD set this parameter to 'false'.\r\n   */\r\n  function _transferWithData(\r\n    bytes32 partition,\r\n    address operator,\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    bytes memory data,\r\n    bytes memory operatorData,\r\n    bool preventLocking\r\n  )\r\n    internal\r\n  {\r\n    ERC1400Raw._transferWithData(partition, operator, from, to, value, data, operatorData, preventLocking);\r\n\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  /**\r\n   * [OVERRIDES ERC1400 METHOD]\r\n   * @dev Perform the token redemption.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC1400Raw transfer).\r\n   * @param operator The address performing the redemption.\r\n   * @param from Token holder whose tokens will be redeemed.\r\n   * @param value Number of tokens to redeem.\r\n   * @param data Information attached to the redemption.\r\n   * @param operatorData Information attached to the redemption by the operator (if any).\r\n   */\r\n  function _redeem(bytes32 partition, address operator, address from, uint256 value, bytes memory data, bytes memory operatorData) internal {\r\n    ERC1400Raw._redeem(partition, operator, from, value, data, operatorData);\r\n\r\n    emit Transfer(from, address(0), value);  //  ERC20 backwards compatibility\r\n  }\r\n\r\n  /**\r\n   * [OVERRIDES ERC1400 METHOD]\r\n   * @dev Perform the issuance of tokens.\r\n   * @param partition Name of the partition (bytes32 to be left empty for ERC1400Raw transfer).\r\n   * @param operator Address which triggered the issuance.\r\n   * @param to Token recipient.\r\n   * @param value Number of tokens issued.\r\n   * @param data Information attached to the issuance.\r\n   * @param operatorData Information attached to the issuance by the operator (if any).\r\n   */\r\n  function _issue(bytes32 partition, address operator, address to, uint256 value, bytes memory data, bytes memory operatorData) internal {\r\n    ERC1400Raw._issue(partition, operator, to, value, data, operatorData);\r\n\r\n    emit Transfer(address(0), to, value); // ERC20 backwards compatibility\r\n  }\r\n\r\n  /**\r\n   * [OVERRIDES ERC1400 METHOD]\r\n   * @dev Get the number of decimals of the token.\r\n   * @return The number of decimals of the token. For Backwards compatibility, decimals are forced to 18 in ERC1400Raw.\r\n   */\r\n  function decimals() external pure returns(uint8) {\r\n    return uint8(18);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Check the value of tokens that an owner allowed to a spender.\r\n   * @param owner address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the value of tokens still available for the spender.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256) {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of 'msg.sender'.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function approve(address spender, uint256 value) external returns (bool) {\r\n    require(spender != address(0), \"A5\"); // Transfer Blocked - Sender not eligible\r\n    _allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Transfer token for a specified address.\r\n   * @param to The address to transfer to.\r\n   * @param value The value to be transferred.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function transfer(address to, uint256 value) external areWhitelisted(msg.sender, to) returns (bool) {\r\n    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, \"\", \"\", false);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400 STANDARD]\r\n   * @dev Transfer tokens from one address to another.\r\n   * @param from The address which you want to transfer tokens from.\r\n   * @param to The address which you want to transfer to.\r\n   * @param value The amount of tokens to be transferred.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function transferFrom(address from, address to, uint256 value) external areWhitelisted(from, to) returns (bool) {\r\n    require( _isOperator(msg.sender, from)\r\n      || (value <= _allowed[from][msg.sender]), \"A7\"); // Transfer Blocked - Identity restriction\r\n\r\n    if(_allowed[from][msg.sender] >= value) {\r\n      _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n    } else {\r\n      _allowed[from][msg.sender] = 0;\r\n    }\r\n\r\n    _transferByDefaultPartitions(msg.sender, from, to, value, \"\", \"\", false);\r\n    return true;\r\n  }\r\n\r\n  /***************** ERC1400ERC20 OPTIONAL FUNCTIONS ***************************/\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400ERC20 STANDARD]\r\n   * @dev Get whitelisted status for a tokenHolder.\r\n   * @param tokenHolder Address whom to check the whitelisted status for.\r\n   * @return bool 'true' if tokenHolder is whitelisted, 'false' if not.\r\n   */\r\n  function whitelisted(address tokenHolder) external view returns (bool) {\r\n    return _whitelisted[tokenHolder];\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400ERC20 STANDARD]\r\n   * @dev Set whitelisted status for a tokenHolder.\r\n   * @param tokenHolder Address to add/remove from whitelist.\r\n   * @param authorized 'true' if tokenHolder shall be added to whitelist, 'false' if not.\r\n   */\r\n  function setWhitelisted(address tokenHolder, bool authorized) external {\r\n    require(_isController[msg.sender]);\r\n    _setWhitelisted(tokenHolder, authorized);\r\n  }\r\n\r\n  /**\r\n   * [NOT MANDATORY FOR ERC1400ERC20 STANDARD]\r\n   * @dev Set whitelisted status for a tokenHolder.\r\n   * @param tokenHolder Address to add/remove from whitelist.\r\n   * @param authorized 'true' if tokenHolder shall be added to whitelist, 'false' if not.\r\n   */\r\n  function _setWhitelisted(address tokenHolder, bool authorized) internal {\r\n    require(tokenHolder != address(0)); // Action Blocked - Not a valid address\r\n    _whitelisted[tokenHolder] = authorized;\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC1400\r\n * @dev ERC1400 logic\r\n */\r\ncontract MWT_token is ERC1400ERC20 {\r\n\r\n  // Some actions might need the actors to be whitelisted in the future\r\n  bool needWhitelisting = false;\r\n\r\n  /**\r\n  * [ERC1400ERC20 CONSTRUCTOR]\r\n  * @dev Initialize ERC71400ERC20 and CertificateController parameters + register\r\n  * the contract implementation in ERC1820Registry.\r\n  * @param name Name of the token.\r\n  * @param symbol Symbol of the token.\r\n  * @param granularity Granularity of the token.\r\n  * @param controllers Array of initial controllers.\r\n  * @param certificateSigner Address of the off-chain service which signs the\r\n  * conditional ownership certificates required for token transfers, issuance,\r\n  * redemption (Cf. CertificateController.sol).\r\n  */\r\n  constructor(\r\n      string memory name,\r\n      string memory symbol,\r\n      uint256 granularity,\r\n      address[] memory controllers,\r\n      address certificateSigner,\r\n      bytes32[] memory tokenDefaultPartitions\r\n  )\r\n      public\r\n      ERC1400ERC20(name, symbol, granularity, controllers, certificateSigner, tokenDefaultPartitions)\r\n  {\r\n  }\r\n\r\n  /**\r\n   * @dev Add this to a function that might reequire involved actors to be whitelisted in the future\r\n   */\r\n  modifier mayNeedWhitelisting(address sender, address recipient) {\r\n    if (needWhitelisting) {\r\n      require(_whitelisted[sender], \"A5\"); //Transfer Blocked - Sender not eligible\r\n      require(_whitelisted[recipient], \"A6\"); //Transfer Blocked - Receiver not eligible\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * === Overrides ERC20 function ===\r\n   * @dev Moves perpetual bonds.\r\n   * @param sender The address from which the tokens should be withdrawn\r\n   * @param recipient The address to which the tokens should be deposit\r\n   * @param amount How many tokens to transfer\r\n   */\r\n  function _transfer(address sender, address recipient, uint256 amount) internal {\r\n    require(sender != address(0), \"A8\"); //Transfer Blocked - Token restriction\r\n    require(recipient != address(0), \"A8\"); //Transfer Blocked - Token restriction\r\n\r\n    bytes32 perpetualPartition = _defaultPartitions[0];\r\n    _balanceOfByPartition[sender][perpetualPartition] = _balanceOfByPartition[sender][perpetualPartition].sub(amount);\r\n    _balanceOfByPartition[recipient][perpetualPartition] = _balanceOfByPartition[recipient][perpetualPartition].add(amount);\r\n\r\n    emit Transfer(sender, recipient, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Enable or disable whitelisting requirement\r\n   * @param needWhitelist True to enable whitelisting requirement\r\n   */\r\n  function setNeedWhitelisting(bool needWhitelist) external onlyOwner {\r\n    needWhitelisting = needWhitelist;\r\n  }\r\n\r\n  /**\r\n   * === Overrides ERC1400raw function ===\r\n   * @dev Get the perpetual balance of the account with address 'tokenHolder', overrides ERC20 and ERC1400Raw balanceOf functions.\r\n   * @param tokenHolder Address for which the perpetual balance is returned.\r\n   * @return Amount of token Perpetual (default partition) held by 'tokenHolder' in the token contract.\r\n   */\r\n  function balanceOf(address tokenHolder) external view returns (uint256) {\r\n    bytes32 perpetualPartition = _defaultPartitions[0];\r\n    return _balanceOfByPartition[tokenHolder][perpetualPartition];\r\n  }\r\n\r\n  /**\r\n   * === Overrides ERC20 function ===\r\n   * @dev Transfer token for a specified address.\r\n   * @param to The address to transfer to.\r\n   * @param value The value to be transferred.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function transfer(address to, uint256 value) external mayNeedWhitelisting(msg.sender, to) returns (bool) {\r\n    _transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Remove the right to mint new tokens.\r\n   */\r\n  function removeMinter(address minter) external onlyOwner {\r\n    _removeMinter(minter);\r\n  }\r\n\r\n  /**\r\n   * Getter to check if whitelist is neeeded to use ERC20-like perpetual bonds\r\n   */\r\n  function needWhitelist() external view returns (bool) {\r\n    return needWhitelisting;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"needWhitelist\",\"type\":\"bool\"}],\"name\":\"setNeedWhitelisting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperatorByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"tokenHolder\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorRedeemByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperatorByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setPartitionControllers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"needWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isIssuable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOfByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isControllable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeemByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"tokenHolder\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"issueByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"checkCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPartitions\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorForPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"certificateSigners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"partitionsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"setCertificateSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controllers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"controllersByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"transferFromWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorTransferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"canTransferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"},{\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"setWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultPartitions\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setControllers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partitions\",\"type\":\"bytes32[]\"}],\"name\":\"setDefaultPartitions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"redeemFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"granularity\",\"type\":\"uint256\"},{\"name\":\"controllers\",\"type\":\"address[]\"},{\"name\":\"certificateSigner\",\"type\":\"address\"},{\"name\":\"tokenDefaultPartitions\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Checked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"TransferWithData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"TransferByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"toPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ChangedPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"IssuedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"RedeemedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"MWT_token","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000140000000000000000000000000f05389715791152d36a5c1a458c5198bc65543b90000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000000000a4c656f6e6f64313430300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034c4e4400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000f05389715791152d36a5c1a458c5198bc65543b900000000000000000000000000000000000000000000000000000000000000017065725f30303030303000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://2d631c65413c99b288b342c1701ff97ddec2c8139dd353552921a64e3d1acf3f"}]}