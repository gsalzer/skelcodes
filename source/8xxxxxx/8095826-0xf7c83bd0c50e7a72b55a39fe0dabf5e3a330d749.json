{"status":"1","message":"OK","result":[{"SourceCode":"// File: @ensdomains/ens/contracts/ENS.sol\r\n\r\npragma solidity >=0.4.24;\r\n\r\ninterface ENS {\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n\r\n}\r\n\r\n// File: @ensdomains/ens/contracts/Deed.sol\r\n\r\npragma solidity >=0.4.24;\r\n\r\ninterface Deed {\r\n\r\n    function setOwner(address payable newOwner) external;\r\n    function setRegistrar(address newRegistrar) external;\r\n    function setBalance(uint newValue, bool throwOnFailure) external;\r\n    function closeDeed(uint refundRatio) external;\r\n    function destroyDeed() external;\r\n\r\n    function owner() external view returns (address);\r\n    function previousOwner() external view returns (address);\r\n    function value() external view returns (uint);\r\n    function creationDate() external view returns (uint);\r\n\r\n}\r\n\r\n// File: @ensdomains/ens/contracts/Registrar.sol\r\n\r\npragma solidity >=0.4.24;\r\n\r\n\r\ninterface Registrar {\r\n\r\n    enum Mode { Open, Auction, Owned, Forbidden, Reveal, NotYetAvailable }\r\n\r\n    event AuctionStarted(bytes32 indexed hash, uint registrationDate);\r\n    event NewBid(bytes32 indexed hash, address indexed bidder, uint deposit);\r\n    event BidRevealed(bytes32 indexed hash, address indexed owner, uint value, uint8 status);\r\n    event HashRegistered(bytes32 indexed hash, address indexed owner, uint value, uint registrationDate);\r\n    event HashReleased(bytes32 indexed hash, uint value);\r\n    event HashInvalidated(bytes32 indexed hash, string indexed name, uint value, uint registrationDate);\r\n\r\n    function state(bytes32 _hash) external view returns (Mode);\r\n    function startAuction(bytes32 _hash) external;\r\n    function startAuctions(bytes32[] calldata _hashes) external;\r\n    function newBid(bytes32 sealedBid) external payable;\r\n    function startAuctionsAndBid(bytes32[] calldata hashes, bytes32 sealedBid) external payable;\r\n    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) external;\r\n    function cancelBid(address bidder, bytes32 seal) external;\r\n    function finalizeAuction(bytes32 _hash) external;\r\n    function transfer(bytes32 _hash, address payable newOwner) external;\r\n    function releaseDeed(bytes32 _hash) external;\r\n    function invalidateName(string calldata unhashedName) external;\r\n    function eraseNode(bytes32[] calldata labels) external;\r\n    function transferRegistrars(bytes32 _hash) external;\r\n    function acceptRegistrarTransfer(bytes32 hash, Deed deed, uint registrationDate) external;\r\n    function entries(bytes32 _hash) external view returns (Mode, address, uint, uint, uint);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/BaseRegistrar.sol\r\n\r\npragma solidity >=0.4.24;\r\n\r\n\r\n\r\n\r\n\r\ncontract BaseRegistrar is IERC721, Ownable {\r\n    uint constant public GRACE_PERIOD = 90 days;\r\n\r\n    event ControllerAdded(address indexed controller);\r\n    event ControllerRemoved(address indexed controller);\r\n    event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\r\n    event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\r\n    event NameRenewed(uint256 indexed id, uint expires);\r\n\r\n    // Expiration timestamp for migrated domains.\r\n    uint public transferPeriodEnds;\r\n\r\n    // The ENS registry\r\n    ENS public ens;\r\n\r\n    // The namehash of the TLD this registrar owns (eg, .eth)\r\n    bytes32 public baseNode;\r\n\r\n    // The interim registrar\r\n    Registrar public previousRegistrar;\r\n\r\n    // A map of addresses that are authorised to register and renew names.\r\n    mapping(address=>bool) public controllers;\r\n\r\n    // Authorises a controller, who can register and renew domains.\r\n    function addController(address controller) external;\r\n\r\n    // Revoke controller permission for an address.\r\n    function removeController(address controller) external;\r\n\r\n    // Set the resolver for the TLD this registrar manages.\r\n    function setResolver(address resolver) external;\r\n\r\n    // Returns the expiration timestamp of the specified label hash.\r\n    function nameExpires(uint256 id) external view returns(uint);\r\n\r\n    // Returns true iff the specified name is available for registration.\r\n    function available(uint256 id) public view returns(bool);\r\n\r\n    /**\r\n     * @dev Register a name.\r\n     */\r\n    function register(uint256 id, address owner, uint duration) external returns(uint);\r\n\r\n    function renew(uint256 id, uint duration) external returns(uint);\r\n\r\n    /**\r\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\r\n     */\r\n    function reclaim(uint256 id, address owner) external;\r\n\r\n    /**\r\n     * @dev Transfers a registration from the initial registrar.\r\n     * This function is called by the initial registrar when a user calls `transferRegistrars`.\r\n     */\r\n    function acceptRegistrarTransfer(bytes32 label, Deed deed, uint) external;\r\n}\r\n\r\n// File: contracts/StringUtils.sol\r\n\r\npragma solidity >=0.4.24;\r\n\r\nlibrary StringUtils {\r\n    /**\r\n     * @dev Returns the length of a given string\r\n     *\r\n     * @param s The string to measure the length of\r\n     * @return The length of the input string\r\n     */\r\n    function strlen(string memory s) internal pure returns (uint) {\r\n        uint len;\r\n        uint i = 0;\r\n        uint bytelength = bytes(s).length;\r\n        for(len = 0; i < bytelength; len++) {\r\n            byte b = bytes(s)[i];\r\n            if(b < 0x80) {\r\n                i += 1;\r\n            } else if (b < 0xE0) {\r\n                i += 2;\r\n            } else if (b < 0xF0) {\r\n                i += 3;\r\n            } else if (b < 0xF8) {\r\n                i += 4;\r\n            } else if (b < 0xFC) {\r\n                i += 5;\r\n            } else {\r\n                i += 6;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n}\r\n\r\n// File: contracts/PriceOracle.sol\r\n\r\npragma solidity >=0.4.24;\r\n\r\ninterface PriceOracle {\r\n    /**\r\n     * @dev Returns the price to register or renew a name.\r\n     * @param name The name being registered or renewed.\r\n     * @param expires When the name presently expires (0 if this is a new registration).\r\n     * @param duration How long the name is being registered or extended for, in seconds.\r\n     * @return The price of this renewal or registration, in wei.\r\n     */\r\n    function price(string calldata name, uint expires, uint duration) external view returns(uint);\r\n}\r\n\r\n// File: @ensdomains/buffer/contracts/Buffer.sol\r\n\r\npragma solidity >0.4.18;\r\n\r\n/**\r\n* @dev A library for working with mutable byte buffers in Solidity.\r\n*\r\n* Byte buffers are mutable and expandable, and provide a variety of primitives\r\n* for writing to them. At any time you can fetch a bytes object containing the\r\n* current contents of the buffer. The bytes object should not be stored between\r\n* operations, as it may change due to resizing of the buffer.\r\n*/\r\nlibrary Buffer {\r\n    /**\r\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\r\n    *      a capacity. The capacity may be longer than the current value, in\r\n    *      which case it can be extended without the need to allocate more memory.\r\n    */\r\n    struct buffer {\r\n        bytes buf;\r\n        uint capacity;\r\n    }\r\n\r\n    /**\r\n    * @dev Initializes a buffer with an initial capacity.\r\n    * @param buf The buffer to initialize.\r\n    * @param capacity The number of bytes of space to allocate the buffer.\r\n    * @return The buffer, for chaining.\r\n    */\r\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\r\n        if (capacity % 32 != 0) {\r\n            capacity += 32 - (capacity % 32);\r\n        }\r\n        // Allocate space for the buffer data\r\n        buf.capacity = capacity;\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(buf, ptr)\r\n            mstore(ptr, 0)\r\n            mstore(0x40, add(32, add(ptr, capacity)))\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Initializes a new buffer from an existing bytes object.\r\n    *      Changes to the buffer may mutate the original value.\r\n    * @param b The bytes object to initialize the buffer with.\r\n    * @return A new buffer.\r\n    */\r\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\r\n        buffer memory buf;\r\n        buf.buf = b;\r\n        buf.capacity = b.length;\r\n        return buf;\r\n    }\r\n\r\n    function resize(buffer memory buf, uint capacity) private pure {\r\n        bytes memory oldbuf = buf.buf;\r\n        init(buf, capacity);\r\n        append(buf, oldbuf);\r\n    }\r\n\r\n    function max(uint a, uint b) private pure returns(uint) {\r\n        if (a > b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets buffer length to 0.\r\n    * @param buf The buffer to truncate.\r\n    * @return The original buffer, for chaining..\r\n    */\r\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\r\n        assembly {\r\n            let bufptr := mload(buf)\r\n            mstore(bufptr, 0)\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The start offset to write to.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to copy.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\r\n        require(len <= data.length);\r\n\r\n        if (off + len > buf.capacity) {\r\n            resize(buf, max(buf.capacity, len + off) * 2);\r\n        }\r\n\r\n        uint dest;\r\n        uint src;\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Start address = buffer address + offset + sizeof(buffer length)\r\n            dest := add(add(bufptr, 32), off)\r\n            // Update buffer length if we're extending it\r\n            if gt(add(len, off), buflen) {\r\n                mstore(bufptr, add(len, off))\r\n            }\r\n            src := add(data, 32)\r\n        }\r\n\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to copy.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, len);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, data.length);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write the byte at.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\r\n        if (off >= buf.capacity) {\r\n            resize(buf, buf.capacity * 2);\r\n        }\r\n\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Address = buffer address + sizeof(buffer length) + off\r\n            let dest := add(add(bufptr, off), 32)\r\n            mstore8(dest, data)\r\n            // Update buffer length if we extended it\r\n            if eq(off, buflen) {\r\n                mstore(bufptr, add(buflen, 1))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\r\n        return writeUint8(buf, buf.buf.length, data);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\r\n    *      exceed the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to write (left-aligned).\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\r\n        if (len + off > buf.capacity) {\r\n            resize(buf, (len + off) * 2);\r\n        }\r\n\r\n        uint mask = 256 ** len - 1;\r\n        // Right-align data\r\n        data = data >> (8 * (32 - len));\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Address = buffer address + sizeof(buffer length) + off + len\r\n            let dest := add(add(bufptr, off), len)\r\n            mstore(dest, or(and(mload(dest), not(mask)), data))\r\n            // Update buffer length if we extended it\r\n            if gt(add(off, len), mload(bufptr)) {\r\n                mstore(bufptr, add(off, len))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\r\n        return write(buf, off, bytes32(data), 20);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chhaining.\r\n    */\r\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, bytes32(data), 20);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, 32);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to write (right-aligned).\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\r\n        if (len + off > buf.capacity) {\r\n            resize(buf, (len + off) * 2);\r\n        }\r\n\r\n        uint mask = 256 ** len - 1;\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Address = buffer address + off + sizeof(buffer length) + len\r\n            let dest := add(add(bufptr, off), len)\r\n            mstore(dest, or(and(mload(dest), not(mask)), data))\r\n            // Update buffer length if we extended it\r\n            if gt(add(off, len), mload(bufptr)) {\r\n                mstore(bufptr, add(off, len))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n     * exceed the capacity of the buffer.\r\n     * @param buf The buffer to append to.\r\n     * @param data The data to append.\r\n     * @return The original buffer.\r\n     */\r\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\r\n        return writeInt(buf, buf.buf.length, data, len);\r\n    }\r\n}\r\n\r\n// File: @ensdomains/dnssec-oracle/contracts/BytesUtils.sol\r\n\r\npragma solidity >0.4.23;\r\n\r\nlibrary BytesUtils {\r\n    /*\r\n    * @dev Returns the keccak-256 hash of a byte range.\r\n    * @param self The byte string to hash.\r\n    * @param offset The position to start hashing at.\r\n    * @param len The number of bytes to hash.\r\n    * @return The hash of the byte range.\r\n    */\r\n    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\r\n        require(offset + len <= self.length);\r\n        assembly {\r\n            ret := keccak256(add(add(self, 32), offset), len)\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n    * @dev Returns a positive number if `other` comes lexicographically after\r\n    *      `self`, a negative number if it comes before, or zero if the\r\n    *      contents of the two bytes are equal.\r\n    * @param self The first bytes to compare.\r\n    * @param other The second bytes to compare.\r\n    * @return The result of the comparison.\r\n    */\r\n    function compare(bytes memory self, bytes memory other) internal pure returns (int) {\r\n        return compare(self, 0, self.length, other, 0, other.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns a positive number if `other` comes lexicographically after\r\n    *      `self`, a negative number if it comes before, or zero if the\r\n    *      contents of the two bytes are equal. Comparison is done per-rune,\r\n    *      on unicode codepoints.\r\n    * @param self The first bytes to compare.\r\n    * @param offset The offset of self.\r\n    * @param len    The length of self.\r\n    * @param other The second bytes to compare.\r\n    * @param otheroffset The offset of the other string.\r\n    * @param otherlen    The length of the other string.\r\n    * @return The result of the comparison.\r\n    */\r\n    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {\r\n        uint shortest = len;\r\n        if (otherlen < len)\r\n        shortest = otherlen;\r\n\r\n        uint selfptr;\r\n        uint otherptr;\r\n\r\n        assembly {\r\n            selfptr := add(self, add(offset, 32))\r\n            otherptr := add(other, add(otheroffset, 32))\r\n        }\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint mask;\r\n                if (shortest > 32) {\r\n                    mask = uint256(- 1); // aka 0xffffff....\r\n                } else {\r\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                }\r\n                uint diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n\r\n        return int(len) - int(otherlen);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @param otherOffset The offset into the second byte range.\r\n    * @param len The number of bytes to compare\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {\r\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal with offsets.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @param otherOffset The offset into the second byte range.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {\r\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\r\n    }\r\n\r\n    /*\r\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\r\n    *      they are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\r\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param other The second byte range to compare.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {\r\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 8-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 8 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {\r\n        return uint8(self[idx]);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 16-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 16 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {\r\n        require(idx + 2 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {\r\n        require(idx + 4 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32 byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\r\n        require(idx + 32 <= self.length);\r\n        assembly {\r\n            ret := mload(add(add(self, 32), idx))\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32 byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {\r\n        require(idx + 20 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the n byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes.\r\n    * @param len The number of bytes.\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {\r\n        require(len <= 32);\r\n        require(idx + len <= self.length);\r\n        assembly {\r\n            let mask := not(sub(exp(256, sub(32, len)), 1))\r\n            ret := and(mload(add(add(self, 32), idx)),  mask)\r\n        }\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Copies a substring into a new byte string.\r\n    * @param self The byte string to copy from.\r\n    * @param offset The offset to start copying at.\r\n    * @param len The number of bytes to copy.\r\n    */\r\n    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {\r\n        require(offset + len <= self.length);\r\n\r\n        bytes memory ret = new bytes(len);\r\n        uint dest;\r\n        uint src;\r\n\r\n        assembly {\r\n            dest := add(ret, 32)\r\n            src := add(add(self, 32), offset)\r\n        }\r\n        memcpy(dest, src, len);\r\n\r\n        return ret;\r\n    }\r\n\r\n    // Maps characters from 0x30 to 0x7A to their base32 values.\r\n    // 0xFF represents invalid characters in that range.\r\n    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';\r\n\r\n    /**\r\n     * @dev Decodes unpadded base32 data of up to one word in length.\r\n     * @param self The data to decode.\r\n     * @param off Offset into the string to start at.\r\n     * @param len Number of characters to decode.\r\n     * @return The decoded data, left aligned.\r\n     */\r\n    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {\r\n        require(len <= 52);\r\n\r\n        uint ret = 0;\r\n        uint8 decoded;\r\n        for(uint i = 0; i < len; i++) {\r\n            bytes1 char = self[off + i];\r\n            require(char >= 0x30 && char <= 0x7A);\r\n            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);\r\n            require(decoded <= 0x20);\r\n            if(i == len - 1) {\r\n                break;\r\n            }\r\n            ret = (ret << 5) | decoded;\r\n        }\r\n\r\n        uint bitlen = len * 5;\r\n        if(len % 8 == 0) {\r\n            // Multiple of 8 characters, no padding\r\n            ret = (ret << 5) | decoded;\r\n        } else if(len % 8 == 2) {\r\n            // Two extra characters - 1 byte\r\n            ret = (ret << 3) | (decoded >> 2);\r\n            bitlen -= 2;\r\n        } else if(len % 8 == 4) {\r\n            // Four extra characters - 2 bytes\r\n            ret = (ret << 1) | (decoded >> 4);\r\n            bitlen -= 4;\r\n        } else if(len % 8 == 5) {\r\n            // Five extra characters - 3 bytes\r\n            ret = (ret << 4) | (decoded >> 1);\r\n            bitlen -= 1;\r\n        } else if(len % 8 == 7) {\r\n            // Seven extra characters - 4 bytes\r\n            ret = (ret << 2) | (decoded >> 3);\r\n            bitlen -= 3;\r\n        } else {\r\n            revert();\r\n        }\r\n\r\n        return bytes32(ret << (256 - bitlen));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: contracts/ShortNameClaims.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev ShortNameClaims is a contract that permits people to register claims\r\n *      for short (3-6 character) ENS names ahead of the auction process.\r\n *\r\n *      Anyone with a DNS name registered before January 1, 2019, may use this\r\n *      name to support a claim for a matching ENS name. In the event that\r\n *      multiple claimants request the same name, the name will be assigned to\r\n *      the oldest registered DNS name.\r\n *\r\n *      Claims may be submitted by calling `submitExactClaim`,\r\n *      `submitCombinedClaim` or `submitPrefixClaim` as appropriate.\r\n *\r\n *      Claims require lodging a deposit equivalent to 365 days' registration of\r\n *      the name. If the claim is approved, this deposit is spent, and the name\r\n *      is registered for the claimant for 365 days. If the claim is declined,\r\n *      the deposit will be returned.\r\n */\r\ncontract ShortNameClaims {\r\n    using Roles for Roles.Role;\r\n\r\n    uint constant public REGISTRATION_PERIOD = 31536000;\r\n\r\n    using Buffer for Buffer.buffer;\r\n    using BytesUtils for bytes;\r\n    using StringUtils for string;\r\n\r\n    enum Phase {\r\n        OPEN,\r\n        REVIEW,\r\n        FINAL\r\n    }\r\n\r\n    enum Status {\r\n        PENDING,\r\n        APPROVED,\r\n        DECLINED,\r\n        WITHDRAWN\r\n    }\r\n\r\n    struct Claim {\r\n        bytes32 labelHash;\r\n        address claimant;\r\n        uint paid;\r\n        Status status;\r\n    }\r\n\r\n    Roles.Role owners;\r\n    Roles.Role ratifiers;\r\n\r\n    PriceOracle public priceOracle;\r\n    BaseRegistrar public registrar;\r\n    mapping(bytes32=>Claim) public claims;\r\n    mapping(bytes32=>bool) approvedNames;\r\n    uint public pendingClaims;\r\n    uint public unresolvedClaims;\r\n    Phase public phase;\r\n\r\n    event ClaimSubmitted(string claimed, bytes dnsname, uint paid, address claimant, string email);\r\n    event ClaimStatusChanged(bytes32 indexed claimId, Status status);\r\n\r\n    constructor(PriceOracle _priceOracle, BaseRegistrar _registrar, address _ratifier) public {\r\n        priceOracle = _priceOracle;\r\n        registrar = _registrar;\r\n        phase = Phase.OPEN;\r\n\r\n        owners.add(msg.sender);\r\n        ratifiers.add(_ratifier);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owners.has(msg.sender), \"Caller must be an owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyRatifier() {\r\n        require(ratifiers.has(msg.sender), \"Caller must be a ratifier\");\r\n        _;\r\n    }\r\n\r\n    modifier inPhase(Phase p) {\r\n        require(phase == p, \"Not in required phase\");\r\n        _;\r\n    }\r\n\r\n    function addOwner(address owner) external onlyOwner {\r\n        owners.add(owner);\r\n    }\r\n\r\n    function removeOwner(address owner) external onlyOwner {\r\n        owners.remove(owner);\r\n    }\r\n\r\n    function addRatifier(address ratifier) external onlyRatifier {\r\n        ratifiers.add(ratifier);\r\n    }\r\n\r\n    function removeRatifier(address ratifier) external onlyRatifier {\r\n        ratifiers.remove(ratifier);\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the claim ID for a submitted claim, so it can be looked up\r\n     *      using `claims`.\r\n     * @param claimed The name being claimed (eg, 'foo')\r\n     * @param dnsname The DNS-encoded name supporting the claim (eg, 'foo.test')\r\n     * @param claimant The address making the claim.\r\n     * @return The claim ID.\r\n     */\r\n    function computeClaimId(string memory claimed, bytes memory dnsname, address claimant, string memory email) public pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(keccak256(bytes(claimed)), keccak256(dnsname), claimant, keccak256(bytes(email))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the cost associated with placing a claim.\r\n     * @param claimed The name being claimed.\r\n     * @return The cost in wei for this claim.\r\n     */\r\n    function getClaimCost(string memory claimed) public view returns(uint) {\r\n        return priceOracle.price(claimed, 0, REGISTRATION_PERIOD);\r\n    }\r\n\r\n    /**\r\n     * @dev Submits a claim for an exact match (eg, foo.test -> foo.eth).\r\n     *      Claimants must provide an amount of ether equal to 365 days'\r\n     *      registration cost; call `getClaimCost` to determine this amount.\r\n     *      Claimants should supply a little extra in case of variation in price;\r\n     *      any excess will be returned to the sender.\r\n     * @param name The DNS-encoded name of the domain being used to support the\r\n     *             claim.\r\n     * @param claimant The address of the claimant.\r\n     * @param email An email address for correspondence regarding the claim.\r\n     */\r\n    function submitExactClaim(bytes memory name, address claimant, string memory email) public payable {\r\n        string memory claimed = getLabel(name, 0);\r\n        handleClaim(claimed, name, claimant, email);\r\n    }\r\n\r\n    /**\r\n     * @dev Submits a claim for match on name+tld (eg, foo.tv -> footv).\r\n     *      Claimants must provide an amount of ether equal to 365 days'\r\n     *      registration cost; call `getClaimCost` to determine this amount.\r\n     *      Claimants should supply a little extra in case of variation in price;\r\n     *      any excess will be returned to the sender.\r\n     * @param name The DNS-encoded name of the domain being used to support the\r\n     *             claim.\r\n     * @param claimant The address of the claimant.\r\n     * @param email An email address for correspondence regarding the claim.\r\n     */\r\n    function submitCombinedClaim(bytes memory name, address claimant, string memory email) public payable {\r\n        bytes memory firstLabel = bytes(getLabel(name, 0));\r\n        bytes memory secondLabel = bytes(getLabel(name, 1));\r\n        Buffer.buffer memory buf;\r\n        buf.init(firstLabel.length + secondLabel.length);\r\n        buf.append(firstLabel);\r\n        buf.append(secondLabel);\r\n\r\n        handleClaim(string(buf.buf), name, claimant, email);\r\n    }\r\n\r\n    /**\r\n     * @dev Submits a claim for prefix match (eg, fooeth.test -> foo.eth).\r\n     *      Claimants must provide an amount of ether equal to 365 days'\r\n     *      registration cost; call `getClaimCost` to determine this amount.\r\n     *      Claimants should supply a little extra in case of variation in price;\r\n     *      any excess will be returned to the sender.\r\n     * @param name The DNS-encoded name of the domain being used to support the\r\n     *             claim.\r\n     * @param claimant The address of the claimant.\r\n     * @param email An email address for correspondence regarding the claim.\r\n     */\r\n    function submitPrefixClaim(bytes memory name, address claimant, string memory email) public payable {\r\n        bytes memory firstLabel = bytes(getLabel(name, 0));\r\n        require(firstLabel.equals(firstLabel.length - 3, bytes(\"eth\")));\r\n        handleClaim(string(firstLabel.substring(0, firstLabel.length - 3)), name, claimant, email);\r\n    }\r\n\r\n    /**\r\n     * @dev Closes the claim submission period.\r\n     *      Callable only by the owner.\r\n     */\r\n    function closeClaims() external onlyOwner inPhase(Phase.OPEN) {\r\n        phase = Phase.REVIEW;\r\n    }\r\n\r\n    /**\r\n     * @dev Ratifies the current set of claims.\r\n     *      Ratification freezes the claims and their resolutions, and permits\r\n     *      them to be acted on.\r\n     */\r\n    function ratifyClaims() external onlyRatifier inPhase(Phase.REVIEW) {\r\n        // Can't ratify until all claims have a resolution.\r\n        require(pendingClaims == 0);\r\n        phase = Phase.FINAL;\r\n    }\r\n\r\n    /**\r\n     * @dev Cleans up the contract, after all claims are resolved.\r\n     *      Callable only by the owner, and only in final state.\r\n     */\r\n    function destroy() external onlyOwner inPhase(Phase.FINAL) {\r\n        require(unresolvedClaims == 0);\r\n        selfdestruct(toPayable(msg.sender));\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the status of a claim to either APPROVED or DECLINED.\r\n     *      Callable only during the review phase, and only by the owner or\r\n     *      ratifier.\r\n     * @param claimId The claim to set the status of.\r\n     * @param approved True if the claim is approved, false if it is declined.\r\n     */\r\n    function setClaimStatus(bytes32 claimId, bool approved) public inPhase(Phase.REVIEW) {\r\n        // Only callable by owner or ratifier\r\n        require(owners.has(msg.sender) || ratifiers.has(msg.sender));\r\n\r\n        Claim memory claim = claims[claimId];\r\n        require(claim.paid > 0, \"Claim not found\");\r\n\r\n        if(claim.status == Status.PENDING) {\r\n          // Claim went from pending -> approved/declined; update counters\r\n          pendingClaims--;\r\n          unresolvedClaims++;\r\n        } else if(claim.status == Status.APPROVED) {\r\n          // Claim was previously approved; remove from approved map\r\n          approvedNames[claim.labelHash] = false;\r\n        }\r\n\r\n        // Claim was just approved; check the name was not already used, and add\r\n        // to approved map\r\n        if(approved) {\r\n          require(!approvedNames[claim.labelHash]);\r\n          approvedNames[claim.labelHash] = true;\r\n        }\r\n\r\n        Status status = approved?Status.APPROVED:Status.DECLINED;\r\n        claims[claimId].status = status;\r\n        emit ClaimStatusChanged(claimId, status);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the status of multiple claims. Callable only during the review\r\n     *      phase, and only by the owner or ratifier.\r\n     * @param approved A list of approved claim IDs.\r\n     * @param declined A list of declined claim IDs.\r\n     */\r\n    function setClaimStatuses(bytes32[] calldata approved, bytes32[] calldata declined) external {\r\n        for(uint i = 0; i < approved.length; i++) {\r\n            setClaimStatus(approved[i], true);\r\n        }\r\n        for(uint i = 0; i < declined.length; i++) {\r\n            setClaimStatus(declined[i], false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Resolves a claim. Callable by anyone, only in the final phase.\r\n     *      Resolving a claim either registers the name or refunds the claimant.\r\n     * @param claimId The claim ID to resolve.\r\n     */\r\n    function resolveClaim(bytes32 claimId) public inPhase(Phase.FINAL) {\r\n        Claim memory claim = claims[claimId];\r\n        require(claim.paid > 0, \"Claim not found\");\r\n\r\n        if(claim.status == Status.APPROVED) {\r\n            registrar.register(uint256(claim.labelHash), claim.claimant, REGISTRATION_PERIOD);\r\n            toPayable(registrar.owner()).transfer(claim.paid);\r\n        } else if(claim.status == Status.DECLINED) {\r\n            toPayable(claim.claimant).transfer(claim.paid);\r\n        } else {\r\n            // It should not be possible to get to FINAL with claim IDs that are\r\n            // not either APPROVED or DECLINED.\r\n            assert(false);\r\n        }\r\n\r\n        unresolvedClaims--;\r\n        delete claims[claimId];\r\n    }\r\n\r\n    /**\r\n     * @dev Resolves multiple claims. Callable by anyone, only in the final phase.\r\n     * @param claimIds A list of claim IDs to resolve.\r\n     */\r\n    function resolveClaims(bytes32[] calldata claimIds) external {\r\n        for(uint i = 0; i < claimIds.length; i++) {\r\n            resolveClaim(claimIds[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws a claim and refunds the claimant.\r\n     *      Callable only by the claimant, at any time.\r\n     * @param claimId The ID of the claim to withdraw.\r\n     */\r\n    function withdrawClaim(bytes32 claimId) external {\r\n        Claim memory claim = claims[claimId];\r\n\r\n        // Only callable by claimant\r\n        require(msg.sender == claim.claimant);\r\n\r\n        if(claim.status == Status.PENDING) {\r\n            pendingClaims--;\r\n        } else {\r\n            unresolvedClaims--;\r\n        }\r\n\r\n        toPayable(claim.claimant).transfer(claim.paid);\r\n        emit ClaimStatusChanged(claimId, Status.WITHDRAWN);\r\n        delete claims[claimId];\r\n    }\r\n\r\n    function handleClaim(string memory claimed, bytes memory name, address claimant, string memory email) internal inPhase(Phase.OPEN) {\r\n        uint len = claimed.strlen();\r\n        require(len >= 3 && len <= 6);\r\n\r\n        bytes32 claimId = computeClaimId(claimed, name, claimant, email);\r\n        require(claims[claimId].paid == 0, \"Claim already submitted\");\r\n\r\n        // Require that there are at most two labels (name.tld)\r\n        require(bytes(getLabel(name, 2)).length == 0, \"Name must be a 2LD\");\r\n\r\n        uint price = getClaimCost(claimed);\r\n        require(msg.value >= price, \"Insufficient funds for reservation\");\r\n        if(msg.value > price) {\r\n            msg.sender.transfer(msg.value - price);\r\n        }\r\n\r\n        claims[claimId] = Claim(keccak256(bytes(claimed)), claimant, price, Status.PENDING);\r\n        pendingClaims++;\r\n        emit ClaimSubmitted(claimed, name, price, claimant, email);\r\n    }\r\n\r\n    function getLabel(bytes memory name, uint idx) internal pure returns(string memory) {\r\n        // Skip the first `idx` labels\r\n        uint offset = 0;\r\n        for(uint i = 0; i < idx; i++) {\r\n            if(offset >= name.length) return \"\";\r\n            offset += name.readUint8(offset) + 1;\r\n        }\r\n\r\n        // Read the label we care about\r\n        if(offset >= name.length) return '';\r\n        uint len = name.readUint8(offset);\r\n        return string(name.substring(offset + 1, len));\r\n    }\r\n\r\n    function toPayable(address addr) internal pure returns(address payable) {\r\n        return address(uint160(addr));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrar\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ratifier\",\"type\":\"address\"}],\"name\":\"removeRatifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingClaims\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ratifier\",\"type\":\"address\"}],\"name\":\"addRatifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes\"},{\"name\":\"claimant\",\"type\":\"address\"},{\"name\":\"email\",\"type\":\"string\"}],\"name\":\"submitPrefixClaim\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unresolvedClaims\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"claimed\",\"type\":\"string\"}],\"name\":\"getClaimCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"claimId\",\"type\":\"bytes32\"}],\"name\":\"withdrawClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ratifyClaims\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"claimed\",\"type\":\"string\"},{\"name\":\"dnsname\",\"type\":\"bytes\"},{\"name\":\"claimant\",\"type\":\"address\"},{\"name\":\"email\",\"type\":\"string\"}],\"name\":\"computeClaimId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"claimId\",\"type\":\"bytes32\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setClaimStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes\"},{\"name\":\"claimant\",\"type\":\"address\"},{\"name\":\"email\",\"type\":\"string\"}],\"name\":\"submitExactClaim\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"claimId\",\"type\":\"bytes32\"}],\"name\":\"resolveClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approved\",\"type\":\"bytes32[]\"},{\"name\":\"declined\",\"type\":\"bytes32[]\"}],\"name\":\"setClaimStatuses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeClaims\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"claimIds\",\"type\":\"bytes32[]\"}],\"name\":\"resolveClaims\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REGISTRATION_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"claims\",\"outputs\":[{\"name\":\"labelHash\",\"type\":\"bytes32\"},{\"name\":\"claimant\",\"type\":\"address\"},{\"name\":\"paid\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes\"},{\"name\":\"claimant\",\"type\":\"address\"},{\"name\":\"email\",\"type\":\"string\"}],\"name\":\"submitCombinedClaim\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_priceOracle\",\"type\":\"address\"},{\"name\":\"_registrar\",\"type\":\"address\"},{\"name\":\"_ratifier\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"claimed\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"dnsname\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"paid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"email\",\"type\":\"string\"}],\"name\":\"ClaimSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"claimId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"ClaimStatusChanged\",\"type\":\"event\"}]","ContractName":"ShortNameClaims","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000b9d374d0fe3d8341155663fae31b7beae0ae233a000000000000000000000000fac7bea255a6990f749363002136af6556b31e04000000000000000000000000b8c2c29ee19d8307cb7255e1cd9cbde883a267d5","Library":"","SwarmSource":"bzzr://9a419cd1bb289ec131e1647267278fa7013b2d937091e25901423b4f734f0a40"}]}