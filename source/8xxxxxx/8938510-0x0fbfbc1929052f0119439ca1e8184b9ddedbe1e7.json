{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\r\n\r\n// Simple Options is a binary option smart contract. Users are given a 24 hour window to determine whether\r\n// the price of ETH will increase or decrease. Winners will split the pot of the losers proportionally based on how many\r\n// tickets they each have. The first 12 hours of the window allows users to bet against each other, while in the second 12 hours,\r\n// they must wait to see if they were right. Once the time has expired, users can force the round to end which will trigger\r\n// balance transfers to the winning side and start a new round with the current price set as the starting price; however,\r\n// if they don't, a cron job ran externally will automatically close the round.\r\n\r\n// The price per ticket will gradually increase per hour as the round continues. In the first hour, the price is 0.01 ETH,\r\n// while in the final (12th) hour before betting ends, the price is 1 ETH. Users can buy more than 1 ticket.\r\n\r\n// The price Oracle for this contract is the Maker medianizer (0x729D19f657BD0614b4985Cf1D82531c67569197B), which updates\r\n// around every 6 hours.\r\n\r\n// The contract charges a fee that goes to the contract feeAddress. It is 5%. This fee is taken from the losers pot before\r\n// being distributed to the winners. If there are no losers (see below), there are no fees subtracted.\r\n\r\n// If at the end of the round, the price stays the same, there are no winners or losers. Everyone can withdraw their balance.\r\n// If the round is not ended within 3 minutes after the deadline, the price is considered stale and there are no winners or\r\n// losers. Everyone can withdraw their balance.\r\n\r\ncontract MakerOracle_ETHUSD {\r\n  function peek() external view returns (uint256,bool);\r\n}\r\n\r\ncontract Simple_Options {\r\n\r\n  // Administrator information\r\n  address public feeAddress; // This is the address of the person that collects the fees, nothing more, nothing less. It can be changed.\r\n  uint256 public feePercent = 5000; // This is the percent of the fee (5000 = 5.0%, 1 = 0.001%)\r\n  uint256 constant roundCutoff = 43200; // The cut-off time (in seconds) to submit a bet before the round ends. Currently 12 hours\r\n  uint256 constant roundLength = 86400; // The length of the round (in seconds)\r\n  address constant makerOracle = 0x729D19f657BD0614b4985Cf1D82531c67569197B; // Contract address for the maker oracle. Controlled by MakerDAO.\r\n\r\n  // Different types of round Status\r\n  enum RoundStatus {\r\n    OPEN,\r\n    CLOSED,\r\n    STALEPRICE, // No winners due to price being too late\r\n    NOCONTEST // No winners\r\n  }\r\n\r\n  struct Round {\r\n    uint256 roundNum; // The round number\r\n    RoundStatus roundStatus; // The round status\r\n    uint256 startPriceWei; // ETH price at start of round\r\n    uint256 endPriceWei; // ETH price at end\r\n    uint256 startTime; // Unix seconds at start of round\r\n    uint256 endTime; // Unix seconds at end\r\n    uint256 totalCallTickets; // Tickets for expected price increase\r\n    uint256 totalCallPotWei; // Pot size for the users who believe in call\r\n    uint256 totalPutTickets; // Tickets for expected price decrease\r\n    uint256 totalPutPotWei; // Pot size for the users who believe in put\r\n\r\n    uint256 totalUsers; // Total users in this round\r\n    mapping (uint256 => address) userList;\r\n    mapping (address => User) users;\r\n  }\r\n\r\n  struct User {\r\n    uint256 numCallTickets;\r\n    uint256 numPutTickets;\r\n    uint256 callBalanceWei;\r\n    uint256 putBalanceWei;\r\n  }\r\n\r\n  mapping (uint256 => Round) roundList; // A mapping of all the rounds based on an integer\r\n  uint256 public currentRound = 0; // The current round\r\n\r\n  event ChangedFeeAddress(address _newFeeAddress);\r\n  event FailedFeeSend(address _user, uint256 _amount);\r\n  event FeeSent(address _user, uint256 _amount);\r\n  event BoughtCallTickets(address _user, uint256 _ticketNum, uint256 _roundNum);\r\n  event BoughtPutTickets(address _user, uint256 _ticketNum, uint256 _roundNum);\r\n  event FailedPriceOracle();\r\n  event StartedNewRound(uint256 _roundNum);\r\n\r\n  constructor() public {\r\n    feeAddress = msg.sender; // Set the contract creator to the first feeAddress\r\n  }\r\n\r\n  // View function\r\n  // View round information\r\n  function viewRoundInfo(uint256 _numRound) public view returns (\r\n    uint256 _startPriceWei,\r\n    uint256 _endPriceWei,\r\n    uint256 _startTime,\r\n    uint256 _endTime,\r\n    uint256 _totalCallPotWei,\r\n    uint256 _totalPutPotWei,\r\n    uint256 _totalCallTickets, \r\n    uint256 _totalPutTickets,\r\n    RoundStatus _status\r\n  ) {\r\n    assert(_numRound <= currentRound);\r\n    assert(_numRound >= 1);\r\n    Round memory _round = roundList[_numRound];\r\n    return (_round.startPriceWei, _round.endPriceWei, _round.startTime, _round.endTime, _round.totalCallPotWei, _round.totalPutPotWei, _round.totalCallTickets, _round.totalPutTickets, _round.roundStatus);\r\n  }\r\n\r\n  // View user information that is round specific\r\n  function viewUserInfo(uint256 _numRound, address _userAddress) public view returns (\r\n    uint256 _numCallTickets,\r\n    uint256 _numPutTickets,\r\n    uint256 _balanceWei\r\n  ) {\r\n    assert(_numRound <= currentRound);\r\n    assert(_numRound >= 1);\r\n    Round storage _round = roundList[_numRound];\r\n    User memory _user = _round.users[_userAddress];\r\n    uint256 balance = _user.callBalanceWei + _user.putBalanceWei;\r\n    return (_user.numCallTickets, _user.numPutTickets, balance);\r\n  }\r\n\r\n  // View the current round's ticket cost based on the reported current time\r\n  function viewCurrentCost(uint256 _currentTime) public view returns (\r\n    uint256 _cost\r\n  ) {\r\n    assert(currentRound > 0);\r\n    Round memory _round = roundList[currentRound];\r\n    uint256 startTime = _round.startTime;\r\n    uint256 currentTime = _currentTime;\r\n    assert(currentTime >= startTime);\r\n    uint256 cost = calculateCost(startTime, currentTime);\r\n    return (cost);\r\n  }\r\n\r\n  // Action functions\r\n  // Change contract fee address\r\n  function changeContractFeeAddress(address _newFeeAddress) public {\r\n    require (msg.sender == feeAddress); // Only the current feeAddress can change the feeAddress of the contract\r\n    \r\n    feeAddress = _newFeeAddress; // Update the fee address\r\n\r\n     // Trigger event.\r\n    emit ChangedFeeAddress(_newFeeAddress);\r\n  }\r\n\r\n  // This function creates a new round if the time is right (only after the endTime of the previous round) or if no rounds exist\r\n  // Anyone can request to start a new round, it is not priviledged\r\n  function startNewRound() public {\r\n    if(currentRound == 0){\r\n      // This is the first round of the contract\r\n      Round memory _newRound;\r\n      currentRound = currentRound + 1;\r\n      _newRound.roundNum = currentRound;\r\n      \r\n      // Obtain the current price from the Maker Oracle\r\n      _newRound.startPriceWei = getOraclePrice(0,true); // This function must return a price\r\n\r\n      // Set the timers up\r\n      _newRound.startTime = now;\r\n      _newRound.endTime = _newRound.startTime + roundLength; // 24 Hour rounds\r\n      roundList[currentRound] = _newRound;\r\n\r\n      emit StartedNewRound(currentRound);\r\n    }else if(currentRound > 0){\r\n      // The user wants to close the current round and start a new one\r\n      uint256 cTime = now;\r\n      uint256 feeAmount = 0;\r\n      Round storage _round = roundList[currentRound];\r\n      require( cTime >= _round.endTime ); // Cannot close a round unless the endTime is reached\r\n\r\n      // Obtain the current price from the Maker Oracle\r\n      _round.endPriceWei = getOraclePrice(_round.startPriceWei, false);\r\n\r\n      bool no_contest = false; \r\n\r\n      // If the price is stale, the current round has no losers or winners   \r\n      if( cTime - 180 > _round.endTime){ // More than 3 minutes after round has ended, price is stale\r\n        no_contest = true;\r\n        _round.endTime = cTime;\r\n        _round.roundStatus = RoundStatus.STALEPRICE;\r\n      }\r\n\r\n      if(_round.endPriceWei == _round.startPriceWei){\r\n        no_contest = true; // The price hasn't changed, so no one wins\r\n        _round.roundStatus = RoundStatus.NOCONTEST;\r\n      }\r\n\r\n      if(_round.totalPutTickets == 0 || _round.totalCallTickets == 0){\r\n        no_contest = true; // There is no one on the opposite side, can't compete\r\n        _round.roundStatus = RoundStatus.NOCONTEST;\r\n      }\r\n\r\n      if(no_contest == false){\r\n        // There are winners and losers\r\n        uint256 addAmount = 0;\r\n        uint256 it = 0;\r\n        uint256 rewardPerTicket = 0;\r\n        uint256 roundTotal = 0;\r\n        if(_round.endPriceWei > _round.startPriceWei){\r\n          // The calls have won the game\r\n          // Take the putters funds, subtract the fee then divide it up among the callers\r\n          roundTotal = _round.totalPutPotWei; // Get the putters total in the round\r\n          feeAmount = (roundTotal * feePercent) / 100000; // Calculate the usage fee\r\n          roundTotal = roundTotal - feeAmount; // Take fee from the total Pot\r\n          uint256 putRemainBalance = roundTotal;    \r\n          rewardPerTicket = roundTotal / _round.totalCallTickets;\r\n\r\n          for(it = 0; it < _round.totalUsers; it++){ // Go through each user in the round\r\n            User storage _user = _round.users[_round.userList[it]];\r\n            if(_user.numPutTickets > 0){\r\n              // We have some losing tickets, set our put balance to zero\r\n              _user.putBalanceWei = 0;\r\n            }\r\n            if(_user.numCallTickets > 0){\r\n              // We have some winning tickets, add to our call balance\r\n              addAmount = _user.numCallTickets * rewardPerTicket;\r\n              if(addAmount > putRemainBalance){addAmount = putRemainBalance;} // Cannot be greater than what is left\r\n              _user.callBalanceWei = _user.callBalanceWei + addAmount;\r\n              putRemainBalance = putRemainBalance - addAmount;\r\n            }\r\n          }\r\n        }else{\r\n          // The puts have won the game, price has decreased\r\n          // Take the callers funds, subtract the fee then divide it up among the putters\r\n          roundTotal = _round.totalCallPotWei; // Get the callers total in the round\r\n          feeAmount = (roundTotal * feePercent) / 100000; // Calculate the usage fee\r\n          roundTotal = roundTotal - feeAmount; // Take fee from the total Pot\r\n          uint256 callRemainBalance = roundTotal;    \r\n          rewardPerTicket = roundTotal / _round.totalPutTickets;\r\n\r\n          for(it = 0; it < _round.totalUsers; it++){ // Go through each user in the round\r\n            User storage _user2 = _round.users[_round.userList[it]];\r\n            if(_user2.numCallTickets > 0){\r\n              // We have some losing tickets, set our call balance to zero\r\n              _user2.callBalanceWei = 0;\r\n            }\r\n            if(_user2.numPutTickets > 0){\r\n              // We have some winning tickets, add to our put balance\r\n              addAmount = _user2.numPutTickets * rewardPerTicket;\r\n              if(addAmount > callRemainBalance){addAmount = callRemainBalance;} // Cannot be greater than what is left\r\n              _user2.putBalanceWei = _user2.putBalanceWei + addAmount;\r\n              callRemainBalance = callRemainBalance - addAmount;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Close out the round completely which allows users to withdraw balance\r\n        _round.roundStatus = RoundStatus.CLOSED;\r\n      }\r\n\r\n      // Open up a new round using the endTime for the last round as the startTime\r\n      // and the endprice of the last round as the startprice\r\n      Round memory _nextRound;\r\n      currentRound = currentRound + 1;\r\n      _nextRound.roundNum = currentRound;\r\n      \r\n      // The current price will be the previous round's end price\r\n      _nextRound.startPriceWei = _round.endPriceWei;\r\n\r\n      // Set the timers up\r\n      _nextRound.startTime = _round.endTime; // Set the start time to the previous round endTime\r\n      _nextRound.endTime = _nextRound.startTime + roundLength; // 24 Hour rounds\r\n      roundList[currentRound] = _nextRound;\r\n\r\n      // Send the fee if present\r\n      if(feeAmount > 0){\r\n        bool sentfee = feeAddress.send(feeAmount);\r\n        if(sentfee == false){\r\n          emit FailedFeeSend(feeAddress, feeAmount); // Create an event in case of fee sending failed, but don't stop ending the round\r\n        }else{\r\n          emit FeeSent(feeAddress, feeAmount); // Record that the fee was sent\r\n        }\r\n      }\r\n\r\n      emit StartedNewRound(currentRound);\r\n    }\r\n  }\r\n\r\n  // Buy some call tickets\r\n  function buyCallTickets() public payable {\r\n    buyTickets(0);\r\n  }\r\n\r\n  // Buy some put tickets\r\n  function buyPutTickets() public payable {\r\n    buyTickets(1);\r\n  }\r\n\r\n  // Withdraw from a previous round\r\n  // Cannot withdraw partial funds, all funds are withdrawn\r\n  function withdrawFunds(uint256 roundNum) public {\r\n    require( roundNum > 0 && roundNum < currentRound); // Can only withdraw from previous rounds\r\n    Round storage _round = roundList[roundNum];\r\n    require( _round.roundStatus != RoundStatus.OPEN ); // Round must be closed\r\n    User storage _user = _round.users[msg.sender];\r\n    uint256 balance = _user.callBalanceWei + _user.putBalanceWei;\r\n    require( _user.callBalanceWei + _user.putBalanceWei > 0); // Must have a balance to send out\r\n    _user.callBalanceWei = 0;\r\n    _user.putBalanceWei = 0;\r\n    msg.sender.transfer(balance); // Protected from re-entrancy\r\n  }\r\n\r\n  // Private functions\r\n  function calculateCost(uint256 startTime, uint256 currentTime) private pure returns (uint256 _weiCost){\r\n    uint256 timediff = currentTime - startTime;\r\n    uint256 chour = timediff / 3600;\r\n    uint256 cost = 10000000000000000; // The starting cost, 0.01 ETH\r\n    cost = cost + 90000000000000000 * chour; // The cost increases at 0.09 ETH per hour\r\n    return cost;\r\n  }\r\n\r\n  // Grabs the price from the MakerDAO oracle\r\n  function getOraclePrice(uint256 _currentPrice, bool required) private returns (uint256 _price){\r\n    MakerOracle_ETHUSD oracle = MakerOracle_ETHUSD(makerOracle);\r\n    (uint256 price, bool ok) = oracle.peek(); // Get the price in Wei\r\n\r\n    if(ok == true){\r\n      return price;\r\n    }else{\r\n      if(required == false){\r\n        // Failed to get the price from the Oracle, set to the start price and rule round no contest\r\n        // Emit an event that shows this failed\r\n        emit FailedPriceOracle();\r\n        return _currentPrice;       \r\n      }else{\r\n        // If required to obtain a price but unable to, revert the transaction\r\n        revert();\r\n      }\r\n    }\r\n  }\r\n\r\n  function buyTickets(uint256 ticketType) private {\r\n    require( currentRound > 0 ); // There must be an active round ongoing\r\n    Round storage _round = roundList[currentRound];\r\n    uint256 endTime = _round.endTime;\r\n    uint256 startTime = _round.startTime;\r\n    uint256 currentTime = now;\r\n    require( currentTime <= endTime - roundCutoff); // Cannot buy a ticket after the cutoff time\r\n    uint256 currentCost = calculateCost(startTime, currentTime); // Calculate the price\r\n    require(msg.value % currentCost == 0); // The value must be a multiple of the cost\r\n    require(msg.value >= currentCost); // Must have some value\r\n    require(_round.totalUsers <= 1000); // Cannot have more than 1000 users per round\r\n    require(_round.roundStatus == RoundStatus.OPEN); // Round is still open, it should be\r\n    \r\n    uint256 numTickets = msg.value / currentCost; // The user can buy multple tickets\r\n\r\n    // Check if user is in the mapping\r\n    User memory _user = _round.users[msg.sender];\r\n    if(_user.numCallTickets + _user.numPutTickets == 0){\r\n      // No tickets yet for user, new user\r\n      _round.userList[_round.totalUsers] = msg.sender;\r\n      _round.totalUsers = _round.totalUsers + 1;\r\n    }\r\n\r\n    if(ticketType == 0){\r\n      // Call ticket\r\n      _user.numCallTickets = _user.numCallTickets + numTickets;\r\n      _user.callBalanceWei = _user.callBalanceWei + msg.value;\r\n      _round.totalCallTickets = _round.totalCallTickets + numTickets;\r\n      _round.totalCallPotWei = _round.totalCallPotWei + msg.value;\r\n\r\n      emit BoughtCallTickets(msg.sender, numTickets, currentRound);\r\n    }else{\r\n      // Put ticket\r\n      _user.numPutTickets = _user.numPutTickets + numTickets;\r\n      _user.putBalanceWei = _user.putBalanceWei + msg.value;\r\n      _round.totalPutTickets = _round.totalPutTickets + numTickets;\r\n      _round.totalPutPotWei = _round.totalPutPotWei + msg.value;\r\n\r\n      emit BoughtPutTickets(msg.sender, numTickets, currentRound);\r\n    }\r\n\r\n    _round.users[msg.sender] = _user; // Add the user information to the game\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"roundNum\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFeeAddress\",\"type\":\"address\"}],\"name\":\"changeContractFeeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyCallTickets\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_numRound\",\"type\":\"uint256\"},{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"viewUserInfo\",\"outputs\":[{\"name\":\"_numCallTickets\",\"type\":\"uint256\"},{\"name\":\"_numPutTickets\",\"type\":\"uint256\"},{\"name\":\"_balanceWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_currentTime\",\"type\":\"uint256\"}],\"name\":\"viewCurrentCost\",\"outputs\":[{\"name\":\"_cost\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startNewRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_numRound\",\"type\":\"uint256\"}],\"name\":\"viewRoundInfo\",\"outputs\":[{\"name\":\"_startPriceWei\",\"type\":\"uint256\"},{\"name\":\"_endPriceWei\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_totalCallPotWei\",\"type\":\"uint256\"},{\"name\":\"_totalPutPotWei\",\"type\":\"uint256\"},{\"name\":\"_totalCallTickets\",\"type\":\"uint256\"},{\"name\":\"_totalPutTickets\",\"type\":\"uint256\"},{\"name\":\"_status\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyPutTickets\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newFeeAddress\",\"type\":\"address\"}],\"name\":\"ChangedFeeAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"FailedFeeSend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"FeeSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ticketNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_roundNum\",\"type\":\"uint256\"}],\"name\":\"BoughtCallTickets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ticketNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_roundNum\",\"type\":\"uint256\"}],\"name\":\"BoughtPutTickets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FailedPriceOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_roundNum\",\"type\":\"uint256\"}],\"name\":\"StartedNewRound\",\"type\":\"event\"}]","ContractName":"Simple_Options","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://c98987477137c8f72d6fc84f87cee626e63344462f3f92a0bd843a52aa28a68f"}]}