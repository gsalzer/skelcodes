{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\n\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint              wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n\ncontract DSProxy is DSAuth, DSNote {\n    DSProxyCache public cache;  \n\n    constructor(address _cacheAddr) public {\n        require(setCache(_cacheAddr));\n    }\n\n    function() external payable {\n    }\n\n    \n    function execute(bytes memory _code, bytes memory _data)\n        public\n        payable\n        returns (address target, bytes32 response)\n    {\n        target = cache.read(_code);\n        if (target == address(0)) {\n            \n            target = cache.write(_code);\n        }\n\n        response = execute(target, _data);\n    }\n\n    function execute(address _target, bytes memory _data)\n        public\n        auth\n        note\n        payable\n        returns (bytes32 response)\n    {\n        require(_target != address(0));\n\n        \n        assembly {\n            let succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 32)\n            response := mload(0)      \n            switch iszero(succeeded)\n            case 1 {\n                \n                revert(0, 0)\n            }\n        }\n    }\n\n    \n    function setCache(address _cacheAddr)\n        public\n        payable\n        auth\n        note\n        returns (bool)\n    {\n        require(_cacheAddr != address(0));        \n        cache = DSProxyCache(_cacheAddr);  \n        return true;\n    }\n}\n\ncontract DSProxyCache {\n    mapping(bytes32 => address) cache;\n\n    function read(bytes memory _code) public view returns (address) {\n        bytes32 hash = keccak256(_code);\n        return cache[hash];\n    }\n\n    function write(bytes memory _code) public returns (address target) {\n        assembly {\n            target := create(0, add(_code, 0x20), mload(_code))\n            switch iszero(extcodesize(target))\n            case 1 {\n                \n                revert(0, 0)\n            }\n        }\n        bytes32 hash = keccak256(_code);\n        cache[hash] = target;\n    }\n}\n\ncontract TokenInterface {\n    function allowance(address, address) public returns (uint);\n    function balanceOf(address) public returns (uint);\n    function approve(address, uint) public;\n    function transfer(address, uint) public returns (bool);\n    function transferFrom(address, address, uint) public returns (bool);\n    function deposit() public payable;\n    function withdraw(uint) public;\n}\n\ncontract Vat {\n\n    struct Urn {\n        uint256 ink;   \n        uint256 art;   \n    }\n\n    struct Ilk {\n        uint256 Art;   \n        uint256 rate;  \n        uint256 spot;  \n        uint256 line;  \n        uint256 dust;  \n    }\n\n    mapping (bytes32 => mapping (address => Urn )) public urns;\n    mapping (bytes32 => Ilk)                       public ilks;\n\n    function can(address, address) public view returns (uint);\n    function dai(address) public view returns (uint);\n    function frob(bytes32, address, address, address, int, int) public;\n    function hope(address) public;\n    function move(address, address, uint) public;\n}\n\ncontract Gem {\n    function dec() public returns (uint);\n    function gem() public returns (Gem);\n    function join(address, uint) public payable;\n    function exit(address, uint) public;\n\n    function approve(address, uint) public;\n    function transfer(address, uint) public returns (bool);\n    function transferFrom(address, address, uint) public returns (bool);\n    function deposit() public payable;\n    function withdraw(uint) public;\n    function allowance(address, address) public returns (uint);\n}\n\ncontract DaiJoin {\n    function vat() public returns (Vat);\n    function dai() public returns (Gem);\n    function join(address, uint) public payable;\n    function exit(address, uint) public;\n}\n\ncontract OtcInterface {\n    function buyAllAmount(address, uint, address, uint) public returns (uint);\n\n    function getPayAmount(address, address, uint) public view returns (uint);\n    function getBuyAmount(address, address, uint) public view returns (uint);\n}\n\ncontract ValueLike {\n    function peek() public returns (uint, bool);\n}\n\ncontract VoxLike {\n    function par() public returns (uint);\n}\n\ncontract SaiTubLike {\n    function skr() public view returns (Gem);\n    function gem() public view returns (Gem);\n    function gov() public view returns (Gem);\n    function sai() public view returns (Gem);\n    function pep() public view returns (ValueLike);\n    function vox() public view returns (VoxLike);\n    function bid(uint) public view returns (uint);\n    function ink(bytes32) public view returns (uint);\n    function tag() public view returns (uint);\n    function tab(bytes32) public returns (uint);\n    function rap(bytes32) public returns (uint);\n    function draw(bytes32, uint) public;\n    function shut(bytes32) public;\n    function exit(uint) public;\n    function give(bytes32, address) public;\n    function lad(bytes32 cup) public view returns (address);\n    function cups(bytes32) public returns (address, uint, uint, uint);\n}\n\ncontract ScdMcdMigration {\n    SaiTubLike public tub;\n    DaiJoin public daiJoin;\n\n    function swapSaiToDai(uint) external;\n    function swapDaiToSai(uint) external;\n    function migrate(bytes32) external returns (uint);\n}\n\ncontract CustomMigrationProxyActions is DSMath {\n\n    function migrate(\n        address payable scdMcdMigration,    \n        bytes32 cup                         \n    ) public returns (uint cdp) {\n        SaiTubLike tub = ScdMcdMigration(scdMcdMigration).tub();\n        \n        (uint val, bool ok) = tub.pep().peek();\n        if (ok && val != 0) {\n            \n            uint govFee = wdiv(tub.rap(cup), val);\n\n            \n\n            address owner = DSProxy(uint160(address(this))).owner();\n\n            require(tub.gov().transferFrom(owner, address(scdMcdMigration), govFee), \"transfer-failed\");\n        }\n        \n        tub.give(cup, address(scdMcdMigration));\n        \n        cdp = ScdMcdMigration(scdMcdMigration).migrate(cup);\n    }\n\n    function migratePayFeeWithGem(\n        address payable scdMcdMigration,    \n        bytes32 cup,                        \n        address otc,                        \n        address payGem,                     \n        uint maxPayAmt                      \n    ) public returns (uint cdp) {\n        SaiTubLike tub = ScdMcdMigration(scdMcdMigration).tub();\n        \n        (uint val, bool ok) = tub.pep().peek();\n        if (ok && val != 0) {\n            \n            uint govFee = wdiv(tub.rap(cup), val);\n\n            \n            uint payAmt = OtcInterface(otc).getPayAmount(payGem, address(tub.gov()), govFee);\n            \n            require(maxPayAmt >= payAmt, \"maxPayAmt-exceeded\");\n            \n            if (Gem(payGem).allowance(address(this), otc) < payAmt) {\n                Gem(payGem).approve(otc, payAmt);\n            }\n\n            address owner = DSProxy(uint160(address(this))).owner();\n            \n            require(Gem(payGem).transferFrom(owner, address(this), payAmt), \"transfer-failed\");\n            \n            OtcInterface(otc).buyAllAmount(address(tub.gov()), govFee, payGem, payAmt);\n            \n            require(tub.gov().transfer(address(scdMcdMigration), govFee), \"transfer-failed\");\n        }\n        \n        tub.give(cup, address(scdMcdMigration));\n        \n        cdp = ScdMcdMigration(scdMcdMigration).migrate(cup);\n    }\n\n    function _getRatio(\n        SaiTubLike tub,\n        bytes32 cup\n    ) internal returns (uint ratio) {\n        ratio = rdiv(\n                        rmul(tub.tag(), tub.ink(cup)),\n                        rmul(tub.vox().par(), tub.tab(cup))\n                    );\n    }\n\n    function migratePayFeeWithDebt(\n        address payable scdMcdMigration,    \n        bytes32 cup,                        \n        address otc,                        \n        uint maxPayAmt,                     \n        uint minRatio                       \n    ) public returns (uint cdp) {\n        SaiTubLike tub = ScdMcdMigration(scdMcdMigration).tub();\n        \n        (uint val, bool ok) = tub.pep().peek();\n        if (ok && val != 0) {\n            \n            uint govFee = wdiv(tub.rap(cup), val) + 1; \n\n            \n            uint payAmt = OtcInterface(otc).getPayAmount(address(tub.sai()), address(tub.gov()), govFee);\n            \n            require(maxPayAmt >= payAmt, \"maxPayAmt-exceeded\");\n            \n            tub.draw(cup, payAmt);\n\n            require(_getRatio(tub, cup) > minRatio, \"minRatio-failed\");\n\n            \n            if (Gem(address(tub.sai())).allowance(address(this), otc) < payAmt) {\n                Gem(address(tub.sai())).approve(otc, payAmt);\n            }\n            \n            OtcInterface(otc).buyAllAmount(address(tub.gov()), govFee, address(tub.sai()), payAmt);\n            \n            govFee = wdiv(tub.rap(cup), val);\n            require(tub.gov().transfer(address(scdMcdMigration), govFee), \"transfer-failed\");\n        }\n        \n        tub.give(cup, address(scdMcdMigration));\n        \n        cdp = ScdMcdMigration(scdMcdMigration).migrate(cup);\n    }\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"scdMcdMigration\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"maxPayAmt\",\"type\":\"uint256\"},{\"name\":\"minRatio\",\"type\":\"uint256\"}],\"name\":\"migratePayFeeWithDebt\",\"outputs\":[{\"name\":\"cdp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"scdMcdMigration\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"},{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"payGem\",\"type\":\"address\"},{\"name\":\"maxPayAmt\",\"type\":\"uint256\"}],\"name\":\"migratePayFeeWithGem\",\"outputs\":[{\"name\":\"cdp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"scdMcdMigration\",\"type\":\"address\"},{\"name\":\"cup\",\"type\":\"bytes32\"}],\"name\":\"migrate\",\"outputs\":[{\"name\":\"cdp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CustomMigrationProxyActions","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://f16ccb9f44c5957a401ad8b927f0d70a7085d9c7ba282261e0bc36282773aac1"}]}