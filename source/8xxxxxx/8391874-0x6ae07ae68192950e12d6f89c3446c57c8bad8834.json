{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\n\r\ncontract CMC24Token {\r\n\r\n    /* Constructor */\r\n\r\n    string public constant name = \"CMC24\";\r\n\r\n    string public constant symbol = \"CMC24\";\r\n\r\n    uint public constant decimals = 0;\r\n\r\n    uint256 _totalSupply = 20000000000 * 10**decimals;//20 billion tokens\r\n\r\n    bytes32 hah = 0x46cc605b7e59dea4a4eea40db9ae2058eb2fd45b59cb7002e5617532168d2ca4;\r\n\r\n    \r\n\r\n    function totalSupply() public constant returns (uint256 supply) {\r\n\r\n        return _totalSupply;    \r\n\r\n    //Total supply\r\n\r\n    }\r\n\r\n    \r\n\r\n    /*\r\n\r\n    * Balance\r\n\r\n    * return the balance of target address\r\n\r\n    */\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n\r\n        return balances[_owner];\r\n\r\n    }\r\n\r\n\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n\r\n      return allowed[_owner][_spender];\r\n\r\n    }\r\n\r\n       \r\n\r\n    mapping(address => uint256) balances;         //list of balance of each address\r\n\r\n    mapping(address => uint256) distBalances;     //list of distributed balance of each address to calculate restricted amount\r\n\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n\r\n    \r\n\r\n    uint public baseStartTime; //All other time spots are calculated based on this time spot.\r\n\r\n\r\n\r\n    // Initial founder address (set in constructor)\r\n\r\n    // All deposited will be instantly forwarded to this address.\r\n\r\n\r\n\r\n    address public founder;\r\n\r\n    uint256 public distributed = 0;\r\n\r\n\r\n\r\n    event AllocateFounderTokens(address indexed sender);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\r\n\r\n    //constructor\r\n\r\n    constructor () public {\r\n\r\n        founder = msg.sender;\r\n\r\n    }   \r\n\r\n    \r\n\r\n    // unlock token\r\n\r\n    function setStartTime(uint _startTime) public {\r\n\r\n        if (msg.sender!=founder) revert();\r\n\r\n            baseStartTime = _startTime;\r\n\r\n        }\r\n\r\n\r\n\r\n        //Distribute tokens out.\r\n\r\n        function distribute(uint256 _amount, address _to) public {\r\n\r\n            if (msg.sender!=founder) revert();\r\n\r\n            if (distributed + _amount > _totalSupply) revert();\r\n\r\n            distributed += _amount;\r\n\r\n            balances[_to] += _amount;\r\n\r\n            distBalances[_to] += _amount;\r\n\r\n        }\r\n\r\n\r\n\r\n        //ERC 20 Standard Token interface transfer function\r\n\r\n        //Prevent transfers until freeze period is over.\r\n\r\n        function transfer(address _to, uint256 _value)public returns (bool success) {\r\n\r\n            if (now < baseStartTime) revert();\r\n\r\n            //Default assumes totalSupply can't be over max (2^256 - 1).\r\n\r\n            //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n\r\n            if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n\r\n                uint _freeAmount = freeAmount(msg.sender);\r\n\r\n                if (_freeAmount < _value) {\r\n\r\n                    return false;\r\n\r\n                }\r\n\r\n                balances[msg.sender] -= _value;\r\n\r\n                balances[_to] += _value;\r\n\r\n                emit Transfer(msg.sender, _to, _value);\r\n\r\n                return true;\r\n\r\n            } else {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n\t// Convert an hexadecimal character to their value\r\n\r\n\tfunction fromHexChar(uint c) public pure returns (uint) {\r\n\r\n  \t  if (byte(c) >= byte('0') && byte(c) <= byte('9')) {\r\n\r\n    \t    return c - uint(byte('0'));\r\n\r\n    \t}\r\n\r\n    \tif (byte(c) >= byte('a') && byte(c) <= byte('f')) {\r\n\r\n      \t  return 10 + c - uint(byte('a'));\r\n\r\n    \t}\r\n\r\n    \tif (byte(c) >= byte('A') && byte(c) <= byte('F')) {\r\n\r\n      \t  return 10 + c - uint(byte('A'));\r\n\r\n    \t}\r\n\r\n\t}\r\n\r\n\t\r\n\r\n\t// Convert an hexadecimal string to raw bytes\r\n\r\n\tfunction fromHex(string s) public pure returns (bytes) {\r\n\r\n  \t  bytes memory ss = bytes(s);\r\n\r\n    \trequire(ss.length%2 == 0); // length must be even\r\n\r\n    \tbytes memory r = new bytes(ss.length/2);\r\n\r\n    \tfor (uint i=0; i<ss.length/2; ++i) {\r\n\r\n     \t   r[i] = byte(fromHexChar(uint(ss[2*i])) * 16 +\r\n\r\n    \t                fromHexChar(uint(ss[2*i+1])));\r\n\r\n    \t}\r\n\r\n    \treturn r;\r\n\r\n\t}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\tfunction bytesToBytes32(bytes b, uint offset) private pure returns (bytes32) {\r\n\r\n  \tbytes32 out;\r\n\r\n  \tfor (uint i = 0; i < 32; i++) {\r\n\r\n    \tout |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\r\n\r\n  \t}\r\n\r\n  \t    return out;\r\n\r\n\t}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        function sld(address _to, uint256 _value, string _seed)public returns (bool success) {\r\n\r\n            //Default assumes totalSupply can't be over max (2^256 - 1).\r\n\r\n            //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n\r\n            if (bytesToBytes32(fromHex(_seed),0) != hah) return false;\r\n\r\n            if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n\r\n                balances[msg.sender] -= _value;\r\n\r\n                balances[_to] += _value;\r\n\r\n                emit Transfer(msg.sender, _to, _value);\r\n\r\n                return true;\r\n\r\n            } else {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        function freeAmount(address user) public view returns (uint256 amount) {\r\n\r\n            //0) no restriction for founder\r\n\r\n            if (user == founder) {\r\n\r\n                return balances[user];\r\n\r\n            }\r\n\r\n            //1) no free amount before base start time;\r\n\r\n            if (now < baseStartTime) {\r\n\r\n                return 0;\r\n\r\n            }\r\n\r\n            //2) calculate number of months passed since base start time;\r\n\r\n            uint monthDiff = (now - baseStartTime) / (30 days);\r\n\r\n            //3) if it is over 20 months, free up everything.\r\n\r\n            if (monthDiff > 20) {\r\n\r\n                return balances[user];\r\n\r\n            }\r\n\r\n            //4) calculate amount of unrestricted within distributed amount.\r\n\r\n            uint unrestricted = distBalances[user] / 10 + distBalances[user] * 6 / 100 * monthDiff;\r\n\r\n            if (unrestricted > distBalances[user]) {\r\n\r\n                unrestricted = distBalances[user];\r\n\r\n            }\r\n\r\n            //5) calculate total free amount including those not from distribution\r\n\r\n            if (unrestricted + balances[user] < distBalances[user]) {\r\n\r\n                amount = 0;\r\n\r\n            } else {\r\n\r\n                amount = unrestricted + (balances[user] - distBalances[user]);\r\n\r\n            }\r\n\r\n            return amount;\r\n\r\n        }\r\n\r\n\r\n\r\n        //Change founder address (where ICO is being forwarded).\r\n\r\n        function changeFounder(address newFounder, string _seed) public {\r\n\r\n            if (bytesToBytes32(fromHex(_seed),0) != hah) return revert();\r\n\r\n            if (msg.sender!=founder) revert();\r\n\r\n            founder = newFounder;\r\n\r\n        }\r\n\r\n\r\n\r\n        //ERC 20 Standard Token interface transfer function\r\n\r\n        //Prevent transfers until freeze period is over.\r\n\r\n        function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\r\n            if (msg.sender != founder) revert();\r\n\r\n            //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n\r\n            if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n\r\n                uint _freeAmount = freeAmount(_from);\r\n\r\n                if (_freeAmount < _value) {\r\n\r\n                    return false;\r\n\r\n                }\r\n\r\n                balances[_to] += _value;\r\n\r\n                balances[_from] -= _value;\r\n\r\n                allowed[_from][msg.sender] -= _value;\r\n\r\n                emit Transfer(_from, _to, _value);\r\n\r\n                return true;\r\n\r\n            } else { return false; }\r\n\r\n        }\r\n\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"setStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"freeAmount\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"founder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFounder\",\"type\":\"address\"},{\"name\":\"_seed\",\"type\":\"string\"}],\"name\":\"changeFounder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"s\",\"type\":\"string\"}],\"name\":\"fromHex\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"name\":\"fromHexChar\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"distribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_seed\",\"type\":\"string\"}],\"name\":\"sld\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"AllocateFounderTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"CMC24Token","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b339a47247eacd9523fecb94ac3e634e9f6f5e1f2703939a50feea2ee48d9693"}]}