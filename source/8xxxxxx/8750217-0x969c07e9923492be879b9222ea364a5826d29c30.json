{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\n\ninterface IProcessor {\n\n    function processPayment(address user, uint cost, uint items, address referrer) external payable returns (uint id);\n    \n}\n\ncontract Pack {\n\n    enum Type {\n        Rare, Epic, Legendary, Shiny\n    }\n\n}\n\ncontract Ownable {\n\n    address payable public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setOwner(address payable _owner) public onlyOwner {\n        owner = _owner;\n    }\n\n    function getOwner() public view returns (address payable) {\n        return owner;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"must be owner to call this function\");\n        _;\n    }\n\n}\n\n// from OZ\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n// from OZ\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath64 {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint64 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract ICards {\n\n    enum Rarity {\n        Common, Rare, Epic, Legendary, Mythic\n    }\n\n    function getRandomCard(Rarity rarity, uint16 random) public view returns (uint16);\n    function createCard(address user, uint16 proto, uint16 purity) public returns (uint);\n\n\n}\n\n\ncontract RarityProvider {\n\n    ICards cards;\n\n    constructor(ICards _cards) public {\n        cards = _cards;\n    }\n\n    struct RandomnessComponents {\n        uint random;\n        uint32 rarity;\n        uint16 quality;\n        uint16 purity;\n        uint16 proto;\n    }\n\n    // return 'length' bytes of 'num' starting at 'start'\n    function extract(uint num, uint length, uint start) internal pure returns (uint) {\n        return (((1 << (length * 8)) - 1) & (num >> ((start - 1) * 8)));\n    }\n\n    // divides the random seed into components\n    function getComponents(\n        uint cardIndex, uint rand\n    ) internal pure returns (\n        RandomnessComponents memory\n    ) {\n        uint random = uint(keccak256(abi.encodePacked(cardIndex, rand)));\n        return RandomnessComponents({\n            random: random,\n            rarity: uint32(extract(random, 4, 10) % 1000000),\n            quality: uint16(extract(random, 2, 4) % 1000),\n            purity: uint16(extract(random, 2, 6) % 1000),\n            proto: uint16(extract(random, 2, 8) % (2**16-1))\n        });\n    }\n\n    function getCardDetails(Pack.Type packType, uint cardIndex, uint result) internal view returns (uint16, uint16) {\n        if (packType == Pack.Type.Shiny) {\n            return _getShinyCardDetails(cardIndex, result);\n        } else if (packType == Pack.Type.Legendary) {\n            return _getLegendaryCardDetails(cardIndex, result);\n        } else if (packType == Pack.Type.Epic) {\n            return _getEpicCardDetails(cardIndex, result);\n        }\n        return _getRareCardDetails(cardIndex, result);\n    }\n\n    function _getShinyCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\n        \n        RandomnessComponents memory rc = getComponents(cardIndex, result); \n\n        ICards.Rarity rarity;\n\n        if (cardIndex % 5 == 0) {\n            rarity = _getLegendaryPlusRarity(rc.rarity);\n            purity = _getShinyPurityBase(rc.quality) + rc.purity;\n        } else if (cardIndex % 5 == 1) {\n            rarity = _getRarePlusRarity(rc.rarity);\n            purity = _getPurityBase(rc.quality) + rc.purity;\n        } else {\n            rarity = _getCommonPlusRarity(rc.rarity);\n            purity = _getPurityBase(rc.quality) + rc.purity;\n        }\n        proto = cards.getRandomCard(rarity, rc.proto);\n        return (proto, purity);\n    }\n\n    function _getLegendaryCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\n        \n        RandomnessComponents memory rc = getComponents(cardIndex, result);\n\n        ICards.Rarity rarity;\n\n        if (cardIndex % 5 == 0) {\n            rarity = _getLegendaryPlusRarity(rc.rarity);\n        } else if (cardIndex % 5 == 1) {\n            rarity = _getRarePlusRarity(rc.rarity);\n        } else {\n            rarity = _getCommonPlusRarity(rc.rarity);\n        }\n\n        purity = _getPurityBase(rc.quality) + rc.purity;\n    \n        proto = cards.getRandomCard(rarity, rc.proto);\n\n        return (proto, purity);\n    }\n\n\n    function _getEpicCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\n        \n        RandomnessComponents memory rc = getComponents(cardIndex, result);\n\n        ICards.Rarity rarity;\n\n        if (cardIndex % 5 == 0) {\n            rarity = _getEpicPlusRarity(rc.rarity);\n        } else {\n            rarity = _getCommonPlusRarity(rc.rarity);\n        }\n\n        purity = _getPurityBase(rc.quality) + rc.purity;\n    \n        proto = cards.getRandomCard(rarity, rc.proto);\n\n        return (proto, purity);\n    } \n\n    function _getRareCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\n\n        RandomnessComponents memory rc = getComponents(cardIndex, result);\n\n        ICards.Rarity rarity;\n\n        if (cardIndex % 5 == 0) {\n            rarity = _getRarePlusRarity(rc.rarity);\n        } else {\n            rarity = _getCommonPlusRarity(rc.rarity);\n        }\n\n        purity = _getPurityBase(rc.quality) + rc.purity;\n    \n        proto = cards.getRandomCard(rarity, rc.proto);\n        return (proto, purity);\n    }  \n\n\n    function _getCommonPlusRarity(uint32 rand) internal pure returns (ICards.Rarity) {\n        if (rand == 999999) {\n            return ICards.Rarity.Mythic;\n        } else if (rand >= 998345) {\n            return ICards.Rarity.Legendary;\n        } else if (rand >= 986765) {\n            return ICards.Rarity.Epic;\n        } else if (rand >= 924890) {\n            return ICards.Rarity.Rare;\n        } else {\n            return ICards.Rarity.Common;\n        }\n    }\n\n    function _getRarePlusRarity(uint32 rand) internal pure returns (ICards.Rarity) {\n        if (rand == 999999) {\n            return ICards.Rarity.Mythic;\n        } else if (rand >= 981615) {\n            return ICards.Rarity.Legendary;\n        } else if (rand >= 852940) {\n            return ICards.Rarity.Epic;\n        } else {\n            return ICards.Rarity.Rare;\n        } \n    }\n\n    function _getEpicPlusRarity(uint32 rand) internal pure returns (ICards.Rarity) {\n        if (rand == 999999) {\n            return ICards.Rarity.Mythic;\n        } else if (rand >= 981615) {\n            return ICards.Rarity.Legendary;\n        } else {\n            return ICards.Rarity.Epic;\n        }\n    }\n\n    function _getLegendaryPlusRarity(uint32 rand) internal pure returns (ICards.Rarity) {\n        if (rand == 999999) {\n            return ICards.Rarity.Mythic;\n        } else {\n            return ICards.Rarity.Legendary;\n        } \n    }\n\n    // store purity and shine as one number to save users gas\n    function _getPurityBase(uint16 randOne) internal pure returns (uint16) {\n        if (randOne >= 998) {\n            return 3000;\n        } else if (randOne >= 988) {\n            return 2000;\n        } else if (randOne >= 938) {\n            return 1000;\n        }\n        return 0;\n    }\n\n    function _getShinyPurityBase(uint16 randOne) internal pure returns (uint16) {\n        if (randOne >= 998) {\n            return 3000;\n        } else if (randOne >= 748) {\n            return 2000;\n        } else {\n            return 1000;\n        }\n    }\n\n    function getShine(uint16 purity) public pure returns (uint8) {\n        return uint8(purity / 1000);\n    }\n\n}\n\n\n\n\n\n\ncontract PackFive is Ownable, RarityProvider {\n\n    using SafeMath for uint;\n    using SafeMath64 for uint64;\n\n    // fired after user purchases count packs, producing purchase with id\n    event PacksPurchased(uint indexed paymentID, uint indexed id, Pack.Type indexed packType, address user, uint count, uint64 lockup);\n    // fired after the callback transaction is successful, replaces RandomnessReceived\n    event CallbackMade(uint indexed id, address indexed user, uint count, uint randomness);\n    // fired after a recommit for a purchase\n    event Recommit(uint indexed id, Pack.Type indexed packType, address indexed user, uint count, uint64 lockup);\n    // fired after a card is activated, replaces PacksOpened\n    event CardActivated(uint indexed purchaseID, uint cardIndex, uint indexed cardID, uint16 proto, uint16 purity);\n    // fired after a chest is opened\n    event ChestsOpened(uint indexed id, Pack.Type indexed packType, address indexed user, uint count, uint packCount);\n    // fired after a purchase is recorded (either buying packs directly or indirectly)\n    // callback sentinels should watch this event\n    event PurchaseRecorded(uint indexed id, Pack.Type indexed packType, address indexed user, uint count, uint64 lockup);\n    // fired after a purchase is revoked\n    event PurchaseRevoked(uint indexed paymentID, address indexed revoker);\n    // fired when a new pack is added\n    event PackAdded(Pack.Type indexed packType, uint price, address chest);\n\n    struct Purchase {\n        uint count;\n        uint randomness;\n        uint[] state;\n        Pack.Type packType;\n        uint64 commit;\n        uint64 lockup;\n        bool revoked;\n        address user;\n    }\n\n    struct PackInstance {\n        uint price;\n        uint chestSize;\n        address token;\n    }\n\n    Purchase[] public purchases;\n    IProcessor public processor;\n    mapping(uint => PackInstance) public packs;\n    mapping(address => bool) public canLockup;\n    mapping(address => bool) public canRevoke;\n    uint public commitLag = 0;\n    // TODO: check this fits under mainnet gas limit\n    uint16 public activationLimit = 40;\n    // override switch in case of contract upgrade etc\n    bool public canActivate = false;\n    // maximum lockup length in blocks\n    uint64 public maxLockup = 600000;\n\n    constructor(ICards _cards, IProcessor _processor) public RarityProvider(_cards) {\n        processor = _processor;\n    }\n\n    // == Admin Functions ==\n    function setCanLockup(address user, bool can) public onlyOwner {\n        canLockup[user] = can;\n    }\n\n    function setCanRevoke(address user, bool can) public onlyOwner {\n        canRevoke[user] = can;\n    }\n\n    function setCommitLag(uint lag) public onlyOwner {\n        require(commitLag < 100, \"can't have a commit lag of >100 blocks\");\n        commitLag = lag;\n    }\n\n    function setActivationLimit(uint16 _limit) public onlyOwner {\n        activationLimit = _limit;\n    }\n\n    function setMaxLockup(uint64 _max) public onlyOwner {\n        maxLockup = _max;\n    }\n\n    function setPack(\n        Pack.Type packType, uint price, address chest, uint chestSize\n    ) public onlyOwner {\n\n        PackInstance memory p = getPack(packType);\n        require(p.token == address(0) && p.price == 0, \"pack instance already set\");\n\n        require(price > 0, \"price cannot be zero\");\n        require(price % 100 == 0, \"price must be a multiple of 100 wei\");\n        require(address(processor) != address(0), \"processor must be set\");\n\n        packs[uint(packType)] = PackInstance({\n            token: chest,\n            price: price,\n            chestSize: chestSize\n        });\n\n        emit PackAdded(packType, price, chest);\n    }\n\n    function setActivate(bool can) public onlyOwner {\n        canActivate = can;\n    }\n\n    function canActivatePurchase(uint id) public view returns (bool) {\n        if (!canActivate) {\n            return false;\n        }\n        Purchase memory p = purchases[id];\n        if (p.lockup > 0) {\n            if (inLockupPeriod(p)) {\n                return false;\n            }\n            return !p.revoked;\n        }\n        return true;\n    }\n\n    function revoke(uint id) public {\n        require(canRevoke[msg.sender], \"sender not approved to revoke\");\n        Purchase storage p = purchases[id];\n        require(!p.revoked, \"must not be revoked already\");\n        require(p.lockup > 0, \"must have lockup set\");\n        require(inLockupPeriod(p), \"must be in lockup period\");\n        p.revoked = true;\n        emit PurchaseRevoked(id, msg.sender);\n    }\n\n    // == User Functions ==\n\n    function purchase(Pack.Type packType, uint16 count, address referrer) public payable returns (uint) {\n        return purchaseFor(packType, msg.sender, count, referrer, 0);\n    }\n\n    function purchaseFor(Pack.Type packType, address user, uint16 count, address referrer, uint64 lockup) public payable returns (uint) {\n\n        PackInstance memory pack = getPack(packType);\n\n        uint purchaseID = _recordPurchase(packType, user, count, lockup);\n    \n        uint paymentID = processor.processPayment.value(msg.value)(msg.sender, pack.price, count, referrer);\n        \n        emit PacksPurchased(paymentID, purchaseID, packType, user, count, lockup);\n\n        return purchaseID;\n    }\n\n    function activateMultiple(uint[] memory pIDs, uint[] memory cardIndices)\n        public returns (uint[] memory ids, uint16[] memory protos, uint16[] memory purities) {\n        uint len = pIDs.length;\n        require(len > 0, \"can't activate no cards\");\n        require(len <= activationLimit, \"can't activate more than the activation limit\");\n        require(len == cardIndices.length, \"must have the same length\");\n        ids = new uint[](len);\n        protos = new uint16[](len);\n        purities = new uint16[](len);\n        for (uint i = 0; i < len; i++) {\n            (ids[i], protos[i], purities[i]) = activate(pIDs[i], cardIndices[i]);\n        }\n        return (ids, protos, purities);\n    }\n\n    function activate(uint purchaseID, uint cardIndex) public returns (uint id, uint16 proto, uint16 purity) {\n        \n        require(canActivatePurchase(purchaseID), \"can't activate purchase\");\n        Purchase storage p = purchases[purchaseID];\n        \n        require(p.randomness != 0, \"must have been a callback\");\n        uint cardCount = uint(p.count).mul(5);\n        require(cardIndex < cardCount, \"not a valid card index\");\n        uint bit = getStateBit(purchaseID, cardIndex);\n        // can only activate each card once\n        require(bit == 0, \"card has already been activated\");\n        uint x = cardIndex.div(256);\n        uint pos = cardIndex % 256;\n        // mark the card as activated by flipping the relevant bit\n        p.state[x] ^= uint(1) << pos;\n        // create the card\n        (proto, purity) = getCardDetails(p.packType, cardIndex, p.randomness);\n        id = cards.createCard(p.user, proto, purity);\n        emit CardActivated(purchaseID, cardIndex, id, proto, purity);\n        return (id, proto, purity);\n    }\n\n    // 'open' a number of chest tokens\n    function openChest(Pack.Type packType, address user, uint count) public returns (uint) {\n        \n        PackInstance memory pack = getPack(packType);\n\n        require(msg.sender == pack.token, \"can only open from the actual token packs\");\n\n        uint packCount = count.mul(pack.chestSize);\n        \n        uint id = _recordPurchase(packType, user, packCount, 0);\n\n        emit ChestsOpened(id, packType, user, count, packCount);\n\n        return id;\n    }\n\n    function _recordPurchase(Pack.Type packType, address user, uint count, uint64 lockup) internal returns (uint) {\n\n        if (lockup != 0) {\n            require(lockup < maxLockup, \"lockup must be lower than maximum\");\n            require(canLockup[msg.sender], \"only some people can lockup cards\");\n        }\n        \n        Purchase memory p = Purchase({\n            user: user,\n            count: count,\n            commit: getCommitBlock(),\n            randomness: 0,\n            packType: packType,\n            state: new uint256[](getStateSize(count)),\n            lockup: lockup,\n            revoked: false\n        });\n\n        uint id = purchases.push(p).sub(1);\n\n        emit PurchaseRecorded(id, packType, user, count, lockup);\n        return id;\n    }\n\n    // can be called by anybody\n    function callback(uint id) public {\n\n        Purchase storage p = purchases[id];\n\n        require(p.randomness == 0, \"randomness already set\");\n\n        require(uint64(block.number) > p.commit, \"cannot callback before commit\");\n\n        // must be within last 256 blocks, otherwise recommit\n        require(p.commit.add(uint64(256)) >= block.number, \"must recommit\");\n\n        bytes32 bhash = blockhash(p.commit);\n\n        require(uint(bhash) != 0, \"blockhash must not be zero\");\n\n        // only use properties which can't be altered by the user\n        // id and factory are determined before the reveal\n        // 'last' determined param must be random\n        p.randomness = uint(keccak256(abi.encodePacked(id, bhash, address(this))));\n\n        emit CallbackMade(id, p.user, p.count, p.randomness);\n    }\n\n    // can recommit\n    // this gives you more chances\n    // if no-one else sends the callback (should never happen)\n    // still only get a random extra chance\n    function recommit(uint id) public {\n        Purchase storage p = purchases[id];\n        require(p.randomness == 0, \"randomness already set\");\n        require(block.number >= p.commit.add(uint64(256)), \"no need to recommit\");\n        p.commit = getCommitBlock();\n        emit Recommit(id, p.packType, p.user, p.count, p.lockup);\n    }\n\n    // == View Functions ==\n\n    function getCommitBlock() internal view returns (uint64) {\n        return uint64(block.number.add(commitLag));\n    }\n\n    function getStateSize(uint count) public pure returns (uint) {\n        return count.mul(5).sub(1).div(256).add(1);\n    }\n\n    function getPurchaseState(uint purchaseID) public view returns (uint[] memory state) {\n        require(purchases.length > purchaseID, \"invalid purchase id\");\n        Purchase memory p = purchases[purchaseID];\n        return p.state;\n    }\n    \n    function getPackDetails(Pack.Type packType) public view returns (address token, uint price) {\n        PackInstance memory p = getPack(packType);\n        return (p.token, p.price);\n    }\n\n    function getPack(Pack.Type packType) internal view returns (PackInstance memory) {\n        return packs[uint(packType)];\n    }\n\n    function getPrice(Pack.Type packType) public view returns (uint) {\n        PackInstance memory p = getPack(packType);\n        require(p.price != 0, \"price is not yet set\");\n        return p.price;\n    }\n\n    function getChestSize(Pack.Type packType) public view returns (uint) {\n        PackInstance memory p = getPack(packType);\n        require(p.chestSize != 0, \"chest size is not yet set\");\n        return p.chestSize;\n    }\n\n    function isActivated(uint purchaseID, uint cardIndex) public view returns (bool) {\n        return getStateBit(purchaseID, cardIndex) != 0;\n    }\n\n    function getStateBit(uint purchaseID, uint cardIndex) public view returns (uint) {\n        Purchase memory p = purchases[purchaseID];\n        uint x = cardIndex.div(256);\n        uint slot = p.state[x];\n        uint pos = cardIndex % 256;\n        uint bit = (slot >> pos) & uint(1);\n        return bit;\n    }\n\n    function predictPacks(uint id) external view returns (uint16[] memory protos, uint16[] memory purities) {\n\n        Purchase memory p = purchases[id];\n\n        require(p.randomness != 0, \"randomness not yet set\");\n\n        uint result = p.randomness;\n\n        uint cardCount = uint(p.count).mul(5);\n\n        purities = new uint16[](cardCount);\n        protos = new uint16[](cardCount);\n\n        for (uint i = 0; i < cardCount; i++) {\n            (protos[i], purities[i]) = getCardDetails(p.packType, i, result);\n        }\n\n        return (protos, purities);\n    }\n \n    function inLockupPeriod(Purchase memory p) internal view returns (bool) {\n        return p.commit.add(p.lockup) >= block.number;\n    }\n\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"canActivatePurchase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lag\",\"type\":\"uint256\"}],\"name\":\"setCommitLag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canRevoke\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"}],\"name\":\"getChestSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"purchaseID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardIndex\",\"type\":\"uint256\"}],\"name\":\"getStateBit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canActivate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxLockup\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commitLag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"recommit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"purchaseID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardIndex\",\"type\":\"uint256\"}],\"name\":\"isActivated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"can\",\"type\":\"bool\"}],\"name\":\"setCanLockup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_max\",\"type\":\"uint64\"}],\"name\":\"setMaxLockup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"can\",\"type\":\"bool\"}],\"name\":\"setActivate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getStateSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"purchases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"},{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"commit\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lockup\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"revoked\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"purity\",\"type\":\"uint16\"}],\"name\":\"getShine\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"purchaseID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardIndex\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"purity\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activationLimit\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"packs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chestSize\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"chest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chestSize\",\"type\":\"uint256\"}],\"name\":\"setPack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canLockup\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"predictPacks\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"protos\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"purities\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"processor\",\"outputs\":[{\"internalType\":\"contract IProcessor\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_limit\",\"type\":\"uint16\"}],\"name\":\"setActivationLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"purchaseID\",\"type\":\"uint256\"}],\"name\":\"getPurchaseState\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"state\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"lockup\",\"type\":\"uint64\"}],\"name\":\"purchaseFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"can\",\"type\":\"bool\"}],\"name\":\"setCanRevoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"openChest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"}],\"name\":\"getPackDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pIDs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"cardIndices\",\"type\":\"uint256[]\"}],\"name\":\"activateMultiple\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16[]\",\"name\":\"protos\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"purities\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICards\",\"name\":\"_cards\",\"type\":\"address\"},{\"internalType\":\"contract IProcessor\",\"name\":\"_processor\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"paymentID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lockup\",\"type\":\"uint64\"}],\"name\":\"PacksPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"CallbackMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lockup\",\"type\":\"uint64\"}],\"name\":\"Recommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"purchaseID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cardIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cardID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"purity\",\"type\":\"uint16\"}],\"name\":\"CardActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packCount\",\"type\":\"uint256\"}],\"name\":\"ChestsOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lockup\",\"type\":\"uint64\"}],\"name\":\"PurchaseRecorded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"paymentID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"revoker\",\"type\":\"address\"}],\"name\":\"PurchaseRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"chest\",\"type\":\"address\"}],\"name\":\"PackAdded\",\"type\":\"event\"}]","ContractName":"PackFive","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006ebeaf8e8e946f0716e6533a6f2cefc83f60e8ab000000000000000000000000474b0ffce789035f69fabbb870a56ef4c6c24daf","Library":"","LicenseType":"","SwarmSource":"bzzr://e585297f761cd45c2a6e2787d89a79a94411d16a969527e2a296095abd33f7fd"}]}