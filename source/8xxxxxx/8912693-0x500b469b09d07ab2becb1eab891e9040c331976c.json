{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.11;\r\ncontract mazzafakka {\r\n     // STARK_Friendly_Hash_Challenge_GMiMC_erf_S128b\r\n \r\n     // 0xc6229fadB32322b86B8F923b5Ae45d28D9f47dcA\r\n     // roundconstants 0xbA7F0E355a55fF14Ca56e26cbfD1e679ac4a7Be0\r\n      uint256 constant prime = 14474011154664525231415395255581126252639794253786371766033694892385558855681;\r\n      uint constant r = 2;\r\n      uint constant c = 1;\r\n      uint constant nRounds = 326;\r\n      uint constant m = r + c;\r\n      uint outputSize = c;\r\n     \r\n      function LoadAuxdata()\r\n        public view\r\n        returns (uint256[] memory roundConstants)\r\n    {\r\n        roundConstants = new uint256[](nRounds);\r\n        address contractAddr = 0xbA7F0E355a55fF14Ca56e26cbfD1e679ac4a7Be0 ;\r\n        assembly {\r\n            let sizeInBytes := mul(mload(roundConstants), 0x20)\r\n            extcodecopy(contractAddr, add(roundConstants, 0x20), 0, sizeInBytes)\r\n        }\r\n    }\r\n function submod(uint a, uint b, uint _prime) public view returns (uint){\r\n      uint a_nn;\r\n\r\n      if(a>b) {\r\n        a_nn = a;\r\n      } else {\r\n        a_nn = a+_prime;\r\n      }\r\n\r\n      uint c = addmod(a_nn - b,0,_prime);\r\n\r\n      return c;\r\n  }\r\nfunction permutation_func(uint256[] memory roundConstants, uint256[] memory elements)\r\n        internal view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256 length = elements.length;\r\n        require(length == m, \"elements length is not equal to m.\");\r\n        for (uint256 i = 0; i < roundConstants.length; i++) {\r\n            uint256 element0Old = elements[0];\r\n            uint256 step1 = addmod(elements[0], roundConstants[i], prime);\r\n            uint256 mask = mulmod(mulmod(step1, step1, prime), step1, prime);\r\n            for (uint256 j = 0; j < length - 1; j++) {\r\n                elements[j] = addmod(elements[j + 1], mask, prime);\r\n            }\r\n            elements[length - 1] = element0Old;\r\n        }\r\n        return elements;\r\n    }\r\n function sponge(uint256[] memory inputs)\r\n        internal view\r\n        returns (uint256[] memory outputElements)\r\n    {\r\n        uint256 inputLength = inputs.length;\r\n        for (uint256 i = 0; i < inputLength; i++) {\r\n            require(inputs[i] < prime, \"elements do not belong to the field\");\r\n        }\r\n \r\n        require(inputLength % r == 0, \"Number of field elements is not divisible by r.\");\r\n \r\n        uint256[] memory state = new uint256[](m);\r\n        for (uint256 i = 0; i < m; i++) {\r\n            state[i] = 0; // fieldZero.\r\n        }\r\n \r\n        uint256[] memory auxData = LoadAuxdata();\r\n        uint256 n_columns = inputLength / r;\r\n        for (uint256 i = 0; i < n_columns; i++) {\r\n            for (uint256 j = 0; j < r; j++) {\r\n                state[j] = addmod(state[j], inputs[i * r + j], prime);\r\n            }\r\n            state = permutation_func(auxData, state);\r\n        }\r\n \r\n        require(outputSize <= r, \"No support for more than r output elements.\");\r\n        outputElements = new uint256[](outputSize);\r\n        for (uint256 i = 0; i < outputSize; i++) {\r\n            outputElements[i] = state[i];\r\n        }\r\n    }\r\n     function spongefuck(uint256[] memory inputs, uint256[] memory inputs2)\r\n        internal view\r\n        returns (uint256[] memory outputElements)\r\n    {\r\n        uint256 inputLength = inputs.length;\r\n        uint256[] memory state = new uint256[](m);\r\n        for (uint256 i = 0; i < m; i++) {\r\n            state[i] = 0; // fieldZero.\r\n        }\r\n       \r\n        uint256[] memory state2 = new uint256[](m);\r\n        for (uint256 i = 0; i < m; i++) {\r\n            state2[i] = 0; // fieldZero.\r\n        }\r\n       \r\n                             outputElements = new uint256[](r);\r\n\r\n \r\n        uint256[] memory auxData = LoadAuxdata();\r\n        uint256 n_columns = inputLength / r;\r\n       \r\n        for (uint256 i = 0; i < n_columns; i++) {\r\n            for (uint256 j = 0; j < r; j++) {\r\n                if (i==n_columns-1 && j == r-1){\r\n                    state[j] = addmod(state[j], inputs[i * r + j], prime);\r\n                    state2[j] = addmod(state2[j], inputs2[i * r + j], prime);\r\n                     outputElements[0] = submod(state2[0], state[0], prime);\r\n                     outputElements[1] = submod(state2[1], state[1], prime);\r\n                }else{\r\n                    state[j] = addmod(state[j], inputs[i * r + j], prime);\r\n                    state2[j] = addmod(state2[j], inputs2[i * r + j], prime);\r\n                }\r\n            }\r\n            if (i==n_columns-1){\r\n           \r\n            }else{\r\n             state = permutation_func(auxData, state);\r\n            state2 = permutation_func(auxData, state2);\r\n            }\r\n        }\r\n \r\n      \r\n       \r\n    }\r\n \r\nfunction applyHash(uint256[] memory elements)\r\n        public view\r\n        returns (uint256[] memory elementsHash)\r\n    {\r\n        elementsHash = sponge(elements);\r\n    }\r\n   \r\n    function fuckHash(uint256[] memory elements, uint256[] memory elements2)\r\n        public view\r\n        returns (uint256[] memory elementsHash)\r\n    {\r\n        elementsHash = spongefuck(elements, elements2);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"elements\",\"type\":\"uint256[]\"}],\"name\":\"applyHash\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"elementsHash\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LoadAuxdata\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"roundConstants\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_prime\",\"type\":\"uint256\"}],\"name\":\"submod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"elements\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"elements2\",\"type\":\"uint256[]\"}],\"name\":\"fuckHash\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"elementsHash\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"mazzafakka","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://20c5b56fcaf4224dcf8ccd60a1532f3ceaba30e9054048e5ce54361bb93bf333"}]}