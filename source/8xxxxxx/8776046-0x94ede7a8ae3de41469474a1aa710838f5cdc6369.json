{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call\r\n//\r\n// ----------------------------------------------------------------------------\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner,\"Owner incorrect!\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner,\"Owner incorrect!\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Lucky Code contract\r\n// ----------------------------------------------------------------------------\r\ncontract LuckyCode is ERC20Interface, Owned{\r\n    using SafeMath for uint;\r\n\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n    modifier onlyBagholders() {\r\n        require(myTokens() > 0,\"Please check my tokens!\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdministrator(){\r\n        address _customerAddress = msg.sender;\r\n        require(administrators[keccak256(abi.encodePacked(_customerAddress))], \"Please check permission admin!\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidAddress(address _to){\r\n        require(_to != address(0x0000000000000000000000000000000000000000), \"Please check address!\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidBlock(){\r\n        address _customerAddress = msg.sender;\r\n        require(blockCustomer_[_customerAddress] > 0, \"Block number invalid!\");\r\n        _;\r\n    }\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted\r\n    );\r\n\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned\r\n    );\r\n\r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n    string public symbol = \"ECT\";\r\n    string public name = \"EtherCenter\";\r\n    uint8 constant public decimals = 18;\r\n    uint256 internal ratio = 2;\r\n    uint256 constant public _maxSupply = 1000000 * 10**uint(decimals);\r\n    uint256 constant public _ECTAllocation = 800000 * 10**uint(decimals);\r\n    uint256 internal totalSupply_;\r\n\r\n    bytes32 internal luckyBlockHash_;\r\n    uint256 constant internal adminETH_ = 300 ether;\r\n    uint256 constant internal defaultECT_ = 10**uint(decimals);\r\n    uint256 constant internal defaultValue_ = 10**uint(decimals-1);\r\n    uint256 constant internal defaultAd_ = 14*10**uint(decimals-4);\r\n\r\n    address internal admin_;\r\n\r\n    mapping(address => uint) balances; // ECT\r\n    mapping(address => mapping(address => uint)) allowed;\r\n    mapping(bytes32 => bool) public administrators;\r\n    mapping(address => uint256) blockCustomer_;\r\n\r\n    /*=====================================\r\n    =             CONSTRUCTOR             =\r\n    =====================================*/\r\n    constructor (address _admin)\r\n    public\r\n    {\r\n        // add administrators here\r\n        administrators[keccak256(abi.encode(_admin))] = true;\r\n        admin_ = _admin;\r\n        luckyBlockHash_ = bytes32(_admin);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Buy lucky code and receive ECT\r\n    // ------------------------------------------------------------------------\r\n    function buyECT()\r\n    public\r\n    payable\r\n    {\r\n        if (address(this).balance <= adminETH_ &&\r\n            administrators[keccak256(abi.encode(msg.sender))]){\r\n            require(administrators[keccak256(abi.encode(msg.sender))],\"You are not permission!\");\r\n            purchaseECT(msg.value);\r\n            return;\r\n        }\r\n\r\n        require(msg.value == defaultValue_,\"Value is invalid!\");\r\n        purchaseECT(msg.value);\r\n        blockCustomer_[msg.sender] = block.number;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Buy lucky code by ECT\r\n    // ------------------------------------------------------------------------\r\n    function buyCodebyECT()\r\n    public\r\n    onlyBagholders()\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        uint256 _amountOfECT = calECT();\r\n        require(_amountOfECT <= balances[_customerAddress],\"ECT is invalid!\");\r\n        balances[_customerAddress] = balances[_customerAddress].sub(_amountOfECT);\r\n        totalSupply_ = totalSupply_.sub(_amountOfECT);\r\n        blockCustomer_[msg.sender] = block.number;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Sell ECT to receive ethereum\r\n    // ------------------------------------------------------------------------\r\n    function sellECT(uint256 _amountOfECT)\r\n    public\r\n    onlyBagholders()\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        require(_amountOfECT <= balances[_customerAddress],\"ECT is invalid!\");\r\n        uint256 _realETH = ECTToEthereum_(_amountOfECT);\r\n        balances[_customerAddress] = balances[_customerAddress].sub(_amountOfECT);\r\n        totalSupply_ = totalSupply_.sub(_amountOfECT);\r\n        _customerAddress.transfer(_realETH);\r\n        emit onTokenSell(_customerAddress,_amountOfECT,_realETH);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer ECT\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address _to, uint256 _value)\r\n    public\r\n    returns (bool success)\r\n    {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n    public\r\n    returns (bool success)\r\n    {\r\n        require(_value <= allowance(_from, msg.sender),\"Please check allowance!\");     // Check allowance\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens)\r\n    public\r\n    onlyOwner\r\n    returns (bool success)\r\n    {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Check award\r\n    // ------------------------------------------------------------------------\r\n    function checkAward_()\r\n    public\r\n    onlyValidBlock()\r\n    returns(bool)\r\n    {\r\n        uint _ret = ECTAward_(blockCustomer_[msg.sender]);\r\n        if (_ret > 2)\r\n        {\r\n            luckyBlockHash_ = bytes32(msg.sender);\r\n        }\r\n        blockCustomer_[msg.sender] = 0;\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply()\r\n    public\r\n    view\r\n    returns (uint)\r\n    {\r\n        return totalSupply_;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total Ethereum\r\n    // ------------------------------------------------------------------------\r\n    function totalEthereumBalance()\r\n    public\r\n    view\r\n    returns(uint)\r\n    {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account `tokenOwner`\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner)\r\n    public\r\n    view\r\n    returns (uint balance)\r\n    {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Retrieve the tokens owned by the caller.\r\n    // ------------------------------------------------------------------------\r\n    function myTokens()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n\r\n    function approve(address spender, uint tokens)\r\n    public\r\n    returns (bool success)\r\n    {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address tokenOwner, address spender)\r\n    public\r\n    view\r\n    returns (uint remaining)\r\n    {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n    function approveAndCall(address spender, uint tokens, bytes memory data)\r\n    public\r\n    returns (bool success)\r\n    {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get lucky code.\r\n    // ------------------------------------------------------------------------\r\n    function getLuckyCode(uint number)\r\n    public\r\n    view\r\n    returns(uint)\r\n    {\r\n        return createCode(luckyBlockHash_, number);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get block number of customer\r\n    // ------------------------------------------------------------------------\r\n    function getblockCustomer(bool agree_)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        if(agree_)\r\n            return blockCustomer_[msg.sender];\r\n        return 0;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get code of customer\r\n    // ------------------------------------------------------------------------\r\n    function getCodeCustomer_(uint number)\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        if (blockCustomer_[msg.sender] > 0)\r\n            return createCode(blockhash(blockCustomer_[msg.sender]),number);\r\n        return 0;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate ECT sent if you buy lucky code by ECT\r\n    // ------------------------------------------------------------------------\r\n    function getCodebyECT()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return calECT();\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate ECT received if you buy lucky code by ETH\r\n    // ------------------------------------------------------------------------\r\n    function getECTReceived()\r\n    public\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return EthereumToECT_(defaultValue_);\r\n    }\r\n\r\n    /*=====================================\r\n    =          Internal Function          =\r\n    =====================================*/\r\n\r\n    function purchaseECT(uint256 _incomingEthereum)\r\n    internal\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        uint256 _ECTTokens;\r\n        if (totalSupply_ <= _maxSupply)\r\n        {\r\n            if (address(this).balance <= adminETH_ &&\r\n                administrators[keccak256(abi.encode(msg.sender))])\r\n            {\r\n                _ECTTokens = EthereumToECTAdmin_(_incomingEthereum);\r\n            } else {\r\n                _ECTTokens = EthereumToECT_(_incomingEthereum);\r\n            }\r\n        } else {\r\n            _ECTTokens = 0;\r\n        }\r\n        balances[_customerAddress] = balances[_customerAddress].add(_ECTTokens);\r\n        totalSupply_ = totalSupply_.add(_ECTTokens);\r\n        emit onTokenPurchase(_customerAddress,_incomingEthereum,_ECTTokens);\r\n    }\r\n\r\n    function calECT()\r\n    internal\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return ratio.mul(EthereumToECT_(defaultValue_));\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value)\r\n    internal\r\n    onlyValidAddress(_to)\r\n    onlyBagholders()\r\n    {\r\n        require(balances[_to] + _value > balances[_to],\"Please check tokens value!\");\r\n        uint previousBalances = balances[_from] + balances[_to];\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        assert(balances[_from] + balances[_to] == previousBalances);\r\n    }\r\n\r\n    function ECTAward_(uint256 _block)\r\n    internal\r\n    returns(uint)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        bytes32 _ECTblockHash = blockhash(_block);\r\n        uint _ECTCode = createCode(_ECTblockHash, 4);\r\n        uint _luckyCode = createCode(luckyBlockHash_, 4);\r\n        uint _ret = 0;\r\n        for (uint i = 4; i > 0; i--){\r\n            if (checkECTAward_(_ECTCode,_luckyCode,i))\r\n            {\r\n                uint256 _realETH = 0;\r\n                uint256 _totalETH = address(this).balance;\r\n                if (i == 4){\r\n                    _realETH = (_totalETH.mul(10)).div(100);\r\n                    if(_realETH > 100 ether)\r\n                        _realETH = 100 ether;\r\n                    _ret = 4;\r\n                }\r\n                if (i == 3){\r\n                    _realETH = (_totalETH.mul(2)).div(100);\r\n                    if(_realETH > 10 ether)\r\n                        _realETH = 10 ether;\r\n                    _ret = 3;\r\n                }\r\n                if (i == 2){\r\n                    _realETH = (_totalETH.mul(5)).div(1000);\r\n                    if(_realETH > 1 ether)\r\n                        _realETH = 1 ether;\r\n                    _ret = 2;\r\n                }\r\n                if (i == 1){\r\n                    _realETH = 0.1 ether;\r\n                    _ret = 1;\r\n                }\r\n                if (_realETH > 0){\r\n                    _customerAddress.transfer(_realETH);\r\n                    return _ret;\r\n                } else {\r\n                    _ret = 0;\r\n                }\r\n            }\r\n        }\r\n        return _ret;\r\n    }\r\n\r\n    function checkECTAward_(uint _ECTCode, uint _luckyCode, uint _number)\r\n    internal\r\n    pure\r\n    returns(bool)\r\n    {\r\n        uint _codeECT = _ECTCode%(10**_number);\r\n        uint _lucky = _luckyCode%(10**_number);\r\n        if (_codeECT == _lucky)\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    function createCode(bytes32 _blhash, uint count_)\r\n    internal\r\n    pure\r\n    returns(uint)\r\n    {\r\n        require(_blhash > 0 && count_ > 0, \"Value is not defined.\");\r\n        uint code_ = 0;\r\n        uint tmp_ = count_ - 1;\r\n        for(uint256 i = _blhash.length - 1; i > 0; i--)\r\n        {\r\n            bytes1 char_ = _blhash[i];\r\n            byte high = byte(uint8(char_) / 16);\r\n            byte low = byte(uint8(char_) - 16 * uint8(high));\r\n            if(low >= 0x00 && low < 0x0A){\r\n                code_ = code_ + uint(low)*(10**tmp_);\r\n                tmp_--;\r\n            }\r\n            if(high >= 0x00 && high < 0x0A){\r\n                code_ = code_ + uint(high)*(10**tmp_);\r\n                tmp_--;\r\n            }\r\n            if(tmp_ < 0)\r\n                break;\r\n        }\r\n        return code_;\r\n    }\r\n\r\n    function EthereumToECTAdmin_(uint256 _amountOfETH)\r\n    internal\r\n    pure\r\n    returns(uint256)\r\n    {\r\n        return (_amountOfETH.mul(defaultECT_)).div(defaultAd_);\r\n    }\r\n\r\n    function EthereumToECT_(uint256 _amountOfETH)\r\n    internal\r\n    view\r\n    returns(uint256)\r\n    {\r\n        if (_amountOfETH == defaultValue_)\r\n            return ((_maxSupply.sub(totalSupply_)).mul(defaultECT_.mul(10))).div(_ECTAllocation);\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    function ECTToEthereum_(uint256 _amountOfECT)\r\n    internal\r\n    view\r\n    returns(uint256)\r\n    {\r\n        return _amountOfECT.mul(guaranteePrice_()).div(defaultECT_);\r\n    }\r\n\r\n    function guaranteePrice_()\r\n    internal\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256 _guarantee = 0;\r\n        uint256 _totalETH = address(this).balance;\r\n        if (totalSupply_ > 0){\r\n            _guarantee = (_totalETH.mul(defaultECT_)).div(totalSupply_);\r\n        }\r\n        return _guarantee;\r\n    }\r\n\r\n    /*=====================================\r\n    =    ADMINISTRATOR ONLY FUNCTIONS     =\r\n    =====================================*/\r\n    /**\r\n     * In case one of us dies, we need to replace ourselves.\r\n     */\r\n    function setAdministrator(bytes32 _identifier, bool _status)\r\n    public\r\n    onlyAdministrator()\r\n    {\r\n        administrators[_identifier] = _status;\r\n    }\r\n\r\n    /**\r\n     * If we want to set name, we can.\r\n     */\r\n    function setName(string memory _name)\r\n    public\r\n    onlyAdministrator()\r\n    {\r\n        name = _name;\r\n    }\r\n\r\n    /**\r\n     * If we want to set symbol, we can.\r\n     */\r\n    function setSymbol(string memory _symbol)\r\n    public\r\n    onlyAdministrator()\r\n    {\r\n        symbol = _symbol;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getECTReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"administrators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCodebyECT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_ECTAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkAward_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyECT\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfECT\",\"type\":\"uint256\"}],\"name\":\"sellECT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"bytes32\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyCodebyECT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"getLuckyCode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"getCodeCustomer_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"agree_\",\"type\":\"bool\"}],\"name\":\"getblockCustomer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethereumEarned\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"LuckyCode","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000972547cfa9425ce4bedbb38e0c6afb604ea188c4","Library":"","LicenseType":"None","SwarmSource":"bzzr://0d0ebea51abecfa96561c3a8ca2e9406da12d82e02de373f329a208678aa51e0"}]}