{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Copyright 2017-2019, bZeroX, LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0.\r\n */\r\n \r\npragma solidity 0.5.8;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title EIP20/ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract EIP20 is ERC20 {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n}\r\n\r\ncontract WETHInterface is EIP20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, rounding up and truncating the quotient\r\n  */\r\n  function divCeil(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    return ((_a - 1) / _b) + 1;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\r\n  /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\r\n  uint256 internal constant REENTRANCY_GUARD_FREE = 1;\r\n\r\n  /// @dev Constant for locked guard state\r\n  uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one `nonReentrant` function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and an `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(reentrancyLock == REENTRANCY_GUARD_FREE, \"nonReentrant\");\r\n    reentrancyLock = REENTRANCY_GUARD_LOCKED;\r\n    _;\r\n    reentrancyLock = REENTRANCY_GUARD_FREE;\r\n  }\r\n\r\n}\r\n\r\ncontract LoanTokenization is ReentrancyGuard, Ownable {\r\n\r\n    uint256 internal constant MAX_UINT = 2**256 - 1;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    address public bZxContract;\r\n    address public bZxVault;\r\n    address public bZxOracle;\r\n    address public wethContract;\r\n\r\n    address public loanTokenAddress;\r\n\r\n    // price of token at last user checkpoint\r\n    mapping (address => uint256) internal checkpointPrices_;\r\n}\r\n\r\ncontract LoanTokenStorage is LoanTokenization {\r\n\r\n    struct ListIndex {\r\n        uint256 index;\r\n        bool isSet;\r\n    }\r\n\r\n    struct LoanData {\r\n        bytes32 loanOrderHash;\r\n        uint256 leverageAmount;\r\n        uint256 initialMarginAmount;\r\n        uint256 maintenanceMarginAmount;\r\n        uint256 maxDurationUnixTimestampSec;\r\n        uint256 index;\r\n    }\r\n\r\n    struct TokenReserves {\r\n        address lender;\r\n        uint256 amount;\r\n    }\r\n\r\n    event Borrow(\r\n        address indexed borrower,\r\n        uint256 borrowAmount,\r\n        uint256 interestRate,\r\n        address collateralTokenAddress,\r\n        address tradeTokenToFillAddress,\r\n        bool withdrawOnOpen\r\n    );\r\n\r\n    event Claim(\r\n        address indexed claimant,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 remainingTokenAmount,\r\n        uint256 price\r\n    );\r\n\r\n    bool internal isInitialized_ = false;\r\n\r\n    address public tokenizedRegistry;\r\n\r\n    uint256 public baseRate = 1000000000000000000; // 1.0%\r\n    uint256 public rateMultiplier = 18750000000000000000; // 18.75%\r\n\r\n    // \"fee percentage retained by the oracle\" = SafeMath.sub(10**20, spreadMultiplier);\r\n    uint256 public spreadMultiplier;\r\n\r\n    mapping (uint256 => bytes32) public loanOrderHashes; // mapping of levergeAmount to loanOrderHash\r\n    mapping (bytes32 => LoanData) public loanOrderData; // mapping of loanOrderHash to LoanOrder\r\n    uint256[] public leverageList;\r\n\r\n    TokenReserves[] public burntTokenReserveList; // array of TokenReserves\r\n    mapping (address => ListIndex) public burntTokenReserveListIndex; // mapping of lender address to ListIndex objects\r\n    uint256 public burntTokenReserved; // total outstanding burnt token amount\r\n    address internal nextOwedLender_;\r\n\r\n    uint256 public totalAssetBorrow; // current amount of loan token amount tied up in loans\r\n\r\n    uint256 public checkpointSupply;\r\n\r\n    uint256 internal lastSettleTime_;\r\n\r\n    uint256 public initialPrice;\r\n}\r\n\r\ncontract AdvancedTokenStorage is LoanTokenStorage {\r\n    using SafeMath for uint256;\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Mint(\r\n        address indexed minter,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n    event Burn(\r\n        address indexed burner,\r\n        uint256 tokenAmount,\r\n        uint256 assetAmount,\r\n        uint256 price\r\n    );\r\n\r\n    mapping(address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    uint256 internal totalSupply_;\r\n\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupply_;\r\n    }\r\n\r\n    function balanceOf(\r\n        address _owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address _spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract AdvancedToken is AdvancedTokenStorage {\r\n    using SafeMath for uint256;\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function _mint(\r\n        address _to,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price)\r\n        internal\r\n    {\r\n        require(_to != address(0), \"invalid address\");\r\n        totalSupply_ = totalSupply_.add(_tokenAmount);\r\n        balances[_to] = balances[_to].add(_tokenAmount);\r\n\r\n        emit Mint(_to, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(address(0), _to, _tokenAmount);\r\n    }\r\n\r\n    function _burn(\r\n        address _who,\r\n        uint256 _tokenAmount,\r\n        uint256 _assetAmount,\r\n        uint256 _price)\r\n        internal\r\n    {\r\n        require(_tokenAmount <= balances[_who], \"burn value exceeds balance\");\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        balances[_who] = balances[_who].sub(_tokenAmount);\r\n        if (balances[_who] <= 10) { // we can't leave such small balance quantities\r\n            _tokenAmount = _tokenAmount.add(balances[_who]);\r\n            balances[_who] = 0;\r\n        }\r\n\r\n        totalSupply_ = totalSupply_.sub(_tokenAmount);\r\n\r\n        emit Burn(_who, _tokenAmount, _assetAmount, _price);\r\n        emit Transfer(_who, address(0), _tokenAmount);\r\n    }\r\n}\r\n\r\ncontract BZxObjects {\r\n\r\n    struct LoanOrder {\r\n        address loanTokenAddress;\r\n        address interestTokenAddress;\r\n        address collateralTokenAddress;\r\n        address oracleAddress;\r\n        uint256 loanTokenAmount;\r\n        uint256 interestAmount;\r\n        uint256 initialMarginAmount;\r\n        uint256 maintenanceMarginAmount;\r\n        uint256 maxDurationUnixTimestampSec;\r\n        bytes32 loanOrderHash;\r\n    }\r\n\r\n    struct LoanPosition {\r\n        address trader;\r\n        address collateralTokenAddressFilled;\r\n        address positionTokenAddressFilled;\r\n        uint256 loanTokenAmountFilled;\r\n        uint256 loanTokenAmountUsed;\r\n        uint256 collateralTokenAmountFilled;\r\n        uint256 positionTokenAmountFilled;\r\n        uint256 loanStartUnixTimestampSec;\r\n        uint256 loanEndUnixTimestampSec;\r\n        bool active;\r\n        uint256 positionId;\r\n    }\r\n}\r\n\r\ninterface IBZxSettings {\r\n    function pushLoanOrderOnChain(\r\n        address[8] calldata orderAddresses,\r\n        uint256[11] calldata orderValues,\r\n        bytes calldata oracleData,\r\n        bytes calldata signature)\r\n        external\r\n        returns (bytes32); // loanOrderHash\r\n\r\n    function setLoanOrderDesc(\r\n        bytes32 loanOrderHash,\r\n        string calldata desc)\r\n        external\r\n        returns (bool);\r\n\r\n    function oracleAddresses(\r\n        address oracleAddress)\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n\r\ninterface IBZxOracleSettings {\r\n    function tradeUserAsset(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress,\r\n        address receiverAddress,\r\n        address returnToSenderAddress,\r\n        uint256 sourceTokenAmount,\r\n        uint256 maxDestTokenAmount,\r\n        uint256 minConversionRate)\r\n        external\r\n        returns (uint256 destTokenAmountReceived, uint256 sourceTokenAmountUsed);\r\n\r\n    function interestFeePercent()\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ncontract LoanTokenSettings is AdvancedToken {\r\n    using SafeMath for uint256;\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == address(this) ||\r\n            msg.sender == owner, \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function()\r\n        external\r\n    {\r\n        revert(\"invalid\");\r\n    }\r\n\r\n\r\n    function initLeverage(\r\n        uint256[4] memory orderParams) // leverageAmount, initialMarginAmount, maintenanceMarginAmount, maxDurationUnixTimestampSec\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(loanOrderHashes[orderParams[0]] == 0);\r\n\r\n        address[8] memory orderAddresses = [\r\n            address(this), // makerAddress\r\n            loanTokenAddress, // loanTokenAddress\r\n            loanTokenAddress, // interestTokenAddress (same as loanToken)\r\n            address(0), // collateralTokenAddress\r\n            address(0), // feeRecipientAddress\r\n            bZxOracle, // (leave as original value)\r\n            address(0), // takerAddress\r\n            address(0) // tradeTokenAddress\r\n        ];\r\n\r\n        uint256[11] memory orderValues = [\r\n            0, // loanTokenAmount\r\n            0, // interestAmountPerDay\r\n            orderParams[1], // initialMarginAmount,\r\n            orderParams[2], // maintenanceMarginAmount,\r\n            0, // lenderRelayFee\r\n            0, // traderRelayFee\r\n            orderParams[3], // maxDurationUnixTimestampSec,\r\n            0, // expirationUnixTimestampSec\r\n            0, // makerRole (0 = lender)\r\n            0, // withdrawOnOpen\r\n            uint(keccak256(abi.encodePacked(msg.sender, block.timestamp))) // salt\r\n        ];\r\n\r\n        bytes32 loanOrderHash = IBZxSettings(bZxContract).pushLoanOrderOnChain(\r\n            orderAddresses,\r\n            orderValues,\r\n            abi.encodePacked(address(this)), // oracleData -> closeLoanNotifier\r\n            \"\"\r\n        );\r\n        IBZxSettings(bZxContract).setLoanOrderDesc(\r\n            loanOrderHash,\r\n            name\r\n        );\r\n        loanOrderData[loanOrderHash] = LoanData({\r\n            loanOrderHash: loanOrderHash,\r\n            leverageAmount: orderParams[0],\r\n            initialMarginAmount: orderParams[1],\r\n            maintenanceMarginAmount: orderParams[2],\r\n            maxDurationUnixTimestampSec: orderParams[3],\r\n            index: leverageList.length\r\n        });\r\n        loanOrderHashes[orderParams[0]] = loanOrderHash;\r\n        leverageList.push(orderParams[0]);\r\n    }\r\n\r\n    function removeLeverage(\r\n        uint256 leverageAmount)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        bytes32 loanOrderHash = loanOrderHashes[leverageAmount];\r\n        require(loanOrderHash != 0);\r\n\r\n        if (leverageList.length > 1) {\r\n            uint256 index = loanOrderData[loanOrderHash].index;\r\n            leverageList[index] = leverageList[leverageList.length - 1];\r\n            loanOrderData[loanOrderHashes[leverageList[index]]].index = index;\r\n        }\r\n        leverageList.length--;\r\n\r\n        delete loanOrderHashes[leverageAmount];\r\n        delete loanOrderData[loanOrderHash];\r\n    }\r\n\r\n    function migrateLeverage(\r\n        uint256 oldLeverageValue,\r\n        uint256 newLeverageValue)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(oldLeverageValue != newLeverageValue);\r\n        bytes32 loanOrderHash = loanOrderHashes[oldLeverageValue];\r\n        LoanData storage loanData = loanOrderData[loanOrderHash];\r\n        require(loanData.initialMarginAmount != 0);\r\n\r\n        delete loanOrderHashes[oldLeverageValue];\r\n\r\n        leverageList[loanData.index] = newLeverageValue;\r\n        loanData.leverageAmount = newLeverageValue;\r\n        loanOrderHashes[newLeverageValue] = loanOrderHash;\r\n    }\r\n\r\n    // These params should be percentages represented like so: 5% = 5000000000000000000\r\n    // rateMultiplier + baseRate can't exceed 100%\r\n    function setDemandCurve(\r\n        uint256 _baseRate,\r\n        uint256 _rateMultiplier)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(rateMultiplier.add(baseRate) <= 10**20);\r\n        baseRate = _baseRate;\r\n        rateMultiplier = _rateMultiplier;\r\n    }\r\n\r\n    function setInterestFeePercent(\r\n        uint256 _newRate)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(_newRate <= 10**20);\r\n        spreadMultiplier = SafeMath.sub(10**20, _newRate);\r\n    }\r\n\r\n    function setBZxOracle(\r\n        address _addr)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        bZxOracle = _addr;\r\n    }\r\n\r\n    function setTokenizedRegistry(\r\n        address _addr)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        tokenizedRegistry = _addr;\r\n    }\r\n\r\n    function setWethContract(\r\n        address _addr)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        wethContract = _addr;\r\n    }\r\n\r\n    function recoverEther(\r\n        address payable receiver,\r\n        uint256 amount)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        uint256 balance = address(this).balance;\r\n        if (balance < amount)\r\n            amount = balance;\r\n\r\n        receiver.transfer(amount);\r\n    }\r\n\r\n    function recoverToken(\r\n        address tokenAddress,\r\n        address receiver,\r\n        uint256 amount)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(tokenAddress != loanTokenAddress, \"invalid token\");\r\n\r\n        ERC20 token = ERC20(tokenAddress);\r\n\r\n        uint256 balance = token.balanceOf(address(this));\r\n        if (balance < amount)\r\n            amount = balance;\r\n\r\n        require(token.transfer(\r\n            receiver,\r\n            amount),\r\n            \"transfer failed\"\r\n        );\r\n    }\r\n\r\n    function swapIntoLoanToken(\r\n        address sourceTokenAddress,\r\n        uint256 amount)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(sourceTokenAddress != loanTokenAddress, \"invalid token\");\r\n\r\n        address oracleAddress = IBZxSettings(bZxContract).oracleAddresses(bZxOracle);\r\n\r\n        uint256 balance = ERC20(sourceTokenAddress).balanceOf(address(this));\r\n        if (balance < amount)\r\n            amount = balance;\r\n\r\n        uint256 tempAllowance = ERC20(sourceTokenAddress).allowance(address(this), oracleAddress);\r\n        if (tempAllowance < amount) {\r\n            if (tempAllowance != 0) {\r\n                // reset approval to 0\r\n                require(ERC20(sourceTokenAddress).approve(oracleAddress, 0), \"token approval reset failed\");\r\n            }\r\n\r\n            require(ERC20(sourceTokenAddress).approve(oracleAddress, MAX_UINT), \"token approval failed\");\r\n        }\r\n\r\n        IBZxOracleSettings(oracleAddress).tradeUserAsset(\r\n            sourceTokenAddress,\r\n            loanTokenAddress,\r\n            address(this),  // receiverAddress\r\n            address(this),  // returnToSenderAddress\r\n            amount,         // sourceTokenAmount\r\n            MAX_UINT,       // maxDestTokenAmount\r\n            0               // minConversionRate\r\n        );\r\n    }\r\n\r\n    function initialize(\r\n        address _bZxContract,\r\n        address _bZxVault,\r\n        address _bZxOracle,\r\n        address _wethContract,\r\n        address _loanTokenAddress,\r\n        address _tokenizedRegistry,\r\n        string memory _name,\r\n        string memory _symbol)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require (!isInitialized_);\r\n\r\n        bZxContract = _bZxContract;\r\n        bZxVault = _bZxVault;\r\n        bZxOracle = _bZxOracle;\r\n        wethContract = _wethContract;\r\n        loanTokenAddress = _loanTokenAddress;\r\n        tokenizedRegistry = _tokenizedRegistry;\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = EIP20(loanTokenAddress).decimals();\r\n\r\n        spreadMultiplier = SafeMath.sub(10**20, IBZxOracleSettings(_bZxOracle).interestFeePercent());\r\n\r\n        initialPrice = 10**18; // starting price of 1\r\n\r\n        isInitialized_ = true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burntTokenReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setTokenizedRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAssetBorrow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"loanOrderData\",\"outputs\":[{\"name\":\"loanOrderHash\",\"type\":\"bytes32\"},{\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"name\":\"initialMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maintenanceMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maxDurationUnixTimestampSec\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderParams\",\"type\":\"uint256[4]\"}],\"name\":\"initLeverage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"leverageAmount\",\"type\":\"uint256\"}],\"name\":\"removeLeverage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_baseRate\",\"type\":\"uint256\"},{\"name\":\"_rateMultiplier\",\"type\":\"uint256\"}],\"name\":\"setDemandCurve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sourceTokenAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swapIntoLoanToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oldLeverageValue\",\"type\":\"uint256\"},{\"name\":\"newLeverageValue\",\"type\":\"uint256\"}],\"name\":\"migrateLeverage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenizedRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burntTokenReserveList\",\"outputs\":[{\"name\":\"lender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loanTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkpointSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZxVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"setInterestFeePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZxOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZxContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"leverageList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setBZxOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setWethContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spreadMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bZxContract\",\"type\":\"address\"},{\"name\":\"_bZxVault\",\"type\":\"address\"},{\"name\":\"_bZxOracle\",\"type\":\"address\"},{\"name\":\"_wethContract\",\"type\":\"address\"},{\"name\":\"_loanTokenAddress\",\"type\":\"address\"},{\"name\":\"_tokenizedRegistry\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"burntTokenReserveListIndex\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"isSet\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"loanOrderHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"interestRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tradeTokenToFillAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawOnOpen\",\"type\":\"bool\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"remainingTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"LoanTokenSettings","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"None","SwarmSource":"bzzr://ca4f9f55cfa5d762bac6093cd2c9ba35486c0ef02b59bfec0b7a48e7395c6bc4"}]}