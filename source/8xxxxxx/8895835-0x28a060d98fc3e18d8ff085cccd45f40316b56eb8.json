{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * > Note that this information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * `IERC20.balanceOf` and `IERC20.transfer`.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the `IERC20` interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using `_mint`.\r\n * For a generic mechanism see `ERC20Mintable`.\r\n *\r\n * *For a detailed writeup see our guide [How to implement supply\r\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See `IERC20.approve`.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See `IERC20.totalSupply`.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.balanceOf`.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transfer`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.allowance`.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.approve`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transferFrom`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of `ERC20`;\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `value`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to `transfer`, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a `Transfer` event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destoys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a `Transfer` event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an `Approval` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See `_burn` and `_approve`.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/ITransferManager.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n* @title Base transfer manager interface\r\n*/\r\ninterface ITransferManager {\r\n\r\n    /**\r\n    * @notice Checks whether transfer approved or not\r\n    * @param _spender Address of the spender\r\n    * @param _from The address to transfer from\r\n    * @param _to The address to transfer to\r\n    * @param _amount Amount of tokens for the transfer\r\n    */\r\n    function isApproved(address _spender, address _from, address _to, uint256 _amount) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/libraries/AddressList.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n * @title Util for working with an array of addresses\r\n * @dev lib doesn't throw errors for already added or not found addresses\r\n * @dev see tests for WhitelistTransferManager\r\n */\r\nlibrary AddressList {\r\n\r\n    string private constant ERROR_INVALID_ADDRESS = \"Invalid address\";\r\n\r\n    struct Data {\r\n        bool added;\r\n        uint248 index;\r\n    }\r\n\r\n    /**\r\n    * @notice Adds the address to the given list\r\n    * @param _address Address to be added\r\n    * @param _data Mapping of AddressData\r\n    * @param _list Array of addresses\r\n    */\r\n    function addTo(\r\n        address _address,\r\n        mapping(address => Data) storage _data,\r\n        address[] storage _list\r\n    )\r\n        internal\r\n    {\r\n        require(_address != address(0), ERROR_INVALID_ADDRESS);\r\n\r\n        if (!_data[_address].added) {\r\n            _data[_address] = Data({\r\n                added: true,\r\n                index: uint248(_list.length)\r\n                });\r\n            _list.push(_address);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Removes the address from the given list\r\n    * @param _address Address to be removed\r\n    * @param _data Mapping of AddressData\r\n    * @param _list Array of addresses\r\n    */\r\n    function removeFrom(\r\n        address _address,\r\n        mapping(address => Data) storage _data,\r\n        address[] storage _list\r\n    )\r\n        internal\r\n    {\r\n        require(_address != address(0), ERROR_INVALID_ADDRESS);\r\n\r\n        if (_data[_address].added) {\r\n            uint248 index = _data[_address].index;\r\n            if (index != _list.length - 1) {\r\n                _list[index] = _list[_list.length - 1];\r\n                _data[_list[index]].index = index;\r\n            }\r\n            _list.length--;\r\n            delete _data[_address];\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IPermissionManager.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n* @title Permission manager\r\n*/\r\ninterface IPermissionManager {\r\n\r\n    function hasRole(address _user, bytes32 _role) external view returns (bool);\r\n\r\n    function hasRoles(address _user, bytes32[] calldata _roles) external view returns (bool);\r\n\r\n    function addRole(address _user, bytes32 _role) external;\r\n\r\n    function removeRole(address _user, bytes32 _role) external;\r\n\r\n    function getRoles() external returns (bytes32[] memory);\r\n\r\n}\r\n\r\n// File: contracts/role/AllowableStorage.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n/**\r\n * @title Storage for Allowable\r\n */\r\ncontract AllowableStorage {\r\n\r\n    string internal constant ERROR_ACCESS_DENIED = \"Access is denied\";\r\n    string internal constant ERROR_INVALID_ADDRESS = \"Invalid address\";\r\n    string internal constant ERROR_IS_NOT_ALLOWED = \"Is not allowed\";\r\n    string internal constant ERROR_ROLE_NOT_FOUND = \"Role not found\";\r\n    string internal constant ERROR_STOPPED = \"Contract is stopped\";\r\n    string internal constant ERROR_NOT_STOPPED = \"Contract is not stopped\";\r\n\r\n    string internal constant ERROR_ACTION_WAS_NOT_REQUESTED = \"Action wasn't requested\";\r\n    string internal constant ERROR_ACTION_WAS_REQUESTED_BY_SENDER = \"Action was requested by a sender\";\r\n\r\n    address _owner = address(0x00);\r\n\r\n    //list of the system roles\r\n    bytes32[] roleNames;\r\n\r\n    //map of users for the given role\r\n    mapping(bytes32 => mapping(address => AddressList.Data)) roleUserData;\r\n    //list of users for the given role\r\n    mapping(bytes32 => address[]) roleUsers;\r\n\r\n    //attached permission manager\r\n    address permissionManager = address(0x00);\r\n\r\n    //Initially, roles can be added without an approval\r\n    bool roleApproval = false;\r\n\r\n    bool transferOwnershipApproval = false;\r\n\r\n    bool stopped = false;\r\n\r\n    //newOwner => initiator\r\n    mapping(address => address) transferOwnershipInitiator;\r\n\r\n    //user => role => initiator\r\n    mapping(address => mapping(bytes32 => address)) addRoleInitiators;\r\n\r\n    //user => role => initiator\r\n    mapping(address => mapping(bytes32 => address)) removeRoleInitiators;\r\n\r\n    //List of admin roles\r\n    bytes32[] adminRoles;\r\n\r\n    address stopInitiator = address(0x00);\r\n\r\n    address startInitiator = address(0x00);\r\n\r\n    address configurator = address(0x00);\r\n\r\n}\r\n\r\n// File: contracts/libraries/linked/AllowableLib.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\nlibrary AllowableLib {\r\n    using AddressList for address;\r\n\r\n    string internal constant ERROR_ROLE_NOT_FOUND = \"Role not found\";\r\n\r\n    string internal constant ERROR_ACCESS_DENIED = \"Access is denied\";\r\n    string internal constant ERROR_ACTION_WAS_NOT_REQUESTED = \"Action wasn't requested\";\r\n    string internal constant ERROR_ACTION_WAS_REQUESTED_BY_SENDER = \"Action was requested by a sender\";\r\n\r\n    event RoleAdded(address indexed _user, bytes32 _role);\r\n    event RoleRemoved(address indexed _user, bytes32 _role);\r\n\r\n    event RoleAddingRequested(address indexed _user, bytes32 _role);\r\n    event RoleRemovingRequested(address indexed _user, bytes32 _role);\r\n\r\n    /**\r\n    * @notice Adds given role to the user\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    * param _withApproval Flag whether we need an approval\r\n    */\r\n    function addRole(\r\n        address _user,\r\n        bytes32 _role,\r\n        bool _withApproval,\r\n        bool _withSameRole,\r\n        bytes32[] storage roleNames,\r\n        mapping(bytes32 => mapping(address => AddressList.Data)) storage roleUserData,\r\n        mapping(bytes32 => address[]) storage roleUsers,\r\n        mapping(address => mapping(bytes32 => address)) storage addRoleInitiators\r\n    )\r\n        public\r\n    {\r\n        if (_withApproval) {\r\n            _checkRoleLevel(_role, _withSameRole, roleUserData);\r\n            _checkInitiator(addRoleInitiators[_user][_role]);\r\n        }\r\n        require(isExists(_role, roleNames), ERROR_ROLE_NOT_FOUND);\r\n        _user.addTo(roleUserData[_role], roleUsers[_role]);\r\n        emit RoleAdded(_user, _role);\r\n        if (_withApproval) {\r\n            delete addRoleInitiators[_user][_role];\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Requests to add given role to the user\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    */\r\n    function addRoleRequest(\r\n        address _user,\r\n        bytes32 _role,\r\n        bool _withSameRole,\r\n        mapping(bytes32 => mapping(address => AddressList.Data)) storage roleUserData,\r\n        mapping(address => mapping(bytes32 => address)) storage addRoleInitiators\r\n    )\r\n        public\r\n    {\r\n        _checkRoleLevel(_role, _withSameRole, roleUserData);\r\n        addRoleInitiators[_user][_role] = msg.sender;\r\n        emit RoleAddingRequested(_user, _role);\r\n    }\r\n\r\n    /**\r\n    * @notice Removes given role from the user\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    */\r\n    function removeRole(\r\n        address _user,\r\n        bytes32 _role,\r\n        bool _withApproval,\r\n        bool _withSameRole,\r\n        bytes32[] storage roleNames,\r\n        mapping(bytes32 => mapping(address => AddressList.Data)) storage roleUserData,\r\n        mapping(bytes32 => address[]) storage roleUsers,\r\n        mapping(address => mapping(bytes32 => address)) storage removeRoleInitiators\r\n    )\r\n        public\r\n    {\r\n        if (_withApproval) {\r\n            _checkRoleLevel(_role, _withSameRole, roleUserData);\r\n            _checkInitiator(removeRoleInitiators[_user][_role]);\r\n        }\r\n        require(isExists(_role, roleNames), ERROR_ROLE_NOT_FOUND);\r\n        _user.removeFrom(roleUserData[_role], roleUsers[_role]);\r\n        emit RoleRemoved(_user, _role);\r\n        if (_withApproval) {\r\n            delete removeRoleInitiators[_user][_role];\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Requests to remove given role to the user\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    */\r\n    function removeRoleRequest(\r\n        address _user,\r\n        bytes32 _role,\r\n        bool _withSameRole,\r\n        mapping(bytes32 => mapping(address => AddressList.Data)) storage roleUserData,\r\n        mapping(address => mapping(bytes32 => address)) storage removeRoleInitiators\r\n    )\r\n        public\r\n    {\r\n        _checkRoleLevel(_role, _withSameRole, roleUserData);\r\n        removeRoleInitiators[_user][_role] = msg.sender;\r\n        emit RoleRemovingRequested(_user, _role);\r\n    }\r\n\r\n    /**\r\n    * @notice Adds given role to the supported role list\r\n    * @param _role Role name\r\n    */\r\n    function addSystemRole(\r\n        bytes32 _role,\r\n        bytes32[] storage roleNames\r\n    )\r\n        public\r\n    {\r\n        if (!isExists(_role, roleNames)) {\r\n            roleNames.push(_role);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Checks whether the role has been already added\r\n    * @param _role Role name\r\n    */\r\n    function isExists(\r\n        bytes32 _role,\r\n        bytes32[] storage roleNames\r\n    )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        for (uint i = 0; i < roleNames.length; i++) {\r\n            if (_role == roleNames[i]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * @notice Checks whether the message sender has the same role\r\n    * @param _role Role to be added\r\n    * @param _withSameRole A flag whether we need to do role level check\r\n    */\r\n    function _checkRoleLevel(\r\n        bytes32 _role,\r\n        bool _withSameRole,\r\n        mapping(bytes32 => mapping(address => AddressList.Data)) storage roleUserData\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        if (_withSameRole) {\r\n            require(roleUserData[_role][msg.sender].added, ERROR_ACCESS_DENIED);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Validates initiator address\r\n    * @param _initiator Address of the action initiator\r\n    * @dev Checks whether an action was requested and by different address\r\n    */\r\n    function _checkInitiator(address _initiator) internal view {\r\n        require(_initiator != address(0), ERROR_ACTION_WAS_NOT_REQUESTED);\r\n        require(_initiator != msg.sender, ERROR_ACTION_WAS_REQUESTED_BY_SENDER);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/role/AllowableModifiers.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Allowable Modifiers\r\n * @dev Provides role-based access control\r\n */\r\ncontract AllowableModifiers is AllowableStorage  {\r\n    using AddressList for address;\r\n\r\n    bytes32 internal constant ROLE_INVENIAM_ADMIN = \"INVENIAM_ADMIN\";\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(), ERROR_ACCESS_DENIED);\r\n        _;\r\n    }\r\n\r\n    modifier onlyRole(bytes32 _role) {\r\n        require(_hasRole(msg.sender, _role), ERROR_ACCESS_DENIED);\r\n        _;\r\n    }\r\n\r\n    modifier onlyRoleStrict(bytes32 _role) {\r\n        require(_hasRoleStrict(msg.sender, _role), ERROR_ACCESS_DENIED);\r\n        _;\r\n    }\r\n\r\n    modifier onlyRoles(bytes32[] memory _roles) {\r\n        require(_hasRoles(msg.sender, _roles), ERROR_ACCESS_DENIED);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(_hasRoles(msg.sender, adminRoles), ERROR_ACCESS_DENIED);\r\n        _;\r\n    }\r\n\r\n    modifier notStopped() {\r\n        require(!stopped, ERROR_STOPPED);\r\n        _;\r\n    }\r\n\r\n    modifier isStopped() {\r\n        require(stopped, ERROR_NOT_STOPPED);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Checks whether the user has an appropriate role or an owner\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    */\r\n    function _hasRole(address _user, bytes32 _role) internal view returns (bool) {\r\n        return isOwner() || _hasRoleStrict(_user, _role);\r\n    }\r\n\r\n    /**\r\n    * @notice Checks whether the user has an appropriate role\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    */\r\n    function _hasRoleStrict(address _user, bytes32 _role) internal view returns (bool) {\r\n        return roleUserData[_role][_user].added\r\n        || (permissionManager != address(0) && IPermissionManager(permissionManager).hasRole(_user, _role));\r\n    }\r\n\r\n    /**\r\n    * @notice Checks whether the user has at least one role from the given list or an owner\r\n    * @param _user Address of user wallet\r\n    * @param _roles Array of role names\r\n    */\r\n    function _hasRoles(address _user, bytes32[] memory _roles) internal view returns (bool) {\r\n        if (isOwner()) {\r\n            return true;\r\n        }\r\n        return _hasLocalRoles(_user, _roles)\r\n        || (permissionManager != address(0) && IPermissionManager(permissionManager).hasRoles(_user, _roles));\r\n    }\r\n\r\n    /**\r\n    * @notice Checks whether the user has at least one role from the given list (current contract storage)\r\n    * @param _user Address of user wallet\r\n    * @param _roles Array of role names\r\n    */\r\n    function _hasLocalRoles(address _user, bytes32[] memory _roles) internal view returns (bool) {\r\n        for (uint i = 0; i < _roles.length; i++) {\r\n            bytes32 role = _roles[i];\r\n            if (roleUserData[role][_user].added) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/proxy/FunctionProxy.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n* @title Base Proxy for delegate function calls\r\n*/\r\ncontract FunctionProxy {\r\n\r\n    string private constant ERROR_IMPLEMENTATION_NOT_FOUND = \"Implementation not found\";\r\n\r\n    /**\r\n    * @dev Returns an address of the implementation.\r\n    */\r\n    function _getImplementation() internal view returns (address) {\r\n        return address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function allowing to perform a delegatecall\r\n     * Returns whatever the implementation call returns\r\n     */\r\n    function () external {\r\n        address implementation = _getImplementation();\r\n        require(implementation != address(0), ERROR_IMPLEMENTATION_NOT_FOUND);\r\n\r\n        assembly {\r\n            let pointer := mload(0x40)\r\n            calldatacopy(pointer, 0, calldatasize)\r\n            let result := delegatecall(gas, implementation, pointer, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(pointer, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(pointer, size) }\r\n            default { return(pointer, size) }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/role/Allowable.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Allowable\r\n * @dev Provides role-based access control\r\n */\r\ncontract Allowable is AllowableModifiers, FunctionProxy {\r\n    using AddressList for address;\r\n\r\n    bytes32 private constant ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN = \"INDIVIDUAL_ISSUE_TOKEN_ADMIN\";\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    event RoleAdded(address indexed _user, bytes32 _role);\r\n    event RoleRemoved(address indexed _user, bytes32 _role);\r\n\r\n    event RoleAddingRequested(address indexed _user, bytes32 _role);\r\n    event RoleRemovingRequested(address indexed _user, bytes32 _role);\r\n\r\n    function initRoleApproval() public {\r\n        roleApproval = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Adds given role to the supported role list\r\n    * @param _role Role name\r\n    */\r\n    function _addSystemRole(bytes32 _role) internal {\r\n        AllowableLib.addSystemRole(_role, roleNames);\r\n    }\r\n\r\n    /**\r\n    * @notice Adds given role to the user\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    */\r\n    function addRole(address _user, bytes32 _role) public notStopped onlyAdmin {\r\n        _addRole(_user, _role);\r\n    }\r\n\r\n    /**\r\n    * @notice Adds given role to the users\r\n    * @param _users List of Addresses\r\n    * @param _role Role name\r\n    */\r\n    function addRoles(address[] memory _users, bytes32 _role) public notStopped onlyAdmin {\r\n        for (uint i = 0; i < _users.length; i++) {\r\n            _addRole(_users[i], _role);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Adds given role to the user\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    */\r\n    function _addRole(address _user, bytes32 _role) private {\r\n        bool withApproval = _addRoleWithApproval(_user, _role);\r\n        bool withSameRole = _withSameRole(_role);\r\n        AllowableLib.addRole(_user, _role, withApproval, withSameRole, roleNames, roleUserData, roleUsers, addRoleInitiators);\r\n    }\r\n\r\n    /**\r\n    * @notice Requests to add given role to the user\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    */\r\n    function addRoleRequest(address _user, bytes32 _role) public notStopped onlyAdmin {\r\n        _addRoleRequest(_user, _role);\r\n    }\r\n\r\n    /**\r\n    * @notice Requests to add given role to the user\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    */\r\n    function _addRoleRequest(address _user, bytes32 _role) private {\r\n        bool withSameRole = _withSameRole(_role);\r\n        AllowableLib.addRoleRequest(_user, _role, withSameRole, roleUserData, addRoleInitiators);\r\n    }\r\n\r\n    /**\r\n    * @notice Removes given role from the user\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    */\r\n    function removeRole(address _user, bytes32 _role) public notStopped onlyAdmin {\r\n        _removeRole(_user, _role);\r\n    }\r\n\r\n    /**\r\n    * @notice Removes given role from the user\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    */\r\n    function _removeRole(address _user, bytes32 _role) private {\r\n        bool withApproval = _removeRoleWithApproval(_user, _role);\r\n        bool withSameRole = _withSameRole(_role);\r\n        AllowableLib.removeRole(_user, _role, withApproval, withSameRole, roleNames, roleUserData, roleUsers, removeRoleInitiators);\r\n    }\r\n\r\n    /**\r\n    * @notice Requests to remove given role to the user\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    */\r\n    function removeRoleRequest(address _user, bytes32 _role) public notStopped onlyAdmin {\r\n        _removeRoleRequest(_user, _role);\r\n    }\r\n\r\n    /**\r\n    * @notice Requests to remove given role to the user\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    */\r\n    function _removeRoleRequest(address _user, bytes32 _role) private {\r\n        bool withSameRole = _withSameRole(_role);\r\n        AllowableLib.removeRoleRequest(_user, _role, withSameRole, roleUserData, removeRoleInitiators);\r\n    }\r\n\r\n    /**\r\n    * @notice Returns whether adding role should be approved by user with the same role\r\n    */\r\n    function _withSameRole(bytes32 _role) private pure returns (bool) {\r\n        return _role == ROLE_INVENIAM_ADMIN;\r\n    }\r\n\r\n    /**\r\n    * @notice Returns whether adding role should be approved\r\n    * @dev Approval makes sense if we have at least one admin\r\n    */\r\n    function _addRoleWithApproval(address /*_user*/, bytes32 /*_role*/) internal view returns (bool) {\r\n        return roleApproval && _getAdminCount() > 0;\r\n    }\r\n\r\n    /**\r\n    * @notice Returns whether removing role should be approved\r\n    * @dev Approval makes sense if we have at least one admin (after removal)\r\n    */\r\n    function _removeRoleWithApproval(address /*_user*/, bytes32 _role) internal view returns (bool) {\r\n        uint adminCount = _getAdminCount();\r\n        //if role to be removed is an admin role, we won't use it for an approval\r\n        if (_role == adminRoles[0] || _role == adminRoles[1]) {\r\n            adminCount--;\r\n        }\r\n        return roleApproval && adminCount > 0;\r\n    }\r\n\r\n    /**\r\n    * @notice Calculates the number of current admins\r\n    * @dev Supposes that we have only 2 levels of admin roles\r\n    */\r\n    function _getAdminCount() private view returns (uint) {\r\n        uint adminCount;\r\n        if (adminRoles.length == 2) {\r\n            adminCount = roleUsers[adminRoles[0]].length + roleUsers[adminRoles[1]].length;\r\n        }\r\n        return adminCount;\r\n    }\r\n\r\n    /**\r\n    * @notice Gets list of the system roles\r\n    */\r\n    function getRoles() public view returns (bytes32[] memory) {\r\n        return roleNames;\r\n    }\r\n\r\n    /**\r\n    * @notice Gets users which have the given role\r\n    * @param _role Role name\r\n    */\r\n    function getUsersByRole(bytes32 _role) public view returns (address[] memory) {\r\n        return roleUsers[_role];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets permission manager\r\n     * @param _permissionManager Address of the permission manager\r\n     */\r\n    function setPermissionManager(address _permissionManager) public notStopped onlyAdmin {\r\n        _setPermissionManager(_permissionManager);\r\n    }\r\n\r\n    function _setPermissionManager(address _permissionManager) private {\r\n        permissionManager = _permissionManager;\r\n    }\r\n\r\n    /**\r\n    * @notice Returns permission manager\r\n    */\r\n    function getPermissionManager() public view returns (address) {\r\n        return permissionManager;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @dev Only first transfer should be without an approval\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public notStopped onlyOwner {\r\n        if (transferOwnershipApproval) {\r\n            transferOwnershipInitiator[newOwner] = msg.sender;\r\n        } else {\r\n            transferOwnershipApproval = true;\r\n            _transferOwnership(newOwner);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) private {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Approve transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function approveTransferOwnership(address newOwner) public notStopped onlyRoleStrict(ROLE_INVENIAM_ADMIN) {\r\n        _checkInitiator(transferOwnershipInitiator[newOwner]);\r\n        _transferOwnership(newOwner);\r\n        delete transferOwnershipInitiator[newOwner];\r\n    }\r\n\r\n    /**\r\n     * @notice Request stop of a contract\r\n     */\r\n    function stopRequest() public notStopped onlyRole(ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN) {\r\n        stopInitiator = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @notice Stops a contract\r\n     * @dev All transactions (except startRequest and start) will be reverted\r\n     */\r\n    function stop() public notStopped onlyRoleStrict(ROLE_INVENIAM_ADMIN) {\r\n        _checkInitiator(stopInitiator);\r\n        stopped = true;\r\n        delete stopInitiator;\r\n    }\r\n\r\n    /**\r\n     * @notice Request start of a contract\r\n     * @dev Can be executed only for stopped contracts\r\n     */\r\n    function startRequest() public isStopped onlyRole(ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN) {\r\n        startInitiator = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @notice Starts a contract\r\n     * @dev Can be executed only for stopped contracts\r\n     */\r\n    function start() public isStopped onlyRoleStrict(ROLE_INVENIAM_ADMIN) {\r\n        _checkInitiator(startInitiator);\r\n        stopped = false;\r\n        delete startInitiator;\r\n    }\r\n\r\n    /**\r\n    * @notice Validates initiator address\r\n    * @param _initiator Address of the action initiator\r\n    * @dev Checks whether an action was requested and by different address\r\n    */\r\n    function _checkInitiator(address _initiator) private view {\r\n        require(_initiator != address(0), ERROR_ACTION_WAS_NOT_REQUESTED);\r\n        require(_initiator != msg.sender, ERROR_ACTION_WAS_REQUESTED_BY_SENDER);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns an address of the 'configurator' implementation.\r\n    */\r\n    function _getImplementation() internal view returns (address) {\r\n        return configurator;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IDocumentManager.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n* @title Interface of a contract for parsing and storing document data\r\n*/\r\ninterface IDocumentManager {\r\n\r\n    event DocumentAdded(\r\n        string indexed _document,\r\n        string _uri,\r\n        string indexed _checksum,\r\n        string _checksumAlgo,\r\n        string _timestamp,\r\n        string _figi,\r\n        string _individualId\r\n    );\r\n\r\n    /**\r\n    * @dev Sets fields separator\r\n    * @param _separator Separator\r\n    */\r\n    function setFieldSeparator(string calldata _separator) external;\r\n\r\n    /**\r\n    * @dev Gets fields separator\r\n    */\r\n    function getFieldSeparator() external view returns (string memory);\r\n\r\n    /**\r\n    * @dev Sets store data flag\r\n    * @param _saveData Store data flag\r\n    */\r\n    function setSaveData(bool _saveData) external;\r\n\r\n    /**\r\n    * @dev Gets store data flag\r\n    */\r\n    function getSaveData() external view returns (bool);\r\n\r\n    /**\r\n    * @dev Attaches document to token\r\n    * @param _symbol Token symbol\r\n    * @param _data string Text message with metadata\r\n    */\r\n    function setDocument(string calldata _symbol, string calldata _data) external;\r\n\r\n    /**\r\n    * @dev Gets document data\r\n    * @param _symbol Token symbol\r\n    * @param _id Document ID\r\n    */\r\n    function getDocument(string calldata _symbol, bytes32 _id)\r\n        external\r\n        view\r\n        returns (string memory, string memory, string memory, string memory, string memory, string memory, string memory);\r\n\r\n    /**\r\n    * @dev Gets the list of documents' ids\r\n    * @param _symbol Token symbol\r\n    */\r\n    function getDocumentIds(string calldata _symbol) external view returns (bytes32[] memory);\r\n\r\n}\r\n\r\n// File: contracts/libraries/linked/InveniamTokenLib.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\nlibrary InveniamTokenLib {\r\n    using SafeMath for uint256;\r\n    using AddressList for address;\r\n\r\n    string private constant ERROR_INVALID_INDEX = \"Index out of bound\";\r\n    string private constant ERROR_INVALID_ADDRESS = \"Invalid address\";\r\n    string private constant ERROR_INVALID_AMOUNT = \"Invalid amount\";\r\n    string private constant ERROR_AMOUNT_IS_NOT_AVAILABLE = \"Amount is not available\";\r\n\r\n    event TransferRequested(address indexed _from, address indexed _to, uint256 _amount);\r\n\r\n    struct HistoryBalance {\r\n        uint40 timestamp;\r\n        uint216 value;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates balances history after transfer\r\n     * @param _from The address which you want to send tokens from\r\n     * @param _to The address which you want to transfer to\r\n     */\r\n    function afterTransfer(\r\n        address tokenAddress,\r\n        address _from,\r\n        address _to,\r\n        uint _balanceFrom,\r\n        uint _balanceTo,\r\n        mapping(address => AddressList.Data) storage holderData,\r\n        address[] storage holders,\r\n        mapping(address => HistoryBalance[]) storage historyBalances,\r\n        address[] storage historyHolders\r\n    )\r\n        public\r\n    {\r\n        if (_from != tokenAddress) {\r\n            if (_balanceFrom == 0) {\r\n                _from.removeFrom(holderData, holders);\r\n            }\r\n            if (historyBalances[_from].length == 0) {\r\n                historyHolders.push(_from);\r\n            }\r\n            historyBalances[_from].push(HistoryBalance(uint40(now), uint216(_balanceFrom)));\r\n        }\r\n\r\n        if (_to != tokenAddress) {\r\n            if (_balanceTo > 0) {\r\n                _to.addTo(holderData, holders);\r\n            }\r\n            if (historyBalances[_to].length == 0) {\r\n                historyHolders.push(_to);\r\n            }\r\n            historyBalances[_to].push(HistoryBalance(uint40(now), uint216(_balanceTo)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Update balance history after mint\r\n     * @param _account The account that will receive the created tokens\r\n     * @param _balance The current balance of the account\r\n     */\r\n    function afterMint(\r\n        address _account,\r\n        uint _balance,\r\n        mapping(address => AddressList.Data) storage holderData,\r\n        address[] storage holders,\r\n        mapping(address => HistoryBalance[]) storage historyBalances,\r\n        address[] storage historyHolders\r\n    )\r\n        public\r\n    {\r\n        if (_balance > 0) {\r\n            _account.addTo(holderData, holders);\r\n        }\r\n\r\n        if (historyBalances[_account].length == 0) {\r\n            historyHolders.push(_account);\r\n        }\r\n        historyBalances[_account].push(HistoryBalance(uint40(now), uint216(_balance)));\r\n    }\r\n\r\n    /**\r\n     * @dev Updates balance history after burn\r\n     * @param _account The account whose tokens will be burnt\r\n     * @param _balance The current balance of the account\r\n     */\r\n    function afterBurn(\r\n        address _account,\r\n        uint _balance,\r\n        mapping(address => AddressList.Data) storage holderData,\r\n        address[] storage holders,\r\n        mapping(address => HistoryBalance[]) storage historyBalances,\r\n        address[] storage historyHolders\r\n    )\r\n        public\r\n    {\r\n        if (_balance == 0) {\r\n            _account.removeFrom(holderData, holders);\r\n        }\r\n\r\n        if (historyBalances[_account].length == 0) {\r\n            historyHolders.push(_account);\r\n        }\r\n        historyBalances[_account].push(HistoryBalance(uint40(now), uint216(_balance)));\r\n    }\r\n\r\n    /**\r\n     * @dev Requests transfer\r\n     * @param _from The address to transfer from\r\n     * @param _to The address to transfer to\r\n     */\r\n    function requestTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 /*_amount*/,\r\n        mapping(address => AddressList.Data) storage senderData,\r\n        address[] storage senders,\r\n        mapping(address => mapping (address => uint256)) storage /*transferBalances*/,\r\n        mapping(address => mapping(address => AddressList.Data)) storage senderToReceiverData,\r\n        mapping(address => address[]) storage senderToReceivers\r\n    )\r\n        public\r\n    {\r\n        if (senderToReceivers[_from].length == 0) {\r\n            _from.addTo(senderData, senders);\r\n        }\r\n        _to.addTo(senderToReceiverData[_from], senderToReceivers[_from]);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes accounts from pending transfer list\r\n     * @param _from The address to transfer from\r\n     * @param _to The address to transfer to\r\n     */\r\n    function removeParticipants(\r\n        address _from,\r\n        address _to,\r\n        mapping(address => AddressList.Data) storage senderData,\r\n        address[] storage senders,\r\n        mapping(address => mapping(address => AddressList.Data)) storage senderToReceiverData,\r\n        mapping(address => address[]) storage senderToReceivers\r\n    )\r\n        public\r\n    {\r\n        _to.removeFrom(senderToReceiverData[_from], senderToReceivers[_from]);\r\n        if (senderToReceivers[_from].length == 0) {\r\n            _from.removeFrom(senderData, senders);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Validates transfer according to rules\r\n     * @param _to The address to transfer to\r\n     * @param _amount The amount of the transfer\r\n     * @param _balance The balance of from address\r\n     */\r\n    function validateTransfer(address /*_from*/, address _to, uint256 _amount, uint256 _balance) public pure {\r\n        require(_amount > 0, ERROR_INVALID_AMOUNT);\r\n        require(_amount <= _balance, ERROR_AMOUNT_IS_NOT_AVAILABLE);\r\n        require(_to != address(0), ERROR_INVALID_ADDRESS);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/TokenStorage.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n/**\r\n * @title Storage for InveniamToken\r\n */\r\ncontract TokenStorage {\r\n\r\n    // Declare storage for (pending) transfer requests\r\n    mapping(address => mapping (address => uint256)) transferBalances;\r\n\r\n    //attached transfer manager\r\n    address transferManager = address(0x00);\r\n\r\n    //current senders list\r\n    mapping(address => AddressList.Data) senderData;\r\n    address[] senders;\r\n\r\n    //current receivers list for a given sender\r\n    mapping(address => mapping(address => AddressList.Data)) senderToReceiverData;\r\n    mapping(address => address[]) senderToReceivers;\r\n\r\n    //current token holders\r\n    mapping(address => AddressList.Data) holderData;\r\n    address[] holders;\r\n\r\n    //history token holders\r\n    mapping(address => InveniamTokenLib.HistoryBalance[]) historyBalances;\r\n    address[] historyHolders;\r\n\r\n    //attached document manager\r\n    address documentManager = address(0x00);\r\n\r\n    //Flag whether pending balances should be saved\r\n    bool savePendingBalances = false;\r\n\r\n    //Flag whether holders history should be saved\r\n    bool saveHoldersHistory = false;\r\n\r\n    //Initially, a forced transfer can be done without an approval\r\n    bool forceTransferApproval = false;\r\n\r\n    address allowable = address(0x00);\r\n\r\n    //from => to => amount => initiator\r\n    mapping(address => mapping(address => mapping(uint256 => address))) forceTransferInitiators;\r\n\r\n}\r\n\r\n// File: contracts/interfaces/ITokenConfigurator.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n* @title Interface for token configurator\r\n*/\r\ninterface ITokenConfigurator {\r\n\r\n    /**\r\n     * @dev Get balance for pending transfer\r\n     * @param _from The address to transfer from.\r\n     * @param _to The address to transfer to.\r\n     */\r\n    function getPendingBalance(address _from, address _to) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns sender addresses\r\n     */\r\n    function getSenders() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev Returns receivers addresses\r\n     */\r\n    function getReceiversBySender(address _sender) external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev Returns holder addresses\r\n     * @dev use balanceOf to get the balance for each holder\r\n     */\r\n    function getHolders() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev Returns history holder addresses\r\n     */\r\n    function getHistoryHolders() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev Returns length of the history for a given account\r\n     */\r\n    function getHistoryLength(address _account) external view returns (uint);\r\n\r\n    /**\r\n     * @dev Returns history balance (timestamp, value) for a given account and index\r\n     */\r\n    function getHistoryBalance(address _account, uint _index) external view returns (uint40, uint216);\r\n\r\n    /**\r\n     * @dev Sets transfer manager\r\n     * @dev set 0x00 if you need to remove transfer manager\r\n     * @param _transferManager Address of the transfer manager\r\n     */\r\n    function setTransferManager(address _transferManager) external;\r\n\r\n    /**\r\n     * @dev Returns address of the transfer manager\r\n     */\r\n    function getTransferManager() external view returns (address);\r\n\r\n    /**\r\n     * @dev Set document manager\r\n     * @dev set 0x00 if you need to remove document manager\r\n     * @param _documentManager Address of the document manager\r\n     */\r\n    function setDocumentManager(address _documentManager) external;\r\n\r\n    /**\r\n     * @dev Return address of the document manager\r\n     */\r\n    function getDocumentManager() external view returns (address);\r\n\r\n    /**\r\n    * @dev Sets save pending balances flag\r\n    * @param _savePendingBalances Flag whether pending balances should be saved\r\n    */\r\n    function setSavePendingBalances(bool _savePendingBalances) external;\r\n\r\n    /**\r\n    * @dev Gets save pending balances flag\r\n    */\r\n    function getSavePendingBalances() external view returns (bool);\r\n\r\n    /**\r\n    * @dev Sets holders history flag\r\n    * @param _saveHoldersHistory Flag whether holders history should be saved\r\n    */\r\n    function setSaveHoldersHistory(bool _saveHoldersHistory) external;\r\n\r\n    /**\r\n    * @dev Gets holders history flag\r\n    */\r\n    function getSaveHoldersHistory() external view returns (bool);\r\n\r\n    function initForceTransferApproval() external;\r\n\r\n}\r\n\r\n// File: contracts/InveniamToken.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 based implementation with:\r\n * 1) off-chain transfer verification;\r\n * 2) owner only mint/burn functionality;\r\n *\r\n * @dev Main Inveniam Token implementation\r\n */\r\ncontract InveniamToken is AllowableModifiers, TokenStorage, ERC20, ERC20Detailed, FunctionProxy {\r\n\r\n    bytes32 private constant ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN = \"INDIVIDUAL_ISSUE_TOKEN_ADMIN\";\r\n\r\n    string private constant ERROR_INVALID_AMOUNT = \"Invalid amount\";\r\n    string private constant ERROR_AMOUNT_IS_NOT_AVAILABLE = \"Amount is not available\";\r\n    string private constant ERROR_AMOUNT_IS_NOT_ALLOWED = \"Amount is not allowed\";\r\n    string private constant ERROR_INVALID_TOTAL_SUPPLY = \"New supply is equal to the current supply\";\r\n    string private constant ERROR_TRANSFER_NOT_FOUND = \"Pending transfer not found\";\r\n\r\n    event TransferRequested(address indexed _from, address indexed _to, uint256 _amount);\r\n\r\n    event TransferApproved(address indexed _from, address indexed _to, uint256 _amount);\r\n\r\n    event TransferRejected(address indexed _from, address indexed _to, uint256 _amount);\r\n\r\n    event SupplyChanged(uint256 _delta, uint256 _totalSupply);\r\n\r\n    event ForcedTransfer(address indexed _from, address indexed _to, uint256 _amount);\r\n\r\n    event ForceTransferRequested(address indexed _from, address indexed _to, uint256 _amount);\r\n\r\n    event DocumentAdded(\r\n        string indexed _document,\r\n        string _uri,\r\n        string indexed _checksum,\r\n        string _checksumAlgo,\r\n        string _timestamp,\r\n        string _figi,\r\n        string _individualId\r\n    );\r\n\r\n    event RawDocumentAdded(string _data);\r\n\r\n    /**\r\n    * @dev Creates token with given data\r\n    * @param _symbol Token symbol\r\n    * @param _name Token name\r\n    * @param _decimals Token decimals\r\n    * @param _totalSupply Initial token supply\r\n    * @param _tokenOwner Owner of the token\r\n    * @param _tokenRegistry Token Registry\r\n    */\r\n    constructor (\r\n        string memory _symbol,\r\n        string memory _name,\r\n        uint8 _decimals,\r\n        uint256 _totalSupply,\r\n        address _tokenOwner,\r\n        address _tokenRegistry,\r\n        bool _saveHoldersHistory,\r\n        address _allowable,\r\n        address _configurator\r\n    )\r\n        ERC20Detailed(_name, _symbol, _decimals)\r\n        public\r\n    {\r\n        saveHoldersHistory = _saveHoldersHistory;\r\n        allowable = _allowable;\r\n        configurator = _configurator;\r\n        if (_totalSupply > 0) {\r\n            _mint(_tokenOwner, _totalSupply);\r\n        }\r\n\r\n        AllowableLib.addSystemRole(ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN, roleNames);\r\n        AllowableLib.addSystemRole(ROLE_INVENIAM_ADMIN, roleNames);\r\n        //we need to add this role for initial token set up\r\n        //will be removed after it\r\n        _addRole(_tokenRegistry, ROLE_INVENIAM_ADMIN);\r\n\r\n        adminRoles.push(ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN);\r\n        adminRoles.push(ROLE_INVENIAM_ADMIN);\r\n    }\r\n\r\n    /**\r\n    * @notice Adds given role to the user\r\n    * @param _user Address of user wallet\r\n    * @param _role Role name\r\n    */\r\n    function _addRole(address _user, bytes32 _role) private {\r\n        AllowableLib.addRole(_user, _role, false, false, roleNames, roleUserData, roleUsers, addRoleInitiators);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _amount The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _amount) public notStopped returns (bool) {\r\n        _validateTransfer(msg.sender, _to, _amount);\r\n\r\n        if (_isApproved(msg.sender, msg.sender, _to, _amount)) {\r\n            super.transfer(_to, _amount);\r\n            emit TransferApproved(msg.sender, _to, _amount);\r\n        } else {\r\n            super.transfer(address(this), _amount);\r\n            _requestTransfer(msg.sender, _to, _amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one specified address to another\r\n     * @param _from The address which you want to send tokens from\r\n     * @param _to The address which you want to transfer to\r\n     * @param _amount The amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _amount) public notStopped returns (bool) {\r\n        _validateTransfer(_from, _to, _amount);\r\n        require(_amount <= allowance(_from, msg.sender), ERROR_AMOUNT_IS_NOT_ALLOWED);\r\n\r\n        if (_isApproved(msg.sender, _from, _to, _amount)) {\r\n            super.transferFrom(_from, _to, _amount);\r\n            emit TransferApproved(_from, _to, _amount);\r\n        } else {\r\n            super.transferFrom(_from, address(this), _amount);\r\n            _requestTransfer(_from, _to, _amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves transfer of tokens\r\n     * The approveTransfer method is used for a withdraw workflow, allowing the owner of the contracts to approve\r\n     * tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n     * fees in sub-currencies;\r\n     * @param _from The address to transfer from.\r\n     * @param _to The address to transfer to.\r\n     * @param _amount The amount to be transferred.\r\n     */\r\n    function approveTransfer(address _from, address _to, uint256 _amount) external notStopped onlyAdmin {\r\n        require(_amount > 0, ERROR_INVALID_AMOUNT);\r\n        require(_amount <= transferBalances[_from][_to], ERROR_AMOUNT_IS_NOT_AVAILABLE);\r\n\r\n        transferBalances[_from][_to] = transferBalances[_from][_to].sub(_amount);\r\n        if (transferBalances[_from][_to] == 0) {\r\n            _removeParticipants(_from, _to);\r\n        }\r\n\r\n        _transfer(address(this), _to, _amount);\r\n        emit TransferApproved(_from, _to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Rejects transfer of tokens\r\n     * The rejectTransfer method is used for a withdraw workflow, allowing the owner of the contracts to approve\r\n     * tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n     * fees in sub-currencies;\r\n     * @param _from The address to transfer from.\r\n     * @param _to The address to transfer to.\r\n     */\r\n    function rejectTransfer(address _from, address _to)\r\n        external\r\n        notStopped\r\n        onlyAdmin\r\n    {\r\n        require(transferBalances[_from][_to] > 0, ERROR_TRANSFER_NOT_FOUND);\r\n\r\n        uint256 amount = transferBalances[_from][_to];\r\n        transferBalances[_from][_to] = 0;\r\n        _removeParticipants(_from, _to);\r\n\r\n        _transfer(address(this), _from, amount);\r\n        emit TransferRejected(_from, _to, amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Request force transfer from one account to the another\r\n    * @param _from The address which you want to send tokens from\r\n    * @param _to The address which you want to transfer to\r\n    * @param _amount The amount of tokens to be transferred\r\n    */\r\n    function forceTransferRequest(address _from, address _to, uint256 _amount)\r\n        public\r\n        notStopped\r\n        onlyRole(ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN)\r\n    {\r\n        _validateTransfer(_from, _to, _amount);\r\n\r\n        if (forceTransferApproval) {\r\n            forceTransferInitiators[_from][_to][_amount] = msg.sender;\r\n            emit ForceTransferRequested(_from, _to, _amount);\r\n        } else {\r\n            _forceTransfer(_from, _to, _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Force transfer from one account to the another without off-chain verification\r\n     * @param _from The address which you want to send tokens from\r\n     * @param _to The address which you want to transfer to\r\n     * @param _amount The amount of tokens to be transferred\r\n     */\r\n    function forceTransfer(address _from, address _to, uint256 _amount)\r\n        public\r\n        notStopped\r\n        onlyRoleStrict(ROLE_INVENIAM_ADMIN)\r\n    {\r\n        if (forceTransferApproval) {\r\n            address initiator = forceTransferInitiators[_from][_to][_amount];\r\n            require(initiator != address(0), ERROR_ACTION_WAS_NOT_REQUESTED);\r\n            require(initiator != msg.sender, ERROR_ACTION_WAS_REQUESTED_BY_SENDER);\r\n        }\r\n\r\n        require(_amount <= balanceOf(_from), ERROR_AMOUNT_IS_NOT_AVAILABLE);\r\n        _forceTransfer(_from, _to, _amount);\r\n\r\n        if (forceTransferApproval) {\r\n            delete forceTransferInitiators[_from][_to][_amount];\r\n        }\r\n    }\r\n\r\n    function _forceTransfer(address _from, address _to, uint256 _amount) private {\r\n        _transfer(_from, _to, _amount);\r\n        emit ForcedTransfer(_from, _to, _amount);\r\n        emit TransferApproved(msg.sender, _to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Update amount of tokens to be supplied by contract\r\n     * @param _newTotalSupply The new amount of tokens to be supplied\r\n     */\r\n    function changeTotalSupply(uint256 _newTotalSupply) public notStopped onlyRole(ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN) {\r\n        require(_newTotalSupply != totalSupply(), ERROR_INVALID_TOTAL_SUPPLY);\r\n\r\n        bool isReducing = _newTotalSupply < totalSupply();\r\n        uint256 delta;\r\n        if (isReducing) {\r\n            delta = totalSupply().sub(_newTotalSupply);\r\n            _burn(owner(), delta);\r\n        } else {\r\n            delta = _newTotalSupply.sub(totalSupply());\r\n            _mint(owner(), delta);\r\n        }\r\n        emit SupplyChanged(delta, totalSupply());\r\n    }\r\n\r\n    /**\r\n    * @dev Attaches document to token\r\n    * @param _data string Text message with metadata\r\n    */\r\n    function setDocument(string calldata _data) external notStopped onlyRole(ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN) {\r\n        if (address(documentManager) != address(0x00)) {\r\n            IDocumentManager(documentManager).setDocument(symbol(), _data);\r\n        } else {\r\n            emit RawDocumentAdded(_data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified addresses and update balances history\r\n     * @param _from The address to transfer from\r\n     * @param _to The address to transfer to\r\n     * @param _amount The amount to be transferred\r\n     */\r\n    function _transfer(address _from, address _to, uint256 _amount) internal {\r\n        super._transfer(_from, _to, _amount);\r\n        if (saveHoldersHistory && _amount > 0) {\r\n            uint balanceFrom = balanceOf(_from);\r\n            uint balanceTo = balanceOf(_to);\r\n\r\n            InveniamTokenLib.afterTransfer(\r\n                address(this),\r\n                _from,\r\n                _to,\r\n                balanceFrom,\r\n                balanceTo,\r\n                holderData,\r\n                holders,\r\n                historyBalances,\r\n                historyHolders\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Mints an amount of the token, assigns it to an account and updates balance history\r\n     * @param _account The account that will receive the created tokens\r\n     * @param _amount The amount that will be created\r\n     */\r\n    function _mint(address _account, uint256 _amount) internal {\r\n        super._mint(_account, _amount);\r\n        if (saveHoldersHistory && _amount > 0) {\r\n            uint balance = balanceOf(_account);\r\n\r\n            InveniamTokenLib.afterMint(\r\n                _account,\r\n                balance,\r\n                holderData,\r\n                holders,\r\n                historyBalances,\r\n                historyHolders\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Burns an amount of the token of a given account and updates balance history\r\n     * @param _account The account whose tokens will be burnt\r\n     * @param _amount The amount that will be burnt\r\n     */\r\n    function _burn(address _account, uint256 _amount) internal {\r\n        super._burn(_account, _amount);\r\n        if (saveHoldersHistory && _amount > 0) {\r\n            uint balance = balanceOf(_account);\r\n\r\n            InveniamTokenLib.afterBurn(\r\n                _account,\r\n                balance,\r\n                holderData,\r\n                holders,\r\n                historyBalances,\r\n                historyHolders\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Validates transfer\r\n     * @param _from The address to transfer from\r\n     * @param _to The address to transfer to\r\n     * @param _amount The amount to be transferred\r\n     */\r\n    function _validateTransfer(address _from, address _to, uint256 _amount) internal view {\r\n        InveniamTokenLib.validateTransfer(_from, _to, _amount, balanceOf(_from));\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether transfer is approved\r\n     * @param _from The address to transfer from\r\n     * @param _to The address to transfer to\r\n     * @param _amount The amount to be transferred\r\n     */\r\n    function _isApproved(address _spender, address _from, address _to, uint256 _amount) internal returns (bool) {\r\n        return (transferManager != address(0x00) &&\r\n                ITransferManager(transferManager).isApproved(_spender, _from, _to, _amount));\r\n    }\r\n\r\n    /**\r\n     * @dev Requests transfer\r\n     * @param _from The address to transfer from\r\n     * @param _to The address to transfer to\r\n     * @param _amount The amount to be transferred\r\n     */\r\n    function _requestTransfer(address _from, address _to, uint256 _amount) internal {\r\n        transferBalances[_from][_to] = transferBalances[_from][_to].add(_amount);\r\n        if (savePendingBalances) {\r\n            InveniamTokenLib.requestTransfer(\r\n                _from,\r\n                _to,\r\n                _amount,\r\n                senderData,\r\n                senders,\r\n                transferBalances,\r\n                senderToReceiverData,\r\n                senderToReceivers\r\n            );\r\n        }\r\n        emit TransferRequested(_from, _to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes accounts from pending transfer list\r\n     * @param _from The address to transfer from\r\n     * @param _to The address to transfer to\r\n     */\r\n    function _removeParticipants(address _from, address _to) internal {\r\n        if (savePendingBalances) {\r\n            InveniamTokenLib.removeParticipants(\r\n                _from,\r\n                _to,\r\n                senderData,\r\n                senders,\r\n                senderToReceiverData,\r\n                senderToReceivers\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Returns an address of the 'allowable' implementation.\r\n    */\r\n    function _getImplementation() internal view returns (address) {\r\n        return allowable;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/ITokenFactory.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n* @title Factory for token deployment\r\n*/\r\ninterface ITokenFactory {\r\n\r\n    /**\r\n    * @notice Deploys token\r\n    * @param _symbol Token symbol\r\n    * @param _name Token name\r\n    * @param _decimals Token decimals\r\n    * @param _totalSupply Token total supply\r\n    * @param _tokenOwner Owner of the deployed token\r\n    * @param _tokenRegistry Token Registry\r\n    */\r\n    function deployToken(\r\n        string calldata _symbol,\r\n        string calldata _name,\r\n        uint8 _decimals,\r\n        uint256 _totalSupply,\r\n        address _tokenOwner,\r\n        address _tokenRegistry,\r\n        bool _saveHoldersHistory,\r\n        address _allowable,\r\n        address _getter\r\n    )\r\n        external\r\n        returns (address);\r\n\r\n}\r\n\r\n// File: contracts/registry/TokenFactory.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n/**\r\n* @title Factory for token deployment\r\n*/\r\ncontract TokenFactory is ITokenFactory, Ownable {\r\n\r\n    /**\r\n    * @notice Deploys token\r\n    * @param _symbol Token symbol\r\n    * @param _name Token name\r\n    * @param _decimals Token decimals\r\n    * @param _totalSupply Token total supply\r\n    * @param _tokenOwner Owner of the deployed token\r\n    * @param _tokenRegistry Token Registry\r\n    */\r\n    function deployToken(\r\n        string calldata _symbol,\r\n        string calldata _name,\r\n        uint8 _decimals,\r\n        uint256 _totalSupply,\r\n        address _tokenOwner,\r\n        address _tokenRegistry,\r\n        bool _saveHoldersHistory,\r\n        address _allowable,\r\n        address _getter\r\n    )\r\n        onlyOwner //owner - TokenRegistry\r\n        external\r\n        returns (address)\r\n    {\r\n        address tokenAddress = address(new InveniamToken(\r\n            _symbol,\r\n            _name,\r\n            _decimals,\r\n            _totalSupply * uint256(10)**_decimals,\r\n            _tokenOwner,\r\n            _tokenRegistry,\r\n            _saveHoldersHistory,\r\n            _allowable,\r\n            _getter\r\n        ));\r\n        Allowable(tokenAddress).transferOwnership(_tokenOwner);\r\n        return tokenAddress;\r\n    }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenRegistry\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_saveHoldersHistory\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_allowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_getter\",\"type\":\"address\"}],\"name\":\"deployToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TokenFactory","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"InveniamTokenLib:eb8b812077450871342e715b1e012277788a2a2f;AllowableLib:871a380c8efa6e2490e9232b90a509689e8161de","LicenseType":"None","SwarmSource":"bzzr://03cd767447a8f4605aa2ab38941e61ee6dc13efc68449fc3fee96c4ff41ac6f7"}]}