{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5 .11;\r\n\r\n // Symbol      :  REAP\r\n // Name        :  The Reaper \r\n // Decimals    :  8\r\n // Total supply:  20,862,499.99998474\r\n // Pre-Minted   :  6,000,000.00000000\r\n // Exchanges allocation: 5,000,000.0000000 from the Pre-minted amount\r\n // Developers allocation: 1,000,000.0000000 from the Pre-minted amount\r\n // Minimum number of transfers until reaching the total supply: 40962\r\n // Rewards are given within a 10 minutes period to a first account that makes a transfer.\r\n // Rewards are halved every 512 transfers.\r\n // Initial reward amount is 14500.00000000 tokens.\r\n // Sow period lasts 512 transfers, then Reaping period begins.\r\n // Reap period lasts 512 transfers, then Sowing period begins with the halved rewards.\r\n // Reap period means burning the least active accounts and taking 50% of their assets.\r\n // The minting will continue for at least 0.5 years, or more, depending on a volume of transfers.\r\n // Once the minting is done, all transfers will be normal with a 1% burning fee (without Sowing or Reaping).\r\n // ----------------------------------------------------------------------------\r\n\r\n // ----------------------------------------------------------------------------\r\n // Safe maths\r\n // ----------------------------------------------------------------------------\r\n\r\n library SafeMath {\r\n\r\n   function add(uint a, uint b) internal pure returns(uint c) {\r\n     c = a + b;\r\n     require(c >= a);\r\n   }\r\n\r\n   function sub(uint a, uint b) internal pure returns(uint c) {\r\n     require(b <= a);\r\n     c = a - b;\r\n   }\r\n\r\n   function mul(uint a, uint b) internal pure returns(uint c) {\r\n     c = a * b;\r\n     require(a == 0 || c / a == b);\r\n   }\r\n\r\n   function div(uint a, uint b) internal pure returns(uint c) {\r\n     require(b > 0);\r\n     c = a / b;\r\n   }\r\n\r\n }\r\n\r\n // ----------------------------------------------------------------------------\r\n // ERC Token Standard #20 Interface\r\n // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n // ----------------------------------------------------------------------------\r\n\r\n contract ERC20Interface {\r\n   function balanceOf(address tokenOwner) public view returns(uint balance);\r\n }\r\n\r\n contract TransfersInterface {\r\n   function transfer(address to, uint tokens) public returns(bool success);\r\n\r\n   function transferFrom(address from, address to, uint tokens) public returns(bool success);\r\n\r\n   function addToWhiteList(address toImmortals) public;\r\n\r\n   function removeFromWhitelist(address toMortals) public;\r\n\r\n   function approve(address spender, uint tokens) public returns(bool success);\r\n\r\n   function allowance(address tokenOwner, address spender) public view returns(uint remaining);\r\n\r\n   function totalSupply() public view returns(uint);\r\n\r\n   event Transfer(address indexed from, address indexed to, uint tokens);\r\n   event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n }\r\n\r\n // ----------------------------------------------------------------------------\r\n // Contract function to receive approval and execute function in one call\r\n //\r\n // Borrowed from MiniMeToken\r\n // ----------------------------------------------------------------------------\r\n\r\n contract ApproveAndCallFallBack {\r\n\r\n   function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n\r\n }\r\n\r\n // ----------------------------------------------------------------------------\r\n // Owned contract\r\n // ----------------------------------------------------------------------------\r\n\r\n contract Owned {\r\n\r\n   address public owner;\r\n   address public newOwner;\r\n\r\n   event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n   constructor() public {\r\n     owner = msg.sender;\r\n   }\r\n\r\n   modifier onlyOwner {\r\n     require(msg.sender == owner);\r\n     _;\r\n   }\r\n\r\n   function transferOwnership(address _newOwner) public onlyOwner {\r\n     newOwner = _newOwner;\r\n   }\r\n\r\n   function acceptOwnership() public {\r\n     require(msg.sender == newOwner);\r\n     emit OwnershipTransferred(owner, newOwner);\r\n     owner = newOwner;\r\n     newOwner = address(0);\r\n   }\r\n\r\n }\r\n\r\n contract NormalTransfer is TransfersInterface {\r\n\r\n   using SafeMath\r\n   for uint;\r\n   mapping(address => uint) balances;\r\n   mapping(address => mapping(address => uint)) allowed;\r\n\r\n   uint8 public decimals = 8;\r\n   uint public _totalSupply = 2086249999998474;\r\n   uint public _currentSupply = 6000000 * 10 ** uint(decimals);\r\n\r\n   uint public pivot = 0;\r\n   uint public lastID = 1;\r\n   mapping(uint => address) public addressesStack;\r\n   mapping(address => uint) public revAddressesStack;\r\n   mapping(address => bool) public whitelist;\r\n   uint public whiteListSize;\r\n\r\n   function transfer(address to, uint tokens) public returns(bool success) {\r\n     require(burnSanityCheck(tokens));\r\n\r\n     balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n     if (to != address(0)) {\r\n       balances[to] = balances[to].add(tokens);\r\n     } else {\r\n       _currentSupply = _currentSupply.sub(tokens);\r\n     }\r\n     emit Transfer(msg.sender, to, tokens);\r\n     return true;\r\n   }\r\n\r\n   function approve(address spender, uint tokens) public returns(bool success) {\r\n     allowed[msg.sender][spender] = tokens;\r\n     emit Approval(msg.sender, spender, tokens);\r\n     return true;\r\n   }\r\n\r\n   function transferFrom(address from, address to, uint tokens) public returns(bool success) {\r\n     require(transferFromSanityCheck(from, to, tokens));\r\n     balances[from] = balances[from].sub(tokens);\r\n     allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n     if (to != address(0)) {\r\n       balances[to] = balances[to].add(tokens);\r\n     } else {\r\n       _currentSupply = _currentSupply.sub(tokens);\r\n     }\r\n     emit Transfer(from, to, tokens);\r\n     return true;\r\n   }\r\n\r\n   function allowance(address tokenOwner, address spender) public view returns(uint remaining) {\r\n     return allowed[tokenOwner][spender];\r\n   }\r\n\r\n   function approveAndCall(address spender, uint tokens, bytes memory data) public returns(bool success) {\r\n     allowed[msg.sender][spender] = tokens;\r\n     emit Approval(msg.sender, spender, tokens);\r\n     ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n     return true;\r\n   }\r\n\r\n   function burnSanityCheck(uint tokens) internal returns(bool) {\r\n     if (tokens == 0) return false;\r\n     if (balances[msg.sender] < tokens) return false;\r\n     return true;\r\n   }\r\n\r\n   function burnFromSanityCheck(address from, uint tokens) internal returns(bool) {\r\n     if (tokens == 0) return false;\r\n     if (balances[from] < tokens) return false;\r\n     if (address(from) == address(0)) return false;\r\n     if (tokens > allowed[from][msg.sender]) return false;\r\n     return true;\r\n   }\r\n\r\n   function transferFromSanityCheck(address from, address to, uint tokens) internal returns(bool) {\r\n     if (!burnFromSanityCheck(from, tokens)) return false;\r\n     if (address(to) == address(from)) return false;\r\n     return true;\r\n   }\r\n\r\n   function addToWhiteList(address toImmortals) public {\r\n     whitelist[toImmortals] = true;\r\n     whiteListSize++;\r\n   }\r\n\r\n   function removeFromWhitelist(address toMortals) public {\r\n     whitelist[toMortals] = false;\r\n     whiteListSize--;\r\n   }\r\n\r\n   function checkWhiteList(address checkAddress) public view returns(bool) {\r\n     return whitelist[checkAddress];\r\n   }\r\n\r\n }\r\n\r\n //===============TRANSFERS CONTRACTS BEGIN HERE================================= \r\n\r\n //---------------BURN TRANSFER-----------------\r\n\r\n contract BurnTransfer is NormalTransfer {\r\n   function transfer(address to, uint tokens) public returns(bool success) {\r\n     uint burn = tokens.div(100);\r\n     NormalTransfer.transfer(to, tokens.sub(burn));\r\n     NormalTransfer.transfer(address(0), burn);\r\n     return true;\r\n   }\r\n\r\n   function transferFrom(address from, address to, uint tokens) public returns(bool success) {\r\n     uint burn = tokens.div(100);\r\n     NormalTransfer.transferFrom(from, to, tokens.sub(burn));\r\n     NormalTransfer.transferFrom(from, address(0), burn);\r\n     return true;\r\n   }\r\n }\r\n\r\n //---------------REAP TRANSFER-----------------\r\n contract ReapTransfer is NormalTransfer {\r\n\r\n   address public lastReapedAddress;\r\n   address public lastReaperAddress;\r\n   uint public lastReapingTimeStamp;\r\n   uint public lastReapReward;\r\n\r\n   function getNextMortalID(address from, address to) internal returns(uint) {\r\n     for (uint t = pivot; t < lastID; t++) {\r\n       address ret = addressesStack[t];\r\n       if (\r\n         !whitelist[ret] &&\r\n         address(ret) != address(0) &&\r\n         address(ret) != address(msg.sender) &&\r\n         address(ret) != address(from) &&\r\n         address(ret) != address(to)\r\n       ) {\r\n         return t;\r\n       }\r\n     }\r\n     return 0;\r\n   }\r\n\r\n   function reapTheMortal(address from, uint burnID) internal returns(bool) {\r\n     address mortal = addressesStack[burnID];\r\n     uint assets = balances[mortal];\r\n     uint reapReward = assets.div(2);\r\n\r\n     emit Transfer(mortal, address(0), assets);\r\n     balances[mortal] = 0;\r\n     _currentSupply = _currentSupply.sub(assets);\r\n\r\n     emit Transfer(address(0), from, reapReward);\r\n     balances[from] = balances[from].add(reapReward);\r\n     _currentSupply = _currentSupply.add(reapReward);\r\n     lastReapReward = reapReward;\r\n\r\n     return true;\r\n   }\r\n\r\n   function transfer(address to, uint256 tokens) public returns(bool) {\r\n     lastID++;\r\n     revAddressesStack[to] = lastID;\r\n     addressesStack[lastID] = to;\r\n\r\n     lastID++;\r\n     revAddressesStack[msg.sender] = lastID;\r\n     addressesStack[lastID] = msg.sender;\r\n\r\n     uint burnID = getNextMortalID(msg.sender, to);\r\n     if (burnID > 0) {\r\n       pivot = burnID;\r\n       lastReapedAddress = addressesStack[burnID];\r\n       lastReaperAddress = msg.sender;\r\n       lastReapingTimeStamp = now;\r\n       reapTheMortal(msg.sender, burnID);\r\n     }\r\n     pivot++;\r\n     NormalTransfer.transfer(to, tokens);\r\n\r\n     return true;\r\n   }\r\n\r\n   function transferFrom(address from, address to, uint256 tokens) public returns(bool) {\r\n     lastID++;\r\n     revAddressesStack[to] = lastID;\r\n     addressesStack[lastID] = to;\r\n\r\n     lastID++;\r\n     revAddressesStack[from] = lastID;\r\n     addressesStack[lastID] = from;\r\n\r\n     uint burnID = getNextMortalID(from, to);\r\n     if (burnID > 0) {\r\n       pivot = burnID;\r\n       lastReapedAddress = addressesStack[burnID];\r\n       lastReaperAddress = from;\r\n       lastReapingTimeStamp = now;\r\n       reapTheMortal(from, burnID);\r\n     }\r\n     pivot++;\r\n     NormalTransfer.transferFrom(from, to, tokens);\r\n   }\r\n\r\n }\r\n\r\n //---------------SOW TRANSFER-----------------\r\n contract SowTransfer is NormalTransfer {\r\n\r\n   uint public sowReward = 14500 * 10 ** uint(decimals); //8 decimals included\r\n   uint timeStamp = now;\r\n   uint private nonce;\r\n   uint public mintedTokens = 0;\r\n\r\n   function nextInterval() internal {\r\n     uint maxSeconds = 500;\r\n     uint randomnumber = uint(keccak256(abi.encodePacked(now, msg.sender, nonce))) % maxSeconds;\r\n     nonce++;\r\n     timeStamp = now + randomnumber;\r\n   }\r\n\r\n   function transfer(address to, uint256 tokens) public returns(bool) {\r\n     lastID++;\r\n     revAddressesStack[to] = lastID;\r\n     addressesStack[lastID] = to;\r\n\r\n     lastID++;\r\n     revAddressesStack[msg.sender] = lastID;\r\n     addressesStack[lastID] = msg.sender;\r\n\r\n     NormalTransfer.transfer(to, tokens);\r\n     if (now >= timeStamp) {\r\n       mint(msg.sender, sowReward);\r\n       nextInterval();\r\n     }\r\n     return true;\r\n   }\r\n\r\n   function transferFrom(address from, address to, uint256 tokens) public returns(bool) {\r\n     lastID++;\r\n     revAddressesStack[to] = lastID;\r\n     addressesStack[lastID] = to;\r\n\r\n     lastID++;\r\n     revAddressesStack[from] = lastID;\r\n     addressesStack[lastID] = from;\r\n\r\n     NormalTransfer.transferFrom(from, to, tokens);\r\n     if (now >= timeStamp) {\r\n       mint(msg.sender, sowReward);\r\n       nextInterval();\r\n     }\r\n     return true;\r\n   }\r\n\r\n   function mint(address rewardAddress, uint sowReward) internal returns(bool) {\r\n     emit Transfer(address(0), rewardAddress, sowReward);\r\n     _currentSupply = _currentSupply.add(sowReward);\r\n     mintedTokens = mintedTokens.add(sowReward);\r\n     balances[rewardAddress] = balances[rewardAddress].add(sowReward);\r\n   }\r\n\r\n }\r\n\r\n //---------------TRANSFER LOGIC-----------------\r\n contract Transfers is BurnTransfer, ReapTransfer, SowTransfer {\r\n   uint private gpi = 0;\r\n   bytes32 private stub;\r\n\r\n   uint public typeOfTransfer = 0;\r\n   uint public cycleCount = 0;\r\n\r\n   function setTransferType() internal {\r\n     if (sowReward <= 2) {\r\n       typeOfTransfer = 2;\r\n     } else if (cycleCount == 512) {\r\n       if (typeOfTransfer == 0) {\r\n         typeOfTransfer = 1;\r\n       } else {\r\n         sowReward = sowReward.div(2);\r\n         typeOfTransfer = 0;\r\n       }\r\n       cycleCount = 0;\r\n     }\r\n   }\r\n\r\n   function transfer(address to, uint256 tokens) public returns(bool) {\r\n     if (whitelist[msg.sender]) {\r\n       NormalTransfer.transfer(to, tokens);\r\n       return true;\r\n     }\r\n\r\n     setTransferType();\r\n     if (typeOfTransfer == 0) {\r\n       SowTransfer.transfer(to, tokens);\r\n     } else if (typeOfTransfer == 1) {\r\n       ReapTransfer.transfer(to, tokens);\r\n     } else if (typeOfTransfer == 2) {\r\n       for (uint t = 0; t < gpi; t++) {\r\n         stub = keccak256(abi.encodePacked(stub));\r\n       }\r\n       gpi++;\r\n       BurnTransfer.transfer(to, tokens);\r\n     }\r\n     if (typeOfTransfer < 2) cycleCount++;\r\n     return true;\r\n   }\r\n\r\n   function transferFrom(address from, address to, uint256 tokens) public returns(bool) {\r\n     if (whitelist[from]) {\r\n       NormalTransfer.transferFrom(from, to, tokens);\r\n       return true;\r\n     }\r\n\r\n     setTransferType();\r\n     if (typeOfTransfer == 0) {\r\n       SowTransfer.transferFrom(from, to, tokens);\r\n     } else if (typeOfTransfer == 1) {\r\n       ReapTransfer.transferFrom(from, to, tokens);\r\n     } else if (typeOfTransfer == 2) {\r\n       for (uint t = 0; t < gpi; t++) {\r\n         stub = keccak256(abi.encodePacked(stub));\r\n       }\r\n       gpi++;\r\n       BurnTransfer.transferFrom(from, to, tokens);\r\n     }\r\n     if (typeOfTransfer < 2) cycleCount++;\r\n     return true;\r\n   }\r\n\r\n }\r\n\r\n //===============TRANSFERS CONTRACTS END HERE================================= \r\n\r\n // ----------------------------------------------------------------------------\r\n // REAPER, MAIN CONTRACT\r\n // ----------------------------------------------------------------------------\r\n\r\n contract _REAPER is ERC20Interface, Owned, Transfers {\r\n\r\n   using SafeMath\r\n   for uint;\r\n\r\n   string public symbol;\r\n   string public name;\r\n\r\n   bool locked = false;\r\n\r\n   // ------------------------------------------------------------------------\r\n   // Constructor\r\n   // ------------------------------------------------------------------------\r\n\r\n   constructor() public onlyOwner {\r\n     if (locked) revert();\r\n     symbol = \"REAP\";\r\n     name = \"The Reaper\";\r\n     decimals = 8;\r\n     emit Transfer(address(0), msg.sender, _currentSupply);\r\n     mintedTokens = _currentSupply;\r\n     balances[msg.sender] = _currentSupply;\r\n     locked = true;\r\n   }\r\n\r\n   function transfer(address to, uint256 tokens) public returns(bool) {\r\n     Transfers.transfer(to, tokens);\r\n     return true;\r\n   }\r\n\r\n   function transferFrom(address from, address to, uint256 tokens) public returns(bool) {\r\n     Transfers.transferFrom(from, to, tokens);\r\n     return true;\r\n   }\r\n\r\n   // ------------------------------------------------------------------------\r\n   // Total supply\r\n   // ------------------------------------------------------------------------\r\n\r\n   function totalSupply() public view returns(uint) {\r\n     return _totalSupply - balances[address(0)];\r\n   }\r\n\r\n   // ------------------------------------------------------------------------\r\n   // Get the token balance for account `tokenOwner`\r\n   // ------------------------------------------------------------------------\r\n\r\n   function balanceOf(address tokenOwner) public view returns(uint balance) {\r\n     return balances[tokenOwner];\r\n   }\r\n\r\n   // ------------------------------------------------------------------------\r\n   // Don't accept ETH\r\n   // ------------------------------------------------------------------------\r\n\r\n   function () external payable {\r\n     revert();\r\n   }\r\n\r\n   // ------------------------------------------------------------------------\r\n   // Owner can transfer out any accidentally sent ERC20 tokens\r\n   // ------------------------------------------------------------------------\r\n\r\n   function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns(bool success) {\r\n     return NormalTransfer(tokenAddress).transfer(owner, tokens);\r\n   }\r\n\r\n }","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastReapingTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastReaperAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cycleCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressesStack\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toImmortals\",\"type\":\"address\"}],\"name\":\"addToWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastReapReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteListSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"typeOfTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toMortals\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"revAddressesStack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"checkAddress\",\"type\":\"address\"}],\"name\":\"checkWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_currentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastReapedAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sowReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pivot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"_REAPER","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://ea16fffb7b3baa67eebcf8e80cdae45114e6a64b9ce678e56785ae9902766013"}]}