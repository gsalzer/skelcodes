{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\n\n\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    \n    function add(Role storage role, address account) internal {\n        require(account != address(0));\n        require(!has(role, account));\n\n        role.bearer[account] = true;\n    }\n\n    \n    function remove(Role storage role, address account) internal {\n        require(account != address(0));\n        require(has(role, account));\n\n        role.bearer[account] = false;\n    }\n\n    \n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0));\n        return role.bearer[account];\n    }\n}\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender));\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\ninterface IERC1400 {\n\n    \n    function getDocument(bytes32 name) external view returns (string memory, bytes32); \n    function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external; \n    event Document(bytes32 indexed name, string uri, bytes32 documentHash);\n\n    \n    function isControllable() external view returns (bool); \n\n    \n    function isIssuable() external view returns (bool); \n    function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data) external; \n    event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\n\n    \n    function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data) external; \n    function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData) external; \n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\n\n    \n    function canTransferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external view returns (byte, bytes32, bytes32); \n    function canOperatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external view returns (byte, bytes32, bytes32); \n\n}\n\ninterface IERC1400Partition {\n\n    \n    function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256); \n    function partitionsOf(address tokenHolder) external view returns (bytes32[] memory); \n\n    \n    function transferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external returns (bytes32); \n    function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32); \n\n    \n    function getDefaultPartitions() external view returns (bytes32[] memory); \n    function setDefaultPartitions(bytes32[] calldata partitions) external; \n\n    \n    function controllersByPartition(bytes32 partition) external view returns (address[] memory); \n    function authorizeOperatorByPartition(bytes32 partition, address operator) external; \n    function revokeOperatorByPartition(bytes32 partition, address operator) external; \n    function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool); \n\n    \n    event TransferByPartition(\n        bytes32 indexed fromPartition,\n        address operator,\n        address indexed from,\n        address indexed to,\n        uint256 value,\n        bytes data,\n        bytes operatorData\n    );\n\n    event ChangedPartition(\n        bytes32 indexed fromPartition,\n        bytes32 indexed toPartition,\n        uint256 value\n    );\n\n    \n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n\n}\n\nlibrary SafeMath {\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        require(b > 0);\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n\n    \n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    \n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    \n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract ReentrancyGuard {\n    \n    uint256 private _guardCounter;\n\n    constructor () internal {\n        \n        \n        _guardCounter = 1;\n    }\n\n    \n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter);\n    }\n}\n\ncontract ERC1820Registry {\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address);\n    function setManager(address _addr, address _newManager) external;\n    function getManager(address _addr) public view returns (address);\n}\n\ncontract ERC1820Client {\n    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    function setInterfaceImplementation(string memory _interfaceLabel, address _implementation) internal {\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n        ERC1820REGISTRY.setInterfaceImplementer(address(this), interfaceHash, _implementation);\n    }\n\n    function interfaceAddr(address addr, string memory _interfaceLabel) internal view returns(address) {\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        ERC1820REGISTRY.setManager(address(this), _newManager);\n    }\n}\n\ncontract CertificateControllerMock {\n\n  \n  mapping(address => bool) internal _certificateSigners;\n\n  \n  mapping(address => uint256) internal _checkCount;\n\n  event Checked(address sender);\n\n  constructor(address _certificateSigner) public {\n    _setCertificateSigner(_certificateSigner, true);\n  }\n\n  \n  modifier isValidCertificate(bytes memory data) {\n\n    require(_certificateSigners[msg.sender] || _checkCertificate(data, 0, 0x00000000), \"A3\"); \n\n    _checkCount[msg.sender] += 1; \n\n    emit Checked(msg.sender);\n    _;\n  }\n\n  \n  function checkCount(address sender) external view returns (uint256) {\n    return _checkCount[sender];\n  }\n\n  \n  function certificateSigners(address operator) external view returns (bool) {\n    return _certificateSigners[operator];\n  }\n\n  \n  function _setCertificateSigner(address operator, bool authorized) internal {\n    require(operator != address(0)); \n    _certificateSigners[operator] = authorized;\n  }\n\n  \n   function _checkCertificate(bytes memory data, uint256 , bytes4 ) internal pure returns(bool) { \n     if(data.length > 0 && (data[0] == hex\"10\" || data[0] == hex\"11\" || data[0] == hex\"22\")) {\n       return true;\n     } else {\n       return false;\n     }\n   }\n}\n\ncontract CertificateController is CertificateControllerMock {\n\n  constructor(address _certificateSigner) public CertificateControllerMock(_certificateSigner) {}\n\n}\n\ninterface IERC1400Raw {\n\n  function name() external view returns (string memory); \n  function symbol() external view returns (string memory); \n  function totalSupply() external view returns (uint256); \n  function balanceOf(address owner) external view returns (uint256); \n  function granularity() external view returns (uint256); \n\n  function controllers() external view returns (address[] memory); \n  function authorizeOperator(address operator) external; \n  function revokeOperator(address operator) external; \n  function isOperator(address operator, address tokenHolder) external view returns (bool); \n\n  function transferWithData(address to, uint256 value, bytes calldata data) external; \n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external; \n\n  function redeem(uint256 value, bytes calldata data) external; \n  function redeemFrom(address from, uint256 value, bytes calldata data, bytes calldata operatorData) external; \n\n  event TransferWithData(\n    address indexed operator,\n    address indexed from,\n    address indexed to,\n    uint256 value,\n    bytes data,\n    bytes operatorData\n  );\n  event Issued(address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\n  event Redeemed(address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\n\n}\n\ninterface IERC1400TokensSender {\n\n  function canTransfer(\n    bytes32 partition,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external view returns(bool);\n\n  function tokensToTransfer(\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external;\n\n}\n\ninterface IERC1400TokensRecipient {\n\n  function canReceive(\n    bytes32 partition,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external view returns(bool);\n\n  function tokensReceived(\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint value,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external;\n\n}\n\ncontract ERC1400Raw is IERC1400Raw, Ownable, ERC1820Client, CertificateController, ReentrancyGuard {\n  using SafeMath for uint256;\n\n  string internal _name;\n  string internal _symbol;\n  uint256 internal _granularity;\n  uint256 internal _totalSupply;\n\n  \n  bool internal _isControllable;\n\n  \n  mapping(address => uint256) internal _balances;\n\n  \n  \n  mapping(address => mapping(address => bool)) internal _authorizedOperator;\n\n  \n  address[] internal _controllers;\n\n  \n  mapping(address => bool) internal _isController;\n  \n\n  \n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 granularity,\n    address[] memory controllers,\n    address certificateSigner\n  )\n    public\n    CertificateController(certificateSigner)\n  {\n    _name = name;\n    _symbol = symbol;\n    _totalSupply = 0;\n    require(granularity >= 1); \n    _granularity = granularity;\n\n    _setControllers(controllers);\n  }\n\n  \n\n  \n  function name() external view returns(string memory) {\n    return _name;\n  }\n\n  \n  function symbol() external view returns(string memory) {\n    return _symbol;\n  }\n\n  \n  function totalSupply() external view returns (uint256) {\n    return _totalSupply;\n  }\n\n  \n  function balanceOf(address tokenHolder) external view returns (uint256) {\n    return _balances[tokenHolder];\n  }\n\n  \n  function granularity() external view returns(uint256) {\n    return _granularity;\n  }\n\n  \n  function controllers() external view returns (address[] memory) {\n    return _controllers;\n  }\n\n  \n  function authorizeOperator(address operator) external {\n    require(operator != msg.sender);\n    _authorizedOperator[operator][msg.sender] = true;\n    emit AuthorizedOperator(operator, msg.sender);\n  }\n\n  \n  function revokeOperator(address operator) external {\n    require(operator != msg.sender);\n    _authorizedOperator[operator][msg.sender] = false;\n    emit RevokedOperator(operator, msg.sender);\n  }\n\n  \n  function isOperator(address operator, address tokenHolder) external view returns (bool) {\n    return _isOperator(operator, tokenHolder);\n  }\n\n  \n  function transferWithData(address to, uint256 value, bytes calldata data)\n    external\n    isValidCertificate(data)\n  {\n    _transferWithData(\"\", msg.sender, msg.sender, to, value, data, \"\", true);\n  }\n\n  \n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\n    external\n    isValidCertificate(operatorData)\n  {\n    require(_isOperator(msg.sender, from), \"A7\"); \n\n    _transferWithData(\"\", msg.sender, from, to, value, data, operatorData, true);\n  }\n\n  \n  function redeem(uint256 value, bytes calldata data)\n    external\n    isValidCertificate(data)\n  {\n    _redeem(\"\", msg.sender, msg.sender, value, data, \"\");\n  }\n\n  \n  function redeemFrom(address from, uint256 value, bytes calldata data, bytes calldata operatorData)\n    external\n    isValidCertificate(operatorData)\n  {\n    require(_isOperator(msg.sender, from), \"A7\"); \n\n    _redeem(\"\", msg.sender, from, value, data, operatorData);\n  }\n\n  \n\n  \n  function _isMultiple(uint256 value) internal view returns(bool) {\n    return(value.div(_granularity).mul(_granularity) == value);\n  }\n\n  \n  function _isRegularAddress(address addr) internal view returns(bool) {\n    if (addr == address(0)) { return false; }\n    uint size;\n    assembly { size := extcodesize(addr) } \n    return size == 0;\n  }\n\n  \n  function _isOperator(address operator, address tokenHolder) internal view returns (bool) {\n    return (operator == tokenHolder\n      || _authorizedOperator[operator][tokenHolder]\n      || (_isControllable && _isController[operator])\n    );\n  }\n\n   \n  function _transferWithData(\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData,\n    bool preventLocking\n  )\n    internal\n    nonReentrant\n  {\n    require(_isMultiple(value), \"A9\"); \n    require(to != address(0), \"A6\"); \n    require(_balances[from] >= value, \"A4\"); \n\n    _callSender(partition, operator, from, to, value, data, operatorData);\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n\n    _callRecipient(partition, operator, from, to, value, data, operatorData, preventLocking);\n\n    emit TransferWithData(operator, from, to, value, data, operatorData);\n  }\n\n  \n  function _redeem(bytes32 partition, address operator, address from, uint256 value, bytes memory data, bytes memory operatorData)\n    internal\n    nonReentrant\n  {\n    require(_isMultiple(value), \"A9\"); \n    require(from != address(0), \"A5\"); \n    require(_balances[from] >= value, \"A4\"); \n\n    _callSender(partition, operator, from, address(0), value, data, operatorData);\n\n    _balances[from] = _balances[from].sub(value);\n    _totalSupply = _totalSupply.sub(value);\n\n    emit Redeemed(operator, from, value, data, operatorData);\n  }\n\n  \n  function _callSender(\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData\n  )\n    internal\n  {\n    address senderImplementation;\n    senderImplementation = interfaceAddr(from, \"ERC1400TokensSender\");\n\n    if (senderImplementation != address(0)) {\n      IERC1400TokensSender(senderImplementation).tokensToTransfer(partition, operator, from, to, value, data, operatorData);\n    }\n  }\n\n  \n  function _callRecipient(\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData,\n    bool preventLocking\n  )\n    internal\n  {\n    address recipientImplementation;\n    recipientImplementation = interfaceAddr(to, \"ERC1400TokensRecipient\");\n\n    if (recipientImplementation != address(0)) {\n      IERC1400TokensRecipient(recipientImplementation).tokensReceived(partition, operator, from, to, value, data, operatorData);\n    } else if (preventLocking) {\n      require(_isRegularAddress(to), \"A6\"); \n    }\n  }\n\n  \n  function _issue(bytes32 partition, address operator, address to, uint256 value, bytes memory data, bytes memory operatorData) internal nonReentrant {\n    require(_isMultiple(value), \"A9\"); \n    require(to != address(0), \"A6\"); \n\n    _totalSupply = _totalSupply.add(value);\n    _balances[to] = _balances[to].add(value);\n\n    _callRecipient(partition, operator, address(0), to, value, data, operatorData, true);\n\n    emit Issued(operator, to, value, data, operatorData);\n  }\n\n  \n\n  \n  function _setControllers(address[] memory operators) internal {\n    for (uint i = 0; i<_controllers.length; i++){\n      _isController[_controllers[i]] = false;\n    }\n    for (uint j = 0; j<operators.length; j++){\n      _isController[operators[j]] = true;\n    }\n    _controllers = operators;\n  }\n\n}\n\ncontract ERC1400Partition is IERC1400Partition, ERC1400Raw {\n\n  \n  \n  bytes32[] internal _totalPartitions;\n\n  \n  mapping (bytes32 => uint256) internal _indexOfTotalPartitions;\n\n  \n  mapping (bytes32 => uint256) internal _totalSupplyByPartition;\n\n  \n  mapping (address => bytes32[]) internal _partitionsOf;\n\n  \n  mapping (address => mapping (bytes32 => uint256)) internal _indexOfPartitionsOf;\n\n  \n  mapping (address => mapping (bytes32 => uint256)) internal _balanceOfByPartition;\n\n  \n  bytes32[] internal _defaultPartitions;\n  \n\n  \n  \n  mapping (address => mapping (bytes32 => mapping (address => bool))) internal _authorizedOperatorByPartition;\n\n  \n  mapping (bytes32 => address[]) internal _controllersByPartition;\n\n  \n  mapping (bytes32 => mapping (address => bool)) internal _isControllerByPartition;\n  \n\n  \n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 granularity,\n    address[] memory controllers,\n    address certificateSigner,\n    bytes32[] memory defaultPartitions\n  )\n    public\n    ERC1400Raw(name, symbol, granularity, controllers, certificateSigner)\n  {\n    _defaultPartitions = defaultPartitions;\n  }\n\n  \n\n  \n  function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256) {\n    return _balanceOfByPartition[tokenHolder][partition];\n  }\n\n  \n  function partitionsOf(address tokenHolder) external view returns (bytes32[] memory) {\n    return _partitionsOf[tokenHolder];\n  }\n\n  \n  function transferByPartition(\n    bytes32 partition,\n    address to,\n    uint256 value,\n    bytes calldata data\n  )\n    external\n    isValidCertificate(data)\n    returns (bytes32)\n  {\n    return _transferByPartition(partition, msg.sender, msg.sender, to, value, data, \"\", true);\n  }\n\n  \n  function operatorTransferByPartition(\n    bytes32 partition,\n    address from,\n    address to,\n    uint256 value,\n    bytes calldata data,\n    bytes calldata operatorData\n  )\n    external\n    isValidCertificate(operatorData)\n    returns (bytes32)\n  {\n    require(_isOperatorForPartition(partition, msg.sender, from), \"A7\"); \n\n    return _transferByPartition(partition, msg.sender, from, to, value, data, operatorData, true);\n  }\n\n  \n  function getDefaultPartitions() external view returns (bytes32[] memory) {\n    return _defaultPartitions;\n  }\n\n  \n  function setDefaultPartitions(bytes32[] calldata partitions) external onlyOwner {\n    _defaultPartitions = partitions;\n  }\n\n  \n  function controllersByPartition(bytes32 partition) external view returns (address[] memory) {\n    return _controllersByPartition[partition];\n  }\n\n  \n  function authorizeOperatorByPartition(bytes32 partition, address operator) external {\n    _authorizedOperatorByPartition[msg.sender][partition][operator] = true;\n    emit AuthorizedOperatorByPartition(partition, operator, msg.sender);\n  }\n\n  \n  function revokeOperatorByPartition(bytes32 partition, address operator) external {\n    _authorizedOperatorByPartition[msg.sender][partition][operator] = false;\n    emit RevokedOperatorByPartition(partition, operator, msg.sender);\n  }\n\n  \n  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool) {\n    return _isOperatorForPartition(partition, operator, tokenHolder);\n  }\n\n  \n\n  \n   function _isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) internal view returns (bool) {\n     return (_isOperator(operator, tokenHolder)\n       || _authorizedOperatorByPartition[tokenHolder][partition][operator]\n       || (_isControllable && _isControllerByPartition[partition][operator])\n     );\n   }\n\n  \n  function _transferByPartition(\n    bytes32 fromPartition,\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData,\n    bool preventLocking\n  )\n    internal\n    returns (bytes32)\n  {\n    require(_balanceOfByPartition[from][fromPartition] >= value, \"A4\"); \n\n    bytes32 toPartition = fromPartition;\n\n    if(operatorData.length != 0 && data.length >= 64) {\n      toPartition = _getDestinationPartition(fromPartition, data);\n    }\n\n    _removeTokenFromPartition(from, fromPartition, value);\n    _transferWithData(fromPartition, operator, from, to, value, data, operatorData, preventLocking);\n    _addTokenToPartition(to, toPartition, value);\n\n    emit TransferByPartition(fromPartition, operator, from, to, value, data, operatorData);\n\n    if(toPartition != fromPartition) {\n      emit ChangedPartition(fromPartition, toPartition, value);\n    }\n\n    return toPartition;\n  }\n\n  \n  function _removeTokenFromPartition(address from, bytes32 partition, uint256 value) internal {\n    _balanceOfByPartition[from][partition] = _balanceOfByPartition[from][partition].sub(value);\n    _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition].sub(value);\n\n    \n    if(_totalSupplyByPartition[partition] == 0) {\n      uint256 index1 = _indexOfTotalPartitions[partition];\n      require(index1 > 0, \"A8\"); \n\n      \n      bytes32 lastValue = _totalPartitions[_totalPartitions.length - 1];\n      _totalPartitions[index1 - 1] = lastValue; \n      _indexOfTotalPartitions[lastValue] = index1;\n\n      _totalPartitions.length -= 1;\n      _indexOfTotalPartitions[partition] = 0;\n    }\n\n    \n    if(_balanceOfByPartition[from][partition] == 0) {\n      uint256 index2 = _indexOfPartitionsOf[from][partition];\n      require(index2 > 0, \"A8\"); \n\n      \n      bytes32 lastValue = _partitionsOf[from][_partitionsOf[from].length - 1];\n      _partitionsOf[from][index2 - 1] = lastValue;  \n      _indexOfPartitionsOf[from][lastValue] = index2;\n\n      _partitionsOf[from].length -= 1;\n      _indexOfPartitionsOf[from][partition] = 0;\n    }\n\n  }\n\n  \n  function _addTokenToPartition(address to, bytes32 partition, uint256 value) internal {\n    if(value != 0) {\n      if (_indexOfPartitionsOf[to][partition] == 0) {\n        _partitionsOf[to].push(partition);\n        _indexOfPartitionsOf[to][partition] = _partitionsOf[to].length;\n      }\n      _balanceOfByPartition[to][partition] = _balanceOfByPartition[to][partition].add(value);\n\n      if (_indexOfTotalPartitions[partition] == 0) {\n        _totalPartitions.push(partition);\n        _indexOfTotalPartitions[partition] = _totalPartitions.length;\n      }\n      _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition].add(value);\n    }\n  }\n\n  \n  function _getDestinationPartition(bytes32 fromPartition, bytes memory data) internal pure returns(bytes32 toPartition) {\n    bytes32 changePartitionFlag = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    bytes32 flag;\n    assembly {\n      flag := mload(add(data, 32))\n    }\n    if(flag == changePartitionFlag) {\n      assembly {\n        toPartition := mload(add(data, 64))\n      }\n    } else {\n      toPartition = fromPartition;\n    }\n  }\n\n  \n\n  \n  function totalPartitions() external view returns (bytes32[] memory) {\n    return _totalPartitions;\n  }\n\n  \n   function _setPartitionControllers(bytes32 partition, address[] memory operators) internal {\n     for (uint i = 0; i<_controllersByPartition[partition].length; i++){\n       _isControllerByPartition[partition][_controllersByPartition[partition][i]] = false;\n     }\n     for (uint j = 0; j<operators.length; j++){\n       _isControllerByPartition[partition][operators[j]] = true;\n     }\n     _controllersByPartition[partition] = operators;\n   }\n\n  \n\n  \n  function transferWithData(address to, uint256 value, bytes calldata data)\n    external\n    isValidCertificate(data)\n  {\n    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, data, \"\", true);\n  }\n\n  \n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\n    external\n    isValidCertificate(operatorData)\n  {\n    require(_isOperator(msg.sender, from), \"A7\"); \n\n    _transferByDefaultPartitions(msg.sender, from, to, value, data, operatorData, true);\n  }\n\n  \n  function redeem(uint256 , bytes calldata ) external { \n    revert(\"A8: Transfer Blocked - Token restriction\");\n  }\n\n  \n  function redeemFrom(address , uint256 , bytes calldata , bytes calldata ) external { \n    revert(\"A8: Transfer Blocked - Token restriction\");\n  }\n\n  \n  function _transferByDefaultPartitions(\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData,\n    bool preventLocking\n  )\n    internal\n  {\n    require(_defaultPartitions.length != 0, \"A8\"); \n\n    uint256 _remainingValue = value;\n    uint256 _localBalance;\n\n    for (uint i = 0; i < _defaultPartitions.length; i++) {\n      _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\n      if(_remainingValue <= _localBalance) {\n        _transferByPartition(_defaultPartitions[i], operator, from, to, _remainingValue, data, operatorData, preventLocking);\n        _remainingValue = 0;\n        break;\n      } else if (_localBalance != 0) {\n        _transferByPartition(_defaultPartitions[i], operator, from, to, _localBalance, data, operatorData, preventLocking);\n        _remainingValue = _remainingValue - _localBalance;\n      }\n    }\n\n    require(_remainingValue == 0, \"A8\"); \n  }\n}\n\ncontract ERC1400 is IERC1400, ERC1400Partition, MinterRole {\n\n  struct Doc {\n    string docURI;\n    bytes32 docHash;\n  }\n\n  \n  mapping(bytes32 => Doc) internal _documents;\n\n  \n  bool internal _isIssuable;\n\n  \n  modifier issuableToken() {\n    require(_isIssuable, \"A8\"); \n    _;\n  }\n\n  \n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 granularity,\n    address[] memory controllers,\n    address certificateSigner,\n    bytes32[] memory defaultPartitions\n  )\n    public\n    ERC1400Partition(name, symbol, granularity, controllers, certificateSigner, defaultPartitions)\n  {\n    setInterfaceImplementation(\"ERC1400Token\", address(this));\n    _isControllable = true;\n    _isIssuable = true;\n  }\n\n  \n\n  \n  function getDocument(bytes32 name) external view returns (string memory, bytes32) {\n    require(bytes(_documents[name].docURI).length != 0); \n    return (\n      _documents[name].docURI,\n      _documents[name].docHash\n    );\n  }\n\n  \n  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external {\n    require(_isController[msg.sender]);\n    _documents[name] = Doc({\n      docURI: uri,\n      docHash: documentHash\n    });\n    emit Document(name, uri, documentHash);\n  }\n\n  \n  function isControllable() external view returns (bool) {\n    return _isControllable;\n  }\n\n  \n  function isIssuable() external view returns (bool) {\n    return _isIssuable;\n  }\n\n  \n  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data)\n    external\n    onlyMinter\n    issuableToken\n    isValidCertificate(data)\n  {\n    _issueByPartition(partition, msg.sender, tokenHolder, value, data, \"\");\n  }\n\n  \n  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data)\n    external\n    isValidCertificate(data)\n  {\n    _redeemByPartition(partition, msg.sender, msg.sender, value, data, \"\");\n  }\n\n  \n  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData)\n    external\n    isValidCertificate(operatorData)\n  {\n    require(_isOperatorForPartition(partition, msg.sender, tokenHolder), \"A7\"); \n\n    _redeemByPartition(partition, msg.sender, tokenHolder, value, data, operatorData);\n  }\n\n  \n  function canTransferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data)\n    external\n    view\n    returns (byte, bytes32, bytes32)\n  {\n    if(!_checkCertificate(data, 0, this.transferByPartition.selector)) { \n      return(hex\"A3\", \"\", partition); \n    } else {\n      return _canTransfer(partition, msg.sender, msg.sender, to, value, data, \"\");\n    }\n  }\n\n  \n  function canOperatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\n    external\n    view\n    returns (byte, bytes32, bytes32)\n  {\n    if(!_checkCertificate(operatorData, 0, this.operatorTransferByPartition.selector)) { \n      return(hex\"A3\", \"\", partition); \n    } else {\n      return _canTransfer(partition, msg.sender, from, to, value, data, operatorData);\n    }\n  }\n\n  \n\n  \n   function _canTransfer(bytes32 partition, address operator, address from, address to, uint256 value, bytes memory data, bytes memory operatorData)\n     internal\n     view\n     returns (byte, bytes32, bytes32)\n   {\n     if(!_isOperatorForPartition(partition, operator, from))\n       return(hex\"A7\", \"\", partition); \n\n     if((_balances[from] < value) || (_balanceOfByPartition[from][partition] < value))\n       return(hex\"A4\", \"\", partition); \n\n     if(to == address(0))\n       return(hex\"A6\", \"\", partition); \n\n     address senderImplementation;\n     address recipientImplementation;\n     senderImplementation = interfaceAddr(from, \"ERC1400TokensSender\");\n     recipientImplementation = interfaceAddr(to, \"ERC1400TokensRecipient\");\n\n     if((senderImplementation != address(0))\n       && !IERC1400TokensSender(senderImplementation).canTransfer(partition, from, to, value, data, operatorData))\n       return(hex\"A5\", \"\", partition); \n\n     if((recipientImplementation != address(0))\n       && !IERC1400TokensRecipient(recipientImplementation).canReceive(partition, from, to, value, data, operatorData))\n       return(hex\"A6\", \"\", partition); \n\n     if(!_isMultiple(value))\n       return(hex\"A9\", \"\", partition); \n\n     return(hex\"A2\", \"\", partition);  \n   }\n\n  \n  function _issueByPartition(\n    bytes32 toPartition,\n    address operator,\n    address to,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData\n  )\n    internal\n  {\n    _issue(toPartition, operator, to, value, data, operatorData);\n    _addTokenToPartition(to, toPartition, value);\n\n    emit IssuedByPartition(toPartition, operator, to, value, data, operatorData);\n  }\n\n  \n  function _redeemByPartition(\n    bytes32 fromPartition,\n    address operator,\n    address from,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData\n  )\n    internal\n  {\n    require(_balanceOfByPartition[from][fromPartition] >= value, \"A4\"); \n\n    _removeTokenFromPartition(from, fromPartition, value);\n    _redeem(fromPartition, operator, from, value, data, operatorData);\n\n    emit RedeemedByPartition(fromPartition, operator, from, value, data, operatorData);\n  }\n\n  \n\n  \n  function renounceControl() external onlyOwner {\n    _isControllable = false;\n  }\n\n  \n  function renounceIssuance() external onlyOwner {\n    _isIssuable = false;\n  }\n\n  \n  function setControllers(address[] calldata operators) external onlyOwner {\n    _setControllers(operators);\n  }\n\n  \n   function setPartitionControllers(bytes32 partition, address[] calldata operators) external onlyOwner {\n     _setPartitionControllers(partition, operators);\n   }\n\n   \n  function setCertificateSigner(address operator, bool authorized) external onlyOwner {\n    _setCertificateSigner(operator, authorized);\n  }\n\n  \n\n\n  \n  function redeem(uint256 value, bytes calldata data)\n    external\n    isValidCertificate(data)\n  {\n    _redeemByDefaultPartitions(msg.sender, msg.sender, value, data, \"\");\n  }\n\n  \n  function redeemFrom(address from, uint256 value, bytes calldata data, bytes calldata operatorData)\n    external\n    isValidCertificate(operatorData)\n  {\n    require(_isOperator(msg.sender, from), \"A7\"); \n\n    _redeemByDefaultPartitions(msg.sender, from, value, data, operatorData);\n  }\n\n  \n  function _redeemByDefaultPartitions(\n    address operator,\n    address from,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData\n  )\n    internal\n  {\n    require(_defaultPartitions.length != 0, \"A8\"); \n\n    uint256 _remainingValue = value;\n    uint256 _localBalance;\n\n    for (uint i = 0; i < _defaultPartitions.length; i++) {\n      _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\n      if(_remainingValue <= _localBalance) {\n        _redeemByPartition(_defaultPartitions[i], operator, from, _remainingValue, data, operatorData);\n        _remainingValue = 0;\n        break;\n      } else {\n        _redeemByPartition(_defaultPartitions[i], operator, from, _localBalance, data, operatorData);\n        _remainingValue = _remainingValue - _localBalance;\n      }\n    }\n\n    require(_remainingValue == 0, \"A8\"); \n  }\n\n}\n\ncontract ERC1400ERC20 is IERC20, ERC1400 {\n\n  \n  mapping (address => mapping (address => uint256)) internal _allowed;\n\n  \n  mapping (address => bool) internal _whitelisted;\n\n  \n  modifier areWhitelisted(address sender, address recipient) {\n    require(_whitelisted[sender], \"A5\"); \n    require(_whitelisted[recipient], \"A6\"); \n    _;\n  }\n\n  \n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 granularity,\n    address[] memory controllers,\n    address certificateSigner,\n    bytes32[] memory tokenDefaultPartitions\n  )\n    public\n    ERC1400(name, symbol, granularity, controllers, certificateSigner, tokenDefaultPartitions)\n  {\n    setInterfaceImplementation(\"ERC20Token\", address(this));\n  }\n\n  \n  function _transferWithData(\n    bytes32 partition,\n    address operator,\n    address from,\n    address to,\n    uint256 value,\n    bytes memory data,\n    bytes memory operatorData,\n    bool preventLocking\n  )\n    internal\n  {\n    ERC1400Raw._transferWithData(partition, operator, from, to, value, data, operatorData, preventLocking);\n\n    emit Transfer(from, to, value);\n  }\n\n  \n  function _redeem(bytes32 partition, address operator, address from, uint256 value, bytes memory data, bytes memory operatorData) internal {\n    ERC1400Raw._redeem(partition, operator, from, value, data, operatorData);\n\n    emit Transfer(from, address(0), value);  \n  }\n\n  \n  function _issue(bytes32 partition, address operator, address to, uint256 value, bytes memory data, bytes memory operatorData) internal {\n    ERC1400Raw._issue(partition, operator, to, value, data, operatorData);\n\n    emit Transfer(address(0), to, value); \n  }\n\n  \n  function decimals() external pure returns(uint8) {\n    return uint8(18);\n  }\n\n  \n  function allowance(address owner, address spender) external view returns (uint256) {\n    return _allowed[owner][spender];\n  }\n\n  \n  function approve(address spender, uint256 value) external returns (bool) {\n    require(spender != address(0), \"A5\"); \n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  \n  function transfer(address to, uint256 value) external areWhitelisted(msg.sender, to) returns (bool) {\n    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, \"\", \"\", false);\n    return true;\n  }\n\n  \n  function transferFrom(address from, address to, uint256 value) external areWhitelisted(from, to) returns (bool) {\n    require( _isOperator(msg.sender, from)\n      || (value <= _allowed[from][msg.sender]), \"A7\"); \n\n    if(_allowed[from][msg.sender] >= value) {\n      _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    } else {\n      _allowed[from][msg.sender] = 0;\n    }\n\n    _transferByDefaultPartitions(msg.sender, from, to, value, \"\", \"\", false);\n    return true;\n  }\n\n  \n\n  \n  function whitelisted(address tokenHolder) external view returns (bool) {\n    return _whitelisted[tokenHolder];\n  }\n\n  \n  function setWhitelisted(address tokenHolder, bool authorized) external {\n    require(_isController[msg.sender]);\n    _setWhitelisted(tokenHolder, authorized);\n  }\n\n  \n  function _setWhitelisted(address tokenHolder, bool authorized) internal {\n    require(tokenHolder != address(0)); \n    _whitelisted[tokenHolder] = authorized;\n  }\n\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"uri\",\"type\":\"string\"},{\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"setDocument\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperatorByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"tokenHolder\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorRedeemByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperatorByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setPartitionControllers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isIssuable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOfByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isControllable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeemByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"tokenHolder\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"issueByPartition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"checkCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPartitions\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"canOperatorTransferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceIssuance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorForPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"certificateSigners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"partitionsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"setCertificateSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controllers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"controllersByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"transferFromWithData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorTransferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"canTransferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"},{\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"setWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"getDocument\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDefaultPartitions\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceControl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setControllers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partitions\",\"type\":\"bytes32[]\"}],\"name\":\"setDefaultPartitions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"partition\",\"type\":\"bytes32\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferByPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"redeemFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"granularity\",\"type\":\"uint256\"},{\"name\":\"controllers\",\"type\":\"address[]\"},{\"name\":\"certificateSigner\",\"type\":\"address\"},{\"name\":\"tokenDefaultPartitions\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Checked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"TransferWithData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"TransferByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"toPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ChangedPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"Document\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"IssuedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"RedeemedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ERC1400ERC20","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000140000000000000000000000000e31c41f0f70c5ff39f73b4b94bccd767b307163000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000005574553544f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005574553544f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000b5747835141b46f7c472393b31f8f5a57f74a44f0000000000000000000000000000000000000000000000000000000000000003526573657276656400000000000000000000000000000000000000000000000049737375656400000000000000000000000000000000000000000000000000004c6f636b65640000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"","SwarmSource":"bzzr://51bd0f44a6716a672ddab2ab3c982a21e24ca9820dcd8b3ccd6feb21671d5b65"}]}