{"status":"1","message":"OK","result":[{"SourceCode":"//orfeed.org alpha contract\r\n\r\npragma solidity ^0.4.26;\r\n\r\ninterface IKyberNetworkProxy {\r\n    function maxGasPrice() external view returns(uint);\r\n    function getUserCapInWei(address user) external view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) external view returns(uint);\r\n    function enabled() external view returns(bool);\r\n    function info(bytes32 id) external view returns(uint);\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) external view returns (uint expectedRate, uint slippageRate);\r\n    function tradeWithHint(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount, uint minConversionRate, address walletId, bytes hint) external payable returns(uint);\r\n    function swapEtherToToken(ERC20 token, uint minRate) external payable returns (uint);\r\n    function swapTokenToEther(ERC20 token, uint tokenQty, uint minRate) external returns (uint);\r\n}\r\n\r\ninterface SynthetixExchange {\r\n    function effectiveValue(bytes32 from, uint256 amount, bytes32 to) external view returns (uint256);\r\n}\r\n\r\ninterface Kyber {\r\n    function getOutputAmount(ERC20 from, ERC20 to, uint256 amount) external view returns (uint256);\r\n    function getInputAmount(ERC20 from, ERC20 to, uint256 amount) external view returns (uint256);\r\n}\r\n \r\ninterface Synthetix {\r\n    function getOutputAmount(bytes32 from, bytes32 to, uint256 amount) external view returns (uint256);\r\n    function getInputAmount(bytes32 from, bytes32 to, uint256 amount) external view returns (uint256);\r\n}\r\n\r\ninterface premiumSubInterface {\r\n    function getExchangeRate(string fromSymbol, string toSymbol, string venue, uint256 amount, address requestAddress ) external view returns(uint256);\r\n\r\n}\r\ninterface synthetixMain {\r\n    function getOutputAmount(bytes32 from, bytes32 to, uint256 amount) external view returns (uint256);\r\n    function getInputAmount(bytes32 from, bytes32 to, uint256 amount) external view returns (uint256);\r\n}\r\n\r\ncontract synthConvertInterface{\r\n    function name (  ) external view returns ( string );\r\n    function setGasPriceLimit ( uint256 _gasPriceLimit ) external;\r\n    function approve ( address spender, uint256 value ) external returns ( bool );\r\n    function removeSynth ( bytes32 currencyKey ) external;\r\n    function issueSynths ( bytes32 currencyKey, uint256 amount ) external;\r\n    function mint (  ) external returns ( bool );\r\n    function setIntegrationProxy ( address _integrationProxy ) external;\r\n    function nominateNewOwner ( address _owner ) external;\r\n    function initiationTime (  ) external view returns ( uint256 );\r\n    function totalSupply (  ) external view returns ( uint256 );\r\n    function setFeePool ( address _feePool ) external;\r\n    function exchange ( bytes32 sourceCurrencyKey, uint256 sourceAmount, bytes32 destinationCurrencyKey, address destinationAddress ) external returns ( bool );\r\n    function setSelfDestructBeneficiary ( address _beneficiary ) external;\r\n    function transferFrom ( address from, address to, uint256 value ) external returns ( bool );\r\n    function decimals (  ) external view returns ( uint8 );\r\n    function synths ( bytes32 ) external view returns ( address );\r\n    function terminateSelfDestruct (  ) external;\r\n    function rewardsDistribution (  ) external view returns ( address );\r\n    function exchangeRates (  ) external view returns ( address );\r\n    function nominatedOwner (  ) external view returns ( address );\r\n    function setExchangeRates ( address _exchangeRates ) external;\r\n    function effectiveValue ( bytes32 sourceCurrencyKey, uint256 sourceAmount, bytes32 destinationCurrencyKey ) external view returns ( uint256 );\r\n    function transferableSynthetix ( address account ) external view returns ( uint256 );\r\n    function validateGasPrice ( uint256 _givenGasPrice ) external view;\r\n    function balanceOf ( address account ) external view returns ( uint256 );\r\n    function availableCurrencyKeys (  ) external view returns ( bytes32[] );\r\n    function acceptOwnership (  ) external;\r\n    function remainingIssuableSynths ( address issuer, bytes32 currencyKey ) external view returns ( uint256 );\r\n    function availableSynths ( uint256 ) external view returns ( address );\r\n    function totalIssuedSynths ( bytes32 currencyKey ) external view returns ( uint256 );\r\n    function addSynth ( address synth ) external;\r\n    function owner (  ) external view returns ( address );\r\n    function setExchangeEnabled ( bool _exchangeEnabled ) external;\r\n    function symbol (  ) external view returns ( string );\r\n    function gasPriceLimit (  ) external view returns ( uint256 );\r\n    function setProxy ( address _proxy ) external;\r\n    function selfDestruct (  ) external;\r\n    function integrationProxy (  ) external view returns ( address );\r\n    function setTokenState ( address _tokenState ) external;\r\n    function collateralisationRatio ( address issuer ) external view returns ( uint256 );\r\n    function rewardEscrow (  ) external view returns ( address );\r\n    function SELFDESTRUCT_DELAY (  ) external view returns ( uint256 );\r\n    function collateral ( address account ) external view returns ( uint256 );\r\n    function maxIssuableSynths ( address issuer, bytes32 currencyKey ) external view returns ( uint256 );\r\n    function transfer ( address to, uint256 value ) external returns ( bool );\r\n    function synthInitiatedExchange ( address from, bytes32 sourceCurrencyKey, uint256 sourceAmount, bytes32 destinationCurrencyKey, address destinationAddress ) external returns ( bool );\r\n    function transferFrom ( address from, address to, uint256 value, bytes data ) external returns ( bool );\r\n    function feePool (  ) external view returns ( address );\r\n    function selfDestructInitiated (  ) external view returns ( bool );\r\n    function setMessageSender ( address sender ) external;\r\n    function initiateSelfDestruct (  ) external;\r\n    function transfer ( address to, uint256 value, bytes data ) external returns ( bool );\r\n    function supplySchedule (  ) external view returns ( address );\r\n    function selfDestructBeneficiary (  ) external view returns ( address );\r\n    function setProtectionCircuit ( bool _protectionCircuitIsActivated ) external;\r\n    function debtBalanceOf ( address issuer, bytes32 currencyKey ) external view returns ( uint256 );\r\n    function synthetixState (  ) external view returns ( address );\r\n    function availableSynthCount (  ) external view returns ( uint256 );\r\n    function allowance ( address owner, address spender ) external view returns ( uint256 );\r\n    function escrow (  ) external view returns ( address );\r\n    function tokenState (  ) external view returns ( address );\r\n    function burnSynths ( bytes32 currencyKey, uint256 amount ) external;\r\n    function proxy (  ) external view returns ( address );\r\n    function issueMaxSynths ( bytes32 currencyKey ) external;\r\n    function exchangeEnabled (  ) external view returns ( bool );\r\n}\r\n\r\ninterface Uniswap {\r\n    function getEthToTokenInputPrice(uint256 ethSold) external view returns(uint256);\r\n    function getEthToTokenOutputPrice(uint256 tokensBought) external view returns(uint256);\r\n    function getTokenToEthInputPrice(uint256 tokensSold) external view returns(uint256);\r\n    function getTokenToEthOutputPrice(uint256 ethBought) external view returns(uint256);\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {}\r\n    function symbol() public view returns (string) {}\r\n    function decimals() public view returns (uint8) {}\r\n    function totalSupply() public view returns (uint256) {}\r\n    function balanceOf(address _owner) public view returns (uint256) { _owner; }\r\n    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n    // Oracle Feed Contract\r\ncontract orfeed {\r\n    using SafeMath for uint256;\r\n\r\n    address owner;\r\n    mapping (string => address) freeRateTokenSymbols;\r\n    mapping (string => address) freeRateForexSymbols;\r\n    mapping (string => bytes32) freeRateForexBytes;\r\n\r\n    uint256 rateDivide1;\r\n    uint256 rateMultiply1;\r\n\r\n    uint256 rateDivide2;\r\n    uint256 rateMultiply2;\r\n\r\n    uint256 rateDivide3;\r\n    uint256 rateMultiply3;\r\n\r\n    uint256 rateDivide4;\r\n    uint256 rateMultiply4;\r\n\r\n    address tokenPriceOracleAddress;\r\n    address synthetixExchangeAddress;\r\n\r\n    address tokenPriceOracleAddress2;\r\n\r\n    //forex price oracle address. Can be changed by DAO\r\n    address forexPriceOracleAddress;\r\n\r\n    //premium price oracle address. Can be changed by DAO\r\n    address premiumSubPriceOracleAddress;\r\n\r\n    premiumSubInterface psi;\r\n    IKyberNetworkProxy ki;\r\n    SynthetixExchange se;\r\n    synthConvertInterface s;\r\n    synthetixMain si;\r\n    Kyber kyber;\r\n    Synthetix synthetix;\r\n    Uniswap uniswap;\r\n    ERC20 ethToken;\r\n\r\n    /*\r\n\r\n    ----\r\n\r\n\r\n    Below is referenced for understanding for how flow works\r\n\r\n\r\n    ----\r\n\r\n    This will be set in external premium sub contract\r\n    mapping(string => address) feedOwners;\r\n    mapping(string => uint256) feedOwnerDeposits;\r\n    mapping(string => address[]) feedSubscribers;\r\n\r\n    //normalsubfee should always remain zero\r\n    uint256 normalSubscriptionFee = 0;\r\n\r\n \r\n    \r\n    //voted on by owner DAO\r\n    uint256 premiumSubscriptionFee = 1;\r\n\r\n    //vote on by ownerDAO\r\n    uint256 purchaseUntakenFeedFee = 1;\r\n\r\n    //voted on by ownerDAO\r\n    uint256 houseTransactionPercentage = 1;\r\n\r\n    */\r\n\r\n    // Functions with this modifier can only be executed by the owner\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    //free ERC20 rates. Can be changed/updated by ownerDAO\r\n    constructor() public payable {\r\n        freeRateTokenSymbols['DAI'] = 0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359;\r\n        freeRateTokenSymbols['USDC'] = 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48;\r\n        freeRateTokenSymbols['MKR'] = 0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2;\r\n        freeRateTokenSymbols['LINK'] = 0x514910771af9ca656af840dff83e8264ecf986ca;\r\n        freeRateTokenSymbols['BAT'] = 0x0d8775f648430679a709e98d2b0cb6250d2887ef;\r\n        freeRateTokenSymbols['WBTC'] = 0x2260fac5e5542a773aa44fbcfedf7c193bc2c599;\r\n        freeRateTokenSymbols['OMG'] = 0xd26114cd6EE289AccF82350c8d8487fedB8A0C07;\r\n        freeRateTokenSymbols['ZRX'] = 0xe41d2489571d322189246dafa5ebde1f4699f498;\r\n        freeRateTokenSymbols['TUSD'] = 0x0000000000085d4780B73119b644AE5ecd22b376;\r\n        freeRateTokenSymbols['ETH'] = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n        freeRateTokenSymbols['WETH'] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2;\r\n\r\n        //free forex rates. Can be changed/updated by ownerDAO        \r\n        freeRateForexSymbols['USD'] = 0x57ab1e02fee23774580c119740129eac7081e9d3;\r\n        freeRateForexSymbols['EUR'] = 0xd71ecff9342a5ced620049e616c5035f1db98620;\r\n        freeRateForexSymbols['CHF'] = 0x0f83287ff768d1c1e17a42f44d644d7f22e8ee1d;\r\n        freeRateForexSymbols['JPY'] = 0xf6b1c627e95bfc3c1b4c9b825a032ff0fbf3e07d;\r\n        freeRateForexSymbols['GBP'] = 0x97fe22e7341a0cd8db6f6c021a24dc8f4dad855f;\r\n        \r\n        freeRateForexBytes['USD'] = 0x7355534400000000000000000000000000000000000000000000000000000000;\r\n        freeRateForexBytes['EUR'] = 0x7345555200000000000000000000000000000000000000000000000000000000;\r\n        freeRateForexBytes['CHF'] = 0x7343484600000000000000000000000000000000000000000000000000000000;\r\n        freeRateForexBytes['JPY'] = 0x734a505900000000000000000000000000000000000000000000000000000000;\r\n        freeRateForexBytes['GBP'] = 0x7347425000000000000000000000000000000000000000000000000000000000;\r\n\r\n        //when returning rates they will be first divided by and then multiplied by these rates\r\n        rateDivide1 = 100;\r\n        rateMultiply1 = 100;\r\n\r\n        rateDivide2 = 100;\r\n        rateMultiply2 = 100;\r\n\r\n        rateDivide3 = 100;\r\n        rateMultiply3 = 100;\r\n\r\n        rateDivide4 = 100;\r\n        rateMultiply4 = 100;\r\n\r\n        //erc20 price oracle address. Can be changed by DAO\r\n        tokenPriceOracleAddress = 0xFd9304Db24009694c680885e6aa0166C639727D6;\r\n        synthetixExchangeAddress = 0x99a46c42689720d9118FF7aF7ce80C2a92fC4f97;\r\n\r\n        tokenPriceOracleAddress2 =0xe9Cf7887b93150D4F2Da7dFc6D502B216438F244;\r\n\r\n        //forex price oracle address. Can be changed by DAO\r\n        forexPriceOracleAddress = 0xE86C848De6e4457720A1eb7f37B519010CD26d35;\r\n\r\n        //premium price oracle address. Can be changed by DAO\r\n        premiumSubPriceOracleAddress = 0xc011a72400e58ecd99ee497cf89e3775d4bd732f;\r\n\r\n        ethToken = ERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n        psi = premiumSubInterface(premiumSubPriceOracleAddress);\r\n\r\n        ki = IKyberNetworkProxy(tokenPriceOracleAddress);\r\n        se = SynthetixExchange(synthetixExchangeAddress);\r\n\r\n        si = synthetixMain(forexPriceOracleAddress);\r\n\r\n        kyber = Kyber(tokenPriceOracleAddress); // Kyber oracle\r\n        synthetix = Synthetix(forexPriceOracleAddress); // Synthetix oracle\r\n\r\n        uniswap = Uniswap(tokenPriceOracleAddress2); \r\n\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function () payable {\r\n        throw;\r\n    }\r\n\r\n    function getTokenToSynthOutputAmount(ERC20 token, bytes32 synth, uint256 inputAmount)  returns(uint256) {\r\n        uint256 ethAmount = kyber.getOutputAmount(token, ethToken, inputAmount);\r\n        uint256 sethAmount = uniswap.getEthToTokenInputPrice(ethAmount);\r\n        uint256 outputAmount = synthetix.getOutputAmount('sETH', synth, sethAmount);\r\n        return outputAmount;\r\n    }\r\n\r\n    function getSynthToTokenOutputAmount(bytes32 synth, ERC20 token, uint256 inputAmount) returns(uint256) {\r\n        uint256 sethAmount = synthetix.getOutputAmount(synth, 'sETH', inputAmount);\r\n        uint256 ethAmount = uniswap.getTokenToEthInputPrice(sethAmount);\r\n        uint256 outputAmount = kyber.getOutputAmount(ethToken, token, ethAmount);\r\n        return outputAmount;\r\n    }\r\n\r\n    //this will go to a DAO\r\n    function changeOwner(address newOwner) onlyOwner external returns(bool){\r\n        owner = newOwner;\r\n        return true;\r\n    }\r\n\r\n    function updateMulDivConverter1(uint256 newDiv, uint256 newMul) onlyOwner external returns(bool){\r\n        rateMultiply1 = newMul;\r\n        rateDivide1 = newDiv;\r\n        return true;\r\n    }\r\n\r\n    function updateMulDivConverter2(uint256 newDiv, uint256 newMul) onlyOwner external returns(bool){\r\n        rateMultiply2 = newMul;\r\n        rateDivide2 = newDiv;\r\n        return true;\r\n    }\r\n\r\n    function updateMulDivConverter3(uint256 newDiv, uint256 newMul) onlyOwner external returns(bool){\r\n        rateMultiply3 = newMul;\r\n        rateDivide3 = newDiv;\r\n        return true;\r\n    }\r\n\r\n    function updateMulDivConverter4(uint256 newDiv, uint256 newMul) onlyOwner external returns(bool){\r\n        rateMultiply4 = newMul;\r\n        rateDivide4 = newDiv;\r\n        return true;\r\n    }\r\n\r\n    //this will go to a DAO\r\n    function updateTokenOracleAddress(address newOracle) onlyOwner external returns(bool){\r\n        tokenPriceOracleAddress = newOracle;\r\n        return true;\r\n    }\r\n\r\n\r\n    function updateTokenOracleAddress2(address newOracle) onlyOwner external returns(bool){\r\n        tokenPriceOracleAddress2 = newOracle;\r\n        return true;\r\n    }\r\n\r\n\r\n    //this will go to a DAO\r\n    function updateForexOracleAddress(address newOracle) onlyOwner external returns(bool){\r\n        forexPriceOracleAddress = newOracle;\r\n        return true;\r\n    }\r\n\r\n\r\n    //this will go to a DAO\r\n    function updatePremiumSubOracleAddress(address newOracle) onlyOwner external returns(bool){\r\n        premiumSubPriceOracleAddress = newOracle;\r\n        return true;\r\n    }\r\n\r\n    //this will go to a DAO\r\n    function addFreeToken(string symb, address tokenAddress) onlyOwner external returns(bool){\r\n        if(freeRateTokenSymbols[symb] != 0x0){\r\n            //this token already exists\r\n            return false; \r\n        }\r\n        freeRateTokenSymbols[symb] = tokenAddress;\r\n        return true;\r\n    }\r\n\r\n    function addFreeCurrency(string symb, address tokenAddress, bytes32 byteCode) onlyOwner external returns(bool){\r\n        if(freeRateForexSymbols[symb] != 0x0){\r\n            //this token already exists\r\n            return false; \r\n        }\r\n        freeRateForexSymbols[symb] = tokenAddress;\r\n        freeRateForexBytes[symb] = byteCode;\r\n        return true;\r\n    }\r\n\r\n    function removeFreeToken(string symb) onlyOwner external returns(bool){\r\n        freeRateTokenSymbols[symb] = 0x0;\r\n        return true;\r\n    }\r\n\r\n\r\n    function removeFreeCurrency(string symb) onlyOwner external returns(bool){\r\n        freeRateForexSymbols[symb] = 0x0;\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    Below is referenced and referred to in the external contract. Mentioned here for reader to get understanding of flow\r\n\r\n    This will be set in external premium sub contract\r\n          function changePremiumSubscriptionFee(uint256 newFee) onlyOwner external returns(bool){\r\n            premiumSubscriptionFee = newFee;\r\n          }\r\n\r\n          function changePurchaseUntakenFeedFee(uint256 newFee) onlyOwner external returns(bool){\r\n            purchaseUntakenFeedFee = newFee;\r\n          }\r\n\r\n\r\n    */\r\n\r\n    //returns zero if the rate cannot be found\r\n    function getExchangeRate(string fromSymbol, string toSymbol, string venue, uint256 amount ) constant external returns (uint256){\r\n        bool isFreeFrom = isFree(fromSymbol);\r\n        bool isFreeTo = isFree(toSymbol);\r\n        bool isFreeVenue = isFreeVenueCheck(venue);\r\n        uint256 rate;\r\n\r\n        if(isFreeFrom == true && isFreeTo ==true && isFreeVenue == true){\r\n            rate = getFreeExchangeRate(fromSymbol, toSymbol, amount);\r\n            return rate;\r\n        } else {\r\n            //init.sender and msg.sender must have premium\r\n            rate = psi.getExchangeRate(fromSymbol, toSymbol, venue, amount, msg.sender);\r\n            return rate;\r\n        }\r\n    }\r\n\r\n    function compareStrings (string memory a, string memory b) public view returns (bool) {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))) );\r\n    }\r\n\r\n    function isFreeVenueCheck(string venueToCheck) returns (bool){\r\n        string memory blankString = '';\r\n        if(compareStrings(venueToCheck, blankString)){\r\n            return true;\r\n        } else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function isFree(string symToCheck) returns (bool){\r\n        if(freeRateTokenSymbols[symToCheck] != 0x0){\r\n            return true;\r\n        }\r\n        if(freeRateForexSymbols[symToCheck] != 0x0){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getFreeExchangeRate(string fromSymb, string toSymb, uint256 amount)  returns (uint256){\r\n        uint256 ethAmount;\r\n\r\n        if(freeRateTokenSymbols[fromSymb] != 0x0 && freeRateTokenSymbols[toSymb] != 0x0){\r\n            //token to token\r\n            uint256 toRate = kyber.getOutputAmount(ERC20(freeRateTokenSymbols[fromSymb]), ERC20(freeRateTokenSymbols[toSymb]), amount);\r\n            // var (toRate, slip) = ki.getExpectedRate( ERC20(freeRateTokenSymbols[fromSymb]), ERC20(freeRateTokenSymbols[toSymb]), amount);\r\n            return toRate.mul(rateMultiply1).div(rateDivide1);\r\n        } else if(freeRateTokenSymbols[fromSymb] != 0x0 && freeRateTokenSymbols[toSymb] == 0x0){\r\n            //token to forex \r\n            // var (ethAmount1, slippp) = ki.getExpectedRate(ERC20(freeRateTokenSymbols[fromSymb]),ERC20(freeRateTokenSymbols['ETH']), amount);\r\n            // uint256 ethToSynthRate = si.getOutputAmount('sETH', freeRateForexBytes[fromSymb], ethAmount1);\r\n            uint256 toRate2 =  getTokenToSynthOutputAmount ( ERC20(freeRateTokenSymbols[fromSymb]), freeRateForexBytes[toSymb], amount);\r\n            return toRate2.mul(rateMultiply2).div(rateDivide2);\r\n        } else if(freeRateTokenSymbols[fromSymb] == 0x0 && freeRateTokenSymbols[toSymb] != 0x0){\r\n            //forex to token\r\n            // uint256 sethAmount = si.getOutputAmount(freeRateForexBytes[fromSymb], 'sETH', amount);\r\n            //var (ethAmount2, slipppp) = ki.getExpectedRate(ERC20(freeRateTokenSymbols['ETH']), ERC20(freeRateTokenSymbols[toSymb]), amount);\r\n            //var(foToRate, slippppp) =  ki.getExpectedRate(ERC20(freeRateTokenSymbols['ETH']), ERC20(freeRateTokenSymbols[toSymb]), amount);\r\n            uint256 toRate3 =  getSynthToTokenOutputAmount( freeRateForexBytes[fromSymb], ERC20(freeRateTokenSymbols[toSymb]),  amount);\r\n            return toRate3.mul(rateMultiply3).div(rateDivide3);\r\n        } else if(freeRateTokenSymbols[fromSymb] == 0x0 && freeRateTokenSymbols[toSymb] == 0x0){\r\n            //forex to forex\r\n            uint256 toRate4 = se.effectiveValue(freeRateForexBytes[fromSymb], amount, freeRateForexBytes[toSymb]);\r\n            return toRate4.mul(rateMultiply4).div(rateDivide4);\r\n        } else{\r\n            return 0;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"symb\",\"type\":\"string\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"byteCode\",\"type\":\"bytes32\"}],\"name\":\"addFreeCurrency\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDiv\",\"type\":\"uint256\"},{\"name\":\"newMul\",\"type\":\"uint256\"}],\"name\":\"updateMulDivConverter2\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"synth\",\"type\":\"bytes32\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"inputAmount\",\"type\":\"uint256\"}],\"name\":\"getSynthToTokenOutputAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"symb\",\"type\":\"string\"},{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"addFreeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"updateForexOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDiv\",\"type\":\"uint256\"},{\"name\":\"newMul\",\"type\":\"uint256\"}],\"name\":\"updateMulDivConverter1\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDiv\",\"type\":\"uint256\"},{\"name\":\"newMul\",\"type\":\"uint256\"}],\"name\":\"updateMulDivConverter3\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fromSymbol\",\"type\":\"string\"},{\"name\":\"toSymbol\",\"type\":\"string\"},{\"name\":\"venue\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"symb\",\"type\":\"string\"}],\"name\":\"removeFreeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"updatePremiumSubOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"symb\",\"type\":\"string\"}],\"name\":\"removeFreeCurrency\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"venueToCheck\",\"type\":\"string\"}],\"name\":\"isFreeVenueCheck\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"symToCheck\",\"type\":\"string\"}],\"name\":\"isFree\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"string\"},{\"name\":\"b\",\"type\":\"string\"}],\"name\":\"compareStrings\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"synth\",\"type\":\"bytes32\"},{\"name\":\"inputAmount\",\"type\":\"uint256\"}],\"name\":\"getTokenToSynthOutputAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"updateTokenOracleAddress2\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromSymb\",\"type\":\"string\"},{\"name\":\"toSymb\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getFreeExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"updateTokenOracleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDiv\",\"type\":\"uint256\"},{\"name\":\"newMul\",\"type\":\"uint256\"}],\"name\":\"updateMulDivConverter4\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"orfeed","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://17b63a57d06c596ef388c2cb41cebd56b26d3ec53e4c09110651e23349d41e97"}]}