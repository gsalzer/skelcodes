{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/commons/Ownable.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\ncontract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"The owner should be the sender\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0x0), msg.sender);\r\n    }\r\n\r\n    function owner() external view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n        @dev Transfers the ownership of the contract.\r\n        @param _newOwner Address of the new owner\r\n    */\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0), \"0x0 Is not a valid owner\");\r\n        emit OwnershipTransferred(_owner, _newOwner);\r\n        _owner = _newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/Math.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\nlibrary Math {\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: contracts/commons/SortedList.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n/**\r\n * @title SortedList\r\n * @author Joaquin Gonzalez & Agustin Aguilar (jpgonzalezra@gmail.com & agusxrun@gmail.com)\r\n * @dev An utility library for using sorted list data structures.\r\n */\r\nlibrary SortedList {\r\n    using SortedList for SortedList.List;\r\n\r\n    uint256 private constant HEAD = 0;\r\n\r\n    struct List {\r\n        uint256 size;\r\n        mapping(uint256 => uint256) values;\r\n        mapping(uint256 => uint256) links;\r\n        mapping(uint256 => bool) exists;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value of a `_node`\r\n     * @param self stored linked list from contract\r\n     * @param _node a node to search value of\r\n     * @return value of the node\r\n     */\r\n    function get(List storage self, uint256 _node) internal view returns (uint256) {\r\n        return self.values[_node];\r\n    }\r\n\r\n    /**\r\n     * @dev Insert node `_node` with a value\r\n     * @param self stored linked list from contract\r\n     * @param _node new node to insert\r\n     * @param _value value of the new `_node` to insert\r\n     * @notice If the `_node` does not exists, it's added to the list\r\n     *   if the `_node` already exists, it updates its value.\r\n     */\r\n    function set(List storage self, uint256 _node, uint256 _value) internal {\r\n        // Check if node previusly existed\r\n        if (self.exists[_node]) {\r\n\r\n            // Load the new and old position\r\n            (uint256 leftOldPos, uint256 leftNewPos) = self.findOldAndNewLeftPosition(_node, _value);\r\n\r\n            // If node position changed, we need to re-do the linking\r\n            if (leftOldPos != leftNewPos && _node != leftNewPos) {\r\n                // Remove prev link\r\n                self.links[leftOldPos] = self.links[_node];\r\n\r\n                // Create new link\r\n                uint256 next = self.links[leftNewPos];\r\n                self.links[leftNewPos] = _node;\r\n                self.links[_node] = next;\r\n            }\r\n        } else {\r\n            // Update size of the list\r\n            self.size = self.size + 1;\r\n            // Set node as existing\r\n            self.exists[_node] = true;\r\n            // Find position for the new node and update the links\r\n            uint256 leftPosition = self.findLeftPosition(_value);\r\n            uint256 next = self.links[leftPosition];\r\n            self.links[leftPosition] = _node;\r\n            self.links[_node] = next;\r\n        }\r\n\r\n        // Set the value for the node\r\n        self.values[_node] = _value;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the previus node of a given `_node`\r\n     *   alongside to the previus node of a hypothetical new `_value`\r\n     * @param self stored linked list from contract\r\n     * @param _node a node to search for its left node\r\n     * @param _value a value to seach for its hypothetical left node\r\n     * @return `leftNodePost` the node previus to the given `_node` and\r\n     *   `leftValPost` the node previus to the hypothetical new `_value`\r\n     * @notice This method performs two seemingly unrelated tasks at the same time\r\n     *   because both of those tasks require a list iteration, thus saving gas.\r\n     */\r\n    function findOldAndNewLeftPosition(\r\n        List storage self,\r\n        uint256 _node,\r\n        uint256 _value\r\n    ) internal view returns (\r\n        uint256 leftNodePos,\r\n        uint256 leftValPos\r\n    ) {\r\n        // Find old and new value positions\r\n        bool foundNode;\r\n        bool foundVal;\r\n\r\n        // Iterate links\r\n        uint256 c = HEAD;\r\n        while (!foundNode || !foundVal) {\r\n            uint256 next = self.links[c];\r\n\r\n            // We should have found the old position\r\n            // the new one must be at the end\r\n            if (next == 0) {\r\n                leftValPos = c;\r\n                break;\r\n            }\r\n\r\n            // If the next node is the current node\r\n            // we found the old position\r\n            if (next == _node) {\r\n                leftNodePos = c;\r\n                foundNode = true;\r\n            }\r\n\r\n            // If the next value is higher and we didn't found one yet\r\n            // the next value if the position\r\n            if (self.values[next] > _value && !foundVal) {\r\n                leftValPos = c;\r\n                foundVal = true;\r\n            }\r\n\r\n            c = next;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get the left node for a given hypothetical `_value`\r\n     * @param self stored linked list from contract\r\n     * @param _value value to seek\r\n     * @return uint256 left node for the given value\r\n     */\r\n    function findLeftPosition(List storage self, uint256 _value) internal view returns (uint256) {\r\n        uint256 next = HEAD;\r\n        uint256 c;\r\n\r\n        do {\r\n            c = next;\r\n            next = self.links[c];\r\n        } while(self.values[next] < _value && next != 0);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the node on a given `_position`\r\n     * @param self stored linked list from contract\r\n     * @param _position node position to retrieve\r\n     * @return the node key\r\n     */\r\n    function nodeAt(List storage self, uint256 _position) internal view returns (uint256) {\r\n        uint256 next = self.links[HEAD];\r\n        for (uint256 i = 0; i < _position; i++) {\r\n            next = self.links[next];\r\n        }\r\n\r\n        return next;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an entry from the sorted list\r\n     * @param self stored linked list from contract\r\n     * @param _node node to remove from the list\r\n     */\r\n    function remove(List storage self, uint256 _node) internal {\r\n        require(self.exists[_node], \"the node does not exists\");\r\n\r\n        uint256 c = self.links[HEAD];\r\n        while (c != 0) {\r\n            uint256 next = self.links[c];\r\n            if (next == _node) {\r\n                break;\r\n            }\r\n\r\n            c = next;\r\n        }\r\n\r\n        self.size -= 1;\r\n        self.exists[_node] = false;\r\n        self.links[c] = self.links[_node];\r\n        delete self.links[_node];\r\n        delete self.values[_node];\r\n    }\r\n\r\n    /**\r\n     * @dev Get median beetween entry from the sorted list\r\n     * @param self stored linked list from contract\r\n     * @return uint256 the median\r\n     */\r\n    function median(List storage self) internal view returns (uint256) {\r\n        uint256 elements = self.size;\r\n        if (elements % 2 == 0) {\r\n            uint256 node = self.nodeAt(elements / 2 - 1);\r\n            return Math.average(self.values[node], self.values[self.links[node]]);\r\n        } else {\r\n            return self.values[self.nodeAt(elements / 2)];\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/RateOracle.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n/**\r\n    @dev Defines the interface of a standard Diaspore RCN Oracle,\r\n    The contract should also implement it's ERC165 interface: 0xa265d8e0\r\n    @notice Each oracle can only support one currency\r\n    @author Agustin Aguilar\r\n*/\r\ncontract RateOracle {\r\n    uint256 public constant VERSION = 5;\r\n    bytes4 internal constant RATE_ORACLE_INTERFACE = 0xa265d8e0;\r\n\r\n    /**\r\n        3 or 4 letters symbol of the currency, Ej: ETH\r\n    */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n        Descriptive name of the currency, Ej: Ethereum\r\n    */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n        The number of decimals of the currency represented by this Oracle,\r\n            it should be the most common number of decimal places\r\n    */\r\n    function decimals() external view returns (uint256);\r\n\r\n    /**\r\n        The base token on which the sample is returned\r\n            should be the RCN Token address.\r\n    */\r\n    function token() external view returns (address);\r\n\r\n    /**\r\n        The currency symbol encoded on a UTF-8 Hex\r\n    */\r\n    function currency() external view returns (bytes32);\r\n\r\n    /**\r\n        The name of the Individual or Company in charge of this Oracle\r\n    */\r\n    function maintainer() external view returns (string memory);\r\n\r\n    /**\r\n        Returns the url where the oracle exposes a valid \"oracleData\" if needed\r\n    */\r\n    function url() external view returns (string memory);\r\n\r\n    /**\r\n        Returns a sample on how many token() are equals to how many currency()\r\n    */\r\n    function readSample(bytes calldata _data) external view returns (uint256 _tokens, uint256 _equivalent);\r\n}\r\n\r\n// File: contracts/interfaces/PausedProvider.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\ninterface PausedProvider {\r\n    function isPaused() external view returns (bool);\r\n}\r\n\r\n// File: contracts/commons/Pausable.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\ncontract Pausable is Ownable {\r\n    mapping(address => bool) public canPause;\r\n    bool public paused;\r\n\r\n    event Paused();\r\n    event Started();\r\n    event CanPause(address _pauser, bool _enabled);\r\n\r\n    function setPauser(address _pauser, bool _enabled) external onlyOwner {\r\n        canPause[_pauser] = _enabled;\r\n        emit CanPause(_pauser, _enabled);\r\n    }\r\n\r\n    function pause() external {\r\n        require(!paused, \"already paused\");\r\n\r\n        require(\r\n            msg.sender == _owner ||\r\n            canPause[msg.sender],\r\n            \"not authorized to pause\"\r\n        );\r\n\r\n        paused = true;\r\n        emit Paused();\r\n    }\r\n\r\n    function start() external onlyOwner {\r\n        require(paused, \"not paused\");\r\n        paused = false;\r\n        emit Started();\r\n    }\r\n}\r\n\r\n// File: contracts/utils/StringUtils.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\nlibrary StringUtils {\r\n    function toBytes32(string memory _a) internal pure returns (bytes32 b) {\r\n        require(bytes(_a).length <= 32, \"string too long\");\r\n\r\n        assembly {\r\n            let bi := mul(mload(_a), 8)\r\n            b := and(mload(add(_a, 32)), shl(sub(256, bi), sub(exp(2, bi), 1)))\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/MultiSourceOracle.sol\r\n\r\npragma solidity ^0.5.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MultiSourceOracle is RateOracle, Ownable, Pausable {\r\n    using SortedList for SortedList.List;\r\n    using StringUtils for string;\r\n\r\n    uint256 public constant BASE = 10 ** 36;\r\n\r\n    mapping(address => bool) public isSigner;\r\n    mapping(address => string) public nameOfSigner;\r\n    mapping(string => address) public signerWithName;\r\n\r\n    SortedList.List private list;\r\n    RateOracle public upgrade;\r\n    PausedProvider public pausedProvider;\r\n\r\n    string private isymbol;\r\n    string private iname;\r\n    uint256 private idecimals;\r\n    address private itoken;\r\n    bytes32 private icurrency;\r\n    string private imaintainer;\r\n\r\n    constructor(\r\n        string memory _symbol,\r\n        string memory _name,\r\n        uint256 _decimals,\r\n        address _token,\r\n        string memory _maintainer\r\n    ) public {\r\n        // Create legacy bytes32 currency\r\n        bytes32 currency = _symbol.toBytes32();\r\n        // Save Oracle metadata\r\n        isymbol = _symbol;\r\n        iname = _name;\r\n        idecimals = _decimals;\r\n        itoken = _token;\r\n        icurrency = currency;\r\n        imaintainer = _maintainer;\r\n        pausedProvider = PausedProvider(msg.sender);\r\n    }\r\n\r\n    function providedBy(address _signer) external view returns (uint256) {\r\n        return list.get(uint256(_signer));\r\n    }\r\n\r\n    /**\r\n     * @return metadata, 3 or 4 letter symbol of the currency provided by this oracle\r\n     *   (ej: ARS)\r\n     * @notice Defined by the RCN RateOracle interface\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return isymbol;\r\n    }\r\n\r\n    /**\r\n     * @return metadata, full name of the currency provided by this oracle\r\n     *   (ej: Argentine Peso)\r\n     * @notice Defined by the RCN RateOracle interface\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return iname;\r\n    }\r\n\r\n    /**\r\n     * @return metadata, decimals to express the common denomination\r\n     *   of the currency provided by this oracle\r\n     * @notice Defined by the RCN RateOracle interface\r\n     */\r\n    function decimals() external view returns (uint256) {\r\n        return idecimals;\r\n    }\r\n\r\n    /**\r\n     * @return metadata, token address of the currency provided by this oracle\r\n     * @notice Defined by the RCN RateOracle interface\r\n     */\r\n    function token() external view returns (address) {\r\n        return itoken;\r\n    }\r\n\r\n    /**\r\n     * @return metadata, bytes32 code of the currency provided by this oracle\r\n     * @notice Defined by the RCN RateOracle interface\r\n     */\r\n    function currency() external view returns (bytes32) {\r\n        return icurrency;\r\n    }\r\n\r\n    /**\r\n     * @return metadata, human readable name of the entity maintainer of this oracle\r\n     * @notice Defined by the RCN RateOracle interface\r\n     */\r\n    function maintainer() external view returns (string memory) {\r\n        return imaintainer;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the URL required to retrieve the auxiliary data\r\n     *   as specified by the RateOracle spec, no auxiliary data is required\r\n     *   so it returns an empty string.\r\n     * @return An empty string, because the auxiliary data is not required\r\n     * @notice Defined by the RCN RateOracle interface\r\n     */\r\n    function url() external view returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the medatada of the oracle\r\n     * @param _name Name of the oracle currency\r\n     * @param _decimals Decimals for the common representation of the currency\r\n     * @param _maintainer Name of the maintainer entity of the Oracle\r\n     */\r\n    function setMetadata(\r\n        string calldata _name,\r\n        uint256 _decimals,\r\n        string calldata _maintainer\r\n    ) external onlyOwner {\r\n        iname = _name;\r\n        idecimals = _decimals;\r\n        imaintainer = _maintainer;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the Oracle contract, all subsequent calls to `readSample` will be forwareded to `_upgrade`\r\n     * @param _upgrade Contract address of the new updated oracle\r\n     * @notice If the `upgrade` address is set to the address `0` the Oracle is considered not upgraded\r\n     */\r\n    function setUpgrade(RateOracle _upgrade) external onlyOwner {\r\n        upgrade = _upgrade;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a `_signer` who is going to be able to provide a new rate\r\n     * @param _signer Address of the signer\r\n     * @param _name Metadata - Human readable name of the signer\r\n     */\r\n    function addSigner(address _signer, string calldata _name) external onlyOwner {\r\n        require(!isSigner[_signer], \"signer already defined\");\r\n        require(signerWithName[_name] == address(0), \"name already in use\");\r\n        require(bytes(_name).length > 0, \"name can't be empty\");\r\n        isSigner[_signer] = true;\r\n        signerWithName[_name] = _signer;\r\n        nameOfSigner[_signer] = _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the `_name` metadata of a given `_signer`\r\n     * @param _signer Address of the signer\r\n     * @param _name Metadata - Human readable name of the signer\r\n     */\r\n    function setName(address _signer, string calldata _name) external onlyOwner {\r\n        require(isSigner[_signer], \"signer not defined\");\r\n        require(signerWithName[_name] == address(0), \"name already in use\");\r\n        require(bytes(_name).length > 0, \"name can't be empty\");\r\n        string memory oldName = nameOfSigner[_signer];\r\n        signerWithName[oldName] = address(0);\r\n        signerWithName[_name] = _signer;\r\n        nameOfSigner[_signer] = _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes an existing `_signer`, removing any provided rate\r\n     * @param _signer Address of the signer\r\n     */\r\n    function removeSigner(address _signer) external onlyOwner {\r\n        require(isSigner[_signer], \"address is not a signer\");\r\n        string memory signerName = nameOfSigner[_signer];\r\n\r\n        isSigner[_signer] = false;\r\n        signerWithName[signerName] = address(0);\r\n        nameOfSigner[_signer] = \"\";\r\n\r\n        // Only remove from list if it provided a value\r\n        if (list.exists[uint256(_signer)]) {\r\n            list.remove(uint256(_signer));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Provides a `_rate` for a given `_signer`\r\n     * @param _signer Address of the signer who is providing the rate\r\n     * @param _rate Rate to be provided\r\n     * @notice This method can only be called by the Owner and not by the signer\r\n     *   this is intended to allow the `OracleFactory.sol` to provide multiple rates\r\n     *   on a single call. The `OracleFactory.sol` contract has the responsability of\r\n     *   validating the signer address.\r\n     */\r\n    function provide(address _signer, uint256 _rate) external onlyOwner {\r\n        require(isSigner[_signer], \"signer not valid\");\r\n        require(_rate != 0, \"rate can't be zero\");\r\n        list.set(uint256(_signer), _rate);\r\n    }\r\n\r\n    /**\r\n     * @dev Reads the rate provided by the Oracle\r\n     *   this being the median of the last rate provided by each signer\r\n     * @param _oracleData Oracle auxiliar data defined in the RCN Oracle spec\r\n     *   not used for this oracle, but forwarded in case of upgrade.\r\n     * @return `_equivalent` is the median of the values provided by the signer\r\n     *   `_tokens` are equivalent to `_equivalent` in the currency of the Oracle\r\n     */\r\n    function readSample(bytes memory _oracleData) public view returns (uint256 _tokens, uint256 _equivalent) {\r\n        // Check if paused\r\n        require(!paused && !pausedProvider.isPaused(), \"contract paused\");\r\n\r\n        // Check if Oracle contract has been upgraded\r\n        RateOracle _upgrade = upgrade;\r\n        if (address(_upgrade) != address(0)) {\r\n            return _upgrade.readSample(_oracleData);\r\n        }\r\n\r\n        // Tokens is always base\r\n        _tokens = BASE;\r\n        _equivalent = list.median();\r\n    }\r\n\r\n    /**\r\n     * @dev Reads the rate provided by the Oracle\r\n     *   this being the median of the last rate provided by each signer\r\n     * @return `_equivalent` is the median of the values provided by the signer\r\n     *   `_tokens` are equivalent to `_equivalent` in the currency of the Oracle\r\n     * @notice This Oracle accepts reading the sample without auxiliary data\r\n     */\r\n    function readSample() external view returns (uint256 _tokens, uint256 _equivalent) {\r\n        (_tokens, _equivalent) = readSample(new bytes(0));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_maintainer\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_pauser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"CanPause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Started\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"addSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canPause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currency\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maintainer\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nameOfSigner\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pausedProvider\",\"outputs\":[{\"internalType\":\"contract PausedProvider\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"provide\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"providedBy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_oracleData\",\"type\":\"bytes\"}],\"name\":\"readSample\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_equivalent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"readSample\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_equivalent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"removeSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_maintainer\",\"type\":\"string\"}],\"name\":\"setMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pauser\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract RateOracle\",\"name\":\"_upgrade\",\"type\":\"address\"}],\"name\":\"setUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"signerWithName\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[{\"internalType\":\"contract RateOracle\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"url\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MultiSourceOracle","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000355534400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014556e697465642053746174657320646f6c6c61720000000000000000000000000000000000000000000000000000000000000000000000000000000000000011506f6f6c206f662070726f766964657273000000000000000000000000000000","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://790c169e81810dd0030bfd48db011d7270ecd0cd65db937d74ddea345d8f395b"}]}