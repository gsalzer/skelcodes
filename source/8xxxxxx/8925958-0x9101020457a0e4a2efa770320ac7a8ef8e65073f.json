{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\n\npragma solidity ^0.5.0;\n\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * > Note that this information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * `IERC20.balanceOf` and `IERC20.transfer`.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.5.0;\n\n\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n\n// File: contracts/interfaces/ITransferManager.sol\n\npragma solidity ^0.5.12;\n\n/**\n* @title Base transfer manager interface\n*/\ninterface ITransferManager {\n\n    /**\n    * @notice Checks whether transfer approved or not\n    * @param _spender Address of the spender\n    * @param _from The address to transfer from\n    * @param _to The address to transfer to\n    * @param _amount Amount of tokens for the transfer\n    */\n    function isApproved(address _spender, address _from, address _to, uint256 _amount) external returns (bool);\n\n}\n\n// File: contracts/libraries/AddressList.sol\n\npragma solidity ^0.5.12;\n\n/**\n * @title Util for working with an array of addresses\n * @dev lib doesn't throw errors for already added or not found addresses\n * @dev see tests for WhitelistTransferManager\n */\nlibrary AddressList {\n\n    string private constant ERROR_INVALID_ADDRESS = \"Invalid address\";\n\n    struct Data {\n        bool added;\n        uint248 index;\n    }\n\n    /**\n    * @notice Adds the address to the given list\n    * @param _address Address to be added\n    * @param _data Mapping of AddressData\n    * @param _list Array of addresses\n    */\n    function addTo(\n        address _address,\n        mapping(address => Data) storage _data,\n        address[] storage _list\n    )\n        internal\n    {\n        require(_address != address(0), ERROR_INVALID_ADDRESS);\n\n        if (!_data[_address].added) {\n            _data[_address] = Data({\n                added: true,\n                index: uint248(_list.length)\n                });\n            _list.push(_address);\n        }\n    }\n\n    /**\n    * @notice Removes the address from the given list\n    * @param _address Address to be removed\n    * @param _data Mapping of AddressData\n    * @param _list Array of addresses\n    */\n    function removeFrom(\n        address _address,\n        mapping(address => Data) storage _data,\n        address[] storage _list\n    )\n        internal\n    {\n        require(_address != address(0), ERROR_INVALID_ADDRESS);\n\n        if (_data[_address].added) {\n            uint248 index = _data[_address].index;\n            if (index != _list.length - 1) {\n                _list[index] = _list[_list.length - 1];\n                _data[_list[index]].index = index;\n            }\n            _list.length--;\n            delete _data[_address];\n        }\n    }\n\n}\n\n// File: openzeppelin-solidity/contracts/access/Roles.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/interfaces/IPermissionManager.sol\n\npragma solidity ^0.5.12;\n\n/**\n* @title Permission manager\n*/\ninterface IPermissionManager {\n\n    function hasRole(address _user, bytes32 _role) external view returns (bool);\n\n    function hasRoles(address _user, bytes32[] calldata _roles) external view returns (bool);\n\n    function addRole(address _user, bytes32 _role) external;\n\n    function removeRole(address _user, bytes32 _role) external;\n\n    function getRoles() external returns (bytes32[] memory);\n\n}\n\n// File: contracts/role/AllowableStorage.sol\n\npragma solidity ^0.5.12;\n\n\n/**\n * @title Storage for Allowable\n */\ncontract AllowableStorage {\n\n    string internal constant ERROR_ACCESS_DENIED = \"Access is denied\";\n    string internal constant ERROR_INVALID_ADDRESS = \"Invalid address\";\n    string internal constant ERROR_IS_NOT_ALLOWED = \"Is not allowed\";\n    string internal constant ERROR_ROLE_NOT_FOUND = \"Role not found\";\n    string internal constant ERROR_STOPPED = \"Contract is stopped\";\n    string internal constant ERROR_NOT_STOPPED = \"Contract is not stopped\";\n\n    string internal constant ERROR_ACTION_WAS_NOT_REQUESTED = \"Action wasn't requested\";\n    string internal constant ERROR_ACTION_WAS_REQUESTED_BY_SENDER = \"Action was requested by a sender\";\n\n    address _owner = address(0x00);\n\n    //list of the system roles\n    bytes32[] roleNames;\n\n    //map of users for the given role\n    mapping(bytes32 => mapping(address => AddressList.Data)) roleUserData;\n    //list of users for the given role\n    mapping(bytes32 => address[]) roleUsers;\n\n    //attached permission manager\n    address permissionManager = address(0x00);\n\n    //Initially, roles can be added without an approval\n    bool roleApproval = false;\n\n    bool transferOwnershipApproval = false;\n\n    bool stopped = false;\n\n    //newOwner => initiator\n    mapping(address => address) transferOwnershipInitiator;\n\n    //user => role => initiator\n    mapping(address => mapping(bytes32 => address)) addRoleInitiators;\n\n    //user => role => initiator\n    mapping(address => mapping(bytes32 => address)) removeRoleInitiators;\n\n    //List of admin roles\n    bytes32[] adminRoles;\n\n    address stopInitiator = address(0x00);\n\n    address startInitiator = address(0x00);\n\n    address configurator = address(0x00);\n\n}\n\n// File: contracts/libraries/linked/AllowableLib.sol\n\npragma solidity ^0.5.12;\n\n\nlibrary AllowableLib {\n    using AddressList for address;\n\n    string internal constant ERROR_ROLE_NOT_FOUND = \"Role not found\";\n\n    string internal constant ERROR_ACCESS_DENIED = \"Access is denied\";\n    string internal constant ERROR_ACTION_WAS_NOT_REQUESTED = \"Action wasn't requested\";\n    string internal constant ERROR_ACTION_WAS_REQUESTED_BY_SENDER = \"Action was requested by a sender\";\n\n    event RoleAdded(address indexed _user, bytes32 _role);\n    event RoleRemoved(address indexed _user, bytes32 _role);\n\n    event RoleAddingRequested(address indexed _user, bytes32 _role);\n    event RoleRemovingRequested(address indexed _user, bytes32 _role);\n\n    /**\n    * @notice Adds given role to the user\n    * @param _user Address of user wallet\n    * @param _role Role name\n    * param _withApproval Flag whether we need an approval\n    */\n    function addRole(\n        address _user,\n        bytes32 _role,\n        bool _withApproval,\n        bool _withSameRole,\n        bytes32[] storage roleNames,\n        mapping(bytes32 => mapping(address => AddressList.Data)) storage roleUserData,\n        mapping(bytes32 => address[]) storage roleUsers,\n        mapping(address => mapping(bytes32 => address)) storage addRoleInitiators\n    )\n        public\n    {\n        if (_withApproval) {\n            _checkRoleLevel(_role, _withSameRole, roleUserData);\n            _checkInitiator(addRoleInitiators[_user][_role]);\n        }\n        require(isExists(_role, roleNames), ERROR_ROLE_NOT_FOUND);\n        _user.addTo(roleUserData[_role], roleUsers[_role]);\n        emit RoleAdded(_user, _role);\n        if (_withApproval) {\n            delete addRoleInitiators[_user][_role];\n        }\n    }\n\n    /**\n    * @notice Requests to add given role to the user\n    * @param _user Address of user wallet\n    * @param _role Role name\n    */\n    function addRoleRequest(\n        address _user,\n        bytes32 _role,\n        bool _withSameRole,\n        mapping(bytes32 => mapping(address => AddressList.Data)) storage roleUserData,\n        mapping(address => mapping(bytes32 => address)) storage addRoleInitiators\n    )\n        public\n    {\n        _checkRoleLevel(_role, _withSameRole, roleUserData);\n        addRoleInitiators[_user][_role] = msg.sender;\n        emit RoleAddingRequested(_user, _role);\n    }\n\n    /**\n    * @notice Removes given role from the user\n    * @param _user Address of user wallet\n    * @param _role Role name\n    */\n    function removeRole(\n        address _user,\n        bytes32 _role,\n        bool _withApproval,\n        bool _withSameRole,\n        bytes32[] storage roleNames,\n        mapping(bytes32 => mapping(address => AddressList.Data)) storage roleUserData,\n        mapping(bytes32 => address[]) storage roleUsers,\n        mapping(address => mapping(bytes32 => address)) storage removeRoleInitiators\n    )\n        public\n    {\n        if (_withApproval) {\n            _checkRoleLevel(_role, _withSameRole, roleUserData);\n            _checkInitiator(removeRoleInitiators[_user][_role]);\n        }\n        require(isExists(_role, roleNames), ERROR_ROLE_NOT_FOUND);\n        _user.removeFrom(roleUserData[_role], roleUsers[_role]);\n        emit RoleRemoved(_user, _role);\n        if (_withApproval) {\n            delete removeRoleInitiators[_user][_role];\n        }\n    }\n\n    /**\n    * @notice Requests to remove given role to the user\n    * @param _user Address of user wallet\n    * @param _role Role name\n    */\n    function removeRoleRequest(\n        address _user,\n        bytes32 _role,\n        bool _withSameRole,\n        mapping(bytes32 => mapping(address => AddressList.Data)) storage roleUserData,\n        mapping(address => mapping(bytes32 => address)) storage removeRoleInitiators\n    )\n        public\n    {\n        _checkRoleLevel(_role, _withSameRole, roleUserData);\n        removeRoleInitiators[_user][_role] = msg.sender;\n        emit RoleRemovingRequested(_user, _role);\n    }\n\n    /**\n    * @notice Adds given role to the supported role list\n    * @param _role Role name\n    */\n    function addSystemRole(\n        bytes32 _role,\n        bytes32[] storage roleNames\n    )\n        public\n    {\n        if (!isExists(_role, roleNames)) {\n            roleNames.push(_role);\n        }\n    }\n\n    /**\n    * @notice Checks whether the role has been already added\n    * @param _role Role name\n    */\n    function isExists(\n        bytes32 _role,\n        bytes32[] storage roleNames\n    )\n        private\n        view\n        returns (bool)\n    {\n        for (uint i = 0; i < roleNames.length; i++) {\n            if (_role == roleNames[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n    * @notice Checks whether the message sender has the same role\n    * @param _role Role to be added\n    * @param _withSameRole A flag whether we need to do role level check\n    */\n    function _checkRoleLevel(\n        bytes32 _role,\n        bool _withSameRole,\n        mapping(bytes32 => mapping(address => AddressList.Data)) storage roleUserData\n    )\n        internal\n        view\n    {\n        if (_withSameRole) {\n            require(roleUserData[_role][msg.sender].added, ERROR_ACCESS_DENIED);\n        }\n    }\n\n    /**\n    * @notice Validates initiator address\n    * @param _initiator Address of the action initiator\n    * @dev Checks whether an action was requested and by different address\n    */\n    function _checkInitiator(address _initiator) internal view {\n        require(_initiator != address(0), ERROR_ACTION_WAS_NOT_REQUESTED);\n        require(_initiator != msg.sender, ERROR_ACTION_WAS_REQUESTED_BY_SENDER);\n    }\n\n}\n\n// File: contracts/role/AllowableModifiers.sol\n\npragma solidity ^0.5.12;\n\n\n\n\n\n\n\n/**\n * @title Allowable Modifiers\n * @dev Provides role-based access control\n */\ncontract AllowableModifiers is AllowableStorage  {\n    using AddressList for address;\n\n    bytes32 internal constant ROLE_INVENIAM_ADMIN = \"INVENIAM_ADMIN\";\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner(), ERROR_ACCESS_DENIED);\n        _;\n    }\n\n    modifier onlyRole(bytes32 _role) {\n        require(_hasRole(msg.sender, _role), ERROR_ACCESS_DENIED);\n        _;\n    }\n\n    modifier onlyRoleStrict(bytes32 _role) {\n        require(_hasRoleStrict(msg.sender, _role), ERROR_ACCESS_DENIED);\n        _;\n    }\n\n    modifier onlyRoles(bytes32[] memory _roles) {\n        require(_hasRoles(msg.sender, _roles), ERROR_ACCESS_DENIED);\n        _;\n    }\n\n    modifier onlyAdmin {\n        require(_hasRoles(msg.sender, adminRoles), ERROR_ACCESS_DENIED);\n        _;\n    }\n\n    modifier notStopped() {\n        require(!stopped, ERROR_STOPPED);\n        _;\n    }\n\n    modifier isStopped() {\n        require(stopped, ERROR_NOT_STOPPED);\n        _;\n    }\n\n    /**\n    * @notice Checks whether the user has an appropriate role or an owner\n    * @param _user Address of user wallet\n    * @param _role Role name\n    */\n    function _hasRole(address _user, bytes32 _role) internal view returns (bool) {\n        return isOwner() || _hasRoleStrict(_user, _role);\n    }\n\n    /**\n    * @notice Checks whether the user has an appropriate role\n    * @param _user Address of user wallet\n    * @param _role Role name\n    */\n    function _hasRoleStrict(address _user, bytes32 _role) internal view returns (bool) {\n        return roleUserData[_role][_user].added\n        || (permissionManager != address(0) && IPermissionManager(permissionManager).hasRole(_user, _role));\n    }\n\n    /**\n    * @notice Checks whether the user has at least one role from the given list or an owner\n    * @param _user Address of user wallet\n    * @param _roles Array of role names\n    */\n    function _hasRoles(address _user, bytes32[] memory _roles) internal view returns (bool) {\n        if (isOwner()) {\n            return true;\n        }\n        return _hasLocalRoles(_user, _roles)\n        || (permissionManager != address(0) && IPermissionManager(permissionManager).hasRoles(_user, _roles));\n    }\n\n    /**\n    * @notice Checks whether the user has at least one role from the given list (current contract storage)\n    * @param _user Address of user wallet\n    * @param _roles Array of role names\n    */\n    function _hasLocalRoles(address _user, bytes32[] memory _roles) internal view returns (bool) {\n        for (uint i = 0; i < _roles.length; i++) {\n            bytes32 role = _roles[i];\n            if (roleUserData[role][_user].added) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n\n// File: contracts/proxy/FunctionProxy.sol\n\npragma solidity ^0.5.12;\n\n/**\n* @title Base Proxy for delegate function calls\n*/\ncontract FunctionProxy {\n\n    string private constant ERROR_IMPLEMENTATION_NOT_FOUND = \"Implementation not found\";\n\n    /**\n    * @dev Returns an address of the implementation.\n    */\n    function _getImplementation() internal view returns (address) {\n        return address(0);\n    }\n\n    /**\n     * @dev Fallback function allowing to perform a delegatecall\n     * Returns whatever the implementation call returns\n     */\n    function () external {\n        address implementation = _getImplementation();\n        require(implementation != address(0), ERROR_IMPLEMENTATION_NOT_FOUND);\n\n        assembly {\n            let pointer := mload(0x40)\n            calldatacopy(pointer, 0, calldatasize)\n            let result := delegatecall(gas, implementation, pointer, calldatasize, 0, 0)\n            let size := returndatasize\n            returndatacopy(pointer, 0, size)\n\n            switch result\n            case 0 { revert(pointer, size) }\n            default { return(pointer, size) }\n        }\n    }\n\n}\n\n// File: contracts/role/Allowable.sol\n\npragma solidity ^0.5.12;\n\n\n\n\n\n\n\n\n/**\n * @title Allowable\n * @dev Provides role-based access control\n */\ncontract Allowable is AllowableModifiers, FunctionProxy {\n    using AddressList for address;\n\n    bytes32 private constant ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN = \"INDIVIDUAL_ISSUE_TOKEN_ADMIN\";\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    event RoleAdded(address indexed _user, bytes32 _role);\n    event RoleRemoved(address indexed _user, bytes32 _role);\n\n    event RoleAddingRequested(address indexed _user, bytes32 _role);\n    event RoleRemovingRequested(address indexed _user, bytes32 _role);\n\n    function initRoleApproval() public {\n        roleApproval = true;\n    }\n\n    /**\n    * @notice Adds given role to the supported role list\n    * @param _role Role name\n    */\n    function _addSystemRole(bytes32 _role) internal {\n        AllowableLib.addSystemRole(_role, roleNames);\n    }\n\n    /**\n    * @notice Adds given role to the user\n    * @param _user Address of user wallet\n    * @param _role Role name\n    */\n    function addRole(address _user, bytes32 _role) public notStopped onlyAdmin {\n        _addRole(_user, _role);\n    }\n\n    /**\n    * @notice Adds given role to the users\n    * @param _users List of Addresses\n    * @param _role Role name\n    */\n    function addRoles(address[] memory _users, bytes32 _role) public notStopped onlyAdmin {\n        for (uint i = 0; i < _users.length; i++) {\n            _addRole(_users[i], _role);\n        }\n    }\n\n    /**\n    * @notice Adds given role to the user\n    * @param _user Address of user wallet\n    * @param _role Role name\n    */\n    function _addRole(address _user, bytes32 _role) private {\n        bool withApproval = _addRoleWithApproval(_user, _role);\n        bool withSameRole = _withSameRole(_role);\n        AllowableLib.addRole(_user, _role, withApproval, withSameRole, roleNames, roleUserData, roleUsers, addRoleInitiators);\n    }\n\n    /**\n    * @notice Requests to add given role to the user\n    * @param _user Address of user wallet\n    * @param _role Role name\n    */\n    function addRoleRequest(address _user, bytes32 _role) public notStopped onlyAdmin {\n        _addRoleRequest(_user, _role);\n    }\n\n    /**\n    * @notice Requests to add given role to the user\n    * @param _user Address of user wallet\n    * @param _role Role name\n    */\n    function _addRoleRequest(address _user, bytes32 _role) private {\n        bool withSameRole = _withSameRole(_role);\n        AllowableLib.addRoleRequest(_user, _role, withSameRole, roleUserData, addRoleInitiators);\n    }\n\n    /**\n    * @notice Removes given role from the user\n    * @param _user Address of user wallet\n    * @param _role Role name\n    */\n    function removeRole(address _user, bytes32 _role) public notStopped onlyAdmin {\n        _removeRole(_user, _role);\n    }\n\n    /**\n    * @notice Removes given role from the user\n    * @param _user Address of user wallet\n    * @param _role Role name\n    */\n    function _removeRole(address _user, bytes32 _role) private {\n        bool withApproval = _removeRoleWithApproval(_user, _role);\n        bool withSameRole = _withSameRole(_role);\n        AllowableLib.removeRole(_user, _role, withApproval, withSameRole, roleNames, roleUserData, roleUsers, removeRoleInitiators);\n    }\n\n    /**\n    * @notice Requests to remove given role to the user\n    * @param _user Address of user wallet\n    * @param _role Role name\n    */\n    function removeRoleRequest(address _user, bytes32 _role) public notStopped onlyAdmin {\n        _removeRoleRequest(_user, _role);\n    }\n\n    /**\n    * @notice Requests to remove given role to the user\n    * @param _user Address of user wallet\n    * @param _role Role name\n    */\n    function _removeRoleRequest(address _user, bytes32 _role) private {\n        bool withSameRole = _withSameRole(_role);\n        AllowableLib.removeRoleRequest(_user, _role, withSameRole, roleUserData, removeRoleInitiators);\n    }\n\n    /**\n    * @notice Returns whether adding role should be approved by user with the same role\n    */\n    function _withSameRole(bytes32 _role) private pure returns (bool) {\n        return _role == ROLE_INVENIAM_ADMIN;\n    }\n\n    /**\n    * @notice Returns whether adding role should be approved\n    * @dev Approval makes sense if we have at least one admin\n    */\n    function _addRoleWithApproval(address /*_user*/, bytes32 /*_role*/) internal view returns (bool) {\n        return roleApproval && _getAdminCount() > 0;\n    }\n\n    /**\n    * @notice Returns whether removing role should be approved\n    * @dev Approval makes sense if we have at least one admin (after removal)\n    */\n    function _removeRoleWithApproval(address /*_user*/, bytes32 _role) internal view returns (bool) {\n        uint adminCount = _getAdminCount();\n        //if role to be removed is an admin role, we won't use it for an approval\n        if (_role == adminRoles[0] || _role == adminRoles[1]) {\n            adminCount--;\n        }\n        return roleApproval && adminCount > 0;\n    }\n\n    /**\n    * @notice Calculates the number of current admins\n    * @dev Supposes that we have only 2 levels of admin roles\n    */\n    function _getAdminCount() private view returns (uint) {\n        uint adminCount;\n        if (adminRoles.length == 2) {\n            adminCount = roleUsers[adminRoles[0]].length + roleUsers[adminRoles[1]].length;\n        }\n        return adminCount;\n    }\n\n    /**\n    * @notice Gets list of the system roles\n    */\n    function getRoles() public view returns (bytes32[] memory) {\n        return roleNames;\n    }\n\n    /**\n    * @notice Gets users which have the given role\n    * @param _role Role name\n    */\n    function getUsersByRole(bytes32 _role) public view returns (address[] memory) {\n        return roleUsers[_role];\n    }\n\n    /**\n     * @dev Sets permission manager\n     * @param _permissionManager Address of the permission manager\n     */\n    function setPermissionManager(address _permissionManager) public notStopped onlyAdmin {\n        _setPermissionManager(_permissionManager);\n    }\n\n    function _setPermissionManager(address _permissionManager) private {\n        permissionManager = _permissionManager;\n    }\n\n    /**\n    * @notice Returns permission manager\n    */\n    function getPermissionManager() public view returns (address) {\n        return permissionManager;\n    }\n\n    /**\n     * @notice Allows the current owner to transfer control of the contract to a newOwner.\n     * @dev Only first transfer should be without an approval\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public notStopped onlyOwner {\n        if (transferOwnershipApproval) {\n            transferOwnershipInitiator[newOwner] = msg.sender;\n        } else {\n            transferOwnershipApproval = true;\n            _transferOwnership(newOwner);\n        }\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) private {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /**\n     * @notice Approve transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function approveTransferOwnership(address newOwner) public notStopped onlyRoleStrict(ROLE_INVENIAM_ADMIN) {\n        _checkInitiator(transferOwnershipInitiator[newOwner]);\n        _transferOwnership(newOwner);\n        delete transferOwnershipInitiator[newOwner];\n    }\n\n    /**\n     * @notice Request stop of a contract\n     */\n    function stopRequest() public notStopped onlyRole(ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN) {\n        stopInitiator = msg.sender;\n    }\n\n    /**\n     * @notice Stops a contract\n     * @dev All transactions (except startRequest and start) will be reverted\n     */\n    function stop() public notStopped onlyRoleStrict(ROLE_INVENIAM_ADMIN) {\n        _checkInitiator(stopInitiator);\n        stopped = true;\n        delete stopInitiator;\n    }\n\n    /**\n     * @notice Request start of a contract\n     * @dev Can be executed only for stopped contracts\n     */\n    function startRequest() public isStopped onlyRole(ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN) {\n        startInitiator = msg.sender;\n    }\n\n    /**\n     * @notice Starts a contract\n     * @dev Can be executed only for stopped contracts\n     */\n    function start() public isStopped onlyRoleStrict(ROLE_INVENIAM_ADMIN) {\n        _checkInitiator(startInitiator);\n        stopped = false;\n        delete startInitiator;\n    }\n\n    /**\n    * @notice Validates initiator address\n    * @param _initiator Address of the action initiator\n    * @dev Checks whether an action was requested and by different address\n    */\n    function _checkInitiator(address _initiator) private view {\n        require(_initiator != address(0), ERROR_ACTION_WAS_NOT_REQUESTED);\n        require(_initiator != msg.sender, ERROR_ACTION_WAS_REQUESTED_BY_SENDER);\n    }\n\n    /**\n    * @dev Returns an address of the 'configurator' implementation.\n    */\n    function _getImplementation() internal view returns (address) {\n        return configurator;\n    }\n\n}\n\n// File: contracts/interfaces/IDocumentManager.sol\n\npragma solidity ^0.5.12;\n\n/**\n* @title Interface of a contract for parsing and storing document data\n*/\ninterface IDocumentManager {\n\n    event DocumentAdded(\n        string indexed _document,\n        string _uri,\n        string indexed _checksum,\n        string _checksumAlgo,\n        string _timestamp,\n        string _figi,\n        string _individualId\n    );\n\n    /**\n    * @dev Sets fields separator\n    * @param _separator Separator\n    */\n    function setFieldSeparator(string calldata _separator) external;\n\n    /**\n    * @dev Gets fields separator\n    */\n    function getFieldSeparator() external view returns (string memory);\n\n    /**\n    * @dev Sets store data flag\n    * @param _saveData Store data flag\n    */\n    function setSaveData(bool _saveData) external;\n\n    /**\n    * @dev Gets store data flag\n    */\n    function getSaveData() external view returns (bool);\n\n    /**\n    * @dev Attaches document to token\n    * @param _symbol Token symbol\n    * @param _data string Text message with metadata\n    */\n    function setDocument(string calldata _symbol, string calldata _data) external;\n\n    /**\n    * @dev Gets document data\n    * @param _symbol Token symbol\n    * @param _id Document ID\n    */\n    function getDocument(string calldata _symbol, bytes32 _id)\n        external\n        view\n        returns (string memory, string memory, string memory, string memory, string memory, string memory, string memory);\n\n    /**\n    * @dev Gets the list of documents' ids\n    * @param _symbol Token symbol\n    */\n    function getDocumentIds(string calldata _symbol) external view returns (bytes32[] memory);\n\n}\n\n// File: contracts/libraries/linked/InveniamTokenLib.sol\n\npragma solidity ^0.5.12;\n\n\n\nlibrary InveniamTokenLib {\n    using SafeMath for uint256;\n    using AddressList for address;\n\n    string private constant ERROR_INVALID_INDEX = \"Index out of bound\";\n    string private constant ERROR_INVALID_ADDRESS = \"Invalid address\";\n    string private constant ERROR_INVALID_AMOUNT = \"Invalid amount\";\n    string private constant ERROR_AMOUNT_IS_NOT_AVAILABLE = \"Amount is not available\";\n\n    event TransferRequested(address indexed _from, address indexed _to, uint256 _amount);\n\n    struct HistoryBalance {\n        uint40 timestamp;\n        uint216 value;\n    }\n\n    /**\n     * @dev Updates balances history after transfer\n     * @param _from The address which you want to send tokens from\n     * @param _to The address which you want to transfer to\n     */\n    function afterTransfer(\n        address tokenAddress,\n        address _from,\n        address _to,\n        uint _balanceFrom,\n        uint _balanceTo,\n        mapping(address => AddressList.Data) storage holderData,\n        address[] storage holders,\n        mapping(address => HistoryBalance[]) storage historyBalances,\n        address[] storage historyHolders\n    )\n        public\n    {\n        if (_from != tokenAddress) {\n            if (_balanceFrom == 0) {\n                _from.removeFrom(holderData, holders);\n            }\n            if (historyBalances[_from].length == 0) {\n                historyHolders.push(_from);\n            }\n            historyBalances[_from].push(HistoryBalance(uint40(now), uint216(_balanceFrom)));\n        }\n\n        if (_to != tokenAddress) {\n            if (_balanceTo > 0) {\n                _to.addTo(holderData, holders);\n            }\n            if (historyBalances[_to].length == 0) {\n                historyHolders.push(_to);\n            }\n            historyBalances[_to].push(HistoryBalance(uint40(now), uint216(_balanceTo)));\n        }\n    }\n\n    /**\n     * @dev Update balance history after mint\n     * @param _account The account that will receive the created tokens\n     * @param _balance The current balance of the account\n     */\n    function afterMint(\n        address _account,\n        uint _balance,\n        mapping(address => AddressList.Data) storage holderData,\n        address[] storage holders,\n        mapping(address => HistoryBalance[]) storage historyBalances,\n        address[] storage historyHolders\n    )\n        public\n    {\n        if (_balance > 0) {\n            _account.addTo(holderData, holders);\n        }\n\n        if (historyBalances[_account].length == 0) {\n            historyHolders.push(_account);\n        }\n        historyBalances[_account].push(HistoryBalance(uint40(now), uint216(_balance)));\n    }\n\n    /**\n     * @dev Updates balance history after burn\n     * @param _account The account whose tokens will be burnt\n     * @param _balance The current balance of the account\n     */\n    function afterBurn(\n        address _account,\n        uint _balance,\n        mapping(address => AddressList.Data) storage holderData,\n        address[] storage holders,\n        mapping(address => HistoryBalance[]) storage historyBalances,\n        address[] storage historyHolders\n    )\n        public\n    {\n        if (_balance == 0) {\n            _account.removeFrom(holderData, holders);\n        }\n\n        if (historyBalances[_account].length == 0) {\n            historyHolders.push(_account);\n        }\n        historyBalances[_account].push(HistoryBalance(uint40(now), uint216(_balance)));\n    }\n\n    /**\n     * @dev Requests transfer\n     * @param _from The address to transfer from\n     * @param _to The address to transfer to\n     */\n    function requestTransfer(\n        address _from,\n        address _to,\n        uint256 /*_amount*/,\n        mapping(address => AddressList.Data) storage senderData,\n        address[] storage senders,\n        mapping(address => mapping (address => uint256)) storage /*transferBalances*/,\n        mapping(address => mapping(address => AddressList.Data)) storage senderToReceiverData,\n        mapping(address => address[]) storage senderToReceivers\n    )\n        public\n    {\n        if (senderToReceivers[_from].length == 0) {\n            _from.addTo(senderData, senders);\n        }\n        _to.addTo(senderToReceiverData[_from], senderToReceivers[_from]);\n    }\n\n    /**\n     * @dev Removes accounts from pending transfer list\n     * @param _from The address to transfer from\n     * @param _to The address to transfer to\n     */\n    function removeParticipants(\n        address _from,\n        address _to,\n        mapping(address => AddressList.Data) storage senderData,\n        address[] storage senders,\n        mapping(address => mapping(address => AddressList.Data)) storage senderToReceiverData,\n        mapping(address => address[]) storage senderToReceivers\n    )\n        public\n    {\n        _to.removeFrom(senderToReceiverData[_from], senderToReceivers[_from]);\n        if (senderToReceivers[_from].length == 0) {\n            _from.removeFrom(senderData, senders);\n        }\n    }\n\n    /**\n     * @dev Validates transfer according to rules\n     * @param _to The address to transfer to\n     * @param _amount The amount of the transfer\n     * @param _balance The balance of from address\n     */\n    function validateTransfer(address /*_from*/, address _to, uint256 _amount, uint256 _balance) public pure {\n        require(_amount > 0, ERROR_INVALID_AMOUNT);\n        require(_amount <= _balance, ERROR_AMOUNT_IS_NOT_AVAILABLE);\n        require(_to != address(0), ERROR_INVALID_ADDRESS);\n    }\n\n}\n\n// File: contracts/TokenStorage.sol\n\npragma solidity ^0.5.12;\n\n\n\n/**\n * @title Storage for InveniamToken\n */\ncontract TokenStorage {\n\n    // Declare storage for (pending) transfer requests\n    mapping(address => mapping (address => uint256)) transferBalances;\n\n    //attached transfer manager\n    address transferManager = address(0x00);\n\n    //current senders list\n    mapping(address => AddressList.Data) senderData;\n    address[] senders;\n\n    //current receivers list for a given sender\n    mapping(address => mapping(address => AddressList.Data)) senderToReceiverData;\n    mapping(address => address[]) senderToReceivers;\n\n    //current token holders\n    mapping(address => AddressList.Data) holderData;\n    address[] holders;\n\n    //history token holders\n    mapping(address => InveniamTokenLib.HistoryBalance[]) historyBalances;\n    address[] historyHolders;\n\n    //attached document manager\n    address documentManager = address(0x00);\n\n    //Flag whether pending balances should be saved\n    bool savePendingBalances = false;\n\n    //Flag whether holders history should be saved\n    bool saveHoldersHistory = false;\n\n    //Initially, a forced transfer can be done without an approval\n    bool forceTransferApproval = false;\n\n    address allowable = address(0x00);\n\n    //from => to => amount => initiator\n    mapping(address => mapping(address => mapping(uint256 => address))) forceTransferInitiators;\n\n}\n\n// File: contracts/interfaces/ITokenConfigurator.sol\n\npragma solidity ^0.5.12;\n\n/**\n* @title Interface for token configurator\n*/\ninterface ITokenConfigurator {\n\n    /**\n     * @dev Get balance for pending transfer\n     * @param _from The address to transfer from.\n     * @param _to The address to transfer to.\n     */\n    function getPendingBalance(address _from, address _to) external view returns (uint256);\n\n    /**\n     * @dev Returns sender addresses\n     */\n    function getSenders() external view returns (address[] memory);\n\n    /**\n     * @dev Returns receivers addresses\n     */\n    function getReceiversBySender(address _sender) external view returns (address[] memory);\n\n    /**\n     * @dev Returns holder addresses\n     * @dev use balanceOf to get the balance for each holder\n     */\n    function getHolders() external view returns (address[] memory);\n\n    /**\n     * @dev Returns history holder addresses\n     */\n    function getHistoryHolders() external view returns (address[] memory);\n\n    /**\n     * @dev Returns length of the history for a given account\n     */\n    function getHistoryLength(address _account) external view returns (uint);\n\n    /**\n     * @dev Returns history balance (timestamp, value) for a given account and index\n     */\n    function getHistoryBalance(address _account, uint _index) external view returns (uint40, uint216);\n\n    /**\n     * @dev Sets transfer manager\n     * @dev set 0x00 if you need to remove transfer manager\n     * @param _transferManager Address of the transfer manager\n     */\n    function setTransferManager(address _transferManager) external;\n\n    /**\n     * @dev Returns address of the transfer manager\n     */\n    function getTransferManager() external view returns (address);\n\n    /**\n     * @dev Set document manager\n     * @dev set 0x00 if you need to remove document manager\n     * @param _documentManager Address of the document manager\n     */\n    function setDocumentManager(address _documentManager) external;\n\n    /**\n     * @dev Return address of the document manager\n     */\n    function getDocumentManager() external view returns (address);\n\n    /**\n    * @dev Sets save pending balances flag\n    * @param _savePendingBalances Flag whether pending balances should be saved\n    */\n    function setSavePendingBalances(bool _savePendingBalances) external;\n\n    /**\n    * @dev Gets save pending balances flag\n    */\n    function getSavePendingBalances() external view returns (bool);\n\n    /**\n    * @dev Sets holders history flag\n    * @param _saveHoldersHistory Flag whether holders history should be saved\n    */\n    function setSaveHoldersHistory(bool _saveHoldersHistory) external;\n\n    /**\n    * @dev Gets holders history flag\n    */\n    function getSaveHoldersHistory() external view returns (bool);\n\n    function initForceTransferApproval() external;\n\n}\n\n// File: contracts/InveniamToken.sol\n\npragma solidity ^0.5.12;\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @title ERC20 based implementation with:\n * 1) off-chain transfer verification;\n * 2) owner only mint/burn functionality;\n *\n * @dev Main Inveniam Token implementation\n */\ncontract InveniamToken is AllowableModifiers, TokenStorage, ERC20, ERC20Detailed, FunctionProxy {\n\n    bytes32 private constant ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN = \"INDIVIDUAL_ISSUE_TOKEN_ADMIN\";\n\n    string private constant ERROR_INVALID_AMOUNT = \"Invalid amount\";\n    string private constant ERROR_AMOUNT_IS_NOT_AVAILABLE = \"Amount is not available\";\n    string private constant ERROR_AMOUNT_IS_NOT_ALLOWED = \"Amount is not allowed\";\n    string private constant ERROR_INVALID_TOTAL_SUPPLY = \"New supply is equal to the current supply\";\n    string private constant ERROR_TRANSFER_NOT_FOUND = \"Pending transfer not found\";\n\n    event TransferRequested(address indexed _from, address indexed _to, uint256 _amount);\n\n    event TransferApproved(address indexed _from, address indexed _to, uint256 _amount);\n\n    event TransferRejected(address indexed _from, address indexed _to, uint256 _amount);\n\n    event SupplyChanged(uint256 _delta, uint256 _totalSupply);\n\n    event ForcedTransfer(address indexed _from, address indexed _to, uint256 _amount);\n\n    event ForceTransferRequested(address indexed _from, address indexed _to, uint256 _amount);\n\n    event DocumentAdded(\n        string indexed _document,\n        string _uri,\n        string indexed _checksum,\n        string _checksumAlgo,\n        string _timestamp,\n        string _figi,\n        string _individualId\n    );\n\n    event RawDocumentAdded(string _data);\n\n    /**\n    * @dev Creates token with given data\n    * @param _symbol Token symbol\n    * @param _name Token name\n    * @param _decimals Token decimals\n    * @param _totalSupply Initial token supply\n    * @param _tokenOwner Owner of the token\n    * @param _tokenRegistry Token Registry\n    */\n    constructor (\n        string memory _symbol,\n        string memory _name,\n        uint8 _decimals,\n        uint256 _totalSupply,\n        address _tokenOwner,\n        address _tokenRegistry,\n        bool _saveHoldersHistory,\n        address _allowable,\n        address _configurator\n    )\n        ERC20Detailed(_name, _symbol, _decimals)\n        public\n    {\n        saveHoldersHistory = _saveHoldersHistory;\n        allowable = _allowable;\n        configurator = _configurator;\n        if (_totalSupply > 0) {\n            _mint(_tokenOwner, _totalSupply);\n        }\n\n        AllowableLib.addSystemRole(ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN, roleNames);\n        AllowableLib.addSystemRole(ROLE_INVENIAM_ADMIN, roleNames);\n        //we need to add this role for initial token set up\n        //will be removed after it\n        _addRole(_tokenRegistry, ROLE_INVENIAM_ADMIN);\n\n        adminRoles.push(ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN);\n        adminRoles.push(ROLE_INVENIAM_ADMIN);\n    }\n\n    /**\n    * @notice Adds given role to the user\n    * @param _user Address of user wallet\n    * @param _role Role name\n    */\n    function _addRole(address _user, bytes32 _role) private {\n        AllowableLib.addRole(_user, _role, false, false, roleNames, roleUserData, roleUsers, addRoleInitiators);\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _amount The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _amount) public notStopped returns (bool) {\n        _validateTransfer(msg.sender, _to, _amount);\n\n        if (_isApproved(msg.sender, msg.sender, _to, _amount)) {\n            super.transfer(_to, _amount);\n            emit TransferApproved(msg.sender, _to, _amount);\n        } else {\n            super.transfer(address(this), _amount);\n            _requestTransfer(msg.sender, _to, _amount);\n        }\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one specified address to another\n     * @param _from The address which you want to send tokens from\n     * @param _to The address which you want to transfer to\n     * @param _amount The amount of tokens to be transferred\n     */\n    function transferFrom(address _from, address _to, uint256 _amount) public notStopped returns (bool) {\n        _validateTransfer(_from, _to, _amount);\n        require(_amount <= allowance(_from, msg.sender), ERROR_AMOUNT_IS_NOT_ALLOWED);\n\n        if (_isApproved(msg.sender, _from, _to, _amount)) {\n            super.transferFrom(_from, _to, _amount);\n            emit TransferApproved(_from, _to, _amount);\n        } else {\n            super.transferFrom(_from, address(this), _amount);\n            _requestTransfer(_from, _to, _amount);\n        }\n        return true;\n    }\n\n    /**\n     * @dev Approves transfer of tokens\n     * The approveTransfer method is used for a withdraw workflow, allowing the owner of the contracts to approve\n     * tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n     * fees in sub-currencies;\n     * @param _from The address to transfer from.\n     * @param _to The address to transfer to.\n     * @param _amount The amount to be transferred.\n     */\n    function approveTransfer(address _from, address _to, uint256 _amount) external notStopped onlyAdmin {\n        require(_amount > 0, ERROR_INVALID_AMOUNT);\n        require(_amount <= transferBalances[_from][_to], ERROR_AMOUNT_IS_NOT_AVAILABLE);\n\n        transferBalances[_from][_to] = transferBalances[_from][_to].sub(_amount);\n        if (transferBalances[_from][_to] == 0) {\n            _removeParticipants(_from, _to);\n        }\n\n        _transfer(address(this), _to, _amount);\n        emit TransferApproved(_from, _to, _amount);\n    }\n\n    /**\n     * @dev Rejects transfer of tokens\n     * The rejectTransfer method is used for a withdraw workflow, allowing the owner of the contracts to approve\n     * tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n     * fees in sub-currencies;\n     * @param _from The address to transfer from.\n     * @param _to The address to transfer to.\n     */\n    function rejectTransfer(address _from, address _to)\n        external\n        notStopped\n        onlyAdmin\n    {\n        require(transferBalances[_from][_to] > 0, ERROR_TRANSFER_NOT_FOUND);\n\n        uint256 amount = transferBalances[_from][_to];\n        transferBalances[_from][_to] = 0;\n        _removeParticipants(_from, _to);\n\n        _transfer(address(this), _from, amount);\n        emit TransferRejected(_from, _to, amount);\n    }\n\n    /**\n    * @notice Request force transfer from one account to the another\n    * @param _from The address which you want to send tokens from\n    * @param _to The address which you want to transfer to\n    * @param _amount The amount of tokens to be transferred\n    */\n    function forceTransferRequest(address _from, address _to, uint256 _amount)\n        public\n        notStopped\n        onlyRole(ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN)\n    {\n        _validateTransfer(_from, _to, _amount);\n\n        if (forceTransferApproval) {\n            forceTransferInitiators[_from][_to][_amount] = msg.sender;\n            emit ForceTransferRequested(_from, _to, _amount);\n        } else {\n            _forceTransfer(_from, _to, _amount);\n        }\n    }\n\n    /**\n     * @dev Force transfer from one account to the another without off-chain verification\n     * @param _from The address which you want to send tokens from\n     * @param _to The address which you want to transfer to\n     * @param _amount The amount of tokens to be transferred\n     */\n    function forceTransfer(address _from, address _to, uint256 _amount)\n        public\n        notStopped\n        onlyRoleStrict(ROLE_INVENIAM_ADMIN)\n    {\n        if (forceTransferApproval) {\n            address initiator = forceTransferInitiators[_from][_to][_amount];\n            require(initiator != address(0), ERROR_ACTION_WAS_NOT_REQUESTED);\n            require(initiator != msg.sender, ERROR_ACTION_WAS_REQUESTED_BY_SENDER);\n        }\n\n        require(_amount <= balanceOf(_from), ERROR_AMOUNT_IS_NOT_AVAILABLE);\n        _forceTransfer(_from, _to, _amount);\n\n        if (forceTransferApproval) {\n            delete forceTransferInitiators[_from][_to][_amount];\n        }\n    }\n\n    function _forceTransfer(address _from, address _to, uint256 _amount) private {\n        _transfer(_from, _to, _amount);\n        emit ForcedTransfer(_from, _to, _amount);\n        emit TransferApproved(msg.sender, _to, _amount);\n    }\n\n    /**\n     * @dev Update amount of tokens to be supplied by contract\n     * @param _newTotalSupply The new amount of tokens to be supplied\n     */\n    function changeTotalSupply(uint256 _newTotalSupply) public notStopped onlyRole(ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN) {\n        require(_newTotalSupply != totalSupply(), ERROR_INVALID_TOTAL_SUPPLY);\n\n        bool isReducing = _newTotalSupply < totalSupply();\n        uint256 delta;\n        if (isReducing) {\n            delta = totalSupply().sub(_newTotalSupply);\n            _burn(owner(), delta);\n        } else {\n            delta = _newTotalSupply.sub(totalSupply());\n            _mint(owner(), delta);\n        }\n        emit SupplyChanged(delta, totalSupply());\n    }\n\n    /**\n    * @dev Attaches document to token\n    * @param _data string Text message with metadata\n    */\n    function setDocument(string calldata _data) external notStopped onlyRole(ROLE_INDIVIDUAL_ISSUE_TOKEN_ADMIN) {\n        if (address(documentManager) != address(0x00)) {\n            IDocumentManager(documentManager).setDocument(symbol(), _data);\n        } else {\n            emit RawDocumentAdded(_data);\n        }\n    }\n\n    /**\n     * @dev Transfer token for a specified addresses and update balances history\n     * @param _from The address to transfer from\n     * @param _to The address to transfer to\n     * @param _amount The amount to be transferred\n     */\n    function _transfer(address _from, address _to, uint256 _amount) internal {\n        super._transfer(_from, _to, _amount);\n        if (saveHoldersHistory && _amount > 0) {\n            uint balanceFrom = balanceOf(_from);\n            uint balanceTo = balanceOf(_to);\n\n            InveniamTokenLib.afterTransfer(\n                address(this),\n                _from,\n                _to,\n                balanceFrom,\n                balanceTo,\n                holderData,\n                holders,\n                historyBalances,\n                historyHolders\n            );\n        }\n    }\n\n    /**\n     * @dev Mints an amount of the token, assigns it to an account and updates balance history\n     * @param _account The account that will receive the created tokens\n     * @param _amount The amount that will be created\n     */\n    function _mint(address _account, uint256 _amount) internal {\n        super._mint(_account, _amount);\n        if (saveHoldersHistory && _amount > 0) {\n            uint balance = balanceOf(_account);\n\n            InveniamTokenLib.afterMint(\n                _account,\n                balance,\n                holderData,\n                holders,\n                historyBalances,\n                historyHolders\n            );\n        }\n    }\n\n    /**\n     * @dev Burns an amount of the token of a given account and updates balance history\n     * @param _account The account whose tokens will be burnt\n     * @param _amount The amount that will be burnt\n     */\n    function _burn(address _account, uint256 _amount) internal {\n        super._burn(_account, _amount);\n        if (saveHoldersHistory && _amount > 0) {\n            uint balance = balanceOf(_account);\n\n            InveniamTokenLib.afterBurn(\n                _account,\n                balance,\n                holderData,\n                holders,\n                historyBalances,\n                historyHolders\n            );\n        }\n    }\n\n    /**\n     * @dev Validates transfer\n     * @param _from The address to transfer from\n     * @param _to The address to transfer to\n     * @param _amount The amount to be transferred\n     */\n    function _validateTransfer(address _from, address _to, uint256 _amount) internal view {\n        InveniamTokenLib.validateTransfer(_from, _to, _amount, balanceOf(_from));\n    }\n\n    /**\n     * @dev Checks whether transfer is approved\n     * @param _from The address to transfer from\n     * @param _to The address to transfer to\n     * @param _amount The amount to be transferred\n     */\n    function _isApproved(address _spender, address _from, address _to, uint256 _amount) internal returns (bool) {\n        return (transferManager != address(0x00) &&\n                ITransferManager(transferManager).isApproved(_spender, _from, _to, _amount));\n    }\n\n    /**\n     * @dev Requests transfer\n     * @param _from The address to transfer from\n     * @param _to The address to transfer to\n     * @param _amount The amount to be transferred\n     */\n    function _requestTransfer(address _from, address _to, uint256 _amount) internal {\n        transferBalances[_from][_to] = transferBalances[_from][_to].add(_amount);\n        if (savePendingBalances) {\n            InveniamTokenLib.requestTransfer(\n                _from,\n                _to,\n                _amount,\n                senderData,\n                senders,\n                transferBalances,\n                senderToReceiverData,\n                senderToReceivers\n            );\n        }\n        emit TransferRequested(_from, _to, _amount);\n    }\n\n    /**\n     * @dev Removes accounts from pending transfer list\n     * @param _from The address to transfer from\n     * @param _to The address to transfer to\n     */\n    function _removeParticipants(address _from, address _to) internal {\n        if (savePendingBalances) {\n            InveniamTokenLib.removeParticipants(\n                _from,\n                _to,\n                senderData,\n                senders,\n                senderToReceiverData,\n                senderToReceivers\n            );\n        }\n    }\n\n    /**\n    * @dev Returns an address of the 'allowable' implementation.\n    */\n    function _getImplementation() internal view returns (address) {\n        return allowable;\n    }\n\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenRegistry\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_saveHoldersHistory\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_allowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_configurator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"_document\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"_checksum\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_checksumAlgo\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_timestamp\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_figi\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_individualId\",\"type\":\"string\"}],\"name\":\"DocumentAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ForceTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ForcedTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_data\",\"type\":\"string\"}],\"name\":\"RawDocumentAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_delta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"SupplyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TransferApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TransferRejected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TransferRequested\",\"type\":\"event\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approveTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTotalSupply\",\"type\":\"uint256\"}],\"name\":\"changeTotalSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"forceTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"forceTransferRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"rejectTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_data\",\"type\":\"string\"}],\"name\":\"setDocument\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"InveniamToken","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a000000000000000000000000042b5f517f330c0918953e6e344a77e402cb9a11000000000000000000000000040d5c00917328a69c13bdd66e76c828d59d1617b0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000cff594a82812596e667476eec2a0c8f53a29da78000000000000000000000000af7bb7711513ee2e064cec22a7f2754aa1c234270000000000000000000000000000000000000000000000000000000000000004554154330000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000105541543320546f6b656e202d204e6f7600000000000000000000000000000000","Library":"InveniamTokenLib:eb8b812077450871342e715b1e012277788a2a2f;AllowableLib:871a380c8efa6e2490e9232b90a509689e8161de","LicenseType":"None","SwarmSource":"bzzr://48d0e48e8edf0c60b573314f2d4cc506e6b9b0eabf6ccd7781445dcf85b6d69f"}]}