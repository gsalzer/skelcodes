{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IERC20 {\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external;\r\n  function transferFrom(address from, address to, uint256 value) external;\r\n  function approve(address spender, uint256 value) external;\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface IVersionable {\r\n  \r\n  /*\r\n   * Is called by DepositContractRegistry when this version\r\n   * is being upgraded to. Will call `versionEndUsage` on the\r\n   * old contract before calling this one\r\n   */\r\n  function versionBeginUsage(\r\n    address owner, \r\n    address payable depositAddress, \r\n    address oldVersion, \r\n    bytes calldata additionalData\r\n  ) external;\r\n\r\n  /*\r\n   * Is called by DepositContractRegistry when this version is\r\n   * being upgraded from. DepositContractRegistry will then call\r\n   * `versionBeginUsage` on the new contract\r\n   */\r\n  function versionEndUsage(\r\n    address owner,\r\n    address payable depositAddress,\r\n    address newVersion,\r\n    bytes calldata additionalData\r\n  ) external;\r\n}\r\n\r\n\r\nlibrary LoopringTypes {\r\n  struct BrokerOrder {\r\n      address owner;\r\n      bytes32 orderHash;\r\n      uint fillAmountB;\r\n      uint requestedAmountS;\r\n      uint requestedFeeAmount;\r\n      address tokenRecipient;\r\n      bytes extraData;\r\n  }\r\n\r\n  struct BrokerApprovalRequest {\r\n      BrokerOrder[] orders;\r\n      address tokenS;\r\n      address tokenB;\r\n      address feeToken;\r\n      uint totalFillAmountB;\r\n      uint totalRequestedAmountS;\r\n      uint totalRequestedFeeAmount;\r\n  }\r\n\r\n  struct BrokerInterceptorReport {\r\n      address owner;\r\n      address broker;\r\n      bytes32 orderHash;\r\n      address tokenB;\r\n      address tokenS;\r\n      address feeToken;\r\n      uint fillAmountB;\r\n      uint spentAmountS;\r\n      uint spentFeeAmount;\r\n      address tokenRecipient;\r\n      bytes extraData;\r\n  }\r\n}\r\n\r\n\r\ninterface IBrokerDelegate {\r\n\r\n  /*\r\n   * Loopring requests an allowance be set on a given token for a specified amount. Order details\r\n   * are provided (tokenS, totalAmountS, tokenB, totalAmountB, orderTokenRecipient, extraOrderData)\r\n   * to aid in any calculations or on-chain exchange of assets that may be required. The last 4\r\n   * parameters concern the actual token approval being requested of the broker.\r\n   *\r\n   * @returns Whether or not onOrderFillReport should be called for orders using this broker\r\n   */\r\n  function brokerRequestAllowance(LoopringTypes.BrokerApprovalRequest calldata request) external returns (bool);\r\n\r\n  /*\r\n   * After Loopring performs all of the transfers necessary to complete all the submitted\r\n   * rings it will call this function for every order's brokerInterceptor (if set) passing\r\n   * along the final fill counts for tokenB, tokenS and feeToken. This allows actions to be\r\n   * performed on a per-order basis after all tokenS/feeToken funds have left the order owner's\r\n   * possesion and the tokenB funds have been transfered to the order owner's intended recipient\r\n   */\r\n  function onOrderFillReport(LoopringTypes.BrokerInterceptorReport calldata fillReport) external;\r\n\r\n  /*\r\n   * Get the available token balance controlled by the broker on behalf of an address (owner)\r\n   */\r\n  function brokerBalanceOf(address owner, address token) external view returns (uint);\r\n}\r\n\r\n\r\ninterface IDolomiteMarginTradingBroker {\r\n  \r\n  /*\r\n   * Called by the DolomiteMarginTrading contract to request approval to deposit funds\r\n   * into itself (the msg.sender) and then into DyDx Solo. Check that the msg.sender is\r\n   * the DolomiteMarginTrading contract\r\n   */\r\n  function brokerMarginRequestApproval(address owner, address token, uint amount) external;\r\n\r\n  /*\r\n   * Called by the DolomiteMarginTrading contract to get the address that borrowed funds are expected\r\n   * to be placed into for Loopring settlement. For DolomiteDirectV1, for example, this function \r\n   * returns the address for the owner's DepositContract \r\n   */\r\n  function brokerMarginGetTrader(address owner, bytes calldata orderData) external returns (address);\r\n}\r\n\r\n\r\n\r\nlibrary Types {\r\n\r\n  struct RequestFee {\r\n    address feeRecipient;\r\n    address feeToken;\r\n    uint feeAmount;\r\n  }\r\n\r\n  struct RequestSignature {\r\n    uint8 v; \r\n    bytes32 r; \r\n    bytes32 s;\r\n  }\r\n\r\n  enum RequestType { Update, Transfer }\r\n\r\n  struct Request {\r\n    address owner;\r\n    address target;\r\n    RequestType requestType;\r\n    bytes payload;\r\n    uint nonce;\r\n    RequestFee fee;\r\n    RequestSignature signature;\r\n  }\r\n\r\n  struct TransferRequest {\r\n    address token;\r\n    address recipient;\r\n    uint amount;\r\n    bool unwrap;\r\n  }\r\n}\r\n\r\nlibrary RequestHelper {\r\n\r\n  bytes constant personalPrefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n\r\n  function getSigner(Types.Request memory self) internal pure returns (address) {\r\n    bytes32 messageHash = keccak256(abi.encode(\r\n      self.owner,\r\n      self.target,\r\n      self.requestType,\r\n      self.payload,\r\n      self.nonce,\r\n      abi.encode(self.fee.feeRecipient, self.fee.feeToken, self.fee.feeAmount)\r\n    ));\r\n\r\n    bytes32 prefixedHash = keccak256(abi.encodePacked(personalPrefix, messageHash));\r\n    return ecrecover(prefixedHash, self.signature.v, self.signature.r, self.signature.s);\r\n  }\r\n\r\n  function decodeTransferRequest(Types.Request memory self) \r\n    internal \r\n    pure \r\n    returns (Types.TransferRequest memory transferRequest) \r\n  {\r\n    require(self.requestType == Types.RequestType.Transfer, \"INVALID_REQUEST_TYPE\");\r\n\r\n    (\r\n      transferRequest.token,\r\n      transferRequest.recipient,\r\n      transferRequest.amount,\r\n      transferRequest.unwrap\r\n    ) = abi.decode(self.payload, (address, address, uint, bool));\r\n  }\r\n}\r\n\r\n\r\ncontract Requestable {\r\n  using RequestHelper for Types.Request;\r\n\r\n  mapping(address => uint) nonces;\r\n\r\n  function validateRequest(Types.Request memory request) internal {\r\n    require(request.target == address(this), \"INVALID_TARGET\");\r\n    require(request.getSigner() == request.owner, \"INVALID_SIGNATURE\");\r\n    require(nonces[request.owner] + 1 == request.nonce, \"INVALID_NONCE\");\r\n    \r\n    if (request.fee.feeAmount > 0) {\r\n      require(balanceOf(request.owner, request.fee.feeToken) >= request.fee.feeAmount, \"INSUFFICIENT_FEE_BALANCE\");\r\n    }\r\n\r\n    nonces[request.owner] += 1;\r\n  }\r\n\r\n  function completeRequest(Types.Request memory request) internal {\r\n    if (request.fee.feeAmount > 0) {\r\n      _payRequestFee(request.owner, request.fee.feeToken, request.fee.feeRecipient, request.fee.feeAmount);\r\n    }\r\n  }\r\n\r\n  function nonceOf(address owner) public view returns (uint) {\r\n    return nonces[owner];\r\n  }\r\n\r\n  // Abtract functions\r\n  function balanceOf(address owner, address token) public view returns (uint);\r\n  function _payRequestFee(address owner, address feeToken, address feeRecipient, uint feeAmount) internal;\r\n}\r\n\r\n\r\ncontract DepositContract {\r\n  address public owner;\r\n  address public parent;\r\n  address public version;\r\n    \r\n  function setVersion(address newVersion) external;\r\n\r\n  function perform(\r\n    address addr, \r\n    string calldata signature, \r\n    bytes calldata encodedParams,\r\n    uint value\r\n  ) external returns (bytes memory);\r\n}\r\n\r\n\r\nlibrary DepositContractHelper {\r\n\r\n  function wrapAndTransferToken(DepositContract self, address token, address recipient, uint amount, address wethAddress) internal {\r\n    if (token == wethAddress) {\r\n      uint etherBalance = address(self).balance;\r\n      if (etherBalance > 0) wrapEth(self, token, etherBalance);\r\n    }\r\n    transferToken(self, token, recipient, amount);\r\n  }\r\n\r\n  function transferToken(DepositContract self, address token, address recipient, uint amount) internal {\r\n    self.perform(token, \"transfer(address,uint256)\", abi.encode(recipient, amount), 0);\r\n  }\r\n\r\n  function transferEth(DepositContract self, address recipient, uint amount) internal {\r\n    self.perform(recipient, \"\", abi.encode(), amount);\r\n  }\r\n\r\n  function approveToken(DepositContract self, address token, address broker, uint amount) internal {\r\n    self.perform(token, \"approve(address,uint256)\", abi.encode(broker, amount), 0);\r\n  }\r\n\r\n  function wrapEth(DepositContract self, address wethToken, uint amount) internal {\r\n    self.perform(wethToken, \"deposit()\", abi.encode(), amount);\r\n  }\r\n\r\n  function unwrapWeth(DepositContract self, address wethToken, uint amount) internal {\r\n    self.perform(wethToken, \"withdraw(uint256)\", abi.encode(amount), 0);\r\n  }\r\n\r\n  function setDydxOperator(DepositContract self, address dydxContract, address operator) internal {\r\n    bytes memory encodedParams = abi.encode(\r\n      bytes32(0x0000000000000000000000000000000000000000000000000000000000000020),\r\n      bytes32(0x0000000000000000000000000000000000000000000000000000000000000001),\r\n      operator,\r\n      bytes32(0x0000000000000000000000000000000000000000000000000000000000000001)\r\n    );\r\n    self.perform(dydxContract, \"setOperators((address,bool)[])\", encodedParams, 0);\r\n  }\r\n}\r\n\r\n\r\ninterface IDepositContractRegistry {\r\n  function depositAddressOf(address owner) external view returns (address payable);\r\n}\r\n\r\n\r\n/**\r\n * @title DolomiteDirectV1\r\n * @author Zack Rubenstein\r\n *\r\n * Interfaces with the DepositContractRegistry and individual \r\n * DepositContracts to enable smart-wallet functionality as well\r\n * as spot and margin trading on Dolomite (through Loopring & Dy/dx)\r\n */\r\ncontract DolomiteDirectV1 is Requestable, IVersionable, IBrokerDelegate, IDolomiteMarginTradingBroker {\r\n  using DepositContractHelper for DepositContract;\r\n  using SafeMath for uint;\r\n\r\n  IDepositContractRegistry public registry;\r\n  address public loopringProtocolAddress;\r\n  address public dolomiteMarginProtocolAddress;\r\n  address public dydxProtocolAddress;\r\n  address public wethTokenAddress;\r\n\r\n  constructor(\r\n    address _depositContractRegistry,\r\n    address _loopringRingSubmitter,\r\n    address _dolomiteMarginProtocol,\r\n    address _dydxProtocolAddress,\r\n    address _wethTokenAddress\r\n  ) public {\r\n    registry = IDepositContractRegistry(_depositContractRegistry);\r\n    loopringProtocolAddress = _loopringRingSubmitter;\r\n    dolomiteMarginProtocolAddress = _dolomiteMarginProtocol;\r\n    dydxProtocolAddress = _dydxProtocolAddress;\r\n    wethTokenAddress = _wethTokenAddress;\r\n  }\r\n\r\n  /*\r\n   * Returns the available balance for an owner that this contract manages.\r\n   * If the token is WETH, it returns the sum of the ETH and WETH balance,\r\n   * as ETH is automatically wrapped upon transfers (unless the unwrap option is\r\n   * set to true in the transfer request)\r\n   */\r\n  function balanceOf(address owner, address token) public view returns (uint) {\r\n    address depositAddress = registry.depositAddressOf(owner);\r\n    uint tokenBalance = IERC20(token).balanceOf(depositAddress);\r\n    if (token == wethTokenAddress) tokenBalance = tokenBalance.add(depositAddress.balance);\r\n    return tokenBalance;\r\n  }\r\n\r\n  /*\r\n   * Send up a signed transfer request and the given amount tokens\r\n   * is transfered to the specified recipient.\r\n   */\r\n  function transfer(Types.Request memory request) public {\r\n    validateRequest(request);\r\n    \r\n    Types.TransferRequest memory transferRequest = request.decodeTransferRequest();\r\n    address payable depositAddress = registry.depositAddressOf(request.owner);\r\n\r\n    _transfer(\r\n      transferRequest.token, \r\n      depositAddress, \r\n      transferRequest.recipient, \r\n      transferRequest.amount, \r\n      transferRequest.unwrap\r\n    );\r\n\r\n    completeRequest(request);\r\n  }\r\n\r\n  // =============================\r\n\r\n  function _transfer(address token, address payable depositAddress, address recipient, uint amount, bool unwrap) internal {\r\n    DepositContract depositContract = DepositContract(depositAddress);\r\n    \r\n    if (token == wethTokenAddress && unwrap) {\r\n      if (depositAddress.balance < amount) {\r\n        depositContract.unwrapWeth(wethTokenAddress, amount.sub(depositAddress.balance));\r\n      }\r\n\r\n      depositContract.transferEth(recipient, amount);\r\n      return;\r\n    }\r\n\r\n    depositContract.wrapAndTransferToken(token, recipient, amount, wethTokenAddress);\r\n  }\r\n\r\n  // -----------------------------\r\n  // Loopring Broker Delegate\r\n\r\n  function brokerRequestAllowance(LoopringTypes.BrokerApprovalRequest memory request) public returns (bool) {\r\n    require(msg.sender == loopringProtocolAddress);\r\n\r\n    LoopringTypes.BrokerOrder[] memory mergedOrders = new LoopringTypes.BrokerOrder[](request.orders.length);\r\n    uint numMergedOrders = 1;\r\n\r\n    mergedOrders[0] = request.orders[0];\r\n    \r\n    if (request.orders.length > 1) {\r\n      for (uint i = 1; i < request.orders.length; i++) {\r\n        bool isDuplicate = false;\r\n\r\n        for (uint b = 0; b < numMergedOrders; b++) {\r\n          if (request.orders[i].owner == mergedOrders[b].owner) {\r\n            mergedOrders[b].requestedAmountS += request.orders[i].requestedAmountS;\r\n            mergedOrders[b].requestedFeeAmount += request.orders[i].requestedFeeAmount;\r\n            isDuplicate = true;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (!isDuplicate) {\r\n          mergedOrders[numMergedOrders] = request.orders[i];\r\n          numMergedOrders += 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (uint j = 0; j < numMergedOrders; j++) {\r\n      LoopringTypes.BrokerOrder memory order = mergedOrders[j];\r\n      address payable depositAddress = registry.depositAddressOf(order.owner);\r\n      \r\n      _transfer(request.tokenS, depositAddress, address(this), order.requestedAmountS, false);\r\n      if (order.requestedFeeAmount > 0) _transfer(request.feeToken, depositAddress, address(this), order.requestedFeeAmount, false);\r\n    }\r\n\r\n    return false; // Does not use onOrderFillReport\r\n  }\r\n\r\n  function onOrderFillReport(LoopringTypes.BrokerInterceptorReport memory fillReport) public {\r\n    // Do nothing\r\n  }\r\n\r\n  function brokerBalanceOf(address owner, address tokenAddress) public view returns (uint) {\r\n    return balanceOf(owner, tokenAddress);\r\n  }\r\n\r\n  // ----------------------------\r\n  // Dolomite Margin Trading Broker\r\n\r\n  function brokerMarginRequestApproval(address owner, address token, uint amount) public {\r\n    require(msg.sender == dolomiteMarginProtocolAddress);\r\n\r\n    address payable depositAddress = registry.depositAddressOf(owner);\r\n    _transfer(token, depositAddress, address(this), amount, false);\r\n  }\r\n\r\n  function brokerMarginGetTrader(address owner, bytes memory orderData) public returns (address) {\r\n    return registry.depositAddressOf(owner);\r\n  }\r\n\r\n  // -----------------------------\r\n  // Requestable\r\n\r\n  function _payRequestFee(address owner, address feeToken, address feeRecipient, uint feeAmount) internal {\r\n    _transfer(feeToken, registry.depositAddressOf(owner), feeRecipient, feeAmount, false);\r\n  }\r\n\r\n  // -----------------------------\r\n  // Versionable\r\n\r\n  function versionBeginUsage(\r\n    address owner, \r\n    address payable depositAddress, \r\n    address oldVersion, \r\n    bytes calldata additionalData\r\n  ) external { \r\n    // Approve the DolomiteMarginProtocol as an operator for the deposit contract's dydx account\r\n    DepositContract(depositAddress).setDydxOperator(dydxProtocolAddress, dolomiteMarginProtocolAddress);\r\n  }\r\n\r\n  function versionEndUsage(\r\n    address owner,\r\n    address payable depositAddress,\r\n    address newVersion,\r\n    bytes calldata additionalData\r\n  ) external { /* do nothing */ }\r\n\r\n\r\n  // =============================\r\n  // Administrative\r\n\r\n  /*\r\n   * Tokens are held in individual deposit contracts, the only time a trader's\r\n   * funds are held by this contract is when Loopring or Dy/dx requests a trader's\r\n   * tokens, and immediatly upon this contract moving funds into itself, Loopring\r\n   * or Dy/dx will move the funds out and into themselves. Thus, we can open this \r\n   * function up for anyone to call to set or reset the approval for Loopring and\r\n   * Dy/dx for a given token. The reason these approvals are set globally and not\r\n   * on an as-needed (per fill) basis is to reduce gas costs.\r\n   */\r\n  function enableTrading(address token) external {\r\n    IERC20(token).approve(loopringProtocolAddress, 10**70);\r\n    IERC20(token).approve(dolomiteMarginProtocolAddress, 10**70);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"enableTrading\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dolomiteMarginProtocolAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"depositAddress\",\"type\":\"address\"},{\"name\":\"oldVersion\",\"type\":\"address\"},{\"name\":\"additionalData\",\"type\":\"bytes\"}],\"name\":\"versionBeginUsage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"brokerMarginRequestApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"broker\",\"type\":\"address\"},{\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"name\":\"tokenB\",\"type\":\"address\"},{\"name\":\"tokenS\",\"type\":\"address\"},{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"fillAmountB\",\"type\":\"uint256\"},{\"name\":\"spentAmountS\",\"type\":\"uint256\"},{\"name\":\"spentFeeAmount\",\"type\":\"uint256\"},{\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"fillReport\",\"type\":\"tuple\"}],\"name\":\"onOrderFillReport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"depositAddress\",\"type\":\"address\"},{\"name\":\"newVersion\",\"type\":\"address\"},{\"name\":\"additionalData\",\"type\":\"bytes\"}],\"name\":\"versionEndUsage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"brokerMarginGetTrader\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"brokerBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"requestType\",\"type\":\"uint8\"},{\"name\":\"payload\",\"type\":\"bytes\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"feeRecipient\",\"type\":\"address\"},{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"fee\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loopringProtocolAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dydxProtocolAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"components\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"name\":\"fillAmountB\",\"type\":\"uint256\"},{\"name\":\"requestedAmountS\",\"type\":\"uint256\"},{\"name\":\"requestedFeeAmount\",\"type\":\"uint256\"},{\"name\":\"tokenRecipient\",\"type\":\"address\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"orders\",\"type\":\"tuple[]\"},{\"name\":\"tokenS\",\"type\":\"address\"},{\"name\":\"tokenB\",\"type\":\"address\"},{\"name\":\"feeToken\",\"type\":\"address\"},{\"name\":\"totalFillAmountB\",\"type\":\"uint256\"},{\"name\":\"totalRequestedAmountS\",\"type\":\"uint256\"},{\"name\":\"totalRequestedFeeAmount\",\"type\":\"uint256\"}],\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"brokerRequestAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_depositContractRegistry\",\"type\":\"address\"},{\"name\":\"_loopringRingSubmitter\",\"type\":\"address\"},{\"name\":\"_dolomiteMarginProtocol\",\"type\":\"address\"},{\"name\":\"_dydxProtocolAddress\",\"type\":\"address\"},{\"name\":\"_wethTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"DolomiteDirectV1","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"0000000000000000000000004f14fc455703d23e0ef852e527cc0a7b1b94333700000000000000000000000075b51fc9436d418633a3ab078315affca12b760600000000000000000000000013a5dfb403c8cfc9c58cf897318ad83db8fe5a0f0000000000000000000000001e0447b19bb6ecfdae1e4ae1694b0c3659614e4e000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","Library":"","LicenseType":"None","SwarmSource":"bzzr://33106af196490082e2c817e4c7c092d9fc056fe9f0a5e1b3b94377c01356556b"}]}