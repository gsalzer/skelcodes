{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\n\n\n/**\n * @title Spawn\n * @author 0age\n * @notice This contract provides creation code that is used by Spawner in order\n * to initialize and deploy eip-1167 minimal proxies for a given logic contract.\n */\ncontract Spawn {\n  constructor(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) public payable {\n    // delegatecall into the logic contract to perform initialization.\n    (bool ok, ) = logicContract.delegatecall(initializationCalldata);\n    if (!ok) {\n      // pass along failure message from delegatecall and revert.\n      assembly {\n        returndatacopy(0, 0, returndatasize)\n        revert(0, returndatasize)\n      }\n    }\n\n    // place eip-1167 runtime code in memory.\n    bytes memory runtimeCode = abi.encodePacked(\n      bytes10(0x363d3d373d3d3d363d73),\n      logicContract,\n      bytes15(0x5af43d82803e903d91602b57fd5bf3)\n    );\n\n    // return eip-1167 code to write it to spawned contract runtime.\n    assembly {\n      return(add(0x20, runtimeCode), 45) // eip-1167 runtime code, length\n    }\n  }\n}\n\n/**\n * @title Spawner\n * @author 0age\n * @notice This contract spawns and initializes eip-1167 minimal proxies that\n * point to existing logic contracts. The logic contracts need to have an\n * intitializer function that should only callable when no contract exists at\n * their current address (i.e. it is being `DELEGATECALL`ed from a constructor).\n */\ncontract Spawner {\n  /**\n   * @notice Internal function for spawning an eip-1167 minimal proxy using\n   * `CREATE2`.\n   * @param logicContract address The address of the logic contract.\n   * @param initializationCalldata bytes The calldata that will be supplied to\n   * the `DELEGATECALL` from the spawned contract to the logic contract during\n   * contract creation.\n   * @return The address of the newly-spawned contract.\n   */\n  function _spawn(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) internal returns (address spawnedContract) {\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n\n    // spawn the contract using `CREATE2`.\n    spawnedContract = _spawnCreate2(initCode);\n  }\n\n  /**\n   * @notice Internal view function for finding the address of the next standard\n   * eip-1167 minimal proxy created using `CREATE2` with a given logic contract\n   * and initialization calldata payload.\n   * @param logicContract address The address of the logic contract.\n   * @param initializationCalldata bytes The calldata that will be supplied to\n   * the `DELEGATECALL` from the spawned contract to the logic contract during\n   * contract creation.\n   * @return The address of the next spawned minimal proxy contract with the\n   * given parameters.\n   */\n  function _computeNextAddress(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) internal view returns (address target) {\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n\n    // get target address using the constructed initialization code.\n    (, target) = _getSaltAndTarget(initCode);\n  }\n\n\n  /**\n   * @notice Private function for spawning a compact eip-1167 minimal proxy\n   * using `CREATE2`. Provides logic that is reused by internal functions. A\n   * salt will also be chosen based on the calling address and a computed nonce\n   * that prevents deployments to existing addresses.\n   * @param initCode bytes The contract creation code.\n   * @return The address of the newly-spawned contract.\n   */\n  function _spawnCreate2(\n    bytes memory initCode\n  ) private returns (address spawnedContract) {\n    // get salt to use during deployment using the supplied initialization code.\n    (bytes32 salt, ) = _getSaltAndTarget(initCode);\n\n    assembly {\n      let encoded_data := add(0x20, initCode) // load initialization code.\n      let encoded_size := mload(initCode)     // load the init code's length.\n      spawnedContract := create2(             // call `CREATE2` w/ 4 arguments.\n        callvalue,                            // forward any supplied endowment.\n        encoded_data,                         // pass in initialization code.\n        encoded_size,                         // pass in init code's length.\n        salt                                  // pass in the salt value.\n      )\n\n      // pass along failure message from failed contract deployment and revert.\n      if iszero(spawnedContract) {\n        returndatacopy(0, 0, returndatasize)\n        revert(0, returndatasize)\n      }\n    }\n  }\n\n  /**\n   * @notice Private function for determining the salt and the target deployment\n   * address for the next spawned contract (using create2) based on the contract\n   * creation code.\n   */\n  function _getSaltAndTarget(\n    bytes memory initCode\n  ) private view returns (bytes32 salt, address target) {\n    // get the keccak256 hash of the init code for address derivation.\n    bytes32 initCodeHash = keccak256(initCode);\n\n    // set the initial nonce to be provided when constructing the salt.\n    uint256 nonce = 0;\n\n    // declare variable for code size of derived address.\n    uint256 codeSize;\n\n    while (true) {\n      // derive `CREATE2` salt using `msg.sender` and nonce.\n      salt = keccak256(abi.encodePacked(msg.sender, nonce));\n\n      target = address(    // derive the target deployment address.\n        uint160(                   // downcast to match the address type.\n          uint256(                 // cast to uint to truncate upper digits.\n            keccak256(             // compute CREATE2 hash using 4 inputs.\n              abi.encodePacked(    // pack all inputs to the hash together.\n                bytes1(0xff),      // pass in the control character.\n                address(this),     // pass in the address of this contract.\n                salt,              // pass in the salt from above.\n                initCodeHash       // pass in hash of contract creation code.\n              )\n            )\n          )\n        )\n      );\n\n      // determine if a contract is already deployed to the target address.\n      assembly { codeSize := extcodesize(target) }\n\n      // exit the loop if no contract is deployed to the target address.\n      if (codeSize == 0) {\n        break;\n      }\n\n      // otherwise, increment the nonce and derive a new salt.\n      nonce++;\n    }\n  }\n}\n\n\ninterface iRegistry {\n\n    enum FactoryStatus { Unregistered, Registered, Retired }\n\n    event FactoryAdded(address owner, address factory, uint256 factoryID, bytes extraData);\n    event FactoryRetired(address owner, address factory, uint256 factoryID);\n    event InstanceRegistered(address instance, uint256 instanceIndex, address indexed creator, address indexed factory, uint256 indexed factoryID);\n\n    // factory state functions\n\n    function addFactory(address factory, bytes calldata extraData ) external;\n    function retireFactory(address factory) external;\n\n    // factory view functions\n\n    function getFactoryCount() external view returns (uint256 count);\n    function getFactoryStatus(address factory) external view returns (FactoryStatus status);\n    function getFactoryID(address factory) external view returns (uint16 factoryID);\n    function getFactoryData(address factory) external view returns (bytes memory extraData);\n    function getFactoryAddress(uint16 factoryID) external view returns (address factory);\n    function getFactory(address factory) external view returns (FactoryStatus state, uint16 factoryID, bytes memory extraData);\n    function getFactories() external view returns (address[] memory factories);\n    function getPaginatedFactories(uint256 startIndex, uint256 endIndex) external view returns (address[] memory factories);\n\n    // instance state functions\n\n    function register(address instance, address creator, uint80 extraData) external;\n\n    // instance view functions\n\n    function getInstanceType() external view returns (bytes4 instanceType);\n    function getInstanceCount() external view returns (uint256 count);\n    function getInstance(uint256 index) external view returns (address instance);\n    function getInstances() external view returns (address[] memory instances);\n    function getPaginatedInstances(uint256 startIndex, uint256 endIndex) external view returns (address[] memory instances);\n}\n\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error.\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\ncontract Metadata {\n\n    bytes private _staticMetadata;\n    bytes private _variableMetadata;\n\n    event StaticMetadataSet(bytes staticMetadata);\n    event VariableMetadataSet(bytes variableMetadata);\n\n    // state functions\n\n    function _setStaticMetadata(bytes memory staticMetadata) internal {\n        require(_staticMetadata.length == 0, \"static metadata cannot be changed\");\n        _staticMetadata = staticMetadata;\n        emit StaticMetadataSet(staticMetadata);\n    }\n\n    function _setVariableMetadata(bytes memory variableMetadata) internal {\n        _variableMetadata = variableMetadata;\n        emit VariableMetadataSet(variableMetadata);\n    }\n\n    // view functions\n\n    function getMetadata() public view returns (bytes memory staticMetadata, bytes memory variableMetadata) {\n        staticMetadata = _staticMetadata;\n        variableMetadata = _variableMetadata;\n    }\n}\n\n\n\ncontract Operated {\n\n    address private _operator;\n    bool private _status;\n\n    event OperatorUpdated(address operator, bool status);\n\n    // state functions\n\n    function _setOperator(address operator) internal {\n        require(_operator != operator, \"cannot set same operator\");\n        _operator = operator;\n        emit OperatorUpdated(operator, hasActiveOperator());\n    }\n\n    function _transferOperator(address operator) internal {\n        // transferring operator-ship implies there was an operator set before this\n        require(_operator != address(0), \"operator not set\");\n        _setOperator(operator);\n    }\n\n    function _renounceOperator() internal {\n        require(hasActiveOperator(), \"only when operator active\");\n        _operator = address(0);\n        _status = false;\n        emit OperatorUpdated(address(0), false);\n    }\n\n    function _activateOperator() internal {\n        require(!hasActiveOperator(), \"only when operator not active\");\n        _status = true;\n        emit OperatorUpdated(_operator, true);\n    }\n\n    function _deactivateOperator() internal {\n        require(hasActiveOperator(), \"only when operator active\");\n        _status = false;\n        emit OperatorUpdated(_operator, false);\n    }\n\n    // view functions\n\n    function getOperator() public view returns (address operator) {\n        operator = _operator;\n    }\n\n    function isOperator(address caller) public view returns (bool ok) {\n        return (caller == getOperator());\n    }\n\n    function hasActiveOperator() public view returns (bool ok) {\n        return _status;\n    }\n\n    function isActiveOperator(address caller) public view returns (bool ok) {\n        return (isOperator(caller) && hasActiveOperator());\n    }\n\n}\n\n\n\n/* Deadline\n *\n */\ncontract Deadline {\n\n    uint256 private _deadline;\n\n    event DeadlineSet(uint256 deadline);\n\n    // state functions\n\n    function _setDeadline(uint256 deadline) internal {\n        _deadline = deadline;\n        emit DeadlineSet(deadline);\n    }\n\n    // view functions\n\n    function getDeadline() public view returns (uint256 deadline) {\n        deadline = _deadline;\n    }\n\n    // if the _deadline is not set yet, isAfterDeadline will return true\n    // due to now - 0 = now\n    function isAfterDeadline() public view returns (bool status) {\n        if (_deadline == 0) {\n            status = false;\n        } else {\n            status = (now >= _deadline);\n        }\n    }\n\n}\n\n\n/* @title DecimalMath\n * @dev taken from https://github.com/PolymathNetwork/polymath-core\n * @dev Apache v2 License\n */\nlibrary DecimalMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant e18 = uint256(10) ** uint256(18);\n\n    /**\n     * @notice This function multiplies two decimals represented as (decimal * 10**DECIMALS)\n     * @return uint256 Result of multiplication represented as (decimal * 10**DECIMALS)\n     */\n    function mul(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        z = SafeMath.add(SafeMath.mul(x, y), (e18) / 2) / (e18);\n    }\n\n    /**\n     * @notice This function divides two decimals represented as (decimal * 10**DECIMALS)\n     * @return uint256 Result of division represented as (decimal * 10**DECIMALS)\n     */\n    function div(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        z = SafeMath.add(SafeMath.mul(x, (e18)), y / 2) / y;\n    }\n\n}\n\n\n/* TODO: Update eip165 interface\n *  bytes4(keccak256('create(bytes)')) == 0xcf5ba53f\n *  bytes4(keccak256('getInstanceType()')) == 0x18c2f4cf\n *  bytes4(keccak256('getInstanceRegistry()')) == 0xa5e13904\n *  bytes4(keccak256('getImplementation()')) == 0xaaf10f42\n *\n *  => 0xcf5ba53f ^ 0x18c2f4cf ^ 0xa5e13904 ^ 0xaaf10f42 == 0xd88967b6\n */\n interface iFactory {\n\n     event InstanceCreated(address indexed instance, address indexed creator, string initABI, bytes initData);\n\n     function create(bytes calldata initData) external returns (address instance);\n     function getInitdataABI() external view returns (string memory initABI);\n     function getInstanceRegistry() external view returns (address instanceRegistry);\n     function getTemplate() external view returns (address template);\n\n     function getInstanceCreator(address instance) external view returns (address creator);\n     function getInstanceType() external view returns (bytes4 instanceType);\n     function getInstanceCount() external view returns (uint256 count);\n     function getInstance(uint256 index) external view returns (address instance);\n     function getInstances() external view returns (address[] memory instances);\n     function getPaginatedInstances(uint256 startIndex, uint256 endIndex) external view returns (address[] memory instances);\n }\n\n\n\ncontract iNMR {\n\n    // ERC20\n    function totalSupply() external returns (uint256);\n    function balanceOf(address _owner) external returns (uint256);\n    function allowance(address _owner, address _spender) external returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool ok);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool ok);\n    function approve(address _spender, uint256 _value) external returns (bool ok);\n    function changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) external returns (bool ok);\n\n    // burn\n    function mint(uint256 _value) external returns (bool ok);\n    // burnFrom\n    function numeraiTransfer(address _to, uint256 _value) external returns (bool ok);\n}\n\n\n\n\ncontract Factory is Spawner {\n\n    address[] private _instances;\n    mapping (address => address) private _instanceCreator;\n\n    /* NOTE: The following items can be hardcoded as constant to save ~200 gas/create */\n    address private _templateContract;\n    string private _initdataABI;\n    address private _instanceRegistry;\n    bytes4 private _instanceType;\n\n    event InstanceCreated(address indexed instance, address indexed creator, bytes callData);\n\n    function _initialize(address instanceRegistry, address templateContract, bytes4 instanceType, string memory initdataABI) internal {\n        // set instance registry\n        _instanceRegistry = instanceRegistry;\n        // set logic contract\n        _templateContract = templateContract;\n        // set initdataABI\n        _initdataABI = initdataABI;\n        // validate correct instance registry\n        require(instanceType == iRegistry(instanceRegistry).getInstanceType(), 'incorrect instance type');\n        // set instanceType\n        _instanceType = instanceType;\n    }\n\n    // IFactory methods\n\n    function _create(bytes memory callData) internal returns (address instance) {\n        // deploy new contract: initialize it & write minimal proxy to runtime.\n        instance = Spawner._spawn(getTemplate(), callData);\n        // add the instance to the array\n        _instances.push(instance);\n        // set instance creator\n        _instanceCreator[instance] = msg.sender;\n        // add the instance to the instance registry\n        iRegistry(getInstanceRegistry()).register(instance, msg.sender, uint64(0));\n        // emit event\n        emit InstanceCreated(instance, msg.sender, callData);\n    }\n\n    function getInstanceCreator(address instance) public view returns (address creator) {\n        creator = _instanceCreator[instance];\n    }\n\n    function getInstanceType() public view returns (bytes4 instanceType) {\n        instanceType = _instanceType;\n    }\n\n    function getInitdataABI() public view returns (string memory initdataABI) {\n        initdataABI = _initdataABI;\n    }\n\n    function getInstanceRegistry() public view returns (address instanceRegistry) {\n        instanceRegistry = _instanceRegistry;\n    }\n\n    function getTemplate() public view returns (address template) {\n        template = _templateContract;\n    }\n\n    function getInstanceCount() public view returns (uint256 count) {\n        count = _instances.length;\n    }\n\n    function getInstance(uint256 index) public view returns (address instance) {\n        require(index < _instances.length, \"index out of range\");\n        instance = _instances[index];\n    }\n\n    function getInstances() public view returns (address[] memory instances) {\n        instances = _instances;\n    }\n\n    // Note: startIndex is inclusive, endIndex exclusive\n    function getPaginatedInstances(uint256 startIndex, uint256 endIndex) public view returns (address[] memory instances) {\n        require(startIndex < endIndex, \"startIndex must be less than endIndex\");\n        require(endIndex <= _instances.length, \"end index out of range\");\n\n        // initialize fixed size memory array\n        address[] memory range = new address[](endIndex - startIndex);\n\n        // Populate array with addresses in range\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            range[i - startIndex] = _instances[i];\n        }\n\n        // return array of addresses\n        instances = range;\n    }\n\n}\n\n\n\n\n/* Countdown timer\n */\ncontract Countdown is Deadline {\n\n    using SafeMath for uint256;\n\n    uint256 private _length;\n\n    event LengthSet(uint256 length);\n\n    // state functions\n\n    function _setLength(uint256 length) internal {\n        _length = length;\n        emit LengthSet(length);\n    }\n\n    function _start() internal returns (uint256 deadline) {\n        require(_length != 0, \"length not set\");\n        deadline = _length.add(now);\n        Deadline._setDeadline(deadline);\n    }\n\n    // view functions\n\n    function getLength() public view returns (uint256 length) {\n        length = _length;\n    }\n\n    // if Deadline._setDeadline or Countdown._setLength is not called,\n    // isOver will yield false\n    function isOver() public view returns (bool status) {\n        // when length or deadline not set,\n        // countdown has not started, hence not isOver\n        if (_length == 0 || Deadline.getDeadline() == 0) {\n            status = false;\n        } else {\n            status = Deadline.isAfterDeadline();\n        }\n    }\n\n    // timeRemaining will default to 0 if _setDeadline is not called\n    // if the now exceeds deadline, just return 0 as the timeRemaining\n    function timeRemaining() public view returns (uint256 time) {\n        if (now >= Deadline.getDeadline()) {\n            time = 0;\n        } else {\n            time = Deadline.getDeadline().sub(now);\n        }\n    }\n\n}\n\n\n\ncontract Template {\n\n    address private _factory;\n\n    // modifiers\n\n    modifier initializeTemplate() {\n        // set factory\n        _factory = msg.sender;\n\n        // only allow function to be delegatecalled from within a constructor.\n        uint32 codeSize;\n        assembly { codeSize := extcodesize(address) }\n        require(codeSize == 0, \"must be called within contract constructor\");\n        _;\n    }\n\n    // view functions\n\n    function getCreator() public view returns (address creator) {\n        // iFactory(...) would revert if _factory address is not actually a factory contract\n        creator = iFactory(_factory).getInstanceCreator(address(this));\n    }\n\n    function isCreator(address caller) public view returns (bool ok) {\n        ok = (caller == getCreator());\n    }\n\n}\n\n\n/**\n * @title NMR token burning helper\n * @dev Allows for calling NMR burn functions using regular openzeppelin ERC20Burnable interface and revert on failure.\n */\ncontract BurnNMR {\n\n    // address of the token\n    address private _Token; // can be hardcoded on mainnet deployment to reduce cost\n\n    function _setToken(address token) internal {\n        // set storage\n        _Token = token;\n    }\n\n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param value The amount of token to be burned.\n     */\n    function _burn(uint256 value) internal {\n        require(iNMR(_Token).mint(value), \"nmr burn failed\");\n    }\n\n    /**\n     * @dev Burns a specific amount of tokens from the target address and decrements allowance.\n     * @param from address The account whose tokens will be burned.\n     * @param value uint256 The amount of token to be burned.\n     */\n    function _burnFrom(address from, uint256 value) internal {\n        require(iNMR(_Token).numeraiTransfer(from, value), \"nmr burnFrom failed\");\n    }\n\n    function getToken() public view returns (address token) {\n        token = _Token;\n    }\n\n}\n\n\n\n\n\ncontract Staking is BurnNMR {\n\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _stake;\n\n    event TokenSet(address token);\n    event StakeAdded(address staker, address funder, uint256 amount, uint256 newStake);\n    event StakeTaken(address staker, address recipient, uint256 amount, uint256 newStake);\n    event StakeBurned(address staker, uint256 amount, uint256 newStake);\n\n    modifier tokenMustBeSet() {\n        require(BurnNMR.getToken() != address(0), \"token not set yet\");\n        _;\n    }\n\n    // state functions\n\n    function _setToken(address token) internal {\n        // set storage\n        BurnNMR._setToken(token);\n\n        // emit event\n        emit TokenSet(token);\n    }\n\n    function _addStake(address staker, address funder, uint256 currentStake, uint256 amountToAdd) internal tokenMustBeSet {\n        // require current stake amount matches expected amount\n        require(currentStake == _stake[staker], \"current stake incorrect\");\n\n        // require non-zero stake to add\n        require(amountToAdd > 0, \"no stake to add\");\n\n        // calculate new stake amount\n        uint256 newStake = currentStake.add(amountToAdd);\n\n        // set new stake to storage\n        _stake[staker] = newStake;\n\n        // transfer the stake amount\n        require(IERC20(BurnNMR.getToken()).transferFrom(funder, address(this), amountToAdd), \"token transfer failed\");\n\n        // emit event\n        emit StakeAdded(staker, funder, amountToAdd, newStake);\n    }\n\n    function _takeStake(address staker, address recipient, uint256 currentStake, uint256 amountToTake) internal tokenMustBeSet {\n        // require current stake amount matches expected amount\n        require(currentStake == _stake[staker], \"current stake incorrect\");\n\n        // require non-zero stake to take\n        require(amountToTake > 0, \"no stake to take\");\n\n        // amountToTake has to be less than equal currentStake\n        require(amountToTake <= currentStake, \"cannot take more than currentStake\");\n\n        // calculate new stake amount\n        uint256 newStake = currentStake.sub(amountToTake);\n\n        // set new stake to storage\n        _stake[staker] = newStake;\n\n        // transfer the stake amount\n        require(IERC20(BurnNMR.getToken()).transfer(recipient, amountToTake), \"token transfer failed\");\n\n        // emit event\n        emit StakeTaken(staker, recipient, amountToTake, newStake);\n    }\n\n    function _takeFullStake(address staker, address recipient) internal tokenMustBeSet returns (uint256 stake) {\n        // get stake from storage\n        stake = _stake[staker];\n\n        // take full stake\n        _takeStake(staker, recipient, stake, stake);\n    }\n\n    function _burnStake(address staker, uint256 currentStake, uint256 amountToBurn) tokenMustBeSet internal {\n        // require current stake amount matches expected amount\n        require(currentStake == _stake[staker], \"current stake incorrect\");\n\n        // require non-zero stake to burn\n        require(amountToBurn > 0, \"no stake to burn\");\n\n        // amountToTake has to be less than equal currentStake\n        require(amountToBurn <= currentStake, \"cannot burn more than currentStake\");\n\n        // calculate new stake amount\n        uint256 newStake = currentStake.sub(amountToBurn);\n\n        // set new stake to storage\n        _stake[staker] = newStake;\n\n        // burn the stake amount\n        BurnNMR._burn(amountToBurn);\n\n        // emit event\n        emit StakeBurned(staker, amountToBurn, newStake);\n    }\n\n    function _burnFullStake(address staker) internal tokenMustBeSet returns (uint256 stake) {\n        // get stake from storage\n        stake = _stake[staker];\n\n        // burn full stake\n        _burnStake(staker, stake, stake);\n    }\n\n    // view functions\n\n    function getStake(address staker) public view returns (uint256 stake) {\n        stake = _stake[staker];\n    }\n\n}\n\n\n\n\ncontract Griefing is Staking {\n\n    enum RatioType { NaN, Inf, Dec }\n\n    mapping (address => GriefRatio) private _griefRatio;\n    struct GriefRatio {\n        uint256 ratio;\n        RatioType ratioType;\n   }\n\n    event RatioSet(address staker, uint256 ratio, RatioType ratioType);\n    event Griefed(address punisher, address staker, uint256 punishment, uint256 cost, bytes message);\n\n    uint256 internal constant e18 = uint256(10) ** uint256(18);\n\n    // state functions\n\n    function _setRatio(address staker, uint256 ratio, RatioType ratioType) internal {\n        if (ratioType == RatioType.NaN || ratioType == RatioType.Inf) {\n            require(ratio == 0, \"ratio must be 0 when ratioType is NaN or Inf\");\n        }\n\n        // set data in storage\n        _griefRatio[staker].ratio = ratio;\n        _griefRatio[staker].ratioType = ratioType;\n\n        // emit event\n        emit RatioSet(staker, ratio, ratioType);\n    }\n\n    function _grief(address punisher, address staker, uint256 punishment, bytes memory message) internal returns (uint256 cost) {\n        require(BurnNMR.getToken() != address(0), \"token not set\");\n\n        // get grief data from storage\n        uint256 ratio = _griefRatio[staker].ratio;\n        RatioType ratioType = _griefRatio[staker].ratioType;\n\n        require(ratioType != RatioType.NaN, \"no punishment allowed\");\n\n        // calculate cost\n        // getCost also acts as a guard when _setRatio is not called before\n        cost = getCost(ratio, punishment, ratioType);\n\n        // burn the cost from the punisher's balance\n        BurnNMR._burnFrom(punisher, cost);\n\n        // get stake from storage\n        uint256 currentStake = Staking.getStake(staker);\n\n        // burn the punishment from the target's stake\n        Staking._burnStake(staker, currentStake, punishment);\n\n        // emit event\n        emit Griefed(punisher, staker, punishment, cost, message);\n    }\n\n    // view functions\n\n    function getRatio(address staker) public view returns (uint256 ratio, RatioType ratioType) {\n        // get stake data from storage\n        ratio = _griefRatio[staker].ratio;\n        ratioType = _griefRatio[staker].ratioType;\n    }\n\n    // pure functions\n\n    function getCost(uint256 ratio, uint256 punishment, RatioType ratioType) public pure returns(uint256 cost) {\n        /*  Dec:  Cost multiplied by ratio interpreted as a decimal number with 18 decimals, e.g. 1 -> 1e18\n         *  Inf:  Punishment at no cost\n         *  NaN:  No Punishment */\n        if (ratioType == RatioType.Dec) {\n            return DecimalMath.mul(SafeMath.mul(punishment, e18), ratio) / e18;\n        }\n        if (ratioType == RatioType.Inf)\n            return 0;\n        if (ratioType == RatioType.NaN)\n            revert(\"ratioType cannot be RatioType.NaN\");\n    }\n\n    function getPunishment(uint256 ratio, uint256 cost, RatioType ratioType) public pure returns(uint256 punishment) {\n        /*  Dec: Ratio is a decimal number with 18 decimals\n         *  Inf:  Punishment at no cost\n         *  NaN:  No Punishment */\n        if (ratioType == RatioType.Dec) {\n            return DecimalMath.div(SafeMath.mul(cost, e18), ratio) / e18;\n        }\n        if (ratioType == RatioType.Inf)\n            revert(\"ratioType cannot be RatioType.Inf\");\n        if (ratioType == RatioType.NaN)\n            revert(\"ratioType cannot be RatioType.NaN\");\n    }\n\n}\n\n\n\n\n\n\n\n\n/* Immediately engage with specific buyer\n * - Stake can be increased at any time.\n * - Request to end agreement and recover stake requires cooldown period to complete.\n * - Counterparty can greif the staker at predefined ratio.\n *\n * NOTE:\n * - This top level contract should only perform access control and state transitions\n *\n */\ncontract OneWayGriefing is Countdown, Griefing, Metadata, Operated, Template {\n\n    using SafeMath for uint256;\n\n    Data private _data;\n    struct Data {\n        address staker;\n        address counterparty;\n    }\n\n    function initialize(\n        address token,\n        address operator,\n        address staker,\n        address counterparty,\n        uint256 ratio,\n        Griefing.RatioType ratioType,\n        uint256 countdownLength,\n        bytes memory staticMetadata\n    ) public initializeTemplate() {\n        // set storage values\n        _data.staker = staker;\n        _data.counterparty = counterparty;\n\n        // set operator\n        if (operator != address(0)) {\n            Operated._setOperator(operator);\n            Operated._activateOperator();\n        }\n\n        // set token used for staking\n        Staking._setToken(token);\n\n        // set griefing ratio\n        Griefing._setRatio(staker, ratio, ratioType);\n\n        // set countdown length\n        Countdown._setLength(countdownLength);\n\n        // set static metadata\n        Metadata._setStaticMetadata(staticMetadata);\n    }\n\n    // state functions\n\n    function setVariableMetadata(bytes memory variableMetadata) public {\n        // restrict access\n        require(isStaker(msg.sender) || Operated.isActiveOperator(msg.sender), \"only staker or active operator\");\n\n        // update metadata\n        Metadata._setVariableMetadata(variableMetadata);\n    }\n\n    function increaseStake(uint256 currentStake, uint256 amountToAdd) public {\n        // restrict access\n        require(isStaker(msg.sender) || Operated.isActiveOperator(msg.sender), \"only staker or active operator\");\n\n        // require agreement is not ended\n        require(!Countdown.isOver(), \"agreement ended\");\n\n        // add stake\n        Staking._addStake(_data.staker, msg.sender, currentStake, amountToAdd);\n    }\n\n    function reward(uint256 currentStake, uint256 amountToAdd) public {\n        // restrict access\n        require(isCounterparty(msg.sender) || Operated.isActiveOperator(msg.sender), \"only counterparty or active operator\");\n\n        // require agreement is not ended\n        require(!Countdown.isOver(), \"agreement ended\");\n\n        // add stake\n        Staking._addStake(_data.staker, msg.sender, currentStake, amountToAdd);\n    }\n\n    function punish(address from, uint256 punishment, bytes memory message) public returns (uint256 cost) {\n        // restrict access\n        require(isCounterparty(msg.sender) || Operated.isActiveOperator(msg.sender), \"only counterparty or active operator\");\n\n        // require agreement is not ended\n        require(!Countdown.isOver(), \"agreement ended\");\n\n        // execute griefing\n        cost = Griefing._grief(from, _data.staker, punishment, message);\n    }\n\n    function startCountdown() public returns (uint256 deadline) {\n        // restrict access\n        require(isStaker(msg.sender) || Operated.isActiveOperator(msg.sender), \"only staker or active operator\");\n\n        // require countdown is not started\n        require(Deadline.getDeadline() == 0, \"deadline already set\");\n\n        // start countdown\n        deadline = Countdown._start();\n    }\n\n    function retrieveStake(address recipient) public returns (uint256 amount) {\n        // restrict access\n        require(isStaker(msg.sender) || Operated.isActiveOperator(msg.sender), \"only staker or active operator\");\n\n        // require deadline is passed\n        require(Deadline.isAfterDeadline(),\"deadline not passed\");\n\n        // retrieve stake\n        amount = Staking._takeFullStake(_data.staker, recipient);\n    }\n\n    function transferOperator(address operator) public {\n        // restrict access\n        require(Operated.isActiveOperator(msg.sender), \"only active operator\");\n\n        // transfer operator\n        Operated._transferOperator(operator);\n    }\n\n    function renounceOperator() public {\n        // restrict access\n        require(Operated.isActiveOperator(msg.sender), \"only active operator\");\n\n        // transfer operator\n        Operated._renounceOperator();\n    }\n\n    // view functions\n\n    function isStaker(address caller) public view returns (bool validity) {\n        validity = (caller == _data.staker);\n    }\n\n    function isCounterparty(address caller) public view returns (bool validity) {\n        validity = (caller == _data.counterparty);\n    }\n}\n\n\n\n\ncontract OneWayGriefing_Factory is Factory {\n\n    constructor(address instanceRegistry) public {\n        // deploy template contract\n        address templateContract = address(new OneWayGriefing());\n        // set instance type\n        bytes4 instanceType = bytes4(keccak256(bytes('Agreement')));\n        // set initdataABI\n        string memory initdataABI = '(address,address,address,address,uint256,uint8,uint256,bytes)';\n        // initialize factory params\n        Factory._initialize(instanceRegistry, templateContract, instanceType, initdataABI);\n    }\n\n    event ExplicitInitData(address indexed staker, address indexed counterparty, address indexed operator, uint256 ratio, Griefing.RatioType ratioType, uint256 countdownLength, bytes staticMetadata);\n\n    function create(bytes memory callData) public returns (address instance) {\n        // deploy instance\n        instance = Factory._create(callData);\n    }\n\n    function createEncoded(bytes memory initdata) public returns (address instance) {\n        // decode initdata\n        (\n            address token,\n            address operator,\n            address staker,\n            address counterparty,\n            uint256 ratio,\n            Griefing.RatioType ratioType, // uint8\n            uint256 countdownLength,\n            bytes memory staticMetadata\n        ) = abi.decode(initdata, (address,address,address,address,uint256,Griefing.RatioType,uint256,bytes));\n\n        // call explicit create\n        instance = createExplicit(token, operator, staker, counterparty, ratio, ratioType, countdownLength, staticMetadata);\n    }\n\n    function createExplicit(\n        address token,\n        address operator,\n        address staker,\n        address counterparty,\n        uint256 ratio,\n        Griefing.RatioType ratioType, // uint8\n        uint256 countdownLength,\n        bytes memory staticMetadata\n    ) public returns (address instance) {\n        // declare template in memory\n        OneWayGriefing template;\n\n        // construct the data payload used when initializing the new contract.\n        bytes memory callData = abi.encodeWithSelector(\n            template.initialize.selector, // selector\n            token,           // token\n            operator,        // operator\n            staker,          // staker\n            counterparty,    // counterparty\n            ratio,           // ratio\n            ratioType,       // ratioType\n            countdownLength, // countdownLength\n            staticMetadata   // staticMetadata\n        );\n\n        // deploy instance\n        instance = Factory._create(callData);\n\n        // emit event\n        emit ExplicitInitData(staker, counterparty, operator, ratio, ratioType, countdownLength, staticMetadata);\n    }\n\n}\n","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getInstanceType\",\"outputs\":[{\"name\":\"instanceType\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTemplate\",\"outputs\":[{\"name\":\"template\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"staker\",\"type\":\"address\"},{\"name\":\"counterparty\",\"type\":\"address\"},{\"name\":\"ratio\",\"type\":\"uint256\"},{\"name\":\"ratioType\",\"type\":\"uint8\"},{\"name\":\"countdownLength\",\"type\":\"uint256\"},{\"name\":\"staticMetadata\",\"type\":\"bytes\"}],\"name\":\"createExplicit\",\"outputs\":[{\"name\":\"instance\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"getInstanceCreator\",\"outputs\":[{\"name\":\"creator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"initdata\",\"type\":\"bytes\"}],\"name\":\"createEncoded\",\"outputs\":[{\"name\":\"instance\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInstanceRegistry\",\"outputs\":[{\"name\":\"instanceRegistry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitdataABI\",\"outputs\":[{\"name\":\"initdataABI\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInstanceCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"getPaginatedInstances\",\"outputs\":[{\"name\":\"instances\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"instance\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInstances\",\"outputs\":[{\"name\":\"instances\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getInstance\",\"outputs\":[{\"name\":\"instance\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"instanceRegistry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"counterparty\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ratio\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ratioType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"countdownLength\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"staticMetadata\",\"type\":\"bytes\"}],\"name\":\"ExplicitInitData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"InstanceCreated\",\"type\":\"event\"}]","ContractName":"OneWayGriefing_Factory","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000009f83e08cc9f41ce8bd901a214f36b2ba958d7ed","Library":"","SwarmSource":"bzzr://ba4e5a2270ef014a646ddbad947413becbdd7419c61b56679cdcb02a557e86de"}]}