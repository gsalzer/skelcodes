{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/data/Pb.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n// runtime proto sol library\r\nlibrary Pb {\r\n    enum WireType { Varint, Fixed64, LengthDelim, StartGroup, EndGroup, Fixed32 }\r\n\r\n    struct Buffer {\r\n        uint idx;  // the start index of next read. when idx=b.length, we're done\r\n        bytes b;   // hold serialized proto msg, readonly\r\n    }\r\n\r\n    // create a new in-memory Buffer object from raw msg bytes\r\n    function fromBytes(bytes memory raw) internal pure returns (Buffer memory buf) {\r\n        buf.b = raw;\r\n        buf.idx = 0;\r\n    }\r\n\r\n    // whether there are unread bytes\r\n    function hasMore(Buffer memory buf) internal pure returns (bool) {\r\n        return buf.idx < buf.b.length;\r\n    }\r\n\r\n    // decode current field number and wiretype\r\n    function decKey(Buffer memory buf) internal pure returns (uint tag, WireType wiretype) {\r\n        uint v = decVarint(buf);\r\n        tag = v / 8;\r\n        wiretype = WireType(v & 7);\r\n    }\r\n\r\n    // count tag occurrences, return an array due to no memory map support\r\n\t// have to create array for (maxtag+1) size. cnts[tag] = occurrences\r\n\t// should keep buf.idx unchanged because this is only a count function\r\n    function cntTags(Buffer memory buf, uint maxtag) internal pure returns (uint[] memory cnts) {\r\n        uint originalIdx = buf.idx;\r\n        cnts = new uint[](maxtag+1);  // protobuf's tags are from 1 rather than 0\r\n        uint tag;\r\n        WireType wire;\r\n        while (hasMore(buf)) {\r\n            (tag, wire) = decKey(buf);\r\n            cnts[tag] += 1;\r\n            skipValue(buf, wire);\r\n        }\r\n        buf.idx = originalIdx;\r\n    }\r\n\r\n    // read varint from current buf idx, move buf.idx to next read, return the int value\r\n    function decVarint(Buffer memory buf) internal pure returns (uint v) {\r\n        bytes10 tmp;  // proto int is at most 10 bytes (7 bits can be used per byte)\r\n        bytes memory bb = buf.b;  // get buf.b mem addr to use in assembly\r\n        v = buf.idx;  // use v to save one additional uint variable\r\n        assembly {\r\n            tmp := mload(add(add(bb, 32), v)) // load 10 bytes from buf.b[buf.idx] to tmp\r\n        }\r\n        uint b; // store current byte content\r\n        v = 0; // reset to 0 for return value\r\n        for (uint i=0; i<10; i++) {\r\n            assembly {\r\n                b := byte(i, tmp)  // don't use tmp[i] because it does bound check and costs extra\r\n            }\r\n            v |= (b & 0x7F) << (i * 7);\r\n            if (b & 0x80 == 0) {\r\n                buf.idx += i + 1;\r\n                return v;\r\n            }\r\n        }\r\n        revert(); // i=10, invalid varint stream\r\n    }\r\n\r\n    // read length delimited field and return bytes\r\n    function decBytes(Buffer memory buf) internal pure returns (bytes memory b) {\r\n        uint len = decVarint(buf);\r\n        uint end = buf.idx + len;\r\n        require(end <= buf.b.length);  // avoid overflow\r\n        b = new bytes(len);\r\n        bytes memory bufB = buf.b;  // get buf.b mem addr to use in assembly\r\n        uint bStart;\r\n        uint bufBStart = buf.idx;\r\n        assembly {\r\n            bStart := add(b, 32)\r\n            bufBStart := add(add(bufB, 32), bufBStart)\r\n        }\r\n        for (uint i=0; i<len; i+=32) {\r\n            assembly{\r\n                mstore(add(bStart, i), mload(add(bufBStart, i)))\r\n            }\r\n        }\r\n        buf.idx = end;\r\n    }\r\n\r\n    // return packed ints\r\n    function decPacked(Buffer memory buf) internal pure returns (uint[] memory t) {\r\n        uint len = decVarint(buf);\r\n        uint end = buf.idx + len;\r\n        require(end <= buf.b.length);  // avoid overflow\r\n        // array in memory must be init w/ known length\r\n        // so we have to create a tmp array w/ max possible len first\r\n        uint[] memory tmp = new uint[](len);\r\n        uint i = 0; // count how many ints are there\r\n        while (buf.idx < end) {\r\n            tmp[i] = decVarint(buf);\r\n            i++;\r\n        }\r\n        t = new uint[](i); // init t with correct length\r\n        for (uint j=0; j<i; j++) {\r\n            t[j] = tmp[j];\r\n        }\r\n        return t;\r\n    }\r\n\r\n    // move idx pass current value field, to beginning of next tag or msg end\r\n    function skipValue(Buffer memory buf, WireType wire) internal pure {\r\n        if (wire == WireType.Varint) { decVarint(buf); }\r\n        else if (wire == WireType.LengthDelim) {\r\n            uint len = decVarint(buf);\r\n            buf.idx += len; // skip len bytes value data\r\n            require(buf.idx <= buf.b.length);  // avoid overflow\r\n        } else { revert(); }  // unsupported wiretype\r\n    }\r\n\r\n    // type conversion help utils\r\n    function _bool(uint x) internal pure returns (bool v) {\r\n        return x != 0;\r\n    }\r\n\r\n    function _uint256(bytes memory b) internal pure returns (uint256 v) {\r\n        require(b.length <= 32);  // b's length must be smaller than or equal to 32\r\n        assembly { v := mload(add(b, 32)) }  // load all 32bytes to v\r\n        v = v >> (8 * (32 - b.length));  // only first b.length is valid\r\n    }\r\n\r\n    function _address(bytes memory b) internal pure returns (address v) {\r\n        v = _addressPayable(b);\r\n    }\r\n\r\n    function _addressPayable(bytes memory b) internal pure returns (address payable v) {\r\n        require(b.length == 20);\r\n        //load 32bytes then shift right 12 bytes\r\n        assembly { v := div(mload(add(b, 32)), 0x1000000000000000000000000) }\r\n    }\r\n\r\n    function _bytes32(bytes memory b) internal pure returns (bytes32 v) {\r\n        require(b.length == 32);\r\n        assembly { v := mload(add(b, 32)) }\r\n    }\r\n\r\n    // uint[] to uint8[]\r\n    function uint8s(uint[] memory arr) internal pure returns (uint8[] memory t) {\r\n        t = new uint8[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = uint8(arr[i]); }\r\n    }\r\n\r\n    function uint32s(uint[] memory arr) internal pure returns (uint32[] memory t) {\r\n        t = new uint32[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = uint32(arr[i]); }\r\n    }\r\n\r\n    function uint64s(uint[] memory arr) internal pure returns (uint64[] memory t) {\r\n        t = new uint64[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = uint64(arr[i]); }\r\n    }\r\n\r\n    function bools(uint[] memory arr) internal pure returns (bool[] memory t) {\r\n        t = new bool[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = arr[i]!=0; }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/data/PbChain.sol\r\n\r\n// Code generated by protoc-gen-sol. DO NOT EDIT.\r\n// source: chain.proto\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary PbChain {\r\n    using Pb for Pb.Buffer;  // so we can call Pb funcs on Buffer obj\r\n\r\n    struct OpenChannelRequest {\r\n        bytes channelInitializer;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct OpenChannelRequest\r\n\r\n    function decOpenChannelRequest(bytes memory raw) internal pure returns (OpenChannelRequest memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.channelInitializer = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder OpenChannelRequest\r\n\r\n    struct CooperativeWithdrawRequest {\r\n        bytes withdrawInfo;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct CooperativeWithdrawRequest\r\n\r\n    function decCooperativeWithdrawRequest(bytes memory raw) internal pure returns (CooperativeWithdrawRequest memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.withdrawInfo = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder CooperativeWithdrawRequest\r\n\r\n    struct CooperativeSettleRequest {\r\n        bytes settleInfo;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct CooperativeSettleRequest\r\n\r\n    function decCooperativeSettleRequest(bytes memory raw) internal pure returns (CooperativeSettleRequest memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.settleInfo = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder CooperativeSettleRequest\r\n\r\n    struct ResolvePayByConditionsRequest {\r\n        bytes condPay;   // tag: 1\r\n        bytes[] hashPreimages;   // tag: 2\r\n    } // end struct ResolvePayByConditionsRequest\r\n\r\n    function decResolvePayByConditionsRequest(bytes memory raw) internal pure returns (ResolvePayByConditionsRequest memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.hashPreimages = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.condPay = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.hashPreimages[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder ResolvePayByConditionsRequest\r\n\r\n    struct SignedSimplexState {\r\n        bytes simplexState;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct SignedSimplexState\r\n\r\n    function decSignedSimplexState(bytes memory raw) internal pure returns (SignedSimplexState memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.simplexState = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder SignedSimplexState\r\n\r\n    struct SignedSimplexStateArray {\r\n        SignedSimplexState[] signedSimplexStates;   // tag: 1\r\n    } // end struct SignedSimplexStateArray\r\n\r\n    function decSignedSimplexStateArray(bytes memory raw) internal pure returns (SignedSimplexStateArray memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(1);\r\n        m.signedSimplexStates = new SignedSimplexState[](cnts[1]);\r\n        cnts[1] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.signedSimplexStates[cnts[1]] = decSignedSimplexState(buf.decBytes());\r\n                cnts[1]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder SignedSimplexStateArray\r\n\r\n    struct ChannelMigrationRequest {\r\n        bytes channelMigrationInfo;   // tag: 1\r\n        bytes[] sigs;   // tag: 2\r\n    } // end struct ChannelMigrationRequest\r\n\r\n    function decChannelMigrationRequest(bytes memory raw) internal pure returns (ChannelMigrationRequest memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.sigs = new bytes[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.channelMigrationInfo = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigs[cnts[2]] = bytes(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder ChannelMigrationRequest\r\n\r\n}\r\n\r\n// File: contracts/lib/data/PbEntity.sol\r\n\r\n// Code generated by protoc-gen-sol. DO NOT EDIT.\r\n// source: entity.proto\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary PbEntity {\r\n    using Pb for Pb.Buffer;  // so we can call Pb funcs on Buffer obj\r\n\r\n    enum TokenType { INVALID, ETH, ERC20 }\r\n\r\n    // TokenType[] decode function\r\n    function TokenTypes(uint[] memory arr) internal pure returns (TokenType[] memory t) {\r\n        t = new TokenType[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = TokenType(arr[i]); }\r\n    }\r\n\r\n    enum TransferFunctionType { BOOLEAN_AND, BOOLEAN_OR, BOOLEAN_CIRCUIT, NUMERIC_ADD, NUMERIC_MAX, NUMERIC_MIN }\r\n\r\n    // TransferFunctionType[] decode function\r\n    function TransferFunctionTypes(uint[] memory arr) internal pure returns (TransferFunctionType[] memory t) {\r\n        t = new TransferFunctionType[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = TransferFunctionType(arr[i]); }\r\n    }\r\n\r\n    enum ConditionType { HASH_LOCK, DEPLOYED_CONTRACT, VIRTUAL_CONTRACT }\r\n\r\n    // ConditionType[] decode function\r\n    function ConditionTypes(uint[] memory arr) internal pure returns (ConditionType[] memory t) {\r\n        t = new ConditionType[](arr.length);\r\n        for (uint i = 0; i < t.length; i++) { t[i] = ConditionType(arr[i]); }\r\n    }\r\n\r\n    struct AccountAmtPair {\r\n        address account;   // tag: 1\r\n        uint256 amt;   // tag: 2\r\n    } // end struct AccountAmtPair\r\n\r\n    function decAccountAmtPair(bytes memory raw) internal pure returns (AccountAmtPair memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.account = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.amt = Pb._uint256(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder AccountAmtPair\r\n\r\n    struct TokenInfo {\r\n        TokenType tokenType;   // tag: 1\r\n        address tokenAddress;   // tag: 2\r\n    } // end struct TokenInfo\r\n\r\n    function decTokenInfo(bytes memory raw) internal pure returns (TokenInfo memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.tokenType = TokenType(buf.decVarint());\r\n            }\r\n            else if (tag == 2) {\r\n                m.tokenAddress = Pb._address(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder TokenInfo\r\n\r\n    struct TokenDistribution {\r\n        TokenInfo token;   // tag: 1\r\n        AccountAmtPair[] distribution;   // tag: 2\r\n    } // end struct TokenDistribution\r\n\r\n    function decTokenDistribution(bytes memory raw) internal pure returns (TokenDistribution memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.distribution = new AccountAmtPair[](cnts[2]);\r\n        cnts[2] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.token = decTokenInfo(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.distribution[cnts[2]] = decAccountAmtPair(buf.decBytes());\r\n                cnts[2]++;\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder TokenDistribution\r\n\r\n    struct TokenTransfer {\r\n        TokenInfo token;   // tag: 1\r\n        AccountAmtPair receiver;   // tag: 2\r\n    } // end struct TokenTransfer\r\n\r\n    function decTokenTransfer(bytes memory raw) internal pure returns (TokenTransfer memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.token = decTokenInfo(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.receiver = decAccountAmtPair(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder TokenTransfer\r\n\r\n    struct SimplexPaymentChannel {\r\n        bytes32 channelId;   // tag: 1\r\n        address peerFrom;   // tag: 2\r\n        uint seqNum;   // tag: 3\r\n        TokenTransfer transferToPeer;   // tag: 4\r\n        PayIdList pendingPayIds;   // tag: 5\r\n        uint lastPayResolveDeadline;   // tag: 6\r\n        uint256 totalPendingAmount;   // tag: 7\r\n    } // end struct SimplexPaymentChannel\r\n\r\n    function decSimplexPaymentChannel(bytes memory raw) internal pure returns (SimplexPaymentChannel memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.channelId = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.peerFrom = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 3) {\r\n                m.seqNum = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 4) {\r\n                m.transferToPeer = decTokenTransfer(buf.decBytes());\r\n            }\r\n            else if (tag == 5) {\r\n                m.pendingPayIds = decPayIdList(buf.decBytes());\r\n            }\r\n            else if (tag == 6) {\r\n                m.lastPayResolveDeadline = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 7) {\r\n                m.totalPendingAmount = Pb._uint256(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder SimplexPaymentChannel\r\n\r\n    struct PayIdList {\r\n        bytes32[] payIds;   // tag: 1\r\n        bytes32 nextListHash;   // tag: 2\r\n    } // end struct PayIdList\r\n\r\n    function decPayIdList(bytes memory raw) internal pure returns (PayIdList memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(2);\r\n        m.payIds = new bytes32[](cnts[1]);\r\n        cnts[1] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.payIds[cnts[1]] = Pb._bytes32(buf.decBytes());\r\n                cnts[1]++;\r\n            }\r\n            else if (tag == 2) {\r\n                m.nextListHash = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder PayIdList\r\n\r\n    struct TransferFunction {\r\n        TransferFunctionType logicType;   // tag: 1\r\n        TokenTransfer maxTransfer;   // tag: 2\r\n    } // end struct TransferFunction\r\n\r\n    function decTransferFunction(bytes memory raw) internal pure returns (TransferFunction memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.logicType = TransferFunctionType(buf.decVarint());\r\n            }\r\n            else if (tag == 2) {\r\n                m.maxTransfer = decTokenTransfer(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder TransferFunction\r\n\r\n    struct ConditionalPay {\r\n        uint payTimestamp;   // tag: 1\r\n        address src;   // tag: 2\r\n        address dest;   // tag: 3\r\n        Condition[] conditions;   // tag: 4\r\n        TransferFunction transferFunc;   // tag: 5\r\n        uint resolveDeadline;   // tag: 6\r\n        uint resolveTimeout;   // tag: 7\r\n        address payResolver;   // tag: 8\r\n    } // end struct ConditionalPay\r\n\r\n    function decConditionalPay(bytes memory raw) internal pure returns (ConditionalPay memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(8);\r\n        m.conditions = new Condition[](cnts[4]);\r\n        cnts[4] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.payTimestamp = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 2) {\r\n                m.src = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 3) {\r\n                m.dest = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 4) {\r\n                m.conditions[cnts[4]] = decCondition(buf.decBytes());\r\n                cnts[4]++;\r\n            }\r\n            else if (tag == 5) {\r\n                m.transferFunc = decTransferFunction(buf.decBytes());\r\n            }\r\n            else if (tag == 6) {\r\n                m.resolveDeadline = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 7) {\r\n                m.resolveTimeout = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 8) {\r\n                m.payResolver = Pb._address(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder ConditionalPay\r\n\r\n    struct CondPayResult {\r\n        bytes condPay;   // tag: 1\r\n        uint256 amount;   // tag: 2\r\n    } // end struct CondPayResult\r\n\r\n    function decCondPayResult(bytes memory raw) internal pure returns (CondPayResult memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.condPay = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.amount = Pb._uint256(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder CondPayResult\r\n\r\n    struct VouchedCondPayResult {\r\n        bytes condPayResult;   // tag: 1\r\n        bytes sigOfSrc;   // tag: 2\r\n        bytes sigOfDest;   // tag: 3\r\n    } // end struct VouchedCondPayResult\r\n\r\n    function decVouchedCondPayResult(bytes memory raw) internal pure returns (VouchedCondPayResult memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.condPayResult = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.sigOfSrc = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 3) {\r\n                m.sigOfDest = bytes(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder VouchedCondPayResult\r\n\r\n    struct Condition {\r\n        ConditionType conditionType;   // tag: 1\r\n        bytes32 hashLock;   // tag: 2\r\n        address deployedContractAddress;   // tag: 3\r\n        bytes32 virtualContractAddress;   // tag: 4\r\n        bytes argsQueryFinalization;   // tag: 5\r\n        bytes argsQueryOutcome;   // tag: 6\r\n    } // end struct Condition\r\n\r\n    function decCondition(bytes memory raw) internal pure returns (Condition memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.conditionType = ConditionType(buf.decVarint());\r\n            }\r\n            else if (tag == 2) {\r\n                m.hashLock = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else if (tag == 3) {\r\n                m.deployedContractAddress = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 4) {\r\n                m.virtualContractAddress = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else if (tag == 5) {\r\n                m.argsQueryFinalization = bytes(buf.decBytes());\r\n            }\r\n            else if (tag == 6) {\r\n                m.argsQueryOutcome = bytes(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder Condition\r\n\r\n    struct CooperativeWithdrawInfo {\r\n        bytes32 channelId;   // tag: 1\r\n        uint seqNum;   // tag: 2\r\n        AccountAmtPair withdraw;   // tag: 3\r\n        uint withdrawDeadline;   // tag: 4\r\n        bytes32 recipientChannelId;   // tag: 5\r\n    } // end struct CooperativeWithdrawInfo\r\n\r\n    function decCooperativeWithdrawInfo(bytes memory raw) internal pure returns (CooperativeWithdrawInfo memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.channelId = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.seqNum = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 3) {\r\n                m.withdraw = decAccountAmtPair(buf.decBytes());\r\n            }\r\n            else if (tag == 4) {\r\n                m.withdrawDeadline = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 5) {\r\n                m.recipientChannelId = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder CooperativeWithdrawInfo\r\n\r\n    struct PaymentChannelInitializer {\r\n        TokenDistribution initDistribution;   // tag: 1\r\n        uint openDeadline;   // tag: 2\r\n        uint disputeTimeout;   // tag: 3\r\n        uint msgValueReceiver;   // tag: 4\r\n    } // end struct PaymentChannelInitializer\r\n\r\n    function decPaymentChannelInitializer(bytes memory raw) internal pure returns (PaymentChannelInitializer memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.initDistribution = decTokenDistribution(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.openDeadline = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 3) {\r\n                m.disputeTimeout = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 4) {\r\n                m.msgValueReceiver = uint(buf.decVarint());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder PaymentChannelInitializer\r\n\r\n    struct CooperativeSettleInfo {\r\n        bytes32 channelId;   // tag: 1\r\n        uint seqNum;   // tag: 2\r\n        AccountAmtPair[] settleBalance;   // tag: 3\r\n        uint settleDeadline;   // tag: 4\r\n    } // end struct CooperativeSettleInfo\r\n\r\n    function decCooperativeSettleInfo(bytes memory raw) internal pure returns (CooperativeSettleInfo memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint[] memory cnts = buf.cntTags(4);\r\n        m.settleBalance = new AccountAmtPair[](cnts[3]);\r\n        cnts[3] = 0;  // reset counter for later use\r\n        \r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.channelId = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.seqNum = uint(buf.decVarint());\r\n            }\r\n            else if (tag == 3) {\r\n                m.settleBalance[cnts[3]] = decAccountAmtPair(buf.decBytes());\r\n                cnts[3]++;\r\n            }\r\n            else if (tag == 4) {\r\n                m.settleDeadline = uint(buf.decVarint());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder CooperativeSettleInfo\r\n\r\n    struct ChannelMigrationInfo {\r\n        bytes32 channelId;   // tag: 1\r\n        address fromLedgerAddress;   // tag: 2\r\n        address toLedgerAddress;   // tag: 3\r\n        uint migrationDeadline;   // tag: 4\r\n    } // end struct ChannelMigrationInfo\r\n\r\n    function decChannelMigrationInfo(bytes memory raw) internal pure returns (ChannelMigrationInfo memory m) {\r\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\r\n\r\n        uint tag;\r\n        Pb.WireType wire;\r\n        while (buf.hasMore()) {\r\n            (tag, wire) = buf.decKey();\r\n            if (false) {} // solidity has no switch/case\r\n            else if (tag == 1) {\r\n                m.channelId = Pb._bytes32(buf.decBytes());\r\n            }\r\n            else if (tag == 2) {\r\n                m.fromLedgerAddress = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 3) {\r\n                m.toLedgerAddress = Pb._address(buf.decBytes());\r\n            }\r\n            else if (tag == 4) {\r\n                m.migrationDeadline = uint(buf.decVarint());\r\n            }\r\n            else { buf.skipValue(wire); } // skip value of unknown tag\r\n        }\r\n    } // end decoder ChannelMigrationInfo\r\n\r\n}\r\n\r\n// File: contracts/lib/interface/IPayRegistry.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n/**\r\n * @title PayRegistry interface\r\n */\r\ninterface IPayRegistry {\r\n    function calculatePayId(bytes32 _payHash, address _setter) external pure returns(bytes32);\r\n\r\n    function setPayAmount(bytes32 _payHash, uint _amt) external;\r\n\r\n    function setPayDeadline(bytes32 _payHash, uint _deadline) external;\r\n\r\n    function setPayInfo(bytes32 _payHash, uint _amt, uint _deadline) external;\r\n\r\n    function setPayAmounts(bytes32[] calldata _payHashes, uint[] calldata _amts) external;\r\n\r\n    function setPayDeadlines(bytes32[] calldata _payHashes, uint[] calldata _deadlines) external;\r\n\r\n    function setPayInfos(bytes32[] calldata _payHashes, uint[] calldata _amts, uint[] calldata _deadlines) external;\r\n\r\n    function getPayAmounts(\r\n        bytes32[] calldata _payIds,\r\n        uint _lastPayResolveDeadline\r\n    ) external view returns(uint[] memory);\r\n\r\n    function getPayInfo(bytes32 _payId) external view returns(uint, uint);\r\n\r\n    event PayInfoUpdate(bytes32 indexed payId, uint amount, uint resolveDeadline);\r\n}\r\n\r\n// File: contracts/lib/interface/IPayResolver.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n/**\r\n * @title PayResolver interface\r\n */\r\ninterface IPayResolver {\r\n    function resolvePaymentByConditions(bytes calldata _resolvePayRequest) external;\r\n\r\n    function resolvePaymentByVouchedResult(bytes calldata _vouchedPayResult) external;\r\n\r\n    event ResolvePayment(bytes32 indexed payId, uint amount, uint resolveDeadline);\r\n}\r\n\r\n// File: contracts/lib/interface/IBooleanCond.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title BooleanCond interface\r\n */\r\ninterface IBooleanCond {\r\n    function isFinalized(bytes calldata _query) external view returns (bool);\r\n    \r\n    function getOutcome(bytes calldata _query) external view returns (bool);\r\n}\r\n\r\n// File: contracts/lib/interface/INumericCond.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title NumericCond interface\r\n */\r\ninterface INumericCond {\r\n    function isFinalized(bytes calldata _query) external view returns (bool);\r\n    \r\n    function getOutcome(bytes calldata _query) external view returns (uint);\r\n}\r\n\r\n// File: contracts/lib/interface/IVirtContractResolver.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n/**\r\n * @title VirtContractResolver interface\r\n */\r\ninterface IVirtContractResolver {\r\n    function deploy(bytes calldata _code, uint _nonce) external returns (bool);\r\n    \r\n    function resolve(bytes32 _virtAddr) external view returns (address);\r\n\r\n    event Deploy(bytes32 indexed virtAddr);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/Math.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    /**\r\n    * @dev Returns the largest of two numbers.\r\n    */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the smallest of two numbers.\r\n    */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the average of two numbers. Since these are integers,\r\n    * averages of an even and odd number cannot be represented, and will be\r\n    * rounded down.\r\n    */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Elliptic curve signature operations\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n */\r\n\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * toEthSignedMessageHash\r\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n     * and hash the result\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n// File: contracts/PayResolver.sol\r\n\r\npragma solidity ^0.5.1;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pay Resolver contract\r\n * @notice Payment resolver with different payment resolving logics.\r\n */\r\ncontract PayResolver is IPayResolver {\r\n    using SafeMath for uint;\r\n    using ECDSA for bytes32;\r\n\r\n    IPayRegistry public payRegistry;\r\n    IVirtContractResolver public virtResolver;\r\n\r\n    /**\r\n     * @notice Pay registry constructor\r\n     * @param _registryAddr address of pay registry\r\n     * @param _virtResolverAddr address of virtual contract resolver\r\n     */\r\n    constructor(address _registryAddr, address _virtResolverAddr) public {\r\n        payRegistry = IPayRegistry(_registryAddr);\r\n        virtResolver = IVirtContractResolver(_virtResolverAddr);\r\n    }\r\n\r\n    /**\r\n     * @notice Resolve a payment by onchain getting its condition outcomes\r\n     * @dev HASH_LOCK should only be used for establishing multi-hop payments,\r\n     *   and is always required to be true for all transfer function logic types.\r\n     *   a pay with no condition or only true HASH_LOCK conditions will use max transfer amount.\r\n     *   The preimage order should align at the order of HASH_LOCK conditions in condition array.\r\n     * @param _resolvePayRequest bytes of PbChain.ResolvePayByConditionsRequest\r\n     */\r\n    function resolvePaymentByConditions(bytes calldata _resolvePayRequest) external {\r\n        PbChain.ResolvePayByConditionsRequest memory resolvePayRequest = \r\n            PbChain.decResolvePayByConditionsRequest(_resolvePayRequest);\r\n        PbEntity.ConditionalPay memory pay = PbEntity.decConditionalPay(resolvePayRequest.condPay);\r\n\r\n        // onchain resolve this payment and get result\r\n        uint amount;\r\n        PbEntity.TransferFunctionType funcType = pay.transferFunc.logicType;\r\n        if (funcType == PbEntity.TransferFunctionType.BOOLEAN_AND) {\r\n            amount = _calculateBooleanAndPayment(pay, resolvePayRequest.hashPreimages);\r\n        } else if (funcType == PbEntity.TransferFunctionType.BOOLEAN_OR) {\r\n            amount = _calculateBooleanOrPayment(pay, resolvePayRequest.hashPreimages);\r\n        } else if (_isNumericLogic(funcType)) {\r\n            amount = _calculateNumericLogicPayment(pay, resolvePayRequest.hashPreimages, funcType);\r\n        } else {\r\n            // TODO: support more transfer function types\r\n            assert(false);\r\n        }\r\n\r\n        bytes32 payHash = keccak256(resolvePayRequest.condPay);\r\n        _resolvePayment(pay, payHash, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Resolve a payment by submitting an offchain vouched result\r\n     * @param _vouchedPayResult bytes of PbEntity.VouchedCondPayResult\r\n     */\r\n    function resolvePaymentByVouchedResult(bytes calldata _vouchedPayResult) external {\r\n        PbEntity.VouchedCondPayResult memory vouchedPayResult = \r\n            PbEntity.decVouchedCondPayResult(_vouchedPayResult);\r\n        PbEntity.CondPayResult memory payResult = \r\n            PbEntity.decCondPayResult(vouchedPayResult.condPayResult);\r\n        PbEntity.ConditionalPay memory pay = PbEntity.decConditionalPay(payResult.condPay);\r\n\r\n        require(\r\n            payResult.amount <= pay.transferFunc.maxTransfer.receiver.amt,\r\n            \"Exceed max transfer amount\"\r\n        );\r\n        // check signatures\r\n        bytes32 hash = keccak256(vouchedPayResult.condPayResult).toEthSignedMessageHash();\r\n        address recoveredSrc = hash.recover(vouchedPayResult.sigOfSrc);\r\n        address recoveredDest = hash.recover(vouchedPayResult.sigOfDest);\r\n        require(\r\n            recoveredSrc == address(pay.src) && recoveredDest == address(pay.dest),\r\n            \"Check sigs failed\"\r\n        );\r\n\r\n        bytes32 payHash = keccak256(payResult.condPay);\r\n        _resolvePayment(pay, payHash, payResult.amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function of resolving a payment with given amount\r\n     * @param _pay conditional pay\r\n     * @param _payHash hash of serialized condPay\r\n     * @param _amount payment amount to resolve\r\n     */\r\n    function _resolvePayment(\r\n        PbEntity.ConditionalPay memory _pay,\r\n        bytes32 _payHash,\r\n        uint _amount\r\n    )\r\n        internal\r\n    {\r\n        uint blockNumber = block.number;\r\n        require(blockNumber <= _pay.resolveDeadline, \"Passed pay resolve deadline in condPay msg\");\r\n\r\n        bytes32 payId = _calculatePayId(_payHash, address(this));\r\n        (uint currentAmt, uint currentDeadline) = payRegistry.getPayInfo(payId);\r\n\r\n        // should never resolve a pay before or not reaching onchain resolve deadline\r\n        require(\r\n            currentDeadline == 0 || blockNumber <= currentDeadline,\r\n            \"Passed onchain resolve pay deadline\"\r\n        );\r\n\r\n        if (currentDeadline > 0) {\r\n            // currentDeadline > 0 implies that this pay has been updated\r\n            // payment amount must be monotone increasing\r\n            require(_amount > currentAmt, \"New amount is not larger\");\r\n\r\n            if (_amount == _pay.transferFunc.maxTransfer.receiver.amt) {\r\n                // set resolve deadline = current block number if amount = max\r\n                payRegistry.setPayInfo(_payHash, _amount, blockNumber);\r\n                emit ResolvePayment(payId, _amount, blockNumber);\r\n            } else {\r\n                // should not update the onchain resolve deadline if not max amount\r\n                payRegistry.setPayAmount(_payHash, _amount);\r\n                emit ResolvePayment(payId, _amount, currentDeadline);\r\n            }\r\n        } else {\r\n            uint newDeadline;\r\n            if (_amount == _pay.transferFunc.maxTransfer.receiver.amt) {\r\n                newDeadline = blockNumber;\r\n            } else {\r\n                newDeadline = Math.min(\r\n                    blockNumber.add(_pay.resolveTimeout),\r\n                    _pay.resolveDeadline\r\n                );\r\n                // 0 is reserved for unresolved status of a payment\r\n                require(newDeadline > 0, \"New resolve deadline is 0\");\r\n            }\r\n\r\n            payRegistry.setPayInfo(_payHash, _amount, newDeadline);\r\n            emit ResolvePayment(payId, _amount, newDeadline);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the result amount of BooleanAnd payment\r\n     * @param _pay conditional pay\r\n     * @param _preimages preimages for hash lock conditions\r\n     * @return pay amount\r\n     */\r\n    function _calculateBooleanAndPayment(\r\n        PbEntity.ConditionalPay memory _pay,\r\n        bytes[] memory _preimages\r\n    )\r\n        internal\r\n        view\r\n        returns(uint)\r\n    {\r\n        uint j = 0;\r\n        bool hasFalseContractCond = false;\r\n        for (uint i = 0; i < _pay.conditions.length; i++) {\r\n            PbEntity.Condition memory cond = _pay.conditions[i];\r\n            if (cond.conditionType == PbEntity.ConditionType.HASH_LOCK) {\r\n                require(keccak256(_preimages[j]) == cond.hashLock, \"Wrong preimage\");\r\n                j++;\r\n            } else if (\r\n                cond.conditionType == PbEntity.ConditionType.DEPLOYED_CONTRACT || \r\n                cond.conditionType == PbEntity.ConditionType.VIRTUAL_CONTRACT\r\n            ) {\r\n                address addr = _getCondAddress(cond);\r\n                IBooleanCond dependent = IBooleanCond(addr);\r\n                require(dependent.isFinalized(cond.argsQueryFinalization), \"Condition is not finalized\");\r\n\r\n                if (!dependent.getOutcome(cond.argsQueryOutcome)) {\r\n                    hasFalseContractCond = true;\r\n                }\r\n            } else {\r\n                assert(false);\r\n            }\r\n        }\r\n\r\n        if (hasFalseContractCond) {\r\n            return 0;\r\n        } else {\r\n            return _pay.transferFunc.maxTransfer.receiver.amt;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the result amount of BooleanOr payment\r\n     * @param _pay conditional pay\r\n     * @param _preimages preimages for hash lock conditions\r\n     * @return pay amount\r\n     */\r\n    function _calculateBooleanOrPayment(\r\n        PbEntity.ConditionalPay memory _pay,\r\n        bytes[] memory _preimages\r\n    )\r\n        internal\r\n        view\r\n        returns(uint)\r\n    {\r\n        uint j = 0;\r\n        // whether there are any contract based conditions, i.e. DEPLOYED_CONTRACT or VIRTUAL_CONTRACT\r\n        bool hasContractCond = false;\r\n        bool hasTrueContractCond = false;\r\n        for (uint i = 0; i < _pay.conditions.length; i++) {\r\n            PbEntity.Condition memory cond = _pay.conditions[i];\r\n            if (cond.conditionType == PbEntity.ConditionType.HASH_LOCK) {\r\n                require(keccak256(_preimages[j]) == cond.hashLock, \"Wrong preimage\");\r\n                j++;\r\n            } else if (\r\n                cond.conditionType == PbEntity.ConditionType.DEPLOYED_CONTRACT || \r\n                cond.conditionType == PbEntity.ConditionType.VIRTUAL_CONTRACT\r\n            ) {\r\n                address addr = _getCondAddress(cond);\r\n                IBooleanCond dependent = IBooleanCond(addr);\r\n                require(dependent.isFinalized(cond.argsQueryFinalization), \"Condition is not finalized\");\r\n\r\n                hasContractCond = true;\r\n                if (dependent.getOutcome(cond.argsQueryOutcome)) {\r\n                    hasTrueContractCond = true;\r\n                }\r\n            } else {\r\n                assert(false);\r\n            }\r\n        }\r\n\r\n        if (!hasContractCond || hasTrueContractCond) {\r\n            return _pay.transferFunc.maxTransfer.receiver.amt;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the result amount of numeric logic payment,\r\n     *   including NUMERIC_ADD, NUMERIC_MAX and NUMERIC_MIN\r\n     * @param _pay conditional pay\r\n     * @param _preimages preimages for hash lock conditions\r\n     * @param _funcType transfer function type\r\n     * @return pay amount\r\n     */\r\n    function _calculateNumericLogicPayment(\r\n        PbEntity.ConditionalPay memory _pay,\r\n        bytes[] memory _preimages,\r\n        PbEntity.TransferFunctionType _funcType\r\n    )\r\n        internal\r\n        view\r\n        returns(uint)\r\n    {\r\n        uint amount = 0;\r\n        uint j = 0;\r\n        bool hasContractCond = false;\r\n        for (uint i = 0; i < _pay.conditions.length; i++) {\r\n            PbEntity.Condition memory cond = _pay.conditions[i];\r\n            if (cond.conditionType == PbEntity.ConditionType.HASH_LOCK) {\r\n                require(keccak256(_preimages[j]) == cond.hashLock, \"Wrong preimage\");\r\n                j++;\r\n            } else if (\r\n                cond.conditionType == PbEntity.ConditionType.DEPLOYED_CONTRACT || \r\n                cond.conditionType == PbEntity.ConditionType.VIRTUAL_CONTRACT\r\n            ) {\r\n                address addr = _getCondAddress(cond);\r\n                INumericCond dependent = INumericCond(addr);\r\n                require(dependent.isFinalized(cond.argsQueryFinalization), \"Condition is not finalized\");\r\n\r\n                if (_funcType == PbEntity.TransferFunctionType.NUMERIC_ADD) {\r\n                    amount = amount.add(dependent.getOutcome(cond.argsQueryOutcome));\r\n                } else if (_funcType == PbEntity.TransferFunctionType.NUMERIC_MAX) {\r\n                    amount = Math.max(amount, dependent.getOutcome(cond.argsQueryOutcome));\r\n                } else if (_funcType == PbEntity.TransferFunctionType.NUMERIC_MIN) {\r\n                    if (hasContractCond) {\r\n                        amount = Math.min(amount, dependent.getOutcome(cond.argsQueryOutcome));\r\n                    } else {\r\n                        amount = dependent.getOutcome(cond.argsQueryOutcome);\r\n                    }\r\n                } else {\r\n                    assert(false);\r\n                }\r\n                \r\n                hasContractCond = true;\r\n            } else {\r\n                assert(false);\r\n            }\r\n        }\r\n\r\n        if (hasContractCond) {\r\n            require(amount <= _pay.transferFunc.maxTransfer.receiver.amt, \"Exceed max transfer amount\");\r\n            return amount;\r\n        } else {\r\n            return _pay.transferFunc.maxTransfer.receiver.amt;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the contract address of the condition\r\n     * @param _cond condition\r\n     * @return contract address of the condition\r\n     */\r\n    function _getCondAddress(PbEntity.Condition memory _cond) internal view returns(address) {\r\n        // We need to take into account that contract may not be deployed.\r\n        // However, this is automatically handled for us\r\n        // because calling a non-existent function will cause an revert.\r\n        if (_cond.conditionType == PbEntity.ConditionType.DEPLOYED_CONTRACT) {\r\n            return _cond.deployedContractAddress;\r\n        } else if (_cond.conditionType == PbEntity.ConditionType.VIRTUAL_CONTRACT) {\r\n            return virtResolver.resolve(_cond.virtualContractAddress);\r\n        } else {\r\n            assert(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Check if a function type is numeric logic\r\n     * @param _funcType transfer function type\r\n     * @return true if it is a numeric logic, otherwise false\r\n     */\r\n    function _isNumericLogic(PbEntity.TransferFunctionType _funcType) internal pure returns(bool) {\r\n        return _funcType == PbEntity.TransferFunctionType.NUMERIC_ADD ||\r\n            _funcType == PbEntity.TransferFunctionType.NUMERIC_MAX ||\r\n            _funcType == PbEntity.TransferFunctionType.NUMERIC_MIN;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate pay id\r\n     * @param _payHash hash of serialized condPay\r\n     * @param _setter payment info setter, i.e. pay resolver\r\n     * @return calculated pay id\r\n     */\r\n    function _calculatePayId(bytes32 _payHash, address _setter) internal pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(_payHash, _setter));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_resolvePayRequest\",\"type\":\"bytes\"}],\"name\":\"resolvePaymentByConditions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vouchedPayResult\",\"type\":\"bytes\"}],\"name\":\"resolvePaymentByVouchedResult\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"virtResolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registryAddr\",\"type\":\"address\"},{\"name\":\"_virtResolverAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"payId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"resolveDeadline\",\"type\":\"uint256\"}],\"name\":\"ResolvePayment\",\"type\":\"event\"}]","ContractName":"PayResolver","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000791bedaa0dd173142311005bb65b58c284cc948c000000000000000000000000ad3e2ea53122d7d94df2deb5def84c86449fb7f4","EVMVersion":"byzantium","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://93f898be22b58cd90c9ab0973e537da4563a3f8560e795ecf5776258e9b315fe"}]}