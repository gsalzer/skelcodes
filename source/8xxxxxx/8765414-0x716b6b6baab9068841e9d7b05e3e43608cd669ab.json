{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.11;\r\n\r\ncontract chainLinkOracleCashout{\r\n    address payable owner;\r\n    \r\n    address constant chainLinkToken = 0x514910771AF9Ca656af840dff83E8264EcF986CA;\r\n    address constant dexBlueAddress = 0x000000000000541E251335090AC5B47176AF4f7E;\r\n    \r\n    address oracleAddress;\r\n    address payable arbiterAddress;\r\n    address payable payoutAddress;\r\n    \r\n    uint payoutThreshold      = 1000000000000000000;  //  1 ETH as standard\r\n    uint arbiterTargetBalance = 10000000000000000000; // 10 ETH as standard\r\n    uint arbiterRefillBalance = 9000000000000000000;  //  9 ETH as standard\r\n    \r\n    // We accept ETH sends\r\n    function() external payable {}\r\n    \r\n    constructor(\r\n        address _oracleAddress,\r\n        address payable _arbiterAddress,\r\n        address payable _payoutAddress\r\n    ) public {\r\n        // set initial owner\r\n        owner = msg.sender;\r\n        \r\n        // set oracle and payout addresses\r\n        oracleAddress  = _oracleAddress;\r\n        arbiterAddress = _arbiterAddress;\r\n        payoutAddress  = _payoutAddress;\r\n        \r\n        // dexBlue contract is known and not upgradable so we can grant\r\n        Token(chainLinkToken).approve(dexBlueAddress, 2**256 - 1);\r\n    }\r\n    \r\n    function trade(address sell_token, uint256 sell_amount, address buy_token,  uint256 buy_amount) public payable returns(bool success){\r\n        require(msg.sender == dexBlueAddress);\r\n        \r\n        // Are we offered to trade LINK for ETH\r\n        if(\r\n            buy_token != chainLinkToken\r\n            || sell_token != address(0)\r\n        ){\r\n            return false;\r\n        }\r\n\r\n        uint linkBalance  = Token(chainLinkToken).balanceOf(address(this));     // get this contracts link balance\r\n\r\n        // Check if we need to withdraw from oracle contract\r\n        if(linkBalance < buy_amount){\r\n            uint withdrawable = Oracle(oracleAddress).withdrawable();           // get the link balance available in the oracle contract\r\n\r\n            if(linkBalance + withdrawable < buy_amount){\r\n                return false;\r\n            }\r\n\r\n            // Withdraw the LINK from the oracle contract\r\n            Oracle(oracleAddress).withdraw(address(this), withdrawable);\r\n        }\r\n \r\n        // deposit the link for this trade\r\n        dexBlue(dexBlueAddress).depositToken(chainLinkToken, buy_amount);\r\n        \r\n        // Payout ETH\r\n        payoutIfAboveThreshold();\r\n        \r\n        // return that we accepted the trade\r\n        return true;\r\n    }\r\n    \r\n    // offer the reserve to enter a trade a a taker\r\n    function offer(address sell_token, uint256 sell_amount, address buy_token,  uint256 buy_amount) public returns(bool accept){\r\n        require(msg.sender == dexBlueAddress);\r\n        \r\n        // Are we offered to trade LINK for ETH\r\n        if(\r\n            sell_token   != chainLinkToken\r\n            || buy_token != address(0)\r\n        ){\r\n            return false;\r\n        }\r\n\r\n        uint linkBalance  = Token(chainLinkToken).balanceOf(address(this));     // get this contracts link balance\r\n\r\n        // Check if we need to withdraw from oracle contract\r\n        if(linkBalance < sell_amount){\r\n            uint withdrawable = Oracle(oracleAddress).withdrawable();           // get the link balance available in the oracle contract\r\n\r\n            if(linkBalance + withdrawable < sell_amount){\r\n                return false;\r\n            }\r\n\r\n            // Withdraw the LINK from the oracle contract\r\n            Oracle(oracleAddress).withdraw(address(this), withdrawable);\r\n        }\r\n        \r\n        // deposit the link for this trade\r\n        dexBlue(dexBlueAddress).depositToken(chainLinkToken, sell_amount);\r\n\r\n        // return that we would accept the trade\r\n        return true;\r\n    }\r\n    \r\n    // callback function, to inform the reserve that an offer has been accepted by the maker reserve\r\n    function offerExecuted(address, uint256, address, uint256) public{\r\n        require(msg.sender == dexBlueAddress);\r\n        \r\n        // Payout ETH\r\n        payoutIfAboveThreshold();\r\n    }\r\n\r\n    // payout the acquired ETH if the balance is above the payout threshold\r\n    function payoutIfAboveThreshold() internal {\r\n        // cache this contracts balance in memory\r\n        uint myBalance      = address(this).balance;\r\n        \r\n        if(myBalance >= payoutThreshold){\r\n            // cache arbiter balance in memory\r\n            uint arbiterBalance = arbiterAddress.balance;\r\n            \r\n            // If arbiterAddress needs a refill we send ETH to it\r\n            if(arbiterBalance <= arbiterRefillBalance){\r\n                uint arbiterPayout = arbiterTargetBalance - arbiterBalance;\r\n                \r\n                if(arbiterPayout > myBalance) arbiterPayout = myBalance;\r\n                \r\n                myBalance -= arbiterPayout;\r\n                arbiterAddress.transfer(arbiterPayout);\r\n            }\r\n            \r\n            // Rest goes to payoutAddress\r\n            if(myBalance >= payoutThreshold){\r\n                payoutAddress.transfer(myBalance);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function changePayoutAddress(address payable _payoutAddress) public {\r\n        require(msg.sender == owner);\r\n        \r\n        payoutAddress = _payoutAddress;\r\n    }\r\n    \r\n    function changeArbiterAddress(address payable newArbiterAddress) public {\r\n        require(msg.sender == owner);\r\n        \r\n        arbiterAddress = newArbiterAddress;\r\n    }\r\n    \r\n    function changeArbiterBalances(uint _arbiterTargetBalance, uint _arbiterRefillBalance) public {\r\n        require(\r\n            msg.sender == owner\r\n            && _arbiterTargetBalance > _arbiterRefillBalance\r\n        );\r\n        \r\n        arbiterTargetBalance = _arbiterTargetBalance;\r\n        arbiterRefillBalance = _arbiterRefillBalance;\r\n    }\r\n    \r\n    function changePayoutThreshold(uint _payoutThreshold) public {\r\n        require(msg.sender == owner);\r\n        \r\n        payoutThreshold = _payoutThreshold;\r\n    }\r\n        \r\n    function changeOwner(address payable newOwner) public {\r\n        require(msg.sender == owner);\r\n        \r\n        owner = newOwner;\r\n    }\r\n    \r\n    // Oracle Owner Function Passthrough: \r\n\r\n    function changeOracleOwnership(address payable newOwner) public {\r\n        require(msg.sender == owner);\r\n        \r\n        Oracle(oracleAddress).transferOwnership(newOwner);\r\n    }\r\n    \r\n    function setOracleFulfillmentPermission(address _node, bool _allowed) public {\r\n        require(msg.sender == owner);\r\n        \r\n        Oracle(oracleAddress).setFulfillmentPermission(_node, _allowed);\r\n    }\r\n\r\n    // Token / ETH recovery functions\r\n    \r\n    function approveTokenFor(address token, address spender, uint256 amount) public {\r\n        require(msg.sender == owner);\r\n        \r\n        Token(token).approve(spender, amount);\r\n    }\r\n    \r\n    function withdrawToken(address token, uint256 amount) public {\r\n        require(msg.sender == owner);\r\n        \r\n        require(Token(token).transfer(owner, amount));      // Withdraw ERC20\r\n    }\r\n    \r\n    function withdrawEther(uint256 amount) public {\r\n        require(msg.sender == owner);\r\n        \r\n        require(\r\n            owner.send(amount),\r\n            \"Sending of ETH failed.\"\r\n        );\r\n    }\r\n    \r\n    \r\n    // unused dexBlue reserve functions\r\n    \r\n    // uninsured swap\r\n    function swap(address, uint256, address,  uint256) public payable returns(uint256){\r\n        revert();\r\n    }\r\n    \r\n    // get output amount of swap\r\n    function getSwapOutput(address, uint256, address) public pure returns(uint256){\r\n        return 0;\r\n    }\r\n    \r\n    function tradeWithData(address sell_token, uint256 sell_amount, address buy_token,  uint256 buy_amount, bytes32[] memory) public payable returns(bool success){\r\n        // we dont handle any data, fallback to trade function\r\n        return trade(sell_token, sell_amount, buy_token,  buy_amount);\r\n    }\r\n    \r\n    function offerWithData(address sell_token, uint256 sell_amount, address buy_token,  uint256 buy_amount, bytes32[] memory) public returns(bool accept){\r\n        // we dont handle any data, fallback to the offer function\r\n        return offer(sell_token, sell_amount, buy_token, buy_amount);\r\n    }\r\n}\r\n\r\n\r\ncontract dexBlue{\r\n    function depositToken(address token, uint256 amount) public {}\r\n    function depositEther() public payable{}\r\n    function getTokens() view public returns(address[] memory){}\r\n}\r\n\r\n// dexBlueReserve\r\ncontract dexBlueReserve{\r\n    // insured trade function with fixed outcome\r\n    function trade(address sell_token, uint256 sell_amount, address buy_token,  uint256 buy_amount) public payable returns(bool success){}\r\n    \r\n    // insured trade function with fixed outcome, passes additional data to the reserve\r\n    function tradeWithData(address sell_token, uint256 sell_amount, address buy_token,  uint256 buy_amount, bytes32[] memory data) public payable returns(bool success){}\r\n    \r\n    // offer the reserve to enter a trade a a taker\r\n    function offer(address sell_token, uint256 sell_amount, address buy_token,  uint256 buy_amount) public returns(bool accept){}\r\n    \r\n    // offer the reserve to enter a trade a a taker, passes additional data to the reserve\r\n    function offerWithData(address sell_token, uint256 sell_amount, address buy_token,  uint256 buy_amount, bytes32[] memory data) public returns(bool accept){}\r\n    \r\n    // callback function, to inform the reserve that an offer has been accepted by the maker reserve\r\n    function offerExecuted(address sell_token, uint256 sell_amount, address buy_token,  uint256 buy_amount) public{}\r\n\r\n    // uninsured swap\r\n    function swap(address sell_token, uint256 sell_amount, address buy_token,  uint256 min_output) public payable returns(uint256 output){}\r\n    \r\n    // get output amount of swap\r\n    function getSwapOutput(address sell_token, uint256 sell_amount, address buy_token) public view returns(uint256 output){}\r\n}\r\n\r\n\r\ncontract Oracle {\r\n    \r\n    function withdraw(address _recipient, uint256 _amount) public {}\r\n  \r\n    function withdrawable() external view returns (uint256) {}\r\n    \r\n    function transferOwnership(address newOwner) public {}\r\n\r\n    function setFulfillmentPermission(address _node, bool _allowed) external {}\r\n}\r\n\r\n\r\ncontract Token {\r\n    /** @return total amount of tokens\r\n      */\r\n    function totalSupply() view public returns (uint256 supply) {}\r\n\r\n    /** @param _owner The address from which the balance will be retrieved\r\n      * @return The balance\r\n      */\r\n    function balanceOf(address _owner) view public returns (uint256 balance) {}\r\n\r\n    /** @notice send `_value` token to `_to` from `msg.sender`\r\n      * @param  _to     The address of the recipient\r\n      * @param  _value  The amount of tokens to be transferred\r\n      * @return whether the transfer was successful or not\r\n      */\r\n    function transfer(address _to, uint256 _value) public returns(bool) {}\r\n\r\n    /** @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n      * @param  _from   The address of the sender\r\n      * @param  _to     The address of the recipient\r\n      * @param  _value  The amount of tokens to be transferred\r\n      * @return whether the transfer was successful or not\r\n      */\r\n    function transferFrom(address _from, address _to, uint256 _value)  public returns(bool) {}\r\n\r\n    /** @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n      * @param  _spender The address of the account able to transfer the tokens\r\n      * @param  _value   The amount of wei to be approved for transfer\r\n      * @return whether the approval was successful or not\r\n      */\r\n    function approve(address _spender, uint256 _value) public returns(bool)  {}\r\n\r\n    /** @param  _owner   The address of the account owning tokens\r\n      * @param  _spender The address of the account able to transfer the tokens\r\n      * @return Amount of remaining tokens allowed to spend\r\n      */\r\n    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    uint256 public decimals;\r\n    string public name;\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_payoutAddress\",\"type\":\"address\"}],\"name\":\"changePayoutAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offerExecuted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveTokenFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_node\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"setOracleFulfillmentPermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_arbiterTargetBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_arbiterRefillBalance\",\"type\":\"uint256\"}],\"name\":\"changeArbiterBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sell_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sell_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buy_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buy_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"name\":\"offerWithData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"accept\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sell_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sell_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buy_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buy_amount\",\"type\":\"uint256\"}],\"name\":\"offer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"accept\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newArbiterAddress\",\"type\":\"address\"}],\"name\":\"changeArbiterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOracleOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_payoutThreshold\",\"type\":\"uint256\"}],\"name\":\"changePayoutThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sell_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sell_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buy_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buy_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"name\":\"tradeWithData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sell_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sell_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buy_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buy_amount\",\"type\":\"uint256\"}],\"name\":\"trade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getSwapOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_arbiterAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_payoutAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"chainLinkOracleCashout","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004565300c576431e5228e8aa32642d5739cf9247d000000000000000000000000d45727e3d7405c6ab3b2b3a57474012e1f99848300000000000000000000000048601a2f7ed00b89180abd955e016689f9927b20","Library":"","LicenseType":"None","SwarmSource":"bzzr://2ab94c49b14814b8f492231b53504002c1387b7c9a704c92d9cade044f46e1fc"}]}