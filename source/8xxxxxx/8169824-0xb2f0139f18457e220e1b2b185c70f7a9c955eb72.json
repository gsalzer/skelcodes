{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.8;\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function _implementation() internal view returns(address);\r\n\r\n    /**\r\n    * @dev Fallback function.\r\n    * Implemented entirely in `_fallback`.\r\n    */\r\n    function _fallback() internal {\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function _delegate(address implementation) internal {\r\n        /*solium-disable-next-line security/no-inline-assembly*/\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize)\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize)\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize) }\r\n            default { return(0, returndatasize) }\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        _fallback();\r\n    }\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n    // Version name of the current implementation\r\n    string internal __version;\r\n\r\n    // Address of the current implementation\r\n    address internal __implementation;\r\n\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param _newVersion representing the version name of the upgraded implementation\r\n    * @param _newImplementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(string _newVersion, address indexed _newImplementation);\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param _newVersion representing the version name of the new implementation to be set\r\n    * @param _newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(string memory _newVersion, address _newImplementation) internal {\r\n        require(\r\n            __implementation != _newImplementation && _newImplementation != address(0),\r\n            \"Old address is not allowed and implementation address should not be 0x\"\r\n        );\r\n        require(Address.isContract(_newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\r\n        require(bytes(_newVersion).length > 0, \"Version should not be empty string\");\r\n        require(keccak256(abi.encodePacked(__version)) != keccak256(abi.encodePacked(_newVersion)), \"New version equals to current\");\r\n        __version = _newVersion;\r\n        __implementation = _newImplementation;\r\n        emit Upgraded(_newVersion, _newImplementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n    // Owner of the contract\r\n    address private __upgradeabilityOwner;\r\n\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param _previousOwner representing the address of the previous owner\r\n    * @param _newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address _previousOwner, address _newOwner);\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier ifOwner() {\r\n        if (msg.sender == _upgradeabilityOwner()) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor() public {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function _upgradeabilityOwner() internal view returns(address) {\r\n        return __upgradeabilityOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the owner\r\n    */\r\n    function _setUpgradeabilityOwner(address _newUpgradeabilityOwner) internal {\r\n        require(_newUpgradeabilityOwner != address(0), \"Address should not be 0x\");\r\n        __upgradeabilityOwner = _newUpgradeabilityOwner;\r\n    }\r\n\r\n    /**\r\n    * @notice Internal function to provide the address of the implementation contract\r\n    */\r\n    function _implementation() internal view returns(address) {\r\n        return __implementation;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the proxy owner\r\n    * @return the address of the proxy owner\r\n    */\r\n    function proxyOwner() external ifOwner returns(address) {\r\n        return _upgradeabilityOwner();\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the version name of the current implementation\r\n    * @return string representing the name of the current version\r\n    */\r\n    function version() external ifOwner returns(string memory) {\r\n        return __version;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() external ifOwner returns(address) {\r\n        return _implementation();\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address _newOwner) external ifOwner {\r\n        require(_newOwner != address(0), \"Address should not be 0x\");\r\n        emit ProxyOwnershipTransferred(_upgradeabilityOwner(), _newOwner);\r\n        _setUpgradeabilityOwner(_newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the upgradeability owner to upgrade the current version of the proxy.\r\n    * @param _newVersion representing the version name of the new implementation to be set.\r\n    * @param _newImplementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(string calldata _newVersion, address _newImplementation) external ifOwner {\r\n        _upgradeTo(_newVersion, _newImplementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the upgradeability owner to upgrade the current version of the proxy and call the new implementation\r\n    * to initialize whatever is needed through a low level call.\r\n    * @param _newVersion representing the version name of the new implementation to be set.\r\n    * @param _newImplementation representing the address of the new implementation to be set.\r\n    * @param _data represents the msg.data to bet sent in the low level call. This parameter may include the function\r\n    * signature of the implementation to be called with the needed payload\r\n    */\r\n    function upgradeToAndCall(string calldata _newVersion, address _newImplementation, bytes calldata _data) external payable ifOwner {\r\n        _upgradeToAndCall(_newVersion, _newImplementation, _data);\r\n    }\r\n\r\n    function _upgradeToAndCall(string memory _newVersion, address _newImplementation, bytes memory _data) internal {\r\n        _upgradeTo(_newVersion, _newImplementation);\r\n        bool success;\r\n        /*solium-disable-next-line security/no-call-value*/\r\n        (success, ) = address(this).call.value(msg.value)(_data);\r\n        require(success, \"Fail in executing the function of implementation contract\");\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title It holds the storage variables related to ERC20DividendCheckpoint module\r\n */\r\ncontract ERC20DividendCheckpointStorage {\r\n    // Mapping to token address for each dividend\r\n    mapping(uint256 => address) public dividendTokens;\r\n\r\n}\r\n\r\n/**\r\n * @title Holds the storage variable for the DividendCheckpoint modules (i.e ERC20, Ether)\r\n * @dev abstract contract\r\n */\r\ncontract DividendCheckpointStorage {\r\n\r\n    // Address to which reclaimed dividends and withholding tax is sent\r\n    address payable public wallet;\r\n    uint256 public EXCLUDED_ADDRESS_LIMIT = 150;\r\n\r\n    struct Dividend {\r\n        uint256 checkpointId;\r\n        uint256 created; // Time at which the dividend was created\r\n        uint256 maturity; // Time after which dividend can be claimed - set to 0 to bypass\r\n        uint256 expiry;  // Time until which dividend can be claimed - after this time any remaining amount can be withdrawn by issuer -\r\n                         // set to very high value to bypass\r\n        uint256 amount; // Dividend amount in WEI\r\n        uint256 claimedAmount; // Amount of dividend claimed so far\r\n        uint256 totalSupply; // Total supply at the associated checkpoint (avoids recalculating this)\r\n        bool reclaimed;  // True if expiry has passed and issuer has reclaimed remaining dividend\r\n        uint256 totalWithheld;\r\n        uint256 totalWithheldWithdrawn;\r\n        mapping (address => bool) claimed; // List of addresses which have claimed dividend\r\n        mapping (address => bool) dividendExcluded; // List of addresses which cannot claim dividends\r\n        mapping (address => uint256) withheld; // Amount of tax withheld from claim\r\n        bytes32 name; // Name/title - used for identification\r\n    }\r\n\r\n    // List of all dividends\r\n    Dividend[] public dividends;\r\n\r\n    // List of addresses which cannot claim dividends\r\n    address[] public excluded;\r\n\r\n    // Mapping from address to withholding tax as a percentage * 10**16\r\n    mapping (address => uint256) public withholdingTax;\r\n\r\n    // Total amount of ETH withheld per investor\r\n    mapping(address => uint256) public investorWithheld;\r\n\r\n}\r\n\r\n/**\r\n * @title Utility contract to allow pausing and unpausing of certain functions\r\n */\r\ncontract Pausable {\r\n    event Pause(address account);\r\n    event Unpause(address account);\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n    * @notice Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused, \"Contract is not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice Called by the owner to pause, triggers stopped state\r\n    */\r\n    function _pause() internal whenNotPaused {\r\n        paused = true;\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit Pause(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Called by the owner to unpause, returns to normal state\r\n    */\r\n    function _unpause() internal whenPaused {\r\n        paused = false;\r\n        /*solium-disable-next-line security/no-block-members*/\r\n        emit Unpause(msg.sender);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Interface for all security tokens\r\n */\r\ninterface ISecurityToken {\r\n    // Standard ERC20 interface\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function decimals() external view returns(uint8);\r\n    function totalSupply() external view returns(uint256);\r\n    function balanceOf(address owner) external view returns(uint256);\r\n    function allowance(address owner, address spender) external view returns(uint256);\r\n    function transfer(address to, uint256 value) external returns(bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\r\n    function approve(address spender, uint256 value) external returns(bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\r\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\r\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\r\n     * @return byte Ethereum status code (ESC)\r\n     * @return bytes32 Application specific reason code\r\n     */\r\n    function canTransfer(address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\r\n\r\n    // Emit at the time when module get added\r\n    event ModuleAdded(\r\n        uint8[] _types,\r\n        bytes32 indexed _name,\r\n        address indexed _moduleFactory,\r\n        address _module,\r\n        uint256 _moduleCost,\r\n        uint256 _budget,\r\n        bytes32 _label,\r\n        bool _archived\r\n    );\r\n\r\n    // Emit when the token details get updated\r\n    event UpdateTokenDetails(string _oldDetails, string _newDetails);\r\n    // Emit when the token name get updated\r\n    event UpdateTokenName(string _oldName, string _newName);\r\n    // Emit when the granularity get changed\r\n    event GranularityChanged(uint256 _oldGranularity, uint256 _newGranularity);\r\n    // Emit when is permanently frozen by the issuer\r\n    event FreezeIssuance();\r\n    // Emit when transfers are frozen or unfrozen\r\n    event FreezeTransfers(bool _status);\r\n    // Emit when new checkpoint created\r\n    event CheckpointCreated(uint256 indexed _checkpointId, uint256 _investorLength);\r\n    // Events to log controller actions\r\n    event SetController(address indexed _oldController, address indexed _newController);\r\n    //Event emit when the global treasury wallet address get changed\r\n    event TreasuryWalletChanged(address _oldTreasuryWallet, address _newTreasuryWallet);\r\n    event DisableController();\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event TokenUpgraded(uint8 _major, uint8 _minor, uint8 _patch);\r\n\r\n    // Emit when Module get archived from the securityToken\r\n    event ModuleArchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\r\n    // Emit when Module get unarchived from the securityToken\r\n    event ModuleUnarchived(uint8[] _types, address _module); //Event emitted by the tokenLib.\r\n    // Emit when Module get removed from the securityToken\r\n    event ModuleRemoved(uint8[] _types, address _module); //Event emitted by the tokenLib.\r\n    // Emit when the budget allocated to a module is changed\r\n    event ModuleBudgetChanged(uint8[] _moduleTypes, address _module, uint256 _oldBudget, uint256 _budget); //Event emitted by the tokenLib.\r\n\r\n    // Transfer Events\r\n    event TransferByPartition(\r\n        bytes32 indexed _fromPartition,\r\n        address _operator,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value,\r\n        bytes _data,\r\n        bytes _operatorData\r\n    );\r\n\r\n    // Operator Events\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n\r\n    // Issuance / Redemption Events\r\n    event IssuedByPartition(bytes32 indexed partition, address indexed to, uint256 value, bytes data);\r\n    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes data, bytes operatorData);\r\n\r\n    // Document Events\r\n    event DocumentRemoved(bytes32 indexed _name, string _uri, bytes32 _documentHash);\r\n    event DocumentUpdated(bytes32 indexed _name, string _uri, bytes32 _documentHash);\r\n\r\n    // Controller Events\r\n    event ControllerTransfer(\r\n        address _controller,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value,\r\n        bytes _data,\r\n        bytes _operatorData\r\n    );\r\n\r\n    event ControllerRedemption(\r\n        address _controller,\r\n        address indexed _tokenHolder,\r\n        uint256 _value,\r\n        bytes _data,\r\n        bytes _operatorData\r\n    );\r\n\r\n    // Issuance / Redemption Events\r\n    event Issued(address indexed _operator, address indexed _to, uint256 _value, bytes _data);\r\n    event Redeemed(address indexed _operator, address indexed _from, uint256 _value, bytes _data);\r\n\r\n    /**\r\n     * @notice Initialization function\r\n     * @dev Expected to be called atomically with the proxy being created, by the owner of the token\r\n     * @dev Can only be called once\r\n     */\r\n    function initialize(address _getterDelegate) external;\r\n\r\n    /**\r\n     * @notice The standard provides an on-chain function to determine whether a transfer will succeed,\r\n     * and return details indicating the reason if the transfer is not valid.\r\n     * @param _from The address from whom the tokens get transferred.\r\n     * @param _to The address to which to transfer tokens to.\r\n     * @param _partition The partition from which to transfer tokens\r\n     * @param _value The amount of tokens to transfer from `_partition`\r\n     * @param _data Additional data attached to the transfer of tokens\r\n     * @return ESC (Ethereum Status Code) following the EIP-1066 standard\r\n     * @return Application specific reason codes with additional details\r\n     * @return The partition to which the transferred tokens were allocated for the _to address\r\n     */\r\n    function canTransferByPartition(\r\n        address _from,\r\n        address _to,\r\n        bytes32 _partition,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        view\r\n        returns (byte statusCode, bytes32 reasonCode, bytes32 partition);\r\n\r\n    /**\r\n     * @notice Transfers of securities may fail for a number of reasons. So this function will used to understand the\r\n     * cause of failure by getting the byte value. Which will be the ESC that follows the EIP 1066. ESC can be mapped\r\n     * with a reson string to understand the failure cause, table of Ethereum status code will always reside off-chain\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\r\n     * @return byte Ethereum status code (ESC)\r\n     * @return bytes32 Application specific reason code\r\n     */\r\n    function canTransferFrom(address _from, address _to, uint256 _value, bytes calldata _data) external view returns (byte statusCode, bytes32 reasonCode);\r\n\r\n    /**\r\n     * @notice Used to attach a new document to the contract, or update the URI or hash of an existing attached document\r\n     * @dev Can only be executed by the owner of the contract.\r\n     * @param _name Name of the document. It should be unique always\r\n     * @param _uri Off-chain uri of the document from where it is accessible to investors/advisors to read.\r\n     * @param _documentHash hash (of the contents) of the document.\r\n     */\r\n    function setDocument(bytes32 _name, string calldata _uri, bytes32 _documentHash) external;\r\n\r\n    /**\r\n     * @notice Used to remove an existing document from the contract by giving the name of the document.\r\n     * @dev Can only be executed by the owner of the contract.\r\n     * @param _name Name of the document. It should be unique always\r\n     */\r\n    function removeDocument(bytes32 _name) external;\r\n\r\n    /**\r\n     * @notice Used to return the details of a document with a known name (`bytes32`).\r\n     * @param _name Name of the document\r\n     * @return string The URI associated with the document.\r\n     * @return bytes32 The hash (of the contents) of the document.\r\n     * @return uint256 the timestamp at which the document was last modified.\r\n     */\r\n    function getDocument(bytes32 _name) external view returns (string memory documentUri, bytes32 documentHash, uint256 documentTime);\r\n\r\n    /**\r\n     * @notice Used to retrieve a full list of documents attached to the smart contract.\r\n     * @return bytes32 List of all documents names present in the contract.\r\n     */\r\n    function getAllDocuments() external view returns (bytes32[] memory documentNames);\r\n\r\n    /**\r\n     * @notice In order to provide transparency over whether `controllerTransfer` / `controllerRedeem` are useable\r\n     * or not `isControllable` function will be used.\r\n     * @dev If `isControllable` returns `false` then it always return `false` and\r\n     * `controllerTransfer` / `controllerRedeem` will always revert.\r\n     * @return bool `true` when controller address is non-zero otherwise return `false`.\r\n     */\r\n    function isControllable() external view returns (bool controlled);\r\n\r\n    /**\r\n     * @notice Checks if an address is a module of certain type\r\n     * @param _module Address to check\r\n     * @param _type type to check against\r\n     */\r\n    function isModule(address _module, uint8 _type) external view returns(bool isValid);\r\n\r\n    /**\r\n     * @notice This function must be called to increase the total supply (Corresponds to mint function of ERC20).\r\n     * @dev It only be called by the token issuer or the operator defined by the issuer. ERC1594 doesn't have\r\n     * have the any logic related to operator but its superset ERC1400 have the operator logic and this function\r\n     * is allowed to call by the operator.\r\n     * @param _tokenHolder The account that will receive the created tokens (account should be whitelisted or KYCed).\r\n     * @param _value The amount of tokens need to be issued\r\n     * @param _data The `bytes _data` allows arbitrary data to be submitted alongside the transfer.\r\n     */\r\n    function issue(address _tokenHolder, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice issue new tokens and assigns them to the target _tokenHolder.\r\n     * @dev Can only be called by the issuer or STO attached to the token.\r\n     * @param _tokenHolders A list of addresses to whom the minted tokens will be dilivered\r\n     * @param _values A list of number of tokens get minted and transfer to corresponding address of the investor from _tokenHolders[] list\r\n     * @return success\r\n     */\r\n    function issueMulti(address[] calldata _tokenHolders, uint256[] calldata _values) external;\r\n\r\n    /**\r\n     * @notice Increases totalSupply and the corresponding amount of the specified owners partition\r\n     * @param _partition The partition to allocate the increase in balance\r\n     * @param _tokenHolder The token holder whose balance should be increased\r\n     * @param _value The amount by which to increase the balance\r\n     * @param _data Additional data attached to the minting of tokens\r\n     */\r\n    function issueByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of msg.sender\r\n     * @param _partition The partition to allocate the decrease in balance\r\n     * @param _value The amount by which to decrease the balance\r\n     * @param _data Additional data attached to the burning of tokens\r\n     */\r\n    function redeemByPartition(bytes32 _partition, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\r\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\r\n     * are out of the scope of the ERC1594.\r\n     * @param _value The amount of tokens need to be redeemed\r\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\r\n     */\r\n    function redeem(uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice This function redeem an amount of the token of a msg.sender. For doing so msg.sender may incentivize\r\n     * using different ways that could be implemented with in the `redeem` function definition. But those implementations\r\n     * are out of the scope of the ERC1594.\r\n     * @dev It is analogy to `transferFrom`\r\n     * @param _tokenHolder The account whose tokens gets redeemed.\r\n     * @param _value The amount of tokens need to be redeemed\r\n     * @param _data The `bytes _data` it can be used in the token contract to authenticate the redemption.\r\n     */\r\n    function redeemFrom(address _tokenHolder, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice Decreases totalSupply and the corresponding amount of the specified partition of tokenHolder\r\n     * @dev This function can only be called by the authorised operator.\r\n     * @param _partition The partition to allocate the decrease in balance.\r\n     * @param _tokenHolder The token holder whose balance should be decreased\r\n     * @param _value The amount by which to decrease the balance\r\n     * @param _data Additional data attached to the burning of tokens\r\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\r\n     */\r\n    function operatorRedeemByPartition(\r\n        bytes32 _partition,\r\n        address _tokenHolder,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Validate permissions with PermissionManager if it exists, If no Permission return false\r\n     * @dev Note that IModule withPerm will allow ST owner all permissions anyway\r\n     * @dev this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\r\n     * @param _delegate address of delegate\r\n     * @param _module address of PermissionManager module\r\n     * @param _perm the permissions\r\n     * @return success\r\n     */\r\n    function checkPermission(address _delegate, address _module, bytes32 _perm) external view returns(bool hasPermission);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _module Address of the module\r\n     * @return bytes32 Name\r\n     * @return address Module address\r\n     * @return address Module factory address\r\n     * @return bool Module archived\r\n     * @return uint8 Array of module types\r\n     * @return bytes32 Module label\r\n     */\r\n    function getModule(address _module) external view returns (bytes32 moduleName, address moduleAddress, address factoryAddress, bool isArchived, uint8[] memory moduleTypes, bytes32 moduleLabel);\r\n\r\n    /**\r\n     * @notice Returns module list for a module name\r\n     * @param _name Name of the module\r\n     * @return address[] List of modules with this name\r\n     */\r\n    function getModulesByName(bytes32 _name) external view returns(address[] memory modules);\r\n\r\n    /**\r\n     * @notice Returns module list for a module type\r\n     * @param _type Type of the module\r\n     * @return address[] List of modules with this type\r\n     */\r\n    function getModulesByType(uint8 _type) external view returns(address[] memory modules);\r\n\r\n    /**\r\n     * @notice use to return the global treasury wallet\r\n     */\r\n    function getTreasuryWallet() external view returns(address treasuryWallet);\r\n\r\n    /**\r\n     * @notice Queries totalSupply at a specified checkpoint\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function totalSupplyAt(uint256 _checkpointId) external view returns(uint256 supply);\r\n\r\n    /**\r\n     * @notice Queries balance at a specified checkpoint\r\n     * @param _investor Investor to query balance for\r\n     * @param _checkpointId Checkpoint ID to query as of\r\n     */\r\n    function balanceOfAt(address _investor, uint256 _checkpointId) external view returns(uint256 balance);\r\n\r\n    /**\r\n     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\r\n     */\r\n    function createCheckpoint() external returns(uint256 checkpointId);\r\n\r\n    /**\r\n     * @notice Gets list of times that checkpoints were created\r\n     * @return List of checkpoint times\r\n     */\r\n    function getCheckpointTimes() external view returns(uint256[] memory checkpointTimes);\r\n\r\n    /**\r\n     * @notice returns an array of investors\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @return list of addresses\r\n     */\r\n    function getInvestors() external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice returns an array of investors at a given checkpoint\r\n     * NB - this length may differ from investorCount as it contains all investors that ever held tokens\r\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\r\n     * @return list of investors\r\n     */\r\n    function getInvestorsAt(uint256 _checkpointId) external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice returns an array of investors with non zero balance at a given checkpoint\r\n     * @param _checkpointId Checkpoint id at which investor list is to be populated\r\n     * @param _start Position of investor to start iteration from\r\n     * @param _end Position of investor to stop iteration at\r\n     * @return list of investors\r\n     */\r\n    function getInvestorsSubsetAt(uint256 _checkpointId, uint256 _start, uint256 _end) external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice generates subset of investors\r\n     * NB - can be used in batches if investor list is large\r\n     * @param _start Position of investor to start iteration from\r\n     * @param _end Position of investor to stop iteration at\r\n     * @return list of investors\r\n     */\r\n    function iterateInvestors(uint256 _start, uint256 _end) external view returns(address[] memory investors);\r\n\r\n    /**\r\n     * @notice Gets current checkpoint ID\r\n     * @return Id\r\n     */\r\n    function currentCheckpointId() external view returns(uint256 checkpointId);\r\n\r\n    /**\r\n     * @notice Determines whether `_operator` is an operator for all partitions of `_tokenHolder`\r\n     * @param _operator The operator to check\r\n     * @param _tokenHolder The token holder to check\r\n     * @return Whether the `_operator` is an operator for all partitions of `_tokenHolder`\r\n     */\r\n    function isOperator(address _operator, address _tokenHolder) external view returns (bool isValid);\r\n\r\n    /**\r\n     * @notice Determines whether `_operator` is an operator for a specified partition of `_tokenHolder`\r\n     * @param _partition The partition to check\r\n     * @param _operator The operator to check\r\n     * @param _tokenHolder The token holder to check\r\n     * @return Whether the `_operator` is an operator for a specified partition of `_tokenHolder`\r\n     */\r\n    function isOperatorForPartition(bytes32 _partition, address _operator, address _tokenHolder) external view returns (bool isValid);\r\n\r\n    /**\r\n     * @notice Return all partitions\r\n     * @param _tokenHolder Whom balance need to queried\r\n     * @return List of partitions\r\n     */\r\n    function partitionsOf(address _tokenHolder) external view returns (bytes32[] memory partitions);\r\n\r\n    /**\r\n     * @notice Gets data store address\r\n     * @return data store address\r\n     */\r\n    function dataStore() external view returns (address dataStoreAddress);\r\n\r\n    /**\r\n    * @notice Allows owner to change data store\r\n    * @param _dataStore Address of the token data store\r\n    */\r\n    function changeDataStore(address _dataStore) external;\r\n\r\n\r\n    /**\r\n     * @notice Allows to change the treasury wallet address\r\n     * @param _wallet Ethereum address of the treasury wallet\r\n     */\r\n    function changeTreasuryWallet(address _wallet) external;\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token.\r\n     * @dev Owner can transfer POLY to the ST which will be used to pay for modules that require a POLY fee.\r\n     * @param _tokenContract Address of the ERC20Basic compliance token\r\n     * @param _value Amount of POLY to withdraw\r\n     */\r\n    function withdrawERC20(address _tokenContract, uint256 _value) external;\r\n\r\n    /**\r\n    * @notice Allows owner to increase/decrease POLY approval of one of the modules\r\n    * @param _module Module address\r\n    * @param _change Change in allowance\r\n    * @param _increase True if budget has to be increased, false if decrease\r\n    */\r\n    function changeModuleBudget(address _module, uint256 _change, bool _increase) external;\r\n\r\n    /**\r\n     * @notice Changes the tokenDetails\r\n     * @param _newTokenDetails New token details\r\n     */\r\n    function updateTokenDetails(string calldata _newTokenDetails) external;\r\n\r\n    /**\r\n    * @notice Allows owner to change token name\r\n    * @param _name new name of the token\r\n    */\r\n    function changeName(string calldata _name) external;\r\n\r\n    /**\r\n    * @notice Allows the owner to change token granularity\r\n    * @param _granularity Granularity level of the token\r\n    */\r\n    function changeGranularity(uint256 _granularity) external;\r\n\r\n    /**\r\n     * @notice Freezes all the transfers\r\n     */\r\n    function freezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Un-freezes all the transfers\r\n     */\r\n    function unfreezeTransfers() external;\r\n\r\n    /**\r\n     * @notice Permanently freeze issuance of this security token.\r\n     * @dev It MUST NOT be possible to increase `totalSuppy` after this function is called.\r\n     */\r\n    function freezeIssuance(bytes calldata _signature) external;\r\n\r\n    /**\r\n      * @notice Attachs a module to the SecurityToken\r\n      * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n      * @dev to control restrictions on transfers.\r\n      * @param _moduleFactory is the address of the module factory to be added\r\n      * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n      * @param _maxCost max amount of POLY willing to pay to the module.\r\n      * @param _budget max amount of ongoing POLY willing to assign to the module.\r\n      * @param _label custom module label.\r\n      * @param _archived whether to add the module as an archived module\r\n      */\r\n    function addModuleWithLabel(\r\n        address _moduleFactory,\r\n        bytes calldata _data,\r\n        uint256 _maxCost,\r\n        uint256 _budget,\r\n        bytes32 _label,\r\n        bool _archived\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Function used to attach a module to the security token\r\n     * @dev  E.G.: On deployment (through the STR) ST gets a TransferManager module attached to it\r\n     * @dev to control restrictions on transfers.\r\n     * @dev You are allowed to add a new moduleType if:\r\n     * @dev - there is no existing module of that type yet added\r\n     * @dev - the last member of the module list is replacable\r\n     * @param _moduleFactory is the address of the module factory to be added\r\n     * @param _data is data packed into bytes used to further configure the module (See STO usage)\r\n     * @param _maxCost max amount of POLY willing to pay to module. (WIP)\r\n     * @param _budget max amount of ongoing POLY willing to assign to the module.\r\n     * @param _archived whether to add the module as an archived module\r\n     */\r\n    function addModule(address _moduleFactory, bytes calldata _data, uint256 _maxCost, uint256 _budget, bool _archived) external;\r\n\r\n    /**\r\n    * @notice Archives a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function archiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Unarchives a module attached to the SecurityToken\r\n    * @param _module address of module to unarchive\r\n    */\r\n    function unarchiveModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Removes a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function removeModule(address _module) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to set the controller addresses\r\n     * @param _controller address of the controller\r\n     */\r\n    function setController(address _controller) external;\r\n\r\n    /**\r\n     * @notice This function allows an authorised address to transfer tokens between any two token holders.\r\n     * The transfer must still respect the balances of the token holders (so the transfer must be for at most\r\n     * `balanceOf(_from)` tokens) and potentially also need to respect other transfer restrictions.\r\n     * @dev This function can only be executed by the `controller` address.\r\n     * @param _from Address The address which you want to send tokens from\r\n     * @param _to Address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\r\n     * because use of `_data` parameter is implementation specific).\r\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\r\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\r\n     */\r\n    function controllerTransfer(address _from, address _to, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\r\n\r\n    /**\r\n     * @notice This function allows an authorised address to redeem tokens for any token holder.\r\n     * The redemption must still respect the balances of the token holder (so the redemption must be for at most\r\n     * `balanceOf(_tokenHolder)` tokens) and potentially also need to respect other transfer restrictions.\r\n     * @dev This function can only be executed by the `controller` address.\r\n     * @param _tokenHolder The account whose tokens will be redeemed.\r\n     * @param _value uint256 the amount of tokens need to be redeemed.\r\n     * @param _data data to validate the transfer. (It is not used in this reference implementation\r\n     * because use of `_data` parameter is implementation specific).\r\n     * @param _operatorData data attached to the transfer by controller to emit in event. (It is more like a reason string\r\n     * for calling this function (aka force transfer) which provides the transparency on-chain).\r\n     */\r\n    function controllerRedeem(address _tokenHolder, uint256 _value, bytes calldata _data, bytes calldata _operatorData) external;\r\n\r\n    /**\r\n     * @notice Used by the issuer to permanently disable controller functionality\r\n     * @dev enabled via feature switch \"disableControllerAllowed\"\r\n     */\r\n    function disableController(bytes calldata _signature) external;\r\n\r\n    /**\r\n     * @notice Used to get the version of the securityToken\r\n     */\r\n    function getVersion() external view returns(uint8[] memory version);\r\n\r\n    /**\r\n     * @notice Gets the investor count\r\n     */\r\n    function getInvestorCount() external view returns(uint256 investorCount);\r\n\r\n    /**\r\n     * @notice Gets the holder count (investors with non zero balance)\r\n     */\r\n    function holderCount() external view returns(uint256 count);\r\n\r\n    /**\r\n      * @notice Overloaded version of the transfer function\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n    function transferWithData(address _to, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n      * @notice Overloaded version of the transferFrom function\r\n      * @param _from sender of transfer\r\n      * @param _to receiver of transfer\r\n      * @param _value value of transfer\r\n      * @param _data data to indicate validation\r\n      * @return bool success\r\n      */\r\n    function transferFromWithData(address _from, address _to, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\r\n     * @param _partition The partition from which to transfer tokens\r\n     * @param _to The address to which to transfer tokens to\r\n     * @param _value The amount of tokens to transfer from `_partition`\r\n     * @param _data Additional data attached to the transfer of tokens\r\n     * @return The partition to which the transferred tokens were allocated for the _to address\r\n     */\r\n    function transferByPartition(bytes32 _partition, address _to, uint256 _value, bytes calldata _data) external returns (bytes32 partition);\r\n\r\n    /**\r\n     * @notice Get the balance according to the provided partitions\r\n     * @param _partition Partition which differentiate the tokens.\r\n     * @param _tokenHolder Whom balance need to queried\r\n     * @return Amount of tokens as per the given partitions\r\n     */\r\n    function balanceOfByPartition(bytes32 _partition, address _tokenHolder) external view returns(uint256 balance);\r\n\r\n    /**\r\n      * @notice Provides the granularity of the token\r\n      * @return uint256\r\n      */\r\n    function granularity() external view returns(uint256 granularityAmount);\r\n\r\n    /**\r\n      * @notice Provides the address of the polymathRegistry\r\n      * @return address\r\n      */\r\n    function polymathRegistry() external view returns(address registryAddress);\r\n\r\n    /**\r\n    * @notice Upgrades a module attached to the SecurityToken\r\n    * @param _module address of module to archive\r\n    */\r\n    function upgradeModule(address _module) external;\r\n\r\n    /**\r\n    * @notice Upgrades security token\r\n    */\r\n    function upgradeToken() external;\r\n\r\n    /**\r\n     * @notice A security token issuer can specify that issuance has finished for the token\r\n     * (i.e. no new tokens can be minted or issued).\r\n     * @dev If a token returns FALSE for `isIssuable()` then it MUST always return FALSE in the future.\r\n     * If a token returns FALSE for `isIssuable()` then it MUST never allow additional tokens to be issued.\r\n     * @return bool `true` signifies the minting is allowed. While `false` denotes the end of minting\r\n     */\r\n    function isIssuable() external view returns (bool issuable);\r\n\r\n    /**\r\n     * @notice Authorises an operator for all partitions of `msg.sender`.\r\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\r\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\r\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\r\n     * @param _operator An address which is being authorised.\r\n     */\r\n    function authorizeOperator(address _operator) external;\r\n\r\n    /**\r\n     * @notice Revokes authorisation of an operator previously given for all partitions of `msg.sender`.\r\n     * NB - Allowing investors to authorize an investor to be an operator of all partitions\r\n     * but it doesn't mean we operator is allowed to transfer the LOCKED partition values.\r\n     * Logic for this restriction is written in `operatorTransferByPartition()` function.\r\n     * @param _operator An address which is being de-authorised\r\n     */\r\n    function revokeOperator(address _operator) external;\r\n\r\n    /**\r\n     * @notice Authorises an operator for a given partition of `msg.sender`\r\n     * @param _partition The partition to which the operator is authorised\r\n     * @param _operator An address which is being authorised\r\n     */\r\n    function authorizeOperatorByPartition(bytes32 _partition, address _operator) external;\r\n\r\n    /**\r\n     * @notice Revokes authorisation of an operator previously given for a specified partition of `msg.sender`\r\n     * @param _partition The partition to which the operator is de-authorised\r\n     * @param _operator An address which is being de-authorised\r\n     */\r\n    function revokeOperatorByPartition(bytes32 _partition, address _operator) external;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of tokens from a specified partition from one address to another address\r\n     * @param _partition The partition from which to transfer tokens.\r\n     * @param _from The address from which to transfer tokens from\r\n     * @param _to The address to which to transfer tokens to\r\n     * @param _value The amount of tokens to transfer from `_partition`\r\n     * @param _data Additional data attached to the transfer of tokens\r\n     * @param _operatorData Additional data attached to the transfer of tokens by the operator\r\n     * @return The partition to which the transferred tokens were allocated for the _to address\r\n     */\r\n    function operatorTransferByPartition(\r\n        bytes32 _partition,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        bytes calldata _operatorData\r\n    )\r\n        external\r\n        returns (bytes32 partition);\r\n\r\n    /*\r\n    * @notice Returns if transfers are currently frozen or not\r\n    */\r\n    function transfersFrozen() external view returns (bool isFrozen);\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() external view returns (bool);\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() external view returns (address ownerAddress);\r\n\r\n    function controller() external view returns(address controllerAddress);\r\n\r\n    function moduleRegistry() external view returns(address moduleRegistryAddress);\r\n\r\n    function securityTokenRegistry() external view returns(address securityTokenRegistryAddress);\r\n\r\n    function polyToken() external view returns(address polyTokenAddress);\r\n\r\n    function tokenFactory() external view returns(address tokenFactoryAddress);\r\n\r\n    function getterDelegate() external view returns(address delegate);\r\n\r\n    function controllerDisabled() external view returns(bool isDisabled);\r\n\r\n    function initialized() external view returns(bool isInitialized);\r\n\r\n    function tokenDetails() external view returns(string memory details);\r\n\r\n    function updateFromRegistry() external;\r\n\r\n}\r\n\r\n/**\r\n * @title Storage for Module contract\r\n * @notice Contract is abstract\r\n */\r\ncontract ModuleStorage {\r\n    address public factory;\r\n\r\n    ISecurityToken public securityToken;\r\n\r\n    // Permission flag\r\n    bytes32 public constant ADMIN = \"ADMIN\";\r\n    bytes32 public constant OPERATOR = \"OPERATOR\";\r\n\r\n    bytes32 internal constant TREASURY = 0xaae8817359f3dcb67d050f44f3e49f982e0359d90ca4b5f18569926304aaece6; // keccak256(abi.encodePacked(\"TREASURY_WALLET\"))\r\n\r\n    IERC20 public polyToken;\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param _securityToken Address of the security token\r\n     * @param _polyAddress Address of the polytoken\r\n     */\r\n    constructor(address _securityToken, address _polyAddress) public {\r\n        securityToken = ISecurityToken(_securityToken);\r\n        factory = msg.sender;\r\n        polyToken = IERC20(_polyAddress);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Transfer Manager module for core transfer validation functionality\r\n */\r\ncontract ERC20DividendCheckpointProxy is ERC20DividendCheckpointStorage, DividendCheckpointStorage, ModuleStorage, Pausable, OwnedUpgradeabilityProxy {\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor(\r\n        string memory _version,\r\n        address _securityToken,\r\n        address _polyAddress,\r\n        address _implementation\r\n    )\r\n        public\r\n        ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(_implementation != address(0), \"Implementation address should not be 0x\");\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Transfer Manager module for core transfer validation functionality\r\n */\r\ncontract EtherDividendCheckpointProxy is DividendCheckpointStorage, ModuleStorage, Pausable, OwnedUpgradeabilityProxy {\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor (\r\n        string memory _version,\r\n        address _securityToken,\r\n        address _polyAddress,\r\n        address _implementation\r\n    )\r\n        public\r\n        ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(_implementation != address(0), \"Implementation address should not be 0x\");\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n\r\n}\r\n\r\ncontract PLCRVotingCheckpointStorage {\r\n\r\n    enum Stage { PREP, COMMIT, REVEAL, RESOLVED }\r\n\r\n    struct Ballot {\r\n        uint256 checkpointId; // Checkpoint At which ballot created\r\n        uint256 quorum;       // Should be a multiple of 10 ** 16\r\n        uint64 commitDuration; // no. of seconds the commit stage will live\r\n        uint64 revealDuration; // no. of seconds the reveal stage will live\r\n        uint64 startTime;       // Timestamp at which ballot will come into effect\r\n        uint24 totalProposals;  // Count of proposals allowed for a given ballot\r\n        uint32 totalVoters;     // Count of voters who vote for the given ballot\r\n        bool isActive;          // flag used to turn off/on the ballot\r\n        mapping(uint256 => uint256) proposalToVotes; // Mapping for proposal to total weight collected by the proposal\r\n        mapping(address => Vote) investorToProposal; // mapping for storing vote details of a voter\r\n        mapping(address => bool) exemptedVoters; // Mapping for blacklist voters\r\n    }\r\n\r\n    struct Vote {\r\n        uint256 voteOption;\r\n        bytes32 secretVote;\r\n    }\r\n\r\n    Ballot[] ballots;\r\n}\r\n\r\ncontract VotingCheckpointStorage {\r\n\r\n    mapping(address => uint256) defaultExemptIndex;\r\n    address[] defaultExemptedVoters;\r\n\r\n}\r\n\r\n/**\r\n * @title Voting module for governance\r\n */\r\ncontract PLCRVotingCheckpointProxy is PLCRVotingCheckpointStorage, VotingCheckpointStorage, ModuleStorage, Pausable, OwnedUpgradeabilityProxy {\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor(\r\n        string memory _version,\r\n        address _securityToken,\r\n        address _polyAddress,\r\n        address _implementation\r\n    )\r\n        public\r\n        ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(_implementation != address(0), \"Implementation address should not be 0x\");\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n\r\n}\r\n\r\ncontract WeightedVoteCheckpointStorage {\r\n\r\n    struct Ballot {\r\n        uint256 checkpointId; // Checkpoint At which ballot created\r\n        uint256 quorum;       // Should be a multiple of 10 ** 16\r\n        uint64 startTime;      // Timestamp at which ballot will come into effect\r\n        uint64 endTime;         // Timestamp at which ballot will no more into effect\r\n        uint64 totalProposals;  // Count of proposals allowed for a given ballot\r\n        uint56 totalVoters;     // Count of voters who vote for the given ballot\r\n        bool isActive;          // flag used to turn off/on the ballot\r\n        mapping(uint256 => uint256) proposalToVotes;  // Mapping for proposal to total weight collected by the proposal\r\n        mapping(address => uint256) investorToProposal; // mapping for storing vote details of a voter\r\n        mapping(address => bool) exemptedVoters; // Mapping for blacklist voters\r\n    }\r\n\r\n    Ballot[] ballots;\r\n}\r\n\r\n/**\r\n * @title Voting module for governance\r\n */\r\ncontract WeightedVoteCheckpointProxy is WeightedVoteCheckpointStorage, VotingCheckpointStorage, ModuleStorage, Pausable, OwnedUpgradeabilityProxy {\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor(\r\n        string memory _version,\r\n        address _securityToken,\r\n        address _polyAddress,\r\n        address _implementation\r\n    )\r\n        public\r\n        ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(_implementation != address(0), \"Implementation address should not be 0x\");\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Contract used to store layout for the GeneralPermissionManager storage\r\n */\r\ncontract GeneralPermissionManagerStorage {\r\n\r\n    // Mapping used to hold the permissions on the modules provided to delegate, module add => delegate add => permission bytes32 => bool\r\n    mapping (address => mapping (address => mapping (bytes32 => bool))) public perms;\r\n    // Mapping hold the delagate details\r\n    mapping (address => bytes32) public delegateDetails;\r\n    // Array to track all delegates\r\n    address[] public allDelegates;\r\n\r\n}\r\n\r\n/**\r\n * @title GeneralPermissionManager module Proxy\r\n */\r\ncontract GeneralPermissionManagerProxy is GeneralPermissionManagerStorage, ModuleStorage, Pausable, ReentrancyGuard, OwnedUpgradeabilityProxy {\r\n\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor (\r\n        string memory _version,\r\n        address _securityToken,\r\n        address _polyAddress,\r\n        address _implementation\r\n    )\r\n        public\r\n        ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(\r\n            _implementation != address(0),\r\n            \"Implementation address should not be 0x\"\r\n        );\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Storage layout for the STO contract\r\n */\r\n\r\ncontract STOStorage {\r\n    bytes32 internal constant INVESTORFLAGS = \"INVESTORFLAGS\";\r\n\r\n    mapping (uint8 => bool) public fundRaiseTypes;\r\n    mapping (uint8 => uint256) public fundsRaised;\r\n\r\n    // Start time of the STO\r\n    uint256 public startTime;\r\n    // End time of the STO\r\n    uint256 public endTime;\r\n    // Time STO was paused\r\n    uint256 public pausedTime;\r\n    // Number of individual investors\r\n    uint256 public investorCount;\r\n    // Address where ETH & POLY funds are delivered\r\n    address payable public wallet;\r\n    // Final amount of tokens sold\r\n    uint256 public totalTokensSold;\r\n\r\n}\r\n\r\n/**\r\n * @title Contract used to store layout for the CappedSTO storage\r\n */\r\ncontract CappedSTOStorage {\r\n\r\n    // Determine whether users can invest on behalf of a beneficiary\r\n    bool public allowBeneficialInvestments = false;\r\n    // How many token units a buyer gets (multiplied by 10^18) per wei / base unit of POLY\r\n    // If rate is 10^18, buyer will get 1 token unit for every wei / base unit of poly.\r\n    uint256 public rate;\r\n    //How many token base units this STO will be allowed to sell to investors\r\n    // 1 full token = 10^decimals_of_token base units\r\n    uint256 public cap;\r\n\r\n    mapping (address => uint256) public investors;\r\n\r\n}\r\n\r\n/**\r\n * @title CappedSTO module Proxy\r\n */\r\ncontract CappedSTOProxy is CappedSTOStorage, STOStorage, ModuleStorage, Pausable, ReentrancyGuard, OwnedUpgradeabilityProxy {\r\n\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor(\r\n        string memory _version,\r\n        address _securityToken,\r\n        address _polyAddress,\r\n        address _implementation\r\n    )\r\n        public\r\n        ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(\r\n            _implementation != address(0),\r\n            \"Implementation address should not be 0x\"\r\n        );\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Contract used to store layout for the PreSaleSTO storage\r\n */\r\ncontract PreSaleSTOStorage {\r\n\r\n    mapping (address => uint256) public investors;\r\n\r\n}\r\n\r\n/**\r\n * @title PreSaleSTO module Proxy\r\n */\r\ncontract PreSaleSTOProxy is PreSaleSTOStorage, STOStorage, ModuleStorage, Pausable, ReentrancyGuard, OwnedUpgradeabilityProxy {\r\n\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor (string memory _version, address _securityToken, address _polyAddress, address _implementation)\r\n    public\r\n    ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(\r\n            _implementation != address(0),\r\n            \"Implementation address should not be 0x\"\r\n        );\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Contract used to store layout for the USDTieredSTO storage\r\n */\r\ncontract USDTieredSTOStorage {\r\n\r\n    bytes32 internal constant INVESTORSKEY = 0xdf3a8dd24acdd05addfc6aeffef7574d2de3f844535ec91e8e0f3e45dba96731; //keccak256(abi.encodePacked(\"INVESTORS\"))\r\n    \r\n    /////////////\r\n    // Storage //\r\n    /////////////\r\n    struct Tier {\r\n        // NB rates mentioned below are actually price and are used like price in the logic.\r\n        // How many token units a buyer gets per USD in this tier (multiplied by 10**18)\r\n        uint256 rate;\r\n        // How many token units a buyer gets per USD in this tier (multiplied by 10**18) when investing in POLY up to tokensDiscountPoly\r\n        uint256 rateDiscountPoly;\r\n        // How many tokens are available in this tier (relative to totalSupply)\r\n        uint256 tokenTotal;\r\n        // How many token units are available in this tier (relative to totalSupply) at the ratePerTierDiscountPoly rate\r\n        uint256 tokensDiscountPoly;\r\n        // How many tokens have been minted in this tier (relative to totalSupply)\r\n        uint256 mintedTotal;\r\n        // How many tokens have been minted in this tier (relative to totalSupply) for each fund raise type\r\n        mapping(uint8 => uint256) minted;\r\n        // How many tokens have been minted in this tier (relative to totalSupply) at discounted POLY rate\r\n        uint256 mintedDiscountPoly;\r\n    }\r\n\r\n    mapping(address => uint256) public nonAccreditedLimitUSDOverride;\r\n\r\n    mapping(bytes32 => mapping(bytes32 => string)) oracleKeys;\r\n\r\n    // Determine whether users can invest on behalf of a beneficiary\r\n    bool public allowBeneficialInvestments;\r\n\r\n    // Whether or not the STO has been finalized\r\n    bool public isFinalized;\r\n\r\n    // Address of issuer treasury wallet for unsold tokens\r\n    address public treasuryWallet;\r\n\r\n    // List of stable coin addresses\r\n    IERC20[] internal usdTokens;\r\n\r\n    // Current tier\r\n    uint256 public currentTier;\r\n\r\n    // Amount of USD funds raised\r\n    uint256 public fundsRaisedUSD;\r\n\r\n    // Amount of stable coins raised\r\n    mapping (address => uint256) public stableCoinsRaised;\r\n\r\n    // Amount in USD invested by each address\r\n    mapping(address => uint256) public investorInvestedUSD;\r\n\r\n    // Amount in fund raise type invested by each investor\r\n    mapping(address => mapping(uint8 => uint256)) public investorInvested;\r\n\r\n    // List of active stable coin addresses\r\n    mapping (address => bool) internal usdTokenEnabled;\r\n\r\n    // Default limit in USD for non-accredited investors multiplied by 10**18\r\n    uint256 public nonAccreditedLimitUSD;\r\n\r\n    // Minimum investable amount in USD\r\n    uint256 public minimumInvestmentUSD;\r\n\r\n    // Final amount of tokens returned to issuer\r\n    uint256 public finalAmountReturned;\r\n\r\n    // Array of Tiers\r\n    Tier[] public tiers;\r\n\r\n    // Optional custom Oracles.\r\n    mapping(bytes32 => mapping(bytes32 => address)) customOracles;\r\n}\r\n\r\n/**\r\n * @title USDTiered STO module Proxy\r\n */\r\ncontract USDTieredSTOProxy is USDTieredSTOStorage, STOStorage, ModuleStorage, Pausable, ReentrancyGuard, OwnedUpgradeabilityProxy {\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor (string memory _version, address _securityToken, address _polyAddress, address _implementation) public ModuleStorage(_securityToken, _polyAddress) {\r\n        require(_implementation != address(0), \"Implementation address should not be 0x\");\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Contract used to store layout for the CountTransferManager storage\r\n */\r\ncontract BlacklistTransferManagerStorage {\r\n\r\n    struct BlacklistsDetails {\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 repeatPeriodTime;\r\n    }\r\n\r\n    //hold the different blacklist details corresponds to its name\r\n    mapping(bytes32 => BlacklistsDetails) public blacklists;\r\n\r\n    //hold the different name of blacklist corresponds to a investor\r\n    mapping(address => bytes32[]) investorToBlacklist;\r\n\r\n    //get list of the addresses for a particular blacklist\r\n    mapping(bytes32 => address[]) blacklistToInvestor;\r\n\r\n    //mapping use to store the indexes for different blacklist types for a investor\r\n    mapping(address => mapping(bytes32 => uint256)) investorToIndex;\r\n\r\n    //mapping use to store the indexes for different investor for a blacklist type\r\n    mapping(bytes32 => mapping(address => uint256)) blacklistToIndex;\r\n\r\n    bytes32[] allBlacklists;\r\n\r\n}\r\n\r\n/**\r\n * @title CountTransferManager module Proxy\r\n */\r\ncontract BlacklistTransferManagerProxy is BlacklistTransferManagerStorage, ModuleStorage, Pausable, OwnedUpgradeabilityProxy {\r\n\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor (\r\n        string memory _version,\r\n        address _securityToken,\r\n        address _polyAddress,\r\n        address _implementation\r\n    )\r\n        public\r\n        ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(\r\n            _implementation != address(0),\r\n            \"Implementation address should not be 0x\"\r\n        );\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Contract used to store layout for the CountTransferManager storage\r\n */\r\ncontract CountTransferManagerStorage {\r\n\r\n    // The maximum number of concurrent token holders\r\n    uint256 public maxHolderCount;\r\n\r\n}\r\n\r\n/**\r\n * @title CountTransferManager module Proxy\r\n */\r\ncontract CountTransferManagerProxy is CountTransferManagerStorage, ModuleStorage, Pausable, OwnedUpgradeabilityProxy {\r\n\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor (\r\n        string memory _version,\r\n        address _securityToken,\r\n        address _polyAddress,\r\n        address _implementation\r\n    )\r\n        public\r\n        ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(\r\n            _implementation != address(0),\r\n            \"Implementation address should not be 0x\"\r\n        );\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Transfer Manager module for core transfer validation functionality\r\n */\r\ncontract GeneralTransferManagerStorage {\r\n\r\n    bytes32 public constant WHITELIST = \"WHITELIST\";\r\n    bytes32 public constant INVESTORSKEY = 0xdf3a8dd24acdd05addfc6aeffef7574d2de3f844535ec91e8e0f3e45dba96731; //keccak256(abi.encodePacked(\"INVESTORS\"))\r\n    bytes32 public constant INVESTORFLAGS = \"INVESTORFLAGS\";\r\n    uint256 internal constant ONE = uint256(1);\r\n\r\n    enum TransferType { GENERAL, ISSUANCE, REDEMPTION }\r\n\r\n    //Address from which issuances come\r\n    address public issuanceAddress;\r\n\r\n    // Allows all TimeRestrictions to be offset\r\n    struct Defaults {\r\n        uint64 canSendAfter;\r\n        uint64 canReceiveAfter;\r\n    }\r\n\r\n    // Offset to be applied to all timings (except KYC expiry)\r\n    Defaults public defaults;\r\n\r\n    // Map of used nonces by customer\r\n    mapping(address => mapping(uint256 => bool)) public nonceMap;\r\n\r\n    struct TransferRequirements {\r\n        bool fromValidKYC;\r\n        bool toValidKYC;\r\n        bool fromRestricted;\r\n        bool toRestricted;\r\n    }\r\n\r\n    mapping(uint8 => TransferRequirements) public transferRequirements;\r\n    // General = 0, Issuance = 1, Redemption = 2\r\n}\r\n\r\n/**\r\n * @title Transfer Manager module for core transfer validation functionality\r\n */\r\ncontract GeneralTransferManagerProxy is GeneralTransferManagerStorage, ModuleStorage, Pausable, OwnedUpgradeabilityProxy {\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor(\r\n        string memory _version,\r\n        address _securityToken,\r\n        address _polyAddress,\r\n        address _implementation\r\n    )\r\n        public\r\n        ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(_implementation != address(0), \"Implementation address should not be 0x\");\r\n        _upgradeTo(_version, _implementation);\r\n        transferRequirements[uint8(TransferType.GENERAL)] = TransferRequirements(true, true, true, true);\r\n        transferRequirements[uint8(TransferType.ISSUANCE)] = TransferRequirements(false, true, false, false);\r\n        transferRequirements[uint8(TransferType.REDEMPTION)] = TransferRequirements(true, false, false, false);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Wallet for core vesting escrow functionality\r\n */\r\ncontract LockUpTransferManagerStorage {\r\n\r\n    // a per-user lockup\r\n    struct LockUp {\r\n        uint256 lockupAmount; // Amount to be locked\r\n        uint256 startTime; // when this lockup starts (seconds)\r\n        uint256 lockUpPeriodSeconds; // total period of lockup (seconds)\r\n        uint256 releaseFrequencySeconds; // how often to release a tranche of tokens (seconds)\r\n    }\r\n\r\n    // mapping use to store the lockup details corresponds to lockup name\r\n    mapping (bytes32 => LockUp) public lockups;\r\n    // mapping user addresses to an array of lockups name for that user\r\n    mapping (address => bytes32[]) internal userToLockups;\r\n    // get list of the addresses for a particular lockupName\r\n    mapping (bytes32 => address[]) internal lockupToUsers;\r\n    // holds lockup index corresponds to user address. userAddress => lockupName => lockupIndex\r\n    mapping (address => mapping(bytes32 => uint256)) internal userToLockupIndex;\r\n    // holds the user address index corresponds to the lockup. lockupName => userAddress => userIndex\r\n    mapping (bytes32 => mapping(address => uint256)) internal lockupToUserIndex;\r\n\r\n    bytes32[] lockupArray;\r\n\r\n}\r\n\r\n/**\r\n * @title CountTransferManager module Proxy\r\n */\r\ncontract LockUpTransferManagerProxy is LockUpTransferManagerStorage, ModuleStorage, Pausable, OwnedUpgradeabilityProxy {\r\n\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor (\r\n        string memory _version,\r\n        address _securityToken,\r\n        address _polyAddress,\r\n        address _implementation\r\n    )\r\n        public\r\n        ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(\r\n            _implementation != address(0),\r\n            \"Implementation address should not be 0x\"\r\n        );\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Contract used to store layout for the ManualApprovalTransferManager storage\r\n */\r\ncontract ManualApprovalTransferManagerStorage {\r\n\r\n    //Manual approval is an allowance (that has been approved) with an expiry time\r\n    struct ManualApproval {\r\n        address from;\r\n        address to;\r\n        uint256 allowance;\r\n        uint256 expiryTime;\r\n        bytes32 description;\r\n    }\r\n\r\n    mapping (address => mapping (address => uint256)) public approvalIndex;\r\n\r\n    // An array to track all approvals. It is an unbounded array but it's not a problem as\r\n    // it is never looped through in an onchain call. It is defined as an Array instead of mapping\r\n    // just to make it easier for users to fetch list of all approvals through constant functions.\r\n    ManualApproval[] public approvals;\r\n\r\n}\r\n\r\n/**\r\n @title ManualApprovalTransferManager module Proxy\r\n */\r\ncontract ManualApprovalTransferManagerProxy is ManualApprovalTransferManagerStorage, ModuleStorage, Pausable, OwnedUpgradeabilityProxy {\r\n\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor (\r\n        string memory _version,\r\n        address _securityToken,\r\n        address _polyAddress,\r\n        address _implementation\r\n    )\r\n        public\r\n        ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(\r\n            _implementation != address(0),\r\n            \"Implementation address should not be 0x\"\r\n        );\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Contract used to store layout for the PercentageTransferManager storage\r\n */\r\ncontract PercentageTransferManagerStorage {\r\n\r\n    // Maximum percentage that any holder can have, multiplied by 10**16 - e.g. 20% is 20 * 10**16\r\n    uint256 public maxHolderPercentage;\r\n\r\n    // Ignore transactions which are part of the primary issuance\r\n    bool public allowPrimaryIssuance = true;\r\n\r\n    // Addresses on this list are always able to send / receive tokens\r\n    mapping (address => bool) public whitelist;\r\n\r\n}\r\n\r\n/**\r\n * @title PercentageTransferManager module Proxy\r\n */\r\ncontract PercentageTransferManagerProxy is PercentageTransferManagerStorage, ModuleStorage, Pausable, OwnedUpgradeabilityProxy {\r\n\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor (string memory _version, address _securityToken, address _polyAddress, address _implementation)\r\n    public\r\n    ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(\r\n            _implementation != address(0),\r\n            \"Implementation address should not be 0x\"\r\n        );\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Storage layout for VolumeRestrictionTM\r\n */\r\ncontract VolumeRestrictionTMStorage {\r\n\r\n    enum RestrictionType { Fixed, Percentage }\r\n\r\n    enum TypeOfPeriod { MultipleDays, OneDay, Both }\r\n\r\n    // Store the type of restriction corresponds to token holder address\r\n    mapping(address => TypeOfPeriod) holderToRestrictionType;\r\n\r\n    struct VolumeRestriction {\r\n        // If typeOfRestriction is `Percentage` then allowedTokens will be in\r\n        // the % (w.r.t to totalSupply) with a multiplier of 10**16 . else it\r\n        // will be fixed amount of tokens\r\n        uint256 allowedTokens;\r\n        uint256 startTime;\r\n        uint256 rollingPeriodInDays;\r\n        uint256 endTime;\r\n        RestrictionType typeOfRestriction;\r\n    }\r\n\r\n    struct IndividualRestrictions {\r\n        // Restriction stored corresponds to a particular token holder\r\n        mapping(address => VolumeRestriction) individualRestriction;\r\n        // Daily restriction stored corresponds to a particular token holder\r\n        mapping(address => VolumeRestriction) individualDailyRestriction;\r\n    }\r\n\r\n    // Individual and daily restrictions for investors\r\n    IndividualRestrictions individualRestrictions;\r\n\r\n    struct GlobalRestrictions {\r\n      // Global restriction that applies to all token holders\r\n      VolumeRestriction defaultRestriction;\r\n      // Daily global restriction that applies to all token holders (Total ST traded daily is restricted)\r\n      VolumeRestriction defaultDailyRestriction;\r\n    }\r\n\r\n    // Individual and daily restrictions for investors\r\n    GlobalRestrictions globalRestrictions;\r\n\r\n    struct BucketDetails {\r\n        uint256 lastTradedDayTime;\r\n        uint256 sumOfLastPeriod;   // It is the sum of transacted amount within the last rollingPeriodDays\r\n        uint256 daysCovered;    // No of days covered till (from the startTime of VolumeRestriction)\r\n        uint256 dailyLastTradedDayTime;\r\n        uint256 lastTradedTimestamp; // It is the timestamp at which last transaction get executed\r\n    }\r\n\r\n    struct BucketData {\r\n        // Storing _from => day's timestamp => total amount transact in a day --individual\r\n        mapping(address => mapping(uint256 => uint256)) bucket;\r\n        // Storing _from => day's timestamp => total amount transact in a day --individual\r\n        mapping(address => mapping(uint256 => uint256)) defaultBucket;\r\n        // Storing the information that used to validate the transaction\r\n        mapping(address => BucketDetails) userToBucket;\r\n        // Storing the information related to default restriction\r\n        mapping(address => BucketDetails) defaultUserToBucket;\r\n    }\r\n\r\n    BucketData bucketData;\r\n\r\n    // Hold exempt index\r\n    struct Exemptions {\r\n        mapping(address => uint256) exemptIndex;\r\n        address[] exemptAddresses;\r\n    }\r\n\r\n    Exemptions exemptions;\r\n\r\n}\r\n\r\n/**\r\n * @title Transfer Manager module for core transfer validation functionality\r\n */\r\ncontract VolumeRestrictionTMProxy is VolumeRestrictionTMStorage, ModuleStorage, Pausable, OwnedUpgradeabilityProxy {\r\n\r\n    /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor (string memory _version, address _securityToken, address _polyAddress, address _implementation)\r\n    public\r\n    ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(\r\n            _implementation != address(0),\r\n            \"Implementation address should not be 0x\"\r\n        );\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Wallet for core vesting escrow functionality\r\n */\r\ncontract VestingEscrowWalletStorage {\r\n\r\n    struct Schedule {\r\n        // Name of the template\r\n        bytes32 templateName;\r\n        // Tokens that were already claimed\r\n        uint256 claimedTokens;\r\n        // Start time of the schedule\r\n        uint256 startTime;\r\n    }\r\n\r\n    struct Template {\r\n        // Total amount of tokens\r\n        uint256 numberOfTokens;\r\n        // Schedule duration (How long the schedule will last)\r\n        uint256 duration;\r\n        // Schedule frequency (It is a cliff time period)\r\n        uint256 frequency;\r\n        // Index of the template in an array template names\r\n        uint256 index;\r\n    }\r\n\r\n    // Number of tokens that are hold by the `this` contract but are unassigned to any schedule\r\n    uint256 public unassignedTokens;\r\n    // Address of the Treasury wallet. All of the unassigned token will transfer to that address.\r\n    address public treasuryWallet;\r\n    // List of all beneficiaries who have the schedules running/completed/created\r\n    address[] public beneficiaries;\r\n    // Flag whether beneficiary has been already added or not\r\n    mapping(address => bool) internal beneficiaryAdded;\r\n\r\n    // Holds schedules array corresponds to the affiliate/employee address\r\n    mapping(address => Schedule[]) public schedules;\r\n    // Holds template names array corresponds to the affiliate/employee address\r\n    mapping(address => bytes32[]) internal userToTemplates;\r\n    // Mapping use to store the indexes for different template names for a user.\r\n    // affiliate/employee address => template name => index\r\n    mapping(address => mapping(bytes32 => uint256)) internal userToTemplateIndex;\r\n    // Holds affiliate/employee addresses coressponds to the template name\r\n    mapping(bytes32 => address[]) internal templateToUsers;\r\n    // Mapping use to store the indexes for different users for a template.\r\n    // template name => affiliate/employee address => index\r\n    mapping(bytes32 => mapping(address => uint256)) internal templateToUserIndex;\r\n    // Store the template details corresponds to the template name\r\n    mapping(bytes32 => Template) templates;\r\n\r\n    // List of all template names\r\n    bytes32[] public templateNames;\r\n}\r\n\r\n/**\r\n * @title Escrow wallet module for vesting functionality\r\n */\r\ncontract VestingEscrowWalletProxy is VestingEscrowWalletStorage, ModuleStorage, Pausable, OwnedUpgradeabilityProxy {\r\n     /**\r\n    * @notice Constructor\r\n    * @param _securityToken Address of the security token\r\n    * @param _polyAddress Address of the polytoken\r\n    * @param _implementation representing the address of the new implementation to be set\r\n    */\r\n    constructor (string memory _version, address _securityToken, address _polyAddress, address _implementation)\r\n    public\r\n    ModuleStorage(_securityToken, _polyAddress)\r\n    {\r\n        require(\r\n            _implementation != address(0),\r\n            \"Implementation address should not be 0x\"\r\n        );\r\n        _upgradeTo(_version, _implementation);\r\n    }\r\n }","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"proxyOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"blacklists\",\"outputs\":[{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"repeatPeriodTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVersion\",\"type\":\"string\"},{\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"polyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newVersion\",\"type\":\"string\"},{\"name\":\"_newImplementation\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OPERATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"securityToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferProxyOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_version\",\"type\":\"string\"},{\"name\":\"_securityToken\",\"type\":\"address\"},{\"name\":\"_polyAddress\",\"type\":\"address\"},{\"name\":\"_implementation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"ProxyOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newVersion\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"BlacklistTransferManagerProxy","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000800000000000000000000000009992ec3cf6a55b00978cddf2b27bc6882d88d1ec0000000000000000000000009992ec3cf6a55b00978cddf2b27bc6882d88d1ec0000000000000000000000009992ec3cf6a55b00978cddf2b27bc6882d88d1ec0000000000000000000000000000000000000000000000000000000000000005332e302e30000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://c5fcc013c648354b1a89264ebbb4be1df6003f073986acb16f4f4b22039955e0"}]}