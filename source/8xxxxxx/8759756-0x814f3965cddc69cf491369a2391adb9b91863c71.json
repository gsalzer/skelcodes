{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\n\n\ninterface IERC165 {\n    \n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    \n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    \n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    \n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    \n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n\ncontract IERC721Receiver {\n    \n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        \n        \n        \n\n        uint256 size;\n        \n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        \n        \n        \n        uint256 _value; \n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\ncontract ERC165 is IERC165 {\n    \n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    \n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        \n        \n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    \n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    \n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\ncontract ERC721 is ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    \n    \n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    \n    mapping (uint256 => address) private _tokenOwner;\n\n    \n    mapping (uint256 => address) private _tokenApprovals;\n\n    \n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n    \n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    \n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor () public {\n        \n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    \n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    \n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n\n        return owner;\n    }\n\n    \n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    \n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    \n    function setApprovalForAll(address to, bool approved) public {\n        require(to != msg.sender, \"ERC721: approve to caller\");\n\n        _operatorApprovals[msg.sender][to] = approved;\n        emit ApprovalForAll(msg.sender, to, approved);\n    }\n\n    \n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    \n    function transferFrom(address from, address to, uint256 tokenId) public {\n        \n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    \n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    \n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    \n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    \n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    \n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    \n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    \n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    \n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    \n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    \n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n\ncontract IERC721Enumerable is IERC721 {\n    function totalSupply() public view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) public view returns (uint256);\n}\n\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\n    \n    mapping(address => uint256[]) private _ownedTokens;\n\n    \n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    \n    uint256[] private _allTokens;\n\n    \n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    \n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    \n    constructor () public {\n        \n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    \n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        require(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    \n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    \n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    \n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        super._transferFrom(from, to, tokenId);\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    \n    function _mint(address to, uint256 tokenId) internal {\n        super._mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    \n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\n        \n        _ownedTokensIndex[tokenId] = 0;\n\n        _removeTokenFromAllTokensEnumeration(tokenId);\n    }\n\n    \n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n        return _ownedTokens[owner];\n    }\n\n    \n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    \n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    \n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        \n        \n\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        \n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; \n            _ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n\n        \n        _ownedTokens[from].length--;\n\n        \n        \n    }\n\n    \n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        \n        \n\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        \n        \n        \n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; \n        _allTokensIndex[lastTokenId] = tokenIndex; \n\n        \n        _allTokens.length--;\n        _allTokensIndex[tokenId] = 0;\n    }\n}\n\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n    \n    string private _name;\n\n    \n    string private _symbol;\n\n    \n    mapping(uint256 => string) private _tokenURIs;\n\n    \n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    \n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        \n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    \n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    \n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    \n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        return _tokenURIs[tokenId];\n    }\n\n    \n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = uri;\n    }\n\n    \n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        \n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\n        \n    }\n}\n\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    \n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    \n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    \n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n\ncontract ERC721Mintable is ERC721, MinterRole {\n    \n    function mint(address to, uint256 tokenId) public onlyMinter returns (bool) {\n        _mint(to, tokenId);\n        return true;\n    }\n}\n\ncontract EpicsToken is ERC721Mintable, ERC721Full {\r\n    using Counters for Counters.Counter;\r\n    Counters.Counter private _tokenIds;\r\n\r\n    event TokenLock(string uuid);    \n    event TokenUnlock(string uuid);  \n    event UserVerified(string userToken, address userAddress);  \n    event TokenCreated(string uuid, address to);\r\n    event TokenUpdated(string uuid);\r\n    event TokenDestroyed(string uuid);\r\n    event TokenOwnerSet(address from, address to, string uuid);\r\n    event TradingLock();          \n    event TradingUnlock();        \n\r\n    address public escrow;\r\n    address public admin;\r\n    bool public tradingLocked;\r\n    mapping (string => bool) private uuidExists;        \n    mapping (uint256 => string) private tokenIdToUuid;  \n    mapping (string => uint256) private uuidToTokenId;  \n    mapping (uint256 => bool) private lockedTokens;     \n\r\n    constructor() ERC721Full(\"Epics\", \"EPICS\") public {\r\n        escrow = msg.sender;\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"Only admin can do this.\");\r\n        _;\r\n    }\r\n\r\n    function verifyUser(string memory userToken) public returns (bool) {\r\n        emit UserVerified(userToken, msg.sender);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function getOwnerOfUUID(string memory uuid) public view returns (address) {\r\n        require(uuidExists[uuid], \"UUID does not exist.\");\r\n        uint256 tokenId = uuidToTokenId[uuid];\r\n        return ownerOf(tokenId);\r\n    }\r\n\r\n    \r\n    function getTokenIdOfUUID(string memory uuid) public view returns (uint256) {\r\n        require(uuidExists[uuid], \"UUID does not exist.\");\r\n        return uuidToTokenId[uuid];\r\n    }\r\n\r\n    function getUUIDOfTokenId(uint256 tokenId) public view returns (string memory) {\r\n        require(_exists(tokenId), \"Token does not exist.\");\r\n        return tokenIdToUuid[tokenId];\r\n    }\r\n\r\n    function isTokenLocked(uint256 tokenId) public view returns (bool) {\r\n        require(_exists(tokenId), \"Token does not exist.\");\r\n        return lockedTokens[tokenId];\r\n    }\r\n\r\n    function doesUUIDExist(string memory uuid) public view returns (bool) {\r\n        return uuidExists[uuid];\r\n    }\r\n\r\n    \n    \n    \r\n    function lockTrading() public onlyAdmin {\r\n        require(tradingLocked == false, \"Trading already locked.\");\r\n        tradingLocked = true;\r\n        emit TradingLock();\r\n    }\r\n\r\n    \r\n    function unlockTrading() public onlyAdmin {\r\n        require(tradingLocked == true, \"Trading already unlocked.\");\r\n        tradingLocked = false;\r\n        emit TradingUnlock();\r\n    }\r\n\r\n    function removeMinter(address account) public onlyAdmin {\r\n        _removeMinter(account);\r\n    }\r\n\r\n    function setEscrowAddress(address newEscrow) public onlyAdmin {\r\n        require(newEscrow != address(0));\r\n        escrow = newEscrow;\r\n    }\r\n\r\n    \r\n    function createToken(string memory uuid, address to, string memory uri) public onlyMinter {\r\n        require(!uuidExists[uuid], \"UUID already exists.\");\r\n\r\n        _tokenIds.increment();\r\n        uint256 tokenId = _tokenIds.current();\r\n        mint(to, tokenId);\r\n        _setTokenURI(tokenId, uri);\r\n\r\n        uuidExists[uuid] = true;\r\n        uuidToTokenId[uuid] = tokenId;\r\n\r\n        tokenIdToUuid[tokenId] = uuid;\r\n        lockedTokens[tokenId] = true;\r\n        emit TokenCreated(uuid, to);\r\n    }\r\n\r\n    \r\n    function updateToken(string memory uuid, string memory uri) public onlyMinter {\r\n        require(uuidExists[uuid], \"UUID does not exist.\");\r\n        uint256 tokenId = uuidToTokenId[uuid];\r\n        _setTokenURI(tokenId, uri);\r\n        emit TokenUpdated(uuid);\r\n    }\r\n\r\n    function destroyToken(uint256 tokenId) public onlyMinter {\r\n        require(_exists(tokenId), \"Token does not exist.\");\r\n        require(lockedTokens[tokenId], \"Token must be locked before being destroyed.\");\r\n\r\n        string memory uuid = tokenIdToUuid[tokenId];\r\n        delete uuidExists[uuid];\r\n        delete uuidToTokenId[uuid];\r\n        delete lockedTokens[tokenId];\r\n        _burn(tokenId);\r\n        emit TokenDestroyed(uuid);\r\n    }\r\n\r\n    \r\n    function lockToken(address owner, uint256 tokenId) public onlyMinter {\r\n        require(_exists(tokenId), \"Token does not exist.\");\r\n        require(!lockedTokens[tokenId], \"Token is already locked.\");\r\n        require(ownerOf(tokenId) == owner, \"The owner has changed since it was suppose to be locked.\");\r\n\r\n        \n        lockedTokens[tokenId] = true;\r\n        setTokenOwner(escrow, tokenId);\r\n\r\n        string memory uuid = tokenIdToUuid[tokenId];\r\n        emit TokenLock(uuid);\r\n    }\r\n\r\n    \r\n    function unlockToken(address owner, uint256 tokenId) public onlyMinter {\r\n        require(_exists(tokenId), \"Token does not exist.\");\r\n        require(lockedTokens[tokenId], \"Token is already unlocked.\");\r\n        require(ownerOf(tokenId) == escrow, \"The owner has changed since it was suppose to be locked.\");\r\n\r\n        \n        setTokenOwner(owner, tokenId);\r\n        lockedTokens[tokenId] = false;\r\n\r\n        string memory uuid = tokenIdToUuid[tokenId];\r\n        emit TokenUnlock(uuid);\r\n    }\r\n\r\n    \r\n    function setTokenOwner(address to, uint256 tokenId) public onlyMinter {\r\n        address owner = ownerOf(tokenId);\r\n        _transferFrom(owner, to, tokenId);\r\n\r\n        string memory uuid = tokenIdToUuid[tokenId];\r\n        emit TokenOwnerSet(owner, to, uuid);\r\n    }\r\n\r\n    \n    \n\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        require(!tradingLocked && !lockedTokens[tokenId], \"Token must be unlocked to be transferred.\");\r\n        super.transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) public {\r\n        require(!tradingLocked && !lockedTokens[tokenId], \"Token must be unlocked to be transferred.\");\r\n        super.approve(to, tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(!tradingLocked, \"Trading is locked.\");\r\n        super.setApprovalForAll(to, approved);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getUUIDOfTokenId\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"lockToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isTokenLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"unlockToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uuid\",\"type\":\"string\"}],\"name\":\"doesUUIDExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"setTokenOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradingLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"string\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"createToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uuid\",\"type\":\"string\"}],\"name\":\"getOwnerOfUUID\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockTrading\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"destroyToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"uuid\",\"type\":\"string\"}],\"name\":\"getTokenIdOfUUID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockTrading\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newEscrow\",\"type\":\"address\"}],\"name\":\"setEscrowAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"userToken\",\"type\":\"string\"}],\"name\":\"verifyUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"string\"},{\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"updateToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"string\"}],\"name\":\"TokenLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"string\"}],\"name\":\"TokenUnlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"userToken\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"UserVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"TokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"string\"}],\"name\":\"TokenUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"uuid\",\"type\":\"string\"}],\"name\":\"TokenDestroyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"uuid\",\"type\":\"string\"}],\"name\":\"TokenOwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TradingLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TradingUnlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"EpicsToken","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://72c6ebffbc6c854341e770f524f4b00cadc7d6261ccdc0da356bc91af88aa485"}]}