{"status":"1","message":"OK","result":[{"SourceCode":"//generated by www.structuredeth.com/gift\r\n\r\npragma solidity ^0.4.26;\r\n\r\ninterface CompoundERC20 {\r\n  function approve ( address spender, uint256 amount ) external returns ( bool );\r\n  function mint ( uint256 mintAmount ) external returns ( uint256 );\r\n  function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n}\r\ninterface IKyberNetworkProxy {\r\n    function maxGasPrice() external view returns(uint);\r\n    \r\n    function getUserCapInWei(address user) external view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) external view returns(uint);\r\n    function enabled() external view returns(bool);\r\n    function info(bytes32 id) external view returns(uint);\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) external view returns (uint expectedRate, uint slippageRate);\r\n    function tradeWithHint(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount, uint minConversionRate, address walletId, bytes hint) external payable returns(uint);\r\n    function swapEtherToToken(ERC20 token, uint minRate) external payable returns (uint);\r\n    function swapTokenToEther(ERC20 token, uint tokenQty, uint minRate) external returns (uint);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() public view returns(uint supply);\r\n\r\n    function balanceOf(address _owner) public view returns(uint balance);\r\n\r\n    function transfer(address _to, uint _value) public returns(bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns(bool success);\r\n\r\n    function approve(address _spender, uint _value) public returns(bool success);\r\n\r\n    function allowance(address _owner, address _spender) public view returns(uint remaining);\r\n\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\ncontract GiftOfCompound {\r\n    \r\n    using SafeMath for uint256;\r\n    address theRecipient;\r\n    address theSender;\r\n    bytes PERM_HINT;\r\n    uint256 initialCDaiAmount;\r\n    uint256 theInterestRecipient;\r\n    uint256 theInterestSender;\r\n\r\n    CompoundERC20 cdai;\r\n    \r\n     modifier onlyGiftGroup() {\r\n        if (msg.sender != theSender && msg.sender != theRecipient) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n    \r\n    //if smeone sends eth to this contract, throw it because it will just end up getting locked forever\r\n    function() payable {\r\n        throw;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\r\n    constructor(address recipient, uint256 interestRecipient, uint256 interestSender) public payable {\r\n        \r\n        if(msg.value <= 0){\r\n            throw;\r\n        }\r\n        \r\n        theSender = msg.sender;\r\n        theRecipient = recipient;\r\n        \r\n        theInterestSender = interestSender;\r\n        theInterestRecipient = interestRecipient;\r\n        \r\n        //sum of the interest percentage must be 100 so everyone can get their funds\r\n        if(theInterestRecipient.add(theInterestSender) != 100){\r\n            throw;\r\n        }\r\n        \r\n        \r\n        \r\n        initialCDaiAmount = giftWrap();\r\n        \r\n        \r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) onlyGiftGroup external  returns(bool)  {\r\n        \r\n            //you are not sending more cdai than how much has been deposited.\r\n            uint256 usersPercentage;\r\n            if(msg.sender == theRecipient){\r\n                usersPercentage = theInterestRecipient;\r\n            }\r\n            else{\r\n                usersPercentage = theInterestSender;\r\n                \r\n            }\r\n            \r\n            \r\n            uint256 daiSurplus= cdai.balanceOf(this).sub(initialCDaiAmount);\r\n            uint256 amountDaiSurplusUserCanSend  = daiSurplus.mul(usersPercentage).div(100);\r\n            \r\n            uint256 requestedSurplus = _value.sub(initialCDaiAmount);\r\n           \r\n            if(_value <= initialCDaiAmount){\r\n                require(cdai.transfer(_to, _value));\r\n            }\r\n            \r\n            //you do not enough entitlement to the interest\r\n            else if(requestedSurplus > amountDaiSurplusUserCanSend){\r\n                \r\n                throw;\r\n            }\r\n            else{\r\n                 require(cdai.transfer(_to, _value));\r\n            }\r\n            \r\n            //set initial amount to current amount so that people can keep withdrawing and we can know if they are entiteld to the interest amount\r\n            initialCDaiAmount = cdai.balanceOf(this);\r\n            \r\n        \r\n            return true;\r\n    }\r\n        \r\n    \r\n    function giftWrap() returns (uint256){\r\n      \r\n        ERC20 dai = ERC20(0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359);\r\n        address kyberProxyAddress = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\r\n        IKyberNetworkProxy kyberProxy = IKyberNetworkProxy(kyberProxyAddress);\r\n        cdai = CompoundERC20(0xf5dce57282a584d2746faf1593d3121fcac444dc);\r\n        uint256 ethAmount1 = msg.value;\r\n        PERM_HINT = \"PERM\";\r\n        ERC20 eth = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n        uint daiAmount = kyberProxy.tradeWithHint.value(ethAmount1)(eth, ethAmount1, dai, this, 8000000000000000000000000000000000000000000000000000000000000000, 0, 0x0000000000000000000000000000000000000004, PERM_HINT);\r\n        dai.approve(address(cdai), 8000000000000000000000000000000000000000000000000000000);\r\n        cdai.mint(daiAmount);\r\n        \r\n        uint256 cdaiAmount = cdai.balanceOf(this);\r\n        return cdaiAmount;\r\n    }\r\n    \r\n    function currentGiftAmount(uint amount) constant external returns (uint256){\r\n        uint256 cDaiMinted = cdai.balanceOf(this);\r\n        return cDaiMinted;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"currentGiftAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"giftWrap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"interestRecipient\",\"type\":\"uint256\"},{\"name\":\"interestSender\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"GiftOfCompound","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000019d73d526fec699f0afe2edfbcd9a96207378131000000000000000000000000000000000000000000000000000000000000005a000000000000000000000000000000000000000000000000000000000000000a","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://9154465933783e65abc720964fa44103136105cd98bec35e1082db036e4da32b"}]}