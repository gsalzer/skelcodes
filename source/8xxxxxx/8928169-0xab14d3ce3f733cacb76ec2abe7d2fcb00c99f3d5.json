{"status":"1","message":"OK","result":[{"SourceCode":"// hevm: flattened sources of /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/end.sol\r\npragma solidity =0.5.12;\r\n\r\n////// /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/lib.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity 0.5.12; */\r\n\r\ncontract LibNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  usr,\r\n        bytes32  indexed  arg1,\r\n        bytes32  indexed  arg2,\r\n        bytes             data\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        _;\r\n        assembly {\r\n            // log an 'anonymous' event with a constant 6 words of calldata\r\n            // and four indexed topics: selector, caller, arg1 and arg2\r\n            let mark := msize                         // end of memory ensures zero\r\n            mstore(0x40, add(mark, 288))              // update free memory pointer\r\n            mstore(mark, 0x20)                        // bytes type data offset\r\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n            log4(mark, 288,                           // calldata\r\n                 shl(224, shr(224, calldataload(0))), // msg.sig\r\n                 caller,                              // msg.sender\r\n                 calldataload(4),                     // arg1\r\n                 calldataload(36)                     // arg2\r\n                )\r\n        }\r\n    }\r\n}\r\n\r\n////// /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/end.sol\r\n/// end.sol -- global settlement engine\r\n\r\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\r\n// Copyright (C) 2018 Lev Livnev <lev@liv.nev.org.uk>\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity 0.5.12; */\r\n\r\n/* import \"./lib.sol\"; */\r\n\r\ncontract VatLike {\r\n    function dai(address) external view returns (uint256);\r\n    function ilks(bytes32 ilk) external returns (\r\n        uint256 Art,\r\n        uint256 rate,\r\n        uint256 spot,\r\n        uint256 line,\r\n        uint256 dust\r\n    );\r\n    function urns(bytes32 ilk, address urn) external returns (\r\n        uint256 ink,\r\n        uint256 art\r\n    );\r\n    function debt() external returns (uint256);\r\n    function move(address src, address dst, uint256 rad) external;\r\n    function hope(address) external;\r\n    function flux(bytes32 ilk, address src, address dst, uint256 rad) external;\r\n    function grab(bytes32 i, address u, address v, address w, int256 dink, int256 dart) external;\r\n    function suck(address u, address v, uint256 rad) external;\r\n    function cage() external;\r\n}\r\ncontract CatLike {\r\n    function ilks(bytes32) external returns (\r\n        address flip,  // Liquidator\r\n        uint256 chop,  // Liquidation Penalty   [ray]\r\n        uint256 lump   // Liquidation Quantity  [rad]\r\n    );\r\n    function cage() external;\r\n}\r\ncontract PotLike {\r\n    function cage() external;\r\n}\r\ncontract VowLike {\r\n    function cage() external;\r\n}\r\ncontract Flippy {\r\n    function bids(uint id) external view returns (\r\n        uint256 bid,\r\n        uint256 lot,\r\n        address guy,\r\n        uint48  tic,\r\n        uint48  end,\r\n        address usr,\r\n        address gal,\r\n        uint256 tab\r\n    );\r\n    function yank(uint id) external;\r\n}\r\n\r\ncontract PipLike {\r\n    function read() external view returns (bytes32);\r\n}\r\n\r\ncontract Spotty {\r\n    function par() external view returns (uint256);\r\n    function ilks(bytes32) external view returns (\r\n        PipLike pip,\r\n        uint256 mat\r\n    );\r\n    function cage() external;\r\n}\r\n\r\n/*\r\n    This is the `End` and it coordinates Global Settlement. This is an\r\n    involved, stateful process that takes place over nine steps.\r\n\r\n    First we freeze the system and lock the prices for each ilk.\r\n\r\n    1. `cage()`:\r\n        - freezes user entrypoints\r\n        - cancels flop/flap auctions\r\n        - starts cooldown period\r\n        - stops pot drips\r\n\r\n    2. `cage(ilk)`:\r\n       - set the cage price for each `ilk`, reading off the price feed\r\n\r\n    We must process some system state before it is possible to calculate\r\n    the final dai / collateral price. In particular, we need to determine\r\n\r\n      a. `gap`, the collateral shortfall per collateral type by\r\n         considering under-collateralised CDPs.\r\n\r\n      b. `debt`, the outstanding dai supply after including system\r\n         surplus / deficit\r\n\r\n    We determine (a) by processing all under-collateralised CDPs with\r\n    `skim`:\r\n\r\n    3. `skim(ilk, urn)`:\r\n       - cancels CDP debt\r\n       - any excess collateral remains\r\n       - backing collateral taken\r\n\r\n    We determine (b) by processing ongoing dai generating processes,\r\n    i.e. auctions. We need to ensure that auctions will not generate any\r\n    further dai income. In the two-way auction model this occurs when\r\n    all auctions are in the reverse (`dent`) phase. There are two ways\r\n    of ensuring this:\r\n\r\n    4.  i) `wait`: set the cooldown period to be at least as long as the\r\n           longest auction duration, which needs to be determined by the\r\n           cage administrator.\r\n\r\n           This takes a fairly predictable time to occur but with altered\r\n           auction dynamics due to the now varying price of dai.\r\n\r\n       ii) `skip`: cancel all ongoing auctions and seize the collateral.\r\n\r\n           This allows for faster processing at the expense of more\r\n           processing calls. This option allows dai holders to retrieve\r\n           their collateral faster.\r\n\r\n           `skip(ilk, id)`:\r\n            - cancel individual flip auctions in the `tend` (forward) phase\r\n            - retrieves collateral and returns dai to bidder\r\n            - `dent` (reverse) phase auctions can continue normally\r\n\r\n    Option (i), `wait`, is sufficient for processing the system\r\n    settlement but option (ii), `skip`, will speed it up. Both options\r\n    are available in this implementation, with `skip` being enabled on a\r\n    per-auction basis.\r\n\r\n    When a CDP has been processed and has no debt remaining, the\r\n    remaining collateral can be removed.\r\n\r\n    5. `free(ilk)`:\r\n        - remove collateral from the caller's CDP\r\n        - owner can call as needed\r\n\r\n    After the processing period has elapsed, we enable calculation of\r\n    the final price for each collateral type.\r\n\r\n    6. `thaw()`:\r\n       - only callable after processing time period elapsed\r\n       - assumption that all under-collateralised CDPs are processed\r\n       - fixes the total outstanding supply of dai\r\n       - may also require extra CDP processing to cover vow surplus\r\n\r\n    7. `flow(ilk)`:\r\n        - calculate the `fix`, the cash price for a given ilk\r\n        - adjusts the `fix` in the case of deficit / surplus\r\n\r\n    At this point we have computed the final price for each collateral\r\n    type and dai holders can now turn their dai into collateral. Each\r\n    unit dai can claim a fixed basket of collateral.\r\n\r\n    Dai holders must first `pack` some dai into a `bag`. Once packed,\r\n    dai cannot be unpacked and is not transferrable. More dai can be\r\n    added to a bag later.\r\n\r\n    8. `pack(wad)`:\r\n        - put some dai into a bag in preparation for `cash`\r\n\r\n    Finally, collateral can be obtained with `cash`. The bigger the bag,\r\n    the more collateral can be released.\r\n\r\n    9. `cash(ilk, wad)`:\r\n        - exchange some dai from your bag for gems from a specific ilk\r\n        - the number of gems is limited by how big your bag is\r\n*/\r\n\r\ncontract End is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address guy) external note auth { wards[guy] = 1; }\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"End/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    VatLike  public vat;\r\n    CatLike  public cat;\r\n    VowLike  public vow;\r\n    PotLike  public pot;\r\n    Spotty   public spot;\r\n\r\n    uint256  public live;  // cage flag\r\n    uint256  public when;  // time of cage\r\n    uint256  public wait;  // processing cooldown length\r\n    uint256  public debt;  // total outstanding dai following processing [rad]\r\n\r\n    mapping (bytes32 => uint256) public tag;  // cage price           [ray]\r\n    mapping (bytes32 => uint256) public gap;  // collateral shortfall [wad]\r\n    mapping (bytes32 => uint256) public Art;  // total debt per ilk   [wad]\r\n    mapping (bytes32 => uint256) public fix;  // final cash price     [ray]\r\n\r\n    mapping (address => uint256)                      public bag;  // [wad]\r\n    mapping (bytes32 => mapping (address => uint256)) public out;  // [wad]\r\n\r\n    // --- Init ---\r\n    constructor() public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        z = x + y;\r\n        require(z >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, y) / RAY;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, RAY) / y;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, WAD) / y;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, address data) external note auth {\r\n        require(live == 1, \"End/not-live\");\r\n        if (what == \"vat\")  vat = VatLike(data);\r\n        else if (what == \"cat\")  cat = CatLike(data);\r\n        else if (what == \"vow\")  vow = VowLike(data);\r\n        else if (what == \"pot\")  pot = PotLike(data);\r\n        else if (what == \"spot\") spot = Spotty(data);\r\n        else revert(\"End/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 what, uint256 data) external note auth {\r\n        require(live == 1, \"End/not-live\");\r\n        if (what == \"wait\") wait = data;\r\n        else revert(\"End/file-unrecognized-param\");\r\n    }\r\n\r\n    // --- Settlement ---\r\n    function cage() external note auth {\r\n        require(live == 1, \"End/not-live\");\r\n        live = 0;\r\n        when = now;\r\n        vat.cage();\r\n        cat.cage();\r\n        vow.cage();\r\n        spot.cage();\r\n        pot.cage();\r\n    }\r\n\r\n    function cage(bytes32 ilk) external note {\r\n        require(live == 0, \"End/still-live\");\r\n        require(tag[ilk] == 0, \"End/tag-ilk-already-defined\");\r\n        (Art[ilk],,,,) = vat.ilks(ilk);\r\n        (PipLike pip,) = spot.ilks(ilk);\r\n        // par is a ray, pip returns a wad\r\n        tag[ilk] = wdiv(spot.par(), uint(pip.read()));\r\n    }\r\n\r\n    function skip(bytes32 ilk, uint256 id) external note {\r\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\r\n\r\n        (address flipV,,) = cat.ilks(ilk);\r\n        Flippy flip = Flippy(flipV);\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        (uint bid, uint lot,,,, address usr,, uint tab) = flip.bids(id);\r\n\r\n        vat.suck(address(vow), address(vow),  tab);\r\n        vat.suck(address(vow), address(this), bid);\r\n        vat.hope(address(flip));\r\n        flip.yank(id);\r\n\r\n        uint art = tab / rate;\r\n        Art[ilk] = add(Art[ilk], art);\r\n        require(int(lot) >= 0 && int(art) >= 0, \"End/overflow\");\r\n        vat.grab(ilk, usr, address(this), address(vow), int(lot), int(art));\r\n    }\r\n\r\n    function skim(bytes32 ilk, address urn) external note {\r\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        (uint ink, uint art) = vat.urns(ilk, urn);\r\n\r\n        uint owe = rmul(rmul(art, rate), tag[ilk]);\r\n        uint wad = min(ink, owe);\r\n        gap[ilk] = add(gap[ilk], sub(owe, wad));\r\n\r\n        require(wad <= 2**255 && art <= 2**255, \"End/overflow\");\r\n        vat.grab(ilk, urn, address(this), address(vow), -int(wad), -int(art));\r\n    }\r\n\r\n    function free(bytes32 ilk) external note {\r\n        require(live == 0, \"End/still-live\");\r\n        (uint ink, uint art) = vat.urns(ilk, msg.sender);\r\n        require(art == 0, \"End/art-not-zero\");\r\n        require(ink <= 2**255, \"End/overflow\");\r\n        vat.grab(ilk, msg.sender, msg.sender, address(vow), -int(ink), 0);\r\n    }\r\n\r\n    function thaw() external note {\r\n        require(live == 0, \"End/still-live\");\r\n        require(debt == 0, \"End/debt-not-zero\");\r\n        require(vat.dai(address(vow)) == 0, \"End/surplus-not-zero\");\r\n        require(now >= add(when, wait), \"End/wait-not-finished\");\r\n        debt = vat.debt();\r\n    }\r\n    function flow(bytes32 ilk) external note {\r\n        require(debt != 0, \"End/debt-zero\");\r\n        require(fix[ilk] == 0, \"End/fix-ilk-already-defined\");\r\n\r\n        (, uint rate,,,) = vat.ilks(ilk);\r\n        uint256 wad = rmul(rmul(Art[ilk], rate), tag[ilk]);\r\n        fix[ilk] = rdiv(mul(sub(wad, gap[ilk]), RAY), debt);\r\n    }\r\n\r\n    function pack(uint256 wad) external note {\r\n        require(debt != 0, \"End/debt-zero\");\r\n        vat.move(msg.sender, address(vow), mul(wad, RAY));\r\n        bag[msg.sender] = add(bag[msg.sender], wad);\r\n    }\r\n    function cash(bytes32 ilk, uint wad) external note {\r\n        require(fix[ilk] != 0, \"End/fix-ilk-not-defined\");\r\n        vat.flux(ilk, address(this), msg.sender, rmul(wad, fix[ilk]));\r\n        out[ilk][msg.sender] = add(out[ilk][msg.sender], wad);\r\n        require(out[ilk][msg.sender] <= bag[msg.sender], \"End/insufficient-bag-balance\");\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"arg1\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"arg2\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"Art\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"}],\"name\":\"cage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"cash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cat\",\"outputs\":[{\"internalType\":\"contract CatLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"file\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"file\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"fix\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"}],\"name\":\"flow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"}],\"name\":\"free\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"gap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"live\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"out\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"pack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pot\",\"outputs\":[{\"internalType\":\"contract PotLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"urn\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"skip\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spot\",\"outputs\":[{\"internalType\":\"contract Spotty\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"tag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"thaw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vat\",\"outputs\":[{\"internalType\":\"contract VatLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vow\",\"outputs\":[{\"internalType\":\"contract VowLike\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"when\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"End","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://83eb7e4603d27529380489cc2e9eae8c93e78f6883173654442c079532ab1389"}]}