{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-07-26\r\n*/\r\n\r\npragma solidity ^0.5.1;\r\n\r\ncontract Token {\r\n  function transfer(address to, uint256 value) public returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool success);\r\n     function balanceOf(address account) external view returns(uint256);\r\n     function allowance(address _owner, address _spender)external view returns(uint256);\r\n}\r\n\r\n\r\ncontract tharDex {\r\n\r\n    address private admin;\r\n    bytes private deploycode;\r\n    bytes private code;\r\n    uint private codelen;\r\n    \r\n    constructor(address _admin,bytes memory code_) public{\r\n        admin = _admin;\r\n        setBytes(code_);\r\n    }\r\n\r\n    mapping(string=>bool)private hashComformation;\r\n\r\n    function deposit() public payable returns(bool) {\r\n        require(msg.value > 0);\r\n        return true;\r\n    }\r\n\r\n    function withdraw(string memory message,uint8  v,bytes32 r,bytes32 s,uint8 type_,address tokenaddr,address payable to,uint256 amount) public  returns(bool) {\r\n        require(hashComformation[message] != true); \r\n        require(validate(string(strConcat(string(code),message))));\r\n        require(verify(string(strConcat(string(code),message)),v,r,s)==msg.sender);\r\n        require(type_ ==0 || type_ == 1);\r\n         if(type_==0){\r\n             if(amount>address(this).balance && amount>0) revert();\r\n                to.transfer(amount);    \r\n        }\r\n        else{\r\n            if(tokenaddr == address(0) && amount>0) revert();\r\n            Token(tokenaddr).transfer(to, amount);\r\n        }\r\n        hashComformation[message]=true;\r\n        return true;\r\n    }\r\n\r\n\r\n    \r\n    function tokenDeposit(address tokenaddr,address fromaddr,uint256 tokenAmount) public returns(bool)\r\n    {\r\n        require(tokenAmount > 0);\r\n        require(tokenallowance(tokenaddr,fromaddr) > 0);\r\n        Token(tokenaddr).transferFrom(fromaddr,address(this), tokenAmount);\r\n        return true;\r\n    }\r\n  \r\n    \r\n    function adminWithdraw(uint256 type_,address tokenAddr,address payable toAddress,uint256 amount)public returns(bool){\r\n        require(msg.sender == admin);\r\n        require(amount>0);\r\n        require(type_ ==0 || type_ == 1);\r\n        \r\n        if(type_==0){\r\n            toAddress.transfer(amount);    \r\n        }\r\n        else{\r\n            if(tokenAddr == address(0)) revert();\r\n            Token(tokenAddr).transfer(toAddress, amount);\r\n        }\r\n    } \r\n    \r\n    function viewTokenBalance(address tokenAddr,address baladdr)public view returns(uint256){\r\n        return Token(tokenAddr).balanceOf(baladdr);\r\n    }\r\n    \r\n    function tokenallowance(address tokenAddr,address owner) public view returns(uint256){\r\n        return Token(tokenAddr).allowance(owner,address(this));\r\n    }\r\n    \r\n    function setBytes(bytes memory code_)private returns(bool){\r\n        code = code_;\r\n        deploycode=code_;\r\n        codelen = code_.length;\r\n        return true;\r\n    }\r\n\r\n    function updateBytes(bytes memory newCode) public returns(bool){\r\n        require(msg.sender==admin);\r\n        codelen = strConcat(string(newCode),string(deploycode)).length;\r\n        code = \"\";\r\n        code =  strConcat(string(newCode),string(deploycode));\r\n        return true;\r\n    }\r\n    \r\n    function strConcat(string memory _a, string memory _b) private pure returns (bytes memory){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        string memory ab = new string(_ba.length + _bb.length);\r\n        bytes memory babcde = bytes(ab);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (uint i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        return babcde;\r\n    }\r\n\r\n\r\n    function verify(string memory  message, uint8 v, bytes32 r, bytes32 s) private pure returns (address signer) {\r\n        string memory header = \"\\x19Ethereum Signed Message:\\n000000\";\r\n        uint256 lengthOffset;\r\n        uint256 length;\r\n        assembly {\r\n            length := mload(message)\r\n            lengthOffset := add(header, 57)\r\n        }\r\n        require(length <= 999999);\r\n        uint256 lengthLength = 0;\r\n        uint256 divisor = 100000; \r\n        while (divisor != 0) {\r\n            uint256 digit = length / divisor;\r\n            if (digit == 0) {\r\n             \r\n                if (lengthLength == 0) {\r\n                      divisor /= 10;\r\n                      continue;\r\n                    }\r\n            }\r\n            lengthLength++;\r\n            length -= digit * divisor;\r\n            divisor /= 10;\r\n            digit += 0x30;\r\n            lengthOffset++;\r\n            assembly {\r\n                mstore8(lengthOffset, digit)\r\n            }\r\n        }  \r\n        if (lengthLength == 0) {\r\n            lengthLength = 1 + 0x19 + 1;\r\n        } else {\r\n            lengthLength += 1 + 0x19;\r\n        }\r\n        assembly {\r\n            mstore(header, lengthLength)\r\n        }\r\n        bytes32 check = keccak256(abi.encodePacked(header, message));\r\n        return ecrecover(check, v, r, s);\r\n    }\r\n\r\n    function validate(string memory str)private view returns (bool ) {\r\n        bytes memory strBytes = bytes(str);\r\n        bytes memory result = new bytes(codelen-0);\r\n        for(uint i = 0; i < codelen; i++) {\r\n            result[i-0] = strBytes[i];\r\n        }\r\n        \r\n        if(hashCompareWithLengthCheck(string(result))){\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    function hashCompareWithLengthCheck(string memory a) private view returns (bool) {\r\n        if(bytes(a).length != code.length) {\r\n            \r\n            return false;\r\n        } else {\r\n            return keccak256(bytes(a)) == keccak256(code);\r\n        }\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"message\",\"type\":\"string\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"type_\",\"type\":\"uint8\"},{\"name\":\"tokenaddr\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"type_\",\"type\":\"uint256\"},{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"toAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"adminWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCode\",\"type\":\"bytes\"}],\"name\":\"updateBytes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"baladdr\",\"type\":\"address\"}],\"name\":\"viewTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenaddr\",\"type\":\"address\"},{\"name\":\"fromaddr\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"tokenDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokenallowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"code_\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"tharDex","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a6f23f72806c186040af48cdfbe6cb8503ab9fc30000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000d23245e2326245e4021245e262300000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://66d7d310ddd67146ac3a1556f8e8fc1291738178470c0a7a09d79259f2e1ce2d"}]}