{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.10;\r\n\r\ncontract GeoRegistry {\r\n\r\n  // ------------------------------------------------\r\n  //\r\n  // Variables Private\r\n  //\r\n  // ------------------------------------------------\r\n\r\n  // set once in constructor()\r\n  //      geohashChar bitmask\r\n  mapping(bytes1 => bytes4) private charToBitmask;\r\n\r\n  // ------------------------------------------------\r\n  //\r\n  // Variables Public\r\n  //\r\n  // ------------------------------------------------\r\n\r\n  //      zoneCode isEnabled\r\n  mapping(bytes2 => bool) public zoneIsEnabled;\r\n\r\n  bytes2[] public enabledZone;\r\n\r\n  //      zoneCode       geohashFirst3 bitmaskLevel4\r\n  mapping(bytes2 => mapping(bytes3 => bytes4)) public level_2;\r\n\r\n  // ------------------------------------------------\r\n  //\r\n  // Events\r\n  //\r\n  // ------------------------------------------------\r\n\r\n\r\n  // ------------------------------------------------\r\n  //\r\n  // Constructor\r\n  //\r\n  // ------------------------------------------------\r\n\r\n  constructor()\r\n    public\r\n  {\r\n\r\n    // TODO: improve below code? https://medium.com/@imolfar/bitwise-operations-and-bit-manipulation-in-solidity-ethereum-1751f3d2e216\r\n    charToBitmask[bytes1(\"v\")] = hex\"80000000\"; // 2147483648\r\n    charToBitmask[bytes1(\"y\")] = hex\"40000000\"; // 1073741824\r\n    charToBitmask[bytes1(\"z\")] = hex\"20000000\"; // 536870912\r\n    charToBitmask[bytes1(\"b\")] = hex\"10000000\"; // 268435456\r\n    charToBitmask[bytes1(\"c\")] = hex\"08000000\"; // 134217728\r\n    charToBitmask[bytes1(\"f\")] = hex\"04000000\"; // 67108864\r\n    charToBitmask[bytes1(\"g\")] = hex\"02000000\"; // 33554432\r\n    charToBitmask[bytes1(\"u\")] = hex\"01000000\"; // 16777216\r\n    charToBitmask[bytes1(\"t\")] = hex\"00800000\"; // 8388608\r\n    charToBitmask[bytes1(\"w\")] = hex\"00400000\"; // 4194304\r\n    charToBitmask[bytes1(\"x\")] = hex\"00200000\"; // 2097152\r\n    charToBitmask[bytes1(\"8\")] = hex\"00100000\"; // 1048576\r\n    charToBitmask[bytes1(\"9\")] = hex\"00080000\"; // 524288\r\n    charToBitmask[bytes1(\"d\")] = hex\"00040000\"; // 262144\r\n    charToBitmask[bytes1(\"e\")] = hex\"00020000\"; // 131072\r\n    charToBitmask[bytes1(\"s\")] = hex\"00010000\"; // 65536\r\n    charToBitmask[bytes1(\"m\")] = hex\"00008000\"; // 32768\r\n    charToBitmask[bytes1(\"q\")] = hex\"00004000\"; // 16384\r\n    charToBitmask[bytes1(\"r\")] = hex\"00002000\"; // 8192\r\n    charToBitmask[bytes1(\"2\")] = hex\"00001000\"; // 4096\r\n    charToBitmask[bytes1(\"3\")] = hex\"00000800\"; // 2048\r\n    charToBitmask[bytes1(\"6\")] = hex\"00000400\"; // 1024\r\n    charToBitmask[bytes1(\"7\")] = hex\"00000200\"; // 512\r\n    charToBitmask[bytes1(\"k\")] = hex\"00000100\"; // 256\r\n    charToBitmask[bytes1(\"j\")] = hex\"00000080\"; // 128\r\n    charToBitmask[bytes1(\"n\")] = hex\"00000040\"; // 64\r\n    charToBitmask[bytes1(\"p\")] = hex\"00000020\"; // 32\r\n    charToBitmask[bytes1(\"0\")] = hex\"00000010\"; // 16\r\n    charToBitmask[bytes1(\"1\")] = hex\"00000008\"; // 8\r\n    charToBitmask[bytes1(\"4\")] = hex\"00000004\"; // 4\r\n    charToBitmask[bytes1(\"5\")] = hex\"00000002\"; // 2\r\n    charToBitmask[bytes1(\"h\")] = hex\"00000001\"; // 1\r\n  }\r\n\r\n  // ------------------------------------------------\r\n  //\r\n  // Functions Private Getters\r\n  //\r\n  // ------------------------------------------------\r\n\r\n  function toBytes1(bytes memory _bytes, uint _start)\r\n    private\r\n    pure\r\n    returns (bytes1)\r\n  {\r\n    require(_bytes.length >= (_start + 1), \" not long enough\");\r\n    bytes1 tempBytes1;\r\n\r\n    assembly {\r\n        tempBytes1 := mload(add(add(_bytes, 0x20), _start))\r\n    }\r\n\r\n    return tempBytes1;\r\n  }\r\n\r\n  function toBytes3(bytes memory _bytes, uint _start)\r\n    private\r\n    pure\r\n    returns (bytes3)\r\n  {\r\n    require(_bytes.length >= (_start + 3), \" not long enough\");\r\n    bytes3 tempBytes3;\r\n\r\n    assembly {\r\n        tempBytes3 := mload(add(add(_bytes, 0x20), _start))\r\n    }\r\n\r\n    return tempBytes3;\r\n  }\r\n\r\n  // ------------------------------------------------\r\n  //\r\n  // Functions Public Getters\r\n  //\r\n  // ------------------------------------------------\r\n\r\n  function validGeohashChars(bytes memory _bytes)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(_bytes.length > 0, \"_bytes geohash chars is empty array\");\r\n\r\n    for (uint i = 0; i < _bytes.length; i += 1) {\r\n      // find the first occurence of a byte which is not valid geohash character\r\n      if (charToBitmask[toBytes1(_bytes, i)] == bytes4(0)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  function validGeohashChars12(bytes12 _bytes)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    for (uint i = 0; i < 12; i += 1) {\r\n      // find the first occurence of a byte which is not valid geohash character\r\n      if (charToBitmask[bytes1(_bytes[i])] == bytes4(0)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // @NOTE: _zone can be any length of bytes\r\n  function zoneInsideBiggerZone(bytes2 _zoneCode, bytes4 _zone)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    bytes3 level2key = bytes3(_zone);\r\n    bytes4 level3bits = level_2[_zoneCode][level2key];\r\n\r\n    bytes1 fourthByte = bytes1(_zone[3]);\r\n    bytes4 fourthByteBitPosMask = charToBitmask[fourthByte];\r\n\r\n    if (level3bits & fourthByteBitPosMask != 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // ------------------------------------------------\r\n  //\r\n  // Functions Setters Public\r\n  //\r\n  // ------------------------------------------------\r\n  function updateLevel2(bytes2 _zoneCode, bytes3 _letter, bytes4 _subLetters)\r\n    public\r\n  {\r\n    require(!zoneIsEnabled[_zoneCode], \"zone must not be enabled\");\r\n    level_2[_zoneCode][_letter] = _subLetters;\r\n  }\r\n  function updateLevel2batch(bytes2 _zoneCode, bytes3[] memory _letters, bytes4[] memory _subLetters)\r\n    public\r\n  {\r\n    require(!zoneIsEnabled[_zoneCode], \"zone must not be enabled\");\r\n    for (uint i = 0; i < _letters.length; i++) {\r\n      level_2[_zoneCode][_letters[i]] = _subLetters[i];\r\n    }\r\n  }\r\n  function endInit(bytes2 _zoneCode)\r\n    external\r\n  {\r\n    require(!zoneIsEnabled[_zoneCode], \"zone must not be enabled\");\r\n    zoneIsEnabled[_zoneCode] = true;\r\n    enabledZone.push(_zoneCode);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_bytes\",\"type\":\"bytes\"}],\"name\":\"validGeohashChars\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_zoneCode\",\"type\":\"bytes2\"},{\"name\":\"_zone\",\"type\":\"bytes4\"}],\"name\":\"zoneInsideBiggerZone\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes2\"},{\"name\":\"\",\"type\":\"bytes3\"}],\"name\":\"level_2\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_zoneCode\",\"type\":\"bytes2\"},{\"name\":\"_letter\",\"type\":\"bytes3\"},{\"name\":\"_subLetters\",\"type\":\"bytes4\"}],\"name\":\"updateLevel2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes2\"}],\"name\":\"zoneIsEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_zoneCode\",\"type\":\"bytes2\"}],\"name\":\"endInit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bytes\",\"type\":\"bytes12\"}],\"name\":\"validGeohashChars12\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_zoneCode\",\"type\":\"bytes2\"},{\"name\":\"_letters\",\"type\":\"bytes3[]\"},{\"name\":\"_subLetters\",\"type\":\"bytes4[]\"}],\"name\":\"updateLevel2batch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"enabledZone\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes2\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"GeoRegistry","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://f3c69085c18b67fd4d62334ecc07dee588deb7ffde029453821c1ccc8d1c2932"}]}