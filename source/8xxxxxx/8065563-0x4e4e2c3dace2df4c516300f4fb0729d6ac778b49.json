{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\n\r\ninterface TokenInterface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface UniswapExchange {\r\n    function getEthToTokenInputPrice(uint ethSold) external view returns (uint tokenBought);\r\n    function getTokenToEthInputPrice(uint tokenSold) external view returns (uint ethBought);\r\n    function ethToTokenSwapInput(uint minTokens, uint deadline) external payable returns (uint tokenBought);\r\n    function tokenToEthSwapInput(uint tokenSold, uint minEth, uint deadline) external returns (uint ethBought);\r\n}\r\n\r\ninterface KyberInterface {\r\n    function trade(\r\n        address src,\r\n        uint srcAmount,\r\n        address dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n        ) external payable returns (uint);\r\n\r\n    function getExpectedRate(\r\n        address src,\r\n        address dest,\r\n        uint srcQty\r\n        ) external view returns (uint, uint);\r\n}\r\n\r\ninterface Eth2DaiInterface {\r\n    function getBuyAmount(address dest, address src, uint srcAmt) external view returns(uint);\r\n\tfunction getPayAmount(address src, address dest, uint destAmt) external view returns (uint);\r\n\tfunction sellAllAmount(\r\n        address src,\r\n        uint srcAmt,\r\n        address dest,\r\n        uint minDest\r\n    ) external returns (uint destAmt);\r\n\tfunction buyAllAmount(\r\n        address dest,\r\n        uint destAmt,\r\n        address src,\r\n        uint maxSrc\r\n    ) external returns (uint srcAmt);\r\n}\r\n\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Helper is DSMath {\r\n\r\n    address public eth2daiAddr = 0x39755357759cE0d7f32dC8dC45414CCa409AE24e;\r\n    address public uniswapAddr = 0x09cabEC1eAd1c0Ba254B09efb3EE13841712bE14; // Uniswap DAI exchange\r\n    address public kyberAddr = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\r\n    address public ethAddr = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address public wethAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address public daiAddr = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\r\n    address public adminOne = 0xa7615CD307F323172331865181DC8b80a2834324;\r\n    address public adminTwo = 0x7284a8451d9a0e7Dc62B3a71C0593eA2eC5c5638;\r\n    uint public maxSplitAmtEth = 60000000000000000000;\r\n    uint public maxSplitAmtDai = 20000000000000000000000;\r\n    uint public cut = 997500000000000000; // 0.25% charge\r\n\r\n    function setAllowance(TokenInterface _token, address _spender) internal {\r\n        if (_token.allowance(address(this), _spender) != uint(-1)) {\r\n            _token.approve(_spender, uint(-1));\r\n        }\r\n    }\r\n\r\n    modifier isAdmin {\r\n        require(msg.sender == adminOne || msg.sender == adminTwo, \"Not an Admin\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract AdminStuffs is Helper {\r\n\r\n    function setSplitEth(uint amt) public isAdmin {\r\n        maxSplitAmtEth = amt;\r\n    }\r\n\r\n    function setSplitDai(uint amt) public isAdmin {\r\n        maxSplitAmtDai = amt;\r\n    }\r\n\r\n    function withdrawToken(address token) public isAdmin {\r\n        uint daiBal = TokenInterface(token).balanceOf(address(this));\r\n        TokenInterface(token).transfer(msg.sender, daiBal);\r\n    }\r\n\r\n    function withdrawEth() public payable isAdmin {\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n    function changeFee(uint amt) public isAdmin {\r\n        if (amt > 997000000000000000) {\r\n            cut = 997000000000000000; // maximum fees can be 0.3%. Minimum 0%\r\n        } else {\r\n            cut = amt;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract SplitHelper is AdminStuffs {\r\n\r\n    function getBest(address src, address dest, uint srcAmt) public view returns (uint bestExchange, uint destAmt) {\r\n        uint finalSrcAmt = srcAmt;\r\n        if (src == daiAddr) {\r\n            finalSrcAmt = wmul(srcAmt, cut);\r\n        }\r\n        uint eth2DaiPrice = getRateEth2Dai(src, dest, finalSrcAmt);\r\n        uint kyberPrice = getRateKyber(src, dest, finalSrcAmt);\r\n        uint uniswapPrice = getRateUniswap(src, dest, finalSrcAmt);\r\n        if (eth2DaiPrice > kyberPrice) {\r\n            destAmt = eth2DaiPrice;\r\n            bestExchange = 0;\r\n        } else if (kyberPrice >= eth2DaiPrice) {\r\n            destAmt = kyberPrice;\r\n            bestExchange = 1;\r\n        } else {\r\n            destAmt = uniswapPrice;\r\n            bestExchange = 2;\r\n        }\r\n        if (dest == daiAddr) {\r\n            destAmt = wmul(destAmt, cut);\r\n        }\r\n        require(destAmt != 0, \"Dest Amt = 0\");\r\n    }\r\n\r\n    function getRateEth2Dai(address src, address dest, uint srcAmt) internal view returns (uint destAmt) {\r\n        if (src == ethAddr) {\r\n            destAmt = Eth2DaiInterface(eth2daiAddr).getBuyAmount(dest, wethAddr, srcAmt);\r\n        } else if (dest == ethAddr) {\r\n            destAmt = Eth2DaiInterface(eth2daiAddr).getBuyAmount(wethAddr, src, srcAmt);\r\n        }\r\n    }\r\n\r\n    function getRateKyber(address src, address dest, uint srcAmt) internal view returns (uint destAmt) {\r\n        (uint kyberPrice,) = KyberInterface(kyberAddr).getExpectedRate(src, dest, srcAmt);\r\n        destAmt = wmul(srcAmt, kyberPrice);\r\n    }\r\n\r\n    function getRateUniswap(address src, address dest, uint srcAmt) internal view returns (uint destAmt) {\r\n        if (src == ethAddr) {\r\n            destAmt = UniswapExchange(uniswapAddr).getEthToTokenInputPrice(srcAmt);\r\n        } else if (dest == ethAddr) {\r\n            destAmt = UniswapExchange(uniswapAddr).getTokenToEthInputPrice(srcAmt);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract SplitResolver is SplitHelper {\r\n\r\n    event LogEthToDai(uint srcAmt, uint destAmt);\r\n    event LogDaiToEth(uint srcAmt, uint destAmt);\r\n\r\n    function swapEth2Dai(address src, address dest, uint srcAmt) internal returns (uint destAmt) {\r\n        if (src == wethAddr) {\r\n            TokenInterface(wethAddr).deposit.value(srcAmt)();\r\n        }\r\n        destAmt = Eth2DaiInterface(eth2daiAddr).sellAllAmount(\r\n                src,\r\n                srcAmt,\r\n                dest,\r\n                0\r\n            );\r\n    }\r\n\r\n    function swapKyber(address src, address dest, uint srcAmt) internal returns (uint destAmt) {\r\n        uint ethAmt = src == ethAddr ? srcAmt : 0;\r\n        destAmt = KyberInterface(kyberAddr).trade.value(ethAmt)(\r\n                src,\r\n                srcAmt,\r\n                dest,\r\n                address(this),\r\n                2**255,\r\n                0,\r\n                adminOne\r\n            );\r\n    }\r\n\r\n    function swapUniswap(address src, address dest, uint srcAmt) internal returns (uint destAmt) {\r\n        if (src == ethAddr) {\r\n            destAmt = UniswapExchange(uniswapAddr).ethToTokenSwapInput.value(srcAmt)(1, block.timestamp + 1);\r\n        } else if (dest == ethAddr) {\r\n            destAmt = UniswapExchange(uniswapAddr).tokenToEthSwapInput(srcAmt, 1, block.timestamp + 1);\r\n        }\r\n    }\r\n\r\n    function ethToDaiBestSwap(uint bestExchange, uint amtToSwap) internal returns (uint destAmt) {\r\n        if (bestExchange == 0) {\r\n            destAmt += swapEth2Dai(wethAddr, daiAddr, amtToSwap);\r\n        } else if (bestExchange == 1) {\r\n            destAmt += swapKyber(ethAddr, daiAddr, amtToSwap);\r\n        } else {\r\n            destAmt += swapUniswap(ethAddr, daiAddr, amtToSwap);\r\n        }\r\n    }\r\n\r\n    function ethToDaiLoop(uint srcAmt, uint splitAmt, uint finalAmt) internal returns (uint destAmt) {\r\n        if (srcAmt > splitAmt) {\r\n            uint amtToSwap = splitAmt;\r\n            uint nextSrcAmt = srcAmt - splitAmt;\r\n            (uint bestExchange,) = getBest(ethAddr, daiAddr, amtToSwap);\r\n            uint daiBought = finalAmt;\r\n            daiBought += ethToDaiBestSwap(bestExchange, amtToSwap);\r\n            destAmt = ethToDaiLoop(nextSrcAmt, splitAmt, daiBought);\r\n        } else if (srcAmt > 0) {\r\n            (uint bestExchange,) = getBest(ethAddr, daiAddr, srcAmt);\r\n            destAmt = finalAmt;\r\n            destAmt += ethToDaiBestSwap(bestExchange, srcAmt);\r\n        } else {\r\n            destAmt = finalAmt;\r\n        }\r\n    }\r\n\r\n    function daiToEthBestSwap(uint bestExchange, uint amtToSwap) internal returns (uint destAmt) {\r\n        if (bestExchange == 0) {\r\n            destAmt += swapEth2Dai(daiAddr, wethAddr, amtToSwap);\r\n        } else if (bestExchange == 1) {\r\n            destAmt += swapKyber(daiAddr, ethAddr, amtToSwap);\r\n        } else {\r\n            destAmt += swapUniswap(daiAddr, ethAddr, amtToSwap);\r\n        }\r\n    }\r\n\r\n    function daiToEthLoop(uint srcAmt, uint splitAmt, uint finalAmt) internal returns (uint destAmt) {\r\n        if (srcAmt > splitAmt) {\r\n            uint amtToSwap = splitAmt;\r\n            uint nextSrcAmt = srcAmt - splitAmt;\r\n            (uint bestExchange,) = getBest(daiAddr, ethAddr, amtToSwap);\r\n            uint ethBought = finalAmt;\r\n            ethBought += daiToEthBestSwap(bestExchange, amtToSwap);\r\n            destAmt = daiToEthLoop(nextSrcAmt, splitAmt, ethBought);\r\n        } else if (srcAmt > 0) {\r\n            (uint bestExchange,) = getBest(daiAddr, ethAddr, srcAmt);\r\n            destAmt = finalAmt;\r\n            destAmt += daiToEthBestSwap(bestExchange, srcAmt);\r\n        } else {\r\n            destAmt = finalAmt;\r\n        }\r\n    }\r\n\r\n    function wethToEth() internal {\r\n        TokenInterface wethContract = TokenInterface(wethAddr);\r\n        uint balanceWeth = wethContract.balanceOf(address(this));\r\n        if (balanceWeth > 0) {\r\n            wethContract.withdraw(balanceWeth);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Swap is SplitResolver {\r\n\r\n    function ethToDaiSwap(uint splitAmt, uint slippageAmt) public payable returns (uint destAmt) { // srcAmt = msg.value\r\n        require(maxSplitAmtEth >= splitAmt, \"split amt > max\");\r\n        destAmt = ethToDaiLoop(msg.value, splitAmt, 0);\r\n        destAmt = wmul(destAmt, cut);\r\n        require(destAmt > slippageAmt, \"Dest Amt < slippage\");\r\n        require(TokenInterface(daiAddr).transfer(msg.sender, destAmt), \"Not enough DAI to transfer\");\r\n        emit LogEthToDai(msg.value, destAmt);\r\n    }\r\n\r\n    function daiToEthSwap(uint srcAmt, uint splitAmt, uint slippageAmt) public returns (uint destAmt) {\r\n        require(maxSplitAmtDai >= splitAmt, \"split amt > max\");\r\n        require(TokenInterface(daiAddr).transferFrom(msg.sender, address(this), srcAmt), \"Token Approved?\");\r\n        uint finalSrcAmt = wmul(srcAmt, cut);\r\n        destAmt = daiToEthLoop(finalSrcAmt, splitAmt, 0);\r\n        wethToEth();\r\n        require(destAmt > slippageAmt, \"Dest Amt < slippage\");\r\n        msg.sender.transfer(destAmt);\r\n        emit LogDaiToEth(finalSrcAmt, destAmt);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract SplitSwap is Swap {\r\n\r\n    constructor() public {\r\n        setAllowance(TokenInterface(daiAddr), eth2daiAddr);\r\n        setAllowance(TokenInterface(daiAddr), kyberAddr);\r\n        setAllowance(TokenInterface(daiAddr), uniswapAddr);\r\n        setAllowance(TokenInterface(wethAddr), eth2daiAddr);\r\n        setAllowance(TokenInterface(wethAddr), wethAddr);\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"uniswapAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eth2daiAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminTwo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"splitAmt\",\"type\":\"uint256\"},{\"name\":\"slippageAmt\",\"type\":\"uint256\"}],\"name\":\"ethToDaiSwap\",\"outputs\":[{\"name\":\"destAmt\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setSplitDai\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"srcAmt\",\"type\":\"uint256\"}],\"name\":\"getBest\",\"outputs\":[{\"name\":\"bestExchange\",\"type\":\"uint256\"},{\"name\":\"destAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daiAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSplitAmtEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"srcAmt\",\"type\":\"uint256\"},{\"name\":\"splitAmt\",\"type\":\"uint256\"},{\"name\":\"slippageAmt\",\"type\":\"uint256\"}],\"name\":\"daiToEthSwap\",\"outputs\":[{\"name\":\"destAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyberAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setSplitEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminOne\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSplitAmtDai\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"srcAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"destAmt\",\"type\":\"uint256\"}],\"name\":\"LogEthToDai\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"srcAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"destAmt\",\"type\":\"uint256\"}],\"name\":\"LogDaiToEth\",\"type\":\"event\"}]","ContractName":"SplitSwap","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://57b72b39e202481686d80a7982c85907ed1f67a24a98e71e78537a3ddd9d9cd2"}]}