{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: truffle/contracts/ECDSA.sol\r\n\r\n/*\r\n**  Blockdemy Certifications | A library to recover signature addresses with ECDSA\r\n**  Authors: Blockchain Academy México @blockdemy, Ernesto García @ernestognw\r\n**  22-July-2019\r\n**  blockchainacademy.mx\r\n*/\r\n\r\n\r\npragma solidity ^0.5.1;\r\n\r\nlibrary ECDSA {\r\n    /**\r\n    * @dev Recovers the address of who signed the hash sent to the function\r\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\r\n    * @param _signature bytes. Signature of the sha3 fingerprint of the file.\r\n    */\r\n    function recoverAddress(bytes32 _fingerprint, bytes memory _signature) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        require(_signature.length == 65, \"Invalid signature\");\r\n\r\n        // Divide the signature in r, s and v variables with inline assembly.\r\n        assembly {\r\n          r := mload(add(_signature, 0x20))\r\n          s := mload(add(_signature, 0x40))\r\n          v := byte(0, mload(add(_signature, 0x60)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n          v += 27;\r\n        }\r\n        \r\n        require(v == 27 || v == 28, \"Invalid signature\");\r\n        return ecrecover(toEthSignedMessageHash(_fingerprint), v, r, s);\r\n    }\r\n    \r\n    /**\r\n    * toEthSignedMessageHash\r\n    * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\" and hash the result\r\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\r\n    */\r\n    function toEthSignedMessageHash(bytes32 _fingerprint) internal pure returns (bytes32) {\r\n        return keccak256(\r\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _fingerprint)\r\n        );\r\n    } \r\n}\r\n\r\n// File: truffle/contracts/Certifications.sol\r\n\r\n/*\r\n**  Blockdemy Certifications | A contract to store digital documents certifications\r\n**  Authors: Blockchain Academy México @blockdemy, Ernesto García @ernestognw\r\n**  22-July-2019\r\n**  blockchainacademy.mx\r\n*/\r\n\r\npragma solidity 0.5.1;\r\n\r\n\r\n\r\ncontract Certifications is Ownable {\r\n    using ECDSA for bytes32;\r\n    \r\n    mapping(bytes32 => Certificate) public fingerprints; \r\n    \r\n    struct Certificate {\r\n        address owner;\r\n        mapping(address => bytes) signatures;\r\n        uint issued;\r\n        uint expires;\r\n        bool exists;\r\n    }\r\n    \r\n    constructor() public {}\r\n    \r\n    /**\r\n    * @dev Certificate a document fingerprint into blockchain\r\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\r\n    * @param _owner address. The address of who is being certificated. The owner of document.\r\n    * @param _issued uint. The unix miliseconds date of certificate issuing.\r\n    * @param _expires uint. The unix miliseconds date of certificate expiration.\r\n    */\r\n    function addCertificate(\r\n        bytes32 _fingerprint,\r\n        address _owner,\r\n        uint _issued,\r\n        uint _expires\r\n    ) onlyOwner() public returns(bool) {\r\n        require(_issued < _expires, \"Issuing date can not be less than expiring date\");\r\n        require(_expires > now, \"This certificate has already expired\");\r\n        require(!fingerprints[_fingerprint].exists, \"File has already been certified\");\r\n        fingerprints[_fingerprint].owner = _owner;\r\n        fingerprints[_fingerprint].issued = _issued;\r\n        fingerprints[_fingerprint].expires = _expires;\r\n        fingerprints[_fingerprint].exists = true;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Function to sign a previously generated certificate\r\n    * @param _signer address. The address of who is signing the certificate.\r\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\r\n    * @param _signature bytes. Signature of the sha3 fingerprint of the file.\r\n    */\r\n    function addSignatureToCertificate(address _signer, bytes32 _fingerprint, bytes memory _signature) onlyOwner() public returns(bool) {\r\n       address signer = _fingerprint.recoverAddress(_signature);\r\n       require(fingerprints[_fingerprint].exists, \"Certificate does not exists\");\r\n       require(_signer == signer, \"Signature does not corresponds to signer\");\r\n       fingerprints[_fingerprint].signatures[_signer] = _signature;\r\n       return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Returns the corresponding signature to a certificate and signer, used to verify signatures\r\n    * @param _signer address. The address of who supposedly signed the certificate.\r\n    * @param _fingerprint bytes32. Is the sha3 hash of document. Generated with web3.\r\n    */\r\n    function getSignature(address _signer, bytes32 _fingerprint) public view returns(bytes memory) {\r\n        return fingerprints[_fingerprint].signatures[_signer];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_signer\",\"type\":\"address\"},{\"name\":\"_fingerprint\",\"type\":\"bytes32\"}],\"name\":\"getSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"fingerprints\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"issued\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signer\",\"type\":\"address\"},{\"name\":\"_fingerprint\",\"type\":\"bytes32\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"addSignatureToCertificate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fingerprint\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_issued\",\"type\":\"uint256\"},{\"name\":\"_expires\",\"type\":\"uint256\"}],\"name\":\"addCertificate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Certifications","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://69ed30fa65481cca4a4f6bc302651c9aed22d126d1ded7af5f65187dd88a7f76"}]}