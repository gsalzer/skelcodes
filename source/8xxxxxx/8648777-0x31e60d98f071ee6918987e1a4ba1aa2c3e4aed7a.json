{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\ncontract owned {\r\n address public owner;\r\n function owned() public {\r\n owner = msg.sender;\r\n }\r\n\r\n modifier onlyOwner {\r\n require(msg.sender == owner);\r\n _;\r\n }\r\n function transferOwnership(address newOwner) onlyOwner public {\r\n owner = newOwner;\r\n }\r\n}\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\r\n\r\ncontract TokenERC20 { \r\n // Public variables of the token\r\n string public name;\r\n string public symbol;\r\n uint8 public decimals = 18; \r\n // 18 decimals is the strongly suggested default, avoid changing it\r\n uint256 public totalSupply; \r\n // This creates an array with all balances\r\n mapping (address => uint256) public balanceOf;\r\n mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients\r\n event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt\r\n event Burn(address indexed from, uint256 value);\r\n /**\r\n * Constrctor function\r\n *\r\n * Initializes contract with initial supply tokens to the creator of the contract\r\n */\r\n \r\n \r\n function TokenERC20(\r\n //uint256 initialSupply,\r\n string tokenName,\r\n string tokenSymbol\r\n ) public {\r\n //totalSupply = initialSupply * 10 ** uint256(decimals);\r\n totalSupply=811800000*10**uint256(decimals);// Update total supply with the decimal amount\r\n balanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens\r\n name = tokenName; // Set the name for display purposes\r\n symbol = tokenSymbol; // Set the symbol for display purposes\r\n } \r\n /**\r\n * Internal transfer, only can be called by this contract\r\n */\r\n \r\n \r\n function _transfer(address _from, address _to, uint _value) internal {\r\n // Prevent transfer to 0x0 address. Use burn() instead\r\n require(_to != 0x0);\r\n // Check if the sender has enough\r\n require(balanceOf[_from] >= _value);\r\n // Check for overflows\r\n require(balanceOf[_to] + _value > balanceOf[_to]);\r\n // Save this for an assertion in the future\r\n uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n // Subtract from the sender\r\n balanceOf[_from] -= _value;\r\n // Add the same to the recipient\r\n balanceOf[_to] += _value;\r\n Transfer(_from, _to, _value);\r\n // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n }\r\n \r\n /**\r\n * Transfer tokens\r\n *\r\n * Send `_value` tokens to `_to` from your account\r\n *\r\n * @param _to The address of the recipient\r\n * @param _value the amount to send\r\n */\r\n \r\n \r\n function transfer(address _to, uint256 _value) public {\r\n _transfer(msg.sender, _to, _value);\r\n }\r\n \r\n \r\n /**\r\n * Transfer tokens from other address\r\n *\r\n * Send `_value` tokens to `_to` in behalf of `_from`\r\n *\r\n * @param _from The address of the sender\r\n * @param _to The address of the recipient\r\n * @param _value the amount to send\r\n */\r\n \r\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n require(_value <= allowance[_from][msg.sender]); // Check allowance\r\n allowance[_from][msg.sender] -= _value;\r\n _transfer(_from, _to, _value);\r\n return true;\r\n }\r\n \r\n \r\n /**\r\n * Set allowance for other address\r\n *\r\n * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n *\r\n * @param _spender The address authorized to spend\r\n * @param _value the max amount they can spend\r\n */\r\n \r\n \r\n function approve(address _spender, uint256 _value) public\r\n returns (bool success) {\r\n allowance[msg.sender][_spender] = _value;\r\n return true;\r\n }\r\n \r\n \r\n /**\r\n * Set allowance for other address and notify\r\n *\r\n * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n *\r\n * @param _spender The address authorized to spend\r\n * @param _value the max amount they can spend\r\n * @param _extraData some extra information to send to the approved contract\r\n */\r\n \r\n \r\n function approveAndCall(address _spender, uint256 _value, bytes _extraData)public returns(bool success){\r\n tokenRecipient spender = tokenRecipient(_spender);\r\n if (approve(_spender, _value)) {\r\n spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n return true;\r\n }\r\n }\r\n \r\n \r\n /**\r\n * Destroy tokens\r\n *\r\n * Remove `_value` tokens from the system irreversibly\r\n *\r\n * @param _value the amount of money to burn\r\n */\r\n \r\n function burn(uint256 _value) public returns (bool success) {\r\n require(balanceOf[msg.sender] >= _value); // Check if the sender has enough\r\n balanceOf[msg.sender] -= _value; // Subtract from the sender\r\n totalSupply -= _value; // Updates totalSupply\r\n Burn(msg.sender, _value);\r\n return true;\r\n }\r\n \r\n \r\n /**\r\n * Destroy tokens from other account\r\n *\r\n * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n *\r\n * @param _from the address of the sender\r\n * @param _value the amount of money to burn\r\n */\r\n \r\n \r\n \r\n function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n require(balanceOf[_from] >= _value); // Check if the targeted balance is enoughrequire(_value <= allowance[_from][msg.sender]); // Check allowance\r\n balanceOf[_from] -= _value; // Subtract from the targeted balance\r\n allowance[_from][msg.sender] -= _value; // Subtract from the sender's allowance\r\n totalSupply -= _value; // Update totalSupply\r\n Burn(_from, _value);\r\n return true;\r\n }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/******************************************/\r\n/* ADVANCED TOKEN STARTS HERE */\r\n/******************************************/\r\ncontract MyAdvancedToken is owned, TokenERC20 {\r\n    \r\n using SafeMath for uint256;\r\n\r\n //uint256 public sellPrice;\r\n //uint256 public buyPrice;\r\n \r\n \r\n //uint256 public totalFundingSupply;\r\n \r\n\r\n \r\n \r\n\r\n\r\n mapping (address => bool) public frozenAccount;\r\n /* This generates a public event on the blockchain that will notify clients */\r\n event FrozenFunds(address target, bool frozen);\r\n \r\n \r\n event CreateERTC(address indexed _to, uint256 _value);\r\n \r\n \r\n\r\n /* Initializes contract with initial supply tokens to the creator of the contract */\r\n function MyAdvancedToken(\r\n //uint256 initialSupply,\r\n string tokenName,\r\n string tokenSymbol\r\n ) TokenERC20(tokenName, tokenSymbol) public {}\r\n \r\n \r\n \r\n  //总流通发行量9.9亿\r\n uint256 public  MAX_FUNDING_SUPPLY=990000000*10**uint256(decimals);\r\n \r\n //挖矿9.9亿\r\n uint256 public  MINING_SUPPLY=990000000*10**uint256(decimals);\r\n \r\n\r\n //总发行量 19.8亿\r\n uint256 public MAX_SUPPLY=MAX_FUNDING_SUPPLY+MINING_SUPPLY;\r\n \r\n /* Internal transfer, only can be called by this contract */\r\n \r\n \r\n \r\n modifier notReachTotalSupply(uint256 _value){\r\n\tassert(MAX_FUNDING_SUPPLY>=totalSupply.add(_value));\r\n\t_;\r\n}\r\n \r\n modifier notBeforeTime(uint256 targetTime){\r\n\tassert(now>targetTime);\r\n\t_;\r\n}\r\n\t\r\n\t\r\nmodifier notAfterTime(uint256 targetTime){\r\n\tassert(now<=targetTime);\r\n\t_;\r\n}\r\n\r\n//代币分发函数，内部使用\r\nfunction processFunding(address receiver,uint256 _value)  internal\r\n\tnotReachTotalSupply(_value)\r\n{\r\n\tuint256 amount=_value;\r\n\ttotalSupply=totalSupply.add(amount);\r\n\tbalanceOf[receiver] +=amount;\r\n\tCreateERTC(receiver,amount);\r\n\tTransfer(0x0, receiver, amount);\r\n}\r\n\t\r\n\t\r\n\t\r\n\t\r\n//2年后主网上线总流通发行量剩余部分进行解锁\r\nfunction withdrawForOneStep(uint256 _value) external \r\n\t onlyOwner\r\n\t notBeforeTime(1632923559)\r\n{\r\n    processFunding(msg.sender,_value);\r\n\t    \r\n}\r\n \r\n \r\n \r\n function _transfer(address _from, address _to, uint _value) internal {\r\n require (_to != 0x0); \r\n // Prevent transfer to 0x0 address. Use burn() instead\r\n require (balanceOf[_from] >= _value); \r\n // Check if the sender has enough\r\n require (balanceOf[_to] + _value > balanceOf[_to]);\r\n // Check for overflows\r\n require(!frozenAccount[_from]); \r\n // Check if sender is frozen\r\n require(!frozenAccount[_to]); \r\n // Check if recipient is frozen\r\n balanceOf[_from] -= _value; \r\n // Subtract from the sender\r\n balanceOf[_to] += _value; \r\n // Add the same to the recipient\r\n Transfer(_from, _to, _value);\r\n }\r\n\r\n \r\n \r\n/* function mintToken(address target, uint256 mintedAmount) onlyOwner public {\r\n balanceOf[target] += mintedAmount;\r\n totalSupply += mintedAmount;\r\n Transfer(0, this, mintedAmount);\r\n Transfer(this, target, mintedAmount);\r\n }*/\r\n \r\n \r\n\r\n \r\n \r\n function freezeAccount(address target, bool freeze) onlyOwner public {\r\n frozenAccount[target] = freeze;\r\n FrozenFunds(target, freeze);\r\n }\r\n \r\n \r\n\r\n /*function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {\r\n sellPrice = newSellPrice;\r\n buyPrice = newBuyPrice;\r\n }\r\n \r\n \r\n \r\n function buy() payable public {\r\n uint amount = msg.value / buyPrice; \r\n // calculates the amount\r\n _transfer(this, msg.sender, amount);\r\n // makes the transfers\r\n }\r\n \r\n \r\n\r\n \r\n \r\n function sell(uint256 amount) public {\r\n require(this.balance >= amount * sellPrice); \r\n // checks if the contract has enough ether to buy\r\n _transfer(msg.sender, this, amount); \r\n // makes the transfers\r\n msg.sender.transfer(amount * sellPrice); \r\n // sends ether to the seller. It's important to do this last to avoid recursion attacks\r\n }*/\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_FUNDING_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawForOneStep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINING_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"CreateERTC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"MyAdvancedToken","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000001a456475636174696f6e205265766f6c7574696f6e20436861696e00000000000000000000000000000000000000000000000000000000000000000000000000044552544300000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"None","SwarmSource":"bzzr://1d08eb902779c852fe63de86c9f920c339ff4f7f0364f25a5d9cbb016e2ed37c"}]}