{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/ERC20.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20\r\n * @dev A standard interface for tokens.\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n */\r\ncontract ERC20 {\r\n\r\n    /// @dev Returns the total token supply\r\n    function totalSupply() public view returns (uint256 supply);\r\n\r\n    /// @dev Returns the account balance of the account with address _owner\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    /// @dev Transfers _value number of tokens to address _to\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Transfers _value number of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Allows _spender to withdraw from the msg.sender's account up to the _value amount\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n// File: contracts/FundsForwarder.sol\r\n\r\n\r\ninterface IGivethBridge {\r\n    function donate(uint64 giverId, uint64 receiverId) external payable;\r\n    function donate(uint64 giverId, uint64 receiverId, address token, uint _amount) external payable;\r\n}\r\n\r\ninterface IFundsForwarderFactory {\r\n    function bridge() external returns (address);\r\n    function escapeHatchCaller() external returns (address);\r\n    function escapeHatchDestination() external returns (address);\r\n}\r\n\r\ninterface IMolochDao {\r\n    function approvedToken() external returns (address);\r\n    function members(address member) external returns (address, uint256, bool, uint256);\r\n    function ragequit(uint sharesToBurn) external;\r\n}\r\n\r\ninterface IWEth {\r\n    function withdraw(uint wad) external;\r\n    function balanceOf(address guy) external returns (uint);\r\n}\r\n\r\n\r\ncontract FundsForwarder {\r\n    uint64 public receiverId;\r\n    uint64 public giverId;\r\n    IFundsForwarderFactory public fundsForwarderFactory;\r\n\r\n    string private constant ERROR_ERC20_APPROVE = \"ERROR_ERC20_APPROVE\";\r\n    string private constant ERROR_BRIDGE_CALL = \"ERROR_BRIDGE_CALL\";\r\n    string private constant ERROR_ZERO_BRIDGE = \"ERROR_ZERO_BRIDGE\";\r\n    string private constant ERROR_DISALLOWED = \"RECOVER_DISALLOWED\";\r\n    string private constant ERROR_TOKEN_TRANSFER = \"RECOVER_TOKEN_TRANSFER\";\r\n    string private constant ERROR_ALREADY_INITIALIZED = \"INIT_ALREADY_INITIALIZED\";\r\n    uint private constant MAX_UINT = uint(-1);\r\n\r\n    event Forwarded(address to, address token, uint balance);\r\n    event EscapeHatchCalled(address token, uint amount);\r\n\r\n    constructor() public {\r\n        /// @dev From AragonOS's Autopetrified contract\r\n        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\r\n        // This renders them uninitializable (and unusable without a proxy).\r\n        fundsForwarderFactory = IFundsForwarderFactory(address(-1));\r\n    }\r\n\r\n    /**\r\n    * Fallback function to receive ETH donations\r\n    */\r\n    function() public payable {}\r\n\r\n    /**\r\n    * @dev Initialize can only be called once.\r\n    * @notice msg.sender MUST be the _fundsForwarderFactory Contract\r\n    *  Its address must be a contract with three public getters:\r\n    *  - bridge(): Returns the bridge address\r\n    *  - escapeHatchCaller(): Returns the escapeHatchCaller address\r\n    *  - escapeHatchDestination(): Returns the escashouldpeHatchDestination address\r\n    * @param _giverId The adminId of the liquidPledging pledge admin who is donating\r\n    * @param _receiverId The adminId of the liquidPledging pledge admin receiving the donation\r\n    */\r\n    function initialize(uint64 _giverId, uint64 _receiverId) public {\r\n        /// @dev onlyInit method from AragonOS's Initializable contract\r\n        require(fundsForwarderFactory == address(0), ERROR_ALREADY_INITIALIZED);\r\n        /// @dev Setting fundsForwarderFactory, serves as calling initialized()\r\n        fundsForwarderFactory = IFundsForwarderFactory(msg.sender);\r\n        /// @dev Make sure that the fundsForwarderFactory is a contract and has a bridge method\r\n        require(fundsForwarderFactory.bridge() != address(0), ERROR_ZERO_BRIDGE);\r\n\r\n        receiverId = _receiverId;\r\n        giverId = _giverId;\r\n    }\r\n\r\n    /**\r\n    * Transfer tokens/eth to the bridge. Transfer the entire balance of the contract\r\n    * @param _token the token to transfer. 0x0 for ETH\r\n    */\r\n    function forward(address _token) public {\r\n        IGivethBridge bridge = IGivethBridge(fundsForwarderFactory.bridge());\r\n        require(bridge != address(0), ERROR_ZERO_BRIDGE);\r\n\r\n        uint balance;\r\n        bool result;\r\n        /// @dev Logic for ether\r\n        if (_token == address(0)) {\r\n            balance = address(this).balance;\r\n            /// @dev Call donate() with two arguments, for tokens\r\n            /// Low level .call must be used due to function overloading\r\n            /// keccak250(\"donate(uint64,uint64)\") = bde60ac9\r\n            /* solium-disable-next-line security/no-call-value */\r\n            result = address(bridge).call.value(balance)(\r\n                0xbde60ac9,\r\n                giverId,\r\n                receiverId\r\n            );\r\n        /// @dev Logic for tokens\r\n        } else {\r\n            ERC20 token = ERC20(_token);\r\n            balance = token.balanceOf(this);\r\n            /// @dev Since the bridge is a trusted contract, the max allowance\r\n            ///  will be set on the first token transfer. Then it's skipped\r\n            ///  Numbers for DAI        First tx | n+1 txs\r\n            ///  approve(_, balance)      66356     51356\r\n            ///  approve(_, MAX_UINT)     78596     39103\r\n            ///                          +12240    -12253\r\n            ///  Worth it if forward is called more than once for each token\r\n            if (token.allowance(address(this), bridge) < balance) {\r\n                require(token.approve(bridge, MAX_UINT), ERROR_ERC20_APPROVE);\r\n            }\r\n\r\n            /// @dev Call donate() with four arguments, for tokens\r\n            /// Low level .call must be used due to function overloading\r\n            /// keccak256(\"donate(uint64,uint64,address,uint256)\") = 4c4316c7\r\n            /* solium-disable-next-line security/no-low-level-calls */\r\n            result = address(bridge).call(\r\n                0x4c4316c7,\r\n                giverId,\r\n                receiverId,\r\n                token,\r\n                balance\r\n            );\r\n        }\r\n        require(result, ERROR_BRIDGE_CALL);\r\n        emit Forwarded(bridge, _token, balance);\r\n    }\r\n\r\n    /**\r\n    * Transfer multiple tokens/eth to the bridge. Simplies UI interactions\r\n    * @param _tokens the array of tokens to transfer. 0x0 for ETH\r\n    */\r\n    function forwardMultiple(address[] _tokens) public {\r\n        uint tokensLength = _tokens.length;\r\n        for (uint i = 0; i < tokensLength; i++) {\r\n            forward(_tokens[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Transfer tokens from a Moloch DAO by calling ragequit on all shares\r\n    * @param _molochDao Address of a Moloch DAO\r\n    * @param _convertWeth Flag to indicate that this DAO uses WETH\r\n    */\r\n    function forwardMoloch(address _molochDao, bool _convertWeth) public {\r\n        IMolochDao molochDao = IMolochDao(_molochDao);\r\n        (,uint shares,,) = molochDao.members(address(this));\r\n        molochDao.ragequit(shares);\r\n        address approvedToken = molochDao.approvedToken();\r\n        if (_convertWeth) {\r\n            IWEth weth = IWEth(approvedToken);\r\n            weth.withdraw(weth.balanceOf(address(this)));\r\n            forward(address(0));\r\n        } else {\r\n            forward(molochDao.approvedToken());\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Send funds to recovery address (escapeHatchDestination).\r\n    * The `escapeHatch()` should only be called as a last resort if a\r\n    * security issue is uncovered or something unexpected happened\r\n    * @param _token Token balance to be sent to recovery vault.\r\n    *\r\n    * @dev Only the escapeHatchCaller can trigger this function\r\n    * @dev The escapeHatchCaller address must not have control over escapeHatchDestination\r\n    * @dev Function extracted from the Escapable contract (by Jordi Baylina and Adrià Massanet)\r\n    * Instead of storing the caller, destination and owner addresses,\r\n    * it fetches them from the parent contract.\r\n    */\r\n    function escapeHatch(address _token) public {\r\n        /// @dev Serves as the original contract's onlyEscapeHatchCaller\r\n        require(msg.sender == fundsForwarderFactory.escapeHatchCaller(), ERROR_DISALLOWED);\r\n\r\n        address escapeHatchDestination = fundsForwarderFactory.escapeHatchDestination();\r\n\r\n        uint256 balance;\r\n        if (_token == 0x0) {\r\n            balance = address(this).balance;\r\n            escapeHatchDestination.transfer(balance);\r\n        } else {\r\n            ERC20 token = ERC20(_token);\r\n            balance = token.balanceOf(this);\r\n            require(token.transfer(escapeHatchDestination, balance), ERROR_TOKEN_TRANSFER);\r\n        }\r\n\r\n        emit EscapeHatchCalled(_token, balance);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/IsContract.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n * Credit to @aragonOS\r\n */\r\n\r\n\r\ncontract IsContract {\r\n    /*\r\n    * NOTE: this should NEVER be used for authentication\r\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\r\n    *\r\n    * This is only intended to be used as a sanity check that an address is actually a contract,\r\n    * RATHER THAN an address not being a contract.\r\n    */\r\n    function isContract(address _target) internal view returns (bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly { size := extcodesize(_target) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/Owned.sol\r\n\r\n\r\n/// @title Owned\r\n/// @author Adrià Massanet <adria@codecontext.io>\r\n/// @notice The Owned contract has an owner address, and provides basic\r\n///  authorization control functions, this simplifies & the implementation of\r\n///  user permissions; this contract has three work flows for a change in\r\n///  ownership, the first requires the new owner to validate that they have the\r\n///  ability to accept ownership, the second allows the ownership to be\r\n///  directly transfered without requiring acceptance, and the third allows for\r\n///  the ownership to be removed to allow for decentralization\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed by, address indexed to);\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    event OwnershipRemoved();\r\n\r\n    /// @dev The constructor sets the `msg.sender` as the`owner` of the contract\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require (msg.sender == owner,\"err_ownedNotOwner\");\r\n        _;\r\n    }\r\n\r\n    /// @dev In this 1st option for ownership transfer `proposeOwnership()` must\r\n    ///  be called first by the current `owner` then `acceptOwnership()` must be\r\n    ///  called by the `newOwnerCandidate`\r\n    /// @notice `onlyOwner` Proposes to transfer control of the contract to a\r\n    ///  new owner\r\n    /// @param _newOwnerCandidate The address being proposed as the new owner\r\n    function proposeOwnership(address _newOwnerCandidate) public onlyOwner {\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n\r\n        emit OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// @notice Can only be called by the `newOwnerCandidate`, accepts the\r\n    ///  transfer of ownership\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwnerCandidate,\"err_ownedNotCandidate\");\r\n\r\n        address oldOwner = owner;\r\n        owner = newOwnerCandidate;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        emit OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /// @dev In this 2nd option for ownership transfer `changeOwnership()` can\r\n    ///  be called and it will immediately assign ownership to the `newOwner`\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner\r\n    function changeOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != 0x0,\"err_ownedInvalidAddress\");\r\n\r\n        address oldOwner = owner;\r\n        owner = _newOwner;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        emit OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /// @dev In this 3rd option for ownership transfer `removeOwnership()` can\r\n    ///  be called and it will immediately assign ownership to the 0x0 address;\r\n    ///  it requires a 0xdece be input as a parameter to prevent accidental use\r\n    /// @notice Decentralizes the contract, this operation cannot be undone\r\n    /// @param _dac `0xdac` has to be entered for this function to work\r\n    function removeOwnership(address _dac) public onlyOwner {\r\n        require(_dac == 0xdac,\"err_ownedInvalidDac\");\r\n\r\n        owner = 0x0;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        emit OwnershipRemoved();\r\n    }\r\n}\r\n\r\n// File: contracts/lib/Escapable.sol\r\n\r\n\r\n/*\r\n    Copyright 2016, Jordi Baylina\r\n    Contributor: Adrià Massanet <adria@codecontext.io>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n/// @dev `Escapable` is a base level contract built off of the `Owned`\r\n///  contract; it creates an escape hatch function that can be called in an\r\n///  emergency that will allow designated addresses to send any ether or tokens\r\n///  held in the contract to an `escapeHatchDestination` as long as they were\r\n///  not blacklisted\r\ncontract Escapable is Owned {\r\n    address public escapeHatchCaller;\r\n    address public escapeHatchDestination;\r\n    mapping (address=>bool) private escapeBlacklist; // Token contract addresses\r\n\r\n    /// @notice The Constructor assigns the `escapeHatchDestination` and the\r\n    ///  `escapeHatchCaller`\r\n    /// @param _escapeHatchCaller The address of a trusted account or contract\r\n    ///  to call `escapeHatch()` to send the ether in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`\r\n    ///  cannot move funds out of `escapeHatchDestination`\r\n    /// @param _escapeHatchDestination The address of a safe location (usu a\r\n    ///  Multisig) to send the ether held in this contract; if a neutral address\r\n    ///  is required, the WHG Multisig is an option:\r\n    ///  0x8Ff920020c8AD673661c8117f2855C384758C572\r\n    constructor(address _escapeHatchCaller, address _escapeHatchDestination) public {\r\n        escapeHatchCaller = _escapeHatchCaller;\r\n        escapeHatchDestination = _escapeHatchDestination;\r\n    }\r\n\r\n    /// @dev The addresses preassigned as `escapeHatchCaller` or `owner`\r\n    ///  are the only addresses that can call a function with this modifier\r\n    modifier onlyEscapeHatchCallerOrOwner {\r\n        require (\r\n            (msg.sender == escapeHatchCaller)||(msg.sender == owner),\r\n            \"err_escapableInvalidCaller\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @notice Creates the blacklist of tokens that are not able to be taken\r\n    ///  out of the contract; can only be done at the deployment, and the logic\r\n    ///  to add to the blacklist will be in the constructor of a child contract\r\n    /// @param _token the token contract address that is to be blacklisted\r\n    function blacklistEscapeToken(address _token) internal {\r\n        escapeBlacklist[_token] = true;\r\n\r\n        emit EscapeHatchBlackistedToken(_token);\r\n    }\r\n\r\n    /// @notice Checks to see if `_token` is in the blacklist of tokens\r\n    /// @param _token the token address being queried\r\n    /// @return False if `_token` is in the blacklist and can't be taken out of\r\n    ///  the contract via the `escapeHatch()`\r\n    function isTokenEscapable(address _token) public view returns (bool) {\r\n        return !escapeBlacklist[_token];\r\n    }\r\n\r\n    /// @notice The `escapeHatch()` should only be called as a last resort if a\r\n    /// security issue is uncovered or something unexpected happened\r\n    /// @param _token to transfer, use 0x0 for ether\r\n    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {\r\n        require(escapeBlacklist[_token]==false,\"err_escapableBlacklistedToken\");\r\n\r\n        uint256 balance;\r\n\r\n        /// @dev Logic for ether\r\n        if (_token == 0x0) {\r\n            balance = address(this).balance;\r\n            escapeHatchDestination.transfer(balance);\r\n            emit EscapeHatchCalled(_token, balance);\r\n            return;\r\n        }\r\n        /// @dev Logic for tokens\r\n        ERC20 token = ERC20(_token);\r\n        balance = token.balanceOf(this);\r\n        require(token.transfer(escapeHatchDestination, balance),\"err_escapableTransfer\");\r\n        emit EscapeHatchCalled(_token, balance);\r\n    }\r\n\r\n    /// @notice Changes the address assigned to call `escapeHatch()`\r\n    /// @param _newEscapeHatchCaller The address of a trusted account or\r\n    ///  contract to call `escapeHatch()` to send the value in this contract to\r\n    ///  the `escapeHatchDestination`; it would be ideal that `escapeHatchCaller`\r\n    ///  cannot move funds out of `escapeHatchDestination`\r\n    function changeHatchEscapeCaller(address _newEscapeHatchCaller) public onlyEscapeHatchCallerOrOwner {\r\n        escapeHatchCaller = _newEscapeHatchCaller;\r\n    }\r\n\r\n    event EscapeHatchBlackistedToken(address token);\r\n    event EscapeHatchCalled(address token, uint amount);\r\n}\r\n\r\n// File: contracts/FundsForwarderFactory.sol\r\n\r\n\r\n\r\n\r\ncontract FundsForwarderFactory is Escapable, IsContract {\r\n    address public bridge;\r\n    address public childImplementation;\r\n\r\n    string private constant ERROR_NOT_A_CONTRACT = \"ERROR_NOT_A_CONTRACT\";\r\n    string private constant ERROR_HATCH_CALLER = \"ERROR_HATCH_CALLER\";\r\n    string private constant ERROR_HATCH_DESTINATION = \"ERROR_HATCH_DESTINATION\";\r\n\r\n    event NewFundForwarder(address indexed _giver, uint64 indexed _receiverId, address fundsForwarder);\r\n    event BridgeChanged(address newBridge);\r\n    event ChildImplementationChanged(address newChildImplementation);\r\n\r\n    /**\r\n    * @notice Create a new factory for deploying Giveth FundForwarders\r\n    * @dev Requires a deployed bridge\r\n    * @param _bridge Bridge address\r\n    * @param _escapeHatchCaller The address of a trusted account or contract to\r\n    *  call `escapeHatch()` to send the ether in this contract to the\r\n    *  `escapeHatchDestination` it would be ideal if `escapeHatchCaller` cannot move\r\n    *  funds out of `escapeHatchDestination`\r\n    * @param _escapeHatchDestination The address of a safe location (usually a\r\n    *  Multisig) to send the value held in this contract in an emergency\r\n    */\r\n    constructor(\r\n        address _bridge,\r\n        address _escapeHatchCaller,\r\n        address _escapeHatchDestination,\r\n        address _childImplementation\r\n    ) Escapable(_escapeHatchCaller, _escapeHatchDestination) public {\r\n        require(isContract(_bridge), ERROR_NOT_A_CONTRACT);\r\n        bridge = _bridge;\r\n\r\n        // Set the escapeHatch params to the same as in the bridge\r\n        Escapable bridgeInstance = Escapable(_bridge);\r\n        require(_escapeHatchCaller == bridgeInstance.escapeHatchCaller(), ERROR_HATCH_CALLER);\r\n        require(_escapeHatchDestination == bridgeInstance.escapeHatchDestination(), ERROR_HATCH_DESTINATION);\r\n        // Set the owner to the same as in the bridge\r\n        changeOwnership(bridgeInstance.owner());\r\n\r\n        // Deploy FundsForwarder\r\n        if (_childImplementation == address(0)) {\r\n            childImplementation = new FundsForwarder();\r\n        } else {\r\n            childImplementation = _childImplementation;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Change the bridge address.\r\n    * @param _bridge New bridge address\r\n    */\r\n    function changeBridge(address _bridge) external onlyEscapeHatchCallerOrOwner {\r\n        bridge = _bridge;\r\n        emit BridgeChanged(_bridge);\r\n    }\r\n\r\n    /**\r\n    * @notice Change the childImplementation address.\r\n    * @param _childImplementation New childImplementation address\r\n    */\r\n    function changeChildImplementation(address _childImplementation) external onlyEscapeHatchCallerOrOwner {\r\n        childImplementation = _childImplementation;\r\n        emit ChildImplementationChanged(_childImplementation);\r\n    }\r\n\r\n    /**\r\n    * @param _giverId The adminId of the liquidPledging pledge admin who is donating\r\n    * @param _receiverId The adminId of the liquidPledging pledge admin receiving the donation\r\n    */\r\n    function newFundsForwarder(uint64 _giverId, uint64 _receiverId) public {\r\n        address fundsForwarder = _deployMinimal(childImplementation);\r\n        FundsForwarder(fundsForwarder).initialize(_giverId, _receiverId);\r\n\r\n        // Store a registry of fundForwarders as events\r\n        emit NewFundForwarder(_giverId, _receiverId, fundsForwarder);\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys a minimal forwarding proxy that is not upgradable\r\n     * From ZepelinOS https://github.com/zeppelinos/zos/blob/v2.4.0/packages/lib/contracts/upgradeability/ProxyFactory.sol\r\n     */\r\n    function _deployMinimal(address _logic) internal returns (address proxy) {\r\n        // Adapted from https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\r\n        bytes20 targetBytes = bytes20(_logic);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            proxy := create(0, clone, 0x37)\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"changeBridge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchCaller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_childImplementation\",\"type\":\"address\"}],\"name\":\"changeChildImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dac\",\"type\":\"address\"}],\"name\":\"removeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"proposeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isTokenEscapable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"escapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEscapeHatchCaller\",\"type\":\"address\"}],\"name\":\"changeHatchEscapeCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"childImplementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_giverId\",\"type\":\"uint64\"},{\"name\":\"_receiverId\",\"type\":\"uint64\"}],\"name\":\"newFundsForwarder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchDestination\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_bridge\",\"type\":\"address\"},{\"name\":\"_escapeHatchCaller\",\"type\":\"address\"},{\"name\":\"_escapeHatchDestination\",\"type\":\"address\"},{\"name\":\"_childImplementation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_giver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_receiverId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"fundsForwarder\",\"type\":\"address\"}],\"name\":\"NewFundForwarder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newBridge\",\"type\":\"address\"}],\"name\":\"BridgeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newChildImplementation\",\"type\":\"address\"}],\"name\":\"ChildImplementationChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"EscapeHatchBlackistedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EscapeHatchCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OwnershipRemoved\",\"type\":\"event\"}]","ContractName":"FundsForwarderFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000030f938fed5de6e06a9a7cd2ac3517131c317b1e70000000000000000000000001e9f6746147e937e8e1c29180e15af0bd5fd64bb00000000000000000000000016fda2fcc887dd7ac65c46be144473067cff86540000000000000000000000000000000000000000000000000000000000000000","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://a7d0ad6fc0da52fe91f72fbfecfe019ed857684e58bf9e736e1871fa0b53c2f5"}]}