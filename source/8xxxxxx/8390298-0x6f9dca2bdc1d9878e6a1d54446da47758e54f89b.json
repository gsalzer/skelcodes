{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/*******************************************************************************\r\n *\r\n * Copyright (c) 2019 Decentralization Authority MDAO.\r\n * Released under the MIT License.\r\n *\r\n * Minado - Crypto Token Mining & Forging Community\r\n * \r\n *          Minado has been optimized for mining ERC918-compatible tokens via\r\n *          the InfinityPool; a public storage of mineable ERC-20 tokens.\r\n * \r\n *          Learn more below:\r\n * \r\n *          Official : https://minado.network\r\n *          Ethereum : https://eips.ethereum.org/EIPS/eip-918\r\n *          Github   : https://github.com/ethereum/EIPs/pull/918\r\n *          Reddit   : https://www.reddit.com/r/Tokenmining\r\n * \r\n * Version 19.7.18\r\n *\r\n * Web    : https://d14na.org\r\n * Email  : support@d14na.org\r\n */\r\n\r\n\r\n/*******************************************************************************\r\n *\r\n * SafeMath\r\n */\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\n/*******************************************************************************\r\n *\r\n * ECRecovery\r\n *\r\n * Contract function to validate signature of pre-approved token transfers.\r\n * (borrowed from LavaWallet)\r\n */\r\ncontract ECRecovery {\r\n    function recover(bytes32 hash, bytes sig) public pure returns (address);\r\n}\r\n\r\n\r\n/*******************************************************************************\r\n *\r\n * Owned contract\r\n */\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n\r\n        emit OwnershipTransferred(owner, newOwner);\r\n\r\n        owner = newOwner;\r\n\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n/*******************************************************************************\r\n * \r\n * Zer0netDb Interface\r\n */\r\ncontract Zer0netDbInterface {\r\n    /* Interface getters. */\r\n    function getAddress(bytes32 _key) external view returns (address);\r\n    function getBool(bytes32 _key)    external view returns (bool);\r\n    function getBytes(bytes32 _key)   external view returns (bytes);\r\n    function getInt(bytes32 _key)     external view returns (int);\r\n    function getString(bytes32 _key)  external view returns (string);\r\n    function getUint(bytes32 _key)    external view returns (uint);\r\n\r\n    /* Interface setters. */\r\n    function setAddress(bytes32 _key, address _value) external;\r\n    function setBool(bytes32 _key, bool _value) external;\r\n    function setBytes(bytes32 _key, bytes _value) external;\r\n    function setInt(bytes32 _key, int _value) external;\r\n    function setString(bytes32 _key, string _value) external;\r\n    function setUint(bytes32 _key, uint _value) external;\r\n\r\n    /* Interface deletes. */\r\n    function deleteAddress(bytes32 _key) external;\r\n    function deleteBool(bytes32 _key) external;\r\n    function deleteBytes(bytes32 _key) external;\r\n    function deleteInt(bytes32 _key) external;\r\n    function deleteString(bytes32 _key) external;\r\n    function deleteUint(bytes32 _key) external;\r\n}\r\n\r\n\r\n/*******************************************************************************\r\n *\r\n * ERC Token Standard #20 Interface\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n */\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\n/*******************************************************************************\r\n *\r\n * InfinityPool Interface\r\n */\r\ncontract InfinityPoolInterface {\r\n    function transfer(address _token, address _to, uint _tokens) external returns (bool success);\r\n}\r\n\r\n\r\n/*******************************************************************************\r\n *\r\n * InfinityWell Interface\r\n */\r\ncontract InfinityWellInterface {\r\n    function forgeStones(address _owner, uint _tokens) external returns (bool success);\r\n    function destroyStones(address _owner, uint _tokens) external returns (bool success);\r\n    function transferERC20(address _token, address _to, uint _tokens) external returns (bool success);\r\n    function transferERC721(address _token, address _to, uint256 _tokenId) external returns (bool success);\r\n}\r\n\r\n\r\n/*******************************************************************************\r\n *\r\n * Staek(house) Factory Interface\r\n */\r\ncontract StaekFactoryInterface {\r\n    function balanceOf(bytes32 _staekhouseId) public view returns (uint balance);\r\n    function balanceOf(bytes32 _staekhouseId, address _owner) public view returns (uint balance);\r\n    function getStaekhouse(bytes32 _staekhouseId, address _staeker) external view returns (address factory, address token, address owner, uint ownerLockTime, uint providerLockTime, uint debtLimit, uint lockInterval, uint balance);\r\n}\r\n\r\n\r\n/*******************************************************************************\r\n *\r\n * @notice Minado - Token Mining Contract\r\n *\r\n * @dev This is a multi-token mining contract, which manages the proof-of-work\r\n *      verifications before authorizing the movement of tokens from the\r\n *      InfinityPool and InfinityWell.\r\n */\r\ncontract Minado is Owned {\r\n    using SafeMath for uint;\r\n\r\n    /* Initialize predecessor contract. */\r\n    address private _predecessor;\r\n\r\n    /* Initialize successor contract. */\r\n    address private _successor;\r\n    \r\n    /* Initialize revision number. */\r\n    uint private _revision;\r\n\r\n    /* Initialize Zer0net Db contract. */\r\n    Zer0netDbInterface private _zer0netDb;\r\n\r\n    /**\r\n     * Set Namespace\r\n     * \r\n     * Provides a \"unique\" name for generating \"unique\" data identifiers,\r\n     * most commonly used as database \"key-value\" keys.\r\n     * \r\n     * NOTE: Use of `namespace` is REQUIRED when generating ANY & ALL\r\n     *       Zer0netDb keys; in order to prevent ANY accidental or\r\n     *       malicious SQL-injection vulnerabilities / attacks.\r\n     */\r\n    string private _namespace = 'minado';\r\n\r\n    /**\r\n     * Large Target\r\n     * \r\n     * A big number used for difficulty targeting.\r\n     * \r\n     * NOTE: Bitcoin uses `2**224`.\r\n     */\r\n    uint private _MAXIMUM_TARGET = 2**234;\r\n\r\n    /**\r\n     * Minimum Targets\r\n     * \r\n     * Minimum number used for difficulty targeting.\r\n     */\r\n    uint private _MINIMUM_TARGET = 2**16;\r\n\r\n    /**\r\n     * Set basis-point multiplier.\r\n     * \r\n     * NOTE: Used for (integer-based) fractional calculations.\r\n     */\r\n    uint private _BP_MUL = 10000;\r\n\r\n    /* Set InfinityStone decimals. */\r\n    uint private _STONE_DECIMALS = 18;\r\n\r\n    /* Set single InfinityStone. */\r\n    uint private _SINGLE_STONE = 1 * 10**_STONE_DECIMALS;\r\n    \r\n    /**\r\n     * (Ethereum) Blocks Per Forge\r\n     * \r\n     * NOTE: Ethereum blocks take approx 15 seconds each.\r\n     *       1,000 blocks takes approx 4 hours.\r\n     */\r\n    uint private _BLOCKS_PER_STONE_FORGE = 1000;\r\n\r\n    /**\r\n     * (Ethereum) Blocks Per Generation\r\n     * \r\n     * NOTE: We mirror the Bitcoin POW mining algorithm. \r\n     *       We want miners to spend 10 minutes to mine each 'block'.\r\n     *       (about 40 Ethereum blocks for every 1 Bitcoin block)\r\n     */\r\n    uint BLOCKS_PER_GENERATION = 40; // Mainnet & Ropsten\r\n    // uint BLOCKS_PER_GENERATION = 120; // Kovan\r\n\r\n    /**\r\n     * (Mint) Generations Per Re-adjustment\r\n     * \r\n     * By default, we automatically trigger a difficulty adjustment\r\n     * after 144 generations / mints (approx 24 hours). \r\n     * \r\n     * Frequent adjustments are especially important with low-liquidity \r\n     * tokens, which are more susceptible to mining manipulation.\r\n     * \r\n     * For additional control, token providers retain the ability to trigger \r\n     * a difficulty re-calculation at any time.\r\n     * \r\n     * NOTE: Bitcoin re-adjusts its difficulty every 2,016 generations,\r\n     *       which occurs approx. every 14 days.\r\n     */\r\n    uint private _DEFAULT_GENERATIONS_PER_ADJUSTMENT = 144; // approx. 24hrs\r\n\r\n    event Claim(\r\n        address owner, \r\n        address token, \r\n        uint amount,\r\n        address collectible,\r\n        uint collectibleId\r\n    );\r\n\r\n    event Excavate(\r\n        address indexed token, \r\n        address indexed miner, \r\n        uint mintAmount, \r\n        uint epochCount, \r\n        bytes32 newChallenge\r\n    );\r\n    \r\n    event Mint(\r\n        address indexed from, \r\n        uint rewardAmount, \r\n        uint epochCount, \r\n        bytes32 newChallenge\r\n    );\r\n\r\n    event ReCalculate(\r\n        address token, \r\n        uint newDifficulty\r\n    );\r\n\r\n    event Solution(\r\n        address indexed token, \r\n        address indexed miner, \r\n        uint difficulty,\r\n        uint nonce,\r\n        bytes32 challenge, \r\n        bytes32 newChallenge\r\n    );\r\n\r\n    /* Constructor. */\r\n    constructor() public {\r\n        /* Initialize Zer0netDb (eternal) storage database contract. */\r\n        // NOTE We hard-code the address here, since it should never change.\r\n        _zer0netDb = Zer0netDbInterface(0xE865Fe1A1A3b342bF0E2fcB11fF4E3BCe58263af);\r\n        // _zer0netDb = Zer0netDbInterface(0x4C2f68bCdEEB88764b1031eC330aD4DF8d6F64D6); // ROPSTEN\r\n        // _zer0netDb = Zer0netDbInterface(0x3e246C5038287DEeC6082B95b5741c147A3f49b3); // KOVAN\r\n\r\n        /* Initialize (aname) hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked('aname.', _namespace));\r\n\r\n        /* Set predecessor address. */\r\n        _predecessor = _zer0netDb.getAddress(hash);\r\n\r\n        /* Verify predecessor address. */\r\n        if (_predecessor != 0x0) {\r\n            /* Retrieve the last revision number (if available). */\r\n            uint lastRevision = Minado(_predecessor).getRevision();\r\n            \r\n            /* Set (current) revision number. */\r\n            _revision = lastRevision + 1;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Only allow access to an authorized Zer0net administrator.\r\n     */\r\n    modifier onlyAuthBy0Admin() {\r\n        /* Verify write access is only permitted to authorized accounts. */\r\n        require(_zer0netDb.getBool(keccak256(\r\n            abi.encodePacked(msg.sender, '.has.auth.for.', _namespace))) == true);\r\n\r\n        _;      // function code is inserted here\r\n    }\r\n\r\n    /**\r\n     * @dev Only allow access to \"registered\" authorized user/contract.\r\n     */\r\n    modifier onlyTokenProvider(\r\n        address _token\r\n    ) {\r\n        /* Validate authorized token manager. */\r\n        require(_zer0netDb.getBool(keccak256(abi.encodePacked(\r\n            _namespace, '.',\r\n            msg.sender, \r\n            '.has.auth.for.', \r\n            _token\r\n        ))) == true);\r\n\r\n        _;      // function code is inserted here\r\n    }\r\n\r\n    /**\r\n     * THIS CONTRACT DOES NOT ACCEPT DIRECT ETHER\r\n     */\r\n    function () public payable {\r\n        /* Cancel this transaction. */\r\n        revert('Oops! Direct payments are NOT permitted here.');\r\n    }\r\n\r\n\r\n    /***************************************************************************\r\n     * \r\n     * ACTIONS\r\n     * \r\n     */\r\n\r\n    /**\r\n     * Initialize Token\r\n     */\r\n    function init(\r\n        address _token,\r\n        address _provider\r\n    ) external onlyAuthBy0Admin returns (bool success) {\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.last.adjustment'\r\n        ));\r\n\r\n        /* Set current adjustment time in Zer0net Db. */\r\n        _zer0netDb.setUint(hash, block.number);\r\n\r\n        /* Set hash. */\r\n        hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.generations.per.adjustment'\r\n        ));\r\n\r\n        /* Set value in Zer0net Db. */\r\n        _zer0netDb.setUint(hash, _DEFAULT_GENERATIONS_PER_ADJUSTMENT);\r\n\r\n        /* Set hash. */\r\n        hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.challenge'\r\n        ));\r\n\r\n        /* Set current adjustment time in Zer0net Db. */\r\n        _zer0netDb.setBytes(\r\n            hash, \r\n            _bytes32ToBytes(blockhash(block.number - 1))\r\n        );\r\n\r\n        /* Set mining target. */\r\n        // NOTE: This is the default difficulty of 1.\r\n        _setMiningTarget(\r\n            _token, \r\n            _MAXIMUM_TARGET\r\n        );\r\n\r\n        /* Set hash. */\r\n        hash = keccak256(abi.encodePacked(\r\n            _namespace, '.',\r\n            _provider, \r\n            '.has.auth.for.', \r\n            _token\r\n        ));\r\n\r\n        /* Set value in Zer0net Db. */\r\n        _zer0netDb.setBool(hash, true);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Mint\r\n     */\r\n    function mint(\r\n        address _token,\r\n        bytes32 _digest,\r\n        uint _nonce\r\n    ) public returns (bool success) {\r\n        /* Retrieve the current challenge. */\r\n        uint challenge = getChallenge(_token);\r\n\r\n        /* Get mint digest. */\r\n        bytes32 digest = getMintDigest(\r\n            challenge, \r\n            msg.sender, \r\n            _nonce\r\n        );\r\n\r\n        /* The challenge digest must match the expected. */\r\n        if (digest != _digest) {\r\n            revert('Oops! That solution is NOT valid.');\r\n        }\r\n\r\n        /* The digest must be smaller than the target. */\r\n        if (uint(digest) > getTarget(_token)) {\r\n            revert('Oops! That solution is NOT valid.');\r\n        }\r\n\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            digest, \r\n            '.solutions'\r\n        ));\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        uint solution = _zer0netDb.getUint(hash);\r\n\r\n        /* Validate solution. */\r\n        if (solution != 0x0) {\r\n            revert('Oops! That solution is a DUPLICATE.');\r\n        }\r\n\r\n        /* Save this digest to 'solved' solutions. */\r\n        _zer0netDb.setUint(hash, uint(digest));\r\n\r\n        /* Set hash. */\r\n        hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.generation'\r\n        ));\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        uint generation = _zer0netDb.getUint(hash);\r\n\r\n        /* Increment the generation. */\r\n        generation = generation.add(1);\r\n\r\n        /* Increment the generation count by 1. */\r\n        _zer0netDb.setUint(hash, generation);\r\n\r\n        /* Set hash. */\r\n        hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.generations.per.adjustment'\r\n        ));\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        uint genPerAdjustment = _zer0netDb.getUint(hash);\r\n\r\n        // every so often, readjust difficulty. Dont readjust when deploying\r\n        if (generation % genPerAdjustment == 0) {\r\n            _reAdjustDifficulty(_token);\r\n        }\r\n\r\n        /* Set hash. */\r\n        hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.challenge'\r\n        ));\r\n\r\n        /**\r\n         * Make the latest ethereum block hash a part of the next challenge \r\n         * for PoW to prevent pre-mining future blocks. Do this last, \r\n         * since this is a protection mechanism in the mint() function.\r\n         */\r\n        _zer0netDb.setBytes(\r\n            hash, \r\n            _bytes32ToBytes(blockhash(block.number - 1))\r\n        );\r\n\r\n        /* Retrieve mining reward. */\r\n        // FIXME Add support for percentage reward.\r\n        uint rewardAmount = getMintFixed(_token);\r\n\r\n        /* Transfer (token) reward to minter. */\r\n        _infinityPool().transfer(\r\n            _token, \r\n            msg.sender, \r\n            rewardAmount\r\n        );\r\n\r\n        /* Emit log info. */\r\n        emit Mint(\r\n            msg.sender, \r\n            rewardAmount, \r\n            generation, \r\n            blockhash(block.number - 1) // next target\r\n        );\r\n\r\n        /* Return success. */\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Test Mint Solution\r\n     */\r\n    function testMint(\r\n        bytes32 _digest, \r\n        uint _challenge, \r\n        address _minter,\r\n        uint _nonce, \r\n        uint _target\r\n    ) public pure returns (bool success) {\r\n        /* Retrieve digest. */\r\n        bytes32 digest = getMintDigest(\r\n            _challenge, \r\n            _minter,\r\n            _nonce\r\n        );\r\n\r\n        /* Validate digest. */\r\n        // NOTE: Cast type to 256-bit integer\r\n        if (uint(digest) > _target) {\r\n            /* Set flag. */\r\n            success = false;\r\n        } else {\r\n            /* Verify success. */\r\n            success = (digest == _digest);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Re-calculate Difficulty\r\n     * \r\n     * Token owner(s) can \"manually\" trigger the re-calculation of their token,\r\n     * based on the parameters that have been set.\r\n     * \r\n     * NOTE: This will help deter malicious miners from gaming the difficulty\r\n     *       parameter, to the detriment of the token's community.\r\n     */\r\n    function reCalculateDifficulty(\r\n        address _token\r\n    ) external onlyTokenProvider(_token) returns (bool success) {\r\n        /* Re-calculate difficulty. */\r\n        return _reAdjustDifficulty(_token);\r\n    }\r\n\r\n    /**\r\n     * Re-adjust Difficulty\r\n     * \r\n     * Re-adjust the target by 5 percent.\r\n     * (source: https://en.bitcoin.it/wiki/Difficulty#What_is_the_formula_for_difficulty.3F)\r\n     * \r\n     * NOTE: Assume 240 ethereum blocks per hour (approx. 15/sec)\r\n     * \r\n     * NOTE: As of 2017 the bitcoin difficulty was up to 17 zeroes, \r\n     *       it was only 8 in the early days.\r\n     */\r\n    function _reAdjustDifficulty(\r\n        address _token\r\n    ) private returns (bool success) {\r\n        /* Set hash. */\r\n        bytes32 lastAdjustmentHash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.last.adjustment'\r\n        ));\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        uint lastAdjustment = _zer0netDb.getUint(lastAdjustmentHash);\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        uint blocksSinceLastAdjustment = block.number - lastAdjustment;\r\n\r\n        /* Set hash. */\r\n        bytes32 adjustmentHash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.generations.per.adjustment'\r\n        ));\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        uint genPerAdjustment = _zer0netDb.getUint(adjustmentHash);\r\n        \r\n        /* Calculate number of expected blocks per adjustment. */\r\n        uint expectedBlocksPerAdjustment = genPerAdjustment.mul(BLOCKS_PER_GENERATION);\r\n\r\n        /* Retrieve mining target. */\r\n        uint miningTarget = getTarget(_token);\r\n\r\n        /* Validate the number of blocks passed; if there were less eth blocks \r\n         * passed in time than expected, then miners are excavating too quickly.\r\n         */\r\n        if (blocksSinceLastAdjustment < expectedBlocksPerAdjustment) {\r\n            // NOTE: This number will be an integer greater than 10000.\r\n            uint excess_block_pct = expectedBlocksPerAdjustment.mul(10000)\r\n                .div(blocksSinceLastAdjustment);\r\n\r\n            /**\r\n             * Excess Block Percentage Extra\r\n             * \r\n             * For example:\r\n             *     If there were 5% more blocks mined than expected, then this is 500.\r\n             *     If there were 25% more blocks mined than expected, then this is 2500.\r\n             */\r\n            uint excess_block_pct_extra = excess_block_pct.sub(10000);\r\n            \r\n            /* Set a maximum difficulty INCREASE of 50%. */\r\n            // NOTE: By default, this is within a 24hr period.\r\n            if (excess_block_pct_extra > 5000) {\r\n                excess_block_pct_extra = 5000;\r\n            }\r\n\r\n            /**\r\n             * Reset the Mining Target\r\n             * \r\n             * Calculate the difficulty difference, then SUBTRACT\r\n             * that value from the current difficulty.\r\n             */\r\n            miningTarget = miningTarget.sub(\r\n                /* Calculate difficulty difference. */\r\n                miningTarget\r\n                    .mul(excess_block_pct_extra)\r\n                    .div(10000)\r\n            );   \r\n        } else {\r\n            // NOTE: This number will be an integer greater than 10000.\r\n            uint shortage_block_pct = blocksSinceLastAdjustment.mul(10000)\r\n                .div(expectedBlocksPerAdjustment);\r\n\r\n            /**\r\n             * Shortage Block Percentage Extra\r\n             * \r\n             * For example:\r\n             *     If it took 5% longer to mine than expected, then this is 500.\r\n             *     If it took 25% longer to mine than expected, then this is 2500.\r\n             */\r\n            uint shortage_block_pct_extra = shortage_block_pct.sub(10000);\r\n\r\n            // NOTE: There is NO limit on the amount of difficulty DECREASE.\r\n\r\n            /**\r\n             * Reset the Mining Target\r\n             * \r\n             * Calculate the difficulty difference, then ADD\r\n             * that value to the current difficulty.\r\n             */\r\n            miningTarget = miningTarget.add(\r\n                miningTarget\r\n                    .mul(shortage_block_pct_extra)\r\n                    .div(10000)\r\n            );\r\n        }\r\n\r\n        /* Set current adjustment time in Zer0net Db. */\r\n        _zer0netDb.setUint(lastAdjustmentHash, block.number);\r\n\r\n        /* Validate TOO SMALL mining target. */\r\n        // NOTE: This is very difficult to guess.\r\n        if (miningTarget < _MINIMUM_TARGET) {\r\n            miningTarget = _MINIMUM_TARGET;\r\n        }\r\n\r\n        /* Validate TOO LARGE mining target. */\r\n        // NOTE: This is very easy to guess.\r\n        if (miningTarget > _MAXIMUM_TARGET) {\r\n            miningTarget = _MAXIMUM_TARGET;\r\n        }\r\n\r\n        /* Set mining target. */\r\n        _setMiningTarget(\r\n            _token,\r\n            miningTarget\r\n        );\r\n\r\n        /* Return success. */\r\n        return true;\r\n    }\r\n\r\n\r\n    /***************************************************************************\r\n     * \r\n     * GETTERS\r\n     * \r\n     */\r\n\r\n    /**\r\n     * Get Starting Block\r\n     * \r\n     * Starting Blocks\r\n     * ---------------\r\n     * \r\n     * First blocks honoring the start of Miss Piggy's celebration year:\r\n     *     - Mainnet :  7,175,716\r\n     *     - Ropsten :  4,956,268\r\n     *     - Kovan   : 10,283,438\r\n     * \r\n     * NOTE: Pulls value from db `minado.starting.block` using the\r\n     *       respective networks.\r\n     */\r\n    function getStartingBlock() public view returns (uint startingBlock) {\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace, \r\n            '.starting.block'\r\n        ));\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        startingBlock = _zer0netDb.getUint(hash);\r\n    }\r\n    \r\n    /**\r\n     * Get minter's mintng address.\r\n     */\r\n    function getMinter() external view returns (address minter) {\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace,\r\n            '.minter'\r\n        ));\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        minter = _zer0netDb.getAddress(hash);\r\n    }\r\n\r\n    /**\r\n     * Get generation details.\r\n     */\r\n    function getGeneration(\r\n        address _token\r\n    ) external view returns (\r\n        uint generation,\r\n        uint cycle\r\n    ) {\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.generation'\r\n        ));\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        generation = _zer0netDb.getUint(hash);\r\n\r\n        /* Set hash. */\r\n        hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.generations.per.adjustment'\r\n        ));\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        cycle = _zer0netDb.getUint(hash);\r\n    }\r\n\r\n    /**\r\n     * Get Minting FIXED amount\r\n     */\r\n    function getMintFixed(\r\n        address _token\r\n    ) public view returns (uint amount) {\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.mint.fixed'\r\n        ));\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        amount = _zer0netDb.getUint(hash);\r\n    }\r\n\r\n    /**\r\n     * Get Minting PERCENTAGE amount\r\n     */\r\n    function getMintPct(\r\n        address _token\r\n    ) public view returns (uint amount) {\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.mint.pct'\r\n        ));\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        amount = _zer0netDb.getUint(hash);\r\n    }\r\n\r\n    /**\r\n     * Get (Mining) Challenge\r\n     * \r\n     * This is an integer representation of a recent ethereum block hash, \r\n     * used to prevent pre-mining future blocks.\r\n     */\r\n    function getChallenge(\r\n        address _token\r\n    ) public view returns (uint challenge) {\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.challenge'\r\n        ));\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        // NOTE: Convert from bytes to integer.\r\n        challenge = uint(_bytesToBytes32(\r\n            _zer0netDb.getBytes(hash)\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * Get (Mining) Difficulty\r\n     * \r\n     * The number of zeroes the digest of the PoW solution requires.\r\n     * (auto adjusts)\r\n     */\r\n    function getDifficulty(\r\n        address _token\r\n    ) public view returns (uint difficulty) {\r\n        /* Caclulate difficulty. */\r\n        difficulty = _MAXIMUM_TARGET.div(getTarget(_token));\r\n    }\r\n\r\n    /**\r\n     * Get (Mining) Target\r\n     */\r\n    function getTarget(\r\n        address _token\r\n    ) public view returns (uint target) {\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.target'\r\n        ));\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        target = _zer0netDb.getUint(hash);\r\n    }\r\n\r\n    /**\r\n     * Get Mint Digest\r\n     * \r\n     * The PoW must contain work that includes a recent \r\n     * ethereum block hash (challenge hash) and the \r\n     * msg.sender's address to prevent MITM attacks\r\n     */\r\n    function getMintDigest(\r\n        uint _challenge,\r\n        address _minter,\r\n        uint _nonce \r\n    ) public pure returns (bytes32 digest) {\r\n        /* Calculate digest. */\r\n        digest = keccak256(abi.encodePacked(\r\n            _challenge, \r\n            _minter, \r\n            _nonce\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * Get Revision (Number)\r\n     */\r\n    function getRevision() public view returns (uint) {\r\n        return _revision;\r\n    }\r\n\r\n    \r\n    /***************************************************************************\r\n     * \r\n     * SETTERS\r\n     * \r\n     */\r\n\r\n    /**\r\n     * Set Generations Per (Difficulty) Adjustment\r\n     * \r\n     * Token owner(s) can adjust the number of generations \r\n     * per difficulty re-calculation.\r\n     * \r\n     * NOTE: This will help deter malicious miners from gaming the difficulty\r\n     *       parameter, to the detriment of the token's community.\r\n     */\r\n    function setGenPerAdjustment(\r\n        address _token,\r\n        uint _numBlocks\r\n    ) external onlyTokenProvider(_token) returns (bool success) {\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.generations.per.adjustment'\r\n        ));\r\n\r\n        /* Set value in Zer0net Db. */\r\n        _zer0netDb.setUint(hash, _numBlocks);\r\n        \r\n        /* Return success. */\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set (Fixed) Mint Amount\r\n     */\r\n    function setMintFixed(\r\n        address _token,\r\n        uint _amount\r\n    ) external onlyTokenProvider(_token) returns (bool success) {\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.mint.fixed'\r\n        ));\r\n\r\n        /* Set value in Zer0net Db. */\r\n        _zer0netDb.setUint(hash, _amount);\r\n        \r\n        /* Return success. */\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set (Dynamic) Mint Percentage\r\n     */\r\n    function setMintPct(\r\n        address _token,\r\n        uint _pct\r\n    ) external onlyTokenProvider(_token) returns (bool success) {\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.mint.pct'\r\n        ));\r\n\r\n        /* Set value in Zer0net Db. */\r\n        _zer0netDb.setUint(hash, _pct);\r\n        \r\n        /* Return success. */\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set Token Parent(s)\r\n     * \r\n     * Enables the use of merged mining by specifying (parent) tokens \r\n     * that offer an acceptibly HIGH difficulty for the child's own \r\n     * mining challenge.\r\n     * \r\n     * Parents are saved in priority levels:\r\n     *     1 - Most significant parent\r\n     *     2 - 2nd most significant parent\r\n     *     ...\r\n     *     # - Least significant parent\r\n     */\r\n    function setTokenParents(\r\n        address _token,\r\n        address[] _parents\r\n    ) external onlyTokenProvider(_token) returns (bool success) {\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.parents'\r\n        ));\r\n        \r\n        // FIXME How should we store a dynamic amount of parents?\r\n        //       Packed as bytes??\r\n        \r\n        // FIXME TEMPORARILY LIMITED TO 3\r\n        bytes memory allParents = abi.encodePacked(\r\n            _parents[0],\r\n            _parents[1],\r\n            _parents[2]\r\n        );\r\n\r\n        /* Set value in Zer0net Db. */\r\n        _zer0netDb.setBytes(hash, allParents);\r\n        \r\n        /* Return success. */\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Set Token Provider\r\n     */\r\n    function setTokenProvider(\r\n        address _token,\r\n        address _provider,\r\n        bool _auth\r\n    ) external onlyAuthBy0Admin returns (bool success) {\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace, '.',\r\n            _provider, \r\n            '.has.auth.for.', \r\n            _token\r\n        ));\r\n\r\n        /* Set value in Zer0net Db. */\r\n        _zer0netDb.setBool(hash, _auth);\r\n        \r\n        /* Return success. */\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set Mining Target\r\n     */\r\n    function _setMiningTarget(\r\n        address _token,\r\n        uint _target\r\n    ) private returns (bool success) {\r\n        /* Set hash. */\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n            _namespace, '.', \r\n            _token, \r\n            '.target'\r\n        ));\r\n\r\n        /* Set value in Zer0net Db. */\r\n        _zer0netDb.setUint(hash, _target);\r\n        \r\n        /* Return success. */\r\n        return true;\r\n    }\r\n\r\n\r\n    /***************************************************************************\r\n     *\r\n     * INTERFACES\r\n     *\r\n     */\r\n\r\n    /**\r\n     * Supports Interface (EIP-165)\r\n     *\r\n     * (see: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md)\r\n     *\r\n     * NOTE: Must support the following conditions:\r\n     *       1. (true) when interfaceID is 0x01ffc9a7 (EIP165 interface)\r\n     *       2. (false) when interfaceID is 0xffffffff\r\n     *       3. (true) for any other interfaceID this contract implements\r\n     *       4. (false) for any other interfaceID\r\n     */\r\n    function supportsInterface(\r\n        bytes4 _interfaceID\r\n    ) external pure returns (bool) {\r\n        /* Initialize constants. */\r\n        bytes4 InvalidId = 0xffffffff;\r\n        bytes4 ERC165Id = 0x01ffc9a7;\r\n\r\n        /* Validate condition #2. */\r\n        if (_interfaceID == InvalidId) {\r\n            return false;\r\n        }\r\n\r\n        /* Validate condition #1. */\r\n        if (_interfaceID == ERC165Id) {\r\n            return true;\r\n        }\r\n\r\n        // TODO Add additional interfaces here.\r\n\r\n        /* Return false (for condition #4). */\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * ECRecovery Interface\r\n     */\r\n    function _ecRecovery() private view returns (\r\n        ECRecovery ecrecovery\r\n    ) {\r\n        /* Initialize hash. */\r\n        bytes32 hash = keccak256('aname.ecrecovery');\r\n\r\n        /* Retrieve value from Zer0net Db. */\r\n        address aname = _zer0netDb.getAddress(hash);\r\n\r\n        /* Initialize interface. */\r\n        ecrecovery = ECRecovery(aname);\r\n    }\r\n\r\n    /**\r\n     * InfinityPool Interface\r\n     * \r\n     * Retrieves the current InfinityPool interface,\r\n     * using the aname record from Zer0netDb.\r\n     */\r\n    function _infinityPool() private view returns (\r\n        InfinityPoolInterface infinityPool\r\n    ) {\r\n        /* Initailze hash. */\r\n        bytes32 hash = keccak256('aname.infinitypool');\r\n        \r\n        /* Retrieve value from Zer0net Db. */\r\n        address aname = _zer0netDb.getAddress(hash);\r\n        \r\n        /* Initialize interface. */\r\n        infinityPool = InfinityPoolInterface(aname);\r\n    }\r\n\r\n    /**\r\n     * InfinityWell Interface\r\n     * \r\n     * Retrieves the current InfinityWell interface,\r\n     * using the aname record from Zer0netDb.\r\n     */\r\n    function _infinityWell() private view returns (\r\n        InfinityWellInterface infinityWell\r\n    ) {\r\n        /* Initailze hash. */\r\n        bytes32 hash = keccak256('aname.infinitywell');\r\n        \r\n        /* Retrieve value from Zer0net Db. */\r\n        address aname = _zer0netDb.getAddress(hash);\r\n        \r\n        /* Initialize interface. */\r\n        infinityWell = InfinityWellInterface(aname);\r\n    }\r\n\r\n\r\n    /***************************************************************************\r\n     * \r\n     * UTILITIES\r\n     * \r\n     */\r\n\r\n    /**\r\n     * Bytes-to-Address\r\n     * \r\n     * Converts bytes into type address.\r\n     */\r\n    function _bytesToAddress(bytes _address) private pure returns (address) {\r\n        uint160 m = 0;\r\n        uint160 b = 0;\r\n\r\n        for (uint8 i = 0; i < 20; i++) {\r\n            m *= 256;\r\n            b = uint160(_address[i]);\r\n            m += (b);\r\n        }\r\n\r\n        return address(m);\r\n    }\r\n\r\n    /**\r\n     * Convert Bytes to Bytes32\r\n     */\r\n    function _bytesToBytes32(\r\n        bytes _data\r\n    ) private pure returns (bytes32 result) {\r\n        /* Loop through each byte. */\r\n        for (uint i = 0; i < 32; i++) {\r\n            /* Shift bytes onto result. */\r\n            result |= bytes32(_data[i] & 0xFF) >> (i * 8);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Convert Bytes32 to Bytes\r\n     * \r\n     * NOTE: Since solidity v0.4.22, you can use `abi.encodePacked()` for this, \r\n     *       which returns bytes. (https://ethereum.stackexchange.com/a/55963)\r\n     */\r\n    function _bytes32ToBytes(\r\n        bytes32 _data\r\n    ) private pure returns (bytes result) {\r\n        /* Pack the data. */\r\n        return abi.encodePacked(_data);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getDifficulty\",\"outputs\":[{\"name\":\"difficulty\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStartingBlock\",\"outputs\":[{\"name\":\"startingBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_numBlocks\",\"type\":\"uint256\"}],\"name\":\"setGenPerAdjustment\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRevision\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_challenge\",\"type\":\"uint256\"},{\"name\":\"_minter\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getMintDigest\",\"outputs\":[{\"name\":\"digest\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getGeneration\",\"outputs\":[{\"name\":\"generation\",\"type\":\"uint256\"},{\"name\":\"cycle\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getMintPct\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_pct\",\"type\":\"uint256\"}],\"name\":\"setMintPct\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_digest\",\"type\":\"bytes32\"},{\"name\":\"_challenge\",\"type\":\"uint256\"},{\"name\":\"_minter\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_target\",\"type\":\"uint256\"}],\"name\":\"testMint\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"reCalculateDifficulty\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMintFixed\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getMintFixed\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getTarget\",\"outputs\":[{\"name\":\"target\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_parents\",\"type\":\"address[]\"}],\"name\":\"setTokenParents\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_digest\",\"type\":\"bytes32\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_provider\",\"type\":\"address\"},{\"name\":\"_auth\",\"type\":\"bool\"}],\"name\":\"setTokenProvider\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinter\",\"outputs\":[{\"name\":\"minter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getChallenge\",\"outputs\":[{\"name\":\"challenge\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"collectible\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"collectibleId\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"miner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"epochCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newChallenge\",\"type\":\"bytes32\"}],\"name\":\"Excavate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"epochCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newChallenge\",\"type\":\"bytes32\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newDifficulty\",\"type\":\"uint256\"}],\"name\":\"ReCalculate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"miner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"difficulty\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"challenge\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"newChallenge\",\"type\":\"bytes32\"}],\"name\":\"Solution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Minado","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://06200276bc1ad13a45a2ea182607b7d25df37cdae15f49c76822bb4b5d0a4b83"}]}