{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: @ensdomains/ens/contracts/ENS.sol\n\npragma solidity >=0.4.24;\n\ninterface ENS {\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n    function setResolver(bytes32 node, address resolver) external;\n    function setOwner(bytes32 node, address owner) external;\n    function setTTL(bytes32 node, uint64 ttl) external;\n    function owner(bytes32 node) external view returns (address);\n    function resolver(bytes32 node) external view returns (address);\n    function ttl(bytes32 node) external view returns (uint64);\n\n}\n\n// File: @ensdomains/resolver/contracts/Resolver.sol\n\npragma solidity >=0.4.25;\n\n/**\n * A generic resolver interface which includes all the functions including the ones deprecated\n */\ninterface Resolver{\n    event AddrChanged(bytes32 indexed node, address a);\n    event NameChanged(bytes32 indexed node, string name);\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\n    function addr(bytes32 node) external view returns (address);\n    function contenthash(bytes32 node) external view returns (bytes memory);\n    function dnsrr(bytes32 node) external view returns (bytes memory);\n    function name(bytes32 node) external view returns (string memory);\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n    function text(bytes32 node, string calldata key) external view returns (string memory);\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\n\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\n    function setAddr(bytes32 node, address addr) external;\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n    function setName(bytes32 node, string calldata _name) external;\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n    function setText(bytes32 node, string calldata key, string calldata value) external;\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n    function multihash(bytes32 node) external view returns (bytes memory);\n    function setContent(bytes32 node, bytes32 hash) external;\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}\n\n// File: contracts/WindingTreeEntrypoint.sol\n\npragma solidity ^0.5.6;\n\n\n\n\n/**\n * @title WindingTreeEntrypoint\n * @dev This smart contract is meant as an entrypoint to Winding Tree\n * ecosystem and holds addresses of all relevant Segment Directories.\n * Segment directories are indexed by their hashed name.\n */\ncontract WindingTreeEntrypoint is Initializable {\n    // Address of the contract owner\n    address _owner;\n\n    // Address of the LifToken contract\n    // solhint-disable-next-line var-name-mixedcase\n    address public _lifToken;\n\n    // Mapping of keccak256(segment) => directory address\n    mapping(bytes32 => address) public directories;\n\n    // Mapping of keccak256(segment) => index in segments array\n    mapping(bytes32 => uint) public segmentsIndex;\n\n    // List of registered segments\n    string[] public segments;\n\n    // Address of Organization Factory\n    address public organizationFactory;\n\n    // hashed 'token.windingtree.eth' using eth-ens-namehash\n    bytes32 private constant tokenNamehash = 0x30151473c3396a0cfca504fc0f1ebc0fe92c65542ad3aaf70126c087458deb85;\n\n    /**\n     * @dev Event triggered when owner of the entrypoint is changed.\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Event triggered when a segment address is changed.\n     */\n    event SegmentSet(bytes32 indexed segment, address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Event triggered when the organization factory address is changed.\n     */\n    event OrganizationFactorySet(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Initializer for upgradeable contracts.\n     * @param __owner The address of the contract owner\n     * @param __lifToken The LifToken contract address\n     * @param _organizationFactory The OrganizationFactory contract address\n     */\n    function initialize(address payable __owner, address __lifToken, address _organizationFactory) public initializer {\n        require(__owner != address(0), 'WindingTreeEntrypoint: Cannot set owner to 0x0 address');\n        _owner = __owner;\n        _lifToken = __lifToken;\n        organizationFactory = _organizationFactory;\n        segments.length++;\n    }\n\n    \n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == _owner, 'WindingTreeEntrypoint: Only owner can call this method');\n        _;\n    }\n\n    function resolveLifTokenFromENS(address _ENS) public onlyOwner {\n        ENS registry = ENS(_ENS);\n        address resolverAddress = registry.resolver(tokenNamehash);\n        require(resolverAddress != address(0), 'WindingTreeEntrypoint: Resolver not found');\n        Resolver resolver = Resolver(resolverAddress);\n        address tokenAddress = resolver.addr(tokenNamehash);\n        require(tokenAddress != address(0), 'WindingTreeEntrypoint: Token not found');\n        _lifToken = tokenAddress;\n    }\n\n    /**\n     * @dev Sets an address for a segment. Overwrites existing value. Can\n     * be called only by the contract owner.\n     * @param segment Segment name\n     * @param addr New segment directory address\n     */\n    function setSegment(string memory segment, address addr) public onlyOwner {\n        require(addr != address(0), 'WindingTreeEntrypoint: Cannot set segment addr to 0x0 address');\n        bytes memory segmentBytes = bytes(segment);\n        require(segmentBytes.length != 0, 'WindingTreeEntrypoint: Segment cannot be empty');\n        bytes32 segmentHash = keccak256(segmentBytes);\n        if (segmentsIndex[segmentHash] == 0) {\n            segmentsIndex[segmentHash] = segments.length;\n            segments.push(segment);\n        }\n        emit SegmentSet(segmentHash, directories[segmentHash], addr);\n        directories[segmentHash] = addr;\n    }\n\n    /**\n     * @dev Sets an address for the organization factory. Overwrites existing\n     * value. Can be called only by the contract owner.\n     * @param addr New organization factory address\n     */\n    function setOrganizationFactory(address addr) public onlyOwner {\n        require(addr != address(0), 'WindingTreeEntrypoint: Cannot set factory addr to 0x0 address');\n        emit OrganizationFactorySet(organizationFactory, addr);\n        organizationFactory = addr;\n    }\n\n    /**\n     * @dev Returns Organization Factory address.\n     * @return {\" \": \"Address of the organization factory\"}\n     */\n    function getOrganizationFactory() public view returns(address) {\n        return organizationFactory;\n    }\n\n    /**\n     * @dev Sets an address for a segment to 0x0 address. Can be called\n     * only by the contract owner\n     * @param segment Segment name\n     */\n    function removeSegment(string memory segment) public onlyOwner {\n        bytes memory segmentBytes = bytes(segment);\n        require(segmentBytes.length != 0, 'WindingTreeEntrypoint: Segment cannot be empty');\n        bytes32 segmentHash = keccak256(segmentBytes);\n        delete segments[segmentsIndex[segmentHash]];\n        delete segmentsIndex[segmentHash];\n        emit SegmentSet(segmentHash, directories[segmentHash], address(0));\n        directories[segmentHash] = address(0);\n    }\n\n    /**\n     * @dev `getSegment` Returns address of a segment or a 0x0 address if segment\n     * is unknown.\n     * @param segment Segment name\n     * @return {\" \": \"Address of a segment\"}\n     */\n    function getSegment(string memory segment) public view returns(address) {\n        bytes memory segmentBytes = bytes(segment);\n        if(segmentBytes.length == 0) {\n            return address(0);\n        }\n        bytes32 segmentHash = keccak256(segmentBytes);\n        return directories[segmentHash];\n    }\n\n    /**\n     * @dev `getSegmentsLength` get the length of the `segments` array\n     * @return {\" \": \"Length of the segments array. Might contain removed segments.\"}\n     */\n    function getSegmentsLength() public view returns(uint) {\n        return segments.length;\n    }\n\n    /**\n     * @dev `getSegmentsIndex` get index of the segment by such name. On that\n     * index, segment's name is stored.\n     * @param segment Segment name\n     * @return {\" \": \"Index of the segment in segments array.\"}\n     */\n    function getSegmentsIndex(string memory segment) public view returns(uint) {\n        bytes memory segmentBytes = bytes(segment);\n        bytes32 segmentHash = keccak256(segmentBytes);\n        return segmentsIndex[segmentHash];\n    }\n\n    /**\n     * @dev `getSegmentName` get name of segment on given index\n     * @param index Segment index\n     * @return {\" \": \"Segment name.\"}\n     */\n    function getSegmentName(uint index) public view returns(string memory) {\n        return segments[index];\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        require(newOwner != address(0), 'WindingTreeEntrypoint: Cannot transfer to 0x0 address');\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev `getLifToken` Returns address of set Lif token\n     * @return {\" \": \"LifToken address.\"}\n     */\n    function getLifToken() public view returns (address) {\n        return _lifToken;\n    }\n\n}\n","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getSegmentsLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOrganizationFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"segments\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"segment\",\"type\":\"string\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setSegment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"segment\",\"type\":\"string\"}],\"name\":\"removeSegment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"directories\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ENS\",\"type\":\"address\"}],\"name\":\"resolveLifTokenFromENS\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getSegmentName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_lifToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"organizationFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"segment\",\"type\":\"string\"}],\"name\":\"getSegmentsIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLifToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"segmentsIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"segment\",\"type\":\"string\"}],\"name\":\"getSegment\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setOrganizationFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"__owner\",\"type\":\"address\"},{\"name\":\"__lifToken\",\"type\":\"address\"},{\"name\":\"_organizationFactory\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"segment\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"SegmentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"OrganizationFactorySet\",\"type\":\"event\"}]","ContractName":"WindingTreeEntrypoint","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://183b381bd1a53a5d4f001a29dc7c15109b249dff243d4dd4de64e2bae189541f"}]}