{"status":"1","message":"OK","result":[{"SourceCode":"// File: @gnosis.pm/util-contracts/contracts/Fixed192x64Math.sol\r\n\r\npragma solidity >=0.4.24 ^0.5.1;\r\n\r\n\r\n/// @title Fixed192x64Math library - Allows calculation of logarithmic and exponential functions\r\n/// @author Alan Lu - <alan.lu@gnosis.pm>\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\nlibrary Fixed192x64Math {\r\n\r\n    enum EstimationMode { LowerBound, UpperBound, Midpoint }\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    // This is equal to 1 in our calculations\r\n    uint public constant ONE =  0x10000000000000000;\r\n    uint public constant LN2 = 0xb17217f7d1cf79ac;\r\n    uint public constant LOG2_E = 0x171547652b82fe177;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Returns natural exponential function value of given x\r\n    /// @param x x\r\n    /// @return e**x\r\n    function exp(int x)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        // revert if x is > MAX_POWER, where\r\n        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE) * ONE))\r\n        require(x <= 2454971259878909886679);\r\n        // return 0 if exp(x) is tiny, using\r\n        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE) * ONE))\r\n        if (x <= -818323753292969962227)\r\n            return 0;\r\n\r\n        // Transform so that e^x -> 2^x\r\n        (uint lower, uint upper) = pow2Bounds(x * int(ONE) / int(LN2));\r\n        return (upper - lower) / 2 + lower;\r\n    }\r\n\r\n    /// @dev Returns estimate of 2**x given x\r\n    /// @param x exponent in fixed point\r\n    /// @param estimationMode whether to return a lower bound, upper bound, or a midpoint\r\n    /// @return estimate of 2**x in fixed point\r\n    function pow2(int x, EstimationMode estimationMode)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        (uint lower, uint upper) = pow2Bounds(x);\r\n        if(estimationMode == EstimationMode.LowerBound) {\r\n            return lower;\r\n        }\r\n        if(estimationMode == EstimationMode.UpperBound) {\r\n            return upper;\r\n        }\r\n        if(estimationMode == EstimationMode.Midpoint) {\r\n            return (upper - lower) / 2 + lower;\r\n        }\r\n        revert();\r\n    }\r\n\r\n    /// @dev Returns bounds for value of 2**x given x\r\n    /// @param x exponent in fixed point\r\n    /// @return {\r\n    ///   \"lower\": \"lower bound of 2**x in fixed point\",\r\n    ///   \"upper\": \"upper bound of 2**x in fixed point\"\r\n    /// }\r\n    function pow2Bounds(int x)\r\n        public\r\n        pure\r\n        returns (uint lower, uint upper)\r\n    {\r\n        // revert if x is > MAX_POWER, where\r\n        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE, 2) * ONE))\r\n        require(x <= 3541774862152233910271);\r\n        // return 0 if exp(x) is tiny, using\r\n        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE, 2) * ONE))\r\n        if (x < -1180591620717411303424)\r\n            return (0, 1);\r\n\r\n        // 2^x = 2^(floor(x)) * 2^(x-floor(x))\r\n        //       ^^^^^^^^^^^^^^ is a bit shift of ceil(x)\r\n        // so Taylor expand on z = x-floor(x), z in [0, 1)\r\n        int shift;\r\n        int z;\r\n        if (x >= 0) {\r\n            shift = x / int(ONE);\r\n            z = x % int(ONE);\r\n        }\r\n        else {\r\n            shift = (x+1) / int(ONE) - 1;\r\n            z = x - (int(ONE) * shift);\r\n        }\r\n        assert(z >= 0);\r\n        // 2^x = 1 + (ln 2) x + (ln 2)^2/2! x^2 + ...\r\n        //\r\n        // Can generate the z coefficients using mpmath and the following lines\r\n        // >>> from mpmath import mp\r\n        // >>> mp.dps = 100\r\n        // >>> coeffs = [mp.log(2)**i / mp.factorial(i) for i in range(1, 21)]\r\n        // >>> shifts = [64 - int(mp.log(c, 2)) for c in coeffs]\r\n        // >>> print('\\n'.join(hex(int(c * (1 << s))) + ', ' + str(s) for c, s in zip(coeffs, shifts)))\r\n        int result = int(ONE) << 64;\r\n        int zpow = z;\r\n        result += 0xb17217f7d1cf79ab * zpow;\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xf5fdeffc162c7543 * zpow >> (66 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xe35846b82505fc59 * zpow >> (68 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0x9d955b7dd273b94e * zpow >> (70 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xaec3ff3c53398883 * zpow >> (73 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xa184897c363c3b7a * zpow >> (76 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xffe5fe2c45863435 * zpow >> (80 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xb160111d2e411fec * zpow >> (83 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xda929e9caf3e1ed2 * zpow >> (87 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xf267a8ac5c764fb7 * zpow >> (91 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xf465639a8dd92607 * zpow >> (95 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xe1deb287e14c2f15 * zpow >> (99 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xc0b0c98b3687cb14 * zpow >> (103 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0x98a4b26ac3c54b9f * zpow >> (107 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xe1b7421d82010f33 * zpow >> (112 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0x9c744d73cfc59c91 * zpow >> (116 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xcc2225a0e12d3eab * zpow >> (121 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        zpow = 0xfb8bb5eda1b4aeb9 * zpow >> (126 - 64);\r\n        result += zpow;\r\n        zpow = int(8 * ONE);\r\n\r\n        shift -= 64;\r\n        if (shift >= 0) {\r\n            if (result >> (256-shift) == 0) {\r\n                lower = uint(result) << shift;\r\n                zpow <<= shift; // todo: is this safe?\r\n                if (lower + uint(zpow) >= lower)\r\n                    upper = lower + uint(zpow);\r\n                else\r\n                    upper = 2**256-1;\r\n                return (lower, upper);\r\n            }\r\n            else\r\n                return (2**256-1, 2**256-1);\r\n        }\r\n        zpow = (zpow >> (-shift)) + 1;\r\n        lower = uint(result) >> (-shift);\r\n        upper = lower + uint(zpow);\r\n        return (lower, upper);\r\n    }\r\n\r\n    /// @dev Returns natural logarithm value of given x\r\n    /// @param x x\r\n    /// @return ln(x)\r\n    function ln(uint x)\r\n        public\r\n        pure\r\n        returns (int)\r\n    {\r\n        (int lower, int upper) = log2Bounds(x);\r\n        return ((upper - lower) / 2 + lower) * int(ONE) / int(LOG2_E);\r\n    }\r\n\r\n    /// @dev Returns estimate of binaryLog(x) given x\r\n    /// @param x logarithm argument in fixed point\r\n    /// @param estimationMode whether to return a lower bound, upper bound, or a midpoint\r\n    /// @return estimate of binaryLog(x) in fixed point\r\n    function binaryLog(uint x, EstimationMode estimationMode)\r\n        public\r\n        pure\r\n        returns (int)\r\n    {\r\n        (int lower, int upper) = log2Bounds(x);\r\n        if(estimationMode == EstimationMode.LowerBound) {\r\n            return lower;\r\n        }\r\n        if(estimationMode == EstimationMode.UpperBound) {\r\n            return upper;\r\n        }\r\n        if(estimationMode == EstimationMode.Midpoint) {\r\n            return (upper - lower) / 2 + lower;\r\n        }\r\n        revert();\r\n    }\r\n\r\n    /// @dev Returns bounds for value of binaryLog(x) given x\r\n    /// @param x logarithm argument in fixed point\r\n    /// @return {\r\n    ///   \"lower\": \"lower bound of binaryLog(x) in fixed point\",\r\n    ///   \"upper\": \"upper bound of binaryLog(x) in fixed point\"\r\n    /// }\r\n    function log2Bounds(uint x)\r\n        public\r\n        pure\r\n        returns (int lower, int upper)\r\n    {\r\n        require(x > 0);\r\n        // compute ⌊log₂x⌋\r\n        lower = floorLog2(x);\r\n\r\n        uint y;\r\n        if (lower < 0)\r\n            y = x << uint(-lower);\r\n        else\r\n            y = x >> uint(lower);\r\n\r\n        lower *= int(ONE);\r\n\r\n        // y = x * 2^(-⌊log₂x⌋)\r\n        // so 1 <= y < 2\r\n        // and log₂x = ⌊log₂x⌋ + log₂y\r\n        for (int m = 1; m <= 64; m++) {\r\n            if(y == ONE) {\r\n                break;\r\n            }\r\n            y = y * y / ONE;\r\n            if(y >= 2 * ONE) {\r\n                lower += int(ONE >> m);\r\n                y /= 2;\r\n            }\r\n        }\r\n\r\n        return (lower, lower + 4);\r\n    }\r\n\r\n    /// @dev Returns base 2 logarithm value of given x\r\n    /// @param x x\r\n    /// @return logarithmic value\r\n    function floorLog2(uint x)\r\n        public\r\n        pure\r\n        returns (int lo)\r\n    {\r\n        lo = -64;\r\n        int hi = 193;\r\n        // I use a shift here instead of / 2 because it floors instead of rounding towards 0\r\n        int mid = (hi + lo) >> 1;\r\n        while((lo + 1) < hi) {\r\n            if (mid < 0 && x << uint(-mid) < ONE || mid >= 0 && x >> uint(mid) < ONE)\r\n                hi = mid;\r\n            else\r\n                lo = mid;\r\n            mid = (hi + lo) >> 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns maximum of an array\r\n    /// @param nums Numbers to look through\r\n    /// @return Maximum number\r\n    function max(int[] memory nums)\r\n        public\r\n        pure\r\n        returns (int maxNum)\r\n    {\r\n        require(nums.length > 0);\r\n        maxNum = -2**255;\r\n        for (uint i = 0; i < nums.length; i++)\r\n            if (nums[i] > maxNum)\r\n                maxNum = nums[i];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"LN2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"estimationMode\",\"type\":\"Fixed192x64Math.EstimationMode\"}],\"name\":\"binaryLog\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"log2Bounds\",\"outputs\":[{\"name\":\"lower\",\"type\":\"int256\"},{\"name\":\"upper\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"int256\"},{\"name\":\"estimationMode\",\"type\":\"Fixed192x64Math.EstimationMode\"}],\"name\":\"pow2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOG2_E\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"ln\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"floorLog2\",\"outputs\":[{\"name\":\"lo\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"pow2Bounds\",\"outputs\":[{\"name\":\"lower\",\"type\":\"uint256\"},{\"name\":\"upper\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nums\",\"type\":\"int256[]\"}],\"name\":\"max\",\"outputs\":[{\"name\":\"maxNum\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"exp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"Fixed192x64Math","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://ea4753e10284cc276a52ddc4afa9e3f32cf6274d4f51d8b83785eddc7bf1361c"}]}