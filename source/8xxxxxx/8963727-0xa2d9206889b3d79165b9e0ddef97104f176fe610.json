{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n***The Shuffle Raffle***\r\n\r\nhttps://shuffle-raffle.com/\r\n\r\nThe shuffle raffle is a game built on top of the Shuffle Monster token (https://shuffle.monster/).\r\nPlayers can buy tickets with SHUF tokens. Each week a winner is randomly picked. \r\n\r\n*/\r\n\r\npragma solidity ^0.5.8;\r\n\r\ncontract ERC20Token {\r\n  function totalSupply() public view returns(uint);\r\n  function balanceOf(address tokenOwner) public view returns(uint balance);\r\n  function allowance(address tokenOwner, address spender) public view returns(uint remaining);\r\n  function transfer(address to, uint tokens) public returns(bool success);\r\n  function approve(address spender, uint tokens) public returns(bool success);\r\n  function transferFrom(address from, address to, uint tokens) public returns(bool success);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    \r\n     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n     function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n \r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() public {\r\n      owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n      require(msg.sender == owner);\r\n      _;\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n      require(newOwner != address(0));\r\n      emit OwnershipTransferred(owner, newOwner);\r\n      owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ShuffleRaffle is Ownable {\r\n    using SafeMath for uint256;\r\n    \r\n    struct Order {\r\n        uint48 position;\r\n        uint48 size;\r\n        address owner;\r\n    }\r\n    \r\n    mapping(uint256 => Order[]) TicketBook;\r\n    ERC20Token public shuf = ERC20Token(0x3A9FfF453d50D4Ac52A6890647b823379ba36B9E);\r\n    uint256 public RaffleNo = 1;\r\n    uint256 public TicketPrice = 5*10**18;\r\n    uint256 public PickerReward = 5*10**18;\r\n    uint256 public minTickets = 9;\r\n    uint256 public nextTicketPrice = 5*10**18;\r\n    uint256 public nextPickerReward = 5*10**18;\r\n    uint256 public nextminTickets = 9;\r\n    uint256 public NextRaffle = 1574197200;\r\n    uint256 public random_seed = 0;\r\n    bool    public raffle_closed = false;\r\n\r\n    event Ticket(uint256 raffle, address indexed addr, uint256 amount);\r\n    event Winner(uint256 raffle, address indexed addr, uint256 amount, uint256 win_ticket);\r\n    event RaffleClosed(uint256 raffle, uint256 block_number);\r\n    event TicketPriceChanged(uint256 previousticketprice, uint256 newticketprice);\r\n    event PickerRewardChanged(uint256 previouspickerReward, uint256 newpickerreward);\r\n    event minTicketsChanged(uint256 previousminTickets,uint256 newmintickets);\r\n\r\n    function TicketsOfAddress(address addr) public view returns (uint256 total_tickets) {\r\n        uint256 _tt=0;\r\n        for(uint256 i = 0; i<TicketBook[RaffleNo].length; i++){\r\n            if (TicketBook[RaffleNo][i].owner == addr)\r\n                _tt=_tt.add(TicketBook[RaffleNo][i].size);\r\n        }\r\n        return _tt;\r\n    }\r\n\r\n    function Stats() public view returns (uint256 raffle_number, uint48 total_tickets, uint256 balance, uint256 next_raffle, uint256 ticket_price, bool must_pick_winner, uint256 picker_reward, uint256 min_tickets,uint256 next_ticket_price,uint256 next_picker_reward,uint256 next_min_tickets, bool is_raffle_closed){\r\n        bool mustPickWinner;\r\n        uint48 TotalTickets= _find_curr_position();\r\n        if (now>NextRaffle && TotalTickets>minTickets)\r\n            mustPickWinner = true;\r\n        else\r\n            mustPickWinner = false;\r\n        return (RaffleNo, TotalTickets, shuf.balanceOf(address(this)), NextRaffle, TicketPrice, mustPickWinner, PickerReward, minTickets, nextTicketPrice, nextPickerReward, nextminTickets, raffle_closed);\r\n    }\r\n    \r\n    function BuyTicket(uint48 tickets) external returns(bool success){\r\n        uint256 bill = uint256(tickets).mul(TicketPrice);\r\n        uint48 TotalTickets= _find_curr_position();\r\n        require(tickets>0);\r\n        require(shuf.allowance(msg.sender, address(this))>=bill, \"Contract not approved\");\r\n        require(shuf.balanceOf(msg.sender)>=bill , \"Not enough SHUF balance.\");\r\n        if (now>NextRaffle){\r\n            //requires to pick a winner or extends duration if not enough participants\r\n            require(TotalTickets<=minTickets,\"A winner has to be picked first\");\r\n            NextRaffle = NextRaffle.add((((now.sub(NextRaffle)).div(60)).add(1)).mul(60));\r\n        }\r\n        shuf.transferFrom(msg.sender, address(this), bill);\r\n\r\n        Order memory t;\r\n        t.size=tickets;\r\n        t.owner=msg.sender;\r\n        t.position=TotalTickets+tickets;\r\n        require(t.position>=TotalTickets);\r\n        TicketBook[RaffleNo].push(t);\r\n        \r\n        emit Ticket(RaffleNo, msg.sender, tickets);\r\n        return true;\r\n    }\r\n    \r\n   \r\n    function pickWinner() external returns(bool success) {\r\n        require(now>NextRaffle, \"It's not time to pick a winner yet\");\r\n        uint256 Totaltickets =_find_curr_position(); \r\n        require(Totaltickets>minTickets,  \"Not enough tickets to pick a winner\");\r\n        \r\n        //Close the Raffle\r\n        if (raffle_closed == false){\r\n            raffle_closed = true;\r\n            random_seed = block.number;\r\n            emit RaffleClosed(RaffleNo, random_seed);\r\n            shuf.transfer(msg.sender, PickerReward);\r\n            return true;\r\n        }\r\n\r\n        uint256 winningticket = _random(Totaltickets);\r\n        address winner = _find_winner(winningticket);\r\n     \r\n        //reward caller\r\n        shuf.transfer(msg.sender, PickerReward);\r\n    \r\n        //reward winner \r\n        uint256 reward = shuf.balanceOf(address(this));\r\n        shuf.transfer(winner,reward);\r\n        emit Winner(RaffleNo, winner, reward, winningticket);\r\n        \r\n        //reset Raffle\r\n        RaffleNo=RaffleNo.add(1);\r\n        NextRaffle = NextRaffle.add((((now.sub(NextRaffle)).div(5 days + 12 hours)).add(1)).mul(5 days + 12 hours));\r\n        raffle_closed = false;\r\n        \r\n        //check for changes\r\n        if(nextTicketPrice!=TicketPrice){\r\n            uint256 oldticketPrice=TicketPrice;\r\n            TicketPrice = nextTicketPrice;\r\n            emit TicketPriceChanged(oldticketPrice, TicketPrice);\r\n        }\r\n        if(nextPickerReward!=PickerReward){\r\n            uint256 oldpickerReward=PickerReward;\r\n            PickerReward = nextPickerReward;\r\n            emit PickerRewardChanged(oldpickerReward, PickerReward);\r\n        }\r\n        if(nextminTickets!=minTickets){\r\n            uint256 oldminTickets=minTickets;\r\n            minTickets = nextminTickets;\r\n            emit minTicketsChanged(oldminTickets, minTickets);\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function _find_curr_position() internal view returns(uint48 curr_position){\r\n        uint256 TotalOrders= TicketBook[RaffleNo].length;\r\n        uint48 Totaltickets=(TotalOrders>0)?TicketBook[RaffleNo][TotalOrders.sub(1)].position:0;\r\n        return Totaltickets;\r\n    }\r\n    \r\n     function _find_winner(uint256 winning_ticket)  internal view returns(address winner){\r\n    //search for the winner using binary search\r\n        uint256 L=0;\r\n        uint256 R=TicketBook[RaffleNo].length.sub(1);\r\n        uint256 raffleno=RaffleNo;\r\n        \r\n        while(L <= R){\r\n            uint256 m = (L.add(R)).div(2);\r\n            Order memory Am = TicketBook[raffleno][m];\r\n            if(Am.position<winning_ticket)\r\n                L=m.add(1);\r\n            else if(Am.position-Am.size>=winning_ticket)\r\n                R=m.sub(1);\r\n            else\r\n                return Am.owner;\r\n        }\r\n        return address(this);\r\n    }\r\n    \r\n    function setTicketPrice(uint256 newticketprice) external onlyOwner {\r\n        nextTicketPrice= newticketprice;\r\n    }\r\n    \r\n    function setPickerReward(uint256 newpickerreward) external onlyOwner {\r\n        nextPickerReward = newpickerreward;\r\n    }\r\n    \r\n    function setminTickets(uint256 newmintickets) external onlyOwner {\r\n        nextminTickets = newmintickets;\r\n    }\r\n  \r\n    function _random(uint256 Totaltickets) internal view returns (uint256) {\r\n        return uint256(uint256(keccak256(abi.encodePacked(blockhash(random_seed), RaffleNo)))%Totaltickets).add(1);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"nextminTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newticketprice\",\"type\":\"uint256\"}],\"name\":\"setTicketPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextTicketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newmintickets\",\"type\":\"uint256\"}],\"name\":\"setminTickets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TicketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RaffleNo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pickWinner\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NextRaffle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextPickerReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"random_seed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Stats\",\"outputs\":[{\"name\":\"raffle_number\",\"type\":\"uint256\"},{\"name\":\"total_tickets\",\"type\":\"uint48\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"next_raffle\",\"type\":\"uint256\"},{\"name\":\"ticket_price\",\"type\":\"uint256\"},{\"name\":\"must_pick_winner\",\"type\":\"bool\"},{\"name\":\"picker_reward\",\"type\":\"uint256\"},{\"name\":\"min_tickets\",\"type\":\"uint256\"},{\"name\":\"next_ticket_price\",\"type\":\"uint256\"},{\"name\":\"next_picker_reward\",\"type\":\"uint256\"},{\"name\":\"next_min_tickets\",\"type\":\"uint256\"},{\"name\":\"is_raffle_closed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"TicketsOfAddress\",\"outputs\":[{\"name\":\"total_tickets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PickerReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newpickerreward\",\"type\":\"uint256\"}],\"name\":\"setPickerReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shuf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raffle_closed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tickets\",\"type\":\"uint48\"}],\"name\":\"BuyTicket\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"raffle\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Ticket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"raffle\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"win_ticket\",\"type\":\"uint256\"}],\"name\":\"Winner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"raffle\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block_number\",\"type\":\"uint256\"}],\"name\":\"RaffleClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousticketprice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newticketprice\",\"type\":\"uint256\"}],\"name\":\"TicketPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previouspickerReward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newpickerreward\",\"type\":\"uint256\"}],\"name\":\"PickerRewardChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousminTickets\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newmintickets\",\"type\":\"uint256\"}],\"name\":\"minTicketsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ShuffleRaffle","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"GNU GPLv3","SwarmSource":"bzzr://aec6d4c1d5e4fb91ead8d0d73a719ccad1166fb0bfe652065f87353a7bf954f5"}]}