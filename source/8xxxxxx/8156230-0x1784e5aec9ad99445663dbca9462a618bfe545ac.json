{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.26;\r\n\r\n//This is the public contract for the NebliDex decentralized exchange ERC20 swap with a non-ETH coin\r\n//This exchange can be used to trade cryptocurrencies in a decentralized way without intermediaries or proxy tokens\r\n//As of July 14th, 2019, the exchange website can be found at www.neblidex.xyz\r\n\r\n//Contract source based on code provided from: https://github.com/jchittoda/eth-atomic-swap/\r\n\r\n//Abstract ERC20 contract\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint value);  \r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n  function balanceOf(address who) public constant returns (uint);\r\n  function allowance(address owner, address spender) public constant returns (uint);\r\n\r\n  function transfer(address to, uint value) public returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n  function approve(address spender, uint value) public returns (bool ok);  \r\n}\r\n\r\n//Main swap contract\r\ncontract NebliDex_AtomicSwap_ERC20 {\r\n\r\n  struct Swap {\r\n    uint256 timelock;\r\n    uint256 erc20Value;\r\n    address erc20Trader;\r\n    address erc20ContractAddress; // Address of token contract\r\n    address withdrawTrader;\r\n    bytes32 secretLock;\r\n    bytes secretKey;\r\n  }\r\n\r\n  enum States {\r\n    INVALID,\r\n    OPEN,\r\n    CLOSED,\r\n    EXPIRED\r\n  }\r\n\r\n  mapping (bytes32 => Swap) private swaps;\r\n  mapping (bytes32 => States) private swapStates;\r\n\r\n  event Open(bytes32 _swapID, address _withdrawTrader);\r\n  event Expire(bytes32 _swapID);\r\n  event Close(bytes32 _swapID, bytes _secretKey);\r\n\r\n  modifier onlyInvalidSwaps(bytes32 _swapID) {\r\n    require (swapStates[_swapID] == States.INVALID);\r\n    _;\r\n  }\r\n\r\n  modifier onlyOpenSwaps(bytes32 _swapID) {\r\n    require (swapStates[_swapID] == States.OPEN);\r\n    _;\r\n  }\r\n\r\n  modifier onlyClosedSwaps(bytes32 _swapID) {\r\n    require (swapStates[_swapID] == States.CLOSED);\r\n    _;\r\n  }\r\n\r\n  modifier onlyExpiredSwaps(bytes32 _swapID) {\r\n    require (now >= swaps[_swapID].timelock);\r\n    _;\r\n  }\r\n\r\n  // Cannot redeem amount if timelock has expired\r\n  modifier onlyNotExpiredSwaps(bytes32 _swapID) {\r\n    require (now < swaps[_swapID].timelock);\r\n    _;\r\n  }\r\n\r\n  modifier onlyWithSecretKey(bytes32 _swapID, bytes _secretKey) {\r\n    require (_secretKey.length == 33); // The key must be this length across the board\r\n    require (swaps[_swapID].secretLock == sha256(_secretKey));\r\n    _;\r\n  }\r\n\r\n  //Unlike ETH swap, this function is not payable thus no ETH accepted\r\n  function open(bytes32 _swapID, uint256 _erc20Value, address _erc20ContractAddress, address _withdrawTrader, uint256 _timelock) public onlyInvalidSwaps(_swapID) {\r\n    require(swapStates[_swapID] == States.INVALID); //Redundancy for second layer re-entry protection\r\n    // Transfer value from the ERC20 trader to this contract.\r\n    ERC20 erc20Contract = ERC20(_erc20ContractAddress);\r\n    require(_erc20Value > 0); //We cannot send a zero token amount\r\n    require(_erc20Value <= erc20Contract.allowance(msg.sender, address(this))); // We must transfer less than that we approve in the ERC20 token contract\r\n    require(erc20Contract.transferFrom(msg.sender, address(this), _erc20Value)); // Now take the tokens from the sending user and store in this contract\r\n\r\n    // Store the details of the swap.\r\n    Swap memory swap = Swap({\r\n      timelock: _timelock,\r\n      erc20Value: _erc20Value,\r\n      erc20Trader: msg.sender,\r\n      erc20ContractAddress: _erc20ContractAddress,\r\n      withdrawTrader: _withdrawTrader,\r\n      secretLock: _swapID,\r\n      secretKey: new bytes(0)\r\n    });\r\n    swaps[_swapID] = swap;\r\n    swapStates[_swapID] = States.OPEN;\r\n\r\n    // Trigger open event\r\n    emit Open(_swapID, _withdrawTrader);\r\n  }\r\n\r\n  function redeem(bytes32 _swapID, bytes _secretKey) public onlyOpenSwaps(_swapID) onlyNotExpiredSwaps(_swapID) onlyWithSecretKey(_swapID, _secretKey) {\r\n    // Redeem the value from the contract.\r\n    Swap memory swap = swaps[_swapID];\r\n    swaps[_swapID].secretKey = _secretKey;\r\n    swapStates[_swapID] = States.CLOSED;\r\n\r\n    // Transfer the ERC20 funds from this contract to the withdrawing trader.\r\n    ERC20 erc20Contract = ERC20(swap.erc20ContractAddress);\r\n    require(erc20Contract.transfer(swap.withdrawTrader, swap.erc20Value));\r\n\r\n    // Trigger close event.\r\n    emit Close(_swapID, _secretKey);    \r\n  }\r\n\r\n  function refund(bytes32 _swapID) public onlyOpenSwaps(_swapID) onlyExpiredSwaps(_swapID) {\r\n    // Expire the swap.\r\n    Swap memory swap = swaps[_swapID];\r\n    swapStates[_swapID] = States.EXPIRED;\r\n\r\n    // Transfer the ERC20 value from this contract back to the ERC20 trader.\r\n    ERC20 erc20Contract = ERC20(swap.erc20ContractAddress);\r\n    require(erc20Contract.transfer(swap.erc20Trader, swap.erc20Value));\r\n\r\n    // Trigger expire event.\r\n    emit Expire(_swapID);\r\n  }\r\n\r\n  function check(bytes32 _swapID) public view returns (uint256 timelock, uint256 erc20Value, address erc20ContractAddress, address withdrawTrader, bytes32 secretLock) {\r\n    Swap memory swap = swaps[_swapID];\r\n    return (swap.timelock, swap.erc20Value, swap.erc20ContractAddress, swap.withdrawTrader, swap.secretLock);\r\n  }\r\n\r\n  function checkSecretKey(bytes32 _swapID) public view onlyClosedSwaps(_swapID) returns (bytes secretKey) {\r\n    Swap memory swap = swaps[_swapID];\r\n    return swap.secretKey;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"name\":\"_erc20Value\",\"type\":\"uint256\"},{\"name\":\"_erc20ContractAddress\",\"type\":\"address\"},{\"name\":\"_withdrawTrader\",\"type\":\"address\"},{\"name\":\"_timelock\",\"type\":\"uint256\"}],\"name\":\"open\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"check\",\"outputs\":[{\"name\":\"timelock\",\"type\":\"uint256\"},{\"name\":\"erc20Value\",\"type\":\"uint256\"},{\"name\":\"erc20ContractAddress\",\"type\":\"address\"},{\"name\":\"withdrawTrader\",\"type\":\"address\"},{\"name\":\"secretLock\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"checkSecretKey\",\"outputs\":[{\"name\":\"secretKey\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"name\":\"_secretKey\",\"type\":\"bytes\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_withdrawTrader\",\"type\":\"address\"}],\"name\":\"Open\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"Expire\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_secretKey\",\"type\":\"bytes\"}],\"name\":\"Close\",\"type\":\"event\"}]","ContractName":"NebliDex_AtomicSwap_ERC20","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b837fa93708e150d6be75f6dcf685a2976b1e2cc149b1102b8a0859091255669"}]}