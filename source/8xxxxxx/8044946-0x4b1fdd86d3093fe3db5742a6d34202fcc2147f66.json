{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.7;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface PrimaryStorage {\r\n    function addProject() external returns (uint256 pid);\r\n    function setControllerStateToProject(uint256 pid) external;\r\n    function getCurrentControllersHash() external view returns (bytes32 controllerState);\r\n    function getMinInvestorContribution() external view returns (uint256);\r\n    function getMaxInvestorContribution() external view returns (uint256);\r\n    function isInvestor(address who) external view returns (bool);\r\n    function addNewInvestor(address newInvestorAddress) external returns (uint256 numberOfInvestors);\r\n    function setInvestorId(address newInvestor, uint256 investorId) external;\r\n    function setInvestor(address newInvestor) external;\r\n    function setReferrer(address newInvestor, address referrerAddress) external;\r\n    function addInsurance() external returns (uint256 insuranceId);\r\n    function setControllerStateToInsurance(uint256 insId, bytes32 ctrl) external;\r\n    function setInsuranceId(uint256 insId) external;\r\n    function setInsuranceProjectId(uint256 insId, uint256 pid) external;\r\n    function setInsuranceOwner(uint256 insId, address insOwner) external;\r\n    function setTimeOfTheRequest(uint256 insId) external;\r\n    function setInsuranceRate(uint256 insId, uint256 protectionPercentage) external;\r\n    function getRegularContributionPercentage() external view returns (uint256);\r\n    function getInsuranceRate(uint256 insId) external view returns (uint256);\r\n    function setEtherSecured(uint256 insId, uint256 amount) external;\r\n    function setPoolContribution(uint256 insId, uint256 amount) external;\r\n    function getMinProtectionPercentage() external view returns (uint256);\r\n    function getMaxOwnerContribution() external view returns (uint256);\r\n    function getMinOwnerContribution() external view returns (uint256);\r\n    function getMaxProtectionPercentage() external view returns (uint256);\r\n    function setProjectOwner(address newOwnerAddr) external;\r\n    function isCanceled(uint256 insId) external view returns (bool);\r\n    function getInsuranceOwner(uint256 insId) external view returns (address);\r\n    function getEtherSecured(uint256 insId) external view returns (uint256);\r\n    function getRefundEtherTokenAddress() external view returns (address);\r\n    function getdAppState(bytes32 cntrllrs)\r\n\t\t\t\texternal\r\n\t\t\t\tview\r\n\t\t\t\treturns (address projectCtrl, address refundCtrl, address disputeCtrl, address utilityCtrl);\r\n    function getPoolContribution(uint256 insId) external view returns (uint256);\r\n    function isProjectOwner(address who) external view returns (bool);\r\n    function getModerationResources() external view returns (address payable);\r\n}\r\n\r\n\r\ninterface SecondaryStorage {\r\n    function getCrowdsaleEndTime(uint256 pid) external view returns (uint256);\r\n    function addProject() external returns (uint256 projectId);\r\n    function setInitialProtectionRate(uint256 pid) external;\r\n    function setPercentageFloatContainer(uint256 pid, uint256 amountOfFunds) external;\r\n    function setProjectId(uint256 pid) external;\r\n    function setVotesForRefundState(uint256 pid, uint256 numberOfVotes) external;\r\n    function setPolicyEnd(uint256 pid) external;\r\n    function setPolicyBase(uint256 pid) external;\r\n    function setAmountOfFundsContributed(uint256 pid, uint256 amount) external;\r\n    function setReturnedRefundTokens(uint256 pid, uint256 amount) external;\r\n    function setTotalAmountSecuredEther(uint256 pid, uint256 amount) external;\r\n    function setFreezeStatePeriod(uint256 pid, uint256 numberInBlocks) external;\r\n    function setRefundStatePeriod(uint256 pid, uint256 numberInBlocks) external;\r\n    function setOwnerContribution(uint256 pid, uint256 amount) external;\r\n    function setOwnerFunds(uint256 pid, address ownerAddr, uint256 amount) external;\r\n    function setInsuranceIdToProject(uint256 pid, uint256 insId) external;\r\n    function setOwnerPercentageFloatContainer(uint256 pid, uint256 amountOfFunds) external;\r\n    function setProjectName(uint256 pid, bytes calldata name) external;\r\n    function setProjectTokenContract(uint256 pid, address tokenAddress) external;\r\n    function setCrowdsaleEndTime(uint256 pid, uint256 crowdsaleEnd) external;\r\n    function setHighestTokenPrice(uint256 pid, uint256 highestTokenPrice) external;\r\n    function setTokenDecimals(uint256 pid, uint8 tokenDecimals) external;\r\n    function getProjectControllerState(uint256 pid) external view returns (bytes32);\r\n    function getProtectionRate(uint256 pid) external view returns (uint256);\r\n    function getAlreadyProtected(uint256 pid, address investor) external view returns(bool isProtected);\r\n    function getHighestTokenPrice(uint256 pid) external view returns (uint256);\r\n    function getTokenDecimals(uint256 pid) external view returns (uint8);\r\n    function setTokenLitter(uint256 pid, uint256 insId, address tokenLitter) external;\r\n    function setMinAmountProjectTokens(uint256 pid, uint256 minAmountProjectTokens, address investor) external;\r\n    function getAmountOfFundsContributed(uint256 pid) external view returns (uint256);\r\n    function setProtectionRate(uint256 pid, uint256 protectionPercentage) external;\r\n    function setAlreadyProtected(uint256 pid, address investor) external;\r\n    function getOwnerContribution(uint256 pid) external view returns (uint256);\r\n    function getInvestmentToProject(uint256 pid, uint256 insuranceNumber)\r\n\t\t\t\texternal\r\n\t\t\t\tview\r\n\t\t\t\treturns (uint256 investmentId);\r\n    function setProjectCurrentState(uint256 pid, uint8 currentState) external;\r\n    function getPercentageFloatContainer(uint256 pid) external view returns (uint256);\r\n    function getMinAmountProjectTokens(uint256 pid, address investor) external view returns (uint256);\r\n    function getProjectCurrentState(uint256 pid) external view returns (uint8);\r\n    function getOwnerPercentageFloatContainer(uint256 pid) external view returns (uint256);\r\n    function getOwnerFunds(uint256 pid, address ownerAddr) external view returns (uint256);\r\n    function getNumberOfProjectInvestments(uint256 pid) external view returns (uint256);\r\n    function getTotalAmountSecuredEther(uint256 pid) external view returns (uint256);\r\n    function setInvestorToProject(uint256 pid, address investor) external;\r\n    function getNumberOfCoveredProjects() external view returns (uint256);\r\n}\r\n\r\n\r\ninterface RefundEther {\r\n    function transfer(address _to, uint value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function burn(address _tokensOwner, uint256 _value) external returns (bool success);\r\n    function mint(address target, uint256 mintedAmount) external;\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function getAmountOfSecuredEther(address investor, uint256 projectId) external view returns (uint256);\r\n    function setAmountOfSecuredEther(address investor, uint256 projectId, uint256 amount)\r\n\t\t\t\texternal\r\n\t\t\t\treturns (bool success);\r\n    function totalSupply() external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface RefundPool {\r\n    function deposit(uint256 pid) external payable;\r\n    function insuranceDeposit(uint256 pid) external payable;\r\n    function getProjectFunds (uint256 pid) external view returns (uint256);\r\n    function withdraw(uint256 pid, address payable to, uint256 amount) external;\r\n    function withdrawInsuranceFee(uint256 pid, address payable to, uint256 amount) external;\r\n    function cleanIfNoProjects() external;\r\n}\r\n\r\n\r\ninterface AffiliateEscrow {\r\n    function deposit(address affiliate) external payable;\r\n    function getAffiliatePayment (address affiliate) external view returns (uint256);\r\n    function withdraw(address to) external;\r\n    function updateControllerState(\r\n\t\t\t\taddress payable projectCtrl,\r\n\t\t\t\taddress payable refundCtrl,\r\n\t\t\t\taddress payable disputeCtrl,\r\n\t\t\t\taddress payable utilityCtrl\r\n\t\t)\r\n\t\t\t\texternal;\r\n}\r\n\r\n\r\ninterface Logger {\r\n    function emitNewInsurance(\r\n        uint256 pid,\r\n        address insuranceOwner,\r\n        uint256 insuranceId,\r\n        uint256 contributedAmount\r\n    )\r\n        external;\r\n\r\n    function emitNewProject(uint256 pid, bytes calldata projectName) external;\r\n    function emitOwnerContribution(\r\n        uint256 pid,\r\n        address ownerAddress,\r\n        uint256 ownerPoolContribution,\r\n        uint256 newProtectionRate\r\n    )\r\n        external;\r\n    function emitNewTokenPrice(uint256 pid, uint256 newPrice, uint256 insurancesProcessed) external;\r\n}\r\n\r\n\r\n/**\r\n  *\r\n  *  Refundable Token Offerings\r\n  *  Project Controller\r\n  *\r\n  */\r\n\r\ncontract ProjectController {\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint64;\r\n    using SafeMath for uint8;\r\n\r\n    PrimaryStorage   masterStorage;\r\n    SecondaryStorage secondStorage;\r\n\r\n    RefundPool refundPool;\r\n    AffiliateEscrow affiliate;\r\n    RefundEther refundEther;\r\n    Logger eventLogger;\r\n\r\n    address payable private main;\r\n    address payable private modResources;\r\n\r\n    constructor(\r\n        address payable dAppMainContractAddr,\r\n        address storageAddr,\r\n        address secStorageAddr,\r\n        address refundEtherAddr,\r\n        address eventLoggerAddr,\r\n        address payable modResourcesAddr,\r\n        address payable refundPoolAddr,\r\n        address payable affiliateEscrowAddr\r\n    )\r\n        public\r\n    {\r\n        masterStorage = PrimaryStorage(storageAddr);\r\n        secondStorage = SecondaryStorage(secStorageAddr);\r\n        refundPool = RefundPool(refundPoolAddr);\r\n        affiliate = AffiliateEscrow(affiliateEscrowAddr);\r\n        refundEther = RefundEther(refundEtherAddr);\r\n        modResources = modResourcesAddr;\r\n        eventLogger = Logger(eventLoggerAddr);\r\n        main = dAppMainContractAddr;\r\n    }\r\n\r\n    modifier onlyMain {\r\n        _isMain();\r\n        _;\r\n    }\r\n\r\n    modifier onlyInsuranceOwner(uint256 insId) {\r\n        require (msg.sender == masterStorage.getInsuranceOwner(insId), \"Not allowed\");\r\n        _;\r\n    }\r\n\r\n    function newProject(\r\n        bytes   calldata projectName,\r\n        address tokenAddress,\r\n        uint256 crowdsaleEnd,\r\n        uint256 highestCrowdsalePrice,\r\n        uint8   tokenDecimals\r\n    )\r\n        external\r\n        payable\r\n        onlyMain\r\n    {\r\n        uint256 pid = masterStorage.addProject();\r\n\r\n        masterStorage.setControllerStateToProject(pid);\r\n        secondStorage.setProjectId(pid);\r\n        secondStorage.setInitialProtectionRate(pid);\r\n        secondStorage.setPolicyBase(pid);\r\n        secondStorage.setPolicyEnd(pid);\r\n\r\n        secondStorage.setVotesForRefundState(pid, 1);\r\n        secondStorage.setPercentageFloatContainer(pid, 1);\r\n        secondStorage.setAmountOfFundsContributed(pid, 1);\r\n        secondStorage.setTotalAmountSecuredEther(pid, 1);\r\n        secondStorage.setReturnedRefundTokens(pid, 1);\r\n\r\n        secondStorage.setOwnerContribution(pid, 1);\r\n        secondStorage.setOwnerPercentageFloatContainer(pid, 1);\r\n        secondStorage.setInsuranceIdToProject(pid, 0);\r\n        secondStorage.setInvestorToProject(pid, address(0));\r\n\r\n        secondStorage.setRefundStatePeriod(pid, 1);\r\n        secondStorage.setFreezeStatePeriod(pid, 1);\r\n\r\n        secondStorage.setProjectName(pid, projectName);\r\n        secondStorage.setProjectTokenContract(pid, tokenAddress);\r\n        secondStorage.setCrowdsaleEndTime(pid, crowdsaleEnd);\r\n        secondStorage.setHighestTokenPrice(pid, highestCrowdsalePrice);\r\n        secondStorage.setTokenDecimals(pid, tokenDecimals);\r\n\r\n        if (msg.value != 0) {\r\n            refundPool.deposit.value(msg.value)(pid);\r\n        }\r\n        eventLogger.emitNewProject(pid, projectName);\r\n    }\r\n\r\n    function newInsurance(\r\n        address payable insOwner,\r\n        uint256 pid,\r\n        address referrer\r\n    )\r\n        external\r\n        payable\r\n        onlyMain\r\n        returns (bool)\r\n    {\r\n        bytes32 cntrllrs = secondStorage.getProjectControllerState(pid);\r\n        if (block.number > secondStorage.getCrowdsaleEndTime(pid).add(93558) && isOpen(pid)) {\r\n            _closeProject(pid);\r\n            insOwner.transfer(msg.value);\r\n            return false;\r\n        }\r\n        uint256 ins = _newInsuranceInit(pid, insOwner, referrer, cntrllrs);\r\n        _newInsuranceCalculations(pid, ins, insOwner, referrer);\r\n        secondStorage.setTokenLitter(pid, ins, _createTokenLitter(insOwner, pid, ins));\r\n        uint256 npc = _calcPoolContribution(bool(referrer != address(0)), referrer, msg.value);\r\n        uint256 nfp = secondStorage.getAmountOfFundsContributed(pid).add(npc);\r\n        masterStorage.setPoolContribution(ins, npc);\r\n        secondStorage.setAmountOfFundsContributed(pid, nfp);\r\n\r\n        secondStorage.setAlreadyProtected(pid, insOwner);\r\n        secondStorage.setInsuranceIdToProject(pid, ins);\r\n        secondStorage.setInvestorToProject(pid, insOwner);\r\n        _newProtectionRate(pid, nfp);\r\n        refundPool.insuranceDeposit.value(npc)(pid);\r\n\r\n        eventLogger.emitNewInsurance(pid, insOwner, ins, msg.value);\r\n    }\r\n\r\n    function newOwnerContribution(\r\n        uint256 pid,\r\n        address ownerAddr\r\n    )\r\n        external\r\n        payable\r\n        onlyMain\r\n    {\r\n        require(pid < secondStorage.getNumberOfCoveredProjects(), \"Invalid project ID\");\r\n        uint256 ifactp = secondStorage.getAmountOfFundsContributed(pid);\r\n        uint256 mcnmpr = masterStorage.getMinOwnerContribution();\r\n        if (ifactp < 88 ether) {\r\n            mcnmpr;\r\n        }\r\n\r\n        if (ifactp >= 88 ether && ifactp < 288 ether) {\r\n            mcnmpr = mcnmpr.mul(2).add(1);\r\n        }\r\n\r\n        if (ifactp >= 288 ether) {\r\n            mcnmpr = mcnmpr.mul(4);\r\n        }\r\n\r\n        require(msg.value >= mcnmpr, \"Owner contribution is below the minimum amount required\");\r\n\r\n        uint256 cpr = secondStorage.getProtectionRate(pid);\r\n        uint256 pfc = secondStorage.getOwnerPercentageFloatContainer(pid);\r\n        uint256 npr;\r\n        uint256 rmn;\r\n        secondStorage.setOwnerPercentageFloatContainer(pid, cpr.add(msg.value));\r\n        mcnmpr = masterStorage.getMaxProtectionPercentage();\r\n        if (cpr != mcnmpr) {\r\n            (npr, rmn) = _increasePercentage(ifactp, mcnmpr, cpr, pfc.add(msg.value));\r\n            if (cpr != npr) {\r\n                secondStorage.setProtectionRate(pid, npr);\r\n                secondStorage.setOwnerPercentageFloatContainer(pid, rmn);\r\n            }\r\n        }\r\n        uint256 pcf = secondStorage.getOwnerContribution(pid);\r\n        uint256 ncf = _calcOwnerContribution(msg.value, ifactp);\r\n        secondStorage.setOwnerContribution(pid, pcf.add(ncf));\r\n\r\n        uint256 prevOwnerFunds = secondStorage.getOwnerFunds(pid, ownerAddr);\r\n        secondStorage.setOwnerFunds(pid, ownerAddr, prevOwnerFunds.add(ncf));\r\n        if (!masterStorage.isProjectOwner(ownerAddr)) {\r\n            masterStorage.setProjectOwner(ownerAddr);\r\n        }\r\n        refundPool.deposit.value(ncf)(pid);\r\n        eventLogger.emitOwnerContribution(pid, ownerAddr, msg.value, npr);\r\n    }\r\n\r\n    function close(uint256 pid) public onlyMain {\r\n        _closeProject(pid);\r\n    }\r\n\r\n    function setNewProjectTokenPrice(\r\n        uint256 pid,\r\n        uint256 newPrice,\r\n        uint256 insuranceIndex\r\n    )\r\n        external\r\n        onlyMain\r\n        returns (uint256 numberOfChanges)\r\n    {\r\n        uint256 crrprc = secondStorage.getHighestTokenPrice(pid);\r\n        require(crrprc <= newPrice, \"New price is lower than the current one\");\r\n        uint256 tnprinv = secondStorage.getNumberOfProjectInvestments(pid);\r\n        address investr;\r\n        uint256 ethscrd;\r\n        uint256 ttlainv;\r\n        uint256 nwmntkn;\r\n\r\n        if (tnprinv > 112) tnprinv = 112;\r\n        uint256 i;\r\n\r\n        if (insuranceIndex != 0) i = insuranceIndex; else i = 1;\r\n        for (i; i < tnprinv; i++) {\r\n            uint256 insId = secondStorage.getInvestmentToProject(pid, i);\r\n            // Recalculate the minimum amount of tokens investor has to posses if the investment is not already canceled\r\n            if (!masterStorage.isCanceled(insId)) {\r\n                investr = masterStorage.getInsuranceOwner(insId);\r\n                ethscrd = masterStorage.getEtherSecured(insId);\r\n                ttlainv = ethscrd.mul(100).div(masterStorage.getInsuranceRate(insId));\r\n                nwmntkn = ttlainv.div(newPrice) * 10 ** uint256(secondStorage.getTokenDecimals(pid));\r\n\r\n                if (secondStorage.getMinAmountProjectTokens(pid, investr) > nwmntkn) {\r\n                    secondStorage.setMinAmountProjectTokens(pid, nwmntkn, investr);\r\n                    numberOfChanges++;\r\n                }\r\n            }\r\n        }\r\n        if (numberOfChanges == 0) {\r\n            secondStorage.setHighestTokenPrice(pid, newPrice);\r\n        }\r\n        eventLogger.emitNewTokenPrice(pid, newPrice, numberOfChanges);\r\n        return numberOfChanges;\r\n    }\r\n\r\n    function isOpen(uint256 projectId) public view returns (bool) {\r\n        return secondStorage.getProjectCurrentState(projectId) == 0;\r\n    }\r\n\r\n    function _decreasePercentage(\r\n        uint256 afc,\r\n        uint256 mnp,\r\n        uint256 crp,\r\n        uint256 nfc\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256 ndp, uint256 rmn)\r\n    {\r\n        uint256 pfc = nfc;\r\n        if (afc < 88 * 1 ether) {\r\n            if (pfc >= 2 ether) {\r\n                rmn = pfc.mod(2 ether);\r\n                pfc = pfc.sub(rmn);\r\n                ndp = crp.sub(pfc.div(2 ether));\r\n                if (ndp > mnp) {\r\n                    return (ndp, rmn);\r\n                } else {\r\n                    return (mnp, 1);\r\n                }\r\n            } else {\r\n                return (crp, 1);\r\n            }\r\n        }\r\n\r\n        if (afc >= 88 * 1 ether && afc < 288 ether) {\r\n            if (pfc >= 5 ether) {\r\n                rmn = pfc.mod(5 ether);\r\n                pfc = pfc.sub(rmn);\r\n                ndp = crp.sub(pfc.div(5 ether));\r\n                if (ndp > mnp) {\r\n                    return (ndp, rmn);\r\n                } else {\r\n                    return (mnp, 1);\r\n                }\r\n            } else {\r\n                return (crp, 1);\r\n            }\r\n        }\r\n\r\n        if (afc >= 288 ether) {\r\n            if (pfc >= 10 ether) {\r\n                rmn = pfc.mod(10 ether);\r\n                pfc = pfc.sub(rmn);\r\n                ndp = crp.sub(pfc.div(10 ether));\r\n                if (ndp >= mnp) {\r\n                    return (ndp, rmn);\r\n                } else {\r\n                    return (mnp, 1);\r\n                }\r\n            } else {\r\n                return (crp, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _increasePercentage(\r\n        uint256 afc,\r\n        uint256 mxp,\r\n        uint256 crp,\r\n        uint256 nfc\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256 nip, uint256 rmn)\r\n    {\r\n        uint256 ofc = nfc;\r\n        if (afc < 88 ether) {\r\n            rmn = ofc.mod(3 ether);\r\n            ofc = ofc.sub(rmn);\r\n            nip = crp.add(ofc.div(3 ether));\r\n            if (nip <= mxp) {\r\n                return (nip, rmn);\r\n            } else {\r\n                return (mxp, ((nip.sub(mxp)) * 3).add(rmn));\r\n            }\r\n        }\r\n\r\n        if (afc >= 88 ether && afc < 288 ether) {\r\n            rmn = ofc.mod(7 ether);\r\n            ofc = ofc.sub(rmn);\r\n            nip = crp.add(ofc.div(7 ether));\r\n            if (nip <= mxp) {\r\n                return (nip, rmn);\r\n            } else {\r\n                return (mxp, ((nip.sub(mxp)) * 7).add(rmn));\r\n            }\r\n        }\r\n\r\n        if (afc >= 288 ether) {\r\n            rmn = ofc.mod(12 ether);\r\n            ofc = ofc.sub(rmn);\r\n            nip = crp.add(ofc.div(12 ether));\r\n            if (nip <= mxp) {\r\n                return (nip, rmn);\r\n            } else {\r\n                return (mxp, ((nip.sub(mxp)) * 12).add(rmn));\r\n            }\r\n        }\r\n    }\r\n\r\n    function _mintRefundEther(\r\n        address investorAddress,\r\n        uint256 projectId,\r\n        uint256 rethAmount\r\n    )\r\n        internal\r\n    {\r\n        refundEther = RefundEther(masterStorage.getRefundEtherTokenAddress());\r\n        refundEther.mint(investorAddress, rethAmount);\r\n        refundEther.setAmountOfSecuredEther(investorAddress, projectId, rethAmount);\r\n    }\r\n\r\n    function _createTokenLitter(\r\n        address investor,\r\n        uint256 projectId,\r\n        uint256 investmentId\r\n    )\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        bytes20 ntl = bytes20(keccak256(abi.encodePacked(investor, projectId, investmentId)));\r\n        return address(ntl);\r\n    }\r\n\r\n    function _calcPoolContribution(\r\n        bool isInvestorReferred,\r\n        address referrer,\r\n        uint amountContributed\r\n    )\r\n        internal\r\n        returns (uint256 poolContribution)\r\n    {\r\n        uint256 platformResources;\r\n\r\n        if (isInvestorReferred) {\r\n            uint256 referralPayment = _calcAffiliatePayment(amountContributed);\r\n            affiliate.deposit.value(referralPayment)(referrer);\r\n            platformResources = amountContributed.div(10);\r\n            poolContribution = amountContributed.sub(platformResources.add(referralPayment));\r\n            address(modResources).transfer(platformResources);\r\n        }\r\n        else {\r\n            platformResources = amountContributed.mul(30).div(100);\r\n            poolContribution = amountContributed.sub(platformResources);\r\n            address(modResources).transfer(platformResources);\r\n        }\r\n        return poolContribution;\r\n    }\r\n\r\n    function _calcOwnerContribution(\r\n        uint256 owncntrbmn,\r\n        uint256 tfndscntrb\r\n    )   internal\r\n        returns (uint256 nowncntrbm)\r\n    {\r\n        uint256 pltfmrsrcs;\r\n        if (tfndscntrb < 88 ether) {\r\n            pltfmrsrcs = owncntrbmn.sub((100 * owncntrbmn) / 150);\r\n            nowncntrbm = owncntrbmn.sub(pltfmrsrcs);\r\n            address(modResources).transfer(pltfmrsrcs);\r\n        }\r\n        if (tfndscntrb >= 88 ether && tfndscntrb < 288 ether) {\r\n            pltfmrsrcs = owncntrbmn.sub((100 * owncntrbmn) / 135);\r\n            nowncntrbm = owncntrbmn.sub(pltfmrsrcs);\r\n            address(modResources).transfer(pltfmrsrcs);\r\n        }\r\n        if (tfndscntrb >= 288 ether) {\r\n            pltfmrsrcs = owncntrbmn.sub((100 * owncntrbmn) / 120);\r\n            nowncntrbm = owncntrbmn.sub(pltfmrsrcs);\r\n            address(modResources).transfer(pltfmrsrcs);\r\n        }\r\n        return nowncntrbm;\r\n    }\r\n\r\n    function _calcAffiliatePayment(uint amountContributed)\r\n        internal\r\n        pure\r\n        returns (uint256 referralPayment)\r\n    {\r\n        return referralPayment = amountContributed.div(5);\r\n    }\r\n\r\n    function _closeProject(uint256 pid) internal {\r\n        require(isOpen(pid), \"This project is already closed for new insurance requests\");\r\n        secondStorage.setProjectCurrentState(pid, 1);\r\n    }\r\n\r\n    function _newInsuranceInit(\r\n        uint256 pid,\r\n        address insOwner,\r\n        address referrer,\r\n        bytes32 cntrllrs\r\n    )\r\n        internal\r\n        returns (uint256 insuranceId)\r\n    {\r\n        require(pid < secondStorage.getNumberOfCoveredProjects(), \"Invalid project ID\");\r\n        require(\r\n            msg.value >= masterStorage.getMinInvestorContribution() &&\r\n            msg.value <= masterStorage.getMaxInvestorContribution(),\r\n            \"The amount you specified as pool contribution is below/above the allowed limits.\"\r\n        );\r\n        require(\r\n            !secondStorage.getAlreadyProtected(pid, insOwner),\r\n            \"Only 1 secured investment per project is allowed\"\r\n        );\r\n        if (!masterStorage.isInvestor(insOwner)) {\r\n\r\n            masterStorage.setInvestorId(insOwner, masterStorage.addNewInvestor(insOwner) - 1);\r\n            masterStorage.setInvestor(insOwner);\r\n\r\n            if (referrer != address(0)) {\r\n                masterStorage.setReferrer(insOwner, referrer);\r\n            }\r\n        }\r\n\r\n        insuranceId = masterStorage.addInsurance();\r\n        masterStorage.setControllerStateToInsurance(insuranceId, cntrllrs);\r\n        masterStorage.setInsuranceId(insuranceId);\r\n        masterStorage.setInsuranceProjectId(insuranceId, pid);\r\n        masterStorage.setInsuranceOwner(insuranceId, insOwner);\r\n        masterStorage.setTimeOfTheRequest(insuranceId);\r\n        masterStorage.setInsuranceRate(insuranceId, secondStorage.getProtectionRate(pid));\r\n\r\n        return insuranceId;\r\n    }\r\n\r\n    function _newInsuranceCalculations(\r\n        uint256 pid,\r\n        uint256 insuranceId,\r\n        address insOwner,\r\n        address referrer\r\n    )\r\n        internal\r\n    {\r\n        uint256 aei;\r\n        uint256 mpt;\r\n        uint256 ethsec;\r\n        uint256 rcp = masterStorage.getRegularContributionPercentage();\r\n        uint256 nse;\r\n        if (referrer == address(0x0)) {\r\n            aei = msg.value.mul(100).div(rcp);\r\n            mpt = aei.div(secondStorage.getHighestTokenPrice(pid)) * 10 ** uint256(secondStorage.getTokenDecimals(pid));\r\n            secondStorage.setMinAmountProjectTokens(pid, mpt, insOwner);\r\n            ethsec = aei.mul(masterStorage.getInsuranceRate(insuranceId)) / 100;\r\n            masterStorage.setEtherSecured(insuranceId, ethsec);\r\n            nse = secondStorage.getTotalAmountSecuredEther(pid).add(ethsec);\r\n            secondStorage.setTotalAmountSecuredEther(pid, nse);\r\n        } else {\r\n            aei = msg.value.mul(100) / (rcp - (rcp.div(10)));\r\n            mpt = aei.div(secondStorage.getHighestTokenPrice(pid)) * 10 ** uint256(secondStorage.getTokenDecimals(pid));\r\n            secondStorage.setMinAmountProjectTokens(pid, mpt, insOwner);\r\n            ethsec = aei.mul(masterStorage.getInsuranceRate(insuranceId)).div(100);\r\n            nse = secondStorage.getTotalAmountSecuredEther(pid).add(ethsec);\r\n            masterStorage.setEtherSecured(insuranceId, ethsec);\r\n            secondStorage.setTotalAmountSecuredEther(pid, nse);\r\n        }\r\n        _mintRefundEther(insOwner, pid, ethsec);\r\n    }\r\n\r\n    function _newProtectionRate(\r\n        uint256 pid,\r\n        uint256 naf\r\n    )\r\n        internal\r\n    {\r\n        uint256 ndp;\r\n        uint256 rmn;\r\n        uint256 prt  = secondStorage.getProtectionRate(pid);\r\n        uint256 mpp  = masterStorage.getMinProtectionPercentage();\r\n        uint256 pfc  = secondStorage.getPercentageFloatContainer(pid).add(msg.value);\r\n        if (prt == mpp) {\r\n            secondStorage.setPercentageFloatContainer(pid, 1);\r\n        } else {\r\n            secondStorage.setPercentageFloatContainer(pid, pfc);\r\n            (ndp, rmn) = _decreasePercentage(naf, mpp, prt, pfc);\r\n            secondStorage.setProtectionRate(pid, ndp);\r\n            if (prt != ndp) {\r\n                secondStorage.setPercentageFloatContainer(pid, rmn);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _isMain() internal view {\r\n        if (msg.sender != main) {\r\n            revert(\"Only the main dApp contract is allowed\");\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"isOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"insOwner\",\"type\":\"address\"},{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"newInsurance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"newPrice\",\"type\":\"uint256\"},{\"name\":\"insuranceIndex\",\"type\":\"uint256\"}],\"name\":\"setNewProjectTokenPrice\",\"outputs\":[{\"name\":\"numberOfChanges\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"projectName\",\"type\":\"bytes\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"crowdsaleEnd\",\"type\":\"uint256\"},{\"name\":\"highestCrowdsalePrice\",\"type\":\"uint256\"},{\"name\":\"tokenDecimals\",\"type\":\"uint8\"}],\"name\":\"newProject\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"ownerAddr\",\"type\":\"address\"}],\"name\":\"newOwnerContribution\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"dAppMainContractAddr\",\"type\":\"address\"},{\"name\":\"storageAddr\",\"type\":\"address\"},{\"name\":\"secStorageAddr\",\"type\":\"address\"},{\"name\":\"refundEtherAddr\",\"type\":\"address\"},{\"name\":\"eventLoggerAddr\",\"type\":\"address\"},{\"name\":\"modResourcesAddr\",\"type\":\"address\"},{\"name\":\"refundPoolAddr\",\"type\":\"address\"},{\"name\":\"affiliateEscrowAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"ProjectController","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"1","Runs":"500000","ConstructorArguments":"0000000000000000000000004f62e6629e4f1cd8b72e7db8ff097f055a6ed4c000000000000000000000000057d504f3ebcc43b8a894a7933676eb17236cc35d000000000000000000000000ac5ae06a85b710c1c68708bb04b80f2d81c0061700000000000000000000000090d44256f40fb8ab49d80c88251ff5132edf885e000000000000000000000000358994ca3f907b689c4177790a2cb424a3d2bcdf00000000000000000000000021e3e3b8b01364c35f76d1f857a7c99c8b4d050b000000000000000000000000df4fdbf83329be988491b047140b37bba12bc4c1000000000000000000000000eddbae4ba377f490b0d7331d135d147855d0f86a","Library":"","SwarmSource":"bzzr://8f27799247de9382ba89e160591c55c007b5a3436494de7a9eeb92832fd9e327"}]}