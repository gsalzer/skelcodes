{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract SHT_Token \r\n{\r\n\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n    // only people with tokens\r\n    modifier onlyTokenHolders() \r\n    {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n    \r\n    // only people with profits\r\n    modifier onlyDividendPositive() \r\n    {\r\n        require(myDividends() > 0);\r\n        _;\r\n    }\r\n\r\n    // only owner\r\n    modifier onlyOwner() \r\n    { \r\n        require (address(msg.sender) == owner); \r\n        _; \r\n    }\r\n    \r\n    // only founders if contract not live\r\n    modifier onlyFoundersIfNotPublic() \r\n    {\r\n        if(!openToThePublic)\r\n        {\r\n            require (founders[address(msg.sender)] == true);   \r\n        }\r\n        _;\r\n    }    \r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted\r\n    );\r\n    \r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned\r\n    );\r\n    \r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethereumReinvested,\r\n        uint256 tokensMinted\r\n    );\r\n    \r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n    \r\n    event lotteryPayout(\r\n        address customerAddress, \r\n        uint256 lotterySupply\r\n    );\r\n    \r\n    event whaleDump(\r\n        uint256 amount\r\n    );\r\n    \r\n    // ERC20\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n    \r\n    \r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n    string public name = \"SHT Token\";\r\n    string public symbol = \"SHT\";\r\n    bool public openToThePublic = false;\r\n    address public owner;\r\n    address public dev;\r\n    uint8 constant public decimals = 18;\r\n    uint8 constant internal dividendFee = 10;  //11% (total.. breakdown is 5% tokenholders, 2.5% OB2, 1.5% whale, 1% lottery, 1% dev)\r\n    uint8 constant internal lotteryFee = 5; \r\n    uint8 constant internal devFee = 5; \r\n    uint8 constant internal ob2Fee = 2;  \r\n    uint256 constant internal tokenPrice = 400000000000000;  //0.0004 ether\r\n    uint256 constant internal magnitude = 2**64;\r\n    Onigiri2 private ob2; \r\n   \r\n\r\n    \r\n   /*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n    mapping(address => uint256) internal publicTokenLedger;\r\n    mapping(address => uint256) public   whaleLedger;\r\n    mapping(address => int256) internal payoutsTo_;\r\n    mapping(address => bool) internal founders;\r\n    address[] lotteryPlayers;\r\n    uint256 internal lotterySupply = 0;\r\n    uint256 internal tokenSupply = 0;\r\n    uint256 internal profitPerShare_;\r\n    \r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS            =\r\n    =======================================*/\r\n    /*\r\n    * -- APPLICATION ENTRY POINTS --  \r\n    */\r\n    constructor()\r\n        public\r\n    {\r\n        // no admin, but the owner of the contract is the address used for whale\r\n        owner = address(msg.sender);\r\n\r\n        dev = address(0x7e474fe5Cfb720804860215f407111183cbc2f85); //some SHT Dev\r\n\r\n        // add founders here... Founders don't get any special priveledges except being first in line at launch day\r\n        founders[0x013f3B8C9F1c4f2f28Fd9cc1E1CF3675Ae920c76] = true; //Nomo\r\n        founders[0xF57924672D6dBF0336c618fDa50E284E02715000] = true; //Bungalogic\r\n        founders[0xE4Cf94e5D30FB4406A2B139CD0e872a1C8012dEf] = true; //Ivan\r\n\r\n        // link this contract to OB2 contract to send rewards\r\n        ob2 = Onigiri2(0xb8a68f9B8363AF79dEf5c5e11B12e8A258cE5be8); //MainNet\r\n    }\r\n    \r\n     \r\n    /**\r\n     * Converts all incoming ethereum to tokens for the caller, and passes down the referral address\r\n     */\r\n    function buy()\r\n        onlyFoundersIfNotPublic()\r\n        public\r\n        payable\r\n        returns(uint256)\r\n    {\r\n        require (msg.sender == tx.origin);\r\n         uint256 tokenAmount;\r\n\r\n        tokenAmount = purchaseTokens(msg.value); //redirects to purchaseTokens so same functionality\r\n\r\n        return tokenAmount;\r\n    }\r\n    \r\n    /**\r\n     * Fallback function to handle ethereum that was send straight to the contract\r\n     */\r\n    function()\r\n        payable\r\n        public\r\n    {\r\n       buy();\r\n    }\r\n    \r\n    /**\r\n     * Converts all of caller's dividends to tokens.\r\n     */\r\n    function reinvest()\r\n        onlyDividendPositive()\r\n        public\r\n    {   \r\n        require (msg.sender == tx.origin);\r\n        \r\n        // fetch dividends\r\n        uint256 dividends = myDividends(); \r\n        \r\n        // pay out the dividends virtually\r\n        address customerAddress = msg.sender;\r\n        payoutsTo_[customerAddress] +=  int256(dividends * magnitude);\r\n        \r\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n        uint256 _tokens = purchaseTokens(dividends);\r\n        \r\n        // fire event for logging \r\n        emit onReinvestment(customerAddress, dividends, _tokens);\r\n    }\r\n    \r\n    /**\r\n     * Alias of sell() and withdraw().\r\n     */\r\n    function exit()\r\n        onlyTokenHolders()\r\n        public\r\n    {\r\n        require (msg.sender == tx.origin);\r\n        \r\n        // get token count for caller & sell them all\r\n        address customerAddress = address(msg.sender);\r\n        uint256 _tokens = publicTokenLedger[customerAddress];\r\n        \r\n        if(_tokens > 0) \r\n        {\r\n            sell(_tokens);\r\n        }\r\n\r\n        withdraw();\r\n    }\r\n\r\n    /**\r\n     * Withdraws all of the callers earnings.\r\n     */\r\n    function withdraw()\r\n        onlyDividendPositive()\r\n        public\r\n    {\r\n        require (msg.sender == tx.origin);\r\n        \r\n        // setup data\r\n        address customerAddress = msg.sender;\r\n        uint256 dividends = myDividends(); \r\n        \r\n        // update dividend tracker\r\n        payoutsTo_[customerAddress] +=  int256(dividends * magnitude);\r\n        \r\n        customerAddress.transfer(dividends);\r\n        \r\n        // fire event for logging \r\n        emit onWithdraw(customerAddress, dividends);\r\n    }\r\n    \r\n    /**\r\n     * Liquifies tokens to ethereum.\r\n     */\r\n    function sell(uint256 _amountOfTokens)\r\n        onlyTokenHolders()\r\n        public\r\n    {\r\n        require (msg.sender == tx.origin);\r\n        require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0));\r\n\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 ethereum = tokensToEthereum_(_tokens);\r\n\r\n        uint256 undividedDivs = SafeMath.div(ethereum, dividendFee);\r\n        \r\n        // from that 10%, divide for Community, Whale, Lottery, and OB2\r\n        uint256 communityDivs = SafeMath.div(undividedDivs, 2); //5%\r\n        uint256 ob2Divs = SafeMath.div(undividedDivs, 4); //2.5% \r\n        uint256 lotteryDivs = SafeMath.div(undividedDivs, 10); // 1%\r\n        uint256 tip4Dev = lotteryDivs;\r\n        uint256 whaleDivs = SafeMath.sub(communityDivs, (ob2Divs + lotteryDivs));  // 1.5%\r\n\r\n\r\n        // let's deduct Whale, Lottery, and OB2 divs just to make sure our math is safe\r\n        uint256 dividends = SafeMath.sub(undividedDivs, (ob2Divs + lotteryDivs + whaleDivs));\r\n\r\n        uint256 taxedEthereum = SafeMath.sub(ethereum, (undividedDivs + tip4Dev));\r\n\r\n        //add divs to whale\r\n        whaleLedger[owner] += whaleDivs;\r\n        \r\n        //add tokens to the lotterySupply\r\n        lotterySupply += ethereumToTokens_(lotteryDivs);\r\n\r\n        //send divs to OB2\r\n        ob2.fromGame.value(ob2Divs)();\r\n\r\n        //send tip to Dev\r\n        dev.transfer(tip4Dev);\r\n        \r\n        // burn the sold tokens\r\n        tokenSupply -=  _tokens;\r\n        publicTokenLedger[msg.sender] -= _tokens;\r\n        \r\n        \r\n        // update dividends tracker\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (taxedEthereum * magnitude));\r\n        payoutsTo_[msg.sender] -= _updatedPayouts;  \r\n        \r\n        // dividing by zero is a bad idea\r\n        if (tokenSupply > 0) \r\n        {\r\n            // update the amount of dividends per token\r\n            profitPerShare_ += ((dividends * magnitude) / tokenSupply);\r\n        }\r\n        \r\n        // fire event for logging \r\n        emit onTokenSell(msg.sender, _tokens, taxedEthereum);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Transfer tokens from the caller to a new holder.\r\n     */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n        onlyTokenHolders()\r\n        public\r\n        returns(bool)\r\n    {\r\n        assert(_toAddress != owner);\r\n        \r\n        // make sure we have the requested tokens\r\n        require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0 ));\r\n            // exchange tokens\r\n        publicTokenLedger[msg.sender] -= _amountOfTokens;\r\n        publicTokenLedger[_toAddress] += _amountOfTokens; \r\n        \r\n        // update dividend trackers\r\n        payoutsTo_[msg.sender] -= int256(profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_toAddress] += int256(profitPerShare_ * _amountOfTokens); \r\n            \r\n        // fire event for logging \r\n        emit Transfer(msg.sender, _toAddress, _amountOfTokens); \r\n\r\n        return true;     \r\n    }\r\n    \r\n    /*----------  OWNER ONLY FUNCTIONS  ----------*/\r\n\r\n    /**\r\n     * Want to prevent snipers from buying prior to launch\r\n     */\r\n    function goPublic() \r\n        onlyOwner()\r\n        public \r\n        returns(bool)\r\n\r\n    {\r\n        openToThePublic = true;\r\n        return openToThePublic;\r\n    }\r\n    \r\n    \r\n    /*----------  HELPERS AND CALCULATORS  ----------*/\r\n    /**\r\n     * Method to view the current Ethereum stored in the contract\r\n     */\r\n    function totalEthereumBalance()\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the total token supply.\r\n     */\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return (tokenSupply + lotterySupply); //adds the tokens from ambassadors to the supply (but not to the dividends calculation which is based on the supply)\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the tokens owned by the caller.\r\n     */\r\n    function myTokens()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return balanceOf(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Retrieve the balance of the whale.\r\n     */\r\n    function whaleBalance()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return  whaleLedger[owner]; \r\n    }\r\n\r\n\r\n    /**\r\n     * Retrieve the balance of the whale.\r\n     */\r\n    function lotteryBalance()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return  lotterySupply; \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Retrieve the dividends owned by the caller.\r\n     */ \r\n    function myDividends() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        return dividendsOf(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the token balance of any single address.\r\n     */\r\n    function balanceOf(address customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        return publicTokenLedger[customerAddress];\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the dividend balance of any single address.\r\n     */\r\n    function dividendsOf(address customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n      return (uint256) ((int256)(profitPerShare_ * publicTokenLedger[customerAddress]) - payoutsTo_[customerAddress]) / magnitude;\r\n    }\r\n    \r\n    /**\r\n     * Return the buy and sell price of 1 individual token.\r\n     */\r\n    function buyAndSellPrice()\r\n    public\r\n    pure \r\n    returns(uint256)\r\n    {\r\n        uint256 ethereum = tokenPrice;\r\n        uint256 dividends = SafeMath.div((ethereum * dividendFee ), 100);\r\n        uint256 taxedEthereum = SafeMath.sub(ethereum, dividends);\r\n        return taxedEthereum;\r\n    }\r\n    \r\n    /**\r\n     * Function for the frontend to dynamically retrieve the price of buy orders.\r\n     */\r\n    function calculateTokensReceived(uint256 ethereumToSpend) \r\n        public \r\n        pure \r\n        returns(uint256)\r\n    {\r\n        require(ethereumToSpend >= tokenPrice);\r\n        uint256 dividends = SafeMath.div((ethereumToSpend * dividendFee), 100);\r\n        uint256 taxedEthereum = SafeMath.sub(ethereumToSpend, dividends);\r\n        uint256 amountOfTokens = ethereumToTokens_(taxedEthereum);\r\n        \r\n        return amountOfTokens;\r\n    }\r\n    \r\n    /**\r\n     * Function for the frontend to dynamically retrieve the price of sell orders.\r\n     */\r\n    function calculateEthereumReceived(uint256 tokensToSell) \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        require(tokensToSell <= tokenSupply);\r\n        uint256 ethereum = tokensToEthereum_(tokensToSell);\r\n        uint256 dividends = SafeMath.div((ethereum * dividendFee ), 100);\r\n        uint256 taxedEthereum = SafeMath.sub(ethereum, dividends);\r\n        return taxedEthereum;\r\n    }\r\n    \r\n    \r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n    \r\n    function purchaseTokens(uint256 incomingEthereum)\r\n        internal\r\n        returns(uint256)\r\n    {\r\n        // take out 10% of incoming eth for divs\r\n        uint256 undividedDivs = SafeMath.div(incomingEthereum, dividendFee);\r\n        \r\n        // from that 10%, divide for Community, Whale, Lottery, and OB2\r\n        uint256 communityDivs = SafeMath.div(undividedDivs, 2); //5%\r\n        uint256 ob2Divs = SafeMath.div(undividedDivs, 4); //2.5% \r\n        uint256 lotteryDivs = SafeMath.div(undividedDivs, 10); // 1%\r\n        uint256 tip4Dev = lotteryDivs;\r\n        uint256 whaleDivs = SafeMath.sub(communityDivs, (ob2Divs + lotteryDivs));  // 1.5%\r\n\r\n        // let's deduct Whale, Lottery, devfee, and OB2 divs just to make sure our math is safe\r\n        uint256 dividends = SafeMath.sub(undividedDivs, (ob2Divs + lotteryDivs + whaleDivs));\r\n\r\n        uint256 taxedEthereum = SafeMath.sub(incomingEthereum, (undividedDivs + tip4Dev));\r\n        uint256 amountOfTokens = ethereumToTokens_(taxedEthereum);\r\n\r\n        //add divs to whale\r\n        whaleLedger[owner] += whaleDivs;\r\n        \r\n        //add tokens to the lotterySupply\r\n        lotterySupply += ethereumToTokens_(lotteryDivs);\r\n        \r\n        //add entry to lottery\r\n        lotteryPlayers.push(msg.sender);\r\n\r\n        //send divs to OB2\r\n        ob2.fromGame.value(ob2Divs)();\r\n\r\n        //tip the dev\r\n        dev.transfer(tip4Dev);\r\n       \r\n        uint256 fee = dividends * magnitude;\r\n \r\n        require(amountOfTokens > 0 && (amountOfTokens + tokenSupply) > tokenSupply);\r\n\r\n        uint256 payoutDividends = isWhalePaying();\r\n        \r\n        // we can't give people infinite ethereum\r\n        if(tokenSupply > 0)\r\n        {\r\n            // add tokens to the pool\r\n            tokenSupply += amountOfTokens;\r\n            \r\n             // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\r\n            profitPerShare_ += ((payoutDividends + dividends) * magnitude / (tokenSupply));\r\n            \r\n            // calculate the amount of tokens the customer receives over his purchase \r\n            fee -= fee-(amountOfTokens * (dividends * magnitude / (tokenSupply)));\r\n        } else \r\n        {\r\n            // add tokens to the pool\r\n            tokenSupply = amountOfTokens;\r\n            \r\n            //if there are zero tokens prior to this buy, and the whale is triggered, send dividends back to whale\r\n            if(whaleLedger[owner] == 0)\r\n            {\r\n                whaleLedger[owner] = payoutDividends;\r\n            }\r\n        }\r\n\r\n        // update circulating supply & the ledger address for the customer\r\n        publicTokenLedger[msg.sender] += amountOfTokens;\r\n        \r\n        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\r\n        int256 _updatedPayouts = int256((profitPerShare_ * amountOfTokens) - fee);\r\n        payoutsTo_[msg.sender] += _updatedPayouts;\r\n        \r\n     \r\n        // fire event for logging \r\n        emit onTokenPurchase(msg.sender, incomingEthereum, amountOfTokens);\r\n        \r\n        return amountOfTokens;\r\n    }\r\n    \r\n    \r\n     /**\r\n     * Calculate token sell value.\r\n     * It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation.\r\n     */\r\n    function isWhalePaying()\r\n    private\r\n    returns(uint256)\r\n    {\r\n        uint256 payoutDividends = 0;\r\n         // this is where we check for lottery winner\r\n        if(whaleLedger[owner] >= 1 ether)\r\n        {\r\n            if(lotteryPlayers.length > 0)\r\n            {\r\n                uint256 winner = uint256(blockhash(block.number-1))%lotteryPlayers.length;\r\n                \r\n                publicTokenLedger[lotteryPlayers[winner]] += lotterySupply;\r\n                emit lotteryPayout(lotteryPlayers[winner], lotterySupply);\r\n                tokenSupply += lotterySupply;\r\n                lotterySupply = 0;\r\n                delete lotteryPlayers;\r\n               \r\n            }\r\n            //whale pays out everyone its divs\r\n            payoutDividends = whaleLedger[owner];\r\n            whaleLedger[owner] = 0;\r\n            emit whaleDump(payoutDividends);\r\n        }\r\n        return payoutDividends;\r\n    }\r\n\r\n    /**\r\n     * Calculate Token price based on an amount of incoming ethereum\r\n     *It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation.\r\n     */\r\n    function ethereumToTokens_(uint256 ethereum)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 tokensReceived = ((ethereum / tokenPrice) * 1e18);\r\n               \r\n        return tokensReceived;\r\n    }\r\n    \r\n    /**\r\n     * Calculate token sell value.\r\n     * It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation.\r\n     */\r\n     function tokensToEthereum_(uint256 coin)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 ethReceived = tokenPrice * (SafeMath.div(coin, 1e18));\r\n        \r\n        return ethReceived;\r\n    }\r\n}\r\n\r\ncontract Onigiri2 \r\n{\r\n    function fromGame() external payable;\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ethereumToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateEthereumReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openToThePublic\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whaleBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyAndSellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"goPublic\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lotteryBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whaleLedger\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethereumEarned\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lotterySupply\",\"type\":\"uint256\"}],\"name\":\"lotteryPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"whaleDump\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"SHT_Token","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6fcda81d220af71346ece0fe93805cebb4340367f25beb3ed99572b2d06647b5"}]}