{"status":"1","message":"OK","result":[{"SourceCode":"{\"Crowdsale.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./RHC.sol\\\";\\n\\ncontract Crowdsale {\\n\\n  /// @dev represents a round of token sale\\n  struct Round {\\n    /// @dev price per token for every token\\n    uint tokenPrice;\\n    /// @dev total number of tokens available in the round\\n    uint capacityLeft;\\n  }\\n  \\n  /// @notice event is raised when a token sale occurs\\n  /// @param amountSent amount of money sent by the purchaser\\n  /// @param amountReturned amount of money returned to the purchaser in case amount sent was not exact\\n  /// @param buyer the address which purchased the tokens\\n  event Sale(uint amountSent, uint amountReturned, uint tokensSold, address buyer);\\n\\n  /// @notice raised when all tokens are sold out\\n  event SaleCompleted();\\n\\n  /// @notice raised when a round completes and the next round starts\\n  /// @param oldTokenPrice previous price per token\\n  /// @param newTokenPrice new price per token\\n  event RoundChanged(uint oldTokenPrice, uint newTokenPrice);\\n\\n  /// @dev information about rounds of fundraising in the crowdsale\\n  Round[] private _rounds;\\n  uint8 private _currentRound;\\n\\n  /// @notice where the contract wires funds in exchange for tokens\\n  address payable private wallet;\\n\\n  /// @notice a refenence to the RHC token being sold\\n  RHC public token;\\n\\n  /// @notice reports whether the sale is still open\\n  bool public isSaleOpen;\\n\\n  /// @dev how much wei has been raised so far\\n  uint public weiRaised;\\n\\n  /// @dev how many tokens have been sold so far\\n  uint public tokensSold;\\n\\n  /// @notice creates the crowdsale. Only intended to be used by Robinhood team.\\n  constructor(address payable targetWallet, uint[] memory roundPrices, uint[] memory roundCapacities,\\n              address advisors, address founders, address legal, address developers, address reserve) public {\\n    require(roundPrices.length == roundCapacities.length, \\\"Equal number of round parameters must be specified\\\");\\n    require(roundPrices.length \\u003e= 1, \\\"Crowdsale must have at least one round\\\");\\n    require(roundPrices.length \\u003c 10, \\\"Rounds are limited to 10 at most\\\");\\n\\n    // store rounds\\n    _currentRound = 0;\\n    for (uint i = 0; i \\u003c roundPrices.length; i++) {\\n      _rounds.push(Round(roundPrices[i], roundCapacities[i]));\\n    }\\n\\n    wallet = targetWallet;\\n    isSaleOpen = true;\\n    weiRaised = 0;\\n    tokensSold = 0;\\n\\n    // Create token with this contract as the owner\\n    token = new RHC(address(this));\\n\\n    // add target wallet as an additional owner\\n    token.addAdmin(wallet);\\n\\n    // Grants future tokens for internal parties. These shares can only be claimed one year\\n    // after the start of the crowdsale\\n    uint in12Months = block.timestamp + (1000 * 60 * 60 * 24 * 365);\\n    // 21.5% reserved for developers\\n    token.grant(developers, 21500000, in12Months);\\n    // 5% reserved for advisors\\n    token.grant(advisors, 5000000, in12Months);\\n    // 14% reserved for founders\\n    token.grant(founders, 14000000, in12Months);\\n    // 7% reserved for future use\\n    token.grant(reserve, 7000000, in12Months);\\n    // 8.5% reserved for legal\\n    token.grant(legal, 8500000, in12Months);\\n  }\\n\\n  function() external payable {\\n    uint amount = msg.value;\\n    address payable buyer = msg.sender;\\n    require(amount \\u003e 0, \\\"must send money to get tokens\\\");\\n    require(buyer != address(0), \\\"can\\u0027t send from address 0\\\");\\n    require(isSaleOpen, \\\"sale must be open in order to purchase tokens\\\");\\n\\n    (uint tokenCount, uint change) = calculateTokenCount(amount);\\n\\n    // if insufficient money is sent, return the buyer\\u0027s mone\\n    if (tokenCount == 0) {\\n      buyer.transfer(change);\\n      return;\\n    }\\n\\n    // this is how much of the money will be consumed by this token purchase\\n    uint acceptedFunds = amount - change;\\n\\n    // forward funds to owner\\n    wallet.transfer(acceptedFunds);\\n\\n    // return left over (unused) funds back to the sender\\n    buyer.transfer(change);\\n\\n    // assign tokens to whoever is purchasing\\n    token.issue(buyer, tokenCount);\\n\\n    // update state tracking how much wei has been raised so far\\n    weiRaised += acceptedFunds;\\n    tokensSold += tokenCount;\\n\\n    updateRounds(tokenCount);\\n\\n    emit Sale(amount, change, tokenCount, buyer);\\n  }\\n\\n  /// @notice given an amount of money returns how many tokens the money will result in with the\\n  /// current round\\u0027s pricing\\n  function calculateTokenCount(uint money) public view returns (uint count, uint change) {\\n    require(isSaleOpen, \\\"sale is no longer open and tokens can\\u0027t be purchased\\\");\\n\\n    // get current token price\\n    uint price = _rounds[_currentRound].tokenPrice;\\n    uint capacityLeft = _rounds[_currentRound].capacityLeft;\\n\\n    // money sent must be bigger than or equal the price, otherwise, no purchase is necessary\\n    if (money \\u003c price) {\\n      // return all the money\\n      return (0, money);\\n    }\\n\\n    count = money / price;\\n    change = money % price;\\n\\n    // Ensure there\\u0027s sufficient capacity in the current round. If the user wishes to\\n    // purchase more, they can send money again to purchase tokens at the next round\\n    if (count \\u003e capacityLeft) {\\n      change += price * (count - capacityLeft);\\n      count = capacityLeft;\\n    }\\n\\n    return (count, change);\\n  }\\n\\n  /// increases the round or closes the sale if tokens are sold out\\n  function updateRounds(uint tokens) private {\\n    Round storage currentRound = _rounds[_currentRound];\\n    currentRound.capacityLeft -= tokens;\\n\\n    if (currentRound.capacityLeft \\u003c= 0) {\\n      if (_currentRound == _rounds.length - 1) {\\n        isSaleOpen = false;\\n        emit SaleCompleted();\\n      } else {\\n        _currentRound++;\\n        emit RoundChanged(currentRound.tokenPrice, _rounds[_currentRound].tokenPrice);\\n      }\\n    }\\n  }\\n}\"},\"EIP20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/// ERC20 interface, as defined by Ethereum Improvement Proposals,\\n/// see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\ncontract EIP20 {\\n    /// this automatically generates the totalSupply() getter required by the ERC20 interface\\n    /// since it\\u0027s a public parameter\\n    /// total amount of tokens\\n    uint256 public totalSupply;\\n\\n    /// @param _owner The address from which the balance will be retrieved\\n    /// @return The balance\\n    function balanceOf(address _owner) public view returns (uint256 balance);\\n\\n    /// @notice send `_value` token to `_to` from `msg.sender`\\n    /// @param _to The address of the recipient\\n    /// @param _value The amount of token to be transferred\\n    /// @return Whether the transfer was successful or not\\n    function transfer(address _to, uint256 _value) public returns (bool success);\\n\\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\\n    /// @param _from The address of the sender\\n    /// @param _to The address of the recipient\\n    /// @param _value The amount of token to be transferred\\n    /// @return Whether the transfer was successful or not\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\\n\\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\\n    /// @param _spender The address of the account able to transfer the tokens\\n    /// @param _value The amount of tokens to be approved for transfer\\n    /// @return Whether the approval was successful or not\\n    function approve(address _spender, uint256 _value) public returns (bool success);\\n\\n    /// @param _owner The address of the account owning tokens\\n    /// @param _spender The address of the account able to transfer the tokens\\n    /// @return Amount of remaining tokens allowed to spent\\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\\n\\n    /// MUST trigger when tokens are transferred, including zero value transfers.\\n    /// A token contract which creates new tokens SHOULD trigger a Transfer event with\\n    /// the _from address set to 0x0 when tokens are created.\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n\\n    /// MUST trigger on any successful call to approve(address _spender, uint256 _value).\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n}\"},\"RHC.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\u0027./EIP20.sol\\u0027;\\n\\n/// @author robinhood.casino\\n/// @title Robinhood (RHC) ERC20 token\\ncontract RHC is EIP20 {\\n\\n  /// @notice reports number of tokens that are promised to vest in a future date\\n  uint256 public pendingGrants;\\n\\n  /// @notice raised when tokens are issued for an account\\n  event Issuance(address indexed _beneficiary, uint256 _amount);\\n\\n  struct Grant {\\n    /// number of shares in the grant\\n    uint256 amount;\\n    /// a linux timestamp of when shares can be claimed\\n    uint vestTime;\\n    /// whether the claim has been cancelled by admins\\n    bool isCancelled;\\n    /// whether the grant has been claimed by the user\\n    bool isClaimed;\\n  }\\n\\n  /// @dev token balance of all addresses\\n  mapping (address =\\u003e uint256) private _balances;\\n\\n  /// @dev tracks who can spend how much.\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n  /// @dev balance of tokens that are not vested yet\\n  mapping (address =\\u003e Grant[]) private _grants;\\n\\n  // used for access management\\n  address private _owner;\\n  mapping (address =\\u003e bool) private _admins;\\n\\n  constructor(address admin) public {\\n    _owner = admin;\\n  }\\n\\n  /// @notice name of the Robinhood token\\n  function name() public pure returns (string memory) {\\n    return \\\"Robinhood\\\";\\n  }\\n\\n  /// @notice symbol of the Robinhood token\\n  function symbol() public pure returns (string memory) {\\n    return \\\"RHC\\\";\\n  }\\n\\n  /// @notice RHC does not allow breaking up of tokens into fractions.\\n  function decimals() public pure returns (uint8) {\\n    return 0;\\n  }\\n\\n  modifier onlyAdmins() {\\n    require(msg.sender == _owner || _admins[msg.sender] == true, \\\"only admins can invoke this function\\\");\\n    _;\\n  }\\n\\n  /// @dev registers a new admin\\n  function addAdmin(address admin) public onlyAdmins() {\\n    _admins[admin] = true;\\n  }\\n\\n  /// @dev removes an existing admin\\n  function removeAdmin(address admin) public onlyAdmins() {\\n    require(admin != _owner, \\\"owner can\\u0027t be removed\\\");\\n    delete _admins[admin];\\n  }\\n\\n  /// @dev Gets the balance of the specified address.\\n  /// @param owner The address to query the balance of.\\n  /// @return A uint256 representing the amount owned by the passed address.\\n  function balanceOf(address owner) public view returns (uint256) {\\n      return _balances[owner];\\n  }\\n\\n  /// @dev Function to check the amount of tokens that an owner allowed to a spender.\\n  /// @param owner address The address which owns the funds.\\n  /// @param spender address The address which will spend the funds.\\n  /// @return A uint256 specifying the amount of tokens still available for the spender.\\n  function allowance(address owner, address spender) public view returns (uint256) {\\n      return _allowances[owner][spender];\\n  }\\n\\n  /// @dev Transfer token to a specified address.\\n  /// @param to The address to transfer to.\\n  /// @param value The amount to be transferred.\\n  function transfer(address to, uint256 value) public returns (bool success) {\\n    require(to != address(0), \\\"Can\\u0027t transfer tokens to address 0\\\");\\n    require(balanceOf(msg.sender) \\u003e= value, \\\"You don\\u0027t have sufficient balance to move tokens\\\");\\n\\n    _move(msg.sender, to, value);\\n\\n    return true;\\n  }\\n\\n  /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n  /// Beware that changing an allowance with this method brings the risk that someone may use both the old\\n  /// and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n  /// race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\n  /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n  /// @param spender The address which will spend the funds.\\n  /// @param value The amount of tokens to be spent.\\n  function approve(address spender, uint256 value) public returns (bool success) {\\n    require(spender != address(0), \\\"Can\\u0027t set allowance for address 0\\\");\\n    require(spender != msg.sender, \\\"Use transfer to move your own funds\\\");\\n\\n    _allowances[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  /// @dev Transfer tokens from one address to another.\\n  /// @param from address The address which you want to send tokens from\\n  /// @param to address The address which you want to transfer to\\n  /// @param value uint256 the amount of tokens to be transferred\\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\\n    require(to != address(0), \\\"Can\\u0027t transfer funds to address 0\\\");\\n\\n    // Validate that the sender is allowed to move funds on behalf of the owner\\n    require(allowance(from, msg.sender) \\u003e= value, \\\"You\\u0027re not authorized to transfer funds from this account\\\");\\n    require(balanceOf(from) \\u003e= value, \\\"Owner of funds does not have sufficient balance\\\");\\n\\n    // Decrease allowance\\n    _allowances[from][msg.sender] -= value;\\n\\n    // Move actual token balances\\n    _move(from, to, value);\\n\\n    return true;\\n  }\\n\\n  /// @notice cancels all grants pending for a given beneficiary. If you want to cancel a single\\n  /// vest, cancel all pending grants, and reinstate the ones you plan to keep\\n  function cancelGrants(address beneficiary) public onlyAdmins() {\\n    Grant[] storage userGrants = _grants[beneficiary];\\n    for (uint i = 0; i \\u003c userGrants.length; i++) {\\n      Grant storage grant = userGrants[i];\\n      if (!grant.isCancelled \\u0026\\u0026 !grant.isClaimed) {\\n        grant.isCancelled = true;\\n\\n        // remove from pending grants\\n        pendingGrants -= grant.amount;\\n      }\\n    }\\n  }\\n\\n  /// @notice Converts a vest schedule into actual shares. Must be called by the beneficiary\\n  // to convert their vests into actual shares\\n  function claimGrant() public {\\n    Grant[] storage userGrants = _grants[msg.sender];\\n    for (uint i = 0; i \\u003c userGrants.length; i++) {\\n      Grant storage grant = userGrants[i];\\n      if (!grant.isCancelled \\u0026\\u0026 !grant.isClaimed \\u0026\\u0026 now \\u003e= grant.vestTime) {\\n        grant.isClaimed = true;\\n\\n        // remove from pending grants\\n        pendingGrants -= grant.amount;\\n\\n        // issue tokens to the user\\n        _issue(msg.sender, grant.amount);\\n      }\\n    }\\n  }\\n\\n  /// @notice returns information about a grant that user has. Returns a tuple indicating\\n  /// the amount of the grant, when it will vest, whether it\\u0027s been cancelled, and whether it\\u0027s been claimed\\n  /// already.\\n  /// @param grantIndex a 0-based index of user\\u0027s grant to retrieve\\n  function getGrant(address beneficiary, uint grantIndex) public view returns (uint, uint, bool, bool) {\\n    Grant[] storage grants = _grants[beneficiary];\\n    if (grantIndex \\u003c grants.length) {\\n      Grant storage grant = grants[grantIndex];\\n      return (grant.amount, grant.vestTime, grant.isCancelled, grant.isClaimed);\\n    } else {\\n      revert(\\\"grantIndex must be smaller than length of grants\\\");\\n    }\\n  }\\n\\n  /// @notice returns number of grants a user has\\n  function getGrantCount(address beneficiary) public view returns (uint) {\\n    return _grants[beneficiary].length;\\n  }\\n\\n  /// @dev Internal function that increases the token supply by issuing new ones\\n  /// and assigning them to an owner.\\n  /// @param account The account that will receive the created tokens.\\n  /// @param amount The amount that will be created.\\n  function issue(address account, uint256 amount) public onlyAdmins() {\\n    require(account != address(0), \\\"can\\u0027t mint to address 0\\\");\\n    require(amount \\u003e 0, \\\"must issue a positive amount of tokens\\\");\\n    _issue(account, amount);\\n  }\\n\\n  /// @dev Internal function that grants shares to a beneficiary in a future date.\\n  /// @param vestTime milliseconds since epoch at which time shares can be claimed\\n  function grant(address account, uint256 amount, uint vestTime) public onlyAdmins() {\\n    require(account != address(0), \\\"grant to the zero address is not allowed\\\");\\n    require(vestTime \\u003e now, \\\"vest schedule must be in the future\\\");\\n\\n    pendingGrants += amount;\\n    _grants[account].push(Grant(amount, vestTime, false, false));\\n  }\\n\\n  /// @dev Internal helper to move balances around between two accounts.\\n  function _move(address from, address to, uint256 value) private {\\n    _balances[from] -= value;\\n    _balances[to] += value;\\n    emit Transfer(from, to, value);\\n  }\\n\\n  /// @dev issues/mints new tokens for the specified account\\n  function _issue(address account, uint256 amount) private {\\n    totalSupply += amount;\\n    _balances[account] += amount;\\n    emit Issuance(account, amount);\\n  }\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isSaleOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"money\",\"type\":\"uint256\"}],\"name\":\"calculateTokenCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"change\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"targetWallet\",\"type\":\"address\"},{\"name\":\"roundPrices\",\"type\":\"uint256[]\"},{\"name\":\"roundCapacities\",\"type\":\"uint256[]\"},{\"name\":\"advisors\",\"type\":\"address\"},{\"name\":\"founders\",\"type\":\"address\"},{\"name\":\"legal\",\"type\":\"address\"},{\"name\":\"developers\",\"type\":\"address\"},{\"name\":\"reserve\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amountSent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountReturned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"Sale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SaleCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldTokenPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newTokenPrice\",\"type\":\"uint256\"}],\"name\":\"RoundChanged\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000030f02e798bafef5a343c531c3a792a2ebf2ff95e000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000005886cec97d05fdf60d77647808aae27882e3cc9b00000000000000000000000030f02e798bafef5a343c531c3a792a2ebf2ff95e0000000000000000000000006a914d230b92f3e762447c4c185ef0438fa3139b000000000000000000000000497e8df6813b9d68426cdb553715e69fc1bbd3a10000000000000000000000009b6a1c0c29c8fa25fa5d58b72d9948a8ddc9773c000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000048e04c2705e0000000000000000000000000000000000000000000000000000050e47ef12b2000000000000000000000000000000000000000000000000000005a99830a81c000000000000000000000000000000000000000000000000000006660ab30ddc0000000000000000000000000000000000000000000000000000074b5e3f6b9a0000000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000632ea000000000000000000000000000000000000000000000000000000000006d19b000000000000000000000000000000000000000000000000000000000007802a800000000000000000000000000000000000000000000000000000000008402ec000000000000000000000000000000000000000000000000000000000091366a","Library":"","SwarmSource":"bzzr://987972e523c09dfb0adb78237fb9160ff4b8462d8eb46b722e919445e238208d"}]}