{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-06-24\r\n*/\r\n\r\npragma solidity 0.4.25;\r\n\r\ncontract Auth {\r\n\r\n  address internal mainAdmin;\r\n  address internal contractAdmin;\r\n\r\n  event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\r\n\r\n  constructor(\r\n    address _mainAdmin,\r\n    address _contractAdmin\r\n  )\r\n  internal\r\n  {\r\n    mainAdmin = _mainAdmin;\r\n    contractAdmin = _contractAdmin;\r\n  }\r\n\r\n  modifier onlyAdmin() {\r\n    require(isMainAdmin() || isContractAdmin(), \"onlyAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyMainAdmin() {\r\n    require(isMainAdmin(), \"onlyMainAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyContractAdmin() {\r\n    require(isContractAdmin(), \"onlyContractAdmin\");\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) onlyContractAdmin internal {\r\n    require(_newOwner != address(0x0));\r\n    contractAdmin = _newOwner;\r\n    emit OwnershipTransferred(msg.sender, _newOwner);\r\n  }\r\n\r\n  function isMainAdmin() public view returns (bool) {\r\n    return msg.sender == mainAdmin;\r\n  }\r\n\r\n  function isContractAdmin() public view returns (bool) {\r\n    return msg.sender == contractAdmin;\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Multiplies two unsigned integers, reverts on overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two unsigned integers, reverts on overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n   * reverts when dividing by zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ninterface ICitizen {\r\n\r\n  function addF1DepositedToInviter(address _invitee, uint _amount) external;\r\n\r\n  function addNetworkDepositedToInviter(address _inviter, uint _amount, uint _source, uint _sourceAmount) external;\r\n\r\n  function checkInvestorsInTheSameReferralTree(address _inviter, address _invitee) external view returns (bool);\r\n\r\n  function getF1Deposited(address _investor) external view returns (uint);\r\n\r\n  function getId(address _investor) external view returns (uint);\r\n\r\n  function getInvestorCount() external view returns (uint);\r\n\r\n  function getInviter(address _investor) external view returns (address);\r\n\r\n  function getDirectlyInvitee(address _investor) external view returns (address[]);\r\n\r\n  function getDirectlyInviteeHaveJoinedPackage(address _investor) external view returns (address[]);\r\n\r\n  function getNetworkDeposited(address _investor) external view returns (uint);\r\n\r\n  function getRank(address _investor) external view returns (uint);\r\n\r\n  function getRankBonus(uint _index) external view returns (uint);\r\n\r\n  function getUserAddresses(uint _index) external view returns (address);\r\n\r\n  function getSubscribers(address _investor) external view returns (uint);\r\n\r\n  function increaseInviterF1HaveJoinedPackage(address _invitee) external;\r\n\r\n  function isCitizen(address _user) view external returns (bool);\r\n\r\n  function register(address _user, string _userName, address _inviter) external returns (uint);\r\n\r\n  function showInvestorInfo(address _investorAddress) external view returns (uint, string memory, address, address[], uint, uint, uint, uint);\r\n}\r\n\r\ninterface IReserveFund {\r\n\r\n  function getLockedStatus(address _investor) view external returns (uint8);\r\n\r\n  function getTransferDifficulty() view external returns (uint);\r\n}\r\n\r\ncontract Wallet is Auth {\r\n  using SafeMath for uint;\r\n\r\n  struct Balance {\r\n    // NOTE: balance is counted in mili-dollar (1/1000 dollar)\r\n    uint totalDeposited; // Treasury package\r\n    uint[] deposited;\r\n    uint profitableBalance; // Green wallet\r\n    uint profitSourceBalance; // Gold wallet\r\n    uint profitBalance; // Mining wallet\r\n    uint totalProfited;\r\n    uint amountToMineToken;\r\n    uint ethWithdrew;\r\n  }\r\n\r\n  IReserveFund private reserveFundContract;\r\n  ICitizen private citizen;\r\n\r\n  uint public ethWithdrew;\r\n  uint private profitPaid;\r\n  uint private f11RewardCondition = 200000000; // 200k\r\n\r\n  mapping (address => Balance) private userWallets;\r\n\r\n  modifier onlyReserveFundContract() {\r\n    require(msg.sender == address(reserveFundContract), \"onlyReserveFundContract\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyCitizenContract() {\r\n    require(msg.sender == address(citizen), \"onlyCitizenContract\");\r\n    _;\r\n  }\r\n\r\n  event ProfitBalanceTransferred(address from, address to, uint amount);\r\n  event RankBonusSent(address investor, uint rank, uint amount);\r\n  // source: 0-eth 1-token 2-usdt\r\n  event ProfitSourceBalanceChanged(address investor, int amount, address from, uint8 source);\r\n  event ProfitableBalanceChanged(address investor, int amount, address from, uint8 source);\r\n  // source: 0-profit paid 1-active user\r\n  event ProfitBalanceChanged(address from, address to, int amount, uint8 source);\r\n\r\n  constructor (address _mainAdmin, address _citizen)\r\n  Auth(_mainAdmin, msg.sender)\r\n  public\r\n  {\r\n    citizen = ICitizen(_citizen);\r\n  }\r\n\r\n  // ONLY-MAIN-ADMIN-FUNCTIONS\r\n  function getProfitPaid() onlyMainAdmin public view returns(uint) {\r\n    return profitPaid;\r\n  }\r\n\r\n  // ONLY-CONTRACT-ADMIN FUNCTIONS\r\n\r\n  function setDABankContract(address _reserveFundContract) onlyContractAdmin public {\r\n    reserveFundContract = IReserveFund(_reserveFundContract);\r\n  }\r\n\r\n  function makeDailyProfit(address[] _userAddresses) onlyContractAdmin public {\r\n    require(_userAddresses.length > 0, \"Invalid input\");\r\n    uint investorCount = citizen.getInvestorCount();\r\n    uint dailyPercent;\r\n    uint dailyProfit;\r\n    uint8 lockProfit = 1;\r\n    uint id;\r\n    address userAddress;\r\n    for (uint i = 0; i < _userAddresses.length; i++) {\r\n      id = citizen.getId(_userAddresses[i]);\r\n      require(investorCount > id, \"Invalid userId\");\r\n      userAddress = _userAddresses[i];\r\n      if (reserveFundContract.getLockedStatus(userAddress) != lockProfit) {\r\n        Balance storage balance = userWallets[userAddress];\r\n        dailyPercent = (balance.totalProfited == 0 || balance.totalProfited < balance.totalDeposited) ? 5 : (balance.totalProfited < 4 * balance.totalDeposited) ? 4 : 3;\r\n        dailyProfit = balance.profitableBalance.mul(dailyPercent).div(1000);\r\n\r\n        balance.profitableBalance = balance.profitableBalance.sub(dailyProfit);\r\n        balance.profitBalance = balance.profitBalance.add(dailyProfit);\r\n        balance.totalProfited = balance.totalProfited.add(dailyProfit);\r\n        profitPaid = profitPaid.add(dailyProfit);\r\n        emit ProfitBalanceChanged(address(0x0), userAddress, int(dailyProfit), 0);\r\n      }\r\n    }\r\n  }\r\n\r\n  // ONLY-DABANK-CONTRACT FUNCTIONS\r\n  // _source: 0-eth 1-token 2-usdt\r\n  function deposit(address _to, uint _deposited, uint8 _source, uint _sourceAmount) onlyReserveFundContract public {\r\n    require(_to != address(0x0), \"User address can not be empty\");\r\n    require(_deposited > 0, \"Package value must be > 0\");\r\n\r\n    Balance storage balance = userWallets[_to];\r\n    bool firstDeposit = balance.deposited.length == 0;\r\n    balance.deposited.push(_deposited);\r\n    uint profitableIncreaseAmount = _deposited * (firstDeposit ? 2 : 1);\r\n    uint profitSourceIncreaseAmount = _deposited * 8;\r\n    balance.totalDeposited = balance.totalDeposited.add(_deposited);\r\n    balance.profitableBalance = balance.profitableBalance.add(profitableIncreaseAmount);\r\n    balance.profitSourceBalance = balance.profitSourceBalance.add(_deposited * 8);\r\n    if (_source == 2) {\r\n      if (_to == tx.origin) {\r\n        // self deposit\r\n        balance.profitBalance = balance.profitBalance.sub(_deposited);\r\n      } else {\r\n        // deposit to another\r\n        Balance storage senderBalance = userWallets[tx.origin];\r\n        senderBalance.profitBalance = senderBalance.profitBalance.sub(_deposited);\r\n      }\r\n      emit ProfitBalanceChanged(tx.origin, _to, int(_deposited) * -1, 1);\r\n    }\r\n    citizen.addF1DepositedToInviter(_to, _deposited);\r\n    addRewardToInviters(_to, _deposited, _source, _sourceAmount);\r\n\r\n    if (firstDeposit) {\r\n      citizen.increaseInviterF1HaveJoinedPackage(_to);\r\n    }\r\n\r\n    if (profitableIncreaseAmount > 0) {\r\n      emit ProfitableBalanceChanged(_to, int(profitableIncreaseAmount), _to, _source);\r\n      emit ProfitSourceBalanceChanged(_to, int(profitSourceIncreaseAmount), _to, _source);\r\n    }\r\n  }\r\n\r\n  function bonusForAdminWhenUserBuyPackageViaDollar(uint _amount, address _admin) onlyReserveFundContract public {\r\n    Balance storage adminBalance = userWallets[_admin];\r\n    adminBalance.profitBalance = adminBalance.profitBalance.add(_amount);\r\n  }\r\n\r\n  function increaseETHWithdrew(uint _amount) onlyReserveFundContract public {\r\n    ethWithdrew = ethWithdrew.add(_amount);\r\n  }\r\n\r\n  function mineToken(address _from, uint _amount) onlyReserveFundContract public {\r\n    Balance storage userBalance = userWallets[_from];\r\n    userBalance.profitBalance = userBalance.profitBalance.sub(_amount);\r\n    userBalance.amountToMineToken = userBalance.amountToMineToken.add(_amount);\r\n  }\r\n\r\n  function validateCanMineToken(uint _tokenAmount, address _from) onlyReserveFundContract public view {\r\n    Balance storage userBalance = userWallets[_from];\r\n    require(userBalance.amountToMineToken.add(_tokenAmount) <= 4 * userBalance.totalDeposited, \"You can only mine maximum 4x of your total deposited\");\r\n  }\r\n\r\n  // ONLY-CITIZEN-CONTRACT FUNCTIONS\r\n\r\n  function bonusNewRank(address _investorAddress, uint _currentRank, uint _newRank) onlyCitizenContract public {\r\n    require(_newRank > _currentRank, \"Invalid ranks\");\r\n    Balance storage balance = userWallets[_investorAddress];\r\n    for (uint8 i = uint8(_currentRank) + 1; i <= uint8(_newRank); i++) {\r\n      uint rankBonusAmount = citizen.getRankBonus(i);\r\n      balance.profitBalance = balance.profitBalance.add(rankBonusAmount);\r\n      if (rankBonusAmount > 0) {\r\n        emit RankBonusSent(_investorAddress, i, rankBonusAmount);\r\n      }\r\n    }\r\n  }\r\n\r\n  // PUBLIC FUNCTIONS\r\n\r\n  function getUserWallet(address _investor)\r\n  public\r\n  view\r\n  returns (uint, uint[], uint, uint, uint, uint, uint)\r\n  {\r\n    if (msg.sender != address(reserveFundContract) && msg.sender != contractAdmin && msg.sender != mainAdmin) {\r\n      require(_investor != mainAdmin, \"You can not see admin account\");\r\n    }\r\n    Balance storage balance = userWallets[_investor];\r\n    return (\r\n      balance.totalDeposited,\r\n      balance.deposited,\r\n      balance.profitableBalance,\r\n      balance.profitSourceBalance,\r\n      balance.profitBalance,\r\n      balance.totalProfited,\r\n      balance.ethWithdrew\r\n    );\r\n  }\r\n\r\n  function getInvestorLastDeposited(address _investor) public view returns (uint) {\r\n    return userWallets[_investor].deposited.length == 0 ? 0 : userWallets[_investor].deposited[userWallets[_investor].deposited.length - 1];\r\n  }\r\n\r\n  function transferProfitWallet(uint _amount, address _to) public {\r\n    require(_amount >= reserveFundContract.getTransferDifficulty(), \"Amount must be >= minimumTransferProfitBalance\");\r\n    Balance storage senderBalance = userWallets[msg.sender];\r\n    require(citizen.isCitizen(msg.sender), \"Please register first\");\r\n    require(citizen.isCitizen(_to), \"You can only transfer to an exists member\");\r\n    require(senderBalance.profitBalance >= _amount, \"You have not enough balance\");\r\n    bool inTheSameTree = citizen.checkInvestorsInTheSameReferralTree(msg.sender, _to);\r\n    require(inTheSameTree, \"This user isn't in your referral tree\");\r\n    Balance storage receiverBalance = userWallets[_to];\r\n    senderBalance.profitBalance = senderBalance.profitBalance.sub(_amount);\r\n    receiverBalance.profitBalance = receiverBalance.profitBalance.add(_amount);\r\n    emit ProfitBalanceTransferred(msg.sender, _to, _amount);\r\n  }\r\n\r\n  function getProfitBalance(address _investor) public view returns (uint) {\r\n    return userWallets[_investor].profitBalance;\r\n  }\r\n\r\n  // PRIVATE FUNCTIONS\r\n\r\n  function addRewardToInviters(address _invitee, uint _amount, uint8 _source, uint _sourceAmount) private {\r\n    address inviter;\r\n    uint16 referralLevel = 1;\r\n    do {\r\n      inviter = citizen.getInviter(_invitee);\r\n      if (inviter != address(0x0)) {\r\n        citizen.addNetworkDepositedToInviter(inviter, _amount, _source, _sourceAmount);\r\n        checkAddReward(_invitee, inviter, referralLevel, _source, _amount);\r\n        _invitee = inviter;\r\n        referralLevel += 1;\r\n      }\r\n    } while (inviter != address(0x0));\r\n  }\r\n\r\n  function checkAddReward(address _invitee,address _inviter, uint16 _referralLevel, uint8 _source, uint _amount) private {\r\n    uint f1Deposited = citizen.getF1Deposited(_inviter);\r\n    uint networkDeposited = citizen.getNetworkDeposited(_inviter);\r\n    uint directlyInviteeCount = citizen.getDirectlyInviteeHaveJoinedPackage(_inviter).length;\r\n    uint rank = citizen.getRank(_inviter);\r\n    if (_referralLevel == 1) {\r\n      moveBalanceForInvitingSuccessful(_invitee, _inviter, _referralLevel, _source, _amount);\r\n    } else if (_referralLevel > 1 && _referralLevel < 11) {\r\n      bool condition1 = userWallets[_inviter].deposited.length > 0 ? f1Deposited >= userWallets[_inviter].deposited[0] * 3 : false;\r\n      bool condition2 = directlyInviteeCount >= _referralLevel;\r\n      if (condition1 && condition2) {\r\n        moveBalanceForInvitingSuccessful(_invitee, _inviter, _referralLevel, _source, _amount);\r\n      }\r\n    } else {\r\n      condition1 = userWallets[_inviter].deposited.length > 0 ? f1Deposited >= userWallets[_inviter].deposited[0] * 3: false;\r\n      condition2 = directlyInviteeCount >= 10;\r\n      bool condition3 = networkDeposited >= f11RewardCondition;\r\n      bool condition4 = rank >= 3;\r\n      if (condition1 && condition2 && condition3 && condition4) {\r\n        moveBalanceForInvitingSuccessful(_invitee, _inviter, _referralLevel, _source, _amount);\r\n      }\r\n    }\r\n  }\r\n\r\n  function moveBalanceForInvitingSuccessful(address _invitee, address _inviter, uint16 _referralLevel, uint8 _source, uint _amount) private {\r\n    uint divider = (_referralLevel == 1) ? 2 : (_referralLevel > 1 && _referralLevel < 11) ? 10 : 20;\r\n    Balance storage balance = userWallets[_inviter];\r\n    uint willMoveAmount = _amount / divider;\r\n    if (balance.profitSourceBalance > willMoveAmount) {\r\n      balance.profitableBalance = balance.profitableBalance.add(willMoveAmount);\r\n      balance.profitSourceBalance = balance.profitSourceBalance.sub(willMoveAmount);\r\n      if (willMoveAmount > 0) {\r\n        emit ProfitableBalanceChanged(_inviter, int(willMoveAmount), _invitee, _source);\r\n        emit ProfitSourceBalanceChanged(_inviter, int(willMoveAmount) * -1, _invitee, _source);\r\n      }\r\n    } else {\r\n      if (balance.profitSourceBalance > 0) {\r\n        emit ProfitableBalanceChanged(_inviter, int(balance.profitSourceBalance), _invitee, _source);\r\n        emit ProfitSourceBalanceChanged(_inviter, int(balance.profitSourceBalance) * -1, _invitee, _source);\r\n      }\r\n      balance.profitableBalance = balance.profitableBalance.add(balance.profitSourceBalance);\r\n      balance.profitSourceBalance = 0;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isMainAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mineToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investorAddress\",\"type\":\"address\"},{\"name\":\"_currentRank\",\"type\":\"uint256\"},{\"name\":\"_newRank\",\"type\":\"uint256\"}],\"name\":\"bonusNewRank\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"validateCanMineToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferProfitWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethWithdrew\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"bonusForAdminWhenUserBuyPackageViaDollar\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getInvestorLastDeposited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userAddresses\",\"type\":\"address[]\"}],\"name\":\"makeDailyProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getUserWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserveFundContract\",\"type\":\"address\"}],\"name\":\"setDABankContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getProfitBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increaseETHWithdrew\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProfitPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isContractAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_deposited\",\"type\":\"uint256\"},{\"name\":\"_source\",\"type\":\"uint8\"},{\"name\":\"_sourceAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_mainAdmin\",\"type\":\"address\"},{\"name\":\"_citizen\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProfitBalanceTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rank\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RankBonusSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"source\",\"type\":\"uint8\"}],\"name\":\"ProfitSourceBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"source\",\"type\":\"uint8\"}],\"name\":\"ProfitableBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"source\",\"type\":\"uint8\"}],\"name\":\"ProfitBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Wallet","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cb7e4c77b1ea6edba3ed0884dc55d09d29779eefe46eec2c471d8fd99096833f"}]}