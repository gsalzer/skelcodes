{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.2;\n\n/**\n * @title Math\n * @dev Assorted math operations\n */\nlibrary Math {\n    /**\n    * @dev Returns the largest of two numbers.\n    */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n    * @dev Returns the smallest of two numbers.\n    */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n    * @dev Calculates the average of two numbers. Since these are integers,\n    * averages of an even and odd number cannot be represented, and will be\n    * rounded down.\n    */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool wasInitializing = initializing;\n    initializing = true;\n    initialized = true;\n\n    _;\n\n    initializing = wasInitializing;\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n/**\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\n *\n * This source code is licensed under the Mozilla Public License, version 2,\n * found in the LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n/**\n * @title Adminable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Adminable is Initializable {\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"org.zeppelinos.proxy.admin\", and is\n   * validated in the constructor.\n   */\n  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, fails.\n   */\n  modifier ifAdmin() {\n    require(msg.sender == _admin());\n    _;\n  }\n\n  function admin() external view returns (address) {\n    return _admin();\n  }\n\n    /**\n   * @return The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n}\n\n/**\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\n *\n * This source code is licensed under the Mozilla Public License, version 2,\n * found in the LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\ncontract Bridge is Adminable {\n  using SafeMath for uint256;\n\n  modifier onlyOperator() {\n    require(msg.sender == operator, \"Tried to call a only-operator function from non-operator\");\n    _;\n  }\n\n  event NewHeight(uint256 height, bytes32 indexed root);\n  event NewOperator(address operator);\n\n  struct Period {\n    uint32 height;            // the height of last block in period\n    uint32 timestamp;         // the block.timestamp at submission of period\n    uint32 parentBlockNumber; // the block.number at submission of period\n    bytes32 parentBlockHash;  // the blockhash(block.number -1) at submission of period\n  }\n\n  bytes32 constant GENESIS = 0x4920616d207665727920616e6772792c20627574206974207761732066756e21;\n\n  bytes32 public tipHash; // hash of first period that has extended chain to some height\n  uint256 public genesisBlockNumber;\n  uint256 parentBlockInterval; // how often epochs can be submitted max\n  uint256 public lastParentBlock; // last ethereum block when epoch was submitted\n  address public operator; // the operator contract\n\n  mapping(bytes32 => Period) public periods;\n\n  function initialize(uint256 _parentBlockInterval) public initializer {\n    // init genesis preiod\n    Period memory genesisPeriod = Period({\n      height: 1,\n      timestamp: uint32(block.timestamp),\n      parentBlockNumber: uint32(block.number),\n      parentBlockHash: blockhash(block.number-1)\n    });\n    tipHash = GENESIS;\n    periods[GENESIS] = genesisPeriod;\n    genesisBlockNumber = block.number;\n    parentBlockInterval = _parentBlockInterval;\n    operator = msg.sender;\n  }\n\n  function setOperator(address _operator) public ifAdmin {\n    operator = _operator;\n    emit NewOperator(_operator);\n  }\n\n  function getParentBlockInterval() public view returns (uint256) {\n    return parentBlockInterval;\n  }\n\n  function setParentBlockInterval(uint256 _parentBlockInterval) public ifAdmin {\n    parentBlockInterval = _parentBlockInterval;\n  }\n\n  function submitPeriod(\n    bytes32 _prevHash,\n    bytes32 _root)\n  public onlyOperator returns (uint256 newHeight) {\n\n    require(periods[_prevHash].timestamp > 0, \"Parent node should exist\");\n    require(periods[_root].timestamp == 0, \"Trying to submit the same root twice\");\n\n    // calculate height\n    newHeight = periods[_prevHash].height + 1;\n    // do some magic if chain extended\n    if (newHeight > periods[tipHash].height) {\n      // new periods can only be submitted every x Ethereum blocks\n      require(\n        block.number >= lastParentBlock + parentBlockInterval,\n        \"Tried to submit new period too soon\"\n      );\n      tipHash = _root;\n      lastParentBlock = block.number;\n    }\n    // strictly speaking this event should be called \"New Period\"\n    // but we don't want to break interfaces for now.\n    emit NewHeight(newHeight, _root);\n    // store the period\n    Period memory newPeriod = Period({\n      height: uint32(newHeight),\n      timestamp: uint32(block.timestamp),\n      parentBlockNumber: uint32(block.number),\n      parentBlockHash: blockhash(block.number-1)\n    });\n    periods[_root] = newPeriod;\n  }\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Originally based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n    * @dev Transfer token for a specified addresses\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burnFrom(address account, uint256 value) internal {\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\n}\n\n/**\n * @title IERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @title ERC165\n * @author Matt Condon (@shrugs)\n * @dev Implements ERC165 using a lookup table.\n */\ncontract ERC165 is IERC165 {\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n    /**\n     * 0x01ffc9a7 ===\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\n     */\n\n    /**\n     * @dev a mapping of interface id to whether or not it's supported\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev A contract implementing SupportsInterfaceWithLookup\n     * implement ERC165 itself\n     */\n    constructor () internal {\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev implement supportsInterface(bytes4) using a lookup table\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev internal method for registering an interface\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff);\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n/**\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\n *\n * This source code is licensed under the Mozilla Public License, version 2,\n * found in the LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\ncontract TransferrableToken is ERC165 {\n  function transferFrom(address _from, address _to, uint256 _valueOrTokenId) public;\n  function approve(address _to, uint256 _value) public;\n}\n\n/**\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\n *\n * This source code is licensed under the Mozilla Public License, version 2,\n * found in the LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n/**\n * @title PriorityQueue\n * @dev A priority queue implementation\n */\n\nlibrary PriorityQueue {\n  using SafeMath for uint256;\n\n  struct Token {\n    TransferrableToken addr;\n    uint256[] heapList;\n    uint256 currentSize;\n  }\n\n  function insert(Token storage self, uint256 k) internal {\n    self.heapList.push(k);\n    self.currentSize = self.currentSize.add(1);\n    percUp(self, self.currentSize);\n  }\n\n  function minChild(Token storage self, uint256 i) internal view returns (uint256) {\n    if (i.mul(2).add(1) > self.currentSize) {\n      return i.mul(2);\n    } else {\n      if (self.heapList[i.mul(2)] < self.heapList[i.mul(2).add(1)]) {\n        return i.mul(2);\n      } else {\n        return i.mul(2).add(1);\n      }\n    }\n  }\n\n  function getMin(Token storage self) internal view returns (uint256) {\n    return self.heapList[1];\n  }\n\n  function delMin(Token storage self) internal returns (uint256) {\n    uint256 retVal = self.heapList[1];\n    self.heapList[1] = self.heapList[self.currentSize];\n    delete self.heapList[self.currentSize];\n    self.currentSize = self.currentSize.sub(1);\n    percDown(self, 1);\n    self.heapList.length = self.heapList.length.sub(1);\n    return retVal;\n  }\n\n  // solium-disable-next-line security/no-assign-params\n  function percUp(Token storage self, uint256 i) private {\n    uint256 j = i;\n    uint256 newVal = self.heapList[i];\n    while (newVal < self.heapList[i.div(2)]) {\n      self.heapList[i] = self.heapList[i.div(2)];\n      i = i.div(2);\n    }\n    if (i != j) self.heapList[i] = newVal;\n  }\n\n  // solium-disable-next-line security/no-assign-params\n  function percDown(Token storage self, uint256 i) private {\n    uint256 j = i;\n    uint256 newVal = self.heapList[i];\n    uint256 mc = minChild(self, i);\n    while (mc <= self.currentSize && newVal > self.heapList[mc]) {\n      self.heapList[i] = self.heapList[mc];\n      i = mc;\n      mc = minChild(self, i);\n    }\n    if (i != j) self.heapList[i] = newVal;\n  }\n\n}\n\n/**\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\n *\n * This source code is licensed under the Mozilla Public License, version 2,\n * found in the LICENSE file in the root directory of this source tree.\n */\n\n\n/**\n * @dev Interface of the ERC1948 contract.\n */\ninterface IERC1948 {\n\n  /**\n   * @dev Emitted when `oldData` is replaced with `newData` in storage of `tokenId`.\n   *\n   * Note that `oldData` or `newData` may be empty bytes.\n   */\n  event DataUpdated(uint256 indexed tokenId, bytes32 oldData, bytes32 newData);\n\n  /**\n   * @dev Reads the data of a specified token. Returns the current data in\n   * storage of `tokenId`.\n   *\n   * @param tokenId The token to read the data off.\n   *\n   * @return A bytes32 representing the current data stored in the token.\n   */\n  function readData(uint256 tokenId) external view returns (bytes32);\n\n  /**\n   * @dev Updates the data of a specified token. Writes `newData` into storage\n   * of `tokenId`.\n   *\n   * @param tokenId The token to write data to.\n   * @param newData The data to be written to the token.\n   *\n   * Emits a `DataUpdated` event.\n   */\n  function writeData(uint256 tokenId, bytes32 newData) external;\n\n}\n\n/**\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\n *\n * This source code is licensed under the Mozilla Public License, version 2,\n * found in the LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\n\n\ncontract Vault is Adminable {\n  using PriorityQueue for PriorityQueue.Token;\n\n  // 2**15 + 1\n  uint16 constant NFT_FIRST_COLOR = 32769;\n  // 2**15 + 2**14 + 1\n  uint16 constant NST_FIRST_COLOR = 49153;\n\n  event NewToken(address indexed tokenAddr, uint16 color);\n\n  Bridge public bridge;\n\n  uint16 public erc20TokenCount;\n  uint16 public nftTokenCount;\n  uint16 public nstTokenCount;\n\n  mapping(uint16 => PriorityQueue.Token) public tokens;\n  mapping(address => bool) public tokenColors;\n\n  function initialize(Bridge _bridge) public initializer {\n    bridge = _bridge;\n  } \n\n  function getTokenAddr(uint16 _color) public view returns (address) {\n    return address(tokens[_color].addr);\n  }\n\n  function registerToken(address _token, bool _isERC721) public ifAdmin {\n    // make sure token is not 0x0 and that it has not been registered yet\n    require(_token != address(0), \"Tried to register 0x0 address\");\n    require(!tokenColors[_token], \"Token already registered\");\n    uint16 color;\n    if (_isERC721) {\n      // max nft count without being an NST is 16384\n      // color must be < 49153\n      require(nftTokenCount < 0x4000);\n      require(TransferrableToken(_token).supportsInterface(0x80ac58cd) == true, \"Not an ERC721 token\");\n      color = NFT_FIRST_COLOR + nftTokenCount; // NFT color namespace starts from 2^15 + 1\n      nftTokenCount += 1;\n    } else {\n      require(ERC20(_token).totalSupply() >= 0, \"Not an ERC20 token\");\n      color = erc20TokenCount;\n      erc20TokenCount += 1;\n    }\n    uint256[] memory arr = new uint256[](1);\n    tokenColors[_token] = true;\n    tokens[color] = PriorityQueue.Token({\n      addr: TransferrableToken(_token),\n      heapList: arr,\n      currentSize: 0\n    });\n    emit NewToken(_token, color);\n  }\n\n  function registerNST(address _token) public ifAdmin {\n    // make sure token is not 0x0 and that it has not been registered yet\n    require(_token != address(0), \"Tried to register 0x0 address\");\n    require(!tokenColors[_token], \"Token already registered\");\n    require(nstTokenCount < 0x3ffe);\n    require(TransferrableToken(_token).supportsInterface(0x80ac58cd) == true, \"Not an ERC721 token\");\n\n    uint16 color = NST_FIRST_COLOR + nstTokenCount; // NST color namespace starts from 2^15 + 2^14 + 1\n    nstTokenCount += 1;\n\n    uint256[] memory arr = new uint256[](1);\n    tokenColors[_token] = true;\n    tokens[color] = PriorityQueue.Token({\n      addr: TransferrableToken(_token),\n      heapList: arr,\n      currentSize: 0\n    });\n    emit NewToken(_token, color);\n  }\n  // solium-disable-next-line mixedcase\n  uint256[49] private ______gap;\n\n}\n\n/**\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\n *\n * This source code is licensed under the Mozilla Public License, version 2,\n * found in the LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\ncontract DepositHandler is Vault {\n\n  event NewDeposit(\n    uint32 indexed depositId,\n    address indexed depositor,\n    uint256 indexed color,\n    uint256 amount\n  );\n  event MinGasPrice(uint256 minGasPrice);\n  // Support for NSTs\n  event NewDepositV2(\n    uint32 indexed depositId,\n    address indexed depositor,\n    uint256 indexed color,\n    uint256 amount,\n    bytes32 data\n  );\n\n  struct Deposit {\n    uint64 time;\n    uint16 color;\n    address owner;\n    uint256 amount;\n  }\n\n  uint32 public depositCount;\n  uint256 public minGasPrice;\n\n  mapping(uint32 => Deposit) public deposits;\n  mapping(uint32 => bytes32) public tokenData;\n\n  function setMinGasPrice(uint256 _minGasPrice) public ifAdmin {\n    minGasPrice = _minGasPrice;\n    emit MinGasPrice(minGasPrice);\n  }\n\n /**\n  * @notice Add to the network `(_amountOrTokenId)` amount of a `(_color)` tokens\n  * or `(_amountOrTokenId)` token id if `(_color)` is NFT.\n  *\n  * !!!! DEPRECATED, use depositBySender() instead !!!!\n  *\n  * @dev Token should be registered with the Bridge first.\n  * @param _owner Account to transfer tokens from\n  * @param _amountOrTokenId Amount (for ERC20) or token ID (for ERC721) to transfer\n  * @param _color Color of the token to deposit\n  */\n  function deposit(address _owner, uint256 _amountOrTokenId, uint16 _color) public {\n    require(_owner == msg.sender, \"owner different from msg.sender\");\n    _deposit(_amountOrTokenId, _color);\n  }\n\n  function depositBySender(uint256 _amountOrTokenId, uint16 _color) public {\n    _deposit(_amountOrTokenId, _color);\n  }\n\n  function _deposit(uint256 _amountOrTokenId, uint16 _color) internal {\n    TransferrableToken token = tokens[_color].addr;\n    require(address(token) != address(0), \"Token color already registered\");\n    require(_amountOrTokenId > 0 || _color > 32769, \"no 0 deposits for fungible tokens\");\n\n    bytes32 _tokenData;\n\n    if (_color >= NST_FIRST_COLOR) {\n      IERC1948 nst = IERC1948(address(token));\n      // XXX: maybe we need a 'support' getter here, to announce support?\n      _tokenData = nst.readData(_amountOrTokenId);\n    }\n\n    token.transferFrom(msg.sender, address(this), _amountOrTokenId);\n\n    bytes32 tipHash = bridge.tipHash();\n    uint256 timestamp;\n    (, timestamp,,) = bridge.periods(tipHash);\n\n    depositCount++;\n    deposits[depositCount] = Deposit({\n      time: uint32(timestamp),\n      owner: msg.sender,\n      color: _color,\n      amount: _amountOrTokenId\n    });\n\n    if (_color >= NST_FIRST_COLOR) {\n      tokenData[depositCount] = _tokenData;\n\n      emit NewDepositV2(\n        depositCount,\n        msg.sender,\n        _color,\n        _amountOrTokenId,\n        _tokenData\n      );\n    } else {\n      emit NewDeposit(\n        depositCount,\n        msg.sender,\n        _color,\n        _amountOrTokenId\n      );\n    }\n  }\n\n  // solium-disable-next-line mixedcase\n  uint256[49] private ______gap;\n}\n\n/**\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\n *\n * This source code is licensed under the Mozilla Public License, version 2,\n * found in the LICENSE file in the root directory of this source tree.\n */\n\n/* solium-disable security/no-block-members */\n\n\n\ncontract IExitHandler {\n\n  function startExit(bytes32[] memory, bytes32[] memory, uint8, uint8) public payable;\n\n}\n\n/**\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\n *\n * This source code is licensed under the Mozilla Public License, version 2,\n * found in the LICENSE file in the root directory of this source tree.\n */\n\n\n\nlibrary TxLib {\n\n  uint constant internal WORD_SIZE = 32;\n  uint constant internal ONES = ~uint(0);\n  enum TxType { None0, None1, Deposit, Transfer, None4, None5,\n  None6, None7, None8, None9, None10, None11, None12, SpendCond }\n\n  struct Outpoint {\n    bytes32 hash;\n    uint8 pos;\n  }\n\n  struct Input {\n    Outpoint outpoint;\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n    bytes script;\n    bytes msgData;\n  }\n\n  struct Output {\n    uint256 value;\n    uint16 color;\n    address owner;\n    bytes32 stateRoot;\n  }\n\n  struct Tx {\n    TxType txType;\n    Input[] ins;\n    Output[] outs;\n  }\n\n  function parseInput(\n    TxType _type, bytes memory _txData, uint256 _pos, uint256 offset, Input[] memory _ins\n  ) internal pure returns (uint256 newOffset) {\n    bytes32 inputData;\n    uint8 index;\n    if (_type == TxType.Deposit) {\n      assembly {\n        // load the depositId (4 bytes) starting from byte 2 of tx\n        inputData := mload(add(add(offset, 4), _txData))\n      }\n      inputData = bytes32(uint256(uint32(uint256(inputData))));\n      index = 0;\n      newOffset = offset + 4;\n    } else {\n      assembly {\n        // load the prevHash (32 bytes) from input\n        inputData := mload(add(add(offset, 32), _txData))\n        // load the output index (1 byte) from input\n        index := mload(add(add(offset, 33), _txData))\n      }\n      newOffset = offset + 33;\n    }\n    Outpoint memory outpoint = Outpoint(inputData, index);\n    bytes memory data = new bytes(0);\n    Input memory input = Input(outpoint, 0, 0, 0, data, data); // solium-disable-line arg-overflow\n    if (_type == TxType.SpendCond) {\n      uint16 len;\n      assembly {\n        len := mload(add(add(offset, 35), _txData)) \n      }\n      // read msgData\n      data = new bytes(len);  \n      uint src;\n      uint dest;\n      assembly {  \n        src := add(add(add(offset, 35), 0x20), _txData) \n        dest := add(data, 0x20) \n      }\n      memcopy(src, dest, len);  \n      input.msgData = data;  \n      newOffset = offset + 37 + len;\n\n      assembly {\n        len := mload(add(newOffset, _txData)) \n      }\n\n      // read script\n      data = new bytes(len);\n      assembly {  \n        src := add(add(add(newOffset, 0), 0x20), _txData) \n        dest := add(data, 0x20) \n      }\n      memcopy(src, dest, len);  \n      input.script = data;\n      newOffset = newOffset + len;\n    }\n    if (_type == TxType.Transfer) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n      assembly {\n        r := mload(add(add(offset, 65), _txData))\n        s := mload(add(add(offset, 97), _txData))\n        v := mload(add(add(offset, 98), _txData))\n      }\n      input.r = r;\n      input.s = s;\n      input.v = v;\n      newOffset = offset + 33 + 65;\n    }\n    _ins[_pos] = input;\n  }\n\n  // Copies 'len' bytes from 'srcPtr' to 'destPtr'.\n  // NOTE: This function does not check if memory is allocated, it only copies the bytes.\n  function memcopy(uint srcPtr, uint destPtr, uint len) internal pure {\n    uint offset = 0;\n    uint size = len / WORD_SIZE;\n    // Copy word-length chunks while possible.\n    for (uint i = 0; i < size; i++) {\n      offset = i * WORD_SIZE;\n      assembly {\n        mstore(add(destPtr, offset), mload(add(srcPtr, offset)))\n      }\n    }\n    offset = size*WORD_SIZE;\n    uint mask = ONES << 8*(32 - len % WORD_SIZE);\n    assembly {\n      let nSrc := add(srcPtr, offset)\n      let nDest := add(destPtr, offset)\n      mstore(nDest, or(and(mload(nSrc), mask), and(mload(nDest), not(mask))))\n    }\n  }\n\n  function parseOutput(\n    bytes memory _txData, uint256 _pos, uint256 offset, Output[] memory _outs\n  ) internal pure returns (uint256) {\n    uint256 value;\n    uint16 color;\n    address owner;\n    bytes32 data;\n\n    assembly {\n      offset := add(offset, 32)\n      value := mload(add(offset, _txData))\n\n      offset := add(offset, 2)\n      color := and(mload(add(offset, _txData)), 0xffff)\n\n      offset := add(offset, 20)\n      owner := mload(add(offset, _txData))\n\n      // NST - data\n      // (2 ** 15) + (2 ** 14);\n      if gt(color, 49152) {\n        offset := add(offset, 32)\n        data := mload(add(offset, _txData))\n      }\n    }\n\n    Output memory output = Output(value, color, owner, data);  // solium-disable-line arg-overflow\n    _outs[_pos] = output;\n\n    return offset;\n  }\n\n  function parseTx(bytes memory _txData) internal pure returns (Tx memory txn) {\n    // read type\n    TxType txType;\n    uint256 a;\n    assembly {\n      a := mload(add(0x20, _txData))\n    }\n    a = a >> 248; // get first byte\n    if (a == 2) {\n      txType = TxType.Deposit;\n    } else if (a == 3) {\n      txType = TxType.Transfer;\n    } else if (a == 13) {\n      txType = TxType.SpendCond;\n    } else {\n      revert(\"unknown tx type\");\n    }\n    // read ins and outs\n    assembly {\n        a := mload(add(0x21, _txData))\n    }\n    a = a >> 252; // get ins-length nibble\n    Input[] memory ins = new Input[](a);\n    uint256 offset = 2;\n    for (uint i = 0; i < ins.length; i++) {\n      offset = parseInput(txType, _txData, i, offset, ins); // solium-disable-line arg-overflow\n    }\n    assembly {\n        a := mload(add(0x21, _txData))\n    }\n    a = (a >> 248) & 0x0f; // get outs-length nibble\n    Output[] memory outs = new Output[](a);\n    for (uint256 i = 0; i < outs.length; i++) {\n      offset = parseOutput(_txData, i, offset, outs); // solium-disable-line arg-overflow\n    }\n    txn = Tx(txType, ins, outs);\n  }\n\n  function getSigHash(bytes memory _txData) internal pure returns (bytes32 sigHash) {\n    uint256 a;\n    assembly {\n      a := mload(add(0x20, _txData))\n    }\n    a = a >> 248;\n    // if not transfer, sighash is just tx hash\n    require(a == 3);\n    // read ins\n    assembly {\n        a := mload(add(0x21, _txData))\n    }\n    a = a >> 252; // get ins-length nibble\n    bytes memory sigData = new bytes(_txData.length);\n    assembly {\n      // copy type\n      mstore8(add(sigData, 32), byte(0, mload(add(_txData, 32))))\n      // copy #inputs / #outputs\n      mstore8(add(sigData, 33), byte(1, mload(add(_txData, 32))))\n      let offset := 0\n      for\n        { let i := 0 }\n        lt(i, a)\n        { i := add(i, 1) }\n        {\n          mstore(add(sigData, add(34, offset)), mload(add(_txData, add(34, offset))))\n          mstore8(add(sigData, add(66, offset)), byte(0, mload(add(_txData, add(66, offset)))))\n          offset := add(offset, add(33, 65))\n        }\n      for\n        { let i := add(34, offset) }\n        lt(i, add(64, mload(_txData)))\n        { i := add(i, 0x20) }\n        {\n          mstore(add(sigData, i), mload(add(_txData, i)))\n        }\n    }\n\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", uint2str(_txData.length), sigData));\n  }\n\n  // solium-disable-next-line security/no-assign-params\n  function getMerkleRoot(\n    bytes32 _leaf, uint256 _index, uint256 _offset, bytes32[] memory _proof\n  ) internal pure returns (bytes32) {\n    bytes32 temp;\n    for (uint256 i = _offset; i < _proof.length; i++) {\n      temp = _proof[i];\n      if (_index % 2 == 0) {\n        assembly {\n          mstore(0, _leaf)\n          mstore(0x20, temp)\n          _leaf := keccak256(0, 0x40)\n        }\n      } else {\n        assembly {\n          mstore(0, temp)\n          mstore(0x20, _leaf)\n          _leaf := keccak256(0, 0x40)\n        }\n      }\n      _index = _index / 2;\n    }\n    return _leaf;\n  }\n\n  //validate that transaction is included to the period (merkle proof)\n  function validateProof(\n    uint256 _cdOffset, bytes32[] memory _proof\n  ) internal pure returns (uint64 txPos, bytes32 txHash, bytes memory txData) {\n    uint256 offset = uint8(uint256(_proof[1] >> 248));\n    uint256 txLength = uint16(uint256(_proof[1] >> 224));\n\n    txData = new bytes(txLength);\n    assembly {\n      calldatacopy(add(txData, 0x20), add(68, add(offset, _cdOffset)), txLength)\n    }\n    txHash = keccak256(txData);\n    txPos = uint64(uint256(_proof[1] >> 160));\n    bytes32 root = getMerkleRoot(\n      txHash, \n      txPos, \n      uint8(uint256(_proof[1] >> 240)),\n      _proof\n    ); \n    require(root == _proof[0]);\n  }\n\n  function recoverTxSigner(uint256 offset, bytes32[] memory _proof) internal pure returns (address dest) {\n    uint16 txLength = uint16(uint256(_proof[1] >> 224));\n    bytes memory txData = new bytes(txLength);\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n    assembly {\n      calldatacopy(add(txData, 32), add(114, offset), 43)\n      r := calldataload(add(157, offset))\n      s := calldataload(add(189, offset))\n      v := calldataload(add(190, offset))\n      calldatacopy(add(txData, 140), add(222, offset), 28) // 32 + 43 + 65\n    }\n    dest = ecrecover(getSigHash(txData), v, r, s); // solium-disable-line arg-overflow\n  }\n\n  // https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol#L886\n  // solium-disable-next-line security/no-assign-params\n  function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n    if (_i == 0) {\n      return \"0\";\n    }\n    uint j = _i;\n    uint len;\n    while (j != 0) {\n      len++;\n      j /= 10;\n    }\n    bytes memory bstr = new bytes(len);\n    uint k = len - 1;\n    while (_i != 0) {\n      bstr[k--] = byte(uint8(48 + _i % 10));\n      _i /= 10;\n    }\n    return string(bstr);\n  }\n}\n\n/**\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\n *\n * This source code is licensed under the Mozilla Public License, version 2,\n * found in the LICENSE file in the root directory of this source tree.\n */\n\n/* solium-disable security/no-block-members */\n\n\n\n\n\n\n\n\n\n\n\ncontract ExitHandler is IExitHandler, DepositHandler {\n\n  using PriorityQueue for PriorityQueue.Token;\n\n  event ExitStarted(\n    bytes32 indexed txHash,\n    uint8 indexed outIndex,\n    uint256 indexed color,\n    address exitor,\n    uint256 amount\n  );\n\n  /**\n    - tokenData — (optional) NST data\n   */\n  struct Exit {\n    uint256 amount;\n    uint16 color;\n    address owner;\n    bool finalized;\n    uint32 priorityTimestamp;\n    uint256 stake;\n    bytes32 tokenData;\n  }\n\n  uint256 public exitDuration;\n  uint256 public exitStake;\n  uint256 public nftExitCounter;\n  uint256 public nstExitCounter;\n\n  /**\n   * UTXO → Exit mapping\n   */\n  mapping(bytes32 => Exit) public exits;\n\n  function initializeWithExit(\n    Bridge _bridge,\n    uint256 _exitDuration,\n    uint256 _exitStake) public initializer {\n    initialize(_bridge);\n    exitDuration = _exitDuration;\n    exitStake = _exitStake;\n    emit MinGasPrice(0);\n  }\n\n  function setExitStake(uint256 _exitStake) public ifAdmin {\n    exitStake = _exitStake;\n  }\n\n  function setExitDuration(uint256 _exitDuration) public ifAdmin {\n    exitDuration = _exitDuration;\n  }\n\n  function startExit(\n    bytes32[] memory _youngestInputProof, bytes32[] memory _proof,\n    uint8 _outputIndex, uint8 _inputIndex\n  ) public payable {\n    require(msg.value >= exitStake, \"Not enough ether sent to pay for exit stake\");\n    uint32 timestamp;\n    (, timestamp,,) = bridge.periods(_proof[0]);\n    require(timestamp > 0, \"The referenced period was not submitted to bridge\");\n\n    if (_youngestInputProof.length > 0) {\n      (, timestamp,,) = bridge.periods(_youngestInputProof[0]);\n      require(timestamp > 0, \"The referenced period was not submitted to bridge\");\n    }\n\n    // check exiting tx inclusion in the root chain block\n    bytes32 txHash;\n    bytes memory txData;\n    uint64 txPos;\n    (txPos, txHash, txData) = TxLib.validateProof(32 * (_youngestInputProof.length + 2) + 64, _proof);\n\n    // parse exiting tx and check if it is exitable\n    TxLib.Tx memory exitingTx = TxLib.parseTx(txData);\n    TxLib.Output memory out = exitingTx.outs[_outputIndex];\n\n    bytes32 utxoId = bytes32(uint256(_outputIndex) << 120 | uint120(uint256(txHash)));\n    uint256 priority;\n    if (msg.sender != out.owner) {\n      // or caller code hashes to owner\n      address a = msg.sender;\n      assembly {\n        priority := extcodehash(a) // abusing priority for hashBytes here, to save stack\n      }\n      require(priority != 0, \"caller not contract\");\n      require(bytes20(out.owner) == ripemd160(abi.encode(priority)), \"Only UTXO owner or contract can start exit\");\n      out.owner = msg.sender;\n    }\n    require(out.value > 0, \"UTXO has no value\");\n    require(exits[utxoId].amount == 0, \"The exit for UTXO has already been started\");\n    require(!exits[utxoId].finalized, \"The exit for UTXO has already been finalized\");\n\n    \n    if (_youngestInputProof.length > 0) {\n      // check youngest input tx inclusion in the root chain block\n      bytes32 inputTxHash;\n      (txPos, inputTxHash,) = TxLib.validateProof(96, _youngestInputProof);\n      require(\n        inputTxHash == exitingTx.ins[_inputIndex].outpoint.hash,\n        \"Input from the proof is not referenced in exiting tx\"\n      );\n      \n      if (isNft(out.color)) {\n        priority = (nftExitCounter << 128) | uint128(uint256(utxoId));\n        nftExitCounter++;\n      } else if (isNST(out.color)) {\n        priority = (nstExitCounter << 128) | uint128(uint256(utxoId));\n        nstExitCounter++;\n      } else {      \n        priority = getERC20ExitPriority(timestamp, utxoId, txPos);\n      }\n    } else {\n      require(exitingTx.txType == TxLib.TxType.Deposit, \"Expected deposit tx\");\n      if (isNft(out.color)) {\n        priority = (nftExitCounter << 128) | uint128(uint256(utxoId));\n        nftExitCounter++;\n      } else if (isNST(out.color)) {\n        priority = (nstExitCounter << 128) | uint128(uint256(utxoId));\n        nstExitCounter++;\n      } else {\n        priority = getERC20ExitPriority(timestamp, utxoId, txPos);\n      }\n    }\n\n    tokens[out.color].insert(priority);\n\n    exits[utxoId] = Exit({\n      owner: out.owner,\n      color: out.color,\n      amount: out.value,\n      finalized: false,\n      stake: exitStake,\n      priorityTimestamp: timestamp,\n      tokenData: out.stateRoot\n    });\n\n    emit ExitStarted(\n      txHash,\n      _outputIndex,\n      out.color,\n      out.owner,\n      out.value\n    );\n  }\n\n  function startDepositExit(uint256 _depositId) public payable {\n    require(msg.value >= exitStake, \"Not enough ether sent to pay for exit stake\");\n    // check that deposit exits\n    Deposit memory deposit = deposits[uint32(_depositId)];\n    require(deposit.owner == msg.sender, \"Only deposit owner can start exit\");\n    require(deposit.amount > 0, \"deposit has no value\");\n    require(exits[bytes32(_depositId)].amount == 0, \"The exit of deposit has already been started\");\n    require(!exits[bytes32(_depositId)].finalized, \"The exit for deposit has already been finalized\");\n\n    uint256 priority;\n    if (isNft(deposit.color)) {\n      priority = (nftExitCounter << 128) | uint128(_depositId);\n      nftExitCounter++;\n    } else if (isNST(deposit.color)) {\n      priority = (nstExitCounter << 128) | uint128(_depositId);\n      nstExitCounter++;\n    } else {\n      priority = getERC20ExitPriority(uint32(deposit.time), bytes32(_depositId), 0);\n    }\n\n    tokens[deposit.color].insert(priority);\n\n    exits[bytes32(_depositId)] = Exit({\n      owner: deposit.owner,\n      color: deposit.color,\n      amount: deposit.amount,\n      finalized: false,\n      stake: exitStake,\n      priorityTimestamp: uint32(now),\n      tokenData: \"0x\"\n    });\n\n    // no need to emit ExitStartedV2\n    // no need to update emit data root for NSTs, as it only got deposit now.\n    emit ExitStarted(\n      bytes32(_depositId),\n      0,\n      deposit.color,\n      deposit.owner,\n      deposit.amount\n    );\n  }\n\n  // @dev Finalizes exit for the chosen color with the highest priority\n  function finalizeExits(uint16 _color) public {\n    bytes32 utxoId;\n    uint256 exitableAt;\n    Exit memory currentExit;\n\n    (utxoId, exitableAt) = getNextExit(_color);\n\n    require(tokens[_color].currentSize > 0, \"Queue empty for color.\");\n\n    for (uint i = 0; i<20; i++) {\n      // if queue is empty or top exit cannot be exited yet, stop\n      if (exitableAt > block.timestamp) {\n        return;\n      }\n\n      currentExit = exits[utxoId];\n\n      if (currentExit.owner != address(0) || currentExit.amount != 0) { // exit was not removed\n        // Note: for NFTs, the amount is actually the NFT id (both uint256)\n        if (isNft(currentExit.color)) {\n          tokens[currentExit.color].addr.transferFrom(address(this), currentExit.owner, currentExit.amount);\n        } else if (isNST(currentExit.color)) {\n          bytes32 tokenData = currentExit.tokenData;\n          address tokenAddr = address(tokens[currentExit.color].addr);\n\n          bool success;\n          (success, ) = tokenAddr.call(abi.encodeWithSignature(\"writeData(uint256,bytes32)\", currentExit.amount, tokenData));\n          // if set data did not work, we assume the token hasn't been minted yet\n          if (!success) {\n            tokenAddr.call(\n              abi.encodeWithSignature(\n                \"breed(uint256,address,bytes32)\",\n                currentExit.amount, currentExit.owner, tokenData\n              )\n            );\n          } else {\n            // only if we were able to setData we try to transfer\n            tokens[currentExit.color].addr.transferFrom(address(this), currentExit.owner, currentExit.amount);\n          }\n        } else {\n          // why so complicated? why not transfer()?\n          tokens[currentExit.color].addr.approve(address(this), currentExit.amount);\n          tokens[currentExit.color].addr.transferFrom(address(this), currentExit.owner, currentExit.amount);\n        }\n        // Pay exit stake\n        address(uint160(currentExit.owner)).send(currentExit.stake);\n      }\n\n      tokens[currentExit.color].delMin();\n      exits[utxoId].finalized = true;\n\n      if (tokens[currentExit.color].currentSize > 0) {\n        (utxoId, exitableAt) = getNextExit(_color);\n      } else {\n        return;\n      }\n    }\n  }\n\n  // @dev For backwards compatibility reasons...\n  function finalizeTopExit(uint16 _color) public {\n    finalizeExits(_color);\n  }\n\n  function challengeExit(\n    bytes32[] memory _proof,\n    bytes32[] memory _prevProof,\n    uint8 _outputIndex,\n    uint8 _inputIndex\n  ) public {\n    // validate exiting tx\n    uint256 offset = 32 * (_proof.length + 2);\n    bytes32 txHash1;\n    bytes memory txData;\n    (, txHash1, txData) = TxLib.validateProof(offset + 64, _prevProof);\n    bytes32 utxoId = bytes32(uint256(_outputIndex) << 120 | uint120(uint256(txHash1)));\n\n    TxLib.Tx memory txn;\n    if (_proof.length > 0) {\n      // validate spending tx\n      bytes32 txHash;\n      (, txHash, txData) = TxLib.validateProof(96, _proof);\n      txn = TxLib.parseTx(txData);\n\n      // make sure one is spending the other one\n      require(txHash1 == txn.ins[_inputIndex].outpoint.hash);\n      require(_outputIndex == txn.ins[_inputIndex].outpoint.pos);\n\n      // if transfer, make sure signature correct\n      if (txn.txType == TxLib.TxType.Transfer) {\n        bytes32 sigHash = TxLib.getSigHash(txData);\n        address signer = ecrecover(\n          sigHash,\n          txn.ins[_inputIndex].v,\n          txn.ins[_inputIndex].r,\n          txn.ins[_inputIndex].s\n        );\n        require(exits[utxoId].owner == signer);\n      } else {\n        revert(\"unknown tx type\");\n      }\n    } else {\n      // challenging deposit exit\n      txn = TxLib.parseTx(txData);\n      utxoId = txn.ins[_inputIndex].outpoint.hash;\n      if (txn.txType == TxLib.TxType.Deposit) {\n        // check that deposit was included correctly\n        // only then it should be usable for challenge\n        Deposit memory deposit = deposits[uint32(uint256(utxoId))];\n        require(deposit.amount == txn.outs[0].value, \"value mismatch\");\n        require(deposit.owner == txn.outs[0].owner, \"owner mismatch\");\n        require(deposit.color == txn.outs[0].color, \"color mismatch\");\n        if (isNST(deposit.color)) {\n          require(tokenData[uint32(uint256(utxoId))] == txn.outs[0].stateRoot, \"data mismatch\");\n        }\n        // todo: check timely inclusion of deposit tx\n        // this will prevent grieving attacks by the operator\n      } else {\n        revert(\"unexpected tx type\");\n      }\n    }\n\n    require(exits[utxoId].amount > 0, \"exit not found\");\n    require(!exits[utxoId].finalized, \"The exit has already been finalized\");\n\n    // award stake to challanger\n    msg.sender.transfer(exits[utxoId].stake);\n    // delete invalid exit\n    delete exits[utxoId];\n  }\n\n  function challengeYoungestInput(\n    bytes32[] memory _youngerInputProof,\n    bytes32[] memory _exitingTxProof,\n    uint8 _outputIndex,\n    uint8 _inputIndex\n  ) public {\n    // validate exiting input tx\n    bytes32 txHash;\n    bytes memory txData;\n    (, txHash, txData) = TxLib.validateProof(32 * (_youngerInputProof.length + 2) + 64, _exitingTxProof);\n    bytes32 utxoId = bytes32(uint256(_outputIndex) << 120 | uint120(uint256(txHash)));\n\n    // check the exit exists\n    require(exits[utxoId].amount > 0, \"There is no exit for this UTXO\");\n\n    TxLib.Tx memory exitingTx = TxLib.parseTx(txData);\n\n    // validate younger input tx\n    (,txHash,) = TxLib.validateProof(96, _youngerInputProof);\n\n    // check younger input is actually an input of exiting tx\n    require(txHash == exitingTx.ins[_inputIndex].outpoint.hash, \"Given output is not referenced in exiting tx\");\n\n    uint32 youngerInputTimestamp;\n    (,youngerInputTimestamp,,) = bridge.periods(_youngerInputProof[0]);\n    require(youngerInputTimestamp > 0, \"The referenced period was not submitted to bridge\");\n\n    require(exits[utxoId].priorityTimestamp < youngerInputTimestamp, \"Challenged input should be older\");\n\n    // award stake to challanger\n    msg.sender.transfer(exits[utxoId].stake);\n    // delete invalid exit\n    delete exits[utxoId];\n  }\n\n  function getNextExit(uint16 _color) internal view returns (bytes32 utxoId, uint256 exitableAt) {\n    uint256 priority = tokens[_color].getMin();\n    utxoId = bytes32(uint256(uint128(priority)));\n    exitableAt = priority >> 192;\n  }\n\n  function isNft(uint16 _color) internal pure returns (bool) {\n    return (_color >= NFT_FIRST_COLOR) && (_color < NST_FIRST_COLOR);\n  }\n\n  function isNST(uint16 _color) internal pure returns (bool) {\n    return _color >= NST_FIRST_COLOR;\n  }\n\n  function getERC20ExitPriority(\n    uint32 timestamp, bytes32 utxoId, uint64 txPos\n  ) internal view returns (uint256 priority) {\n    uint256 exitableAt = Math.max(timestamp + (2 * exitDuration), block.timestamp + exitDuration);\n    return (exitableAt << 192) | uint256(txPos) << 128 | uint128(uint256(utxoId));\n  }\n\n  // solium-disable-next-line mixedcase\n  uint256[49] private ______gap;\n}\n\n/**\n * Copyright (c) 2018-present, Leap DAO (leapdao.org)\n *\n * This source code is licensed under the Mozilla Public License, version 2,\n * found in the LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\n\n\ncontract FastExitHandler is ExitHandler {\n\n  struct Data {\n    uint32 timestamp;\n    bytes32 txHash;\n    uint64 txPos;\n    bytes32 utxoId;\n  }\n\n  function startBoughtExit(\n    bytes32[] memory _youngestInputProof, bytes32[] memory _proof,\n    uint8 _outputIndex, uint8 _inputIndex, bytes32[] memory signedData\n  ) public payable {\n    require(msg.value >= exitStake, \"Not enough ether sent to pay for exit stake\");\n    Data memory data;\n\n    (,data.timestamp,,) = bridge.periods(_proof[0]);\n    require(data.timestamp > 0, \"The referenced period was not submitted to bridge\");\n\n    (, data.timestamp,,) = bridge.periods(_youngestInputProof[0]);\n    require(data.timestamp > 0, \"The referenced period was not submitted to bridge\");\n\n    // check exiting tx inclusion in the root chain block\n    bytes memory txData;\n    (data.txPos, data.txHash, txData) = TxLib.validateProof(32 * (_youngestInputProof.length + 2) + 96, _proof);\n\n    // parse exiting tx and check if it is exitable\n    TxLib.Tx memory exitingTx = TxLib.parseTx(txData);\n    TxLib.Output memory out = exitingTx.outs[_outputIndex];\n    data.utxoId = bytes32(uint256(_outputIndex) << 120 | uint120(uint256(data.txHash)));\n\n    (uint256 buyPrice, bytes32 utxoIdSigned, address signer) = unpackSignedData(signedData);\n\n    require(!isNft(out.color), \"Can not fast exit NFTs\");\n    require(out.owner == address(this), \"Funds were not sent to this contract\");\n    require(\n      ecrecover(\n        TxLib.getSigHash(txData),\n        exitingTx.ins[0].v, exitingTx.ins[0].r, exitingTx.ins[0].s\n      ) == signer,\n      \"Signer was not the previous owner of UTXO\"\n    );\n    require(\n      data.utxoId == utxoIdSigned,\n      \"The signed utxoid does not match the one in the proof\"\n    );\n\n    require(out.value > 0, \"UTXO has no value\");\n    require(exits[data.utxoId].amount == 0, \"The exit for UTXO has already been started\");\n    require(!exits[data.utxoId].finalized, \"The exit for UTXO has already been finalized\");\n    require(exitingTx.txType == TxLib.TxType.Transfer, \"Can only fast exit transfer tx\");\n\n    uint256 priority;\n    // check youngest input tx inclusion in the root chain block\n    bytes32 inputTxHash;\n    (data.txPos, inputTxHash,) = TxLib.validateProof(128, _youngestInputProof);\n    require(\n      inputTxHash == exitingTx.ins[_inputIndex].outpoint.hash,\n      \"Input from the proof is not referenced in exiting tx\"\n    );\n\n    if (isNft(out.color)) {\n      priority = (nftExitCounter << 128) | uint128(uint256(data.utxoId));\n      nftExitCounter++;\n    } else {\n      priority = getERC20ExitPriority(data.timestamp, data.utxoId, data.txPos);\n    }\n\n    tokens[out.color].addr.transferFrom(msg.sender, signer, buyPrice);\n\n    tokens[out.color].insert(priority);\n\n    exits[data.utxoId] = Exit({\n      owner: msg.sender,\n      color: out.color,\n      amount: out.value,\n      finalized: false,\n      stake: exitStake,\n      priorityTimestamp: data.timestamp,\n      tokenData: out.stateRoot\n    });\n    emit ExitStarted(\n      data.txHash,\n      _outputIndex,\n      out.color,\n      out.owner,\n      out.value\n    );\n  }\n\n  function unpackSignedData(\n    bytes32[] memory signedData\n  ) internal pure returns (\n    uint256 buyPrice, bytes32 utxoId, address signer\n  ) {\n    utxoId = signedData[0];\n    buyPrice = uint256(signedData[1]);\n    bytes32 r = signedData[2];\n    bytes32 s = signedData[3];\n    uint8 v = uint8(uint256(signedData[4]));\n    // solium-disable-next-line\n    bytes32 sigHash = keccak256(abi.encodePacked(\n      \"\\x19Ethereum Signed Message:\\n\",\n      uint2str(64),\n      utxoId,\n      buyPrice\n    ));\n    signer = ecrecover(sigHash, v, r, s); // solium-disable-line arg-overflow\n  }\n\n  // https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol#L886\n  // solium-disable-next-line security/no-assign-params\n  function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n    if (_i == 0) {\n      return \"0\";\n    }\n    uint j = _i;\n    uint len;\n    while (j != 0) {\n      len++;\n      j /= 10;\n    }\n    bytes memory bstr = new bytes(len);\n    uint k = len - 1;\n    while (_i != 0) {\n      bstr[k--] = byte(uint8(48 + _i % 10));\n      _i /= 10;\n    }\n    return string(bstr);\n  }\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_amountOrTokenId\",\"type\":\"uint256\"},{\"name\":\"_color\",\"type\":\"uint16\"}],\"name\":\"depositBySender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"registerNST\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"tokenData\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_youngerInputProof\",\"type\":\"bytes32[]\"},{\"name\":\"_exitingTxProof\",\"type\":\"bytes32[]\"},{\"name\":\"_outputIndex\",\"type\":\"uint8\"},{\"name\":\"_inputIndex\",\"type\":\"uint8\"}],\"name\":\"challengeYoungestInput\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exitStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint64\"},{\"name\":\"color\",\"type\":\"uint16\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nstExitCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"name\":\"_prevProof\",\"type\":\"bytes32[]\"},{\"name\":\"_outputIndex\",\"type\":\"uint8\"},{\"name\":\"_inputIndex\",\"type\":\"uint8\"}],\"name\":\"challengeExit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_isERC721\",\"type\":\"bool\"}],\"name\":\"registerToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_youngestInputProof\",\"type\":\"bytes32[]\"},{\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"name\":\"_outputIndex\",\"type\":\"uint8\"},{\"name\":\"_inputIndex\",\"type\":\"uint8\"},{\"name\":\"signedData\",\"type\":\"bytes32[]\"}],\"name\":\"startBoughtExit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nftTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nftExitCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_color\",\"type\":\"uint16\"}],\"name\":\"finalizeExits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nstTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minGasPrice\",\"type\":\"uint256\"}],\"name\":\"setMinGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exitDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exitStake\",\"type\":\"uint256\"}],\"name\":\"setExitStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bridge\",\"type\":\"address\"},{\"name\":\"_exitDuration\",\"type\":\"uint256\"},{\"name\":\"_exitStake\",\"type\":\"uint256\"}],\"name\":\"initializeWithExit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc20TokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_color\",\"type\":\"uint16\"}],\"name\":\"finalizeTopExit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_amountOrTokenId\",\"type\":\"uint256\"},{\"name\":\"_color\",\"type\":\"uint16\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minGasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_color\",\"type\":\"uint16\"}],\"name\":\"getTokenAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exitDuration\",\"type\":\"uint256\"}],\"name\":\"setExitDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenColors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"currentSize\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"startDepositExit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_youngestInputProof\",\"type\":\"bytes32[]\"},{\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"name\":\"_outputIndex\",\"type\":\"uint8\"},{\"name\":\"_inputIndex\",\"type\":\"uint8\"}],\"name\":\"startExit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"exits\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"color\",\"type\":\"uint16\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"finalized\",\"type\":\"bool\"},{\"name\":\"priorityTimestamp\",\"type\":\"uint32\"},{\"name\":\"stake\",\"type\":\"uint256\"},{\"name\":\"tokenData\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"txHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"outIndex\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"color\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"exitor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ExitStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"depositId\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"color\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"minGasPrice\",\"type\":\"uint256\"}],\"name\":\"MinGasPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"depositId\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"color\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes32\"}],\"name\":\"NewDepositV2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"color\",\"type\":\"uint16\"}],\"name\":\"NewToken\",\"type\":\"event\"}]","ContractName":"FastExitHandler","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2ad2c23e3c883160309d94c830d120b44c8647c60107ef39d03f6947a659d714"}]}