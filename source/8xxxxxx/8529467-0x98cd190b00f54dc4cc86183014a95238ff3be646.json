{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-09-11\r\n*/\r\n\r\n/**\r\n *  @authors: [@mtsalenc]\r\n *  @reviewers: []\r\n *  @auditors: []\r\n *  @bounties: []\r\n *  @deployments: []\r\n */\r\n\r\npragma solidity ^0.5.11;\r\n\r\ninterface IArbitrableTCR {\r\n    \r\n    enum Party {\r\n        None,      // Party per default when there is no challenger or requester. Also used for unconclusive ruling.\r\n        Requester, // Party that made the request to change an address status.\r\n        Challenger // Party that challenges the request to change an address status.\r\n    }\r\n    \r\n    function governor() external view returns(address);\r\n    function arbitrator() external view returns(address);\r\n    function arbitratorExtraData() external view returns(bytes memory);\r\n    function requesterBaseDeposit() external view returns(uint);\r\n    function challengerBaseDeposit() external view returns(uint);\r\n    function challengePeriodDuration() external view returns(uint);\r\n    function metaEvidenceUpdates() external view returns(uint);\r\n    function winnerStakeMultiplier() external view returns(uint);\r\n    function loserStakeMultiplier() external view returns(uint);\r\n    function sharedStakeMultiplier() external view returns(uint);\r\n    function MULTIPLIER_DIVISOR() external view returns(uint);\r\n    function countByStatus() \r\n        external \r\n        view \r\n        returns(\r\n            uint absent,\r\n            uint registered,\r\n            uint registrationRequest,\r\n            uint clearingRequest,\r\n            uint challengedRegistrationRequest,\r\n            uint challengedClearingRequest\r\n        );\r\n}\r\n\r\ninterface IArbitrableAddressTCR {\r\n    enum AddressStatus {\r\n        Absent, // The address is not in the registry.\r\n        Registered, // The address is in the registry.\r\n        RegistrationRequested, // The address has a request to be added to the registry.\r\n        ClearingRequested // The address has a request to be removed from the registry.\r\n    }\r\n    \r\n    function addressCount() external view returns(uint); \r\n    function addressList(uint index) external view returns(address);\r\n    function getAddressInfo(address _address)\r\n        external\r\n        view\r\n        returns (\r\n            AddressStatus status,\r\n            uint numberOfRequests\r\n        );\r\n    \r\n    function getRequestInfo(address _address, uint _request)\r\n        external\r\n        view\r\n        returns (\r\n            bool disputed,\r\n            uint disputeID,\r\n            uint submissionTime,\r\n            bool resolved,\r\n            address[3] memory parties,\r\n            uint numberOfRounds,\r\n            IArbitrableTCR.Party ruling,\r\n            address arbitrator,\r\n            bytes memory arbitratorExtraData\r\n        );\r\n        \r\n    function getRoundInfo(address _address, uint _request, uint _round)\r\n        external\r\n        view\r\n        returns (\r\n            bool appealed,\r\n            uint[3] memory paidFees,\r\n            bool[3] memory hasPaid,\r\n            uint feeRewards\r\n        );\r\n}\r\n\r\ninterface IArbitrableTokenTCR {\r\n    enum TokenStatus {\r\n        Absent, // The address is not in the registry.\r\n        Registered, // The address is in the registry.\r\n        RegistrationRequested, // The address has a request to be added to the registry.\r\n        ClearingRequested // The address has a request to be removed from the registry.\r\n    }\r\n    \r\n    function tokenCount() external view returns(uint); \r\n    function tokensList(uint index) external view returns(bytes32);\r\n    function getTokenInfo(bytes32 _tokenID)\r\n        external\r\n        view\r\n        returns (\r\n            string memory name,\r\n            string memory ticker,\r\n            address addr,\r\n            string memory symbolMultihash,\r\n            TokenStatus status,\r\n            uint numberOfRequests\r\n        );\r\n        \r\n    function getRequestInfo(bytes32 _tokenID, uint _request)\r\n        external\r\n        view\r\n        returns (\r\n            bool disputed,\r\n            uint disputeID,\r\n            uint submissionTime,\r\n            bool resolved,\r\n            address[3] memory parties,\r\n            uint numberOfRounds,\r\n            IArbitrableTCR.Party ruling,\r\n            address arbitrator,\r\n            bytes memory arbitratorExtraData\r\n        );\r\n        \r\n    function getRoundInfo(bytes32 _tokenID, uint _request, uint _round)\r\n        external\r\n        view\r\n        returns (\r\n            bool appealed,\r\n            uint[3] memory paidFees,\r\n            bool[3] memory hasPaid,\r\n            uint feeRewards\r\n        );\r\n}\r\n\r\ninterface IArbitrator {\r\n    \r\n    enum DisputeStatus {Waiting, Appealable, Solved}\r\n    \r\n    function createDispute(uint _choices, bytes calldata _extraData) external payable returns(uint disputeID);\r\n    function arbitrationCost(bytes calldata _extraData) external view returns(uint cost);\r\n    function appeal(uint _disputeID, bytes calldata _extraData) external payable;\r\n    function appealCost(uint _disputeID, bytes calldata _extraData) external view returns(uint cost);\r\n    function appealPeriod(uint _disputeID) external view returns(uint start, uint end);\r\n    function disputeStatus(uint _disputeID) external view returns(DisputeStatus status);\r\n    function currentRuling(uint _disputeID) external view returns(uint ruling);\r\n}\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract ArbitrableTCRView {\r\n    \r\n    struct CountByStatus {\r\n        uint absent;\r\n        uint registered;\r\n        uint registrationRequest;\r\n        uint clearingRequest;\r\n        uint challengedRegistrationRequest;\r\n        uint challengedClearingRequest;\r\n    }\r\n\r\n    struct ArbitrableTCRData {\r\n        address governor;\r\n        address arbitrator;\r\n        bytes arbitratorExtraData;\r\n        uint requesterBaseDeposit;\r\n        uint challengerBaseDeposit;\r\n        uint challengePeriodDuration;\r\n        uint metaEvidenceUpdates;\r\n        uint winnerStakeMultiplier;\r\n        uint loserStakeMultiplier;\r\n        uint sharedStakeMultiplier;\r\n        uint MULTIPLIER_DIVISOR;\r\n        CountByStatus countByStatus;\r\n        uint arbitrationCost;\r\n    }\r\n\r\n    /** @dev Fetch arbitrable TCR data in a single call.\r\n     *  @param _address The address of the Generalized TCR to query.\r\n     *  @return The latest data on an arbitrable TCR contract.\r\n     */\r\n    function fetchArbitrable(address _address) external view returns (ArbitrableTCRData memory result) {\r\n        IArbitrableTCR tcr = IArbitrableTCR(_address);\r\n        result.governor = tcr.governor();\r\n        result.arbitrator = tcr.arbitrator();\r\n        result.arbitratorExtraData = tcr.arbitratorExtraData();\r\n        result.requesterBaseDeposit = tcr.requesterBaseDeposit();\r\n        result.challengerBaseDeposit = tcr.challengerBaseDeposit();\r\n        result.challengePeriodDuration = tcr.challengePeriodDuration();\r\n        result.metaEvidenceUpdates = tcr.metaEvidenceUpdates();\r\n        result.winnerStakeMultiplier = tcr.winnerStakeMultiplier();\r\n        result.loserStakeMultiplier = tcr.loserStakeMultiplier();\r\n        result.sharedStakeMultiplier = tcr.sharedStakeMultiplier();\r\n        result.MULTIPLIER_DIVISOR = tcr.MULTIPLIER_DIVISOR();\r\n        \r\n        {\r\n            (\r\n                uint absent,\r\n                uint registered,\r\n                uint registrationRequest,\r\n                uint clearingRequest,\r\n                uint challengedRegistrationRequest,\r\n                uint challengedClearingRequest\r\n            ) = tcr.countByStatus();\r\n            result.countByStatus = CountByStatus({\r\n                absent: absent,\r\n                registered: registered,\r\n                registrationRequest: registrationRequest,\r\n                clearingRequest: clearingRequest,\r\n                challengedRegistrationRequest: challengedRegistrationRequest,\r\n                challengedClearingRequest: challengedClearingRequest\r\n            });\r\n        }\r\n        \r\n        IArbitrator arbitrator = IArbitrator(result.arbitrator);\r\n        result.arbitrationCost = arbitrator.arbitrationCost(result.arbitratorExtraData);\r\n    }\r\n    \r\n    struct AppealableToken {\r\n        uint disputeID;\r\n        address arbitrator;\r\n        bytes32 tokenID;\r\n        bool inAppealPeriod;\r\n    }\r\n    \r\n    struct AppealableAddress {\r\n        uint disputeID;\r\n        address arbitrator;\r\n        address addr;\r\n        bool inAppealPeriod;\r\n    }\r\n    \r\n    function fetchAppealableAddresses(address _addressTCR, uint _cursor, uint _count) external view returns (AppealableAddress[] memory results) {\r\n        IArbitrableAddressTCR tcr = IArbitrableAddressTCR(_addressTCR);\r\n        results = new AppealableAddress[]( tcr.addressCount() < _count ?  tcr.addressCount() : _count);\r\n        \r\n        for (uint i = _cursor; i < tcr.addressCount() && _count - i > 0; i++) {\r\n            address itemAddr = tcr.addressList(i);\r\n            (\r\n                IArbitrableAddressTCR.AddressStatus status,\r\n                uint numberOfRequests\r\n            ) = tcr.getAddressInfo(itemAddr);\r\n            \r\n            if (status == IArbitrableAddressTCR.AddressStatus.Absent || status == IArbitrableAddressTCR.AddressStatus.Registered) continue;\r\n            \r\n            // Using arrays to get around stack limit.\r\n            bool[] memory disputedResolved = new bool[](2);\r\n            uint[] memory disputeIDNumberOfRounds = new uint[](2);\r\n            address arbitrator;\r\n            (\r\n                disputedResolved[0],\r\n                disputeIDNumberOfRounds[0],\r\n                ,\r\n                disputedResolved[1],\r\n                ,\r\n                disputeIDNumberOfRounds[1],\r\n                ,\r\n                arbitrator,\r\n            ) = tcr.getRequestInfo(itemAddr, numberOfRequests - 1);\r\n            \r\n            if (!disputedResolved[0] || disputedResolved[1]) continue;\r\n            \r\n            IArbitrator arbitratorContract = IArbitrator(arbitrator);\r\n            uint[] memory appealPeriod = new uint[](2);\r\n            (appealPeriod[0], appealPeriod[1]) = arbitratorContract.appealPeriod(disputeIDNumberOfRounds[0]);\r\n            if (appealPeriod[0] > 0 && appealPeriod[1] > 0) {\r\n                results[i] = AppealableAddress({\r\n                    disputeID: disputeIDNumberOfRounds[0],\r\n                    arbitrator: arbitrator,\r\n                    addr: itemAddr,\r\n                    inAppealPeriod: now < appealPeriod[1]\r\n                });\r\n                \r\n                // If the arbitrator gave a decisive ruling (i.e. did not rule for Party.None)\r\n                // we must check if the loser fully funded and the dispute is in the second half\r\n                // of the appeal period. If the dispute is in the second half, and the loser is not \r\n                // funded the appeal period is over.\r\n                IArbitrableTCR.Party currentRuling = IArbitrableTCR.Party(arbitratorContract.currentRuling(disputeIDNumberOfRounds[0]));\r\n                if (\r\n                    currentRuling != IArbitrableTCR.Party.None && \r\n                    now > (appealPeriod[1] - appealPeriod[0]) / 2 + appealPeriod[0]\r\n                ) {\r\n                    IArbitrableTCR.Party loser = currentRuling == IArbitrableTCR.Party.Requester \r\n                        ? IArbitrableTCR.Party.Challenger\r\n                        : IArbitrableTCR.Party.Requester;\r\n                        \r\n                    (\r\n                        ,\r\n                        ,\r\n                        bool[3] memory hasPaid,\r\n                    ) = tcr.getRoundInfo(itemAddr, numberOfRequests - 1, disputeIDNumberOfRounds[1] - 1);\r\n                    \r\n                    if(!hasPaid[uint(loser)]) results[i].inAppealPeriod = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function fetchAppealableToken(address _addressTCR, uint _cursor, uint _count) external view returns (AppealableToken[] memory results) {\r\n        IArbitrableTokenTCR tcr = IArbitrableTokenTCR(_addressTCR);\r\n        results = new AppealableToken[](tcr.tokenCount() < _count ? tcr.tokenCount() : _count);\r\n        \r\n        for (uint i = _cursor; i < tcr.tokenCount() && _count - i > 0; i++) {\r\n            bytes32 tokenID = tcr.tokensList(i);\r\n            (\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n                IArbitrableTokenTCR.TokenStatus status,\r\n                uint numberOfRequests\r\n            ) = tcr.getTokenInfo(tokenID);\r\n            \r\n            if (status == IArbitrableTokenTCR.TokenStatus.Absent || status == IArbitrableTokenTCR.TokenStatus.Registered) continue;\r\n            \r\n            // Using arrays to get around stack limit.\r\n            bool[] memory disputedResolved = new bool[](2);\r\n            uint[] memory disputeIDNumberOfRounds = new uint[](2);\r\n            address arbitrator;\r\n            (\r\n                disputedResolved[0],\r\n                disputeIDNumberOfRounds[0],\r\n                ,\r\n                disputedResolved[1],\r\n                ,\r\n                disputeIDNumberOfRounds[1],\r\n                ,\r\n                arbitrator,\r\n            ) = tcr.getRequestInfo(tokenID, numberOfRequests - 1);\r\n            \r\n            if (!disputedResolved[0] || disputedResolved[1]) continue;\r\n            \r\n            IArbitrator arbitratorContract = IArbitrator(arbitrator);\r\n            uint[] memory appealPeriod = new uint[](2);\r\n            (appealPeriod[0], appealPeriod[1]) = arbitratorContract.appealPeriod(disputeIDNumberOfRounds[0]);\r\n            if (appealPeriod[0] > 0 && appealPeriod[1] > 0) {\r\n                results[i] = AppealableToken({\r\n                    disputeID: disputeIDNumberOfRounds[0],\r\n                    arbitrator: arbitrator,\r\n                    tokenID: tokenID,\r\n                    inAppealPeriod: now < appealPeriod[1]\r\n                });\r\n                \r\n                // If the arbitrator gave a decisive ruling (i.e. did not rule for Party.None)\r\n                // we must check if the loser fully funded and the dispute is in the second half\r\n                // of the appeal period. If the dispute is in the second half, and the loser is not \r\n                // funded the appeal period is over.\r\n                IArbitrableTCR.Party currentRuling = IArbitrableTCR.Party(arbitratorContract.currentRuling(disputeIDNumberOfRounds[0]));\r\n                if (\r\n                    currentRuling != IArbitrableTCR.Party.None && \r\n                    now > (appealPeriod[1] - appealPeriod[0]) / 2 + appealPeriod[0]\r\n                ) {\r\n                    IArbitrableTCR.Party loser = currentRuling == IArbitrableTCR.Party.Requester \r\n                        ? IArbitrableTCR.Party.Challenger\r\n                        : IArbitrableTCR.Party.Requester;\r\n                        \r\n                    (\r\n                        ,\r\n                        ,\r\n                        bool[3] memory hasPaid,\r\n                    ) = tcr.getRoundInfo(tokenID, numberOfRequests - 1, disputeIDNumberOfRounds[1] - 1);\r\n                    \r\n                    if(!hasPaid[uint(loser)]) results[i].inAppealPeriod = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n   \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"fetchArbitrable\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"arbitratorExtraData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"requesterBaseDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"challengerBaseDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"challengePeriodDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"metaEvidenceUpdates\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winnerStakeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loserStakeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharedStakeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MULTIPLIER_DIVISOR\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"absent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registrationRequest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"clearingRequest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"challengedRegistrationRequest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"challengedClearingRequest\",\"type\":\"uint256\"}],\"internalType\":\"struct ArbitrableTCRView.CountByStatus\",\"name\":\"countByStatus\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"arbitrationCost\",\"type\":\"uint256\"}],\"internalType\":\"struct ArbitrableTCRView.ArbitrableTCRData\",\"name\":\"result\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressTCR\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"fetchAppealableToken\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"disputeID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"tokenID\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"inAppealPeriod\",\"type\":\"bool\"}],\"internalType\":\"struct ArbitrableTCRView.AppealableToken[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressTCR\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"fetchAppealableAddresses\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"disputeID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"inAppealPeriod\",\"type\":\"bool\"}],\"internalType\":\"struct ArbitrableTCRView.AppealableAddress[]\",\"name\":\"results\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ArbitrableTCRView","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://bf87e5a665ea604860d8f4bf356274481f14d2c74f86f597604c5eab24f99220"}]}