{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC20InterfaceV5.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\n\\ninterface ERC20 {\\n    function transfer(address _to, uint _value) external returns (bool success);\\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\\n    function approve(address _spender, uint _value) external returns (bool success);\\n    function totalSupply() external view returns (uint supply);\\n    function balanceOf(address _owner) external view returns (uint balance);\\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\\n    function decimals() external view returns(uint digits);\\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\\n}\\n\"},\"IBancorContracts.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\n\\nimport \\\"./ERC20InterfaceV5.sol\\\";\\n\\n\\n/**\\n    Id definitions for bancor contracts\\n\\n    Can be used in conjunction with the contract registry to get contract addresses\\n*/\\ncontract ContractIds {\\n    // generic\\n    bytes32 public constant CONTRACT_REGISTRY = \\\"ContractRegistry\\\";\\n\\n    // bancor logic\\n    bytes32 public constant BANCOR_NETWORK = \\\"BancorNetwork\\\";\\n    bytes32 public constant BANCOR_FORMULA = \\\"BancorFormula\\\";\\n    bytes32 public constant BANCOR_NETWORK_PATH_FINDER = \\\"BancorNetworkPathFinder\\\";\\n\\n    // Ids of BNT converter and BNT token\\n    bytes32 public constant BNT_TOKEN = \\\"BNTToken\\\";\\n    bytes32 public constant BNT_CONVERTER = \\\"BNTConverter\\\";\\n\\n    // Id of BancorX contract\\n    bytes32 public constant BANCOR_X = \\\"BancorX\\\";\\n}\\n\\ncontract IBancorNetworkPathFinder {\\n    function get(ERC20 srcToken, ERC20 destToken, address[] memory converterRegistries) public view returns (address[] memory);\\n}\\n\\n// File: contracts/utility/interfaces/IContractRegistry.sol\\n\\n/*\\n    Contract Registry interface\\n*/\\ncontract IContractRegistry {\\n    function addressOf(bytes32 _contractName) public view returns (address);\\n\\n    // deprecated, backward compatibility\\n    function getAddress(bytes32 _contractName) public view returns (address);\\n}\\n\\n\\n// File: contracts/converter/interfaces/IBancorConverter.sol\\n\\n/*\\n    Bancor Converter interface\\n*/\\ncontract IBancorNetwork {\\n    function getReturnByPath(ERC20[] calldata _path, uint256 _amount) external view returns (uint256, uint256);\\n    function convert2(\\n        ERC20[] calldata _path,\\n        uint256 _amount,\\n        uint256 _minReturn,\\n        address _affiliateAccount,\\n        uint256 _affiliateFee\\n    ) external payable returns (uint256);\\n}\\n\"},\"KyberBancorReserve.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\nimport \\\"./ERC20InterfaceV5.sol\\\";\\nimport \\\"./KyberReserveInterfaceV5.sol\\\";\\nimport \\\"./WithdrawableV5.sol\\\";\\nimport \\\"./UtilsV5.sol\\\";\\nimport \\\"./IBancorContracts.sol\\\";\\n\\ncontract KyberBancorReserve is KyberReserveInterface, Withdrawable, Utils {\\n\\n    uint  constant internal BPS = 10000; // 10^4\\n\\n    address public kyberNetwork;\\n    IContractRegistry public contractRegistry; // 0x52Ae12ABe5D8BD778BD5397F99cA900624CfADD4\\n    IBancorNetwork public bancorNetwork;\\n    IBancorNetworkPathFinder public bancorPathFinder;\\n    address public converterRegistry;\\n\\n    bool public tradeEnabled;\\n    uint public feeBps;\\n\\n    ERC20 public bancorEth = ERC20(0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315);\\n    ERC20 public bancorToken = ERC20(0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C);\\n\\n    mapping(address =\\u003e bool) public isTokenListed;\\n\\n    constructor(\\n        address _contractRegistry,\\n        address _kyberNetwork,\\n        uint _feeBps,\\n        address _admin\\n    )\\n        public\\n    {\\n        require(_contractRegistry != address(0), \\\"contractRegistry address is missing\\\");\\n        require(_kyberNetwork != address(0), \\\"kyberNetwork address is missing\\\");\\n        require(_admin != address(0), \\\"admin address is missing\\\");\\n        require(_feeBps \\u003c BPS, \\\"fee is too big\\\");\\n\\n        contractRegistry = IContractRegistry(_contractRegistry);\\n        bancorNetwork = IBancorNetwork(contractRegistry.getAddress(\\\"BancorNetwork\\\"));\\n        bancorPathFinder = IBancorNetworkPathFinder(contractRegistry.getAddress(\\\"BancorNetworkPathFinder\\\"));\\n        converterRegistry = contractRegistry.getAddress(\\\"BancorConverterRegistry\\\");\\n\\n        kyberNetwork = _kyberNetwork;\\n        feeBps = _feeBps;\\n        admin = _admin;\\n        tradeEnabled = true;\\n    }\\n\\n    function() external payable { }\\n\\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint) public view returns(uint) {\\n        if (!tradeEnabled) return 0;\\n\\n        ERC20 token = src == ETH_TOKEN_ADDRESS ? dest : src;\\n        if (!isTokenListed[address(token)]) { return 0; } // not listed\\n\\n        ERC20[] memory path = getConversionPath(src, dest, bancorPathFinder);\\n\\n        uint destQty;\\n        (destQty, ) = bancorNetwork.getReturnByPath(path, srcQty);\\n\\n        uint rate = calcRateFromQty(srcQty, destQty, getDecimals(src), getDecimals(dest));\\n\\n        rate = valueAfterReducingFee(rate);\\n\\n        return rate;\\n    }\\n\\n    event TradeExecute(\\n        address indexed sender,\\n        address src,\\n        uint srcAmount,\\n        address destToken,\\n        uint destAmount,\\n        address payable destAddress\\n    );\\n\\n    function trade(\\n        ERC20 srcToken,\\n        uint srcAmount,\\n        ERC20 destToken,\\n        address payable destAddress,\\n        uint conversionRate,\\n        bool validate\\n    )\\n        public\\n        payable\\n        returns(bool)\\n    {\\n\\n        require(tradeEnabled);\\n        require(msg.sender == kyberNetwork);\\n        require(srcToken == ETH_TOKEN_ADDRESS || destToken == ETH_TOKEN_ADDRESS);\\n\\n        require(doTrade(srcToken, srcAmount, destToken, destAddress, conversionRate, validate));\\n\\n        return true;\\n    }\\n\\n    // test func\\n    function testGetReturns(ERC20 token, bool isEthToToken, uint srcAmount) public returns(uint) {\\n        uint destAmount;\\n        ERC20[] memory path = getConversionPath(\\n            isEthToToken ? bancorEth : token,\\n            isEthToToken ? token : bancorEth,\\n            bancorPathFinder\\n        );\\n        if (isEthToToken) {\\n            (destAmount, ) = bancorNetwork.getReturnByPath(path, srcAmount);\\n        } else {\\n            (destAmount, ) = bancorNetwork.getReturnByPath(path, srcAmount);\\n        }\\n        tradeEnabled = true;\\n        return destAmount;\\n    }\\n\\n    event ContractsSet(address kyberNetwork, address _contractRegistry);\\n\\n    function setContracts(address _kyberNetwork, address _contractRegistry) public onlyAdmin {\\n        require(_contractRegistry != address(0), \\\"contractRegistry address is missing\\\");\\n        require(_kyberNetwork != address(0), \\\"kyberNetwork address is missing\\\");\\n\\n        kyberNetwork = _kyberNetwork;\\n        contractRegistry = IContractRegistry(_contractRegistry);\\n\\n        bancorNetwork = IBancorNetwork(contractRegistry.getAddress(\\\"BancorNetwork\\\"));\\n        bancorPathFinder = IBancorNetworkPathFinder(contractRegistry.getAddress(\\\"BancorNetworkPathFinder\\\"));\\n        converterRegistry = contractRegistry.getAddress(\\\"BancorConverterRegistry\\\");\\n\\n        emit ContractsSet(_kyberNetwork, _contractRegistry);\\n    }\\n\\n    event BasicTokensSet(address bancorEth, address bancorToken);\\n\\n    function setBasicTokens(address _bancorEth, address _bancorToken) public {\\n        require(_bancorEth != address(0), \\\"setBasicTokens: bancorEth is missing\\\");\\n        require(_bancorToken != address(0), \\\"setBasicTokens: bancorToken is missing\\\");\\n\\n        bancorEth = ERC20(_bancorEth);\\n        bancorToken = ERC20(_bancorToken);\\n\\n        emit BasicTokensSet(_bancorEth, _bancorToken);\\n    }\\n\\n    event TokenListed(ERC20 token);\\n\\n    function listToken(ERC20 token) public onlyAdmin {\\n        require(address(token) != address(0), \\\"listToken: token\\u0027s address is missing\\\");\\n        require(!isTokenListed[address(token)], \\\"listToken: duplicated\\\");\\n\\n        require(token.approve(address(bancorNetwork), 2**255), \\\"listToken: fail to approve bancor network\\\");\\n\\n        isTokenListed[address(token)] = true;\\n\\n        emit TokenListed(token);\\n    }\\n\\n    event TokenDelisted(ERC20 token);\\n\\n    function delistToken(ERC20 token) public onlyAdmin {\\n        require(address(token) != address(0), \\\"listToken: token\\u0027s address is missing\\\");\\n        require(isTokenListed[address(token)], \\\"listToken: duplicated\\\");\\n\\n        require(token.approve(address(bancorNetwork), 0), \\\"listToken: fail to approve bancor network\\\");\\n\\n        delete isTokenListed[address(token)];\\n\\n        emit TokenDelisted(token);\\n    }\\n\\n    event FeeBpsSet(uint feeBps);\\n\\n    function setFeeBps(uint _feeBps) public onlyAdmin {\\n        require(_feeBps \\u003c BPS, \\\"setFeeBps: feeBps \\u003e= bps\\\");\\n\\n        feeBps = _feeBps;\\n        emit FeeBpsSet(feeBps);\\n    }\\n\\n    event TradeEnabled(bool enable);\\n\\n    function enableTrade() public onlyAdmin returns(bool) {\\n        tradeEnabled = true;\\n        emit TradeEnabled(true);\\n\\n        return true;\\n    }\\n\\n    function disableTrade() public onlyAlerter returns(bool) {\\n        tradeEnabled = false;\\n        emit TradeEnabled(false);\\n\\n        return true;\\n    }\\n\\n    function doTrade(\\n        ERC20 srcToken,\\n        uint srcAmount,\\n        ERC20 destToken,\\n        address payable destAddress,\\n        uint conversionRate,\\n        bool validate\\n    )\\n        internal\\n        returns(bool)\\n    {\\n        // can skip validation if done at kyber network level\\n        if (validate) {\\n            require(conversionRate \\u003e 0);\\n            if (srcToken == ETH_TOKEN_ADDRESS)\\n                require(msg.value == srcAmount, \\\"doTrade: msg value is not correct for ETH trade\\\");\\n            else\\n                require(msg.value == 0, \\\"doTrade: msg value is not correct for token trade\\\");\\n        }\\n\\n        if (srcToken != ETH_TOKEN_ADDRESS) {\\n            // collect source amount\\n            require(srcToken.transferFrom(msg.sender, address(this), srcAmount), \\\"doTrade: collect src token failed\\\");\\n        }\\n\\n        ERC20[] memory path = getConversionPath(srcToken, destToken, bancorPathFinder);\\n        require(path.length \\u003e 0, \\\"doTrade: couldn\\u0027t find path\\\");\\n\\n        uint userExpectedDestAmount = calcDstQty(srcAmount, getDecimals(srcToken), getDecimals(destToken), conversionRate);\\n        uint destAmount;\\n\\n        if (srcToken == ETH_TOKEN_ADDRESS) {\\n            destAmount = bancorNetwork.convert2.value(srcAmount)(path, srcAmount, userExpectedDestAmount, address(0), 0);\\n        } else {\\n            destAmount = bancorNetwork.convert2(path, srcAmount, userExpectedDestAmount, address(0), 0);\\n        }\\n\\n        require(destAmount \\u003e= userExpectedDestAmount, \\\"doTrade: dest amount is lower than expected amount\\\");\\n\\n        if (destToken == ETH_TOKEN_ADDRESS) {\\n            destAddress.transfer(userExpectedDestAmount);\\n        } else {\\n            require(destToken.transfer(destAddress, userExpectedDestAmount), \\\"doTrade: transfer back dest token failed\\\");\\n        }\\n\\n        emit TradeExecute(msg.sender, address(srcToken), srcAmount, address(destToken), userExpectedDestAmount, destAddress);\\n        return true;\\n    }\\n\\n    function getConversionPath(ERC20 src, ERC20 dest, IBancorNetworkPathFinder finder) public view returns(ERC20[] memory path) {\\n        ERC20 bntToken = bancorToken;\\n\\n        address[] memory converterRegistries = new address[](1);\\n        converterRegistries[0] = converterRegistry;\\n\\n        if (src == ETH_TOKEN_ADDRESS) {\\n            address[] memory newPath = finder.get(bntToken, dest, converterRegistries);\\n            if (newPath.length == 0) { return path; }\\n            path = new ERC20[](newPath.length + 2);\\n            path[0] = bancorEth;\\n            path[1] = bntToken;\\n            for(uint i = 0; i \\u003c newPath.length; i++) {\\n                path[i + 2] = ERC20(newPath[i]);\\n            }\\n        } else {\\n            address[] memory newPath = finder.get(src, bntToken, converterRegistries);\\n            if (newPath.length == 0) { return path; }\\n            path = new ERC20[](newPath.length + 2);\\n            for(uint i = 0; i \\u003c newPath.length; i++) {\\n                path[i] = ERC20(newPath[i]);\\n            }\\n            path[newPath.length] = bntToken;\\n            path[newPath.length + 1] = bancorEth;\\n        }\\n\\n        return path;\\n    }\\n\\n    function valueAfterReducingFee(uint val) internal view returns(uint) {\\n        require(val \\u003c= MAX_QTY, \\\"valueAfterReducingFee: val \\u003e MAX_QTY\\\");\\n        return ((BPS - feeBps) * val) / BPS;\\n    }\\n}\\n\"},\"KyberReserveInterfaceV5.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\nimport \\\"./ERC20InterfaceV5.sol\\\";\\n\\n\\n/// @title Kyber Reserve contract\\ninterface KyberReserveInterface {\\n\\n    function trade(\\n        ERC20 srcToken,\\n        uint srcAmount,\\n        ERC20 destToken,\\n        address payable destAddress,\\n        uint conversionRate,\\n        bool validate\\n    )\\n        external\\n        payable\\n        returns(bool);\\n\\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) external view returns(uint);\\n}\\n\"},\"PermissionGroupsV5.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\n\\ncontract PermissionGroups {\\n\\n    address public admin;\\n    address public pendingAdmin;\\n    mapping(address=\\u003ebool) internal operators;\\n    mapping(address=\\u003ebool) internal alerters;\\n    address[] internal operatorsGroup;\\n    address[] internal alertersGroup;\\n    uint constant internal MAX_GROUP_SIZE = 50;\\n\\n    constructor() public {\\n        admin = msg.sender;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin);\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(operators[msg.sender]);\\n        _;\\n    }\\n\\n    modifier onlyAlerter() {\\n        require(alerters[msg.sender]);\\n        _;\\n    }\\n\\n    function getOperators () external view returns(address[] memory) {\\n        return operatorsGroup;\\n    }\\n\\n    function getAlerters () external view returns(address[] memory) {\\n        return alertersGroup;\\n    }\\n\\n    event TransferAdminPending(address pendingAdmin);\\n\\n    /**\\n     * @dev Allows the current admin to set the pendingAdmin address.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdmin(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0));\\n        emit TransferAdminPending(pendingAdmin);\\n        pendingAdmin = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\\n     * @param newAdmin The address to transfer ownership to.\\n     */\\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\\n        require(newAdmin != address(0));\\n        emit TransferAdminPending(newAdmin);\\n        emit AdminClaimed(newAdmin, admin);\\n        admin = newAdmin;\\n    }\\n\\n    event AdminClaimed( address newAdmin, address previousAdmin);\\n\\n    /**\\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\\n     */\\n    function claimAdmin() public {\\n        require(pendingAdmin == msg.sender);\\n        emit AdminClaimed(pendingAdmin, admin);\\n        admin = pendingAdmin;\\n        pendingAdmin = address(0);\\n    }\\n\\n    event AlerterAdded (address newAlerter, bool isAdd);\\n\\n    function addAlerter(address newAlerter) public onlyAdmin {\\n        require(!alerters[newAlerter]); // prevent duplicates.\\n        require(alertersGroup.length \\u003c MAX_GROUP_SIZE);\\n\\n        emit AlerterAdded(newAlerter, true);\\n        alerters[newAlerter] = true;\\n        alertersGroup.push(newAlerter);\\n    }\\n\\n    function removeAlerter (address alerter) public onlyAdmin {\\n        require(alerters[alerter]);\\n        alerters[alerter] = false;\\n\\n        for (uint i = 0; i \\u003c alertersGroup.length; ++i) {\\n            if (alertersGroup[i] == alerter) {\\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\\n                alertersGroup.length--;\\n                emit AlerterAdded(alerter, false);\\n                break;\\n            }\\n        }\\n    }\\n\\n    event OperatorAdded(address newOperator, bool isAdd);\\n\\n    function addOperator(address newOperator) public onlyAdmin {\\n        require(!operators[newOperator]); // prevent duplicates.\\n        require(operatorsGroup.length \\u003c MAX_GROUP_SIZE);\\n\\n        emit OperatorAdded(newOperator, true);\\n        operators[newOperator] = true;\\n        operatorsGroup.push(newOperator);\\n    }\\n\\n    function removeOperator (address operator) public onlyAdmin {\\n        require(operators[operator]);\\n        operators[operator] = false;\\n\\n        for (uint i = 0; i \\u003c operatorsGroup.length; ++i) {\\n            if (operatorsGroup[i] == operator) {\\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\\n                operatorsGroup.length -= 1;\\n                emit OperatorAdded(operator, false);\\n                break;\\n            }\\n        }\\n    }\\n}\\n\"},\"UtilsV5.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\nimport \\\"./ERC20InterfaceV5.sol\\\";\\n\\n\\n/// @title Kyber utils and utils2 contracts\\ncontract Utils {\\n\\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n    uint  constant internal PRECISION = (10**18);\\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\\n    uint  constant internal MAX_DECIMALS = 18;\\n    uint  constant internal ETH_DECIMALS = 18;\\n\\n    mapping(address=\\u003euint) internal decimals;\\n\\n    /// @dev get the balance of a user.\\n    /// @param token The token type\\n    /// @return The balance\\n    function getBalance(ERC20 token, address user) public view returns(uint) {\\n        if (token == ETH_TOKEN_ADDRESS)\\n            return user.balance;\\n        else\\n            return token.balanceOf(user);\\n    }\\n\\n    function setDecimals(ERC20 token) internal {\\n        if (token == ETH_TOKEN_ADDRESS)\\n            decimals[address(token)] = ETH_DECIMALS;\\n        else\\n            decimals[address(token)] = token.decimals();\\n    }\\n\\n    function getDecimals(ERC20 token) internal view returns(uint) {\\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\\n        uint tokenDecimals = decimals[address(token)];\\n        // moreover, very possible that old tokens have decimals 0\\n        // these tokens will just have higher gas fees.\\n        if (tokenDecimals == 0) return token.decimals();\\n\\n        return tokenDecimals;\\n    }\\n\\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\\n        require(srcQty \\u003c= MAX_QTY);\\n        require(rate \\u003c= MAX_RATE);\\n\\n        if (dstDecimals \\u003e= srcDecimals) {\\n            require((dstDecimals - srcDecimals) \\u003c= MAX_DECIMALS);\\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\\n        } else {\\n            require((srcDecimals - dstDecimals) \\u003c= MAX_DECIMALS);\\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\\n        }\\n    }\\n\\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\\n        require(dstQty \\u003c= MAX_QTY);\\n        require(rate \\u003c= MAX_RATE);\\n        \\n        //source quantity is rounded up. to avoid dest quantity being too low.\\n        uint numerator;\\n        uint denominator;\\n        if (srcDecimals \\u003e= dstDecimals) {\\n            require((srcDecimals - dstDecimals) \\u003c= MAX_DECIMALS);\\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\\n            denominator = rate;\\n        } else {\\n            require((dstDecimals - srcDecimals) \\u003c= MAX_DECIMALS);\\n            numerator = (PRECISION * dstQty);\\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\\n        }\\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\\n    }\\n\\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\\n    }\\n\\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\\n    }\\n\\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\\n        internal pure returns(uint)\\n    {\\n        require(srcAmount \\u003c= MAX_QTY);\\n        require(destAmount \\u003c= MAX_QTY);\\n\\n        if (dstDecimals \\u003e= srcDecimals) {\\n            require((dstDecimals - srcDecimals) \\u003c= MAX_DECIMALS);\\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\\n        } else {\\n            require((srcDecimals - dstDecimals) \\u003c= MAX_DECIMALS);\\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\\n        }\\n    }\\n\\n    function minOf(uint x, uint y) internal pure returns(uint) {\\n        return x \\u003e y ? y : x;\\n    }\\n}\\n\"},\"WithdrawableV5.sol\":{\"content\":\"pragma solidity 0.5.11;\\n\\nimport \\\"./ERC20InterfaceV5.sol\\\";\\nimport \\\"./PermissionGroupsV5.sol\\\";\\n\\n\\ncontract Withdrawable is PermissionGroups {\\n\\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\\n\\n    /**\\n     * @dev Withdraw all ERC20 compatible tokens\\n     * @param token ERC20 The address of the token contract\\n     */\\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\\n        require(token.transfer(sendTo, amount));\\n        emit TokenWithdraw(token, amount, sendTo);\\n    }\\n\\n    event EtherWithdraw(uint amount, address sendTo);\\n\\n    /**\\n     * @dev Withdraw Ethers\\n     */\\n    function withdrawEther(uint amount, address payable sendTo) external onlyAdmin {\\n        sendTo.transfer(amount);\\n        emit EtherWithdraw(amount, sendTo);\\n    }\\n}\\n\"}}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"enableTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEthToToken\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"}],\"name\":\"testGetReturns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"converterRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"listToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bancorPathFinder\",\"outputs\":[{\"internalType\":\"contract IBancorNetworkPathFinder\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bancorEth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bancorToken\",\"type\":\"address\"}],\"name\":\"setBasicTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bancorToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bancorEth\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"destAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"conversionRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"validate\",\"type\":\"bool\"}],\"name\":\"trade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeBps\",\"type\":\"uint256\"}],\"name\":\"setFeeBps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"contract IBancorNetworkPathFinder\",\"name\":\"finder\",\"type\":\"address\"}],\"name\":\"getConversionPath\",\"outputs\":[{\"internalType\":\"contract ERC20[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcQty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getConversionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bancorNetwork\",\"outputs\":[{\"internalType\":\"contract IBancorNetwork\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractRegistry\",\"outputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"delistToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyberNetwork\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_kyberNetwork\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contractRegistry\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTokenListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_kyberNetwork\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeBps\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"destAddress\",\"type\":\"address\"}],\"name\":\"TradeExecute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"kyberNetwork\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_contractRegistry\",\"type\":\"address\"}],\"name\":\"ContractsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bancorEth\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bancorToken\",\"type\":\"address\"}],\"name\":\"BasicTokensSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"TokenDelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeBps\",\"type\":\"uint256\"}],\"name\":\"FeeBpsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"TradeEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"}]","ContractName":"KyberBancorReserve","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000052ae12abe5d8bd778bd5397f99ca900624cfadd4000000000000000000000000be2f0354d970265bfc36d383af77f72736b81b540000000000000000000000000000000000000000000000000000000000000019000000000000000000000000be2f0354d970265bfc36d383af77f72736b81b54","Library":"","LicenseType":"None","SwarmSource":"bzzr://6e9fe76a21f4783f2cd750ea62a5bddc516dfe312d2a4308b10c3234e71f5fe5"}]}