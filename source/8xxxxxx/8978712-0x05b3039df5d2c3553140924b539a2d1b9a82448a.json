{"status":"1","message":"OK","result":[{"SourceCode":"{\"DSMath.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n\\ncontract DSMath {\\n    /*\\n    standard uint256 functions\\n     */\\n\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assert((z = x + y) \\u003e= x);\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assert((z = x - y) \\u003c= x);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assert((z = x * y) \\u003e= x);\\n    }\\n\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x / y;\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x \\u003c= y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x \\u003e= y ? x : y;\\n    }\\n\\n    /*\\n    uint128 functions (h is for half)\\n     */\\n\\n    function hadd(uint128 x, uint128 y) internal pure returns (uint128 z) {\\n        assert((z = x + y) \\u003e= x);\\n    }\\n\\n    function hsub(uint128 x, uint128 y) internal pure returns (uint128 z) {\\n        assert((z = x - y) \\u003c= x);\\n    }\\n\\n    function hmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\\n        assert((z = x * y) \\u003e= x);\\n    }\\n\\n    function hdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\\n        z = x / y;\\n    }\\n\\n    function hmin(uint128 x, uint128 y) internal pure returns (uint128 z) {\\n        return x \\u003c= y ? x : y;\\n    }\\n\\n    function hmax(uint128 x, uint128 y) internal pure returns (uint128 z) {\\n        return x \\u003e= y ? x : y;\\n    }\\n\\n    /*\\n    int256 functions\\n     */\\n\\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x \\u003c= y ? x : y;\\n    }\\n\\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x \\u003e= y ? x : y;\\n    }\\n\\n    /*\\n    WAD math\\n     */\\n\\n    uint128 constant WAD = 10 ** 18;\\n\\n    function wadd(uint128 x, uint128 y) internal pure returns (uint128) {\\n        return hadd(x, y);\\n    }\\n\\n    function wsub(uint128 x, uint128 y) internal pure returns (uint128) {\\n        return hsub(x, y);\\n    }\\n\\n    function wmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\\n        z = cast((uint256(x) * y + WAD / 2) / WAD);\\n    }\\n\\n    function wdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\\n        z = cast((uint256(x) * WAD + y / 2) / y);\\n    }\\n\\n    function wmin(uint128 x, uint128 y) internal pure returns (uint128) {\\n        return hmin(x, y);\\n    }\\n\\n    function wmax(uint128 x, uint128 y) internal pure returns (uint128) {\\n        return hmax(x, y);\\n    }\\n\\n    /*\\n    RAY math\\n     */\\n\\n    uint128 constant RAY = 10 ** 27;\\n\\n    function radd(uint128 x, uint128 y) internal pure returns (uint128) {\\n        return hadd(x, y);\\n    }\\n\\n    function rsub(uint128 x, uint128 y) internal pure returns (uint128) {\\n        return hsub(x, y);\\n    }\\n\\n    function rmul(uint128 x, uint128 y) internal pure returns (uint128 z) {\\n        z = cast((uint256(x) * y + RAY / 2) / RAY);\\n    }\\n\\n    function rdiv(uint128 x, uint128 y) internal pure returns (uint128 z) {\\n        z = cast((uint256(x) * RAY + y / 2) / y);\\n    }\\n\\n    function rpow(uint128 x, uint64 n) internal pure returns (uint128 z) {\\n        // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n        // and calculates x^n with x as fixed-point and n as regular unsigned.\\n        //\\n        // It\\u0027s O(log n), instead of O(n) for naive repeated multiplication.\\n        //\\n        // These facts are why it works:\\n        //\\n        //  If n is even, then x^n = (x^2)^(n/2).\\n        //  If n is odd,  then x^n = x * x^(n-1),\\n        //   and applying the equation for even x gives\\n        //    x^n = x * (x^2)^((n-1) / 2).\\n        //\\n        //  Also, EVM division is flooring and\\n        //    floor[(n-1) / 2] = floor[n / 2].\\n\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n\\n    function rmin(uint128 x, uint128 y) internal pure returns (uint128) {\\n        return hmin(x, y);\\n    }\\n\\n    function rmax(uint128 x, uint128 y) internal pure returns (uint128) {\\n        return hmax(x, y);\\n    }\\n\\n    function cast(uint256 x) internal pure returns (uint128 z) {\\n        assert((z = uint128(x)) == x);\\n    }\\n\\n}\\n\"},\"DSTokenBase.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\nimport \\\"./DSMath.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\ncontract DSTokenBase is ERC20, DSMath {\\n    uint256                                            _supply;\\n    mapping (address =\\u003e uint256)                       _balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256))  _approvals;\\n\\n    constructor(uint supply) public {\\n        _supply = supply;\\n    }\\n\\n    function totalSupply() public view returns (uint) {\\n        return _supply;\\n    }\\n    function balanceOf(address src) public view returns (uint) {\\n        return _balances[src];\\n    }\\n    function allowance(address src, address guy) public view returns (uint) {\\n        return _approvals[src][guy];\\n    }\\n\\n    function transfer(address dst, uint wad) public returns (bool) {\\n        return transferFrom(msg.sender, dst, wad);\\n    }\\n\\n    function transferFrom(address src, address dst, uint wad)\\n        public\\n        returns (bool)\\n    {\\n        if (src != msg.sender) {\\n            require(_approvals[src][msg.sender] \\u003e= wad, \\\"ds-token-insufficient-approval\\\");\\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\\n        }\\n\\n        require(_balances[src] \\u003e= wad, \\\"ds-token-insufficient-balance\\\");\\n        _balances[src] = sub(_balances[src], wad);\\n        _balances[dst] = add(_balances[dst], wad);\\n\\n        emit Transfer(src, dst, wad);\\n\\n        return true;\\n    }\\n\\n    function approve(address guy, uint wad) public returns (bool) {\\n        _approvals[msg.sender][guy] = wad;\\n\\n        emit Approval(msg.sender, guy, wad);\\n\\n        return true;\\n    }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\nimport \\\"./DSMath.sol\\\";\\n\\ncontract ERC20Events {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n}\\n\\ncontract ERC20 is ERC20Events {\\n    function totalSupply() public view returns (uint);\\n    function balanceOf(address guy) public view returns (uint);\\n    function allowance(address src, address guy) public view returns (uint);\\n\\n    function approve(address guy, uint wad) public returns (bool);\\n    function transfer(address dst, uint wad) public returns (bool);\\n    function transferFrom(address src, address dst, uint wad) public returns (bool);\\n}\\n\"},\"Lottoshi.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\nimport \\\"./DSTokenBase.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\ninterface ILottery {\\n    function getAvailablePrize() external view returns (uint256);\\n}\\n\\ncontract Lottoshi is DSTokenBase(0), Ownable {\\n    uint256 constant internal magnitude = 2 ** 64;\\n    uint256 constant internal HOUSE_PERCENTAGE = 75; // 7.5%\\n    uint256 constant internal REFERRAL_PERCENTAGE = 50; // 5%\\n    uint256 constant internal FOMO_PERCENTAGE = 120; // 12%\\n    uint256 constant internal PRIZE_LIMIT_TO_INVEST = 50000 ether;\\n    uint256 constant internal MAX_SUPPLY = 500000 * (10 ** 6);\\n    string constant public name = \\\"Lottoshi\\\";\\n    string constant public symbol = \\\"LTS\\\";\\n    uint256 constant public decimals = 6;\\n\\n    uint256 public profitPerShare;\\n    uint256 public totalStakes;\\n    address payable public lottery;\\n    bool public decentralized;\\n\\n    mapping (address =\\u003e uint256) public stakesOf;\\n    mapping (address =\\u003e uint256) public payout;\\n    mapping (address =\\u003e uint256) public dividends;\\n\\n    event Invest(address indexed user, uint256 ethAmount, uint256 tokenAmount, address referee);\\n    event Stake(address indexed user, uint256 amount);\\n    event Unstake(address indexed user, uint256 amount);\\n    event Withdraw(address indexed user, uint256 amount);\\n\\n    constructor (address payable _lottery) public {\\n        lottery = _lottery;\\n    }\\n\\n    function () external {\\n    }\\n\\n    function decentralize() external {\\n        require(lottery == msg.sender, \\\"invalid sender\\\");\\n        decentralized = true;\\n    }\\n\\n    function contribute(address referral) external payable {\\n        uint256 referralAmount;\\n        if (referral != address(0)) {\\n            referralAmount = msg.value * REFERRAL_PERCENTAGE / 300;\\n            dividends[referral] += referralAmount;\\n        }\\n        uint256 houseAmount;\\n        if (!decentralized) {\\n            houseAmount = msg.value * HOUSE_PERCENTAGE / 300;\\n            dividends[owner()] += houseAmount;\\n        }\\n        profitPerShare += (msg.value - houseAmount - referralAmount) * magnitude / totalStakes;\\n    }\\n\\n    function invest(address referral) public payable {\\n        uint256 prize = getPrize();\\n        require(prize \\u003c PRIZE_LIMIT_TO_INVEST, \\\"prize is enough\\\");\\n        uint256 fomoAmount;\\n        if (totalStakes \\u003e 0) {\\n            fomoAmount = msg.value * FOMO_PERCENTAGE / 1000;\\n            profitPerShare += fomoAmount * magnitude / totalStakes;\\n        }\\n        lottery.transfer(msg.value - fomoAmount);\\n        uint256 token1 = ethToTokens(prize);\\n        uint256 token2 = ethToTokens(prize + msg.value);\\n        uint256 tokenAmount = (token2 - token1) / 1000000000000;\\n        uint256 referralAmount;\\n        if (referral != address(0) \\u0026\\u0026 referral != msg.sender) {\\n            referralAmount = tokenAmount / 20;\\n            stakesOf[referral] += referralAmount;\\n            payout[referral] += referralAmount * profitPerShare;\\n            emit Invest(referral, 0, referralAmount, msg.sender);\\n            emit Transfer(address(0), referral, referralAmount);\\n            emit Transfer(referral, address(this), referralAmount);\\n            emit Stake(referral, referralAmount);\\n        }\\n        uint256 totalAmount = referralAmount + tokenAmount;\\n        require(_supply + totalAmount \\u003c= MAX_SUPPLY, \\\"exceed max supply\\\");\\n        stakesOf[msg.sender] += tokenAmount;\\n        payout[msg.sender] += tokenAmount * profitPerShare;\\n        _supply += totalAmount;\\n        totalStakes += totalAmount;\\n        _balances[address(this)] = totalAmount;\\n        emit Invest(msg.sender, msg.value, tokenAmount, address(0));\\n        emit Transfer(address(0), msg.sender, tokenAmount);\\n        emit Transfer(msg.sender, address(this), tokenAmount);\\n        emit Stake(msg.sender, tokenAmount);\\n    }\\n\\n    function stake(uint256 amount) external {\\n        internalTransfer(msg.sender, address(this), amount);\\n        stakesOf[msg.sender] += amount;\\n        payout[msg.sender] += amount * profitPerShare;\\n        totalStakes += amount;\\n        emit Stake(msg.sender, amount);\\n    }\\n\\n    function unstake(uint256 amount) external {\\n        require(stakesOf[msg.sender] \\u003e= amount, \\\"stakesOf not enough\\\");\\n        withdrawDividends(msg.sender);\\n        payout[msg.sender] -= amount * profitPerShare;\\n        stakesOf[msg.sender] -= amount;\\n        totalStakes -= amount;\\n        emit Unstake(msg.sender, amount);\\n        internalTransfer(address(this), msg.sender, amount);\\n    }\\n\\n    function withdrawDividends() public {\\n        withdrawDividends(msg.sender);\\n    }\\n\\n    function withdrawDividends(address payable user) internal {\\n        uint256 dividend = dividendOf(user);\\n        if (dividend \\u003e 0) {\\n            uint256 dividend2 = dividends[user];\\n            payout[user] += (dividend - dividend2) * magnitude;\\n            if (dividend2 \\u003e 0) {\\n                dividends[user] = 0;\\n            }\\n            user.transfer(dividend);\\n            emit Withdraw(user, dividend);\\n        }\\n    }\\n\\n    function dividendOf(address user) public view returns (uint256) {\\n        return (profitPerShare * stakesOf[user] - payout[user]) / magnitude + dividends[user];\\n    }\\n\\n    function ethToTokens(uint256 eth) internal pure returns (uint256) {\\n        return (sqrt(10000800016000000000000000000000000000000000000 + 4000000000000000000000000 * eth) - 100004000000000000000000) \\u003e\\u003e 1;\\n    }\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\\n        uint256 z = (x + 1) \\u003e\\u003e 1;\\n        y = x;\\n        while (z \\u003c y) {\\n            y = z;\\n            z = (x / z + z) \\u003e\\u003e 1;\\n        }\\n    }\\n\\n    function getPrize() internal view returns (uint256) {\\n        return ILottery(lottery).getAvailablePrize();\\n    }\\n\\n    function internalTransfer(address src, address dst, uint wad) internal {\\n        require(_balances[src] \\u003e= wad, \\\"ds-token-insufficient-balance\\\");\\n        _balances[src] = sub(_balances[src], wad);\\n        _balances[dst] = add(_balances[dst], wad);\\n\\n        emit Transfer(src, dst, wad);\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.2;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"}}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"guy\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakesOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decentralized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"dividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"contribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"decentralize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitPerShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"dividendOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dst\",\"type\":\"address\"},{\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lottery\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_lottery\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referee\",\"type\":\"address\"}],\"name\":\"Invest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Lottoshi","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008c53cdbe9456743e24937096ca79545cff3c113d","Library":"","LicenseType":"None","SwarmSource":"bzzr://b5964367fff56cfa583be621803ee92312b4962ac7a1725953f96c60703b3ea5"}]}