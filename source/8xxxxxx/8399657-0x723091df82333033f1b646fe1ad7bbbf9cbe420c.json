{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n    Copyright 2019 The Hydro Protocol Foundation\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n        http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.5.8;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary OperationsComponent {\r\n\r\n    function createMarket(\r\n        Store.State storage state,\r\n        Types.Market memory market\r\n    )\r\n        public\r\n    {\r\n        Requires.requireMarketAssetsValid(state, market);\r\n        Requires.requireMarketNotExist(state, market);\r\n        Requires.requireDecimalLessOrEquanThanOne(market.auctionRatioStart);\r\n        Requires.requireDecimalLessOrEquanThanOne(market.auctionRatioPerBlock);\r\n        Requires.requireDecimalGreaterThanOne(market.liquidateRate);\r\n        Requires.requireDecimalGreaterThanOne(market.withdrawRate);\r\n        require(market.withdrawRate > market.liquidateRate, \"WITHDARW_RATE_LESS_OR_EQUAL_THAN_LIQUIDATE_RATE\");\r\n\r\n        state.markets[state.marketsCount++] = market;\r\n        Events.logCreateMarket(market);\r\n    }\r\n\r\n    function updateMarket(\r\n        Store.State storage state,\r\n        uint16 marketID,\r\n        uint256 newAuctionRatioStart,\r\n        uint256 newAuctionRatioPerBlock,\r\n        uint256 newLiquidateRate,\r\n        uint256 newWithdrawRate\r\n    )\r\n        external\r\n    {\r\n        Requires.requireMarketIDExist(state, marketID);\r\n        Requires.requireDecimalLessOrEquanThanOne(newAuctionRatioStart);\r\n        Requires.requireDecimalLessOrEquanThanOne(newAuctionRatioPerBlock);\r\n        Requires.requireDecimalGreaterThanOne(newLiquidateRate);\r\n        Requires.requireDecimalGreaterThanOne(newWithdrawRate);\r\n        require(newWithdrawRate > newLiquidateRate, \"WITHDARW_RATE_LESS_OR_EQUAL_THAN_LIQUIDATE_RATE\");\r\n\r\n        state.markets[marketID].auctionRatioStart = newAuctionRatioStart;\r\n        state.markets[marketID].auctionRatioPerBlock = newAuctionRatioPerBlock;\r\n        state.markets[marketID].liquidateRate = newLiquidateRate;\r\n        state.markets[marketID].withdrawRate = newWithdrawRate;\r\n\r\n        Events.logUpdateMarket(\r\n            marketID,\r\n            newAuctionRatioStart,\r\n            newAuctionRatioPerBlock,\r\n            newLiquidateRate,\r\n            newWithdrawRate\r\n        );\r\n    }\r\n\r\n    function setMarketBorrowUsability(\r\n        Store.State storage state,\r\n        uint16 marketID,\r\n        bool   usability\r\n    )\r\n        external\r\n    {\r\n        Requires.requireMarketIDExist(state, marketID);\r\n        state.markets[marketID].borrowEnable = usability;\r\n        if (usability) {\r\n            Events.logMarketBorrowDisable(\r\n                marketID\r\n            );\r\n        } else {\r\n            Events.logMarketBorrowEnable(\r\n                marketID\r\n            );\r\n        }\r\n    }\r\n\r\n    function createAsset(\r\n        Store.State storage state,\r\n        address asset,\r\n        address oracleAddress,\r\n        address interestModelAddress,\r\n        string calldata poolTokenName,\r\n        string calldata poolTokenSymbol,\r\n        uint8 poolTokenDecimals\r\n    )\r\n        external\r\n    {\r\n        Requires.requirePriceOracleAddressValid(oracleAddress);\r\n        Requires.requireAssetNotExist(state, asset);\r\n\r\n        LendingPool.initializeAssetLendingPool(state, asset);\r\n\r\n        state.assets[asset].priceOracle = IPriceOracle(oracleAddress);\r\n        state.assets[asset].interestModel = IInterestModel(interestModelAddress);\r\n        state.assets[asset].lendingPoolToken = ILendingPoolToken(address(new LendingPoolToken(\r\n            poolTokenName,\r\n            poolTokenSymbol,\r\n            poolTokenDecimals\r\n        )));\r\n\r\n        Events.logCreateAsset(\r\n            asset,\r\n            oracleAddress,\r\n            address(state.assets[asset].lendingPoolToken),\r\n            interestModelAddress\r\n        );\r\n    }\r\n\r\n    function updateAsset(\r\n        Store.State storage state,\r\n        address asset,\r\n        address oracleAddress,\r\n        address interestModelAddress\r\n    )\r\n        external\r\n    {\r\n        Requires.requirePriceOracleAddressValid(oracleAddress);\r\n        Requires.requireAssetExist(state, asset);\r\n\r\n        state.assets[asset].priceOracle = IPriceOracle(oracleAddress);\r\n        state.assets[asset].interestModel = IInterestModel(interestModelAddress);\r\n\r\n        Events.logUpdateAsset(\r\n            asset,\r\n            oracleAddress,\r\n            interestModelAddress\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @param newConfig A data blob representing the new discount config. Details on format above.\r\n     */\r\n    function updateDiscountConfig(\r\n        Store.State storage state,\r\n        bytes32 newConfig\r\n    )\r\n        external\r\n    {\r\n        state.exchange.discountConfig = newConfig;\r\n        Events.logUpdateDiscountConfig(newConfig);\r\n    }\r\n\r\n    function updateAuctionInitiatorRewardRatio(\r\n        Store.State storage state,\r\n        uint256 newInitiatorRewardRatio\r\n    )\r\n        external\r\n    {\r\n        Requires.requireDecimalLessOrEquanThanOne(newInitiatorRewardRatio);\r\n\r\n        state.auction.initiatorRewardRatio = newInitiatorRewardRatio;\r\n        Events.logUpdateAuctionInitiatorRewardRatio(newInitiatorRewardRatio);\r\n    }\r\n\r\n    function updateInsuranceRatio(\r\n        Store.State storage state,\r\n        uint256 newInsuranceRatio\r\n    )\r\n        external\r\n    {\r\n        Requires.requireDecimalLessOrEquanThanOne(newInsuranceRatio);\r\n\r\n        state.pool.insuranceRatio = newInsuranceRatio;\r\n        Events.logUpdateInsuranceRatio(newInsuranceRatio);\r\n    }\r\n}\r\n\r\nlibrary CollateralAccounts {\r\n    using SafeMath for uint256;\r\n\r\n    function getDetails(\r\n        Store.State storage state,\r\n        address user,\r\n        uint16 marketID\r\n    )\r\n        internal\r\n        view\r\n        returns (Types.CollateralAccountDetails memory details)\r\n    {\r\n        Types.CollateralAccount storage account = state.accounts[user][marketID];\r\n        Types.Market storage market = state.markets[marketID];\r\n\r\n        details.status = account.status;\r\n\r\n        address baseAsset = market.baseAsset;\r\n        address quoteAsset = market.quoteAsset;\r\n\r\n        uint256 baseUSDPrice = AssemblyCall.getAssetPriceFromPriceOracle(\r\n            address(state.assets[baseAsset].priceOracle),\r\n            baseAsset\r\n        );\r\n        uint256 quoteUSDPrice = AssemblyCall.getAssetPriceFromPriceOracle(\r\n            address(state.assets[quoteAsset].priceOracle),\r\n            quoteAsset\r\n        );\r\n\r\n        uint256 baseBorrowOf = LendingPool.getAmountBorrowed(state, baseAsset, user, marketID);\r\n        uint256 quoteBorrowOf = LendingPool.getAmountBorrowed(state, quoteAsset, user, marketID);\r\n\r\n        details.debtsTotalUSDValue = SafeMath.add(\r\n            baseBorrowOf.mul(baseUSDPrice),\r\n            quoteBorrowOf.mul(quoteUSDPrice)\r\n        ) / Decimal.one();\r\n\r\n        details.balancesTotalUSDValue = SafeMath.add(\r\n            account.balances[baseAsset].mul(baseUSDPrice),\r\n            account.balances[quoteAsset].mul(quoteUSDPrice)\r\n        ) / Decimal.one();\r\n\r\n        if (details.status == Types.CollateralAccountStatus.Normal) {\r\n            details.liquidatable = details.balancesTotalUSDValue < Decimal.mulCeil(details.debtsTotalUSDValue, market.liquidateRate);\r\n        } else {\r\n            details.liquidatable = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the amount that is avaliable to transfer out of the collateral account.\r\n     *\r\n     * If there are no open loans, this is just the total asset balance.\r\n     *\r\n     * If there are open loans, then this is the maximum amount that can be withdrawn\r\n     *   without falling below the withdraw collateral ratio\r\n     */\r\n    function getTransferableAmount(\r\n        Store.State storage state,\r\n        uint16 marketID,\r\n        address user,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Types.CollateralAccountDetails memory details = getDetails(state, user, marketID);\r\n\r\n        // already checked at batch operation\r\n        // liquidating or liquidatable account can't move asset\r\n\r\n        uint256 assetBalance = state.accounts[user][marketID].balances[asset];\r\n\r\n        // If and only if balance USD value is larger than transferableUSDValueBar, the user is able to withdraw some assets\r\n        uint256 transferableThresholdUSDValue = Decimal.mulCeil(\r\n            details.debtsTotalUSDValue,\r\n            state.markets[marketID].withdrawRate\r\n        );\r\n\r\n        if(transferableThresholdUSDValue > details.balancesTotalUSDValue) {\r\n            return 0;\r\n        } else {\r\n            uint256 transferableUSD = details.balancesTotalUSDValue - transferableThresholdUSDValue;\r\n            uint256 assetUSDPrice = state.assets[asset].priceOracle.getPrice(asset);\r\n            uint256 transferableAmount = Decimal.divFloor(transferableUSD, assetUSDPrice);\r\n            if (transferableAmount > assetBalance) {\r\n                return assetBalance;\r\n            } else {\r\n                return transferableAmount;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary LendingPool {\r\n    using SafeMath for uint256;\r\n    using SafeMath for int256;\r\n\r\n    uint256 private constant SECONDS_OF_YEAR = 31536000;\r\n\r\n    // create new pool\r\n    function initializeAssetLendingPool(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        internal\r\n    {\r\n        // indexes starts at 1 for easy computation\r\n        state.pool.borrowIndex[asset] = Decimal.one();\r\n        state.pool.supplyIndex[asset] = Decimal.one();\r\n\r\n        // record starting time for the pool\r\n        state.pool.indexStartTime[asset] = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * Supply asset into the pool. Supplied asset in the pool gains interest.\r\n     */\r\n    function supply(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 amount,\r\n        address user\r\n    )\r\n        internal\r\n    {\r\n        // update value of index at this moment in time\r\n        updateIndex(state, asset);\r\n\r\n        // transfer asset from user's balance account\r\n        Transfer.transferOut(state, asset, BalancePath.getCommonPath(user), amount);\r\n\r\n        // compute the normalized value of 'amount'\r\n        // round floor\r\n        uint256 normalizedAmount = Decimal.divFloor(amount, state.pool.supplyIndex[asset]);\r\n\r\n        // mint normalizedAmount of pool token for user\r\n        state.assets[asset].lendingPoolToken.mint(user, normalizedAmount);\r\n\r\n        // update interest rate based on latest state\r\n        updateInterestRate(state, asset);\r\n\r\n        Events.logSupply(user, asset, amount);\r\n    }\r\n\r\n    /**\r\n     * unsupply asset from the pool, up to initial asset supplied plus interest\r\n     */\r\n    function unsupply(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 amount,\r\n        address user\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // update value of index at this moment in time\r\n        updateIndex(state, asset);\r\n\r\n        // compute the normalized value of 'amount'\r\n        // round ceiling\r\n        uint256 normalizedAmount = Decimal.divCeil(amount, state.pool.supplyIndex[asset]);\r\n\r\n        uint256 unsupplyAmount = amount;\r\n\r\n        // check and cap the amount so user can't overdraw\r\n        if (getNormalizedSupplyOf(state, asset, user) <= normalizedAmount) {\r\n            normalizedAmount = getNormalizedSupplyOf(state, asset, user);\r\n            unsupplyAmount = Decimal.mulFloor(normalizedAmount, state.pool.supplyIndex[asset]);\r\n        }\r\n\r\n        // transfer asset to user's balance account\r\n        Transfer.transferIn(state, asset, BalancePath.getCommonPath(user), unsupplyAmount);\r\n        Requires.requireCashLessThanOrEqualContractBalance(state, asset);\r\n\r\n        // subtract normalizedAmount from the pool\r\n        state.assets[asset].lendingPoolToken.burn(user, normalizedAmount);\r\n\r\n        // update interest rate based on latest state\r\n        updateInterestRate(state, asset);\r\n\r\n        Events.logUnsupply(user, asset, unsupplyAmount);\r\n\r\n        return unsupplyAmount;\r\n    }\r\n\r\n    /**\r\n     * Borrow money from the lending pool.\r\n     */\r\n    function borrow(\r\n        Store.State storage state,\r\n        address user,\r\n        uint16 marketID,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        // update value of index at this moment in time\r\n        updateIndex(state, asset);\r\n\r\n        // compute the normalized value of 'amount'\r\n        uint256 normalizedAmount = Decimal.divCeil(amount, state.pool.borrowIndex[asset]);\r\n\r\n        // transfer assets to user's balance account\r\n        Transfer.transferIn(state, asset, BalancePath.getMarketPath(user, marketID), amount);\r\n        Requires.requireCashLessThanOrEqualContractBalance(state, asset);\r\n\r\n        // update normalized amount borrowed by user\r\n        state.pool.normalizedBorrow[user][marketID][asset] = state.pool.normalizedBorrow[user][marketID][asset].add(normalizedAmount);\r\n\r\n        // update normalized amount borrowed from the pool\r\n        state.pool.normalizedTotalBorrow[asset] = state.pool.normalizedTotalBorrow[asset].add(normalizedAmount);\r\n\r\n        // update interest rate based on latest state\r\n        updateInterestRate(state, asset);\r\n\r\n        Requires.requireCollateralAccountNotLiquidatable(state, user, marketID);\r\n\r\n        Events.logBorrow(user, marketID, asset, amount);\r\n    }\r\n\r\n    /**\r\n     * repay money borrowed money from the pool.\r\n     */\r\n    function repay(\r\n        Store.State storage state,\r\n        address user,\r\n        uint16 marketID,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // update value of index at this moment in time\r\n        updateIndex(state, asset);\r\n\r\n        // get normalized value of amount to be repaid, which in effect take into account interest\r\n        // (ex: if you borrowed 10, with index at 1.1, amount repaid needs to be 11 to make 11/1.1 = 10)\r\n        uint256 normalizedAmount = Decimal.divFloor(amount, state.pool.borrowIndex[asset]);\r\n\r\n        uint256 repayAmount = amount;\r\n\r\n        // make sure user cannot repay more than amount owed\r\n        if (state.pool.normalizedBorrow[user][marketID][asset] <= normalizedAmount) {\r\n            normalizedAmount = state.pool.normalizedBorrow[user][marketID][asset];\r\n            // repayAmount <= amount\r\n            // because ⌈⌊a/b⌋*b⌉ <= a\r\n            repayAmount = Decimal.mulCeil(normalizedAmount, state.pool.borrowIndex[asset]);\r\n        }\r\n\r\n        // transfer assets from user's balance account\r\n        Transfer.transferOut(state, asset, BalancePath.getMarketPath(user, marketID), repayAmount);\r\n\r\n        // update amount(normalized) borrowed by user\r\n        state.pool.normalizedBorrow[user][marketID][asset] = state.pool.normalizedBorrow[user][marketID][asset].sub(normalizedAmount);\r\n\r\n        // update total amount(normalized) borrowed from pool\r\n        state.pool.normalizedTotalBorrow[asset] = state.pool.normalizedTotalBorrow[asset].sub(normalizedAmount);\r\n\r\n        // update interest rate\r\n        updateInterestRate(state, asset);\r\n\r\n        Events.logRepay(user, marketID, asset, repayAmount);\r\n\r\n        return repayAmount;\r\n    }\r\n\r\n    /**\r\n     * This method is called if a loan could not be paid back by the borrower, auction, or insurance,\r\n     * in which case the generalized loss is recognized across all lenders.\r\n     */\r\n    function recognizeLoss(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        uint256 totalnormalizedSupply = getTotalNormalizedSupply(\r\n            state,\r\n            asset\r\n        );\r\n\r\n        uint256 actualSupply = getTotalSupply(\r\n            state,\r\n            asset\r\n        ).sub(amount);\r\n\r\n        state.pool.supplyIndex[asset] = Decimal.divFloor(\r\n            actualSupply,\r\n            totalnormalizedSupply\r\n        );\r\n\r\n        updateIndex(state, asset);\r\n\r\n        Events.logLoss(asset, amount);\r\n    }\r\n\r\n    /**\r\n     * Claim an amount from the insurance pool, in return for all the collateral.\r\n     * Only called if an auction expired without being filled.\r\n     */\r\n    function claimInsurance(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        uint256 insuranceBalance = state.pool.insuranceBalances[asset];\r\n\r\n        uint256 compensationAmount = SafeMath.min(amount, insuranceBalance);\r\n\r\n        state.cash[asset] = state.cash[asset].add(amount);\r\n\r\n        // remove compensationAmount from insurance balances\r\n        state.pool.insuranceBalances[asset] = SafeMath.sub(\r\n            state.pool.insuranceBalances[asset],\r\n            compensationAmount\r\n        );\r\n\r\n        // all suppliers pay debt if insurance not enough\r\n        if (compensationAmount < amount) {\r\n            recognizeLoss(\r\n                state,\r\n                asset,\r\n                amount.sub(compensationAmount)\r\n            );\r\n        }\r\n\r\n        Events.logInsuranceCompensation(\r\n            asset,\r\n            compensationAmount\r\n        );\r\n\r\n    }\r\n\r\n    function updateInterestRate(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        private\r\n    {\r\n        (uint256 borrowInterestRate, uint256 supplyInterestRate) = getInterestRates(state, asset, 0);\r\n        state.pool.borrowAnnualInterestRate[asset] = borrowInterestRate;\r\n        state.pool.supplyAnnualInterestRate[asset] = supplyInterestRate;\r\n    }\r\n\r\n    // get interestRate\r\n    function getInterestRates(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 extraBorrowAmount\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256 borrowInterestRate, uint256 supplyInterestRate)\r\n    {\r\n        (uint256 currentSupplyIndex, uint256 currentBorrowIndex) = getCurrentIndex(state, asset);\r\n\r\n        uint256 _supply = getTotalSupplyWithIndex(state, asset, currentSupplyIndex);\r\n\r\n        if (_supply == 0) {\r\n            return (0, 0);\r\n        }\r\n\r\n        uint256 _borrow = getTotalBorrowWithIndex(state, asset, currentBorrowIndex).add(extraBorrowAmount);\r\n\r\n        uint256 borrowRatio = _borrow.mul(Decimal.one()).div(_supply);\r\n\r\n        borrowInterestRate = AssemblyCall.getBorrowInterestRate(\r\n            address(state.assets[asset].interestModel),\r\n            borrowRatio\r\n        );\r\n        require(borrowInterestRate <= 3 * Decimal.one(), \"BORROW_INTEREST_RATE_EXCEED_300%\");\r\n\r\n        uint256 borrowInterest = Decimal.mulCeil(_borrow, borrowInterestRate);\r\n        uint256 supplyInterest = Decimal.mulFloor(borrowInterest, Decimal.one().sub(state.pool.insuranceRatio));\r\n\r\n        supplyInterestRate = Decimal.divFloor(supplyInterest, _supply);\r\n    }\r\n\r\n    /**\r\n     * update the index value\r\n     */\r\n    function updateIndex(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        private\r\n    {\r\n        if (state.pool.indexStartTime[asset] == block.timestamp) {\r\n            return;\r\n        }\r\n\r\n        (uint256 currentSupplyIndex, uint256 currentBorrowIndex) = getCurrentIndex(state, asset);\r\n\r\n        // get the total equity value\r\n        uint256 normalizedBorrow = state.pool.normalizedTotalBorrow[asset];\r\n        uint256 normalizedSupply = getTotalNormalizedSupply(state, asset);\r\n\r\n        // interest = equity value * (current index value - starting index value)\r\n        uint256 recentBorrowInterest = Decimal.mulCeil(\r\n            normalizedBorrow,\r\n            currentBorrowIndex.sub(state.pool.borrowIndex[asset])\r\n        );\r\n\r\n        uint256 recentSupplyInterest = Decimal.mulFloor(\r\n            normalizedSupply,\r\n            currentSupplyIndex.sub(state.pool.supplyIndex[asset])\r\n        );\r\n\r\n        // the interest rate spread goes into the insurance pool\r\n        state.pool.insuranceBalances[asset] = state.pool.insuranceBalances[asset].add(recentBorrowInterest.sub(recentSupplyInterest));\r\n\r\n        // update the indexes\r\n        Events.logUpdateIndex(\r\n            asset,\r\n            state.pool.borrowIndex[asset],\r\n            currentBorrowIndex,\r\n            state.pool.supplyIndex[asset],\r\n            currentSupplyIndex\r\n        );\r\n\r\n        state.pool.supplyIndex[asset] = currentSupplyIndex;\r\n        state.pool.borrowIndex[asset] = currentBorrowIndex;\r\n        state.pool.indexStartTime[asset] = block.timestamp;\r\n\r\n    }\r\n\r\n    function getAmountSupplied(\r\n        Store.State storage state,\r\n        address asset,\r\n        address user\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        (uint256 currentSupplyIndex, ) = getCurrentIndex(state, asset);\r\n        return Decimal.mulFloor(getNormalizedSupplyOf(state, asset, user), currentSupplyIndex);\r\n    }\r\n\r\n    function getAmountBorrowed(\r\n        Store.State storage state,\r\n        address asset,\r\n        address user,\r\n        uint16 marketID\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // the actual amount borrowed = normalizedAmount * poolIndex\r\n        (, uint256 currentBorrowIndex) = getCurrentIndex(state, asset);\r\n        return Decimal.mulCeil(state.pool.normalizedBorrow[user][marketID][asset], currentBorrowIndex);\r\n    }\r\n\r\n    function getTotalSupply(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        (uint256 currentSupplyIndex, ) = getCurrentIndex(state, asset);\r\n        return getTotalSupplyWithIndex(state, asset, currentSupplyIndex);\r\n    }\r\n\r\n    function getTotalBorrow(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        (, uint256 currentBorrowIndex) = getCurrentIndex(state, asset);\r\n        return getTotalBorrowWithIndex(state, asset, currentBorrowIndex);\r\n    }\r\n\r\n    function getTotalSupplyWithIndex(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 currentSupplyIndex\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return Decimal.mulFloor(getTotalNormalizedSupply(state, asset), currentSupplyIndex);\r\n    }\r\n\r\n    function getTotalBorrowWithIndex(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 currentBorrowIndex\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return Decimal.mulCeil(state.pool.normalizedTotalBorrow[asset], currentBorrowIndex);\r\n    }\r\n\r\n    /**\r\n     * Compute the current value of poolIndex based on the time elapsed and the interest rate\r\n     */\r\n    function getCurrentIndex(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256 currentSupplyIndex, uint256 currentBorrowIndex)\r\n    {\r\n        uint256 timeDelta = block.timestamp.sub(state.pool.indexStartTime[asset]);\r\n\r\n        uint256 borrowInterestRate = state.pool.borrowAnnualInterestRate[asset]\r\n            .mul(timeDelta).divCeil(SECONDS_OF_YEAR); // Ceil Ensure asset greater than liability\r\n\r\n        uint256 supplyInterestRate = state.pool.supplyAnnualInterestRate[asset]\r\n            .mul(timeDelta).div(SECONDS_OF_YEAR);\r\n\r\n        currentBorrowIndex = Decimal.mulCeil(state.pool.borrowIndex[asset], Decimal.onePlus(borrowInterestRate));\r\n        currentSupplyIndex = Decimal.mulFloor(state.pool.supplyIndex[asset], Decimal.onePlus(supplyInterestRate));\r\n\r\n        return (currentSupplyIndex, currentBorrowIndex);\r\n    }\r\n\r\n    function getNormalizedSupplyOf(\r\n        Store.State storage state,\r\n        address asset,\r\n        address user\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return state.assets[asset].lendingPoolToken.balanceOf(user);\r\n    }\r\n\r\n    function getTotalNormalizedSupply(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return state.assets[asset].lendingPoolToken.totalSupply();\r\n    }\r\n}\r\n\r\ncontract StandardToken {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param amount The amount to be transferred.\r\n    */\r\n    function transfer(\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\r\n        require(amount <= balances[msg.sender], \"BALANCE_NOT_ENOUGH\");\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(amount);\r\n        balances[to] = balances[to].add(amount);\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param from address The address which you want to send tokens from\r\n    * @param to address The address which you want to transfer to\r\n    * @param amount uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\r\n        require(amount <= balances[from], \"BALANCE_NOT_ENOUGH\");\r\n        require(amount <= allowed[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\r\n\r\n        balances[from] = balances[from].sub(amount);\r\n        balances[to] = balances[to].add(amount);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * @param spender The address which will spend the funds.\r\n    * @param amount The amount of tokens to be spent.\r\n    */\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param owner address The address which owns the funds.\r\n    * @param spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[owner][spender];\r\n    }\r\n}\r\n\r\ninterface IInterestModel {\r\n    function polynomialInterestModel(\r\n        uint256 borrowRatio\r\n    )\r\n        external\r\n        pure\r\n        returns(uint256);\r\n}\r\n\r\ninterface ILendingPoolToken {\r\n    function mint(\r\n        address user,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n    function burn(\r\n        address user,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n    function balanceOf(\r\n        address user\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function totalSupply()\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface IPriceOracle {\r\n    /** return USD price of token */\r\n    function getPrice(\r\n        address asset\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface IStandardToken {\r\n    function transfer(\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function balanceOf(\r\n        address _owner)\r\n        external\r\n        view\r\n        returns (uint256 balance);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\nlibrary AssemblyCall {\r\n    function getAssetPriceFromPriceOracle(\r\n        address oracleAddress,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // saves about 1200 gas.\r\n        // return state.assets[asset].priceOracle.getPrice(asset);\r\n\r\n        // keccak256('getPrice(address)') & 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\r\n        bytes32 functionSelector = 0x41976e0900000000000000000000000000000000000000000000000000000000;\r\n\r\n        (uint256 result, bool success) = callWith32BytesReturnsUint256(\r\n            oracleAddress,\r\n            functionSelector,\r\n            bytes32(uint256(uint160(asset)))\r\n        );\r\n\r\n        if (!success) {\r\n            revert(\"ASSEMBLY_CALL_GET_ASSET_PRICE_FAILED\");\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the HOT token balance of an address.\r\n     *\r\n     * @param owner The address to check.\r\n     * @return The HOT balance for the owner address.\r\n     */\r\n    function getHotBalance(\r\n        address hotToken,\r\n        address owner\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // saves about 1200 gas.\r\n        // return HydroToken(hotToken).balanceOf(owner);\r\n\r\n        // keccak256('balanceOf(address)') bitmasked to 4 bytes\r\n        bytes32 functionSelector = 0x70a0823100000000000000000000000000000000000000000000000000000000;\r\n\r\n        (uint256 result, bool success) = callWith32BytesReturnsUint256(\r\n            hotToken,\r\n            functionSelector,\r\n            bytes32(uint256(uint160(owner)))\r\n        );\r\n\r\n        if (!success) {\r\n            revert(\"ASSEMBLY_CALL_GET_HOT_BALANCE_FAILED\");\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function getBorrowInterestRate(\r\n        address interestModel,\r\n        uint256 borrowRatio\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // saves about 1200 gas.\r\n        // return IInterestModel(interestModel).polynomialInterestModel(borrowRatio);\r\n\r\n        // keccak256('polynomialInterestModel(uint256)') & 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\r\n        bytes32 functionSelector = 0x69e8a15f00000000000000000000000000000000000000000000000000000000;\r\n\r\n        (uint256 result, bool success) = callWith32BytesReturnsUint256(\r\n            interestModel,\r\n            functionSelector,\r\n            bytes32(borrowRatio)\r\n        );\r\n\r\n        if (!success) {\r\n            revert(\"ASSEMBLY_CALL_GET_BORROW_INTEREST_RATE_FAILED\");\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function callWith32BytesReturnsUint256(\r\n        address to,\r\n        bytes32 functionSelector,\r\n        bytes32 param1\r\n    )\r\n        private\r\n        view\r\n        returns (uint256 result, bool success)\r\n    {\r\n        assembly {\r\n            let freePtr := mload(0x40)\r\n            let tmp1 := mload(freePtr)\r\n            let tmp2 := mload(add(freePtr, 4))\r\n\r\n            mstore(freePtr, functionSelector)\r\n            mstore(add(freePtr, 4), param1)\r\n\r\n            // call ERC20 Token contract transfer function\r\n            success := staticcall(\r\n                gas,           // Forward all gas\r\n                to,            // Interest Model Address\r\n                freePtr,       // Pointer to start of calldata\r\n                36,            // Length of calldata\r\n                freePtr,       // Overwrite calldata with output\r\n                32             // Expecting uint256 output\r\n            )\r\n\r\n            result := mload(freePtr)\r\n\r\n            mstore(freePtr, tmp1)\r\n            mstore(add(freePtr, 4), tmp2)\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Consts {\r\n    function ETHEREUM_TOKEN_ADDRESS()\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        return 0x000000000000000000000000000000000000000E;\r\n    }\r\n\r\n    // The base discounted rate is 100% of the current rate, or no discount.\r\n    function DISCOUNT_RATE_BASE()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 100;\r\n    }\r\n\r\n    function REBATE_RATE_BASE()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 100;\r\n    }\r\n}\r\n\r\nlibrary Decimal {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant BASE = 10**18;\r\n\r\n    function one()\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return BASE;\r\n    }\r\n\r\n    function onePlus(\r\n        uint256 d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return d.add(BASE);\r\n    }\r\n\r\n    function mulFloor(\r\n        uint256 target,\r\n        uint256 d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(d) / BASE;\r\n    }\r\n\r\n    function mulCeil(\r\n        uint256 target,\r\n        uint256 d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(d).divCeil(BASE);\r\n    }\r\n\r\n    function divFloor(\r\n        uint256 target,\r\n        uint256 d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(BASE).div(d);\r\n    }\r\n\r\n    function divCeil(\r\n        uint256 target,\r\n        uint256 d\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return target.mul(BASE).divCeil(d);\r\n    }\r\n}\r\n\r\nlibrary EIP712 {\r\n    string private constant DOMAIN_NAME = \"Hydro Protocol\";\r\n\r\n    /**\r\n     * Hash of the EIP712 Domain Separator Schema\r\n     */\r\n    bytes32 private constant EIP712_DOMAIN_TYPEHASH = keccak256(\r\n        abi.encodePacked(\"EIP712Domain(string name)\")\r\n    );\r\n\r\n    bytes32 private constant DOMAIN_SEPARATOR = keccak256(\r\n        abi.encodePacked(\r\n            EIP712_DOMAIN_TYPEHASH,\r\n            keccak256(bytes(DOMAIN_NAME))\r\n        )\r\n    );\r\n\r\n    /**\r\n     * Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\r\n     *\r\n     * @param eip712hash The EIP712 hash struct.\r\n     * @return EIP712 hash applied to this EIP712 Domain.\r\n     */\r\n    function hashMessage(\r\n        bytes32 eip712hash\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, eip712hash));\r\n    }\r\n}\r\n\r\nlibrary Events {\r\n    //////////////////\r\n    // Funds moving //\r\n    //////////////////\r\n\r\n    // some assets move into contract\r\n    event Deposit(\r\n        address indexed user,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logDeposit(\r\n        address user,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit Deposit(\r\n            user,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    // some assets move out of contract\r\n    event Withdraw(\r\n        address indexed user,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logWithdraw(\r\n        address user,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit Withdraw(\r\n            user,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    // transfer from balance to collateral account\r\n    event IncreaseCollateral (\r\n        address indexed user,\r\n        uint16 indexed marketID,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logIncreaseCollateral(\r\n        address user,\r\n        uint16 marketID,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit IncreaseCollateral(\r\n            user,\r\n            marketID,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    // transfer from collateral account to balance\r\n    event DecreaseCollateral (\r\n        address indexed user,\r\n        uint16 indexed marketID,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logDecreaseCollateral(\r\n        address user,\r\n        uint16 marketID,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit DecreaseCollateral(\r\n            user,\r\n            marketID,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    //////////////////\r\n    // Lending Pool //\r\n    //////////////////\r\n\r\n    event UpdateIndex(\r\n        address indexed asset,\r\n        uint256 oldBorrowIndex,\r\n        uint256 newBorrowIndex,\r\n        uint256 oldSupplyIndex,\r\n        uint256 newSupplyIndex\r\n    );\r\n\r\n    function logUpdateIndex(\r\n        address asset,\r\n        uint256 oldBorrowIndex,\r\n        uint256 newBorrowIndex,\r\n        uint256 oldSupplyIndex,\r\n        uint256 newSupplyIndex\r\n    )\r\n        internal\r\n    {\r\n        emit UpdateIndex(\r\n            asset,\r\n            oldBorrowIndex,\r\n            newBorrowIndex,\r\n            oldSupplyIndex,\r\n            newSupplyIndex\r\n        );\r\n    }\r\n\r\n    event Borrow(\r\n        address indexed user,\r\n        uint16 indexed marketID,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logBorrow(\r\n        address user,\r\n        uint16 marketID,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit Borrow(\r\n            user,\r\n            marketID,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    event Repay(\r\n        address indexed user,\r\n        uint16 indexed marketID,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logRepay(\r\n        address user,\r\n        uint16 marketID,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit Repay(\r\n            user,\r\n            marketID,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    event Supply(\r\n        address indexed user,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logSupply(\r\n        address user,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit Supply(\r\n            user,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    event Unsupply(\r\n        address indexed user,\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logUnsupply(\r\n        address user,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit Unsupply(\r\n            user,\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    event Loss(\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logLoss(\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit Loss(\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    event InsuranceCompensation(\r\n        address indexed asset,\r\n        uint256 amount\r\n    );\r\n\r\n    function logInsuranceCompensation(\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        emit InsuranceCompensation(\r\n            asset,\r\n            amount\r\n        );\r\n    }\r\n\r\n    ///////////////////\r\n    // Admin Actions //\r\n    ///////////////////\r\n\r\n    event CreateMarket(Types.Market market);\r\n\r\n    function logCreateMarket(\r\n        Types.Market memory market\r\n    )\r\n        internal\r\n    {\r\n        emit CreateMarket(market);\r\n    }\r\n\r\n    event UpdateMarket(\r\n        uint16 indexed marketID,\r\n        uint256 newAuctionRatioStart,\r\n        uint256 newAuctionRatioPerBlock,\r\n        uint256 newLiquidateRate,\r\n        uint256 newWithdrawRate\r\n    );\r\n\r\n    function logUpdateMarket(\r\n        uint16 marketID,\r\n        uint256 newAuctionRatioStart,\r\n        uint256 newAuctionRatioPerBlock,\r\n        uint256 newLiquidateRate,\r\n        uint256 newWithdrawRate\r\n    )\r\n        internal\r\n    {\r\n        emit UpdateMarket(\r\n            marketID,\r\n            newAuctionRatioStart,\r\n            newAuctionRatioPerBlock,\r\n            newLiquidateRate,\r\n            newWithdrawRate\r\n        );\r\n    }\r\n\r\n    event MarketBorrowDisable(\r\n        uint16 indexed marketID\r\n    );\r\n\r\n    function logMarketBorrowDisable(\r\n        uint16 marketID\r\n    )\r\n        internal\r\n    {\r\n        emit MarketBorrowDisable(\r\n            marketID\r\n        );\r\n    }\r\n\r\n    event MarketBorrowEnable(\r\n        uint16 indexed marketID\r\n    );\r\n\r\n    function logMarketBorrowEnable(\r\n        uint16 marketID\r\n    )\r\n        internal\r\n    {\r\n        emit MarketBorrowEnable(\r\n            marketID\r\n        );\r\n    }\r\n\r\n    event UpdateDiscountConfig(bytes32 newConfig);\r\n\r\n    function logUpdateDiscountConfig(\r\n        bytes32 newConfig\r\n    )\r\n        internal\r\n    {\r\n        emit UpdateDiscountConfig(newConfig);\r\n    }\r\n\r\n    event CreateAsset(\r\n        address asset,\r\n        address oracleAddress,\r\n        address poolTokenAddress,\r\n        address interestModelAddress\r\n    );\r\n\r\n    function logCreateAsset(\r\n        address asset,\r\n        address oracleAddress,\r\n        address poolTokenAddress,\r\n        address interestModelAddress\r\n    )\r\n        internal\r\n    {\r\n        emit CreateAsset(\r\n            asset,\r\n            oracleAddress,\r\n            poolTokenAddress,\r\n            interestModelAddress\r\n        );\r\n    }\r\n\r\n    event UpdateAsset(\r\n        address indexed asset,\r\n        address oracleAddress,\r\n        address interestModelAddress\r\n    );\r\n\r\n    function logUpdateAsset(\r\n        address asset,\r\n        address oracleAddress,\r\n        address interestModelAddress\r\n    )\r\n        internal\r\n    {\r\n        emit UpdateAsset(\r\n            asset,\r\n            oracleAddress,\r\n            interestModelAddress\r\n        );\r\n    }\r\n\r\n    event UpdateAuctionInitiatorRewardRatio(\r\n        uint256 newInitiatorRewardRatio\r\n    );\r\n\r\n    function logUpdateAuctionInitiatorRewardRatio(\r\n        uint256 newInitiatorRewardRatio\r\n    )\r\n        internal\r\n    {\r\n        emit UpdateAuctionInitiatorRewardRatio(\r\n            newInitiatorRewardRatio\r\n        );\r\n    }\r\n\r\n    event UpdateInsuranceRatio(\r\n        uint256 newInsuranceRatio\r\n    );\r\n\r\n    function logUpdateInsuranceRatio(\r\n        uint256 newInsuranceRatio\r\n    )\r\n        internal\r\n    {\r\n        emit UpdateInsuranceRatio(newInsuranceRatio);\r\n    }\r\n\r\n    /////////////\r\n    // Auction //\r\n    /////////////\r\n\r\n    event Liquidate(\r\n        address indexed user,\r\n        uint16 indexed marketID,\r\n        bool indexed hasAuction\r\n    );\r\n\r\n    function logLiquidate(\r\n        address user,\r\n        uint16 marketID,\r\n        bool hasAuction\r\n    )\r\n        internal\r\n    {\r\n        emit Liquidate(\r\n            user,\r\n            marketID,\r\n            hasAuction\r\n        );\r\n    }\r\n\r\n    // an auction is created\r\n    event AuctionCreate(\r\n        uint256 auctionID\r\n    );\r\n\r\n    function logAuctionCreate(\r\n        uint256 auctionID\r\n    )\r\n        internal\r\n    {\r\n        emit AuctionCreate(auctionID);\r\n    }\r\n\r\n    // a user filled an acution\r\n    event FillAuction(\r\n        uint256 indexed auctionID,\r\n        address bidder,\r\n        uint256 repayDebt,\r\n        uint256 bidderRepayDebt,\r\n        uint256 bidderCollateral,\r\n        uint256 leftDebt\r\n    );\r\n\r\n    function logFillAuction(\r\n        uint256 auctionID,\r\n        address bidder,\r\n        uint256 repayDebt,\r\n        uint256 bidderRepayDebt,\r\n        uint256 bidderCollateral,\r\n        uint256 leftDebt\r\n    )\r\n        internal\r\n    {\r\n        emit FillAuction(\r\n            auctionID,\r\n            bidder,\r\n            repayDebt,\r\n            bidderRepayDebt,\r\n            bidderCollateral,\r\n            leftDebt\r\n        );\r\n    }\r\n\r\n    /////////////\r\n    // Relayer //\r\n    /////////////\r\n\r\n    event RelayerApproveDelegate(\r\n        address indexed relayer,\r\n        address indexed delegate\r\n    );\r\n\r\n    function logRelayerApproveDelegate(\r\n        address relayer,\r\n        address delegate\r\n    )\r\n        internal\r\n    {\r\n        emit RelayerApproveDelegate(\r\n            relayer,\r\n            delegate\r\n        );\r\n    }\r\n\r\n    event RelayerRevokeDelegate(\r\n        address indexed relayer,\r\n        address indexed delegate\r\n    );\r\n\r\n    function logRelayerRevokeDelegate(\r\n        address relayer,\r\n        address delegate\r\n    )\r\n        internal\r\n    {\r\n        emit RelayerRevokeDelegate(\r\n            relayer,\r\n            delegate\r\n        );\r\n    }\r\n\r\n    event RelayerExit(\r\n        address indexed relayer\r\n    );\r\n\r\n    function logRelayerExit(\r\n        address relayer\r\n    )\r\n        internal\r\n    {\r\n        emit RelayerExit(relayer);\r\n    }\r\n\r\n    event RelayerJoin(\r\n        address indexed relayer\r\n    );\r\n\r\n    function logRelayerJoin(\r\n        address relayer\r\n    )\r\n        internal\r\n    {\r\n        emit RelayerJoin(relayer);\r\n    }\r\n\r\n    //////////////\r\n    // Exchange //\r\n    //////////////\r\n\r\n    event Match(\r\n        Types.OrderAddressSet addressSet,\r\n        address maker,\r\n        address taker,\r\n        address buyer,\r\n        uint256 makerFee,\r\n        uint256 makerRebate,\r\n        uint256 takerFee,\r\n        uint256 makerGasFee,\r\n        uint256 takerGasFee,\r\n        uint256 baseAssetFilledAmount,\r\n        uint256 quoteAssetFilledAmount\r\n\r\n    );\r\n\r\n    function logMatch(\r\n        Types.MatchResult memory result,\r\n        Types.OrderAddressSet memory addressSet\r\n    )\r\n        internal\r\n    {\r\n        emit Match(\r\n            addressSet,\r\n            result.maker,\r\n            result.taker,\r\n            result.buyer,\r\n            result.makerFee,\r\n            result.makerRebate,\r\n            result.takerFee,\r\n            result.makerGasFee,\r\n            result.takerGasFee,\r\n            result.baseAssetFilledAmount,\r\n            result.quoteAssetFilledAmount\r\n        );\r\n    }\r\n\r\n    event OrderCancel(\r\n        bytes32 indexed orderHash\r\n    );\r\n\r\n    function logOrderCancel(\r\n        bytes32 orderHash\r\n    )\r\n        internal\r\n    {\r\n        emit OrderCancel(orderHash);\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /** @dev The Ownable constructor sets the original `owner` of the contract to the sender account. */\r\n    constructor()\r\n        internal\r\n    {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /** @return the address of the owner. */\r\n    function owner()\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        return _owner;\r\n    }\r\n\r\n    /** @dev Throws if called by any account other than the owner. */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    /** @return true if `msg.sender` is the owner of the contract. */\r\n    function isOwner()\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /** @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /** @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(\r\n        address newOwner\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"INVALID_OWNER\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract LendingPoolToken is StandardToken, Ownable {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    event Mint(address indexed user, uint256 value);\r\n    event Burn(address indexed user, uint256 value);\r\n\r\n    constructor (\r\n        string memory tokenName,\r\n        string memory tokenSymbol,\r\n        uint8 tokenDecimals\r\n    )\r\n        public\r\n    {\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n        decimals = tokenDecimals;\r\n    }\r\n\r\n    function mint(\r\n        address user,\r\n        uint256 value\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        balances[user] = balances[user].add(value);\r\n        totalSupply = totalSupply.add(value);\r\n        emit Mint(user, value);\r\n    }\r\n\r\n    function burn(\r\n        address user,\r\n        uint256 value\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        balances[user] = balances[user].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Burn(user, value);\r\n    }\r\n\r\n}\r\n\r\nlibrary Requires {\r\n    function requireAssetExist(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(isAssetExist(state, asset), \"ASSET_NOT_EXIST\");\r\n    }\r\n\r\n    function requireAssetNotExist(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(!isAssetExist(state, asset), \"ASSET_ALREADY_EXIST\");\r\n    }\r\n\r\n    function requireMarketIDAndAssetMatch(\r\n        Store.State storage state,\r\n        uint16 marketID,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(\r\n            asset == state.markets[marketID].baseAsset || asset == state.markets[marketID].quoteAsset,\r\n            \"ASSET_NOT_BELONGS_TO_MARKET\"\r\n        );\r\n    }\r\n\r\n    function requireMarketNotExist(\r\n        Store.State storage state,\r\n        Types.Market memory market\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(!isMarketExist(state, market), \"MARKET_ALREADY_EXIST\");\r\n    }\r\n\r\n    function requireMarketAssetsValid(\r\n        Store.State storage state,\r\n        Types.Market memory market\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(market.baseAsset != market.quoteAsset, \"BASE_QUOTE_DUPLICATED\");\r\n        require(isAssetExist(state, market.baseAsset), \"MARKET_BASE_ASSET_NOT_EXIST\");\r\n        require(isAssetExist(state, market.quoteAsset), \"MARKET_QUOTE_ASSET_NOT_EXIST\");\r\n    }\r\n\r\n    function requireCashLessThanOrEqualContractBalance(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        if (asset == Consts.ETHEREUM_TOKEN_ADDRESS()) {\r\n            if (state.cash[asset] > 0) {\r\n                require(uint256(state.cash[asset]) <= address(this).balance, \"CONTRACT_BALANCE_NOT_ENOUGH\");\r\n            }\r\n        } else {\r\n            if (state.cash[asset] > 0) {\r\n                require(uint256(state.cash[asset]) <= IStandardToken(asset).balanceOf(address(this)), \"CONTRACT_BALANCE_NOT_ENOUGH\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function requirePriceOracleAddressValid(\r\n        address oracleAddress\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        require(oracleAddress != address(0), \"ORACLE_ADDRESS_NOT_VALID\");\r\n    }\r\n\r\n    function requireDecimalLessOrEquanThanOne(\r\n        uint256 decimal\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        require(decimal <= Decimal.one(), \"DECIMAL_GREATER_THAN_ONE\");\r\n    }\r\n\r\n    function requireDecimalGreaterThanOne(\r\n        uint256 decimal\r\n    )\r\n        internal\r\n        pure\r\n    {\r\n        require(decimal > Decimal.one(), \"DECIMAL_LESS_OR_EQUAL_THAN_ONE\");\r\n    }\r\n\r\n    function requireMarketIDExist(\r\n        Store.State storage state,\r\n        uint16 marketID\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(marketID < state.marketsCount, \"MARKET_NOT_EXIST\");\r\n    }\r\n\r\n    function requireMarketBorrowEnabled(\r\n        Store.State storage state,\r\n        uint16 marketID\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(state.markets[marketID].borrowEnable, \"MARKET_BORROW_DISABLED\");\r\n    }\r\n\r\n    function requirePathNormalStatus(\r\n        Store.State storage state,\r\n        Types.BalancePath memory path\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        if (path.category == Types.BalanceCategory.CollateralAccount) {\r\n            requireAccountNormal(state, path.marketID, path.user);\r\n        }\r\n    }\r\n\r\n    function requireAccountNormal(\r\n        Store.State storage state,\r\n        uint16 marketID,\r\n        address user\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(\r\n            state.accounts[user][marketID].status == Types.CollateralAccountStatus.Normal,\r\n            \"CAN_NOT_OPERATE_LIQUIDATING_COLLATERAL_ACCOUNT\"\r\n        );\r\n    }\r\n\r\n    function requirePathMarketIDAssetMatch(\r\n        Store.State storage state,\r\n        Types.BalancePath memory path,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        if (path.category == Types.BalanceCategory.CollateralAccount) {\r\n            requireMarketIDExist(state, path.marketID);\r\n            requireMarketIDAndAssetMatch(state, path.marketID, asset);\r\n        }\r\n    }\r\n\r\n    function requireCollateralAccountNotLiquidatable(\r\n        Store.State storage state,\r\n        Types.BalancePath memory path\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        if (path.category == Types.BalanceCategory.CollateralAccount) {\r\n            requireCollateralAccountNotLiquidatable(state, path.user, path.marketID);\r\n        }\r\n    }\r\n\r\n    function requireCollateralAccountNotLiquidatable(\r\n        Store.State storage state,\r\n        address user,\r\n        uint16 marketID\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(\r\n            !CollateralAccounts.getDetails(state, user, marketID).liquidatable,\r\n            \"COLLATERAL_ACCOUNT_LIQUIDATABLE\"\r\n        );\r\n    }\r\n\r\n    function requireAuctionNotFinished(\r\n        Store.State storage state,\r\n        uint32 auctionID\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(\r\n            state.auction.auctions[auctionID].status == Types.AuctionStatus.InProgress,\r\n            \"AUCTION_ALREADY_FINISHED\"\r\n        );\r\n    }\r\n\r\n    function requireAuctionExist(\r\n        Store.State storage state,\r\n        uint32 auctionID\r\n    )\r\n        internal\r\n        view\r\n    {\r\n        require(\r\n            auctionID < state.auction.auctionsCount,\r\n            \"AUCTION_NOT_EXIST\"\r\n        );\r\n    }\r\n\r\n    function isAssetExist(\r\n        Store.State storage state,\r\n        address asset\r\n    )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return state.assets[asset].priceOracle != IPriceOracle(address(0));\r\n    }\r\n\r\n    function isMarketExist(\r\n        Store.State storage state,\r\n        Types.Market memory market\r\n    )\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        for(uint16 i = 0; i < state.marketsCount; i++) {\r\n            if (state.markets[i].baseAsset == market.baseAsset && state.markets[i].quoteAsset == market.quoteAsset) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        bool result;\r\n\r\n        assembly {\r\n            let tmp1 := mload(0)\r\n            let tmp2 := mload(4)\r\n            let tmp3 := mload(36)\r\n\r\n            // keccak256('transfer(address,uint256)') & 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\r\n            mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n            mstore(4, to)\r\n            mstore(36, amount)\r\n\r\n            // call ERC20 Token contract transfer function\r\n            let callResult := call(gas, token, 0, 0, 68, 0, 32)\r\n            let returnValue := mload(0)\r\n\r\n            mstore(0, tmp1)\r\n            mstore(4, tmp2)\r\n            mstore(36, tmp3)\r\n\r\n            // result check\r\n            result := and (\r\n                eq(callResult, 1),\r\n                or(eq(returndatasize, 0), and(eq(returndatasize, 32), gt(returnValue, 0)))\r\n            )\r\n        }\r\n\r\n        if (!result) {\r\n            revert(\"TOKEN_TRANSFER_ERROR\");\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        bool result;\r\n\r\n        assembly {\r\n            let tmp1 := mload(0)\r\n            let tmp2 := mload(4)\r\n            let tmp3 := mload(36)\r\n            let tmp4 := mload(68)\r\n\r\n            // keccak256('transferFrom(address,address,uint256)') & 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\r\n            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n            mstore(4, from)\r\n            mstore(36, to)\r\n            mstore(68, amount)\r\n\r\n            // call ERC20 Token contract transferFrom function\r\n            let callResult := call(gas, token, 0, 0, 100, 0, 32)\r\n            let returnValue := mload(0)\r\n\r\n            mstore(0, tmp1)\r\n            mstore(4, tmp2)\r\n            mstore(36, tmp3)\r\n            mstore(68, tmp4)\r\n\r\n            // result check\r\n            result := and (\r\n                eq(callResult, 1),\r\n                or(eq(returndatasize, 0), and(eq(returndatasize, 32), gt(returnValue, 0)))\r\n            )\r\n        }\r\n\r\n        if (!result) {\r\n            revert(\"TOKEN_TRANSFER_FROM_ERROR\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    // Multiplies two numbers, reverts on overflow.\r\n    function mul(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MUL_ERROR\");\r\n\r\n        return c;\r\n    }\r\n\r\n    // Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    function div(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b > 0, \"DIVIDING_ERROR\");\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder > 0) {\r\n            return quotient + 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    // Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, \"SUB_ERROR\");\r\n        return a - b;\r\n    }\r\n\r\n    function sub(\r\n        int256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        require(b <= 2**255-1, \"INT256_SUB_ERROR\");\r\n        int256 c = a - int256(b);\r\n        require(c <= a, \"INT256_SUB_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    // Adds two numbers, reverts on overflow.\r\n    function add(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    function add(\r\n        int256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (int256)\r\n    {\r\n        require(b <= 2**255 - 1, \"INT256_ADD_ERROR\");\r\n        int256 c = a + int256(b);\r\n        require(c >= a, \"INT256_ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    // Divides two numbers and returns the remainder (unsigned integer modulo), reverts when dividing by zero.\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b != 0, \"MOD_ERROR\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * Check the amount of precision lost by calculating multiple * (numerator / denominator). To\r\n     * do this, we check the remainder and make sure it's proportionally less than 0.1%. So we have:\r\n     *\r\n     *     ((numerator * multiple) % denominator)     1\r\n     *     -------------------------------------- < ----\r\n     *              numerator * multiple            1000\r\n     *\r\n     * To avoid further division, we can move the denominators to the other sides and we get:\r\n     *\r\n     *     ((numerator * multiple) % denominator) * 1000 < numerator * multiple\r\n     *\r\n     * Since we want to return true if there IS a rounding error, we simply flip the sign and our\r\n     * final equation becomes:\r\n     *\r\n     *     ((numerator * multiple) % denominator) * 1000 >= numerator * multiple\r\n     *\r\n     * @param numerator The numerator of the proportion\r\n     * @param denominator The denominator of the proportion\r\n     * @param multiple The amount we want a proportion of\r\n     * @return Boolean indicating if there is a rounding error when calculating the proportion\r\n     */\r\n    function isRoundingError(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 multiple\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // numerator.mul(multiple).mod(denominator).mul(1000) >= numerator.mul(multiple)\r\n        return mul(mod(mul(numerator, multiple), denominator), 1000) >= mul(numerator, multiple);\r\n    }\r\n\r\n    /**\r\n     * Takes an amount (multiple) and calculates a proportion of it given a numerator/denominator\r\n     * pair of values. The final value will be rounded down to the nearest integer value.\r\n     *\r\n     * This function will revert the transaction if rounding the final value down would lose more\r\n     * than 0.1% precision.\r\n     *\r\n     * @param numerator The numerator of the proportion\r\n     * @param denominator The denominator of the proportion\r\n     * @param multiple The amount we want a proportion of\r\n     * @return The final proportion of multiple rounded down\r\n     */\r\n    function getPartialAmountFloor(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 multiple\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(!isRoundingError(numerator, denominator, multiple), \"ROUNDING_ERROR\");\r\n        // numerator.mul(multiple).div(denominator)\r\n        return div(mul(numerator, multiple), denominator);\r\n    }\r\n\r\n    /**\r\n     * Returns the smaller integer of the two passed in.\r\n     *\r\n     * @param a Unsigned integer\r\n     * @param b Unsigned integer\r\n     * @return The smaller of the two integers\r\n     */\r\n    function min(\r\n        uint256 a,\r\n        uint256 b\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\nlibrary Signature {\r\n\r\n    enum SignatureMethod {\r\n        EthSign,\r\n        EIP712\r\n    }\r\n\r\n    /**\r\n     * Validate a signature given a hash calculated from the order data, the signer, and the\r\n     * signature data passed in with the order.\r\n     *\r\n     * This function will revert the transaction if the signature method is invalid.\r\n     *\r\n     * @param hash Hash bytes calculated by taking the EIP712 hash of the passed order data\r\n     * @param signerAddress The address of the signer\r\n     * @param signature The signature data passed along with the order to validate against\r\n     * @return True if the calculated signature matches the order signature data, false otherwise.\r\n     */\r\n    function isValidSignature(\r\n        bytes32 hash,\r\n        address signerAddress,\r\n        Types.Signature memory signature\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint8 method = uint8(signature.config[1]);\r\n        address recovered;\r\n        uint8 v = uint8(signature.config[0]);\r\n\r\n        if (method == uint8(SignatureMethod.EthSign)) {\r\n            recovered = ecrecover(\r\n                keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)),\r\n                v,\r\n                signature.r,\r\n                signature.s\r\n            );\r\n        } else if (method == uint8(SignatureMethod.EIP712)) {\r\n            recovered = ecrecover(hash, v, signature.r, signature.s);\r\n        } else {\r\n            revert(\"INVALID_SIGN_METHOD\");\r\n        }\r\n\r\n        return signerAddress == recovered;\r\n    }\r\n}\r\n\r\nlibrary Store {\r\n\r\n    struct RelayerState {\r\n        /**\r\n        * Mapping of relayerAddress => delegateAddress\r\n        */\r\n        mapping (address => mapping (address => bool)) relayerDelegates;\r\n\r\n        /**\r\n        * Mapping of relayerAddress => whether relayer is opted out of the liquidity incentive system\r\n        */\r\n        mapping (address => bool) hasExited;\r\n    }\r\n\r\n    struct ExchangeState {\r\n\r\n        /**\r\n        * Calculate and return the rate at which fees will be charged for an address. The discounted\r\n        * rate depends on how much HOT token is owned by the user. Values returned will be a percentage\r\n        * used to calculate how much of the fee is paid, so a return value of 100 means there is 0\r\n        * discount, and a return value of 70 means a 30% rate reduction.\r\n        *\r\n        * The discountConfig is defined as such:\r\n        * ╔═══════════════════╤════════════════════════════════════════════╗\r\n        * ║                   │ length(bytes)   desc                       ║\r\n        * ╟───────────────────┼────────────────────────────────────────────╢\r\n        * ║ count             │ 1               the count of configs       ║\r\n        * ║ maxDiscountedRate │ 1               the max discounted rate    ║\r\n        * ║ config            │ 5 each                                     ║\r\n        * ╚═══════════════════╧════════════════════════════════════════════╝\r\n        *\r\n        * The default discount structure as defined in code would give the following result:\r\n        *\r\n        * Fee discount table\r\n        * ╔════════════════════╤══════════╗\r\n        * ║     HOT BALANCE    │ DISCOUNT ║\r\n        * ╠════════════════════╪══════════╣\r\n        * ║     0 <= x < 10000 │     0%   ║\r\n        * ╟────────────────────┼──────────╢\r\n        * ║ 10000 <= x < 20000 │    10%   ║\r\n        * ╟────────────────────┼──────────╢\r\n        * ║ 20000 <= x < 30000 │    20%   ║\r\n        * ╟────────────────────┼──────────╢\r\n        * ║ 30000 <= x < 40000 │    30%   ║\r\n        * ╟────────────────────┼──────────╢\r\n        * ║ 40000 <= x         │    40%   ║\r\n        * ╚════════════════════╧══════════╝\r\n        *\r\n        * Breaking down the bytes of 0x043c000027106400004e205a000075305000009c404600000000000000000000\r\n        *\r\n        * 0x  04           3c          0000271064  00004e205a  0000753050  00009c4046  0000000000  0000000000;\r\n        *     ~~           ~~          ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~  ~~~~~~~~~~\r\n        *      |            |               |           |           |           |           |           |\r\n        *    count  maxDiscountedRate       1           2           3           4           5           6\r\n        *\r\n        * The first config breaks down as follows:  00002710   64\r\n        *                                           ~~~~~~~~   ~~\r\n        *                                               |      |\r\n        *                                              bar    rate\r\n        *\r\n        * Meaning if a user has less than 10000 (0x00002710) HOT, they will pay 100%(0x64) of the\r\n        * standard fee.\r\n        *\r\n        */\r\n        bytes32 discountConfig;\r\n\r\n        /**\r\n        * Mapping of orderHash => amount\r\n        * Generally the amount will be specified in base token units, however in the case of a market\r\n        * buy order the amount is specified in quote token units.\r\n        */\r\n        mapping (bytes32 => uint256) filled;\r\n\r\n        /**\r\n        * Mapping of orderHash => whether order has been cancelled.\r\n        */\r\n        mapping (bytes32 => bool) cancelled;\r\n\r\n        address hotTokenAddress;\r\n    }\r\n\r\n    struct LendingPoolState {\r\n        uint256 insuranceRatio;\r\n\r\n        // insurance balances\r\n        mapping(address => uint256) insuranceBalances;\r\n\r\n        mapping (address => uint256) borrowIndex; // decimal\r\n        mapping (address => uint256) supplyIndex; // decimal\r\n        mapping (address => uint256) indexStartTime; // timestamp\r\n\r\n        mapping (address => uint256) borrowAnnualInterestRate; // decimal\r\n        mapping (address => uint256) supplyAnnualInterestRate; // decimal\r\n\r\n        // total borrow\r\n        mapping(address => uint256) normalizedTotalBorrow;\r\n\r\n        // user => marketID => balances\r\n        mapping (address => mapping (uint16 => mapping(address => uint256))) normalizedBorrow;\r\n    }\r\n\r\n    struct AuctionState {\r\n\r\n        // count of auctions\r\n        uint32 auctionsCount;\r\n\r\n        // all auctions\r\n        mapping(uint32 => Types.Auction) auctions;\r\n\r\n        // current auctions\r\n        uint32[] currentAuctions;\r\n\r\n        // auction initiator reward ratio\r\n        uint256 initiatorRewardRatio;\r\n    }\r\n\r\n    struct State {\r\n\r\n        uint16 marketsCount;\r\n\r\n        mapping(address => Types.Asset) assets;\r\n        mapping(address => int256) cash;\r\n\r\n        // user => marketID => account\r\n        mapping(address => mapping(uint16 => Types.CollateralAccount)) accounts;\r\n\r\n        // all markets\r\n        mapping(uint16 => Types.Market) markets;\r\n\r\n        // user balances\r\n        mapping(address => mapping(address => uint256)) balances;\r\n\r\n        LendingPoolState pool;\r\n\r\n        ExchangeState exchange;\r\n\r\n        RelayerState relayer;\r\n\r\n        AuctionState auction;\r\n    }\r\n}\r\n\r\nlibrary Transfer {\r\n    using SafeMath for uint256;\r\n    using SafeMath for int256;\r\n    using BalancePath for Types.BalancePath;\r\n\r\n    // Transfer asset into current contract\r\n    function deposit(\r\n        Store.State storage state,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 depositedEtherAmount = 0;\r\n\r\n        if (asset == Consts.ETHEREUM_TOKEN_ADDRESS()) {\r\n            // Since this method is able to be called in batch,\r\n            // there is a chance that a batch contains multi deposit ether calls.\r\n            // To make sure the the msg.value is equal to the total deposit ethers,\r\n            // each ether deposit function needs to return the actual deposited ether amount.\r\n            depositedEtherAmount = amount;\r\n        } else {\r\n            SafeERC20.safeTransferFrom(asset, msg.sender, address(this), amount);\r\n        }\r\n\r\n        transferIn(state, asset, BalancePath.getCommonPath(msg.sender), amount);\r\n        Events.logDeposit(msg.sender, asset, amount);\r\n\r\n        return depositedEtherAmount;\r\n    }\r\n\r\n    // Transfer asset out of current contract\r\n    function withdraw(\r\n        Store.State storage state,\r\n        address user,\r\n        address asset,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        require(state.balances[user][asset] >= amount, \"BALANCE_NOT_ENOUGH\");\r\n\r\n        if (asset == Consts.ETHEREUM_TOKEN_ADDRESS()) {\r\n            address payable payableUser = address(uint160(user));\r\n            payableUser.transfer(amount);\r\n        } else {\r\n            SafeERC20.safeTransfer(asset, user, amount);\r\n        }\r\n\r\n        transferOut(state, asset, BalancePath.getCommonPath(user), amount);\r\n\r\n        Events.logWithdraw(user, asset, amount);\r\n    }\r\n\r\n    // Get a user's asset balance\r\n    function balanceOf(\r\n        Store.State storage state,\r\n        Types.BalancePath memory balancePath,\r\n        address asset\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        mapping(address => uint256) storage balances = balancePath.getBalances(state);\r\n        return balances[asset];\r\n    }\r\n\r\n    // Move asset from a balances map to another\r\n    function transfer(\r\n        Store.State storage state,\r\n        address asset,\r\n        Types.BalancePath memory fromBalancePath,\r\n        Types.BalancePath memory toBalancePath,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n\r\n        Requires.requirePathMarketIDAssetMatch(state, fromBalancePath, asset);\r\n        Requires.requirePathMarketIDAssetMatch(state, toBalancePath, asset);\r\n\r\n        mapping(address => uint256) storage fromBalances = fromBalancePath.getBalances(state);\r\n        mapping(address => uint256) storage toBalances = toBalancePath.getBalances(state);\r\n\r\n        require(fromBalances[asset] >= amount, \"TRANSFER_BALANCE_NOT_ENOUGH\");\r\n\r\n        fromBalances[asset] = fromBalances[asset] - amount;\r\n        toBalances[asset] = toBalances[asset].add(amount);\r\n    }\r\n\r\n    function transferIn(\r\n        Store.State storage state,\r\n        address asset,\r\n        Types.BalancePath memory path,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        mapping(address => uint256) storage balances = path.getBalances(state);\r\n        balances[asset] = balances[asset].add(amount);\r\n        state.cash[asset] = state.cash[asset].add(amount);\r\n    }\r\n\r\n    function transferOut(\r\n        Store.State storage state,\r\n        address asset,\r\n        Types.BalancePath memory path,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        mapping(address => uint256) storage balances = path.getBalances(state);\r\n        balances[asset] = balances[asset].sub(amount);\r\n        state.cash[asset] = state.cash[asset].sub(amount);\r\n    }\r\n}\r\n\r\nlibrary Types {\r\n    enum AuctionStatus {\r\n        InProgress,\r\n        Finished\r\n    }\r\n\r\n    enum CollateralAccountStatus {\r\n        Normal,\r\n        Liquid\r\n    }\r\n\r\n    enum OrderStatus {\r\n        EXPIRED,\r\n        CANCELLED,\r\n        FILLABLE,\r\n        FULLY_FILLED\r\n    }\r\n\r\n    /**\r\n     * Signature struct contains typical signature data as v, r, and s with the signature\r\n     * method encoded in as well.\r\n     */\r\n    struct Signature {\r\n        /**\r\n         * Config contains the following values packed into 32 bytes\r\n         * ╔════════════════════╤═══════════════════════════════════════════════════════════╗\r\n         * ║                    │ length(bytes)   desc                                      ║\r\n         * ╟────────────────────┼───────────────────────────────────────────────────────────╢\r\n         * ║ v                  │ 1               the v parameter of a signature            ║\r\n         * ║ signatureMethod    │ 1               SignatureMethod enum value                ║\r\n         * ╚════════════════════╧═══════════════════════════════════════════════════════════╝\r\n         */\r\n        bytes32 config;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    enum BalanceCategory {\r\n        Common,\r\n        CollateralAccount\r\n    }\r\n\r\n    struct BalancePath {\r\n        BalanceCategory category;\r\n        uint16          marketID;\r\n        address         user;\r\n    }\r\n\r\n    struct Asset {\r\n        ILendingPoolToken  lendingPoolToken;\r\n        IPriceOracle      priceOracle;\r\n        IInterestModel    interestModel;\r\n    }\r\n\r\n    struct Market {\r\n        address baseAsset;\r\n        address quoteAsset;\r\n\r\n        // If the collateralRate is below this rate, the account will be liquidated\r\n        uint256 liquidateRate;\r\n\r\n        // If the collateralRate is above this rate, the account asset balance can be withdrawed\r\n        uint256 withdrawRate;\r\n\r\n        uint256 auctionRatioStart;\r\n        uint256 auctionRatioPerBlock;\r\n\r\n        bool borrowEnable;\r\n    }\r\n\r\n    struct CollateralAccount {\r\n        uint32 id;\r\n        uint16 marketID;\r\n        CollateralAccountStatus status;\r\n        address owner;\r\n\r\n        mapping(address => uint256) balances;\r\n    }\r\n\r\n    // memory only\r\n    struct CollateralAccountDetails {\r\n        bool       liquidatable;\r\n        CollateralAccountStatus status;\r\n        uint256    debtsTotalUSDValue;\r\n        uint256    balancesTotalUSDValue;\r\n    }\r\n\r\n    struct Auction {\r\n        uint32 id;\r\n        AuctionStatus status;\r\n\r\n        // To calculate the ratio\r\n        uint32 startBlockNumber;\r\n\r\n        uint16 marketID;\r\n\r\n        address borrower;\r\n        address initiator;\r\n\r\n        address debtAsset;\r\n        address collateralAsset;\r\n    }\r\n\r\n    struct AuctionDetails {\r\n        address borrower;\r\n        uint16  marketID;\r\n        address debtAsset;\r\n        address collateralAsset;\r\n        uint256 leftDebtAmount;\r\n        uint256 leftCollateralAmount;\r\n        uint256 ratio;\r\n        uint256 price;\r\n        bool    finished;\r\n    }\r\n\r\n    struct Order {\r\n        address trader;\r\n        address relayer;\r\n        address baseAsset;\r\n        address quoteAsset;\r\n        uint256 baseAssetAmount;\r\n        uint256 quoteAssetAmount;\r\n        uint256 gasTokenAmount;\r\n\r\n        /**\r\n         * Data contains the following values packed into 32 bytes\r\n         * ╔════════════════════╤═══════════════════════════════════════════════════════════╗\r\n         * ║                    │ length(bytes)   desc                                      ║\r\n         * ╟────────────────────┼───────────────────────────────────────────────────────────╢\r\n         * ║ version            │ 1               order version                             ║\r\n         * ║ side               │ 1               0: buy, 1: sell                           ║\r\n         * ║ isMarketOrder      │ 1               0: limitOrder, 1: marketOrder             ║\r\n         * ║ expiredAt          │ 5               order expiration time in seconds          ║\r\n         * ║ asMakerFeeRate     │ 2               maker fee rate (base 100,000)             ║\r\n         * ║ asTakerFeeRate     │ 2               taker fee rate (base 100,000)             ║\r\n         * ║ makerRebateRate    │ 2               rebate rate for maker (base 100)          ║\r\n         * ║ salt               │ 8               salt                                      ║\r\n         * ║ isMakerOnly        │ 1               is maker only                             ║\r\n         * ║ balancesType       │ 1               0: common, 1: collateralAccount           ║\r\n         * ║ marketID           │ 2               marketID                                  ║\r\n         * ║                    │ 6               reserved                                  ║\r\n         * ╚════════════════════╧═══════════════════════════════════════════════════════════╝\r\n         */\r\n        bytes32 data;\r\n    }\r\n\r\n        /**\r\n     * When orders are being matched, they will always contain the exact same base token,\r\n     * quote token, and relayer. Since excessive call data is very expensive, we choose\r\n     * to create a stripped down OrderParam struct containing only data that may vary between\r\n     * Order objects, and separate out the common elements into a set of addresses that will\r\n     * be shared among all of the OrderParam items. This is meant to eliminate redundancy in\r\n     * the call data, reducing it's size, and hence saving gas.\r\n     */\r\n    struct OrderParam {\r\n        address trader;\r\n        uint256 baseAssetAmount;\r\n        uint256 quoteAssetAmount;\r\n        uint256 gasTokenAmount;\r\n        bytes32 data;\r\n        Signature signature;\r\n    }\r\n\r\n\r\n    struct OrderAddressSet {\r\n        address baseAsset;\r\n        address quoteAsset;\r\n        address relayer;\r\n    }\r\n\r\n    struct MatchResult {\r\n        address maker;\r\n        address taker;\r\n        address buyer;\r\n        uint256 makerFee;\r\n        uint256 makerRebate;\r\n        uint256 takerFee;\r\n        uint256 makerGasFee;\r\n        uint256 takerGasFee;\r\n        uint256 baseAssetFilledAmount;\r\n        uint256 quoteAssetFilledAmount;\r\n        BalancePath makerBalancePath;\r\n        BalancePath takerBalancePath;\r\n    }\r\n    /**\r\n     * @param takerOrderParam A Types.OrderParam object representing the order from the taker.\r\n     * @param makerOrderParams An array of Types.OrderParam objects representing orders from a list of makers.\r\n     * @param orderAddressSet An object containing addresses common across each order.\r\n     */\r\n    struct MatchParams {\r\n        OrderParam       takerOrderParam;\r\n        OrderParam[]     makerOrderParams;\r\n        uint256[]        baseAssetFilledAmounts;\r\n        OrderAddressSet  orderAddressSet;\r\n    }\r\n}\r\n\r\nlibrary Auction {\r\n    using SafeMath for uint256;\r\n\r\n    function ratio(\r\n        Types.Auction memory auction,\r\n        Store.State storage state\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 increasedRatio = (block.number - auction.startBlockNumber).mul(state.markets[auction.marketID].auctionRatioPerBlock);\r\n        uint256 initRatio = state.markets[auction.marketID].auctionRatioStart;\r\n        uint256 totalRatio = initRatio.add(increasedRatio);\r\n        return totalRatio;\r\n    }\r\n}\r\n\r\nlibrary BalancePath {\r\n\r\n    function getBalances(\r\n        Types.BalancePath memory path,\r\n        Store.State storage state\r\n    )\r\n        internal\r\n        view\r\n        returns (mapping(address => uint256) storage)\r\n    {\r\n        if (path.category == Types.BalanceCategory.Common) {\r\n            return state.balances[path.user];\r\n        } else {\r\n            return state.accounts[path.user][path.marketID].balances;\r\n        }\r\n    }\r\n\r\n    function getCommonPath(\r\n        address user\r\n    )\r\n        internal\r\n        pure\r\n        returns (Types.BalancePath memory)\r\n    {\r\n        return Types.BalancePath({\r\n            user: user,\r\n            category: Types.BalanceCategory.Common,\r\n            marketID: 0\r\n        });\r\n    }\r\n\r\n    function getMarketPath(\r\n        address user,\r\n        uint16 marketID\r\n    )\r\n        internal\r\n        pure\r\n        returns (Types.BalancePath memory)\r\n    {\r\n        return Types.BalancePath({\r\n            user: user,\r\n            category: Types.BalanceCategory.CollateralAccount,\r\n            marketID: marketID\r\n        });\r\n    }\r\n}\r\n\r\nlibrary Order {\r\n\r\n    bytes32 public constant EIP712_ORDER_TYPE = keccak256(\r\n        abi.encodePacked(\r\n            \"Order(address trader,address relayer,address baseAsset,address quoteAsset,uint256 baseAssetAmount,uint256 quoteAssetAmount,uint256 gasTokenAmount,bytes32 data)\"\r\n        )\r\n    );\r\n\r\n    /**\r\n     * Calculates the Keccak-256 EIP712 hash of the order using the Hydro Protocol domain.\r\n     *\r\n     * @param order The order data struct.\r\n     * @return Fully qualified EIP712 hash of the order in the Hydro Protocol domain.\r\n     */\r\n    function getHash(\r\n        Types.Order memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32 orderHash)\r\n    {\r\n        orderHash = EIP712.hashMessage(_hashContent(order));\r\n        return orderHash;\r\n    }\r\n\r\n    /**\r\n     * Calculates the EIP712 hash of the order.\r\n     *\r\n     * @param order The order data struct.\r\n     * @return Hash of the order.\r\n     */\r\n    function _hashContent(\r\n        Types.Order memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes32 result)\r\n    {\r\n        /**\r\n         * Calculate the following hash in solidity assembly to save gas.\r\n         *\r\n         * keccak256(\r\n         *     abi.encodePacked(\r\n         *         EIP712_ORDER_TYPE,\r\n         *         bytes32(order.trader),\r\n         *         bytes32(order.relayer),\r\n         *         bytes32(order.baseAsset),\r\n         *         bytes32(order.quoteAsset),\r\n         *         order.baseAssetAmount,\r\n         *         order.quoteAssetAmount,\r\n         *         order.gasTokenAmount,\r\n         *         order.data\r\n         *     )\r\n         * );\r\n         */\r\n\r\n        bytes32 orderType = EIP712_ORDER_TYPE;\r\n\r\n        assembly {\r\n            let start := sub(order, 32)\r\n            let tmp := mload(start)\r\n\r\n            // 288 = (1 + 8) * 32\r\n            //\r\n            // [0...32)   bytes: EIP712_ORDER_TYPE\r\n            // [32...288) bytes: order\r\n            mstore(start, orderType)\r\n            result := keccak256(start, 288)\r\n\r\n            mstore(start, tmp)\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nlibrary OrderParam {\r\n    /* Functions to extract info from data bytes in Order struct */\r\n\r\n    function getOrderVersion(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return uint256(uint8(byte(order.data)));\r\n    }\r\n\r\n    function getExpiredAtFromOrderData(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return uint256(uint40(bytes5(order.data << (8*3))));\r\n    }\r\n\r\n    function isSell(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return uint8(order.data[1]) == 1;\r\n    }\r\n\r\n    function isMarketOrder(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return uint8(order.data[2]) == 1;\r\n    }\r\n\r\n    function isMakerOnly(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return uint8(order.data[22]) == 1;\r\n    }\r\n\r\n    function isMarketBuy(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return !isSell(order) && isMarketOrder(order);\r\n    }\r\n\r\n    function getAsMakerFeeRateFromOrderData(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return uint256(uint16(bytes2(order.data << (8*8))));\r\n    }\r\n\r\n    function getAsTakerFeeRateFromOrderData(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return uint256(uint16(bytes2(order.data << (8*10))));\r\n    }\r\n\r\n    function getMakerRebateRateFromOrderData(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 makerRebate = uint256(uint16(bytes2(order.data << (8*12))));\r\n\r\n        // make sure makerRebate will never be larger than REBATE_RATE_BASE, which is 100\r\n        return SafeMath.min(makerRebate, Consts.REBATE_RATE_BASE());\r\n    }\r\n\r\n    function getBalancePathFromOrderData(\r\n        Types.OrderParam memory order\r\n    )\r\n        internal\r\n        pure\r\n        returns (Types.BalancePath memory)\r\n    {\r\n        Types.BalanceCategory category;\r\n        uint16 marketID;\r\n\r\n        if (byte(order.data << (8*23)) == \"\\x01\") {\r\n            category = Types.BalanceCategory.CollateralAccount;\r\n            marketID = uint16(bytes2(order.data << (8*24)));\r\n        } else {\r\n            category = Types.BalanceCategory.Common;\r\n            marketID = 0;\r\n        }\r\n\r\n        return Types.BalancePath({\r\n            user: order.trader,\r\n            category: category,\r\n            marketID: marketID\r\n        });\r\n    }\r\n}","ABI":"[]","ContractName":"OperationsComponent","CompilerVersion":"v0.5.8+commit.23d335f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://35e40d4829bbc44f2ac24256441c98fbd69cda8a9a9847a9e6cbfc4fe64459ba"}]}