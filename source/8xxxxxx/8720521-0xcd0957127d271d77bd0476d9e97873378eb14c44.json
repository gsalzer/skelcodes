{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n* d888888P                                           dP              a88888b.                   dP\r\n*    88                                              88             d8'   `88                   88\r\n*    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\r\n*    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\r\n*    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\r\n*    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\r\n* ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\r\n*/\r\n\r\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\r\n\r\npragma solidity >=0.4.24 <0.6.0;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// File: contracts/MerkleTreeWithHistory.sol\r\n\r\n// https://tornado.cash\r\n/*\r\n* d888888P                                           dP              a88888b.                   dP\r\n*    88                                              88             d8'   `88                   88\r\n*    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\r\n*    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\r\n*    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\r\n*    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\r\n* ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\r\n*/\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\nlibrary MiMC {\r\n  function MiMCSponge(uint256 in_xL, uint256 in_xR, uint256 in_k) public pure returns (uint256 xL, uint256 xR);\r\n}\r\n\r\ncontract MerkleTreeWithHistory is Initializable {\r\n  uint256 public levels;\r\n\r\n  uint8 constant ROOT_HISTORY_SIZE = 100;\r\n  uint256[] private _roots;\r\n  uint256 public current_root = 0;\r\n\r\n  uint256[] private _filled_subtrees;\r\n  uint256[] private _zeros;\r\n\r\n  uint32 public next_index = 0;\r\n\r\n  function initialize(\r\n    uint256 tree_levels,\r\n    uint256 zero_value,\r\n    uint256[] memory filled_subtrees,\r\n    uint256 lastRoot\r\n  ) initializer public {\r\n    levels = tree_levels;\r\n    _zeros.push(zero_value);\r\n\r\n    for (uint8 i = 1; i < levels; i++) {\r\n      _zeros.push(hashLeftRight(_zeros[i-1], _zeros[i-1]));\r\n    }\r\n\r\n    _roots = new uint256[](ROOT_HISTORY_SIZE);\r\n    _filled_subtrees = filled_subtrees;\r\n    _roots[0] = lastRoot;\r\n  }\r\n\r\n  function hashLeftRight(uint256 left, uint256 right) public pure returns (uint256 mimc_hash) {\r\n    uint256 k = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    uint256 R = 0;\r\n    uint256 C = 0;\r\n\r\n    R = addmod(R, left, k);\r\n    (R, C) = MiMC.MiMCSponge(R, C, 0);\r\n\r\n    R = addmod(R, right, k);\r\n    (R, C) = MiMC.MiMCSponge(R, C, 0);\r\n\r\n    mimc_hash = R;\r\n  }\r\n\r\n  function _insert(uint256 leaf) internal {\r\n    uint32 current_index = next_index;\r\n    require(current_index != 2**(levels - 1), \"Merkle tree is full\");\r\n    next_index += 1;\r\n    uint256 current_level_hash = leaf;\r\n    uint256 left;\r\n    uint256 right;\r\n\r\n    for (uint256 i = 0; i < levels; i++) {\r\n      if (current_index % 2 == 0) {\r\n        left = current_level_hash;\r\n        right = _zeros[i];\r\n\r\n        _filled_subtrees[i] = current_level_hash;\r\n      } else {\r\n        left = _filled_subtrees[i];\r\n        right = current_level_hash;\r\n      }\r\n\r\n      current_level_hash = hashLeftRight(left, right);\r\n\r\n      current_index /= 2;\r\n    }\r\n\r\n    current_root = (current_root + 1) % ROOT_HISTORY_SIZE;\r\n    _roots[current_root] = current_level_hash;\r\n  }\r\n\r\n  function isKnownRoot(uint256 root) public view returns(bool) {\r\n    if (root == 0) {\r\n      return false;\r\n    }\r\n    // search most recent first\r\n    uint256 i;\r\n    for(i = current_root; i < 2**256 - 1; i--) {\r\n      if (root == _roots[i]) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // process the rest of roots\r\n    for(i = ROOT_HISTORY_SIZE - 1; i > current_root; i--) {\r\n      if (root == _roots[i]) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n\r\n    // or we can do that in other way\r\n    //   uint256 i = _current_root;\r\n    //   do {\r\n    //       if (root == _roots[i]) {\r\n    //           return true;\r\n    //       }\r\n    //       if (i == 0) {\r\n    //           i = ROOT_HISTORY_SIZE;\r\n    //       }\r\n    //       i--;\r\n    //   } while (i != _current_root);\r\n  }\r\n\r\n  function getLastRoot() public view returns(uint256) {\r\n    return _roots[current_root];\r\n  }\r\n\r\n  function roots() public view returns(uint256[] memory) {\r\n    return _roots;\r\n  }\r\n\r\n  function filled_subtrees() public view returns(uint256[] memory) {\r\n    return _filled_subtrees;\r\n  }\r\n\r\n  function zeros() public view returns(uint256[] memory) {\r\n    return _zeros;\r\n  }\r\n}\r\n\r\n// File: contracts/Mixer.sol\r\n\r\n// https://tornado.cash\r\n/*\r\n* d888888P                                           dP              a88888b.                   dP\r\n*    88                                              88             d8'   `88                   88\r\n*    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\r\n*    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\r\n*    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\r\n*    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\r\n* ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\r\n*/\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\ncontract IVerifier {\r\n  function verifyProof(uint256[2] memory a, uint256[2][2] memory b, uint256[2] memory c, uint256[4] memory input) public returns(bool);\r\n}\r\n\r\ncontract Mixer is MerkleTreeWithHistory {\r\n  uint256 public transferValue;\r\n  bool public isDepositsEnabled;\r\n  // operator can\r\n  //  - receive a relayer fee\r\n  //  - disable new deposits in case of emergency\r\n  //  - update this contact logic\r\n  address payable public operator;\r\n  mapping(uint256 => bool) public nullifierHashes;\r\n  // we store all commitments just to prevent accidental deposits with the same commitment\r\n  mapping(uint256 => bool) public commitments;\r\n  IVerifier public verifier;\r\n  bool public isMigrating;\r\n\r\n  event Deposit(uint256 indexed commitment, uint256 leafIndex, uint256 timestamp);\r\n  event Withdraw(address to, uint256 nullifierHash, uint256 fee);\r\n\r\n  modifier onlyOperator() {\r\n    require(msg.sender == operator, \"unauthorized\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n    @dev The constructor\r\n    @param _verifier the address of SNARK verifier for this contract\r\n    @param _transferValue the value for all deposits in this contract in wei\r\n    @param _merkleTreeHeight the height of deposits' Merkle Tree\r\n    @param _emptyElement default element of the deposits' Merkle Tree\r\n    @param _operator operator address (see operator above)\r\n    @param _filled_subtrees subroots from previous mixer contract\r\n    @param _lastRoot last root from previous mixer contract\r\n  */\r\n  function initialize(\r\n    address _verifier,\r\n    uint256 _transferValue,\r\n    uint8 _merkleTreeHeight,\r\n    uint256 _emptyElement,\r\n    address payable _operator,\r\n    uint256[] memory _filled_subtrees,\r\n    uint256 _lastRoot\r\n  ) public initializer {\r\n    verifier = IVerifier(_verifier);\r\n    transferValue = _transferValue;\r\n    operator = _operator;\r\n    isMigrating = true;\r\n    isDepositsEnabled = false;\r\n    MerkleTreeWithHistory.initialize(_merkleTreeHeight, _emptyElement, _filled_subtrees, _lastRoot);\r\n  }\r\n\r\n  /**\r\n    @dev Migrate state from old mixer to this one.\r\n    @param _commitments deposited commitments from previous contract\r\n    @param _nullifierHashes spent nullifiers from previous contract\r\n  */\r\n  function migrateState(uint256[] calldata _commitments, uint256[] calldata _nullifierHashes) external onlyOperator {\r\n    require(isMigrating, \"Migration is disabled\");\r\n    for (uint256 i = 0; i < _commitments.length; i++) {\r\n      commitments[_commitments[i]] = true;\r\n      emit Deposit(_commitments[i], next_index + i, block.timestamp); // should we load timestamp as well? cause UI uses them\r\n    }\r\n\r\n    next_index += uint32(_commitments.length);\r\n\r\n    for (uint256 i = 0; i < _nullifierHashes.length; i++) {\r\n      nullifierHashes[_nullifierHashes[i]] = true;\r\n      emit Withdraw(address(0), _nullifierHashes[i], 0);\r\n    }\r\n  }\r\n\r\n  /**\r\n    @dev Deposit funds into mixer. The caller must send value equal to `transferValue` of this mixer.\r\n    @param commitment the note commitment, which is PedersenHash(nullifier + secret)\r\n  */\r\n  function deposit(uint256 commitment) public payable {\r\n    require(isDepositsEnabled, \"deposits disabled\");\r\n    require(msg.value == transferValue, \"Please send `transferValue` ETH along with transaction\");\r\n    require(!commitments[commitment], \"The commitment has been submitted\");\r\n    _insert(commitment);\r\n    commitments[commitment] = true;\r\n    emit Deposit(commitment, next_index - 1, block.timestamp);\r\n  }\r\n\r\n  /**\r\n    @dev Withdraw deposit from the mixer. `a`, `b`, and `c` are zkSNARK proof data, and input is an array of circuit public inputs\r\n    `input` array consists of:\r\n      - merkle root of all deposits in the mixer\r\n      - hash of unique deposit nullifier to prevent double spends\r\n      - the receiver of funds\r\n      - optional fee that goes to the transaction sender (usually a relay)\r\n  */\r\n  function withdraw(uint256[2] memory a, uint256[2][2] memory b, uint256[2] memory c, uint256[4] memory input) public {\r\n    uint256 root = input[0];\r\n    uint256 nullifierHash = input[1];\r\n    address payable receiver = address(input[2]);\r\n    uint256 fee = input[3];\r\n\r\n    require(!nullifierHashes[nullifierHash], \"The note has been already spent\");\r\n    require(fee < transferValue, \"Fee exceeds transfer value\");\r\n    require(isKnownRoot(root), \"Cannot find your merkle root\"); // Make sure to use a recent one\r\n    require(verifier.verifyProof(a, b, c, input), \"Invalid withdraw proof\");\r\n\r\n    nullifierHashes[nullifierHash] = true;\r\n    receiver.transfer(transferValue - fee);\r\n    if (fee > 0) {\r\n      operator.transfer(fee);\r\n    }\r\n    emit Withdraw(receiver, nullifierHash, fee);\r\n  }\r\n\r\n  function toggleDeposits() external onlyOperator {\r\n    isDepositsEnabled = !isDepositsEnabled;\r\n  }\r\n\r\n  function stopMigration() external onlyOperator {\r\n    isMigrating = false;\r\n    isDepositsEnabled = true;\r\n  }\r\n\r\n  function changeOperator(address payable _newAccount) external onlyOperator {\r\n    operator = _newAccount;\r\n  }\r\n\r\n  function isSpent(uint256 nullifier) public view returns(bool) {\r\n    return nullifierHashes[nullifier];\r\n  }\r\n\r\n  // enable direct eth transfer for operator (to top-up balance of migrated deposites)\r\n  function() external payable onlyOperator {}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAccount\",\"type\":\"address\"}],\"name\":\"changeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"filled_subtrees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nullifierHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_commitments\",\"type\":\"uint256[]\"},{\"name\":\"_nullifierHashes\",\"type\":\"uint256[]\"}],\"name\":\"migrateState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_verifier\",\"type\":\"address\"},{\"name\":\"_transferValue\",\"type\":\"uint256\"},{\"name\":\"_merkleTreeHeight\",\"type\":\"uint8\"},{\"name\":\"_emptyElement\",\"type\":\"uint256\"},{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_filled_subtrees\",\"type\":\"uint256[]\"},{\"name\":\"_lastRoot\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"commitments\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zeros\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"levels\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256[2]\"},{\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"name\":\"c\",\"type\":\"uint256[2]\"},{\"name\":\"input\",\"type\":\"uint256[4]\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDepositsEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nullifier\",\"type\":\"uint256\"}],\"name\":\"isSpent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"left\",\"type\":\"uint256\"},{\"name\":\"right\",\"type\":\"uint256\"}],\"name\":\"hashLeftRight\",\"outputs\":[{\"name\":\"mimc_hash\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"next_index\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"current_root\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tree_levels\",\"type\":\"uint256\"},{\"name\":\"zero_value\",\"type\":\"uint256\"},{\"name\":\"filled_subtrees\",\"type\":\"uint256[]\"},{\"name\":\"lastRoot\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"root\",\"type\":\"uint256\"}],\"name\":\"isKnownRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commitment\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"toggleDeposits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopMigration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMigrating\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"commitment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"leafIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nullifierHash\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"Mixer","CompilerVersion":"v0.5.10+commit.5a6ea5b1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"MiMC:5b0010eea43265f020a55a722199a09fb16f6055","LicenseType":"None","SwarmSource":"bzzr://1e310bea66d55063640e61d2f081cbd81f945ec092c647d8ab000ab9e3f0954e"}]}