{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\r\n\r\n\r\ninterface DharmaUpgradeBeaconControllerManagerInterface {\r\n  // Fire an event whenever the Adharma Contingency is activated or exited.\r\n  event AdharmaContingencyActivated();\r\n  event AdharmaContingencyExited();\r\n\r\n  // Store timestamp and last implementation in case of Adharma Contingency.\r\n  struct AdharmaContingency {\r\n    bool armed;\r\n    bool activated;\r\n    uint256 activationTime;\r\n  }\r\n\r\n  // Store all prior implementations and allow for blocking rollbacks to them.\r\n  struct PriorImplementation {\r\n    address implementation;\r\n    bool rollbackBlocked;\r\n  }\r\n\r\n  function initiateUpgrade(\r\n    address controller,\r\n    address beacon,\r\n    address implementation,\r\n    uint256 extraTime\r\n  ) external;\r\n\r\n  function upgrade(\r\n    address controller, address beacon, address implementation\r\n  ) external;\r\n\r\n  function agreeToAcceptControllerOwnership(\r\n    address controller, bool willAcceptOwnership\r\n  ) external;\r\n\r\n  function initiateTransferControllerOwnership(\r\n    address controller, address newOwner, uint256 extraTime\r\n  ) external;\r\n\r\n  function transferControllerOwnership(\r\n    address controller, address newOwner\r\n  ) external;\r\n\r\n  function heartbeat() external;\r\n\r\n  function newHeartbeater(address heartbeater) external;\r\n\r\n  function armAdharmaContingency(bool armed) external;\r\n\r\n  function activateAdharmaContingency() external;\r\n\r\n  function rollback(address controller, address beacon, uint256 index) external;\r\n\r\n  function blockRollback(\r\n    address controller, address beacon, uint256 index\r\n  ) external;\r\n\r\n  function exitAdharmaContingency(\r\n    address smartWalletImplementation, address keyRingImplementation\r\n  ) external;\r\n\r\n  function getTotalPriorImplementations(\r\n    address controller, address beacon\r\n  ) external view returns (uint256 totalPriorImplementations);\r\n\r\n  function getPriorImplementation(\r\n    address controller, address beacon, uint256 index\r\n  ) external view returns (address priorImplementation, bool rollbackAllowed);\r\n\r\n  function contingencyStatus() external view returns (\r\n    bool armed, bool activated, uint256 activationTime\r\n  );\r\n\r\n  function heartbeatStatus() external view returns (\r\n    bool expired, uint256 expirationTime\r\n  );\r\n}\r\n\r\n\r\ninterface UpgradeBeaconControllerInterface {\r\n  function upgrade(address beacon, address implementation) external;\r\n}\r\n\r\n\r\ninterface TimelockerModifiersInterface {\r\n  function initiateModifyTimelockInterval(\r\n    bytes4 functionSelector, uint256 newTimelockInterval, uint256 extraTime\r\n  ) external;\r\n\r\n  function modifyTimelockInterval(\r\n    bytes4 functionSelector, uint256 newTimelockInterval\r\n  ) external;\r\n\r\n  function initiateModifyTimelockExpiration(\r\n    bytes4 functionSelector, uint256 newTimelockExpiration, uint256 extraTime\r\n  ) external;\r\n\r\n  function modifyTimelockExpiration(\r\n    bytes4 functionSelector, uint256 newTimelockExpiration\r\n  ) external;\r\n}\r\n\r\n\r\ninterface IndestructibleRegistryCheckerInterface {\r\n  function isRegisteredAsIndestructible(\r\n    address target\r\n  ) external view returns (bool registeredAsIndestructible);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint256 c = a / b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n *\r\n * In order to transfer ownership, a recipient must be specified, at which point\r\n * the specified recipient can call `acceptOwnership` and take ownership.\r\n */\r\ncontract TwoStepOwnable {\r\n  address private _owner;\r\n\r\n  address private _newPotentialOwner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev Initialize contract by setting transaction submitter as initial owner.\r\n   */\r\n  constructor() internal {\r\n    _owner = tx.origin;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \"TwoStepOwnable: caller is not the owner.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the caller is the current owner.\r\n   */\r\n  function isOwner() public view returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows a new account (`newOwner`) to accept ownership.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(\r\n      newOwner != address(0),\r\n      \"TwoStepOwnable: new potential owner is the zero address.\"\r\n    );\r\n\r\n    _newPotentialOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancel a transfer of ownership to a new account.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function cancelOwnershipTransfer() public onlyOwner {\r\n    delete _newPotentialOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to the caller.\r\n   * Can only be called by a new potential owner set by the current owner.\r\n   */\r\n  function acceptOwnership() public {\r\n    require(\r\n      msg.sender == _newPotentialOwner,\r\n      \"TwoStepOwnable: current owner must set caller as new potential owner.\"\r\n    );\r\n\r\n    delete _newPotentialOwner;\r\n\r\n    emit OwnershipTransferred(_owner, msg.sender);\r\n\r\n    _owner = msg.sender;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Timelocker\r\n * @author 0age\r\n * @notice This contract allows contracts that inherit it to implement timelocks\r\n * on functions, where the `_setTimelock` internal function must first be called\r\n * and passed the target function selector and arguments. Then, a given time\r\n * interval must first fully transpire before the timelock functions can be\r\n * successfully called. Furthermore, once a timelock is complete, it will expire\r\n * after a period of time. In order to change timelock intervals or expirations,\r\n * the inheriting contract needs to implement `modifyTimelockInterval` and\r\n * `modifyTimelockExpiration` functions, respectively, as well as functions that\r\n * call `_setTimelock` in order to initiate the timelocks for those functions.\r\n * To make a function timelocked, use the `_enforceTimelock` internal function.\r\n * To set initial defult minimum timelock intervals and expirations, use the\r\n * `_setInitialTimelockInterval` and `_setInitialTimelockExpiration` internal\r\n * functions - they can only be used during contract creation. Finally, there\r\n * are three public getters: `getTimelock`, `getDefaultTimelockInterval`, and\r\n * `getDefaultTimelockExpiration`.\r\n */\r\ncontract Timelocker {\r\n  using SafeMath for uint256;\r\n\r\n  // Fire an event any time a timelock is initiated.\r\n  event TimelockInitiated(\r\n    bytes4 functionSelector, // selector of the function\r\n    uint256 timeComplete,    // timestamp at which the function can be called\r\n    bytes arguments,         // abi-encoded function arguments to call with\r\n    uint256 timeExpired      // timestamp where function can no longer be called\r\n  );\r\n\r\n  // Fire an event any time a minimum timelock interval is modified.\r\n  event TimelockIntervalModified(\r\n    bytes4 functionSelector, // selector of the function\r\n    uint256 oldInterval,     // old minimum timelock interval for the function\r\n    uint256 newInterval      // new minimum timelock interval for the function\r\n  );\r\n\r\n  // Fire an event any time a default timelock expiration is modified.\r\n  event TimelockExpirationModified(\r\n    bytes4 functionSelector, // selector of the function\r\n    uint256 oldExpiration,   // old default timelock expiration for the function\r\n    uint256 newExpiration    // new default timelock expiration for the function\r\n  );\r\n\r\n  // Each timelock has timestamps for when it is complete and when it expires.\r\n  struct Timelock {\r\n    uint128 complete;\r\n    uint128 expires;\r\n  }\r\n\r\n  // Functions have a timelock interval and time from completion to expiration.\r\n  struct TimelockDefaults {\r\n    uint128 interval;\r\n    uint128 expiration;\r\n  }\r\n\r\n  // Implement a timelock for each function and set of arguments.\r\n  mapping(bytes4 => mapping(bytes32 => Timelock)) private _timelocks;\r\n\r\n  // Implement default timelock intervals and expirations for each function.\r\n  mapping(bytes4 => TimelockDefaults) private _timelockDefaults;\r\n\r\n  // Only allow one new interval or expiration change at a time per function.\r\n  mapping(bytes4 => mapping(bytes4 => bytes32)) private _protectedTimelockIDs;\r\n\r\n  // Store modifyTimelockInterval function selector as a constant.\r\n  bytes4 private constant _MODIFY_TIMELOCK_INTERVAL_SELECTOR = bytes4(\r\n    0xe950c085\r\n  );\r\n\r\n  // Store modifyTimelockExpiration function selector as a constant.\r\n  bytes4 private constant _MODIFY_TIMELOCK_EXPIRATION_SELECTOR = bytes4(\r\n    0xd7ce3c6f\r\n  );\r\n\r\n  // Set a ridiculously high duration in order to protect against overflows.\r\n  uint256 private constant _A_TRILLION_YEARS = 365000000000000 days;\r\n\r\n  /**\r\n   * @notice In the constructor, confirm that selectors specified as constants\r\n   * are correct.\r\n   */\r\n  constructor() internal {\r\n    TimelockerModifiersInterface modifiers;\r\n\r\n    bytes4 targetModifyInterval = modifiers.modifyTimelockInterval.selector;\r\n    require(\r\n      _MODIFY_TIMELOCK_INTERVAL_SELECTOR == targetModifyInterval,\r\n      \"Incorrect modify timelock interval selector supplied.\"\r\n    );\r\n\r\n    bytes4 targetModifyExpiration = modifiers.modifyTimelockExpiration.selector;\r\n    require(\r\n      _MODIFY_TIMELOCK_EXPIRATION_SELECTOR == targetModifyExpiration,\r\n      \"Incorrect modify timelock expiration selector supplied.\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice View function to check if a timelock for the specified function and\r\n   * arguments has completed.\r\n   * @param functionSelector function to be called.\r\n   * @param arguments The abi-encoded arguments of the function to be called.\r\n   * @return A boolean indicating if the timelock exists or not and the time at\r\n   * which the timelock completes if it does exist.\r\n   */\r\n  function getTimelock(\r\n    bytes4 functionSelector, bytes memory arguments\r\n  ) public view returns (\r\n    bool exists,\r\n    bool completed,\r\n    bool expired,\r\n    uint256 completionTime,\r\n    uint256 expirationTime\r\n  ) {\r\n    // Get timelock ID using the supplied function arguments.\r\n    bytes32 timelockID = keccak256(abi.encodePacked(arguments));\r\n\r\n    // Get information on the current timelock, if one exists.\r\n    completionTime = uint256(_timelocks[functionSelector][timelockID].complete);\r\n    exists = completionTime != 0;\r\n    expirationTime = uint256(_timelocks[functionSelector][timelockID].expires);\r\n    completed = exists && now > completionTime;\r\n    expired = exists && now > expirationTime;\r\n  }\r\n\r\n  /**\r\n   * @notice View function to check the current minimum timelock interval on a\r\n   * given function.\r\n   * @param functionSelector function to retrieve the timelock interval for.\r\n   * @return The current minimum timelock interval for the given function.\r\n   */\r\n  function getDefaultTimelockInterval(\r\n    bytes4 functionSelector\r\n  ) public view returns (uint256 defaultTimelockInterval) {\r\n    defaultTimelockInterval = uint256(\r\n      _timelockDefaults[functionSelector].interval\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice View function to check the current default timelock expiration on a\r\n   * given function.\r\n   * @param functionSelector function to retrieve the timelock expiration for.\r\n   * @return The current default timelock expiration for the given function.\r\n   */\r\n  function getDefaultTimelockExpiration(\r\n    bytes4 functionSelector\r\n  ) public view returns (uint256 defaultTimelockExpiration) {\r\n    defaultTimelockExpiration = uint256(\r\n      _timelockDefaults[functionSelector].expiration\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function that sets a timelock so that the specified\r\n   * function can be called with the specified arguments. Note that existing\r\n   * timelocks may be extended, but not shortened - this can also be used as a\r\n   * method for \"cancelling\" a function call by extending the timelock to an\r\n   * arbitrarily long duration. Keep in mind that new timelocks may be created\r\n   * with a shorter duration on functions that already have other timelocks on\r\n   * them, but only if they have different arguments.\r\n   * @param functionSelector selector of the function to be called.\r\n   * @param arguments The abi-encoded arguments of the function to be called.\r\n   * @param extraTime Additional time in seconds to add to the minimum timelock\r\n   * interval for the given function.\r\n   */\r\n  function _setTimelock(\r\n    bytes4 functionSelector, bytes memory arguments, uint256 extraTime\r\n  ) internal {\r\n    // Ensure that the specified extra time will not cause an overflow error.\r\n    require(extraTime < _A_TRILLION_YEARS, \"Supplied extra time is too large.\");\r\n\r\n    // Get timelock ID using the supplied function arguments.\r\n    bytes32 timelockID = keccak256(abi.encodePacked(arguments));\r\n\r\n    // For timelock interval or expiration changes, first drop any existing\r\n    // timelock for the function being modified if the argument has changed.\r\n    if (\r\n      functionSelector == _MODIFY_TIMELOCK_INTERVAL_SELECTOR ||\r\n      functionSelector == _MODIFY_TIMELOCK_EXPIRATION_SELECTOR\r\n    ) {\r\n      // Determine the function that will be modified by the timelock.\r\n      (bytes4 modifiedFunction, uint256 duration) = abi.decode(\r\n        arguments, (bytes4, uint256)\r\n      );\r\n\r\n      // Ensure that the new timelock duration will not cause an overflow error.\r\n      require(\r\n        duration < _A_TRILLION_YEARS,\r\n        \"Supplied default timelock duration to modify is too large.\"\r\n      );\r\n\r\n      // Determine the current timelockID, if any, for the modified function.\r\n      bytes32 currentTimelockID = (\r\n        _protectedTimelockIDs[functionSelector][modifiedFunction]\r\n      );\r\n\r\n      // Determine if current timelockID differs from what is currently set.\r\n      if (currentTimelockID != timelockID) {\r\n        // Drop existing timelock if one exists and has a different timelockID.\r\n        if (currentTimelockID != bytes32(0)) {\r\n          delete _timelocks[functionSelector][currentTimelockID];\r\n        }\r\n\r\n        // Register the new timelockID as the current protected timelockID.\r\n        _protectedTimelockIDs[functionSelector][modifiedFunction] = timelockID;\r\n      }\r\n    }\r\n\r\n    // Get timelock using current time, inverval for timelock ID, & extra time.\r\n    uint256 timelock = uint256(\r\n      _timelockDefaults[functionSelector].interval\r\n    ).add(now).add(extraTime);\r\n\r\n    // Get expiration time using timelock duration plus default expiration time.\r\n    uint256 expiration = timelock.add(\r\n      uint256(_timelockDefaults[functionSelector].expiration)\r\n    );\r\n\r\n    // Get the current timelock, if one exists.\r\n    Timelock storage timelockStorage = _timelocks[functionSelector][timelockID];\r\n\r\n    // Determine the duration of the current timelock.\r\n    uint256 currentTimelock = uint256(timelockStorage.complete);\r\n\r\n    // Ensure that the timelock duration does not decrease. Note that a new,\r\n    // shorter timelock may still be set up on the same function in the event\r\n    // that it is provided with different arguments. Also note that this can be\r\n    // circumvented when modifying intervals or expirations by setting a new\r\n    // timelock (removing the old one), then resetting the original timelock but\r\n    // with a shorter duration.\r\n    require(\r\n      currentTimelock == 0 || timelock > currentTimelock,\r\n      \"Existing timelocks may only be extended.\"\r\n    );\r\n\r\n    // Set timelock completion and expiration using timelock ID and extra time.\r\n    timelockStorage.complete = uint128(timelock);\r\n    timelockStorage.expires = uint128(expiration);\r\n\r\n    // Emit an event with all of the relevant information.\r\n    emit TimelockInitiated(functionSelector, timelock, arguments, expiration);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for setting a new timelock interval for a given\r\n   * function selector. The default for this function may also be modified, but\r\n   * excessive values will cause the `modifyTimelockInterval` function to become\r\n   * unusable.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * interval for.\r\n   * @param newTimelockInterval the new minimum timelock interval to set for the\r\n   * given function.\r\n   */\r\n  function _modifyTimelockInterval(\r\n    bytes4 functionSelector, uint256 newTimelockInterval\r\n  ) internal {\r\n    // Ensure that the timelock has been set and is completed.\r\n    _enforceTimelockPrivate(\r\n      _MODIFY_TIMELOCK_INTERVAL_SELECTOR,\r\n      abi.encode(functionSelector, newTimelockInterval)\r\n    );\r\n\r\n    // Clear out the existing timelockID protection for the given function.\r\n    delete _protectedTimelockIDs[\r\n      _MODIFY_TIMELOCK_INTERVAL_SELECTOR\r\n    ][functionSelector];\r\n\r\n    // Set new timelock interval and emit a `TimelockIntervalModified` event.\r\n    _setTimelockIntervalPrivate(functionSelector, newTimelockInterval);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function for setting a new timelock expiration for a given\r\n   * function selector. Once the minimum interval has elapsed, the timelock will\r\n   * expire once the specified expiration time has elapsed. Setting this value\r\n   * too low will result in timelocks that are very difficult to execute\r\n   * correctly. Be sure to override the public version of this function with\r\n   * appropriate access controls.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * expiration for.\r\n   * @param newTimelockExpiration the new minimum timelock expiration to set for\r\n   * the given function.\r\n   */\r\n  function _modifyTimelockExpiration(\r\n    bytes4 functionSelector, uint256 newTimelockExpiration\r\n  ) internal {\r\n    // Ensure that the timelock has been set and is completed.\r\n    _enforceTimelockPrivate(\r\n      _MODIFY_TIMELOCK_EXPIRATION_SELECTOR,\r\n      abi.encode(functionSelector, newTimelockExpiration)\r\n    );\r\n\r\n    // Clear out the existing timelockID protection for the given function.\r\n    delete _protectedTimelockIDs[\r\n      _MODIFY_TIMELOCK_EXPIRATION_SELECTOR\r\n    ][functionSelector];\r\n\r\n    // Set new default expiration and emit a `TimelockExpirationModified` event.\r\n    _setTimelockExpirationPrivate(functionSelector, newTimelockExpiration);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to set an initial timelock interval for a given\r\n   * function selector. Only callable during contract creation.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * interval for.\r\n   * @param newTimelockInterval the new minimum timelock interval to set for the\r\n   * given function.\r\n   */\r\n  function _setInitialTimelockInterval(\r\n    bytes4 functionSelector, uint256 newTimelockInterval\r\n  ) internal {\r\n    // Ensure that this function is only callable during contract construction.\r\n    assembly { if extcodesize(address) { revert(0, 0) } }\r\n\r\n    // Set the timelock interval and emit a `TimelockIntervalModified` event.\r\n    _setTimelockIntervalPrivate(functionSelector, newTimelockInterval);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to set an initial timelock expiration for a given\r\n   * function selector. Only callable during contract creation.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * expiration for.\r\n   * @param newTimelockExpiration the new minimum timelock expiration to set for\r\n   * the given function.\r\n   */\r\n  function _setInitialTimelockExpiration(\r\n    bytes4 functionSelector, uint256 newTimelockExpiration\r\n  ) internal {\r\n    // Ensure that this function is only callable during contract construction.\r\n    assembly { if extcodesize(address) { revert(0, 0) } }\r\n\r\n    // Set the timelock interval and emit a `TimelockExpirationModified` event.\r\n    _setTimelockExpirationPrivate(functionSelector, newTimelockExpiration);\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to ensure that a timelock is complete or expired\r\n   * and to clear the existing timelock if it is complete so it cannot later be\r\n   * reused. The function to enforce the timelock on is inferred from `msg.sig`.\r\n   * @param arguments The abi-encoded arguments of the function to be called.\r\n   */\r\n  function _enforceTimelock(bytes memory arguments) internal {\r\n    // Enforce the relevant timelock.\r\n    _enforceTimelockPrivate(msg.sig, arguments);\r\n  }\r\n\r\n  /**\r\n   * @notice Private function to ensure that a timelock is complete or expired\r\n   * and to clear the existing timelock if it is complete so it cannot later be\r\n   * reused.\r\n   * @param functionSelector function to be called.\r\n   * @param arguments The abi-encoded arguments of the function to be called.\r\n   */\r\n  function _enforceTimelockPrivate(\r\n    bytes4 functionSelector, bytes memory arguments\r\n  ) private {\r\n    // Get timelock ID using the supplied function arguments.\r\n    bytes32 timelockID = keccak256(abi.encodePacked(arguments));\r\n\r\n    // Get the current timelock, if one exists.\r\n    Timelock memory timelock = _timelocks[functionSelector][timelockID];\r\n\r\n    uint256 currentTimelock = uint256(timelock.complete);\r\n    uint256 expiration = uint256(timelock.expires);\r\n\r\n    // Ensure that the timelock is set and has completed.\r\n    require(\r\n      currentTimelock != 0 && currentTimelock <= now, \"Timelock is incomplete.\"\r\n    );\r\n\r\n    // Ensure that the timelock has not expired.\r\n    require(expiration > now, \"Timelock has expired.\");\r\n\r\n    // Clear out the existing timelock so that it cannot be reused.\r\n    delete _timelocks[functionSelector][timelockID];\r\n  }\r\n\r\n  /**\r\n   * @notice Private function for setting a new timelock interval for a given\r\n   * function selector.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * interval for.\r\n   * @param newTimelockInterval the new minimum timelock interval to set for the\r\n   * given function.\r\n   */\r\n  function _setTimelockIntervalPrivate(\r\n    bytes4 functionSelector, uint256 newTimelockInterval\r\n  ) private {\r\n    // Ensure that the new timelock interval will not cause an overflow error.\r\n    require(\r\n      newTimelockInterval < _A_TRILLION_YEARS,\r\n      \"Supplied minimum timelock interval is too large.\"\r\n    );\r\n\r\n    // Get the existing timelock interval, if any.\r\n    uint256 oldTimelockInterval = uint256(\r\n      _timelockDefaults[functionSelector].interval\r\n    );\r\n\r\n    // Update the timelock interval on the provided function.\r\n    _timelockDefaults[functionSelector].interval = uint128(newTimelockInterval);\r\n\r\n    // Emit a `TimelockIntervalModified` event with the appropriate arguments.\r\n    emit TimelockIntervalModified(\r\n      functionSelector, oldTimelockInterval, newTimelockInterval\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Private function for setting a new timelock expiration for a given\r\n   * function selector.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * interval for.\r\n   * @param newTimelockExpiration the new default timelock expiration to set for\r\n   * the given function.\r\n   */\r\n  function _setTimelockExpirationPrivate(\r\n    bytes4 functionSelector, uint256 newTimelockExpiration\r\n  ) private {\r\n    // Ensure that the new timelock expiration will not cause an overflow error.\r\n    require(\r\n      newTimelockExpiration < _A_TRILLION_YEARS,\r\n      \"Supplied default timelock expiration is too large.\"\r\n    );\r\n\r\n    // Ensure that the new timelock expiration is not too short.\r\n    require(\r\n      newTimelockExpiration > 1 minutes,\r\n      \"New timelock expiration is too short.\"\r\n    );\r\n\r\n    // Get the existing timelock expiration, if any.\r\n    uint256 oldTimelockExpiration = uint256(\r\n      _timelockDefaults[functionSelector].expiration\r\n    );\r\n\r\n    // Update the timelock expiration on the provided function.\r\n    _timelockDefaults[functionSelector].expiration = uint128(\r\n      newTimelockExpiration\r\n    );\r\n\r\n    // Emit a `TimelockExpirationModified` event with the appropriate arguments.\r\n    emit TimelockExpirationModified(\r\n      functionSelector, oldTimelockExpiration, newTimelockExpiration\r\n    );\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DharmaUpgradeBeaconControllerManager\r\n * @author 0age\r\n * @notice This contract will be owned by DharmaUpgradeMultisig and will manage\r\n * upgrades to the global smart wallet and key ring implementation contracts via\r\n * dedicated control over the \"upgrade beacon\" controller contracts (and can\r\n * additionally be used to manage other upgrade beacon controllers). It contains\r\n * a set of timelocked functions, where the `setTimelock` function must first be\r\n * called, with the same arguments that the function will be supplied with.\r\n * Then, a given time interval must first fully transpire before the timelock\r\n * functions can be successfully called.\r\n *\r\n * The timelocked functions currently implemented include:\r\n *  upgrade(address controller, address implementation)\r\n *  transferControllerOwnership(address controller, address newOwner)\r\n *  modifyTimelockInterval(bytes4 functionSelector, uint256 newTimelockInterval)\r\n *  modifyTimelockExpiration(\r\n *    bytes4 functionSelector, uint256 newTimelockExpiration\r\n *  )\r\n *\r\n * This contract also allows for immediately triggering a \"rollback\" to a prior\r\n * implementation in the event that a new vulnerability is introduced. It can\r\n * roll back to any implementation for a given controller + upgrade beacon pair\r\n * unless that implementation has been explicitly \"blocked\" by the owner.\r\n *\r\n * It also specifies dedicated implementations for the Dharma Smart Wallet and\r\n * Dharma Key Ring upgrade beacons that can be triggered in an emergency or in\r\n * the event of an extended period of inactivity from Dharma. These contingency\r\n * implementations give the user the ability to withdraw any funds on their\r\n * smart wallet by submitting a transaction directly from the account of any of\r\n * their signing keys, but are otherwise kept as simple as possible. After 48\r\n * hours in the contingency state, the owner may bypass the standard upgrade\r\n * timelock and trigger upgrades to the smart wallet and key ring implementation\r\n * contracts. Note that triggering a rollback, or performing a standard upgrade,\r\n * will cause the contingency state to be exited if it is active at the time.\r\n *\r\n * This contract can transfer ownership of any upgrade beacon controller it owns\r\n * (subject to the timelock on `transferControllerOwnership`), in order to\r\n * introduce new upgrade conditions or to otherwise alter the way that upgrades\r\n * are carried out.\r\n */\r\ncontract DharmaUpgradeBeaconControllerManager is\r\n  DharmaUpgradeBeaconControllerManagerInterface,\r\n  TimelockerModifiersInterface,\r\n  TwoStepOwnable,\r\n  Timelocker {\r\n  using SafeMath for uint256;\r\n\r\n  // Store prior implementation addresses for each controller + beacon pair.\r\n  mapping(address => mapping (address => PriorImplementation[])) private _implementations;\r\n\r\n  // New controller owners must accept ownership before a transfer can occur.\r\n  mapping(address => mapping(address => bool)) private _willAcceptOwnership;\r\n\r\n  // Store information on the current Adharma Contingency status.\r\n  AdharmaContingency private _adharma;\r\n\r\n  // Track the last heartbeat timestamp as well as the current heartbeat address\r\n  uint256 private _lastHeartbeat;\r\n  address private _heartbeater;\r\n\r\n  // Store address of Smart Wallet Upgrade Beacon Controller as a constant.\r\n  address private constant _SMART_WALLET_UPGRADE_BEACON_CONTROLLER = address(\r\n    0x00000000002226C940b74d674B85E4bE05539663\r\n  );\r\n\r\n  // Store the address of the Dharma Smart Wallet Upgrade Beacon as a constant.\r\n  address private constant _DHARMA_SMART_WALLET_UPGRADE_BEACON = address(\r\n    0x000000000026750c571ce882B17016557279ADaa\r\n  );\r\n\r\n  // Store the Adharma Smart Wallet Contingency implementation.\r\n  address private constant _ADHARMA_SMART_WALLET_IMPLEMENTATION = address(\r\n    0x00000000009f22dA6fEB6735614563B9Af0339fB\r\n  );\r\n\r\n  // Store address of Key Ring Upgrade Beacon Controller as a constant.\r\n  address private constant _KEY_RING_UPGRADE_BEACON_CONTROLLER = address(\r\n    0x00000000011dF015e8aD00D7B2486a88C2Eb8210\r\n  );\r\n\r\n  // Store the address of the Dharma Key Ring Upgrade Beacon as a constant.\r\n  address private constant _DHARMA_KEY_RING_UPGRADE_BEACON = address(\r\n    0x0000000000BDA2152794ac8c76B2dc86cbA57cad\r\n  );\r\n\r\n  // Store the Adharma Key Ring Contingency implementation.\r\n  address private constant _ADHARMA_KEY_RING_IMPLEMENTATION = address(\r\n    0x000000000053d1F0F8aA88b9001Bec1B49445B3c\r\n  );\r\n\r\n  /**\r\n   * @notice In the constructor, set tx.origin as initial owner, the initial\r\n   * minimum timelock interval and expiration values, and some initial variable\r\n   * values. The runtime code of the smart wallet and key ring upgrade beacons,\r\n   * their controllers, and their contingency implementations are also verified.\r\n   * Note that each contract in question has also been registered as\r\n   * indestructible at indestructible.eth - this makes it impossible for their\r\n   * runtime bytecode to be altered from the point of the deployment of this\r\n   * contract.\r\n   */\r\n  constructor() public {\r\n    // Declare variable in order to put constants on the stack for hash checks.\r\n    address extcodehashTarget;\r\n\r\n    // Get Smart Wallet Upgrade Beacon Controller runtime code hash.\r\n    bytes32 smartWalletControllerHash;\r\n    extcodehashTarget = _SMART_WALLET_UPGRADE_BEACON_CONTROLLER;\r\n    assembly { smartWalletControllerHash := extcodehash(extcodehashTarget) }\r\n\r\n    // Get Smart Wallet Upgrade Beacon runtime code hash.\r\n    bytes32 smartWalletUpgradeBeaconHash;\r\n    extcodehashTarget = _DHARMA_SMART_WALLET_UPGRADE_BEACON;\r\n    assembly { smartWalletUpgradeBeaconHash := extcodehash(extcodehashTarget) }\r\n\r\n    // Get Adharma Smart Wallet implementation runtime code hash.\r\n    bytes32 adharmaSmartWalletHash;\r\n    extcodehashTarget = _ADHARMA_SMART_WALLET_IMPLEMENTATION;\r\n    assembly { adharmaSmartWalletHash := extcodehash(extcodehashTarget) }\r\n\r\n    // Get Key Ring Upgrade Beacon Controller runtime code hash.\r\n    bytes32 keyRingControllerHash;\r\n    extcodehashTarget = _KEY_RING_UPGRADE_BEACON_CONTROLLER;\r\n    assembly { keyRingControllerHash := extcodehash(extcodehashTarget) }\r\n\r\n    // Get Key Ring Upgrade Beacon runtime code hash.\r\n    bytes32 keyRingUpgradeBeaconHash;\r\n    extcodehashTarget = _DHARMA_KEY_RING_UPGRADE_BEACON;\r\n    assembly { keyRingUpgradeBeaconHash := extcodehash(extcodehashTarget) }\r\n\r\n    // Get Adharma Key Ring implementation runtime code hash.\r\n    bytes32 adharmaKeyRingHash;\r\n    extcodehashTarget = _ADHARMA_KEY_RING_IMPLEMENTATION;\r\n    assembly { adharmaKeyRingHash := extcodehash(extcodehashTarget) }\r\n\r\n    // Verify the runtime hashes of smart wallet and key ring upgrade contracts.\r\n    bool allRuntimeCodeHashesMatchExpectations = (\r\n      smartWalletControllerHash == bytes32(\r\n        0x6586626c057b68d99775ec4cae9aa5ce96907fb5f8d8c8046123f49f8ad93f1e\r\n      ) &&\r\n      smartWalletUpgradeBeaconHash == bytes32(\r\n        0xca51e36cf6ab9af9a6f019a923588cd6df58aa1e58f5ac1639da46931167e436\r\n      ) &&\r\n      adharmaSmartWalletHash == bytes32(\r\n        0xa8d641085d608420781e0b49768aa57d6e19dfeef227f839c33e2e00e2b8d82e\r\n      ) &&\r\n      keyRingControllerHash == bytes32(\r\n        0xb98d105738145a629aeea247cee5f12bb25eabc1040eb01664bbc95f0e7e8d39\r\n      ) &&\r\n      keyRingUpgradeBeaconHash == bytes32(\r\n        0xb65d03cdc199085ae86b460e897b6d53c08a6c6d436063ea29822ea80d90adc3\r\n      ) &&\r\n      adharmaKeyRingHash == bytes32(\r\n        0xc5a2c3124a4bf13329ce188ce5813ad643bedd26058ae22958f6b23962070949\r\n      )\r\n    );\r\n\r\n    // Ensure that the all of the runtime code hashes match expectations.\r\n    require(\r\n      allRuntimeCodeHashesMatchExpectations,\r\n      \"Runtime code hash of supplied upgradeability contracts is incorrect.\"\r\n    );\r\n\r\n    // Set up interface to check Indestructible registry for indestructibility.\r\n    IndestructibleRegistryCheckerInterface indestructible;\r\n    indestructible = IndestructibleRegistryCheckerInterface(\r\n      0x0000000000f55ff05D0080fE17A63b16596Fd59f\r\n    );\r\n\r\n    // Ensure that each specified upgradeability contract is indestructible.\r\n    require(\r\n      indestructible.isRegisteredAsIndestructible(\r\n        _SMART_WALLET_UPGRADE_BEACON_CONTROLLER\r\n      ) &&\r\n      indestructible.isRegisteredAsIndestructible(\r\n        _DHARMA_SMART_WALLET_UPGRADE_BEACON\r\n      ) &&\r\n      indestructible.isRegisteredAsIndestructible(\r\n        _ADHARMA_SMART_WALLET_IMPLEMENTATION\r\n      ) &&\r\n      indestructible.isRegisteredAsIndestructible(\r\n        _KEY_RING_UPGRADE_BEACON_CONTROLLER\r\n      ) &&\r\n      indestructible.isRegisteredAsIndestructible(\r\n        _DHARMA_KEY_RING_UPGRADE_BEACON\r\n      ) &&\r\n      indestructible.isRegisteredAsIndestructible(\r\n        _ADHARMA_KEY_RING_IMPLEMENTATION\r\n      ),\r\n      \"Supplied upgradeability contracts are not registered as indestructible.\"\r\n    );\r\n\r\n    // Set initial minimum timelock interval values.\r\n    _setInitialTimelockInterval(\r\n      this.transferControllerOwnership.selector, 4 weeks\r\n    );\r\n    _setInitialTimelockInterval(this.modifyTimelockInterval.selector, 4 weeks);\r\n    _setInitialTimelockInterval(\r\n      this.modifyTimelockExpiration.selector, 4 weeks\r\n    );\r\n    _setInitialTimelockInterval(this.upgrade.selector, 7 days);\r\n\r\n    // Set initial default timelock expiration values.\r\n    _setInitialTimelockExpiration(\r\n      this.transferControllerOwnership.selector, 7 days\r\n    );\r\n    _setInitialTimelockExpiration(this.modifyTimelockInterval.selector, 7 days);\r\n    _setInitialTimelockExpiration(\r\n      this.modifyTimelockExpiration.selector, 7 days\r\n    );\r\n    _setInitialTimelockExpiration(this.upgrade.selector, 7 days);\r\n\r\n    // Set the initial owner as the initial heartbeater and trigger a heartbeat.\r\n    _heartbeater = tx.origin;\r\n    _lastHeartbeat = now;\r\n  }\r\n\r\n  /**\r\n   * @notice Initiates a timelocked upgrade process via a given controller and\r\n   * upgrade beacon to a given implementation address. Only the owner may call\r\n   * this function. Once the timelock period is complete (and before it has\r\n   * expired) the owner may call `upgrade` to complete the process and trigger\r\n   * the upgrade.\r\n   * @param controller address of controller to call into that will trigger the\r\n   * update to the specified upgrade beacon.\r\n   * @param beacon address of upgrade beacon to set the new implementation on.\r\n   * @param implementation the address of the new implementation.\r\n   * @param extraTime Additional time in seconds to add to the timelock.\r\n   */\r\n  function initiateUpgrade(\r\n    address controller,\r\n    address beacon,\r\n    address implementation,\r\n    uint256 extraTime\r\n  ) external onlyOwner {\r\n    require(controller != address(0), \"Must specify a controller address.\");\r\n\r\n    require(beacon != address(0), \"Must specify a beacon address.\");\r\n\r\n    // Ensure that the implementaton contract is not the null address.\r\n    require(\r\n      implementation != address(0),\r\n      \"Implementation cannot be the null address.\"\r\n    );\r\n\r\n    // Ensure that the implementation contract has code via extcodesize.\r\n    uint256 size;\r\n    assembly {\r\n      size := extcodesize(implementation)\r\n    }\r\n    require(size > 0, \"Implementation must have contract code.\");\r\n\r\n    // Set the timelock and emit a `TimelockInitiated` event.\r\n    _setTimelock(\r\n      this.upgrade.selector,\r\n      abi.encode(controller, beacon, implementation),\r\n      extraTime\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Timelocked function to set a new implementation address on an\r\n   * upgrade beacon contract. Note that calling this function will cause the\r\n   * contincency state to be exited if it is currently active. Only the owner\r\n   * may call this function.\r\n   * @param controller address of controller to call into that will trigger the\r\n   * update to the specified upgrade beacon.\r\n   * @param beacon address of upgrade beacon to set the new implementation on.\r\n   * @param implementation the address of the new implementation.\r\n   */\r\n  function upgrade(\r\n    address controller, address beacon, address implementation\r\n  ) external onlyOwner {\r\n    // Ensure that the timelock has been set and is completed.\r\n    _enforceTimelock(abi.encode(controller, beacon, implementation));\r\n\r\n    // Exit contingency state if it is currently active and trigger a heartbeat.\r\n    _exitAdharmaContingencyIfActiveAndTriggerHeartbeat();\r\n\r\n    // Call controller with beacon to upgrade and implementation to upgrade to.\r\n    _upgrade(controller, beacon, implementation);\r\n  }\r\n\r\n  /**\r\n   * @notice Allow a new potential owner of an upgrade beacon controller to\r\n   * accept ownership of the controller. Anyone may call this function, though\r\n   * ownership transfer of the controller in question will only proceed once the\r\n   * owner calls `transferControllerOwnership`.\r\n   * @param controller address of controller to allow ownership transfer for.\r\n   * @param willAcceptOwnership a boolean signifying if an ownership transfer to\r\n   * the caller is acceptable.\r\n   */\r\n  function agreeToAcceptControllerOwnership(\r\n    address controller, bool willAcceptOwnership\r\n  ) external {\r\n    require(controller != address(0), \"Must specify a controller address.\");\r\n\r\n    // Register whether or not the new owner is willing to accept ownership.\r\n    _willAcceptOwnership[controller][msg.sender] = willAcceptOwnership;\r\n  }\r\n\r\n  /**\r\n   * @notice Initiates a timelock to set a new owner on an upgrade beacon\r\n   * controller that is owned by this contract. Only the owner may call this\r\n   * function.\r\n   * @param controller address of controller to transfer ownership of.\r\n   * @param newOwner address to assign ownership of the controller to.\r\n   * @param extraTime Additional time in seconds to add to the timelock.\r\n   */\r\n  function initiateTransferControllerOwnership(\r\n    address controller, address newOwner, uint256 extraTime\r\n  ) external onlyOwner {\r\n    require(controller != address(0), \"No controller address provided.\");\r\n\r\n    require(newOwner != address(0), \"No new owner address provided.\");\r\n\r\n    // Ensure that the new owner has confirmed that it can accept ownership.\r\n    require(\r\n      _willAcceptOwnership[controller][newOwner],\r\n      \"New owner must agree to accept ownership of the given controller.\"\r\n    );\r\n\r\n    // Set the timelock and emit a `TimelockInitiated` event.\r\n    _setTimelock(\r\n      this.transferControllerOwnership.selector,\r\n      abi.encode(controller, newOwner),\r\n      extraTime\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Timelocked function to set a new owner on an upgrade beacon\r\n   * controller that is owned by this contract.\r\n   * @param controller address of controller to transfer ownership of.\r\n   * @param newOwner address to assign ownership of the controller to.\r\n   */\r\n  function transferControllerOwnership(\r\n    address controller, address newOwner\r\n  ) external onlyOwner {\r\n    // Ensure that the new owner has confirmed that it can accept ownership.\r\n    require(\r\n      _willAcceptOwnership[controller][newOwner],\r\n      \"New owner must agree to accept ownership of the given controller.\"\r\n    );\r\n\r\n    // Ensure that the timelock has been set and is completed.\r\n    _enforceTimelock(abi.encode(controller, newOwner));\r\n\r\n    // Transfer ownership of the controller to the new owner.\r\n    TwoStepOwnable(controller).transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @notice Send a new heartbeat. If 90 days pass without a heartbeat, anyone\r\n   * may trigger the Adharma Contingency and force an upgrade to any controlled\r\n   * upgrade beacon.\r\n   */\r\n  function heartbeat() external {\r\n    require(msg.sender == _heartbeater, \"Must be called from the heartbeater.\");\r\n    _lastHeartbeat = now;\r\n  }\r\n\r\n  /**\r\n   * @notice Set a new heartbeater.\r\n   * @param heartbeater address to designate as the heartbeating address.\r\n   */\r\n  function newHeartbeater(address heartbeater) external onlyOwner {\r\n    require(heartbeater != address(0), \"Must specify a heartbeater address.\");\r\n    _heartbeater = heartbeater;\r\n  }\r\n\r\n  /**\r\n   * @notice Arm the Adharma Contingency upgrade. This is required as an extra\r\n   * safeguard against accidentally triggering the Adharma Contingency. Note\r\n   * that there is a possibility for griefing in the event that 90 days have\r\n   * passed since the last heartbeat - this can be circumvented if necessary by\r\n   * calling both `armAdharmaContingency` and `activateAdharmaContingency` as\r\n   * part of the same transaction.\r\n   * @param armed Boolean that signifies the desired armed status.\r\n   */\r\n  function armAdharmaContingency(bool armed) external {\r\n    // Non-owners can only call if 90 days have passed since the last heartbeat.\r\n    _ensureCallerIsOwnerOrDeadmansSwitchActivated();\r\n\r\n    // Arm (or disarm) the Adharma Contingency.\r\n    _adharma.armed = armed;\r\n  }\r\n\r\n  /**\r\n   * @notice Trigger the Adharma Contingency upgrade. This requires that the\r\n   * owner first call `armAdharmaContingency` and set `armed` to `true`. This is\r\n   * only to be invoked in cases of a time-sensitive emergency, or if the owner\r\n   * has become inactive for over 90 days. It also requires that the Upgrade\r\n   * Beacon Controller Manager contract still owns the specified upgrade beacon\r\n   * controllers. It will simultaneously upgrade the Smart Wallet and the Key\r\n   * Ring implementations to their designated contingency implementations.\r\n   */\r\n  function activateAdharmaContingency() external {\r\n    // Non-owners can only call if 90 days have passed since the last heartbeat.\r\n    _ensureCallerIsOwnerOrDeadmansSwitchActivated();\r\n\r\n    // Ensure that the Adharma Contingency has been armed.\r\n    require(\r\n      _adharma.armed,\r\n      \"Adharma Contingency is not armed - are SURE you meant to call this?\"\r\n    );\r\n\r\n    // Ensure that the Adharma Contingency is not already active.\r\n    require(!_adharma.activated, \"Adharma Contingency is already activated.\");\r\n\r\n    // Ensure this contract still owns the required upgrade beacon controllers.\r\n    _ensureOwnershipOfSmartWalletAndKeyRingControllers();\r\n\r\n    // Mark the Adharma Contingency as having been activated.\r\n    _adharma = AdharmaContingency({\r\n      armed: false,\r\n      activated: true,\r\n      activationTime: now\r\n    });\r\n\r\n    // Trigger upgrades on both beacons to the Adharma implementation contracts.\r\n    _upgrade(\r\n      _SMART_WALLET_UPGRADE_BEACON_CONTROLLER,\r\n      _DHARMA_SMART_WALLET_UPGRADE_BEACON,\r\n      _ADHARMA_SMART_WALLET_IMPLEMENTATION\r\n    );\r\n    _upgrade(\r\n      _KEY_RING_UPGRADE_BEACON_CONTROLLER,\r\n      _DHARMA_KEY_RING_UPGRADE_BEACON,\r\n      _ADHARMA_KEY_RING_IMPLEMENTATION\r\n    );\r\n\r\n    // Emit an event to signal that the Adharma Contingency has been activated.\r\n    emit AdharmaContingencyActivated();\r\n  }\r\n\r\n  /**\r\n   * @notice Roll back an upgrade to a prior implementation and exit from\r\n   * contingency status if one currently exists. Note that you can also \"roll\r\n   * forward\" a rollback to restore it to a more recent implementation that has\r\n   * been rolled back from. If the Adharma Contingency state is activated,\r\n   * triggering a rollback will cause it to be immediately exited - in that\r\n   * event it is recommended to simultaneously roll back both the smart wallet\r\n   * implementation and the key ring implementation.\r\n   * @param controller address of controller to call into that will trigger the\r\n   * rollback on the specified upgrade beacon.\r\n   * @param beacon address of upgrade beacon to roll back to the last\r\n   * implementation.\r\n   * @param index uint256 the index of the implementation to roll back to.\r\n   */\r\n  function rollback(\r\n    address controller, address beacon, uint256 index\r\n  ) external onlyOwner {\r\n    // Ensure that there is an implementation address to roll back to.\r\n    require(\r\n      _implementations[controller][beacon].length > index,\r\n      \"No implementation with the given index available to roll back to.\"\r\n    );\r\n\r\n    // Get the specified prior implementation.\r\n    PriorImplementation memory priorImplementation = (\r\n      _implementations[controller][beacon][index]\r\n    );\r\n\r\n    // Ensure rollbacks to the implementation have not already been blocked.\r\n    require(\r\n      !priorImplementation.rollbackBlocked,\r\n      \"Rollbacks to this implementation have been permanently blocked.\"\r\n    );\r\n\r\n    // Exit contingency state if it is currently active and trigger a heartbeat.\r\n    _exitAdharmaContingencyIfActiveAndTriggerHeartbeat();\r\n\r\n    // Upgrade to the specified implementation contract.\r\n    _upgrade(controller, beacon, priorImplementation.implementation);\r\n  }\r\n\r\n  /**\r\n   * @notice Permanently prevent a prior implementation from being rolled back\r\n   * to. This can be used to prevent accidentally rolling back to an\r\n   * implementation with a known vulnerability, or to remove the possibility of\r\n   * a rollback once the security of more recent implementations has been firmly\r\n   * established. Note that a blocked implementation can still be upgraded to in\r\n   * the usual fashion, and after an additional upgrade it will become possible\r\n   * to roll back to it unless it is blocked again. Only the owner may call this\r\n   * function.\r\n   * @param controller address of controller that was used to set the\r\n   * implementation.\r\n   * @param beacon address of upgrade beacon that the implementation was set on.\r\n   * @param index uint256 the index of the implementation to block rollbacks to.\r\n   */\r\n  function blockRollback(\r\n    address controller, address beacon, uint256 index\r\n  ) external onlyOwner {\r\n    // Ensure that there is an implementation address to roll back to.\r\n    require(\r\n      _implementations[controller][beacon].length > index,\r\n      \"No implementation with the given index available to block.\"\r\n    );\r\n\r\n    // Ensure rollbacks to the implementation have not already been blocked.\r\n    require(\r\n      !_implementations[controller][beacon][index].rollbackBlocked,\r\n      \"Rollbacks to this implementation are aleady blocked.\"\r\n    );\r\n\r\n    // Permanently lock rollbacks to the implementation in question.\r\n    _implementations[controller][beacon][index].rollbackBlocked = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Exit the Adharma Contingency by upgrading to new smart wallet and\r\n   * key ring implementation contracts. This requires that the contingency is\r\n   * currently activated and that at least 48 hours has elapsed since it was\r\n   * activated. Only the owner may call this function.\r\n   * @param smartWalletImplementation Address of the new smart wallet\r\n   * implementation.\r\n   * @param keyRingImplementation Address of the new key ring implementation.\r\n   */\r\n  function exitAdharmaContingency(\r\n    address smartWalletImplementation, address keyRingImplementation\r\n  ) external onlyOwner {\r\n    // Ensure that the Adharma Contingency is currently active.\r\n    require(\r\n      _adharma.activated, \"Adharma Contingency is not currently activated.\"\r\n    );\r\n\r\n    // Ensure that at least 48 hours has elapsed since the contingency commenced.\r\n    require(\r\n      now > _adharma.activationTime + 48 hours,\r\n      \"Cannot exit contingency with a new upgrade until 48 hours have elapsed.\"\r\n    );\r\n\r\n    // Ensure this contract still owns the required upgrade beacon controllers.\r\n    _ensureOwnershipOfSmartWalletAndKeyRingControllers();\r\n\r\n    // Exit the contingency state and trigger a heartbeat.\r\n    _exitAdharmaContingencyIfActiveAndTriggerHeartbeat();\r\n\r\n    // Trigger upgrades on both beacons to the Adharma implementation contracts.\r\n    _upgrade(\r\n      _SMART_WALLET_UPGRADE_BEACON_CONTROLLER,\r\n      _DHARMA_SMART_WALLET_UPGRADE_BEACON,\r\n      smartWalletImplementation\r\n    );\r\n    _upgrade(\r\n      _KEY_RING_UPGRADE_BEACON_CONTROLLER,\r\n      _DHARMA_KEY_RING_UPGRADE_BEACON,\r\n      keyRingImplementation\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the timelock for a new timelock interval for a given function\r\n   * selector. Only the owner may call this function.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * interval for.\r\n   * @param newTimelockInterval The new timelock interval to set for the given\r\n   * function selector.\r\n   * @param extraTime Additional time in seconds to add to the timelock.\r\n   */\r\n  function initiateModifyTimelockInterval(\r\n    bytes4 functionSelector, uint256 newTimelockInterval, uint256 extraTime\r\n  ) external onlyOwner {\r\n    // Ensure that a function selector is specified (no 0x00000000 selector).\r\n    require(\r\n      functionSelector != bytes4(0),\r\n      \"Function selector cannot be empty.\"\r\n    );\r\n\r\n    // Ensure a timelock interval over eight weeks is not set on this function.\r\n    if (functionSelector == this.modifyTimelockInterval.selector) {\r\n      require(\r\n        newTimelockInterval <= 8 weeks,\r\n        \"Timelock interval of modifyTimelockInterval cannot exceed eight weeks.\"\r\n      );\r\n    }\r\n\r\n    // Set the timelock and emit a `TimelockInitiated` event.\r\n    _setTimelock(\r\n      this.modifyTimelockInterval.selector,\r\n      abi.encode(functionSelector, newTimelockInterval),\r\n      extraTime\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Sets a new timelock interval for a given function selector. The\r\n   * default for this function may also be modified, but has a maximum allowable\r\n   * value of eight weeks. Only the owner may call this function.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * interval for.\r\n   * @param newTimelockInterval The new timelock interval to set for the given\r\n   * function selector.\r\n   */\r\n  function modifyTimelockInterval(\r\n    bytes4 functionSelector, uint256 newTimelockInterval\r\n  ) external onlyOwner {\r\n    // Ensure that a function selector is specified (no 0x00000000 selector).\r\n    require(\r\n      functionSelector != bytes4(0),\r\n      \"Function selector cannot be empty.\"\r\n    );\r\n\r\n    // Continue via logic in the inherited `_modifyTimelockInterval` function.\r\n    _modifyTimelockInterval(functionSelector, newTimelockInterval);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets a new timelock expiration for a given function selector. The\r\n   * default Only the owner may call this function. New expiration durations may\r\n   * not exceed one month.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * expiration for.\r\n   * @param newTimelockExpiration The new timelock expiration to set for the\r\n   * given function selector.\r\n   * @param extraTime Additional time in seconds to add to the timelock.\r\n   */\r\n  function initiateModifyTimelockExpiration(\r\n    bytes4 functionSelector, uint256 newTimelockExpiration, uint256 extraTime\r\n  ) external onlyOwner {\r\n    // Ensure that a function selector is specified (no 0x00000000 selector).\r\n    require(\r\n      functionSelector != bytes4(0),\r\n      \"Function selector cannot be empty.\"\r\n    );\r\n\r\n    // Ensure that the supplied default expiration does not exceed 1 month.\r\n    require(\r\n      newTimelockExpiration <= 30 days,\r\n      \"New timelock expiration cannot exceed one month.\"\r\n    );\r\n\r\n    // Ensure a timelock expiration under one hour is not set on this function.\r\n    if (functionSelector == this.modifyTimelockExpiration.selector) {\r\n      require(\r\n        newTimelockExpiration >= 60 minutes,\r\n        \"Expiration of modifyTimelockExpiration must be at least an hour long.\"\r\n      );\r\n    }\r\n\r\n    // Set the timelock and emit a `TimelockInitiated` event.\r\n    _setTimelock(\r\n      this.modifyTimelockExpiration.selector,\r\n      abi.encode(functionSelector, newTimelockExpiration),\r\n      extraTime\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Sets a new timelock expiration for a given function selector. The\r\n   * default for this function may also be modified, but has a minimum allowable\r\n   * value of one hour. Only the owner may call this function.\r\n   * @param functionSelector the selector of the function to set the timelock\r\n   * expiration for.\r\n   * @param newTimelockExpiration The new timelock expiration to set for the\r\n   * given function selector.\r\n   */\r\n  function modifyTimelockExpiration(\r\n    bytes4 functionSelector, uint256 newTimelockExpiration\r\n  ) external onlyOwner {\r\n    // Ensure that a function selector is specified (no 0x00000000 selector).\r\n    require(\r\n      functionSelector != bytes4(0),\r\n      \"Function selector cannot be empty.\"\r\n    );\r\n\r\n    // Continue via logic in the inherited `_modifyTimelockExpiration` function.\r\n    _modifyTimelockExpiration(\r\n      functionSelector, newTimelockExpiration\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Get a count of total prior implementations for a given controller\r\n   * and upgrade beacon.\r\n   * @param controller address of controller that was used to set the\r\n   * implementations.\r\n   * @param beacon address of upgrade beacon that the implementations were set\r\n   * on.\r\n   * @return The total number of prior implementations.\r\n   */\r\n  function getTotalPriorImplementations(\r\n    address controller, address beacon\r\n  ) external view returns (uint256 totalPriorImplementations) {\r\n    // Get the total number of prior implementation contracts.\r\n    totalPriorImplementations = _implementations[controller][beacon].length;\r\n  }\r\n\r\n  /**\r\n   * @notice Get an implementation contract that has been used in the past for a\r\n   * specific controller and beacon by index, and determine whether or not the\r\n   * implementation can be rolled back to or not.\r\n   * @param controller address of controller that was used to set the\r\n   * implementation.\r\n   * @param beacon address of upgrade beacon that the implementation was set on.\r\n   * @param index uint256 the index of the implementation.\r\n   * @return The address of the prior implementation if one exists and a boolean\r\n   * representing whether or not the prior implementation can be rolled back to.\r\n   */\r\n  function getPriorImplementation(\r\n    address controller, address beacon, uint256 index\r\n  ) external view returns (address priorImplementation, bool rollbackAllowed) {\r\n    // Ensure that there is an implementation address with the given index.\r\n    require(\r\n      _implementations[controller][beacon].length > index,\r\n      \"No implementation contract found with the given index.\"\r\n    );\r\n\r\n    // Get information on the specified prior implementation contract.\r\n    PriorImplementation memory implementation = (\r\n      _implementations[controller][beacon][index]\r\n    );\r\n\r\n    priorImplementation = implementation.implementation;\r\n    rollbackAllowed = (\r\n      priorImplementation != address(0) && !implementation.rollbackBlocked\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Determine if the Adharma Contingency state is currently armed or\r\n   * activated, and if so, what time it was activated. An upgrade to arbitrary\r\n   * smart wallet and key ring implementations can be performed by the owner\r\n   * after 48 hours has elapsed in the contingency state.\r\n   */\r\n  function contingencyStatus() external view returns (\r\n    bool armed, bool activated, uint256 activationTime\r\n  ) {\r\n    AdharmaContingency memory adharma = _adharma;\r\n\r\n    armed = adharma.armed;\r\n    activated = adharma.activated;\r\n    activationTime = adharma.activationTime;\r\n  }\r\n\r\n  /**\r\n   * @notice Determine if the deadman's switch has expired and get the time at\r\n   * which it is set to expire (i.e. 90 days from the last heartbeat).\r\n   * @return A boolean signifying whether the upgrade beacon controller is in an\r\n   * expired state, as well as the expiration time.\r\n   */\r\n  function heartbeatStatus() external view returns (\r\n    bool expired, uint256 expirationTime\r\n  ) {\r\n    (expired, expirationTime) = _heartbeatStatus();\r\n  }\r\n\r\n  /**\r\n   * @notice Internal view function to determine if the deadman's switch has\r\n   * expired and to get the time at which it is set to expire (i.e. 90 days from\r\n   * the last heartbeat).\r\n   * @return A boolean signifying whether the upgrade beacon controller is in an\r\n   * expired state, as well as the expiration time.\r\n   */\r\n  function _heartbeatStatus() internal view returns (\r\n    bool expired, uint256 expirationTime\r\n  ) {\r\n    expirationTime = _lastHeartbeat + 90 days;\r\n    expired = now > expirationTime;\r\n  }\r\n\r\n  /**\r\n   * @notice Private function that sets a new implementation address on an\r\n   * upgrade beacon contract.\r\n   * @param controller address of controller to call into that will trigger the\r\n   * update to the specified upgrade beacon.\r\n   * @param beacon address of upgrade beacon to set the new implementation on.\r\n   * @param implementation the address of the new implementation.\r\n   */\r\n  function _upgrade(\r\n    address controller, address beacon, address implementation\r\n  ) private {\r\n    // Ensure that the implementaton contract is not the null address.\r\n    require(\r\n      implementation != address(0),\r\n      \"Implementation cannot be the null address.\"\r\n    );\r\n\r\n    // Ensure that the implementation contract has code via extcodesize.\r\n    uint256 size;\r\n    assembly {\r\n      size := extcodesize(implementation)\r\n    }\r\n    require(size > 0, \"Implementation must have contract code.\");\r\n\r\n    // Try to get current implementation and store it as a prior implementation.\r\n    (bool ok, bytes memory returnData) = beacon.call(\"\");\r\n    if (ok && returnData.length == 32) {\r\n      address currentImplementation = abi.decode(returnData, (address));\r\n\r\n      _implementations[controller][beacon].push(PriorImplementation({\r\n        implementation: currentImplementation,\r\n        rollbackBlocked: false\r\n      }));\r\n    }\r\n\r\n    // Trigger the upgrade to the new implementation contract.\r\n    UpgradeBeaconControllerInterface(controller).upgrade(\r\n      beacon, implementation\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Private function that exits the Adharma Contingency if currently\r\n   * active and triggers a heartbeat.\r\n   */\r\n  function _exitAdharmaContingencyIfActiveAndTriggerHeartbeat() private {\r\n    // Exit the contingency state if there is currently one active or armed.\r\n    if (_adharma.activated || _adharma.armed) {\r\n\r\n      // Only emit an `AdharmaContingencyExited` if it is actually activated.\r\n      if (_adharma.activated) {\r\n        emit AdharmaContingencyExited();\r\n      }\r\n\r\n      delete _adharma;\r\n    }\r\n\r\n    // Reset the heartbeat to the current time.\r\n    _lastHeartbeat = now;\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to enforce that either the owner is the\r\n   * caller, or that the deadman's switch has been activated as a result of 90\r\n   * days passing without a heartbeat.\r\n   */\r\n  function _ensureCallerIsOwnerOrDeadmansSwitchActivated() private view {\r\n    // Do not check if heartbeat has expired if the owner is the caller.\r\n    if (!isOwner()) {\r\n      // Determine if 90 days have passed since the last heartbeat.\r\n      (bool expired, ) = _heartbeatStatus();\r\n\r\n      // Ensure that the deadman's switch is active.\r\n      require(\r\n        expired,\r\n        \"Only callable by the owner or after 90 days without a heartbeat.\"\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Private view function to enforce that this contract is still the\r\n   * owner of the Dharma Smart Wallet Upgrade Beacon Controller and the Dharma\r\n   * Key Ring Upgrade Beacon Controller prior to triggering the Adharma\r\n   * Contingency, or prior to upgrading those contracts on exiting the Adharma\r\n   * Contingency.\r\n   */\r\n  function _ensureOwnershipOfSmartWalletAndKeyRingControllers() private view {\r\n    // Ensure this contract still owns the required upgrade beacon controllers.\r\n    require(\r\n      TwoStepOwnable(_SMART_WALLET_UPGRADE_BEACON_CONTROLLER).isOwner(),\r\n      \"This contract no longer owns the Smart Wallet Upgrade Beacon Controller.\"\r\n    );\r\n    require(\r\n      TwoStepOwnable(_KEY_RING_UPGRADE_BEACON_CONTROLLER).isOwner(),\r\n      \"This contract no longer owns the Key Ring Upgrade Beacon Controller.\"\r\n    );\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"heartbeatStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"expired\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"extraTime\",\"type\":\"uint256\"}],\"name\":\"initiateTransferControllerOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"rollback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"extraTime\",\"type\":\"uint256\"}],\"name\":\"initiateUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"}],\"name\":\"getDefaultTimelockInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"defaultTimelockInterval\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activateAdharmaContingency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"heartbeat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferControllerOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"blockRollback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contingencyStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"armed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"activated\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"activationTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"newTimelockInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraTime\",\"type\":\"uint256\"}],\"name\":\"initiateModifyTimelockInterval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getPriorImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"priorImplementation\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"rollbackAllowed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartWalletImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keyRingImplementation\",\"type\":\"address\"}],\"name\":\"exitAdharmaContingency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"armed\",\"type\":\"bool\"}],\"name\":\"armAdharmaContingency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"heartbeater\",\"type\":\"address\"}],\"name\":\"newHeartbeater\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"}],\"name\":\"getDefaultTimelockExpiration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"defaultTimelockExpiration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"newTimelockExpiration\",\"type\":\"uint256\"}],\"name\":\"modifyTimelockExpiration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"willAcceptOwnership\",\"type\":\"bool\"}],\"name\":\"agreeToAcceptControllerOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"getTotalPriorImplementations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalPriorImplementations\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"newTimelockInterval\",\"type\":\"uint256\"}],\"name\":\"modifyTimelockInterval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"arguments\",\"type\":\"bytes\"}],\"name\":\"getTimelock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"expired\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"completionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"newTimelockExpiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraTime\",\"type\":\"uint256\"}],\"name\":\"initiateModifyTimelockExpiration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeComplete\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"arguments\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeExpired\",\"type\":\"uint256\"}],\"name\":\"TimelockInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newInterval\",\"type\":\"uint256\"}],\"name\":\"TimelockIntervalModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldExpiration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newExpiration\",\"type\":\"uint256\"}],\"name\":\"TimelockExpirationModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AdharmaContingencyActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AdharmaContingencyExited\",\"type\":\"event\"}]","ContractName":"DharmaUpgradeBeaconControllerManager","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://2055706772616465426561636f6e436f6e74726f6c6c65724d616e6167657220"}]}