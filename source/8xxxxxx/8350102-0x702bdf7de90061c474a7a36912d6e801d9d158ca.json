{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.7;\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'EuPi' token contract\r\n//\r\n// Symbol      : EuPi\r\n// Name        : EuPi \r\n// Total supply: 100,000,000\r\n// Decimals    : 18\r\n//\r\n// Contact: <info@cryptopi.fund>, http://CryptoPi.fund\r\n//\r\n//\r\n// Inspired by a contract template \r\n// from https://github.com/bitfwdcommunity/Issue-your-own-ERC20-token\r\n// ----------------------------------------------------------------------------\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\ncontract SafeMath {\r\n    uint256 constant private MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    function safeAdd (uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        assert (x <= MAX_UINT256 - y);\r\n        return x + y;\r\n    }\r\n\r\n    function safeSub (uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        assert (x >= y);\r\n        return x - y;\r\n    }\r\n\r\n    function safeMul (uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        if (y == 0) return 0;\r\n        assert (x <= MAX_UINT256 / y);\r\n        return x * y;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call\r\n// Borrowed from MiniMeToken\r\n// ----------------------------------------------------------------------------\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address internal owner;\r\n    address internal ownerToTransferTo;\r\n\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        ownerToTransferTo = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == ownerToTransferTo);\r\n        emit OwnershipTransferred(owner, ownerToTransferTo);\r\n        owner = ownerToTransferTo;\r\n        ownerToTransferTo = address(0);\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Pausable contract\r\n// ----------------------------------------------------------------------------\r\ncontract Pausable is Owned {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    modifier notPaused() {\r\n        require(!paused, \"this contract is suspened, come later\");\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused, \"contract must be paused\");\r\n        _;\r\n    }\r\n\r\n    function pause() public onlyOwner notPaused {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Transfer fees abstraction\r\n// ----------------------------------------------------------------------------\r\ncontract TransferFee is Owned, SafeMath {\r\n\r\n    event ChangedFee (\r\n        uint256 fixedFee,\r\n        uint256 minVariableFee,\r\n        uint256 maxVariableFee,\r\n        uint256 variableFee\r\n    );\r\n\r\n    // Variable fee is denomintated in 0.001% with maximum 100%\r\n    uint256 constant internal VARIABLE_FEE_DENOMINATOR = 100000;\r\n\r\n    mapping (address => bool) internal zeroFeeAddress;\r\n    address internal feeCollector; // address recieving fees\r\n    uint256 internal flatFee; // flat fee in tokens\r\n    uint256 internal variableFee; // variable fee in denominated %%\r\n    uint256 internal minVariableFee; // minumum variable fee in tokens\r\n    uint256 internal maxVariableFee; // maximum variable fee in tokens\r\n\r\n    constructor () public {\r\n        flatFee = 0; // in tokens\r\n        variableFee = 100; // in denominated %%, 0.1% = 1000 * 0.1\r\n        minVariableFee = 0; // in tokens\r\n        maxVariableFee =  // in tokens, not limited\r\n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff - flatFee;\r\n        feeCollector = owner;\r\n\r\n        zeroFeeAddress[address(this)] = true;\r\n    }\r\n\r\n    function calculateFee (address from, address to, uint256 amount) public view returns (uint256 _fee) {\r\n        if (zeroFeeAddress[from] || from == owner) return 0;\r\n        if (zeroFeeAddress[to] || to == owner) return 0;\r\n\r\n        _fee = safeMul (amount, variableFee) / VARIABLE_FEE_DENOMINATOR;\r\n        if (_fee < minVariableFee) _fee = minVariableFee;\r\n        if (_fee > maxVariableFee) _fee = maxVariableFee;\r\n        _fee = safeAdd (_fee, flatFee);\r\n    }\r\n\r\n    function setFeeCollector (address _newFeeCollector) public onlyOwner {\r\n        feeCollector = _newFeeCollector;\r\n    }\r\n\r\n    function setZeroFee (address _address) public onlyOwner {\r\n        zeroFeeAddress [_address] = true;\r\n    }\r\n\r\n    function getFeeParameters () public view returns (\r\n        uint256 _flatFee,\r\n        uint256 _minVariableFee,\r\n        uint256 _maxVariableFee,\r\n        uint256 _variableFee) \r\n    {\r\n        _flatFee = flatFee;\r\n        _minVariableFee = minVariableFee;\r\n        _maxVariableFee = maxVariableFee;\r\n        _variableFee = variableFee;\r\n    }\r\n\r\n    function setFeeParameters (\r\n        uint256 _flatFee,\r\n        uint256 _minVariableFee,\r\n        uint256 _maxVariableFee,\r\n        uint256 _variableFee) public onlyOwner\r\n    {\r\n        require (_minVariableFee <= _maxVariableFee, \"minimum variable fee should be less than maximum one\");\r\n        require (_variableFee <= VARIABLE_FEE_DENOMINATOR, \"variable fee should be less than 100%\");\r\n\r\n        flatFee = _flatFee;\r\n        minVariableFee = _minVariableFee;\r\n        maxVariableFee = _maxVariableFee;\r\n        variableFee = _variableFee;\r\n\r\n        emit ChangedFee (_flatFee, _minVariableFee, _maxVariableFee, _variableFee);\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\r\n// token transfers\r\n// ----------------------------------------------------------------------------\r\ncontract EuPi is IERC20, Owned, Pausable, SafeMath, TransferFee {\r\n    string public constant symbol = \"EuPi\";\r\n    string public constant name = \"EuPi\";\r\n    uint8 public constant decimals = 18; // !!! It must be 18, until decimals alignment is implemented in ()\r\n    \r\n    uint256 private _totalSupply;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowed;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor() public {\r\n        // 100,000,000 and 18 decimals\r\n        _totalSupply = 100000000000000000000000000;\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply - _balances[address(0)];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public view returns (uint256 balance) {\r\n        return _balances[tokenOwner];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - zero amount transfers are _allowed, but do nothing\r\n    // - We don't check it the contract is paused, take care in a public method\r\n    // ------------------------------------------------------------------------\r\n    function noFeeTransfer(address to, uint256 tokens) internal returns (bool success) {\r\n        require(to != address(0), \"not zero address is required\");\r\n\r\n        uint256 fromBalance = _balances [msg.sender];\r\n        if (fromBalance < tokens) return false;\r\n        if (tokens > 0 && msg.sender != to) {\r\n            _balances [msg.sender] = safeSub (fromBalance, tokens);\r\n            _balances [to] = safeAdd (_balances [to], tokens);\r\n        }\r\n        // to simplify consumer app logic we emit event even if nothing has been changed\r\n        emit Transfer (msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 tokens) public notPaused returns (bool success) {\r\n        uint256 fee = calculateFee (msg.sender, to, tokens);\r\n        if (tokens <= _balances [msg.sender] &&\r\n          fee <= safeSub (_balances [msg.sender], tokens)) {\r\n            // we've done all the prechecks before, following transfers must never fail\r\n            assert (noFeeTransfer (to, tokens));\r\n            assert (noFeeTransfer (feeCollector, fee));\r\n            return true;\r\n        } else return false;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint256 tokens) public notPaused \r\n    returns (bool success) {\r\n        _allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // - The calling account must already have sufficient allowance (approved tokens) \r\n    // for spending from the from account\r\n    // - From account must have sufficient balance to transfer\r\n    // - Zero amount transfers are _allowed\r\n    // - We don't check it the contract is paused, take care in a public method\r\n    // ------------------------------------------------------------------------\r\n    function noFeeTransferFrom (address from, address to, uint256 tokens) \r\n    internal returns (bool success) {\r\n        require(to != address(0), \"not zero address is required\");\r\n\r\n        uint256 allowance = _allowed [from][msg.sender];\r\n        if (allowance < tokens) return false;\r\n        uint256 fromBalance = _balances [from];\r\n        if (fromBalance < tokens) return false;\r\n\r\n        if (tokens > 0 && from != to) {\r\n            _balances [from] = safeSub (fromBalance, tokens);\r\n            _allowed [from][msg.sender] = safeSub (allowance, tokens);\r\n            _balances [to] = safeAdd (_balances [to], tokens);\r\n        }\r\n        // to simplify consumer app logic we emit event even if nothing has been changed\r\n        emit Transfer (from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokens) public notPaused \r\n    returns (bool success) {\r\n        require(to != address(0), \"not zero address is required\");\r\n        \r\n        uint256 fee = calculateFee (msg.sender, to, tokens);\r\n        uint256 fromBalance = _balances [from];\r\n        uint256 allowance = _allowed [from][msg.sender];\r\n\r\n        // after deduction of the principal amount:\r\n        // - there must be enough allowance to cover transaction fee\r\n        // - there must be enough balance to cover transaction fee  \r\n        if (\r\n            tokens <= allowance && fee <= safeSub (allowance, tokens) && \r\n            tokens <= fromBalance && fee <= safeSub (fromBalance, tokens)\r\n            )\r\n        {\r\n            // we've done all the prechecks before, following transfers must never fail\r\n            assert (noFeeTransferFrom (from, to, tokens));\r\n            assert (noFeeTransferFrom (from, feeCollector, fee));\r\n            return true;\r\n        } else return false;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public view \r\n    returns (uint256 remaining) {\r\n        return _allowed[tokenOwner][spender];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve spender to transferFrom(...) tokens\r\n    // from the token owner account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // Borrowed from MiniMeToken\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint256 tokens, bytes memory data) public notPaused\r\n    returns (bool _success) {\r\n        _allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can increase approval for spender to transferFrom(...) tokens\r\n    // from the token owner's account.\r\n    // From MonolithDAO Token.sol\r\n    // ------------------------------------------------------------------------\r\n    function increaseApproval(address spender, uint256 addedValue) public notPaused \r\n    returns (bool) {\r\n        _allowed[msg.sender][spender] = (\r\n            safeAdd(_allowed[msg.sender][spender], addedValue));\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can reduce approval for spender to transferFrom(...) tokens\r\n    // from the token owner's account.\r\n    // From MonolithDAO Token.sol\r\n    // ------------------------------------------------------------------------\r\n    function decreaseApproval(address spender, uint256 substractedValue) public notPaused\r\n    returns (bool) {\r\n        uint256 oldValue = _allowed[msg.sender][spender];\r\n        if (substractedValue > oldValue) {\r\n            _allowed[msg.sender][spender] = 0;\r\n        } else {\r\n            _allowed[msg.sender][spender] = safeSub(oldValue, substractedValue);\r\n        }\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Allows any ERC20 tokens accidentially sent to this contract's address \r\n    // to be transferred out\r\n    // ------------------------------------------------------------------------\r\n    function claimERC20(address tokenAddress, address to, uint256 amount) public onlyOwner returns (bool _success) {\r\n        return \r\n            IERC20(tokenAddress).transfer(\r\n                to,\r\n                amount > 0 ? amount : \r\n                    IERC20(tokenAddress).balanceOf(address(this))\r\n            );\r\n    }\r\n\r\n    function claimETH(address payable to, uint256 amount) public returns (bool _success) {\r\n        require(msg.sender == owner);\r\n        return to.send(amount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimETH\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeeParameters\",\"outputs\":[{\"name\":\"_flatFee\",\"type\":\"uint256\"},{\"name\":\"_minVariableFee\",\"type\":\"uint256\"},{\"name\":\"_maxVariableFee\",\"type\":\"uint256\"},{\"name\":\"_variableFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"substractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setZeroFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateFee\",\"outputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFeeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_flatFee\",\"type\":\"uint256\"},{\"name\":\"_minVariableFee\",\"type\":\"uint256\"},{\"name\":\"_maxVariableFee\",\"type\":\"uint256\"},{\"name\":\"_variableFee\",\"type\":\"uint256\"}],\"name\":\"setFeeParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimERC20\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fixedFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"minVariableFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"maxVariableFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"variableFee\",\"type\":\"uint256\"}],\"name\":\"ChangedFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"EuPi","CompilerVersion":"v0.5.7+commit.6da8b019","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4310b2b528133e645dd8dc1fd5e218f5334d6bd3977bc83f860c4f4f799e9219"}]}