{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/interfaces/IContractRegistry.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n// File: contracts/interfaces/IERC20Token.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {}\r\n    function symbol() public view returns (string) {}\r\n    function decimals() public view returns (uint8) {}\r\n    function totalSupply() public view returns (uint256) {}\r\n    function balanceOf(address _owner) public view returns (uint256) { _owner; }\r\n    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n// File: contracts/interfaces/IPegSettings.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\ncontract IPegSettings {\r\n\r\n    function authorized(address _address) public view returns (bool) { _address; }\r\n    \r\n    function authorize(address _address, bool _auth) public;\r\n    function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public;\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IVault.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\ncontract IVault {\r\n\r\n    function registry() public view returns (IContractRegistry);\r\n\r\n    function auctions(address _borrower) public view returns (address) { _borrower; }\r\n    function vaultExists(address _vault) public view returns (bool) { _vault; }\r\n    function totalBorrowed(address _vault) public view returns (uint256) { _vault; }\r\n    function rawBalanceOf(address _vault) public view returns (uint256) { _vault; }\r\n    function rawDebt(address _vault) public view returns (uint256) { _vault; }\r\n    function rawTotalBalance() public view returns (uint256);\r\n    function rawTotalDebt() public view returns (uint256);\r\n    function collateralBorrowedRatio() public view returns (uint256);\r\n    function amountMinted() public view returns (uint256);\r\n\r\n    function debtScalePrevious() public view returns (uint256);\r\n    function debtScaleTimestamp() public view returns (uint256);\r\n    function debtScaleRate() public view returns (int256);\r\n    function balScalePrevious() public view returns (uint256);\r\n    function balScaleTimestamp() public view returns (uint256);\r\n    function balScaleRate() public view returns (int256);\r\n    \r\n    function liquidationRatio() public view returns (uint32);\r\n    function maxBorrowLTV() public view returns (uint32);\r\n\r\n    function borrowingEnabled() public view returns (bool);\r\n    function biddingTime() public view returns (uint);\r\n\r\n    function setType(bool _type) public;\r\n    function create(address _vault) public;\r\n    function setCollateralBorrowedRatio(uint _newRatio) public;\r\n    function setAmountMinted(uint _amountMinted) public;\r\n    function setLiquidationRatio(uint32 _liquidationRatio) public;\r\n    function setMaxBorrowLTV(uint32 _maxBorrowLTV) public;\r\n    function setDebtScalingRate(int256 _debtScalingRate) public;\r\n    function setBalanceScalingRate(int256 _balanceScalingRate) public;\r\n    function setBiddingTime(uint _biddingTime) public;\r\n    function setRawTotalDebt(uint _rawTotalDebt) public;\r\n    function setRawTotalBalance(uint _rawTotalBalance) public;\r\n    function setRawBalanceOf(address _borrower, uint _rawBalance) public;\r\n    function setRawDebt(address _borrower, uint _rawDebt) public;\r\n    function setTotalBorrowed(address _borrower, uint _totalBorrowed) public;\r\n    function debtScalingFactor() public view returns (uint256);\r\n    function balanceScalingFactor() public view returns (uint256);\r\n    function debtRawToActual(uint256 _raw) public view returns (uint256);\r\n    function debtActualToRaw(uint256 _actual) public view returns (uint256);\r\n    function balanceRawToActual(uint256 _raw) public view returns (uint256);\r\n    function balanceActualToRaw(uint256 _actual) public view returns (uint256);\r\n    function getVaults(address _vault, uint256 _balanceOf) public view returns(address[]);\r\n    function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public;\r\n    function oracleValue() public view returns(uint256);\r\n    function emitBorrow(address _borrower, uint256 _amount) public;\r\n    function emitRepay(address _borrower, uint256 _amount) public;\r\n    function emitDeposit(address _borrower, uint256 _amount) public;\r\n    function emitWithdraw(address _borrower, address _to, uint256 _amount) public;\r\n    function emitLiquidate(address _borrower) public;\r\n    function emitAuctionStarted(address _borrower) public;\r\n    function emitAuctionEnded(address _borrower, address _highestBidder, uint256 _highestBid) public;\r\n    function setAuctionAddress(address _borrower, address _auction) public;\r\n}\r\n\r\n// File: contracts/interfaces/IPegOracle.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\ncontract IPegOracle {\r\n    function getValue() public view returns (uint256);\r\n}\r\n\r\n// File: contracts/interfaces/IOwned.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n    function setOwner(address _newOwner) public;\r\n}\r\n\r\n// File: contracts/interfaces/ISmartToken.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is IOwned, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/interfaces/IStableToken.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\ncontract IStableToken is ISmartToken {\r\n    \r\n    function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public;\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IPegLogic.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\ncontract IPegLogic {\r\n\r\n    function adjustCollateralBorrowingRate() public;\r\n    function isInsolvent(IVault _vault, address _borrower) public view returns (bool);\r\n    function actualDebt(IVault _vault, address _address) public view returns(uint256);\r\n    function excessCollateral(IVault _vault, address _borrower) public view returns (int256);\r\n    function availableCredit(IVault _vault, address _borrower) public view returns (int256);\r\n    function getCollateralToken(IVault _vault) public view returns(IERC20Token);\r\n    function getDebtToken(IVault _vault) public view returns(IStableToken);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IAuctionActions.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\ncontract IAuctionActions {\r\n\r\n    function startAuction(IVault _vault, address _borrower) public;\r\n    function endAuction(IVault _vault, address _borrower) public;\r\n\r\n}\r\n\r\n// File: contracts/ContractIds.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\ncontract ContractIds {\r\n    bytes32 public constant STABLE_TOKEN = \"StableToken\";\r\n    bytes32 public constant COLLATERAL_TOKEN = \"CollateralToken\";\r\n\r\n    bytes32 public constant PEGUSD_TOKEN = \"PEGUSD\";\r\n\r\n    bytes32 public constant VAULT_A = \"VaultA\";\r\n    bytes32 public constant VAULT_B = \"VaultB\";\r\n\r\n    bytes32 public constant PEG_LOGIC = \"PegLogic\";\r\n    bytes32 public constant PEG_LOGIC_ACTIONS = \"LogicActions\";\r\n    bytes32 public constant AUCTION_ACTIONS = \"AuctionActions\";\r\n\r\n    bytes32 public constant PEG_SETTINGS = \"PegSettings\";\r\n    bytes32 public constant ORACLE = \"Oracle\";\r\n    bytes32 public constant FEE_RECIPIENT = \"StabilityFeeRecipient\";\r\n}\r\n\r\n// File: contracts/Helpers.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Helpers is ContractIds {\r\n\r\n    IContractRegistry public registry;\r\n\r\n    constructor(IContractRegistry _registry) public {\r\n        registry = _registry;\r\n    }\r\n\r\n    modifier authOnly() {\r\n        require(settings().authorized(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier validate(IVault _vault, address _borrower) {\r\n        require(address(_vault) == registry.addressOf(ContractIds.VAULT_A) || address(_vault) == registry.addressOf(ContractIds.VAULT_B));\r\n        _vault.create(_borrower);\r\n        _;\r\n    }\r\n\r\n    function stableToken() internal returns(IStableToken) {\r\n        return IStableToken(registry.addressOf(ContractIds.STABLE_TOKEN));\r\n    }\r\n\r\n    function collateralToken() internal returns(IERC20Token) {\r\n        return IERC20Token(registry.addressOf(ContractIds.COLLATERAL_TOKEN));\r\n    }\r\n\r\n    function PEGUSD() internal returns(IERC20Token) {\r\n        return IERC20Token(registry.addressOf(ContractIds.PEGUSD_TOKEN));\r\n    }\r\n\r\n    function vaultA() internal returns(IVault) {\r\n        return IVault(registry.addressOf(ContractIds.VAULT_A));\r\n    }\r\n\r\n    function vaultB() internal returns(IVault) {\r\n        return IVault(registry.addressOf(ContractIds.VAULT_B));\r\n    }\r\n\r\n    function oracle() internal returns(IPegOracle) {\r\n        return IPegOracle(registry.addressOf(ContractIds.ORACLE));\r\n    }\r\n\r\n    function settings() internal returns(IPegSettings) {\r\n        return IPegSettings(registry.addressOf(ContractIds.PEG_SETTINGS));\r\n    }\r\n\r\n    function pegLogic() internal returns(IPegLogic) {\r\n        return IPegLogic(registry.addressOf(ContractIds.PEG_LOGIC));\r\n    }\r\n\r\n    function auctionActions() internal returns(IAuctionActions) {\r\n        return IAuctionActions(registry.addressOf(ContractIds.AUCTION_ACTIONS));\r\n    }\r\n\r\n    function transferERC20Token(IERC20Token _token, address _to, uint256 _amount) public authOnly {\r\n        _token.transfer(_to, _amount);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/library/SafeMath.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\nlibrary SafeMath {\r\n    function plus(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        assert(c >= _a);\r\n        return c;\r\n    }\r\n\r\n    function plus(int256 _a, int256 _b) internal pure returns (int256) {\r\n        int256 c = _a + _b;\r\n        assert((_b >= 0 && c >= _a) || (_b < 0 && c < _a));\r\n        return c;\r\n    }\r\n\r\n    function minus(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        assert(_a >= _b);\r\n        return _a - _b;\r\n    }\r\n\r\n    function minus(int256 _a, int256 _b) internal pure returns (int256) {\r\n        int256 c = _a - _b;\r\n        assert((_b >= 0 && c <= _a) || (_b < 0 && c > _a));\r\n        return c;\r\n    }\r\n\r\n    function times(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = _a * _b;\r\n        assert(c / _a == _b);\r\n        return c;\r\n    }\r\n\r\n    function times(int256 _a, int256 _b) internal pure returns (int256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n        int256 c = _a * _b;\r\n        assert(c / _a == _b);\r\n        return c;\r\n    }\r\n\r\n    function toInt256(uint256 _a) internal pure returns (int256) {\r\n        assert(_a <= 2 ** 255);\r\n        return int256(_a);\r\n    }\r\n\r\n    function toUint256(int256 _a) internal pure returns (uint256) {\r\n        assert(_a >= 0);\r\n        return uint256(_a);\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a / _b;\r\n    }\r\n\r\n    function div(int256 _a, int256 _b) internal pure returns (int256) {\r\n        return _a / _b;\r\n    }\r\n}\r\n\r\n// File: contracts/PegLogic.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract PegLogic is Helpers {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath for int256;\r\n\r\n    IContractRegistry public registry;\r\n\r\n    constructor(IContractRegistry _registry) public Helpers(_registry) {\r\n        registry = _registry;\r\n    }\r\n\r\n    function collateralValue(IVault _vault, address _borrower) public view validate(_vault, _borrower) returns(uint) {\r\n        return actualBalance(_vault, _borrower).times(_vault.oracleValue()) / 1e6;\r\n    }\r\n\r\n    function liquidationPrice(IVault _vault, address _borrower) public view validate(_vault, _borrower) returns(uint) {\r\n        return actualBalance(_vault, _borrower).times(_vault.liquidationRatio()) / 1e6;\r\n    }\r\n\r\n    function totalCredit(IVault _vault, address _borrower) public view validate(_vault, _borrower) returns (int256) {\r\n        return (collateralValue(_vault, _borrower).times(_vault.maxBorrowLTV()) / 1e6).toInt256();\r\n    }\r\n\r\n    function availableCredit(IVault _vault, address _borrower) public view returns (int256) {\r\n        return totalCredit(_vault, _borrower).minus(actualDebt(_vault, _borrower).toInt256());\r\n    }\r\n\r\n    function minSafeBalance(IVault _vault, address _borrower) public view validate(_vault, _borrower) returns (uint256) {\r\n        return actualDebt(_vault, _borrower).times(1e12) / _vault.oracleValue() / _vault.maxBorrowLTV();\r\n    }\r\n\r\n    function minBalance(IVault _vault, address _borrower) public view validate(_vault, _borrower) returns (uint256) {\r\n        return actualDebt(_vault, _borrower).times(1e12) / _vault.oracleValue() / _vault.liquidationRatio();\r\n    }\r\n\r\n    function excessCollateral(IVault _vault, address _borrower) public view returns (int256) {\r\n        return int(actualBalance(_vault, _borrower)).minus(int(minSafeBalance(_vault, _borrower)));\r\n    }\r\n\r\n    function isInsolvent(IVault _vault, address _borrower) public view returns (bool) {\r\n        return (actualDebt(_vault, _borrower) > 0 && actualBalance(_vault, _borrower) < minBalance(_vault, _borrower));\r\n    }\r\n\r\n    function totalActualDebt(IVault _vault) public view returns(uint) {\r\n        return _vault.debtRawToActual(_vault.rawTotalDebt());\r\n    }\r\n\r\n    function mintableAmount(IVault _vault) public view returns(uint) {\r\n        return totalActualDebt(_vault).minus(stableToken().totalSupply());\r\n    }\r\n\r\n    function ratioVaultABorrowed() public view returns(uint256) {\r\n        return vaultB().debtRawToActual(vaultB().rawTotalDebt()).times(1e18) / actualTotalBalance(vaultA());\r\n    }\r\n\r\n    function actualTotalBalance(IVault _vault) public view returns(uint256) {\r\n        return _vault.balanceRawToActual(_vault.rawTotalBalance());\r\n    }\r\n\r\n    function actualDebt(IVault _vault, address _address) public view returns(uint256) {\r\n        return _vault.debtRawToActual(_vault.rawDebt(_address));\r\n    }\r\n\r\n    function actualBalance(IVault _vault, address _address) public view returns(uint256) {\r\n        return _vault.balanceRawToActual(_vault.rawBalanceOf(_address));\r\n    }\r\n\r\n    function adjustDebtStabilityFee(IVault _vault, bool _increaseStabilityFee) public authOnly {\r\n        if(_increaseStabilityFee) {\r\n            _vault.setDebtScalingRate(_vault.debtScaleRate().minus(1e8));\r\n        }else{\r\n            _vault.setDebtScalingRate(_vault.debtScaleRate().plus(1e8));\r\n        }\r\n    }\r\n\r\n    function adjustCollateralBorrowingRate() public authOnly {\r\n        int secondsInYear = 31540000;\r\n        int ratio = int(ratioVaultABorrowed());\r\n        int newRate = (ratio * 2 - 15e17) * -100 / secondsInYear;\r\n        if(ratio < 8e17) {\r\n            newRate = ratio * 100 / (secondsInYear * -8);\r\n        }\r\n        if(vaultB().rawTotalDebt() > 0)\r\n            setCollateralBorrowingRate(newRate);\r\n    }\r\n\r\n    function processStabilityFee(IVault _vault) public {\r\n        mintStabletoken(registry.addressOf(ContractIds.FEE_RECIPIENT), mintableAmount(_vault));\r\n    }\r\n\r\n    function setCollateralBorrowingRate(int newRate) internal {\r\n        vaultB().setDebtScalingRate(newRate/1e2);\r\n        vaultA().setBalanceScalingRate(newRate * int(ratioVaultABorrowed()) / 1e20);\r\n    }\r\n\r\n    function mintStabletoken(address _to, uint _amount) internal {\r\n        vaultA().setAmountMinted(vaultA().amountMinted().plus(_amount));\r\n        stableToken().issue(_to, _amount);\r\n    }\r\n\r\n    function getCollateralToken(IVault _vault) public view returns(IERC20Token) {\r\n        if (address(_vault) == address(vaultA())) {\r\n            return collateralToken();\r\n        } else {\r\n            return stableToken();\r\n        }\r\n    }\r\n\r\n    function getDebtToken(IVault _vault) public view returns(IStableToken) {\r\n        if (address(_vault) == address(vaultA())) {\r\n            return stableToken();\r\n        } else {\r\n            return IStableToken(collateralToken());\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"isInsolvent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"actualDebt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"actualBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"liquidationPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VAULT_B\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PEG_LOGIC_ACTIONS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"collateralValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"minSafeBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ORACLE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"adjustCollateralBorrowingRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VAULT_A\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"totalActualDebt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ratioVaultABorrowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"processStabilityFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STABLE_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferERC20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUCTION_ACTIONS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"availableCredit\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"minBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"excessCollateral\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"getDebtToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_increaseStabilityFee\",\"type\":\"bool\"}],\"name\":\"adjustDebtStabilityFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"mintableAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"totalCredit\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PEG_SETTINGS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PEG_LOGIC\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE_RECIPIENT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"getCollateralToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"actualTotalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COLLATERAL_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PEGUSD_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"PegLogic","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e68ebda2488c213cf4ba25a7a7da179f96ce0baf","Library":"","SwarmSource":"bzzr://33f0ef93fd7bfdad318040680ca764a15d16f4c579868a19d331972b23796711"}]}