{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.11;\r\n\r\n/// @title Ownable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev The Ownable contract has an owner address, and provides basic\r\n///      authorization control functions, this simplifies the implementation of\r\n///      \"user permissions\".\r\ncontract Ownable\r\n{\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract\r\n    ///      to the sender.\r\n    constructor()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a\r\n    ///      new owner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"ZERO_ADDRESS\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function renounceOwnership()\r\n        public\r\n        onlyOwner\r\n    {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n/// @title Claimable\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Extension for the Ownable contract, where the ownership needs\r\n///      to be claimed. This allows the new owner to accept the transfer.\r\ncontract Claimable is Ownable\r\n{\r\n    address public pendingOwner;\r\n\r\n    /// @dev Modifier throws if called by any account other than the pendingOwner.\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"UNAUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to set the pendingOwner address.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0) && newOwner != owner, \"INVALID_ADDRESS\");\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /// @dev Allows the pendingOwner address to finalize the transfer.\r\n    function claimOwnership()\r\n        public\r\n        onlyPendingOwner\r\n    {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n/// @title ReentrancyGuard\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @dev Exposes a modifier that guards a function against reentrancy\r\n///      Changing the value of the same storage value multiple times in a transaction\r\n///      is cheap (starting from Istanbul) so there is no need to minimize\r\n///      the number of times the value is changed\r\ncontract ReentrancyGuard\r\n{\r\n    //The default value must be 0 in order to work behind a proxy.\r\n    uint private _guardValue;\r\n\r\n    // Use this modifier on a function to prevent reentrancy\r\n    modifier nonReentrant()\r\n    {\r\n        // Check if the guard value has its original value\r\n        require(_guardValue == 0, \"REENTRANCY\");\r\n\r\n        // Set the value to something else\r\n        _guardValue = 1;\r\n\r\n        // Function body\r\n        _;\r\n\r\n        // Set the value back\r\n        _guardValue = 0;\r\n    }\r\n}\r\n\r\n/// @title Utility Functions for uint\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\nlibrary MathUint\r\n{\r\n    function mul(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"MUL_OVERFLOW\");\r\n    }\r\n\r\n    function sub(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        require(b <= a, \"SUB_UNDERFLOW\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(\r\n        uint a,\r\n        uint b\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"ADD_OVERFLOW\");\r\n    }\r\n\r\n    function decodeFloat(\r\n        uint f\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint value)\r\n    {\r\n        uint numBitsMantissa = 23;\r\n        uint exponent = f >> numBitsMantissa;\r\n        uint mantissa = f & ((1 << numBitsMantissa) - 1);\r\n        value = mantissa * (10 ** exponent);\r\n    }\r\n}\r\n\r\n/// @title IAddressWhitelist\r\n/// @author Daniel Wang - <daniel@loopring.org>\r\ncontract IAddressWhitelist\r\n{\r\n    /// @dev Check if a address is whitelisted.\r\n    /// @param user The user to check if being whitelisted.\r\n    /// @param permission An arbitrary data from caller to indicate permission.\r\n    /// @return true if the address is whitelisted\r\n    function isWhitelisted(\r\n        address user,\r\n        bytes   memory permission\r\n        )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n/// @title Poseidon hash function\r\n///        See: https://eprint.iacr.org/2019/458.pdf\r\n///        Code auto-generated by generate_poseidon_EVM_code.py\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary Poseidon\r\n{\r\n    function hash_t5f6p52(\r\n        uint t0,\r\n        uint t1,\r\n        uint t2,\r\n        uint t3,\r\n        uint t4\r\n        )\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        uint q = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n        // Make sure the inputs can be stored in the SNARK field\r\n        require(t0 < q, \"INVALID_INPUT\");\r\n        require(t1 < q, \"INVALID_INPUT\");\r\n        require(t2 < q, \"INVALID_INPUT\");\r\n        require(t3 < q, \"INVALID_INPUT\");\r\n        require(t4 < q, \"INVALID_INPUT\");\r\n\r\n        assembly {\r\n            function mix(t0, t1, t2, t3, t4, q) -> nt0, nt1, nt2, nt3, nt4 {\r\n                nt0 := mulmod(t0, 4977258759536702998522229302103997878600602264560359702680165243908162277980, q)\r\n                nt0 := addmod(nt0, mulmod(t1, 19167410339349846567561662441069598364702008768579734801591448511131028229281, q), q)\r\n                nt0 := addmod(nt0, mulmod(t2, 14183033936038168803360723133013092560869148726790180682363054735190196956789, q), q)\r\n                nt0 := addmod(nt0, mulmod(t3, 9067734253445064890734144122526450279189023719890032859456830213166173619761, q), q)\r\n                nt0 := addmod(nt0, mulmod(t4, 16378664841697311562845443097199265623838619398287411428110917414833007677155, q), q)\r\n                nt1 := mulmod(t0, 107933704346764130067829474107909495889716688591997879426350582457782826785, q)\r\n                nt1 := addmod(nt1, mulmod(t1, 17034139127218860091985397764514160131253018178110701196935786874261236172431, q), q)\r\n                nt1 := addmod(nt1, mulmod(t2, 2799255644797227968811798608332314218966179365168250111693473252876996230317, q), q)\r\n                nt1 := addmod(nt1, mulmod(t3, 2482058150180648511543788012634934806465808146786082148795902594096349483974, q), q)\r\n                nt1 := addmod(nt1, mulmod(t4, 16563522740626180338295201738437974404892092704059676533096069531044355099628, q), q)\r\n                nt2 := mulmod(t0, 13596762909635538739079656925495736900379091964739248298531655823337482778123, q)\r\n                nt2 := addmod(nt2, mulmod(t1, 18985203040268814769637347880759846911264240088034262814847924884273017355969, q), q)\r\n                nt2 := addmod(nt2, mulmod(t2, 8652975463545710606098548415650457376967119951977109072274595329619335974180, q), q)\r\n                nt2 := addmod(nt2, mulmod(t3, 970943815872417895015626519859542525373809485973005165410533315057253476903, q), q)\r\n                nt2 := addmod(nt2, mulmod(t4, 19406667490568134101658669326517700199745817783746545889094238643063688871948, q), q)\r\n                nt3 := mulmod(t0, 2953507793609469112222895633455544691298656192015062835263784675891831794974, q)\r\n                nt3 := addmod(nt3, mulmod(t1, 19025623051770008118343718096455821045904242602531062247152770448380880817517, q), q)\r\n                nt3 := addmod(nt3, mulmod(t2, 9077319817220936628089890431129759976815127354480867310384708941479362824016, q), q)\r\n                nt3 := addmod(nt3, mulmod(t3, 4770370314098695913091200576539533727214143013236894216582648993741910829490, q), q)\r\n                nt3 := addmod(nt3, mulmod(t4, 4298564056297802123194408918029088169104276109138370115401819933600955259473, q), q)\r\n                nt4 := mulmod(t0, 8336710468787894148066071988103915091676109272951895469087957569358494947747, q)\r\n                nt4 := addmod(nt4, mulmod(t1, 16205238342129310687768799056463408647672389183328001070715567975181364448609, q), q)\r\n                nt4 := addmod(nt4, mulmod(t2, 8303849270045876854140023508764676765932043944545416856530551331270859502246, q), q)\r\n                nt4 := addmod(nt4, mulmod(t3, 20218246699596954048529384569730026273241102596326201163062133863539137060414, q), q)\r\n                nt4 := addmod(nt4, mulmod(t4, 1712845821388089905746651754894206522004527237615042226559791118162382909269, q), q)\r\n            }\r\n\r\n            function ark(t0, t1, t2, t3, t4, q, c) -> nt0, nt1, nt2, nt3, nt4 {\r\n                nt0 := addmod(t0, c, q)\r\n                nt1 := addmod(t1, c, q)\r\n                nt2 := addmod(t2, c, q)\r\n                nt3 := addmod(t3, c, q)\r\n                nt4 := addmod(t4, c, q)\r\n            }\r\n\r\n            function sbox_full(t0, t1, t2, t3, t4, q) -> nt0, nt1, nt2, nt3, nt4 {\r\n                nt0 := mulmod(t0, t0, q)\r\n                nt0 := mulmod(nt0, nt0, q)\r\n                nt0 := mulmod(t0, nt0, q)\r\n                nt1 := mulmod(t1, t1, q)\r\n                nt1 := mulmod(nt1, nt1, q)\r\n                nt1 := mulmod(t1, nt1, q)\r\n                nt2 := mulmod(t2, t2, q)\r\n                nt2 := mulmod(nt2, nt2, q)\r\n                nt2 := mulmod(t2, nt2, q)\r\n                nt3 := mulmod(t3, t3, q)\r\n                nt3 := mulmod(nt3, nt3, q)\r\n                nt3 := mulmod(t3, nt3, q)\r\n                nt4 := mulmod(t4, t4, q)\r\n                nt4 := mulmod(nt4, nt4, q)\r\n                nt4 := mulmod(t4, nt4, q)\r\n            }\r\n\r\n            function sbox_partial(t, q) -> nt {\r\n                nt := mulmod(t, t, q)\r\n                nt := mulmod(nt, nt, q)\r\n                nt := mulmod(t, nt, q)\r\n            }\r\n\r\n            // round 0\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14397397413755236225575615486459253198602422701513067526754101844196324375522)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 1\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10405129301473404666785234951972711717481302463898292859783056520670200613128)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 2\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 5179144822360023508491245509308555580251733042407187134628755730783052214509)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 3\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9132640374240188374542843306219594180154739721841249568925550236430986592615)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 4\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20360807315276763881209958738450444293273549928693737723235350358403012458514)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 5\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17933600965499023212689924809448543050840131883187652471064418452962948061619)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 6\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3636213416533737411392076250708419981662897009810345015164671602334517041153)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 7\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2008540005368330234524962342006691994500273283000229509835662097352946198608)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 8\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16018407964853379535338740313053768402596521780991140819786560130595652651567)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 9\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20653139667070586705378398435856186172195806027708437373983929336015162186471)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 10\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17887713874711369695406927657694993484804203950786446055999405564652412116765)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 11\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4852706232225925756777361208698488277369799648067343227630786518486608711772)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 12\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8969172011633935669771678412400911310465619639756845342775631896478908389850)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 13\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20570199545627577691240476121888846460936245025392381957866134167601058684375)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 14\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16442329894745639881165035015179028112772410105963688121820543219662832524136)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 15\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20060625627350485876280451423010593928172611031611836167979515653463693899374)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 16\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16637282689940520290130302519163090147511023430395200895953984829546679599107)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 17\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15599196921909732993082127725908821049411366914683565306060493533569088698214)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 18\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16894591341213863947423904025624185991098788054337051624251730868231322135455)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 19\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 1197934381747032348421303489683932612752526046745577259575778515005162320212)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 20\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6172482022646932735745595886795230725225293469762393889050804649558459236626)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 21\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21004037394166516054140386756510609698837211370585899203851827276330669555417)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 22\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15262034989144652068456967541137853724140836132717012646544737680069032573006)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 23\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15017690682054366744270630371095785995296470601172793770224691982518041139766)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 24\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15159744167842240513848638419303545693472533086570469712794583342699782519832)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 25\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11178069035565459212220861899558526502477231302924961773582350246646450941231)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 26\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21154888769130549957415912997229564077486639529994598560737238811887296922114)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 27\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20162517328110570500010831422938033120419484532231241180224283481905744633719)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 28\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2777362604871784250419758188173029886707024739806641263170345377816177052018)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 29\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15732290486829619144634131656503993123618032247178179298922551820261215487562)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 30\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6024433414579583476444635447152826813568595303270846875177844482142230009826)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 31\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17677827682004946431939402157761289497221048154630238117709539216286149983245)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 32\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10716307389353583413755237303156291454109852751296156900963208377067748518748)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 33\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14925386988604173087143546225719076187055229908444910452781922028996524347508)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 34\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8940878636401797005293482068100797531020505636124892198091491586778667442523)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 35\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 18911747154199663060505302806894425160044925686870165583944475880789706164410)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 36\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8821532432394939099312235292271438180996556457308429936910969094255825456935)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 37\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20632576502437623790366878538516326728436616723089049415538037018093616927643)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 38\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 71447649211767888770311304010816315780740050029903404046389165015534756512)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 39\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2781996465394730190470582631099299305677291329609718650018200531245670229393)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 40\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 12441376330954323535872906380510501637773629931719508864016287320488688345525)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 41\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2558302139544901035700544058046419714227464650146159803703499681139469546006)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 42\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10087036781939179132584550273563255199577525914374285705149349445480649057058)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 43\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4267692623754666261749551533667592242661271409704769363166965280715887854739)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 44\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4945579503584457514844595640661884835097077318604083061152997449742124905548)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 45\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17742335354489274412669987990603079185096280484072783973732137326144230832311)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 46\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6266270088302506215402996795500854910256503071464802875821837403486057988208)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 47\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2716062168542520412498610856550519519760063668165561277991771577403400784706)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 48\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 19118392018538203167410421493487769944462015419023083813301166096764262134232)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 49\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9386595745626044000666050847309903206827901310677406022353307960932745699524)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 50\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9121640807890366356465620448383131419933298563527245687958865317869840082266)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 51\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3078975275808111706229899605611544294904276390490742680006005661017864583210)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 52\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 7157404299437167354719786626667769956233708887934477609633504801472827442743)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 53\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14056248655941725362944552761799461694550787028230120190862133165195793034373)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 54\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14124396743304355958915937804966111851843703158171757752158388556919187839849)\r\n            t0 := sbox_partial(t0, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 55\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11851254356749068692552943732920045260402277343008629727465773766468466181076)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 56\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9799099446406796696742256539758943483211846559715874347178722060519817626047)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n            // round 57\r\n            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10156146186214948683880719664738535455146137901666656566575307300522957959544)\r\n            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\r\n            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\r\n        }\r\n        return t0;\r\n    }\r\n}\r\n\r\n/// @title ExchangeBalances.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeBalances\r\n{\r\n    using MathUint  for uint;\r\n\r\n    function verifyAccountBalance(\r\n        uint     merkleRoot,\r\n        uint24   accountID,\r\n        uint16   tokenID,\r\n        uint     pubKeyX,\r\n        uint     pubKeyY,\r\n        uint32   nonce,\r\n        uint96   balance,\r\n        uint     tradeHistoryRoot,\r\n        uint[30] calldata accountMerkleProof,\r\n        uint[12] calldata balanceMerkleProof\r\n        )\r\n        external\r\n        pure\r\n    {\r\n        bool isCorrect = isAccountBalanceCorrect(\r\n            merkleRoot,\r\n            accountID,\r\n            tokenID,\r\n            pubKeyX,\r\n            pubKeyY,\r\n            nonce,\r\n            balance,\r\n            tradeHistoryRoot,\r\n            accountMerkleProof,\r\n            balanceMerkleProof\r\n        );\r\n        require(isCorrect, \"INVALID_MERKLE_TREE_DATA\");\r\n    }\r\n\r\n    function isAccountBalanceCorrect(\r\n        uint     merkleRoot,\r\n        uint24   accountID,\r\n        uint16   tokenID,\r\n        uint     pubKeyX,\r\n        uint     pubKeyY,\r\n        uint32   nonce,\r\n        uint96   balance,\r\n        uint     tradeHistoryRoot,\r\n        uint[30] memory accountMerkleProof,\r\n        uint[12] memory balanceMerkleProof\r\n        )\r\n        public\r\n        pure\r\n        returns (bool isCorrect)\r\n    {\r\n        // Verify data\r\n        uint calculatedRoot = getBalancesRoot(\r\n            tokenID,\r\n            balance,\r\n            tradeHistoryRoot,\r\n            balanceMerkleProof\r\n        );\r\n        calculatedRoot = getAccountInternalsRoot(\r\n            accountID,\r\n            pubKeyX,\r\n            pubKeyY,\r\n            nonce,\r\n            calculatedRoot,\r\n            accountMerkleProof\r\n        );\r\n        isCorrect = (calculatedRoot == merkleRoot);\r\n    }\r\n\r\n    function getBalancesRoot(\r\n        uint16   tokenID,\r\n        uint     balance,\r\n        uint     tradeHistoryRoot,\r\n        uint[12] memory balanceMerkleProof\r\n        )\r\n        private\r\n        pure\r\n        returns (uint)\r\n    {\r\n        uint balanceItem = hashImpl(balance, tradeHistoryRoot, 0, 0);\r\n        uint _id = tokenID;\r\n        for (uint depth = 0; depth < 4; depth++) {\r\n            if (_id & 3 == 0) {\r\n                balanceItem = hashImpl(\r\n                    balanceItem,\r\n                    balanceMerkleProof[depth * 3],\r\n                    balanceMerkleProof[depth * 3 + 1],\r\n                    balanceMerkleProof[depth * 3 + 2]\r\n                );\r\n            } else if (_id & 3 == 1) {\r\n                balanceItem = hashImpl(\r\n                    balanceMerkleProof[depth * 3],\r\n                    balanceItem,\r\n                    balanceMerkleProof[depth * 3 + 1],\r\n                    balanceMerkleProof[depth * 3 + 2]\r\n                );\r\n            } else if (_id & 3 == 2) {\r\n                balanceItem = hashImpl(\r\n                    balanceMerkleProof[depth * 3],\r\n                    balanceMerkleProof[depth * 3 + 1],\r\n                    balanceItem,\r\n                    balanceMerkleProof[depth * 3 + 2]\r\n                );\r\n            } else if (_id & 3 == 3) {\r\n                balanceItem = hashImpl(\r\n                    balanceMerkleProof[depth * 3],\r\n                    balanceMerkleProof[depth * 3 + 1],\r\n                    balanceMerkleProof[depth * 3 + 2],\r\n                    balanceItem\r\n                );\r\n            }\r\n            _id = _id >> 2;\r\n        }\r\n        return balanceItem;\r\n    }\r\n\r\n    function getAccountInternalsRoot(\r\n        uint24   accountID,\r\n        uint     pubKeyX,\r\n        uint     pubKeyY,\r\n        uint     nonce,\r\n        uint     balancesRoot,\r\n        uint[30] memory accountMerkleProof\r\n        )\r\n        private\r\n        pure\r\n        returns (uint)\r\n    {\r\n        uint accountItem = hashImpl(pubKeyX, pubKeyY, nonce, balancesRoot);\r\n        uint _id = accountID;\r\n        for (uint depth = 0; depth < 10; depth++) {\r\n            if (_id & 3 == 0) {\r\n                accountItem = hashImpl(\r\n                    accountItem,\r\n                    accountMerkleProof[depth * 3],\r\n                    accountMerkleProof[depth * 3 + 1],\r\n                    accountMerkleProof[depth * 3 + 2]\r\n                );\r\n            } else if (_id & 3 == 1) {\r\n                accountItem = hashImpl(\r\n                    accountMerkleProof[depth * 3],\r\n                    accountItem,\r\n                    accountMerkleProof[depth * 3 + 1],\r\n                    accountMerkleProof[depth * 3 + 2]\r\n                );\r\n            } else if (_id & 3 == 2) {\r\n                accountItem = hashImpl(\r\n                    accountMerkleProof[depth * 3],\r\n                    accountMerkleProof[depth * 3 + 1],\r\n                    accountItem,\r\n                    accountMerkleProof[depth * 3 + 2]\r\n                );\r\n            } else if (_id & 3 == 3) {\r\n                accountItem = hashImpl(\r\n                    accountMerkleProof[depth * 3],\r\n                    accountMerkleProof[depth * 3 + 1],\r\n                    accountMerkleProof[depth * 3 + 2],\r\n                    accountItem\r\n                );\r\n            }\r\n            _id = _id >> 2;\r\n        }\r\n        return accountItem;\r\n    }\r\n\r\n    function hashImpl(\r\n        uint t0,\r\n        uint t1,\r\n        uint t2,\r\n        uint t3\r\n        )\r\n        private\r\n        pure\r\n        returns (uint)\r\n    {\r\n        return Poseidon.hash_t5f6p52(t0, t1, t2, t3, 0);\r\n    }\r\n}\r\n\r\n/// @title IBlockVerifier\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\ncontract IBlockVerifier\r\n{\r\n    // -- Events --\r\n\r\n    event CircuitRegistered(\r\n        uint8  indexed blockType,\r\n        bool           onchainDataAvailability,\r\n        uint16         blockSize,\r\n        uint8          blockVersion\r\n    );\r\n\r\n    event CircuitDisabled(\r\n        uint8  indexed blockType,\r\n        bool           onchainDataAvailability,\r\n        uint16         blockSize,\r\n        uint8          blockVersion\r\n    );\r\n\r\n    // -- Public functions --\r\n\r\n    /// @dev Sets the verifying key for the specified circuit.\r\n    ///      Every block permutation needs its own circuit and thus its own set of\r\n    ///      verification keys. Only a limited number of block sizes per block\r\n    ///      type are supported.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @param vk The verification key\r\n    function registerCircuit(\r\n        uint8    blockType,\r\n        bool     onchainDataAvailability,\r\n        uint16   blockSize,\r\n        uint8    blockVersion,\r\n        uint[18] calldata vk\r\n        )\r\n        external;\r\n\r\n    /// @dev Disables the use of the specified circuit.\r\n    ///      This will stop NEW blocks from using the given circuit, blocks that were already committed\r\n    ///      can still be verified.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    function disableCircuit(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external;\r\n\r\n    /// @dev Verify blocks with the given public data and proofs.\r\n    ///      Verifying a block makes sure all requests handled in the block\r\n    ///      are correctly handled by the operator.\r\n    /// @param blockType The type of block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @param publicInputs The hash of all the public data of the blocks\r\n    /// @param proofs The ZK proofs proving that the blocks are correct\r\n    /// @return True if the block is valid, false otherwise\r\n    function verifyProofs(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion,\r\n        uint[] calldata publicInputs,\r\n        uint[] calldata proofs\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Checks if a circuit with the specified parameters is registered.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @return True if the circuit is registered, false otherwise\r\n    function isCircuitRegistered(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Checks if a circuit can still be used to commit new blocks.\r\n    /// @param blockType The type of the block See @BlockType\r\n    /// @param onchainDataAvailability True if the block expects onchain\r\n    ///        data availability data as public input, false otherwise\r\n    /// @param blockSize The number of requests handled in the block\r\n    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\r\n    /// @return True if the circuit is enabled, false otherwise\r\n    function isCircuitEnabled(\r\n        uint8  blockType,\r\n        bool   onchainDataAvailability,\r\n        uint16 blockSize,\r\n        uint8  blockVersion\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n/// @title ILoopring\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract ILoopring is Claimable, ReentrancyGuard\r\n{\r\n    address public protocolRegistry;\r\n    address public lrcAddress;\r\n    uint    public exchangeCreationCostLRC;\r\n\r\n    event ExchangeInitialized(\r\n        uint    indexed exchangeId,\r\n        address indexed exchangeAddress,\r\n        address indexed owner,\r\n        address         operator,\r\n        bool            onchainDataAvailability\r\n    );\r\n\r\n    /// @dev Initialize and register an exchange.\r\n    ///      This function should only be callabled by the protocolRegistry contract.\r\n    ///      Also note that this function can only be called once per exchange instance.\r\n    /// @param  exchangeAddress The address of the exchange to initialize and register.\r\n    /// @param  exchangeId The unique exchange id.\r\n    /// @param  owner The owner of the exchange.\r\n    /// @param  operator The operator of the exchange.\r\n    /// @param  onchainDataAvailability True if \"Data Availability\" is turned on for this\r\n    ///         exchange. Note that this value can not be changed once the exchange is initialized.\r\n    /// @return exchangeId The id of the exchange.\r\n    function initializeExchange(\r\n        address exchangeAddress,\r\n        uint    exchangeId,\r\n        address owner,\r\n        address payable operator,\r\n        bool    onchainDataAvailability\r\n        )\r\n        external;\r\n}\r\n\r\n/// @title ILoopringV3\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\ncontract ILoopringV3 is ILoopring\r\n{\r\n    // == Events ==\r\n\r\n    event ExchangeStakeDeposited(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ExchangeStakeWithdrawn(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ExchangeStakeBurned(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ProtocolFeeStakeDeposited(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event ProtocolFeeStakeWithdrawn(\r\n        uint    indexed exchangeId,\r\n        uint            amount\r\n    );\r\n\r\n    event SettingsUpdated(\r\n        uint            time\r\n    );\r\n\r\n    // == Public Variables ==\r\n    struct Exchange\r\n    {\r\n        address exchangeAddress;\r\n        uint    exchangeStake;\r\n        uint    protocolFeeStake;\r\n    }\r\n\r\n    mapping (uint => Exchange) internal exchanges;\r\n\r\n    uint    public totalStake;\r\n\r\n    address public wethAddress;\r\n    address public exchangeDeployerAddress;\r\n    address public blockVerifierAddress;\r\n    address public downtimeCostCalculator;\r\n    uint    public maxWithdrawalFee;\r\n    uint    public withdrawalFineLRC;\r\n    uint    public tokenRegistrationFeeLRCBase;\r\n    uint    public tokenRegistrationFeeLRCDelta;\r\n    uint    public minExchangeStakeWithDataAvailability;\r\n    uint    public minExchangeStakeWithoutDataAvailability;\r\n    uint    public revertFineLRC;\r\n    uint8   public minProtocolTakerFeeBips;\r\n    uint8   public maxProtocolTakerFeeBips;\r\n    uint8   public minProtocolMakerFeeBips;\r\n    uint8   public maxProtocolMakerFeeBips;\r\n    uint    public targetProtocolTakerFeeStake;\r\n    uint    public targetProtocolMakerFeeStake;\r\n\r\n    address payable public protocolFeeVault;\r\n\r\n    // == Public Functions ==\r\n    /// @dev Update the global exchange settings.\r\n    ///      This function can only be called by the owner of this contract.\r\n    ///\r\n    ///      Warning: these new values will be used by existing and\r\n    ///      new Loopring exchanges.\r\n    function updateSettings(\r\n        address payable _protocolFeeVault,   // address(0) not allowed\r\n        address _blockVerifierAddress,       // address(0) not allowed\r\n        address _downtimeCostCalculator,     // address(0) allowed\r\n        uint    _exchangeCreationCostLRC,\r\n        uint    _maxWithdrawalFee,\r\n        uint    _tokenRegistrationFeeLRCBase,\r\n        uint    _tokenRegistrationFeeLRCDelta,\r\n        uint    _minExchangeStakeWithDataAvailability,\r\n        uint    _minExchangeStakeWithoutDataAvailability,\r\n        uint    _revertFineLRC,\r\n        uint    _withdrawalFineLRC\r\n        )\r\n        external;\r\n\r\n    /// @dev Update the global protocol fee settings.\r\n    ///      This function can only be called by the owner of this contract.\r\n    ///\r\n    ///      Warning: these new values will be used by existing and\r\n    ///      new Loopring exchanges.\r\n    function updateProtocolFeeSettings(\r\n        uint8 _minProtocolTakerFeeBips,\r\n        uint8 _maxProtocolTakerFeeBips,\r\n        uint8 _minProtocolMakerFeeBips,\r\n        uint8 _maxProtocolMakerFeeBips,\r\n        uint  _targetProtocolTakerFeeStake,\r\n        uint  _targetProtocolMakerFeeStake\r\n        )\r\n        external;\r\n\r\n    /// @dev Returns whether the Exchange has staked enough to commit blocks\r\n    ///      Exchanges with on-chain data-availaiblity need to stake at least\r\n    ///      minExchangeStakeWithDataAvailability, exchanges without\r\n    ///      data-availability need to stake at least\r\n    ///      minExchangeStakeWithoutDataAvailability.\r\n    /// @param exchangeId The id of the exchange\r\n    /// @param onchainDataAvailability True if the exchange has on-chain\r\n    ///        data-availability, else false\r\n    /// @return True if the exchange has staked enough, else false\r\n    function canExchangeCommitBlocks(\r\n        uint exchangeId,\r\n        bool onchainDataAvailability\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Get the amount of staked LRC for an exchange.\r\n    /// @param exchangeId The id of the exchange\r\n    /// @return stakedLRC The amount of LRC\r\n    function getExchangeStake(\r\n        uint exchangeId\r\n        )\r\n        public\r\n        view\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Burn a certain amount of staked LRC for a specific exchange.\r\n    ///      This function is meant to be called only from exchange contracts.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @return burnedLRC The amount of LRC burned. If the amount is greater than\r\n    ///         the staked amount, all staked LRC will be burned.\r\n    function burnExchangeStake(\r\n        uint exchangeId,\r\n        uint amount\r\n        )\r\n        external\r\n        returns (uint burnedLRC);\r\n\r\n    /// @dev Stake more LRC for an exchange.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  amountLRC The amount of LRC to stake\r\n    /// @return stakedLRC The total amount of LRC staked for the exchange\r\n    function depositExchangeStake(\r\n        uint exchangeId,\r\n        uint amountLRC\r\n        )\r\n        external\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Withdraw a certain amount of staked LRC for an exchange to the given address.\r\n    ///      This function is meant to be called only from within exchange contracts.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  recipient The address to receive LRC\r\n    /// @param  requestedAmount The amount of LRC to withdraw\r\n    /// @return stakedLRC The amount of LRC withdrawn\r\n    function withdrawExchangeStake(\r\n        uint    exchangeId,\r\n        address recipient,\r\n        uint    requestedAmount\r\n        )\r\n        external\r\n        returns (uint amount);\r\n\r\n    /// @dev Stake more LRC for an exchange.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  amountLRC The amount of LRC to stake\r\n    /// @return stakedLRC The total amount of LRC staked for the exchange\r\n    function depositProtocolFeeStake(\r\n        uint exchangeId,\r\n        uint amountLRC\r\n        )\r\n        external\r\n        returns (uint stakedLRC);\r\n\r\n    /// @dev Withdraw a certain amount of staked LRC for an exchange to the given address.\r\n    ///      This function is meant to be called only from within exchange contracts.\r\n    /// @param  exchangeId The id of the exchange\r\n    /// @param  recipient The address to receive LRC\r\n    /// @param  amount The amount of LRC to withdraw\r\n    function withdrawProtocolFeeStake(\r\n        uint    exchangeId,\r\n        address recipient,\r\n        uint    amount\r\n        )\r\n        external;\r\n\r\n    /// @dev Get the protocol fee values for an exchange.\r\n    /// @param exchangeId The id of the exchange\r\n    /// @param onchainDataAvailability True if the exchange has on-chain\r\n    ///        data-availability, else false\r\n    /// @return takerFeeBips The protocol taker fee\r\n    /// @return makerFeeBips The protocol maker fee\r\n    function getProtocolFeeValues(\r\n        uint exchangeId,\r\n        bool onchainDataAvailability\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint8 takerFeeBips,\r\n            uint8 makerFeeBips\r\n        );\r\n\r\n    /// @dev Returns the exchange's protocol fee stake.\r\n    /// @param  exchangeId The exchange's id.\r\n    /// @return protocolFeeStake The exchange's protocol fee stake.\r\n    function getProtocolFeeStake(\r\n        uint exchangeId\r\n        )\r\n        external\r\n        view\r\n        returns (uint protocolFeeStake);\r\n}\r\n\r\n/// @title ExchangeData\r\n/// @dev All methods in this lib are internal, therefore, there is no need\r\n///      to deploy this library independently.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeData\r\n{\r\n    // -- Enums --\r\n    enum BlockType\r\n    {\r\n        RING_SETTLEMENT,\r\n        DEPOSIT,\r\n        ONCHAIN_WITHDRAWAL,\r\n        OFFCHAIN_WITHDRAWAL,\r\n        ORDER_CANCELLATION,\r\n        TRANSFER\r\n    }\r\n\r\n    enum BlockState\r\n    {\r\n        // This value should never be seen onchain, but we want to reserve 0 so the\r\n        // relayer can use this as the default for new blocks.\r\n        NEW,            // = 0\r\n\r\n        // The default state when a new block is included onchain.\r\n        COMMITTED,      // = 1\r\n\r\n        // A valid ZK proof has been submitted for this block.\r\n        // The genesis block is VERIFIED by default.\r\n        VERIFIED        // = 2\r\n    }\r\n\r\n    // -- Structs --\r\n    struct Account\r\n    {\r\n        address owner;\r\n\r\n        // pubKeyX and pubKeyY put together is the EdDSA public trading key. Users or their\r\n        // wallet software are supposed to manage the corresponding private key for signing\r\n        // orders and offchain requests.\r\n        //\r\n        // We use EdDSA because it is more circuit friendly than ECDSA. In later versions\r\n        // we may switch back to ECDSA, then we will not need such a dedicated tradig key-pair.\r\n        //\r\n        // We split the public key into two uint to make it more circuit friendly.\r\n        uint    pubKeyX;\r\n        uint    pubKeyY;\r\n    }\r\n\r\n    struct Token\r\n    {\r\n        address token;\r\n        bool    depositDisabled;\r\n    }\r\n\r\n    struct ProtocolFeeData\r\n    {\r\n        uint32 timestamp;\r\n        uint8 takerFeeBips;\r\n        uint8 makerFeeBips;\r\n        uint8 previousTakerFeeBips;\r\n        uint8 previousMakerFeeBips;\r\n    }\r\n\r\n    // This is the (virtual) block an operator needs to submit onchain to maintain the\r\n    // per-exchange (virtual) blockchain.\r\n    struct Block\r\n    {\r\n        // The merkle root of the offchain data stored in a merkle tree. The merkle tree\r\n        // stores balances for users using an account model.\r\n        bytes32 merkleRoot;\r\n\r\n        // The hash of all the public data sent in commitBlock. Committing a block\r\n        // is decoupled from the verification of a block, but we don't want to send\r\n        // the (often) large amount of data (certainly with onchain data availability) again\r\n        // when verifying the proof, so we hash all that data onchain in commitBlock so that we\r\n        // can use it in verifyBlock to verify the block. This also makes the verification cheaper\r\n        // onchain because we only have this single public input.\r\n        bytes32 publicDataHash;\r\n\r\n        // The current state of the block. See @BlockState for more information.\r\n        BlockState state;\r\n\r\n        // The type of the block (i.e. what kind of requests were processed).\r\n        // See @BlockType for more information.\r\n        BlockType blockType;\r\n\r\n        // The number of requests processed in the block. Only a limited number of permutations\r\n        // are available for each block type (because each will need a different circuit\r\n        // and thus different verification key onchain). Use IBlockVerifier.canVerify to find out if\r\n        // the block is supported.\r\n        uint16 blockSize;\r\n\r\n        // The block version (i.e. what circuit version needs to be used to verify the block).\r\n        uint8  blockVersion;\r\n\r\n        // The time the block was created.\r\n        uint32 timestamp;\r\n\r\n        // The number of onchain deposit requests that have been processed\r\n        // up to and including this block.\r\n        uint32 numDepositRequestsCommitted;\r\n\r\n        // The number of onchain withdrawal requests that have been processed\r\n        // up to and including this block.\r\n        uint32 numWithdrawalRequestsCommitted;\r\n\r\n        // Stores whether the fee earned by the operator for processing onchain requests\r\n        // is withdrawn or not.\r\n        bool   blockFeeWithdrawn;\r\n\r\n        // Number of withdrawals distributed using `distributeWithdrawals`\r\n        uint16 numWithdrawalsDistributed;\r\n\r\n        // The approved withdrawal data. Needs to be stored onchain so this data is available\r\n        // once the block is finalized and the funds can be withdrawn using the info stored\r\n        // in this data.\r\n        // For every withdrawal (there are 'blockSize' withdrawals),\r\n        // stored sequentially after each other:\r\n        //    - Token ID: 1 bytes\r\n        //    - Account ID: 2,5 bytes\r\n        //    - Amount: 3,5 bytes\r\n        bytes  withdrawals;\r\n    }\r\n\r\n    // Represents the post-state of an onchain deposit/withdrawal request. We can visualize\r\n    // a deposit request-chain and a withdrawal request-chain, each of which is\r\n    // composed of such Request objects. Please refer to the design doc for more details.\r\n    struct Request\r\n    {\r\n        bytes32 accumulatedHash;\r\n        uint    accumulatedFee;\r\n        uint32  timestamp;\r\n    }\r\n\r\n    // Represents an onchain deposit request.  `tokenID` being `0x0` means depositing Ether.\r\n    struct Deposit\r\n    {\r\n        uint24 accountID;\r\n        uint16 tokenID;\r\n        uint96 amount;\r\n    }\r\n\r\n    function SNARK_SCALAR_FIELD() internal pure returns (uint) {\r\n        // This is the prime number that is used for the alt_bn128 elliptic curve, see EIP-196.\r\n        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    }\r\n\r\n    function MAX_PROOF_GENERATION_TIME_IN_SECONDS() internal pure returns (uint32) { return 1 hours; }\r\n    function MAX_GAP_BETWEEN_FINALIZED_AND_VERIFIED_BLOCKS() internal pure returns (uint32) { return 2500; }\r\n    function MAX_OPEN_DEPOSIT_REQUESTS() internal pure returns (uint16) { return 1024; }\r\n    function MAX_OPEN_WITHDRAWAL_REQUESTS() internal pure returns (uint16) { return 1024; }\r\n    function MAX_AGE_UNFINALIZED_BLOCK_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 1 days; }\r\n    function MAX_AGE_REQUEST_UNTIL_FORCED() internal pure returns (uint32) { return 15 minutes; }\r\n    function MAX_AGE_REQUEST_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 1 days; }\r\n    function MAX_TIME_IN_SHUTDOWN_BASE() internal pure returns (uint32) { return 1 days; }\r\n    function MAX_TIME_IN_SHUTDOWN_DELTA() internal pure returns (uint32) { return 15 seconds; }\r\n    function TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() internal pure returns (uint32) { return 10 minutes; }\r\n    function MAX_NUM_TOKENS() internal pure returns (uint) { return 2 ** 8; }\r\n    function MAX_NUM_ACCOUNTS() internal pure returns (uint) { return 2 ** 20 - 1; }\r\n    function MAX_TIME_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 2 hours; }\r\n    function FEE_BLOCK_FINE_START_TIME() internal pure returns (uint32) { return 5 minutes; }\r\n    function FEE_BLOCK_FINE_MAX_DURATION() internal pure returns (uint32) { return 30 minutes; }\r\n    function MIN_GAS_TO_DISTRIBUTE_WITHDRAWALS() internal pure returns (uint32) { return 60000; }\r\n    function MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED() internal pure returns (uint32) { return 1 days; }\r\n    function GAS_LIMIT_SEND_TOKENS() internal pure returns (uint32) { return 30000; }\r\n\r\n    // Represents the entire exchange state except the owner of the exchange.\r\n    struct State\r\n    {\r\n        uint    id;\r\n        uint    exchangeCreationTimestamp;\r\n        address payable operator; // The only address that can submit new blocks.\r\n        bool    onchainDataAvailability;\r\n\r\n        ILoopringV3    loopring;\r\n        IBlockVerifier blockVerifier;\r\n\r\n        address lrcAddress;\r\n\r\n        uint    totalTimeInMaintenanceSeconds;\r\n        uint    numDowntimeMinutes;\r\n        uint    downtimeStart;\r\n\r\n        address addressWhitelist;\r\n        uint    accountCreationFeeETH;\r\n        uint    accountUpdateFeeETH;\r\n        uint    depositFeeETH;\r\n        uint    withdrawalFeeETH;\r\n\r\n        Block[]     blocks;\r\n        Token[]     tokens;\r\n        Account[]   accounts;\r\n        Deposit[]   deposits;\r\n        Request[]   depositChain;\r\n        Request[]   withdrawalChain;\r\n\r\n        // A map from the account owner to accountID + 1\r\n        mapping (address => uint24) ownerToAccountId;\r\n        mapping (address => uint16) tokenToTokenId;\r\n\r\n        // A map from an account owner to a token to if the balance is withdrawn\r\n        mapping (address => mapping (address => bool)) withdrawnInWithdrawMode;\r\n\r\n        // A map from token address to their accumulated balances\r\n        mapping (address => uint) tokenBalances;\r\n\r\n        // A block's state will become FINALIZED when and only when this block is VERIFIED\r\n        // and all previous blocks in the chain have become FINALIZED.\r\n        // The genesis block is FINALIZED by default.\r\n        uint numBlocksFinalized;\r\n\r\n        // Cached data for the protocol fee\r\n        ProtocolFeeData protocolFeeData;\r\n\r\n        // Time when the exchange was shutdown\r\n        uint shutdownStartTime;\r\n    }\r\n}\r\n\r\n/// @title ExchangeAccounts.\r\n/// @author Daniel Wang  - <daniel@loopring.org>\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\nlibrary ExchangeAccounts\r\n{\r\n    using MathUint          for uint;\r\n    using ExchangeBalances  for ExchangeData.State;\r\n\r\n    event AccountCreated(\r\n        address indexed owner,\r\n        uint24  indexed id,\r\n        uint            pubKeyX,\r\n        uint            pubKeyY\r\n    );\r\n\r\n    event AccountUpdated(\r\n        address indexed owner,\r\n        uint24  indexed id,\r\n        uint            pubKeyX,\r\n        uint            pubKeyY\r\n    );\r\n\r\n    // == Public Functions ==\r\n    function getAccount(\r\n        ExchangeData.State storage S,\r\n        address owner\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            uint24 accountID,\r\n            uint   pubKeyX,\r\n            uint   pubKeyY\r\n        )\r\n    {\r\n        accountID = getAccountID(S, owner);\r\n        ExchangeData.Account storage account = S.accounts[accountID];\r\n        pubKeyX = account.pubKeyX;\r\n        pubKeyY = account.pubKeyY;\r\n    }\r\n\r\n    function createOrUpdateAccount(\r\n        ExchangeData.State storage S,\r\n        uint  pubKeyX,\r\n        uint  pubKeyY,\r\n        bytes calldata permission\r\n        )\r\n        external\r\n        returns (\r\n            uint24 accountID,\r\n            bool   isAccountNew,\r\n            bool   isAccountUpdated\r\n        )\r\n    {\r\n        isAccountNew = (S.ownerToAccountId[msg.sender] == 0);\r\n        if (isAccountNew) {\r\n            if (S.addressWhitelist != address(0)) {\r\n                require(\r\n                    IAddressWhitelist(S.addressWhitelist).isWhitelisted(msg.sender, permission),\r\n                    \"ADDRESS_NOT_WHITELISTED\"\r\n                );\r\n            }\r\n            accountID = createAccount(S, pubKeyX, pubKeyY);\r\n            isAccountUpdated = false;\r\n        } else {\r\n            (accountID, isAccountUpdated) = updateAccount(S, pubKeyX, pubKeyY);\r\n        }\r\n    }\r\n\r\n    function getAccountID(\r\n        ExchangeData.State storage S,\r\n        address owner\r\n        )\r\n        public\r\n        view\r\n        returns (uint24 accountID)\r\n    {\r\n        accountID = S.ownerToAccountId[owner];\r\n        require(accountID != 0, \"ADDRESS_HAS_NO_ACCOUNT\");\r\n\r\n        accountID = accountID - 1;\r\n    }\r\n\r\n    function createAccount(\r\n        ExchangeData.State storage S,\r\n        uint pubKeyX,\r\n        uint pubKeyY\r\n        )\r\n        private\r\n        returns (uint24 accountID)\r\n    {\r\n        require(S.accounts.length < ExchangeData.MAX_NUM_ACCOUNTS(), \"ACCOUNTS_FULL\");\r\n        require(S.ownerToAccountId[msg.sender] == 0, \"ACCOUNT_EXISTS\");\r\n\r\n        accountID = uint24(S.accounts.length);\r\n        ExchangeData.Account memory account = ExchangeData.Account(\r\n            msg.sender,\r\n            pubKeyX,\r\n            pubKeyY\r\n        );\r\n\r\n        S.accounts.push(account);\r\n        S.ownerToAccountId[msg.sender] = accountID + 1;\r\n\r\n        emit AccountCreated(\r\n            msg.sender,\r\n            accountID,\r\n            pubKeyX,\r\n            pubKeyY\r\n        );\r\n    }\r\n\r\n    function updateAccount(\r\n        ExchangeData.State storage S,\r\n        uint pubKeyX,\r\n        uint pubKeyY\r\n        )\r\n        private\r\n        returns (\r\n            uint24 accountID,\r\n            bool   isAccountUpdated\r\n        )\r\n    {\r\n        require(S.ownerToAccountId[msg.sender] != 0, \"ACCOUNT_NOT_EXIST\");\r\n\r\n        accountID = S.ownerToAccountId[msg.sender] - 1;\r\n        ExchangeData.Account storage account = S.accounts[accountID];\r\n\r\n        isAccountUpdated = (account.pubKeyX != pubKeyX || account.pubKeyY != pubKeyY);\r\n        if (isAccountUpdated) {\r\n            account.pubKeyX = pubKeyX;\r\n            account.pubKeyY = pubKeyY;\r\n\r\n            emit AccountUpdated(\r\n                msg.sender,\r\n                accountID,\r\n                pubKeyX,\r\n                pubKeyY\r\n            );\r\n        }\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"id\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"}],\"name\":\"AccountCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint24\",\"name\":\"id\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyX\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pubKeyY\",\"type\":\"uint256\"}],\"name\":\"AccountUpdated\",\"type\":\"event\"}]","ContractName":"ExchangeAccounts","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8d9632f38908cbade5b3c1b4d62922fcd18b96001cdd248a37c9fec8587972ca"}]}