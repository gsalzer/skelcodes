{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\r\n * available, which can be aplied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/IAllocationStrategy.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n/**\r\n * @notice Allocation strategy for assets.\r\n *         - It invests the underlying assets into some yield generating contracts,\r\n *           usually lending contracts, in return it gets new assets aka. saving assets.\r\n *         - Sainv assets can be redeemed back to the underlying assets plus interest any time.\r\n */\r\ninterface IAllocationStrategy {\r\n\r\n    /**\r\n     * @notice Underlying asset for the strategy\r\n     * @return address Underlying asset address\r\n     */\r\n    function underlying() external view returns (address);\r\n\r\n    /**\r\n     * @notice Calculates the exchange rate from the underlying to the saving assets\r\n     * @return uint256 Calculated exchange rate scaled by 1e18\r\n     */\r\n    function exchangeRateStored() external view returns (uint256);\r\n\r\n    /**\r\n      * @notice Applies accrued interest to all savings\r\n      * @dev This should calculates interest accrued from the last checkpointed\r\n      *      block up to the current block and writes new checkpoint to storage.\r\n      * @return bool success(true) or failure(false)\r\n      */\r\n    function accrueInterest() external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender supplies underlying assets into the market and receives saving assets in exchange\r\n     * @dev Interst shall be accrued\r\n     * @param investAmount The amount of the underlying asset to supply\r\n     * @return uint256 Amount of saving assets created\r\n     */\r\n    function investUnderlying(uint256 investAmount) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Sender redeems saving assets in exchange for a specified amount of underlying asset\r\n     * @dev Interst shall be accrued\r\n     * @param redeemAmount The amount of underlying to redeem\r\n     * @return uint256 Amount of saving assets burned\r\n     */\r\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\r\n\r\n}\r\n\r\n// File: contracts/IRToken.sol\r\n\r\npragma solidity ^0.5.8;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n/**\r\n * @notice RToken interface a ERC20 interface and one can mint new tokens by\r\n *      trasfering underlying token into the contract, configure _hats_ for\r\n *      addresses and pay earned interest in new _rTokens_.\r\n */\r\ncontract IRToken is IERC20 {\r\n\r\n\r\n    /**\r\n     * @notice Global stats\r\n     */\r\n    struct GlobalStats {\r\n        /// @notice Total redeemable tokens supply\r\n        uint256 totalSupply;\r\n        /// @notice Total saving assets in redeemable amount\r\n        uint256 totalSavingsAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Stats for accounts\r\n     */\r\n    struct AccountStats {\r\n        /// @notice Cumulative interests paid\r\n        uint256 cumulativeInterest;\r\n    }\r\n\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // For external transactions\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @return uint 0=success, otherwise a failure\r\n     */\r\n    function mint(uint256 mintAmount) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\r\n     *         Also setting the a selected hat for the account.\r\n     * @param hatID The id of the selected Hat\r\n     * @return uint 0=success, otherwise a failure\r\n     */\r\n    function mintWithSelectedHat(uint256 mintAmount, uint256 hatID) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender supplies assets into the market and receives rTokens in exchange\r\n     *         Also setting the a new hat for the account.\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     * @param proportions Relative proportions of benefits received by the recipients\r\n     * @return uint 0=success, otherwise a failure\r\n     */\r\n    function mintWithNewHat(uint256 mintAmount,\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions) external returns (bool);\r\n\r\n    /**\r\n     * @notice Moves all tokens from the caller's account to `dst`.\r\n     */\r\n    function transferAll(address dst) external returns (bool);\r\n\r\n    /**\r\n     * @notice Moves all tokens from `src` account to `dst`.\r\n     */\r\n    function transferAllFrom(address src, address dst) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender redeems rTokens in exchange for the underlying asset\r\n     * @param redeemTokens The number of rTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure\r\n     */\r\n    function redeem(uint256 redeemTokens) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender redeems all rTokens in exchange for the underlying asset\r\n     * @return uint 0=success, otherwise a failure\r\n     */\r\n    function redeemAll() external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender redeems rTokens in exchange for the underlying asset then immediately transfer them to a differen user\r\n     * @param redeemTo Destination address to send the redeemed tokens to\r\n     * @param redeemTokens The number of rTokens to redeem into underlying\r\n     * @return uint 0=success, otherwise a failure\r\n     */\r\n    function redeemAndTransfer(address redeemTo, uint256 redeemTokens) external returns (bool);\r\n\r\n    /**\r\n     * @notice Sender redeems all rTokens in exchange for the underlying asset then immediately transfer them to a differen user\r\n     * @param redeemTo Destination address to send the redeemed tokens to\r\n     * @return uint 0=success, otherwise a failure\r\n     */\r\n    function redeemAndTransferAll(address redeemTo) external returns (bool);\r\n\r\n    /**\r\n     * @notice Create a new Hat\r\n     * @param recipients List of beneficial recipients\r\n     * @param proportions Relative proportions of benefits received by the recipients\r\n     * @param doChangeHat Should the hat of the `msg.sender` be switched to the new one\r\n     */\r\n    function createHat(\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions,\r\n        bool doChangeHat) external returns (uint256 hatID);\r\n\r\n    /**\r\n     * @notice Change the hat for `msg.sender`\r\n     * @param hatID The id of the Hat\r\n     */\r\n    function changeHat(uint256 hatID) external;\r\n\r\n    /**\r\n     * @notice pay interest to the owner\r\n     * @param owner Account owner address\r\n     *\r\n     * Anyone can trigger the interest distribution on behalf of the recipient,\r\n     * due to the fact that the recipient can be a contract code that has not\r\n     * implemented the interaction with the rToken contract internally`.\r\n     *\r\n     * A interest lock-up period may apply, in order to mitigate the \"hat\r\n     * inheritance scam\".\r\n     */\r\n    function payInterest(address owner) external returns (bool);\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // Essential info views\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Get the maximum hatID in the system\r\n     */\r\n    function getMaximumHatID() external view returns (uint256 hatID);\r\n\r\n    /**\r\n     * @notice Get the hatID of the owner and the hat structure\r\n     * @param owner Account owner address\r\n     * @return hatID Hat ID\r\n     * @return recipients Hat recipients\r\n     * @return proportions Hat recipient's relative proportions\r\n     */\r\n    function getHatByAddress(address owner) external view\r\n        returns (\r\n            uint256 hatID,\r\n            address[] memory recipients,\r\n            uint32[] memory proportions);\r\n\r\n    /**\r\n     * @notice Get the hat structure\r\n     * @param hatID Hat ID\r\n     * @return recipients Hat recipients\r\n     * @return proportions Hat recipient's relative proportions\r\n     */\r\n    function getHatByID(uint256 hatID) external view\r\n        returns (\r\n            address[] memory recipients,\r\n            uint32[] memory proportions);\r\n\r\n    /**\r\n     * @notice Amount of saving assets given to the recipient along with the\r\n     *         loans.\r\n     * @param owner Account owner address\r\n     */\r\n    function receivedSavingsOf(address owner) external view returns (uint256 amount);\r\n\r\n    /**\r\n     * @notice Amount of token loaned to the recipient along with the savings\r\n     *         assets.\r\n     * @param owner Account owner address\r\n     * @return amount\r\n     */\r\n    function receivedLoanOf(address owner) external view returns (uint256 amount);\r\n\r\n    /**\r\n     * @notice Get the current interest balance of the owner.\r\n               It is equivalent of: receivedSavings - receivedLoan - freeBalance\r\n     * @param owner Account owner address\r\n     * @return amount\r\n     */\r\n    function interestPayableOf(address owner) external view returns (uint256 amount);\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // statistics views\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Get the current saving strategy contract\r\n     * @return Saving strategy address\r\n     */\r\n    function getCurrentSavingStrategy() external view returns (address);\r\n\r\n    /**\r\n    * @notice Get saving asset balance for specific saving strategy\r\n    * @return rAmount Balance in redeemable amount\r\n    * @return sAmount Balance in native amount of the strategy\r\n    */\r\n    function getSavingAssetBalance() external view returns (uint256 nAmount, uint256 sAmount);\r\n\r\n    /**\r\n    * @notice Get global stats\r\n    * @return global stats\r\n    */\r\n    function getGlobalStats() external view returns (GlobalStats memory);\r\n\r\n    /**\r\n    * @notice Get account stats\r\n    * @param owner Account owner address\r\n    * @return account stats\r\n    */\r\n    function getAccountStats(address owner) external view returns (AccountStats memory);\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // admin functions\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n    * @notice Change allocation strategy for the contract instance\r\n    * @param allocationStrategy Allocation strategy instance\r\n    */\r\n    function changeAllocationStrategy(IAllocationStrategy allocationStrategy) external;\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    // Events\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /**\r\n     * @notice Event emitted when tokens are minted\r\n     */\r\n    event Mint(address indexed minter, uint256 mintAmount);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are redeemed\r\n     */\r\n    event Redeem(address indexed redeemer, address indexed redeemTo, uint256 redeemAmount);\r\n\r\n    /**\r\n     * @notice Event emitted when interest paid\r\n     */\r\n    event InterestPaid(address indexed recipient, uint256 interestAmount);\r\n\r\n    /**\r\n     * @notice A new hat is created\r\n     */\r\n    event HatCreated(uint256 indexed hatID);\r\n\r\n    /**\r\n     * @notice Hat is changed for the account\r\n     */\r\n    event HatChanged(address indexed account, uint256 indexed hatID);\r\n}\r\n\r\n// File: contracts/RToken.sol\r\n\r\npragma solidity ^0.5.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice RToken an ERC20 token that is 1:1 redeemable to its underlying ERC20 token.\r\n */\r\ncontract RToken is IRToken, Ownable, ReentrancyGuard {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant SELF_HAT_ID = uint256(int256(-1));\r\n\r\n    uint32 constant PROPORTION_BASE = 0xFFFFFFFF;\r\n\r\n    //\r\n    // public structures\r\n    //\r\n\r\n    /**\r\n     * @notice Hat structure describes who are the recipients of the interest\r\n     *\r\n     * To be a valid hat structure:\r\n     *   - at least one recipient\r\n     *   - recipients.length == proportions.length\r\n     *   - each value in proportions should be greater than 0\r\n     */\r\n    struct Hat {\r\n        address[] recipients;\r\n        uint32[] proportions;\r\n    }\r\n\r\n    /**\r\n     * @notice Create rToken linked with cToken at `cToken_`\r\n     */\r\n    constructor(IAllocationStrategy allocationStrategy) public {\r\n        ias = allocationStrategy;\r\n        token = IERC20(ias.underlying());\r\n        // special hat aka. zero hat : hatID = 0\r\n        hats.push(Hat(new address[](0), new uint32[](0)));\r\n    }\r\n\r\n    //\r\n    // ERC20 Interface\r\n    //\r\n\r\n    /**\r\n     * @notice EIP-20 token name for this token\r\n     */\r\n    string public name = \"Redeemable DAI (rDAI ethberlin)\";\r\n\r\n    /**\r\n     * @notice EIP-20 token symbol for this token\r\n     */\r\n    string public symbol = \"rDAItest\";\r\n\r\n    /**\r\n     * @notice EIP-20 token decimals for this token\r\n     */\r\n    uint256 public decimals = 18;\r\n\r\n     /**\r\n      * @notice Total number of tokens in circulation\r\n      */\r\n    uint256 public totalSupply;\r\n\r\n    /**\r\n     * @notice Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256) {\r\n        return accounts[owner].rAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256) {\r\n        return transferAllowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        address src = msg.sender;\r\n        transferAllowances[src][spender] = amount;\r\n        emit Approval(src, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Moves `amount` tokens from the caller's account to `dst`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     * May also emit `InterestPaid` event.\r\n     */\r\n    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\r\n        return transferInternal(msg.sender, msg.sender, dst, amount);\r\n    }\r\n\r\n    /// @dev IRToken.transferAll implementation\r\n    function transferAll(address dst) external nonReentrant returns (bool) {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        return transferInternal(src, src, dst, accounts[src].rAmount);\r\n    }\r\n\r\n    /// @dev IRToken.transferAllFrom implementation\r\n    function transferAllFrom(address src, address dst) external nonReentrant returns (bool) {\r\n        payInterestInternal(src);\r\n        payInterestInternal(dst);\r\n        return transferInternal(msg.sender, src, dst, accounts[src].rAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\r\n        return transferInternal(msg.sender, src, dst, amount);\r\n    }\r\n\r\n    //\r\n    // rToken interface\r\n    //\r\n\r\n    /// @dev IRToken.mint implementation\r\n    function mint(uint256 mintAmount) external nonReentrant returns (bool) {\r\n        mintInternal(mintAmount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.mintWithSelectedHat implementation\r\n    function mintWithSelectedHat(uint256 mintAmount, uint256 hatID) external nonReentrant returns (bool) {\r\n        require(hatID == SELF_HAT_ID || hatID < hats.length, \"Invalid hat ID\");\r\n        changeHatInternal(msg.sender, hatID);\r\n        mintInternal(mintAmount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev IRToken.mintWithNewHat implementation\r\n     */\r\n    function mintWithNewHat(uint256 mintAmount,\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions) external nonReentrant returns (bool) {\r\n        uint256 hatID = createHatInternal(recipients, proportions);\r\n        changeHatInternal(msg.sender, hatID);\r\n\r\n        mintInternal(mintAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev IRToken.redeem implementation\r\n     *      It withdraws equal amount of initially supplied underlying assets\r\n     */\r\n    function redeem(uint256 redeemTokens) external nonReentrant returns (bool) {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        redeemInternal(src, redeemTokens);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.redeemAll implementation\r\n    function redeemAll() external nonReentrant returns (bool) {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        redeemInternal(src, accounts[src].rAmount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.redeemAndTransfer implementation\r\n    function redeemAndTransfer(address redeemTo, uint256 redeemTokens) external nonReentrant returns (bool) {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        redeemInternal(redeemTo, redeemTokens);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.redeemAndTransferAll implementation\r\n    function redeemAndTransferAll(address redeemTo) external nonReentrant returns (bool) {\r\n        address src = msg.sender;\r\n        payInterestInternal(src);\r\n        redeemInternal(redeemTo, accounts[src].rAmount);\r\n        return true;\r\n    }\r\n\r\n     /// @dev IRToken.createHat implementation\r\n    function createHat(\r\n        address[] calldata recipients,\r\n        uint32[] calldata proportions,\r\n        bool doChangeHat) external nonReentrant returns (uint256 hatID) {\r\n        hatID = createHatInternal(recipients, proportions);\r\n        if (doChangeHat) {\r\n            changeHatInternal(msg.sender, hatID);\r\n        }\r\n    }\r\n\r\n    /// @dev IRToken.changeHat implementation\r\n    function changeHat(uint256 hatID) external nonReentrant {\r\n        changeHatInternal(msg.sender, hatID);\r\n    }\r\n\r\n    /// @dev IRToken.getMaximumHatID implementation\r\n    function getMaximumHatID() external view returns (uint256 hatID) {\r\n        return hats.length - 1;\r\n    }\r\n\r\n    /// @dev IRToken.getHatByAddress implementation\r\n    function getHatByAddress(address owner) external view returns (\r\n        uint256 hatID,\r\n        address[] memory recipients,\r\n        uint32[] memory proportions) {\r\n        hatID = accounts[owner].hatID;\r\n        if (hatID != 0 && hatID != SELF_HAT_ID) {\r\n            Hat memory hat = hats[hatID];\r\n            recipients = hat.recipients;\r\n            proportions = hat.proportions;\r\n        } else {\r\n            recipients = new address[](0);\r\n            proportions = new uint32[](0);\r\n        }\r\n    }\r\n\r\n    /// @dev IRToken.getHatByID implementation\r\n    function getHatByID(uint256 hatID) external view returns (\r\n        address[] memory recipients,\r\n        uint32[] memory proportions) {\r\n        if (hatID != 0 && hatID != SELF_HAT_ID) {\r\n            Hat memory hat = hats[hatID];\r\n            recipients = hat.recipients;\r\n            proportions = hat.proportions;\r\n        } else {\r\n            recipients = new address[](0);\r\n            proportions = new uint32[](0);\r\n        }\r\n    }\r\n\r\n    /// @dev IRToken.receivedSavingsOf implementation\r\n    function receivedSavingsOf(address owner) external view returns (uint256 amount) {\r\n        Account storage account = accounts[owner];\r\n        uint256 rGross =\r\n            account.sInternalAmount\r\n            .mul(ias.exchangeRateStored())\r\n            .div(savingAssetConversionRate); // the 1e18 decimals should be cancelled out\r\n        return rGross;\r\n    }\r\n\r\n    /// @dev IRToken.receivedLoanOf implementation\r\n    function receivedLoanOf(address owner) external view returns (uint256 amount) {\r\n        Account storage account = accounts[owner];\r\n        return account.lDebt;\r\n    }\r\n\r\n    /// @dev IRToken.interestPayableOf implementation\r\n    function interestPayableOf(address owner) external view returns (uint256 amount) {\r\n        Account storage account = accounts[owner];\r\n        return getInterestPayableOf(account);\r\n    }\r\n\r\n    /// @dev IRToken.payInterest implementation\r\n    function payInterest(address owner) external nonReentrant returns (bool) {\r\n        payInterestInternal(owner);\r\n        return true;\r\n    }\r\n\r\n    /// @dev IRToken.getAccountStats implementation!1\r\n    function getGlobalStats() external view returns (GlobalStats memory) {\r\n        uint256 totalSavingsAmount;\r\n        totalSavingsAmount +=\r\n            savingAssetOrignalAmount\r\n            .mul(ias.exchangeRateStored())\r\n            .div(10 ** 18);\r\n        return GlobalStats({\r\n            totalSupply: totalSupply,\r\n            totalSavingsAmount: totalSavingsAmount\r\n        });\r\n    }\r\n\r\n    /// @dev IRToken.getAccountStats implementation\r\n    function getAccountStats(address owner) external view returns (AccountStats memory) {\r\n        Account storage account = accounts[owner];\r\n        return account.stats;\r\n    }\r\n\r\n    /// @dev IRToken.getCurrentSavingStrategy implementation\r\n    function getCurrentSavingStrategy() external view returns (address) {\r\n        return address(ias);\r\n    }\r\n\r\n    /// @dev IRToken.getSavingAssetBalance implementation\r\n    function getSavingAssetBalance() external view\r\n        returns (uint256 nAmount, uint256 sAmount) {\r\n        sAmount = savingAssetOrignalAmount;\r\n        nAmount = sAmount\r\n            .mul(ias.exchangeRateStored())\r\n            .div(10 ** 18);\r\n    }\r\n\r\n    /// @dev IRToken.changeAllocationStrategy implementation\r\n    function changeAllocationStrategy(IAllocationStrategy allocationStrategy) external nonReentrant onlyOwner {\r\n        require(allocationStrategy.underlying() == address(token), \"New strategy should have the same underlying asset\");\r\n        IAllocationStrategy oldIas = ias;\r\n        ias = allocationStrategy;\r\n        // redeem everything from the old strategy\r\n        uint256 sOriginalBurned = oldIas.redeemUnderlying(totalSupply);\r\n        // invest everything into the new strategy\r\n        token.transferFrom(msg.sender, address(this), totalSupply);\r\n        token.approve(address(ias), totalSupply);\r\n        uint256 sOriginalCreated = ias.investUnderlying(totalSupply);\r\n        // calculate new saving asset conversion rate\r\n        // if new original saving asset is 2x in amount\r\n        // then the conversion of internal amount should be also 2x\r\n        savingAssetConversionRate =\r\n            sOriginalCreated\r\n            .mul(10 ** 18)\r\n            .div(sOriginalBurned);\r\n    }\r\n\r\n    //\r\n    // internal\r\n    //\r\n\r\n    /// @dev Current saving strategy\r\n    IAllocationStrategy private ias;\r\n\r\n    /// @dev Underlying token\r\n    IERC20 private token;\r\n\r\n    /// @dev Saving assets original amount\r\n    uint256 private savingAssetOrignalAmount;\r\n\r\n    /// @dev Saving asset original to internal amount conversion rate.\r\n    ///      - It has 18 decimals\r\n    ///      - It starts with value 1.\r\n    ///      - Each strategy switching results a new conversion rate\r\n    uint256 private savingAssetConversionRate = 10 ** 18;\r\n\r\n    /// @dev Saving assets exchange rate with\r\n\r\n    /// @dev Approved token transfer amounts on behalf of others\r\n    mapping(address => mapping(address => uint256)) private transferAllowances;\r\n\r\n    /// @dev Hat list\r\n    Hat[] private hats;\r\n\r\n    /// @dev Account structure\r\n    struct Account {\r\n        //\r\n        // Essential info\r\n        //\r\n        /// @dev ID of the hat selected for the account\r\n        uint256 hatID;\r\n        /// @dev Redeemable token balance for the account\r\n        uint256 rAmount;\r\n        /// @dev Redeemable token balance portion that is from interest payment\r\n        uint256 rInterest;\r\n        /// @dev Loan recipients and their amount of debt\r\n        mapping (address => uint256) lRecipients;\r\n        /// @dev Loan debt amount for the account\r\n        uint256 lDebt;\r\n        /// @dev Saving asset amount internal\r\n        uint256 sInternalAmount;\r\n\r\n        /// @dev Stats\r\n        AccountStats stats;\r\n    }\r\n\r\n    /// @dev Account mapping\r\n    mapping (address => Account) private accounts;\r\n\r\n    /**\r\n     * @dev Transfer `tokens` tokens from `src` to `dst` by `spender`\r\n            Called by both `transfer` and `transferFrom` internally\r\n     * @param spender The address of the account performing the transfer\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param tokens The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transferInternal(address spender, address src, address dst, uint256 tokens) internal returns (bool) {\r\n        require(src != dst, \"src should not equal dst\");\r\n\r\n        // pay the interest before doing the transfer\r\n        payInterestInternal(src);\r\n\r\n        require(accounts[src].rAmount >= tokens, \"Not enough balance to transfer\");\r\n\r\n        /* Get the allowance, infinite for the account owner */\r\n        uint256 startingAllowance = 0;\r\n        if (spender == src) {\r\n            startingAllowance = uint256(-1);\r\n        } else {\r\n            startingAllowance = transferAllowances[src][spender];\r\n        }\r\n        require(startingAllowance >= tokens, \"Not enough allowance for transfer\");\r\n\r\n        /* Do the calculations, checking for {under,over}flow */\r\n        uint256 allowanceNew = startingAllowance.sub(tokens);\r\n        uint256 srcTokensNew = accounts[src].rAmount.sub(tokens);\r\n        uint256 dstTokensNew = accounts[dst].rAmount.add(tokens);\r\n\r\n        /////////////////////////\r\n        // EFFECTS & INTERACTIONS\r\n        // (No safe failures beyond this point)\r\n\r\n        // apply hat inheritance rule\r\n        if (accounts[src].hatID != 0 && accounts[dst].hatID == 0) {\r\n            changeHatInternal(dst, accounts[src].hatID);\r\n        }\r\n\r\n        accounts[src].rAmount = srcTokensNew;\r\n        accounts[dst].rAmount = dstTokensNew;\r\n\r\n        /* Eat some of the allowance (if necessary) */\r\n        if (startingAllowance != uint256(-1)) {\r\n            transferAllowances[src][spender] = allowanceNew;\r\n        }\r\n\r\n        // lRecipients adjustments\r\n        uint256 sInternalAmountCollected = estimateAndRecollectLoans(src, tokens);\r\n        distributeLoans(dst, tokens, sInternalAmountCollected);\r\n\r\n        // rInterest adjustment for src\r\n        if (accounts[src].rInterest > accounts[src].rAmount) {\r\n            accounts[src].rInterest = accounts[src].rAmount;\r\n        }\r\n\r\n        /* We emit a Transfer event */\r\n        emit Transfer(src, dst, tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Sender supplies assets into the market and receives rTokens in exchange\r\n     * @dev Invest into underlying assets immediately\r\n     * @param mintAmount The amount of the underlying asset to supply\r\n     */\r\n    function mintInternal(uint256 mintAmount) internal {\r\n        require(token.allowance(msg.sender, address(this)) >= mintAmount, \"Not enough allowance\");\r\n\r\n        Account storage account = accounts[msg.sender];\r\n\r\n        // create saving assets\r\n        token.transferFrom(msg.sender, address(this), mintAmount);\r\n        token.approve(address(ias), mintAmount);\r\n        uint256 sOriginalCreated = ias.investUnderlying(mintAmount);\r\n\r\n        // update global and account r balances\r\n        totalSupply = totalSupply.add(mintAmount);\r\n        account.rAmount = account.rAmount.add(mintAmount);\r\n\r\n        // update global stats\r\n        savingAssetOrignalAmount += sOriginalCreated;\r\n\r\n        // distribute saving assets as loans to recipients\r\n        uint256 sInternalCreated =\r\n            sOriginalCreated\r\n            .mul(savingAssetConversionRate)\r\n            .div(10 ** 18);\r\n        distributeLoans(msg.sender, mintAmount, sInternalCreated);\r\n\r\n        emit Mint(msg.sender, mintAmount);\r\n        emit Transfer(address(this), msg.sender, mintAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Sender redeems rTokens in exchange for the underlying asset\r\n     * @dev Withdraw equal amount of initially supplied underlying assets\r\n     * @param redeemTo Destination address to send the redeemed tokens to\r\n     * @param redeemAmount The number of rTokens to redeem into underlying\r\n     */\r\n    function redeemInternal(address redeemTo, uint256 redeemAmount) internal {\r\n        Account storage account = accounts[msg.sender];\r\n        require(redeemAmount > 0, \"Redeem amount cannot be zero\");\r\n        require(redeemAmount <= account.rAmount, \"Not enough balance to redeem\");\r\n\r\n        uint256 sOriginalBurned = redeemAndRecollectLoans(msg.sender, redeemAmount);\r\n\r\n        // update Account r balances and global statistics\r\n        account.rAmount = account.rAmount.sub(redeemAmount);\r\n        if (account.rInterest > account.rAmount) {\r\n            account.rInterest = account.rAmount;\r\n        }\r\n        totalSupply = totalSupply.sub(redeemAmount);\r\n\r\n        // update global stats\r\n        if (savingAssetOrignalAmount > sOriginalBurned) {\r\n            savingAssetOrignalAmount -= sOriginalBurned;\r\n        } else {\r\n            savingAssetOrignalAmount = 0;\r\n        }\r\n\r\n        // transfer the token back\r\n        token.transfer(redeemTo, redeemAmount);\r\n\r\n        emit Transfer(msg.sender, address(this), redeemAmount);\r\n        emit Redeem(msg.sender, redeemTo, redeemAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new Hat\r\n     * @param recipients List of beneficial recipients\r\n     * @param proportions Relative proportions of benefits received by the recipients\r\n     */\r\n    function createHatInternal(\r\n        address[] memory recipients,\r\n        uint32[] memory proportions) internal returns (uint256 hatID) {\r\n        uint i;\r\n\r\n        require(recipients.length > 0, \"Invalid hat: at least one recipient\");\r\n        require(recipients.length == proportions.length, \"Invalid hat: length not matching\");\r\n\r\n        // normalize the proportions\r\n        uint256 totalProportions = 0;\r\n        for (i = 0; i < recipients.length; ++i) {\r\n            require(proportions[i] > 0, \"Invalid hat: proportion should be larger than 0\");\r\n            totalProportions += uint256(proportions[i]);\r\n        }\r\n        for (i = 0; i < proportions.length; ++i) {\r\n            proportions[i] = uint32(\r\n                uint256(proportions[i])\r\n                * uint256(PROPORTION_BASE)\r\n                / totalProportions);\r\n        }\r\n\r\n        hatID = hats.push(Hat(\r\n            recipients,\r\n            proportions\r\n        )) - 1;\r\n        emit HatCreated(hatID);\r\n    }\r\n\r\n    /**\r\n     * @dev Change the hat for `owner`\r\n     * @param owner Account owner\r\n     * @param hatID The id of the Hat\r\n     */\r\n    function changeHatInternal(address owner, uint256 hatID) internal {\r\n        Account storage account = accounts[owner];\r\n        if (account.rAmount > 0) {\r\n            uint256 sInternalAmountCollected = estimateAndRecollectLoans(owner, account.rAmount);\r\n            account.hatID = hatID;\r\n            distributeLoans(owner, account.rAmount, sInternalAmountCollected);\r\n        } else {\r\n            account.hatID = hatID;\r\n        }\r\n        emit HatChanged(owner, hatID);\r\n    }\r\n\r\n    /**\r\n     * @dev Get interest payable of the account\r\n     */\r\n    function getInterestPayableOf(Account storage account) internal view returns (uint256) {\r\n        uint256 rGross =\r\n            account.sInternalAmount\r\n            .mul(ias.exchangeRateStored())\r\n            .div(savingAssetConversionRate); // the 1e18 decimals should be cancelled out\r\n        if (rGross > (account.lDebt + account.rInterest)) {\r\n            return rGross - account.lDebt - account.rInterest;\r\n        } else {\r\n            // no interest accumulated yet or even negative interest rate!?\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Distribute the incoming tokens to the recipients as loans.\r\n     *      The tokens are immediately invested into the saving strategy and\r\n     *      add to the sAmount of the recipient account.\r\n     *      Recipient also inherits the owner's hat if it does already have one.\r\n     * @param owner Owner account address\r\n     * @param rAmount rToken amount being loaned to the recipients\r\n     * @param sInternalAmount Amount of saving assets (internal amount) being given to the recipients\r\n     */\r\n    function distributeLoans(\r\n            address owner,\r\n            uint256 rAmount,\r\n            uint256 sInternalAmount) internal {\r\n        Account storage account = accounts[owner];\r\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID ? 0 : account.hatID];\r\n        bool[] memory recipientsNeedsNewHat = new bool[](hat.recipients.length);\r\n        uint i;\r\n        if (hat.recipients.length > 0) {\r\n            uint256 rLeft = rAmount;\r\n            uint256 sInternalLeft = sInternalAmount;\r\n            for (i = 0; i < hat.proportions.length; ++i) {\r\n                Account storage recipient = accounts[hat.recipients[i]];\r\n                bool isLastRecipient = i == (hat.proportions.length - 1);\r\n\r\n                // inherit the hat if needed\r\n                if (recipient.hatID == 0) {\r\n                    recipientsNeedsNewHat[i] = true;\r\n                }\r\n\r\n                uint256 lDebtRecipient = isLastRecipient ? rLeft :\r\n                    rAmount\r\n                    * hat.proportions[i]\r\n                    / PROPORTION_BASE;\r\n                account.lRecipients[hat.recipients[i]] = account.lRecipients[hat.recipients[i]].add(lDebtRecipient);\r\n                recipient.lDebt = recipient.lDebt.add(lDebtRecipient);\r\n                // leftover adjustments\r\n                if (rLeft > lDebtRecipient) {\r\n                    rLeft -= lDebtRecipient;\r\n                } else {\r\n                    rLeft = 0;\r\n                }\r\n\r\n                uint256 sInternalAmountRecipient = isLastRecipient ? sInternalLeft:\r\n                    sInternalAmount\r\n                    * hat.proportions[i]\r\n                    / PROPORTION_BASE;\r\n                recipient.sInternalAmount = recipient.sInternalAmount.add(sInternalAmountRecipient);\r\n                // leftover adjustments\r\n                if (sInternalLeft >= sInternalAmountRecipient) {\r\n                    sInternalLeft -= sInternalAmountRecipient;\r\n                } else {\r\n                    rLeft = 0;\r\n                }\r\n            }\r\n        } else {\r\n            // Account uses the zero hat, give all interest to the owner\r\n            account.lDebt = account.lDebt.add(rAmount);\r\n            account.sInternalAmount = account.sInternalAmount.add(sInternalAmount);\r\n        }\r\n\r\n        // apply to new hat owners\r\n        for (i = 0; i < hat.proportions.length; ++i) {\r\n            if (recipientsNeedsNewHat[i]) {\r\n                changeHatInternal(hat.recipients[i], account.hatID);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Recollect loans from the recipients for further distribution\r\n     *      without actually redeeming the saving assets\r\n     * @param owner Owner account address\r\n     * @param rAmount rToken amount neeeds to be recollected from the recipients\r\n     *                by giving back estimated amount of saving assets\r\n     * @return Estimated amount of saving assets (internal) needs to recollected\r\n     */\r\n    function estimateAndRecollectLoans(\r\n        address owner,\r\n        uint256 rAmount) internal returns (uint256 sInternalAmount) {\r\n        Account storage account = accounts[owner];\r\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID ? 0 : account.hatID];\r\n        // accrue interest so estimate is up to date\r\n        ias.accrueInterest();\r\n        sInternalAmount = rAmount\r\n            .mul(savingAssetConversionRate)\r\n            .div(ias.exchangeRateStored()); // the 1e18 decimals should be cancelled out\r\n        recollectLoans(account, hat, rAmount, sInternalAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Recollect loans from the recipients for further distribution\r\n     *      by redeeming the saving assets in `rAmount`\r\n     * @param owner Owner account address\r\n     * @param rAmount rToken amount neeeds to be recollected from the recipients\r\n     *                by redeeming equivalent value of the saving assets\r\n     * @return Amount of saving assets redeemed for rAmount of tokens.\r\n     */\r\n    function redeemAndRecollectLoans(\r\n        address owner,\r\n        uint256 rAmount) internal returns (uint256 sOriginalBurned) {\r\n        Account storage account = accounts[owner];\r\n        Hat storage hat = hats[account.hatID == SELF_HAT_ID ? 0 : account.hatID];\r\n        sOriginalBurned = ias.redeemUnderlying(rAmount);\r\n        uint256 sInternalBurned =\r\n            sOriginalBurned\r\n            .mul(savingAssetConversionRate)\r\n            .div(10 ** 18);\r\n        recollectLoans(account, hat, rAmount, sInternalBurned);\r\n    }\r\n\r\n    /**\r\n     * @dev Recollect loan from the recipients\r\n     * @param account Owner account\r\n     * @param hat     Owner's hat\r\n     * @param rAmount rToken amount being written of from the recipients\r\n     * @param sInternalAmount Amount of sasving assets (internal amount) recollected from the recipients\r\n     */\r\n    function recollectLoans(\r\n        Account storage account,\r\n        Hat storage hat,\r\n        uint256 rAmount,\r\n        uint256 sInternalAmount) internal {\r\n        uint i;\r\n        if (hat.recipients.length > 0) {\r\n            uint256 rLeft = rAmount;\r\n            uint256 sInternalLeft = sInternalAmount;\r\n            for (i = 0; i < hat.proportions.length; ++i) {\r\n                Account storage recipient = accounts[hat.recipients[i]];\r\n                bool isLastRecipient = i == (hat.proportions.length - 1);\r\n\r\n                uint256 lDebtRecipient = isLastRecipient ? rLeft: rAmount\r\n                    * hat.proportions[i]\r\n                    / PROPORTION_BASE;\r\n                if (recipient.lDebt > lDebtRecipient) {\r\n                    recipient.lDebt -= lDebtRecipient;\r\n                } else {\r\n                    recipient.lDebt = 0;\r\n                }\r\n                if (account.lRecipients[hat.recipients[i]] > lDebtRecipient) {\r\n                    account.lRecipients[hat.recipients[i]] -= lDebtRecipient;\r\n                } else {\r\n                    account.lRecipients[hat.recipients[i]] = 0;\r\n                }\r\n                // leftover adjustments\r\n                if (rLeft > lDebtRecipient) {\r\n                    rLeft -= lDebtRecipient;\r\n                } else {\r\n                    rLeft = 0;\r\n                }\r\n\r\n                uint256 sInternalAmountRecipient = isLastRecipient ? sInternalLeft:\r\n                    sInternalAmount\r\n                    * hat.proportions[i]\r\n                    / PROPORTION_BASE;\r\n                if (recipient.sInternalAmount > sInternalAmountRecipient) {\r\n                    recipient.sInternalAmount -= sInternalAmountRecipient;\r\n                } else {\r\n                    recipient.sInternalAmount = 0;\r\n                }\r\n                // leftover adjustments\r\n                if (sInternalLeft >= sInternalAmountRecipient) {\r\n                    sInternalLeft -= sInternalAmountRecipient;\r\n                } else {\r\n                    rLeft = 0;\r\n                }\r\n            }\r\n        } else {\r\n            // Account uses the zero hat, recollect interests from the owner\r\n            if (account.lDebt > rAmount) {\r\n                account.lDebt -= rAmount;\r\n            } else {\r\n                account.lDebt = 0;\r\n            }\r\n            if (account.sInternalAmount > sInternalAmount) {\r\n                account.sInternalAmount -= sInternalAmount;\r\n            } else {\r\n                account.sInternalAmount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev pay interest to the owner\r\n     * @param owner Account owner address\r\n     */\r\n    function payInterestInternal(address owner) internal {\r\n        Account storage account = accounts[owner];\r\n\r\n        ias.accrueInterest();\r\n        uint256 interestAmount = getInterestPayableOf(account);\r\n\r\n        if (interestAmount > 0) {\r\n            account.stats.cumulativeInterest = account.stats.cumulativeInterest.add(interestAmount);\r\n            account.rInterest = account.rInterest.add(interestAmount);\r\n            account.rAmount = account.rAmount.add(interestAmount);\r\n            totalSupply = totalSupply.add(interestAmount);\r\n            emit InterestPaid(owner, interestAmount);\r\n            emit Transfer(address(this), owner, interestAmount);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemTo\",\"type\":\"address\"}],\"name\":\"redeemAndTransferAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getHatByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"receivedLoanOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"getHatByID\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getAccountStats\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"cumulativeInterest\",\"type\":\"uint256\"}],\"internalType\":\"struct IRToken.AccountStats\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"changeHat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"mintWithSelectedHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaximumHatID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"},{\"internalType\":\"bool\",\"name\":\"doChangeHat\",\"type\":\"bool\"}],\"name\":\"createHat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGlobalStats\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSavingsAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IRToken.GlobalStats\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"interestPayableOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"transferAllFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"transferAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"proportions\",\"type\":\"uint32[]\"}],\"name\":\"mintWithNewHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SELF_HAT_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentSavingStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"payInterest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeemAndTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IAllocationStrategy\",\"name\":\"allocationStrategy\",\"type\":\"address\"}],\"name\":\"changeAllocationStrategy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSavingAssetBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"receivedSavingsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAllocationStrategy\",\"name\":\"allocationStrategy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestAmount\",\"type\":\"uint256\"}],\"name\":\"InterestPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"HatCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"hatID\",\"type\":\"uint256\"}],\"name\":\"HatChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"RToken","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008e8f05f1ad16d20e66bd0922b510332104ddac7b","Library":"","SwarmSource":"bzzr://b3f1245e273b29d0910a2a0fa5e36e66f10a3c52eb354620870e14a5917e95ea"}]}