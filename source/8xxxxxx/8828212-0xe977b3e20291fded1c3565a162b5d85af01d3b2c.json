{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2019-10-22\r\n*/\r\n\r\npragma solidity ^0.4.26;\r\n\r\nlibrary SafeMath\r\n{\r\n    function mul(uint256 a, uint256 b) internal pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a * b;\r\n\r\n        assert(a == 0 || c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure\r\n        returns (uint256)\r\n    {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure\r\n        returns (uint256)\r\n    {\r\n        assert(b <= a);\r\n\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n\r\n        assert(c >= a);\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable\r\n{\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract TokenERC20 is Ownable {\r\n    bytes32 public standard;\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    uint8 public decimals;\r\n    bool public allowTransactions;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n}\r\n\r\n\r\n/**\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract STMUniversity is Ownable {\r\n    using ECRecovery for bytes32;\r\n    \r\n    uint8 constant public EMPTY = 0x0;\r\n\r\n    TokenERC20 public streamityContractAddress;\r\n\r\n    mapping(bytes32 => Deal) public stmTransfers;\r\n\r\n    function STMUniversity(address streamityContract) public {\r\n        require(streamityContract != 0x0);\r\n        streamityContractAddress = TokenERC20(streamityContract);\r\n    }\r\n\r\n    struct Deal {\r\n        uint256 value;\r\n    }\r\n\r\n    event Buy(bytes32 _tradeID);\r\n\r\n    function payAltCoin(bytes32 _tradeID, uint256 _value, bytes _sign) \r\n    external \r\n    {\r\n        bytes32 _hashDeal = keccak256(_tradeID, _value);\r\n        verifyDeal(_hashDeal, _sign);\r\n        bool result = streamityContractAddress.transferFrom(msg.sender, address(this), _value);\r\n        require(result == true);\r\n        startDeal(_hashDeal, _value, _tradeID);\r\n    }\r\n\r\n    function verifyDeal(bytes32 _hashDeal, bytes _sign) private view {\r\n        require(_hashDeal.recover(_sign) == owner);\r\n        require(stmTransfers[_hashDeal].value == EMPTY); \r\n    }\r\n\r\n    function startDeal(bytes32 _hashDeal, uint256 _value, bytes32 _tradeID) \r\n    private\r\n    {\r\n        Deal storage userDeals = stmTransfers[_hashDeal];\r\n        userDeals.value = _value; \r\n        emit Buy(_tradeID);\r\n    }\r\n\r\n    function withdrawCommisionToAddressAltCoin(address _to, uint256 _amount) external onlyOwner {\r\n        streamityContractAddress.transfer(_to, _amount);\r\n    }\r\n\r\n    function setStreamityContractAddress(address newAddress) \r\n    external onlyOwner \r\n    {\r\n        streamityContractAddress = TokenERC20(newAddress);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"EMPTY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"streamityContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"stmTransfers\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawCommisionToAddressAltCoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setStreamityContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_sign\",\"type\":\"bytes\"}],\"name\":\"payAltCoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"streamityContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tradeID\",\"type\":\"bytes32\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"STMUniversity","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000e22734e078d6e399bcee40a549db591c4ea46cb","Library":"ECRecovery:aaafde945f5ac749f1a838783718930a57dbd67a","LicenseType":"None","SwarmSource":"bzzr://1898eceb5a6a573e4e595334607c1cbd10f2ecf4bd6e5eb0924ea9f9e03692ca"}]}