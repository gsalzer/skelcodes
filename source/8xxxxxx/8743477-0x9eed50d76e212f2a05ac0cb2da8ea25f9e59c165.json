{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.0;\r\n\r\ncontract ICards {\r\n\r\n    enum Rarity {\r\n        Common, Rare, Epic, Legendary, Mythic\r\n    }\r\n\r\n    function getRandomCard(Rarity rarity, uint16 random) public view returns (uint16);\r\n    function createCard(address user, uint16 proto, uint16 purity) public returns (uint);\r\n\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath64 {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint64 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract Ownable {\r\n\r\n    address payable public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setOwner(address payable _owner) public onlyOwner {\r\n        owner = _owner;\r\n    }\r\n\r\n    function getOwner() public view returns (address payable) {\r\n        return owner;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"must be owner to call this function\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ninterface IProcessor {\r\n\r\n    function processPayment(address user, uint cost, uint items, address referrer) external payable returns (uint id);\r\n    \r\n}\r\n\r\ncontract Pack {\r\n\r\n    enum Type {\r\n        Rare, Epic, Legendary, Shiny\r\n    }\r\n\r\n}\r\n\r\ncontract RarityProvider {\r\n\r\n    ICards cards;\r\n\r\n    constructor(ICards _cards) public {\r\n        cards = _cards;\r\n    }\r\n\r\n    struct RandomnessComponents {\r\n        uint random;\r\n        uint32 rarity;\r\n        uint16 quality;\r\n        uint16 purity;\r\n        uint16 proto;\r\n    }\r\n\r\n    // return 'length' bytes of 'num' starting at 'start'\r\n    function extract(uint num, uint length, uint start) internal pure returns (uint) {\r\n        return (((1 << (length * 8)) - 1) & (num >> ((start - 1) * 8)));\r\n    }\r\n\r\n    // divides the random seed into components\r\n    function getComponents(\r\n        uint cardIndex, uint rand\r\n    ) internal pure returns (\r\n        RandomnessComponents memory\r\n    ) {\r\n        uint random = uint(keccak256(abi.encodePacked(cardIndex, rand)));\r\n        return RandomnessComponents({\r\n            random: random,\r\n            rarity: uint32(extract(random, 4, 10) % 1000000),\r\n            quality: uint16(extract(random, 2, 4) % 1000),\r\n            purity: uint16(extract(random, 2, 6) % 1000),\r\n            proto: uint16(extract(random, 2, 8) % (2**16-1))\r\n        });\r\n    }\r\n\r\n    function getCardDetails(Pack.Type packType, uint cardIndex, uint result) internal view returns (uint16, uint16) {\r\n        if (packType == Pack.Type.Shiny) {\r\n            return _getShinyCardDetails(cardIndex, result);\r\n        } else if (packType == Pack.Type.Legendary) {\r\n            return _getLegendaryCardDetails(cardIndex, result);\r\n        } else if (packType == Pack.Type.Epic) {\r\n            return _getEpicCardDetails(cardIndex, result);\r\n        }\r\n        return _getRareCardDetails(cardIndex, result);\r\n    }\r\n\r\n    function _getShinyCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\r\n        \r\n        RandomnessComponents memory rc = getComponents(cardIndex, result); \r\n\r\n        ICards.Rarity rarity;\r\n\r\n        if (cardIndex == 4) {\r\n            rarity = _getLegendaryPlusRarity(rc.rarity);\r\n            purity = _getShinyPurityBase(rc.quality) + rc.purity;\r\n        } else if (cardIndex == 3) {\r\n            rarity = _getRarePlusRarity(rc.rarity);\r\n            purity = _getPurityBase(rc.quality) + rc.purity;\r\n        } else {\r\n            rarity = _getCommonPlusRarity(rc.rarity);\r\n            purity = _getPurityBase(rc.quality) + rc.purity;\r\n        }\r\n        proto = cards.getRandomCard(rarity, rc.proto);\r\n        return (proto, purity);\r\n    }\r\n\r\n    function _getLegendaryCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\r\n        \r\n        RandomnessComponents memory rc = getComponents(cardIndex, result);\r\n\r\n        ICards.Rarity rarity;\r\n\r\n        if (cardIndex == 4) {\r\n            rarity = _getLegendaryPlusRarity(rc.rarity);\r\n        } else if (cardIndex == 3) {\r\n            rarity = _getRarePlusRarity(rc.rarity);\r\n        } else {\r\n            rarity = _getCommonPlusRarity(rc.rarity);\r\n        }\r\n\r\n        purity = _getPurityBase(rc.quality) + rc.purity;\r\n    \r\n        proto = cards.getRandomCard(rarity, rc.proto);\r\n\r\n        return (proto, purity);\r\n    } \r\n\r\n\r\n    function _getEpicCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\r\n        \r\n        RandomnessComponents memory rc = getComponents(cardIndex, result);\r\n\r\n        ICards.Rarity rarity;\r\n\r\n        if (cardIndex == 4) {\r\n            rarity = _getEpicPlusRarity(rc.rarity);\r\n        } else {\r\n            rarity = _getCommonPlusRarity(rc.rarity);\r\n        }\r\n\r\n        purity = _getPurityBase(rc.quality) + rc.purity;\r\n    \r\n        proto = cards.getRandomCard(rarity, rc.proto);\r\n\r\n        return (proto, purity);\r\n    } \r\n\r\n    function _getRareCardDetails(uint cardIndex, uint result) internal view returns (uint16 proto, uint16 purity) {\r\n\r\n        RandomnessComponents memory rc = getComponents(cardIndex, result);\r\n\r\n        ICards.Rarity rarity;\r\n\r\n        if (cardIndex == 4) {\r\n            rarity = _getRarePlusRarity(rc.rarity);\r\n        } else {\r\n            rarity = _getCommonPlusRarity(rc.rarity);\r\n        }\r\n\r\n        purity = _getPurityBase(rc.quality) + rc.purity;\r\n    \r\n        proto = cards.getRandomCard(rarity, rc.proto);\r\n        return (proto, purity);\r\n    }  \r\n\r\n\r\n    function _getCommonPlusRarity(uint32 rand) internal pure returns (ICards.Rarity) {\r\n        if (rand == 999999) {\r\n            return ICards.Rarity.Mythic;\r\n        } else if (rand >= 998345) {\r\n            return ICards.Rarity.Legendary;\r\n        } else if (rand >= 986765) {\r\n            return ICards.Rarity.Epic;\r\n        } else if (rand >= 924890) {\r\n            return ICards.Rarity.Rare;\r\n        } else {\r\n            return ICards.Rarity.Common;\r\n        }\r\n    }\r\n\r\n    function _getRarePlusRarity(uint32 rand) internal pure returns (ICards.Rarity) {\r\n        if (rand == 999999) {\r\n            return ICards.Rarity.Mythic;\r\n        } else if (rand >= 981615) {\r\n            return ICards.Rarity.Legendary;\r\n        } else if (rand >= 852940) {\r\n            return ICards.Rarity.Epic;\r\n        } else {\r\n            return ICards.Rarity.Rare;\r\n        } \r\n    }\r\n\r\n    function _getEpicPlusRarity(uint32 rand) internal pure returns (ICards.Rarity) {\r\n        if (rand == 999999) {\r\n            return ICards.Rarity.Mythic;\r\n        } else if (rand >= 981615) {\r\n            return ICards.Rarity.Legendary;\r\n        } else {\r\n            return ICards.Rarity.Epic;\r\n        }\r\n    }\r\n\r\n    function _getLegendaryPlusRarity(uint32 rand) internal pure returns (ICards.Rarity) {\r\n        if (rand == 999999) {\r\n            return ICards.Rarity.Mythic;\r\n        } else {\r\n            return ICards.Rarity.Legendary;\r\n        } \r\n    }\r\n\r\n    // store purity and shine as one number to save users gas\r\n    function _getPurityBase(uint16 randOne) internal pure returns (uint16) {\r\n        if (randOne >= 998) {\r\n            return 3000;\r\n        } else if (randOne >= 988) {\r\n            return 2000;\r\n        } else if (randOne >= 938) {\r\n            return 1000;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function _getShinyPurityBase(uint16 randOne) internal pure returns (uint16) {\r\n        if (randOne >= 998) {\r\n            return 3000;\r\n        } else if (randOne >= 748) {\r\n            return 2000;\r\n        } else {\r\n            return 1000;\r\n        }\r\n    }\r\n\r\n    function getShine(uint16 purity) public pure returns (uint8) {\r\n        return uint8(purity / 1000);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract PackFive is Ownable, RarityProvider {\r\n\r\n    using SafeMath for uint;\r\n    using SafeMath64 for uint64;\r\n\r\n    // fired after user purchases count packs, producing purchase with id\r\n    event PacksPurchased(uint indexed paymentID, uint indexed id, Pack.Type indexed packType, address user, uint count, uint64 lockup);\r\n    // fired after the callback transaction is successful, replaces RandomnessReceived\r\n    event CallbackMade(uint indexed id, address indexed user, uint count, uint randomness);\r\n    // fired after a recommit for a purchase\r\n    event Recommit(uint indexed id, Pack.Type indexed packType, address indexed user, uint count, uint64 lockup);\r\n    // fired after a card is activated, replaces PacksOpened\r\n    event CardActivated(uint indexed purchaseID, uint cardIndex, uint indexed cardID, uint16 proto, uint16 purity);\r\n    // fired after a chest is opened\r\n    event ChestsOpened(uint indexed id, Pack.Type indexed packType, address indexed user, uint count, uint packCount);\r\n    // fired after a purchase is recorded (either buying packs directly or indirectly)\r\n    // callback sentinels should watch this event\r\n    event PurchaseRecorded(uint indexed id, Pack.Type indexed packType, address indexed user, uint count, uint64 lockup);\r\n    // fired after a purchase is revoked\r\n    event PurchaseRevoked(uint indexed paymentID, address indexed revoker);\r\n    // fired when a new pack is added\r\n    event PackAdded(Pack.Type indexed packType, uint price, address chest);\r\n\r\n    struct Purchase {\r\n        uint count;\r\n        uint randomness;\r\n        uint[] state;\r\n        Pack.Type packType;\r\n        uint64 commit;\r\n        uint64 lockup;\r\n        bool revoked;\r\n        address user;\r\n    }\r\n\r\n    struct PackInstance {\r\n        uint price;\r\n        uint chestSize;\r\n        address token;\r\n    }\r\n\r\n    Purchase[] public purchases;\r\n    IProcessor public processor;\r\n    mapping(uint => PackInstance) public packs;\r\n    mapping(address => bool) public canLockup;\r\n    mapping(address => bool) public canRevoke;\r\n    uint public commitLag = 0;\r\n    // TODO: check this fits under mainnet gas limit\r\n    uint16 public activationLimit = 40;\r\n    // override switch in case of contract upgrade etc\r\n    bool public canActivate = false;\r\n    // maximum lockup length in blocks\r\n    uint64 public maxLockup = 600000;\r\n\r\n    constructor(ICards _cards, IProcessor _processor) public RarityProvider(_cards) {\r\n        processor = _processor;\r\n    }\r\n\r\n    // == Admin Functions ==\r\n    function setCanLockup(address user, bool can) public onlyOwner {\r\n        canLockup[user] = can;\r\n    }\r\n\r\n    function setCanRevoke(address user, bool can) public onlyOwner {\r\n        canRevoke[user] = can;\r\n    }\r\n\r\n    function setCommitLag(uint lag) public onlyOwner {\r\n        require(commitLag < 100, \"can't have a commit lag of >100 blocks\");\r\n        commitLag = lag;\r\n    }\r\n\r\n    function setActivationLimit(uint16 _limit) public onlyOwner {\r\n        activationLimit = _limit;\r\n    }\r\n\r\n    function setMaxLockup(uint64 _max) public onlyOwner {\r\n        maxLockup = _max;\r\n    }\r\n\r\n    function setPack(\r\n        Pack.Type packType, uint price, address chest, uint chestSize\r\n    ) public onlyOwner {\r\n\r\n        PackInstance memory p = getPack(packType);\r\n        require(p.token == address(0) && p.price == 0, \"pack instance already set\");\r\n\r\n        require(price > 0, \"price cannot be zero\");\r\n        require(price % 100 == 0, \"price must be a multiple of 100 wei\");\r\n        require(address(processor) != address(0), \"processor must be set\");\r\n\r\n        packs[uint(packType)] = PackInstance({\r\n            token: chest,\r\n            price: price,\r\n            chestSize: chestSize\r\n        });\r\n\r\n        emit PackAdded(packType, price, chest);\r\n    }\r\n\r\n    function setActivate(bool can) public onlyOwner {\r\n        canActivate = can;\r\n    }\r\n\r\n    function canActivatePurchase(uint id) public view returns (bool) {\r\n        if (!canActivate) {\r\n            return false;\r\n        }\r\n        Purchase memory p = purchases[id];\r\n        if (p.lockup > 0) {\r\n            if (inLockupPeriod(p)) {\r\n                return false;\r\n            }\r\n            return !p.revoked;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function revoke(uint id) public {\r\n        require(canRevoke[msg.sender], \"sender not approved to revoke\");\r\n        Purchase storage p = purchases[id];\r\n        require(!p.revoked, \"must not be revoked already\");\r\n        require(p.lockup > 0, \"must have lockup set\");\r\n        require(inLockupPeriod(p), \"must be in lockup period\");\r\n        p.revoked = true;\r\n        emit PurchaseRevoked(id, msg.sender);\r\n    }\r\n\r\n    // == User Functions ==\r\n\r\n    function purchase(Pack.Type packType, uint16 count, address referrer) public payable returns (uint) {\r\n        return purchaseFor(packType, msg.sender, count, referrer, 0);\r\n    }\r\n\r\n    function purchaseFor(Pack.Type packType, address user, uint16 count, address referrer, uint64 lockup) public payable returns (uint) {\r\n\r\n        PackInstance memory pack = getPack(packType);\r\n\r\n        uint purchaseID = _recordPurchase(packType, user, count, lockup);\r\n    \r\n        uint paymentID = processor.processPayment.value(msg.value)(msg.sender, pack.price, count, referrer);\r\n        \r\n        emit PacksPurchased(paymentID, purchaseID, packType, user, count, lockup);\r\n\r\n        return purchaseID;\r\n    }\r\n\r\n    function activateMultiple(uint[] memory pIDs, uint[] memory cardIndices)\r\n        public returns (uint[] memory ids, uint16[] memory protos, uint16[] memory purities) {\r\n        uint len = pIDs.length;\r\n        require(len > 0, \"can't activate no cards\");\r\n        require(len <= activationLimit, \"can't activate more than the activation limit\");\r\n        require(len == cardIndices.length, \"must have the same length\");\r\n        ids = new uint[](len);\r\n        protos = new uint16[](len);\r\n        purities = new uint16[](len);\r\n        for (uint i = 0; i < len; i++) {\r\n            (ids[i], protos[i], purities[i]) = activate(pIDs[i], cardIndices[i]);\r\n        }\r\n        return (ids, protos, purities);\r\n    }\r\n\r\n    function activate(uint purchaseID, uint cardIndex) public returns (uint id, uint16 proto, uint16 purity) {\r\n        \r\n        require(canActivatePurchase(purchaseID), \"can't activate purchase\");\r\n        Purchase storage p = purchases[purchaseID];\r\n        \r\n        require(p.randomness != 0, \"must have been a callback\");\r\n        uint cardCount = uint(p.count).mul(5);\r\n        require(cardIndex < cardCount, \"not a valid card index\");\r\n        uint bit = getStateBit(purchaseID, cardIndex);\r\n        // can only activate each card once\r\n        require(bit == 0, \"card has already been activated\");\r\n        uint x = cardIndex.div(256);\r\n        uint pos = cardIndex % 256;\r\n        // mark the card as activated by flipping the relevant bit\r\n        p.state[x] ^= uint(1) << pos;\r\n        // create the card\r\n        (proto, purity) = getCardDetails(p.packType, cardIndex, p.randomness);\r\n        id = cards.createCard(p.user, proto, purity);\r\n        emit CardActivated(purchaseID, cardIndex, id, proto, purity);\r\n        return (id, proto, purity);\r\n    }\r\n\r\n    // 'open' a number of chest tokens\r\n    function openChest(Pack.Type packType, address user, uint count) public returns (uint) {\r\n        \r\n        PackInstance memory pack = getPack(packType);\r\n\r\n        require(msg.sender == pack.token, \"can only open from the actual token packs\");\r\n\r\n        uint packCount = count.mul(pack.chestSize);\r\n        \r\n        uint id = _recordPurchase(packType, user, packCount, 0);\r\n\r\n        emit ChestsOpened(id, packType, user, count, packCount);\r\n\r\n        return id;\r\n    }\r\n\r\n    function _recordPurchase(Pack.Type packType, address user, uint count, uint64 lockup) internal returns (uint) {\r\n\r\n        if (lockup != 0) {\r\n            require(lockup < maxLockup, \"lockup must be lower than maximum\");\r\n            require(canLockup[msg.sender], \"only some people can lockup cards\");\r\n        }\r\n        \r\n        Purchase memory p = Purchase({\r\n            user: user,\r\n            count: count,\r\n            commit: getCommitBlock(),\r\n            randomness: 0,\r\n            packType: packType,\r\n            state: new uint256[](getStateSize(count)),\r\n            lockup: lockup,\r\n            revoked: false\r\n        });\r\n\r\n        uint id = purchases.push(p).sub(1);\r\n\r\n        emit PurchaseRecorded(id, packType, user, count, lockup);\r\n        return id;\r\n    }\r\n\r\n    // can be called by anybody\r\n    function callback(uint id) public {\r\n\r\n        Purchase storage p = purchases[id];\r\n\r\n        require(p.randomness == 0, \"randomness already set\");\r\n\r\n        require(uint64(block.number) > p.commit, \"cannot callback before commit\");\r\n\r\n        // must be within last 256 blocks, otherwise recommit\r\n        require(p.commit.add(uint64(256)) >= block.number, \"must recommit\");\r\n\r\n        bytes32 bhash = blockhash(p.commit);\r\n\r\n        require(uint(bhash) != 0, \"blockhash must not be zero\");\r\n\r\n        // only use properties which can't be altered by the user\r\n        // id and factory are determined before the reveal\r\n        // 'last' determined param must be random\r\n        p.randomness = uint(keccak256(abi.encodePacked(id, bhash, address(this))));\r\n\r\n        emit CallbackMade(id, p.user, p.count, p.randomness);\r\n    }\r\n\r\n    // can recommit\r\n    // this gives you more chances\r\n    // if no-one else sends the callback (should never happen)\r\n    // still only get a random extra chance\r\n    function recommit(uint id) public {\r\n        Purchase storage p = purchases[id];\r\n        require(p.randomness == 0, \"randomness already set\");\r\n        require(block.number >= p.commit.add(uint64(256)), \"no need to recommit\");\r\n        p.commit = getCommitBlock();\r\n        emit Recommit(id, p.packType, p.user, p.count, p.lockup);\r\n    }\r\n\r\n    // == View Functions ==\r\n\r\n    function getCommitBlock() internal view returns (uint64) {\r\n        return uint64(block.number.add(commitLag));\r\n    }\r\n\r\n    function getStateSize(uint count) public pure returns (uint) {\r\n        return count.mul(5).sub(1).div(256).add(1);\r\n    }\r\n\r\n    function getPurchaseState(uint purchaseID) public view returns (uint[] memory state) {\r\n        require(purchases.length > purchaseID, \"invalid purchase id\");\r\n        Purchase memory p = purchases[purchaseID];\r\n        return p.state;\r\n    }\r\n    \r\n    function getPackDetails(Pack.Type packType) public view returns (address token, uint price) {\r\n        PackInstance memory p = getPack(packType);\r\n        return (p.token, p.price);\r\n    }\r\n\r\n    function getPack(Pack.Type packType) internal view returns (PackInstance memory) {\r\n        return packs[uint(packType)];\r\n    }\r\n\r\n    function getPrice(Pack.Type packType) public view returns (uint) {\r\n        PackInstance memory p = getPack(packType);\r\n        require(p.price != 0, \"price is not yet set\");\r\n        return p.price;\r\n    }\r\n\r\n    function getChestSize(Pack.Type packType) public view returns (uint) {\r\n        PackInstance memory p = getPack(packType);\r\n        require(p.chestSize != 0, \"chest size is not yet set\");\r\n        return p.chestSize;\r\n    }\r\n\r\n    function isActivated(uint purchaseID, uint cardIndex) public view returns (bool) {\r\n        return getStateBit(purchaseID, cardIndex) != 0;\r\n    }\r\n\r\n    function getStateBit(uint purchaseID, uint cardIndex) public view returns (uint) {\r\n        Purchase memory p = purchases[purchaseID];\r\n        uint x = cardIndex.div(256);\r\n        uint slot = p.state[x];\r\n        uint pos = cardIndex % 256;\r\n        uint bit = (slot >> pos) & uint(1);\r\n        return bit;\r\n    }\r\n\r\n    function predictPacks(uint id) external view returns (uint16[] memory protos, uint16[] memory purities) {\r\n\r\n        Purchase memory p = purchases[id];\r\n\r\n        require(p.randomness != 0, \"randomness not yet set\");\r\n\r\n        uint result = p.randomness;\r\n\r\n        uint cardCount = uint(p.count).mul(5);\r\n\r\n        purities = new uint16[](cardCount);\r\n        protos = new uint16[](cardCount);\r\n\r\n        for (uint i = 0; i < cardCount; i++) {\r\n            (protos[i], purities[i]) = getCardDetails(p.packType, i, result);\r\n        }\r\n\r\n        return (protos, purities);\r\n    }\r\n \r\n    function inLockupPeriod(Purchase memory p) internal view returns (bool) {\r\n        return p.commit.add(p.lockup) >= block.number;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"canActivatePurchase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lag\",\"type\":\"uint256\"}],\"name\":\"setCommitLag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canRevoke\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"}],\"name\":\"getChestSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"purchaseID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardIndex\",\"type\":\"uint256\"}],\"name\":\"getStateBit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canActivate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxLockup\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commitLag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"recommit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"purchaseID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardIndex\",\"type\":\"uint256\"}],\"name\":\"isActivated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"can\",\"type\":\"bool\"}],\"name\":\"setCanLockup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_max\",\"type\":\"uint64\"}],\"name\":\"setMaxLockup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"can\",\"type\":\"bool\"}],\"name\":\"setActivate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getStateSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"purchases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"},{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"commit\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lockup\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"revoked\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"purity\",\"type\":\"uint16\"}],\"name\":\"getShine\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"purchaseID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardIndex\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"purity\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activationLimit\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"packs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chestSize\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"chest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chestSize\",\"type\":\"uint256\"}],\"name\":\"setPack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canLockup\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"predictPacks\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"protos\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"purities\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"processor\",\"outputs\":[{\"internalType\":\"contract IProcessor\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_limit\",\"type\":\"uint16\"}],\"name\":\"setActivationLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"purchaseID\",\"type\":\"uint256\"}],\"name\":\"getPurchaseState\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"state\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"lockup\",\"type\":\"uint64\"}],\"name\":\"purchaseFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"can\",\"type\":\"bool\"}],\"name\":\"setCanRevoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"openChest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"}],\"name\":\"getPackDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pIDs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"cardIndices\",\"type\":\"uint256[]\"}],\"name\":\"activateMultiple\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16[]\",\"name\":\"protos\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"purities\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICards\",\"name\":\"_cards\",\"type\":\"address\"},{\"internalType\":\"contract IProcessor\",\"name\":\"_processor\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"paymentID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lockup\",\"type\":\"uint64\"}],\"name\":\"PacksPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"CallbackMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lockup\",\"type\":\"uint64\"}],\"name\":\"Recommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"purchaseID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cardIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cardID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"proto\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"purity\",\"type\":\"uint16\"}],\"name\":\"CardActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packCount\",\"type\":\"uint256\"}],\"name\":\"ChestsOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lockup\",\"type\":\"uint64\"}],\"name\":\"PurchaseRecorded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"paymentID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"revoker\",\"type\":\"address\"}],\"name\":\"PurchaseRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum Pack.Type\",\"name\":\"packType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"chest\",\"type\":\"address\"}],\"name\":\"PackAdded\",\"type\":\"event\"}]","ContractName":"PackFive","CompilerVersion":"v0.5.11+commit.c082d0b4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006ebeaf8e8e946f0716e6533a6f2cefc83f60e8ab0000000000000000000000002a390847ad1b90ea380212e4294c0111969b71d1","Library":"","LicenseType":"None","SwarmSource":"bzzr://a820b7f62a4ab3b78919f25d17794a9ccc5ad2560e6f685d21f2afdf93387d0b"}]}