{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\ncontract Auth {\r\n\r\n  address internal mainAdmin;\r\n  address internal contractAdmin;\r\n  address internal profitAdmin;\r\n  address internal ethAdmin;\r\n  address internal LAdmin;\r\n  address internal maxSAdmin;\r\n  address internal backupAdmin;\r\n  address internal commissionAdmin;\r\n\r\n  event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\r\n\r\n  constructor(\r\n    address _mainAdmin,\r\n    address _contractAdmin,\r\n    address _profitAdmin,\r\n    address _ethAdmin,\r\n    address _LAdmin,\r\n    address _maxSAdmin,\r\n    address _backupAdmin,\r\n    address _commissionAdmin\r\n  )\r\n  internal\r\n  {\r\n    mainAdmin = _mainAdmin;\r\n    contractAdmin = _contractAdmin;\r\n    profitAdmin = _profitAdmin;\r\n    ethAdmin = _ethAdmin;\r\n    LAdmin = _LAdmin;\r\n    maxSAdmin = _maxSAdmin;\r\n    backupAdmin = _backupAdmin;\r\n    commissionAdmin = _commissionAdmin;\r\n  }\r\n\r\n  modifier onlyMainAdmin() {\r\n    require(isMainAdmin(), \"onlyMainAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyContractAdmin() {\r\n    require(isContractAdmin() || isMainAdmin(), \"onlyContractAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyProfitAdmin() {\r\n    require(isProfitAdmin() || isMainAdmin(), \"onlyProfitAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyEthAdmin() {\r\n    require(isEthAdmin() || isMainAdmin(), \"onlyEthAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyLAdmin() {\r\n    require(isLAdmin() || isMainAdmin(), \"onlyLAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyMaxSAdmin() {\r\n    require(isMaxSAdmin() || isMainAdmin(), \"onlyMaxSAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyBackupAdmin() {\r\n    require(isBackupAdmin() || isMainAdmin(), \"onlyBackupAdmin\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyBackupAdmin2() {\r\n    require(isBackupAdmin(), \"onlyBackupAdmin\");\r\n    _;\r\n  }\r\n\r\n  function isMainAdmin() public view returns (bool) {\r\n    return msg.sender == mainAdmin;\r\n  }\r\n\r\n  function isContractAdmin() public view returns (bool) {\r\n    return msg.sender == contractAdmin;\r\n  }\r\n\r\n  function isProfitAdmin() public view returns (bool) {\r\n    return msg.sender == profitAdmin;\r\n  }\r\n\r\n  function isEthAdmin() public view returns (bool) {\r\n    return msg.sender == ethAdmin;\r\n  }\r\n\r\n  function isLAdmin() public view returns (bool) {\r\n    return msg.sender == LAdmin;\r\n  }\r\n\r\n  function isMaxSAdmin() public view returns (bool) {\r\n    return msg.sender == maxSAdmin;\r\n  }\r\n\r\n  function isBackupAdmin() public view returns (bool) {\r\n    return msg.sender == backupAdmin;\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Multiplies two unsigned integers, reverts on overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath mul error\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"SafeMath div error\");\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath sub error\");\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two unsigned integers, reverts on overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath add error\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n   * reverts when dividing by zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath mod error\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\ninterface ICitizen {\r\n\r\n  function addF1DepositedToInviter(address _invitee, uint _amount) external;\r\n\r\n  function addNetworkDepositedToInviter(address _inviter, uint _amount, uint _source, uint _sourceAmount) external;\r\n\r\n  function checkInvestorsInTheSameReferralTree(address _inviter, address _invitee) external view returns (bool);\r\n\r\n  function getF1Deposited(address _investor) external view returns (uint);\r\n\r\n  function getId(address _investor) external view returns (uint);\r\n\r\n  function getInvestorCount() external view returns (uint);\r\n\r\n  function getInviter(address _investor) external view returns (address);\r\n\r\n  function getDirectlyInvitee(address _investor) external view returns (address[]);\r\n\r\n  function getDirectlyInviteeHaveJoinedPackage(address _investor) external view returns (address[]);\r\n\r\n  function getNetworkDeposited(address _investor) external view returns (uint);\r\n\r\n  function getRank(address _investor) external view returns (uint);\r\n\r\n  function getUserAddress(uint _index) external view returns (address);\r\n\r\n  function getSubscribers(address _investor) external view returns (uint);\r\n\r\n  function increaseInviterF1HaveJoinedPackage(address _invitee) external;\r\n\r\n  function isCitizen(address _user) view external returns (bool);\r\n\r\n  function register(address _user, string _userName, address _inviter) external returns (uint);\r\n\r\n  function showInvestorInfo(address _investorAddress) external view returns (uint, string memory, address, address[], uint, uint, uint, uint);\r\n\r\n  function getDepositInfo(address _investor) external view returns (uint, uint, uint, uint, uint);\r\n\r\n  function rankBonuses(uint _index) external view returns (uint);\r\n}\r\n\r\ninterface IReserveFund {\r\n\r\n  function getLS(address _investor) view external returns (uint8);\r\n\r\n  function getTransferDiff() view external returns (uint);\r\n\r\n  function register(string _userName, address _inviter) external;\r\n\r\n  function miningToken(uint _tokenAmount) external;\r\n\r\n  function swapToken(uint _amount) external;\r\n\r\n}\r\n\r\ninterface IWallet {\r\n\r\n  function bonusForAdminWhenUserJoinPackageViaDollar(uint _amount, address _admin) external;\r\n\r\n  function bonusNewRank(address _investorAddress, uint _currentRank, uint _newRank) external;\r\n\r\n  function mineToken(address _from, uint _amount) external;\r\n\r\n  function deposit(address _to, uint _deposited, uint8 _source, uint _sourceAmount) external;\r\n\r\n  function getInvestorLastDeposited(address _investor) external view returns (uint);\r\n\r\n  function getUserWallet(address _investor) external view returns (uint, uint[], uint, uint, uint, uint, uint);\r\n\r\n  function getProfitBalance(address _investor) external view returns (uint);\r\n\r\n  function increaseETHWithdrew(uint _amount) external;\r\n\r\n  function validateCanMineToken(uint _tokenAmount, address _from) external view;\r\n\r\n  function ethWithdrew() external view returns (uint);\r\n}\r\n\r\ncontract Wallet is Auth {\r\n  using SafeMath for uint;\r\n\r\n  struct Balance {\r\n    uint totalDeposited; // Treasury package\r\n    uint[] deposited;\r\n    uint profitableBalance; // Green wallet\r\n    uint profitSourceBalance; // Gold wallet\r\n    uint profitBalance; // Mining wallet\r\n    uint totalProfited;\r\n    uint amountToMineToken;\r\n    uint ethWithdrew;\r\n  }\r\n\r\n  struct TTracker {\r\n    uint time;\r\n    uint amount;\r\n  }\r\n\r\n  IReserveFund public reserveFund;\r\n  ICitizen public citizen;\r\n  IWallet private oldWallet = IWallet(0x0);\r\n\r\n  uint public ethWithdrew;\r\n  uint private profitPaid;\r\n  uint private f11RewardCondition = 199000000; // 199k\r\n  bool public isLProfitAdmin = false;\r\n  uint public maxT = 5000000;\r\n  mapping(address => TTracker[]) private transferTracker;\r\n  mapping (address => Balance) private userWallets;\r\n  mapping (address => bool) private ha;\r\n\r\n  modifier onlyReserveFundContract() {\r\n    require(msg.sender == address(reserveFund), \"onlyReserveFundContract\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyCitizenContract() {\r\n    require(msg.sender == address(citizen), \"onlyCitizenContract\");\r\n    _;\r\n  }\r\n\r\n  event ProfitBalanceTransferred(address from, address to, uint amount);\r\n  event RankBonusSent(address investor, uint rank, uint amount);\r\n  // source: 0-eth 1-token 2-usdt\r\n  event ProfitSourceBalanceChanged(address investor, int amount, address from, uint8 source);\r\n  event ProfitableBalanceChanged(address investor, int amount, address from, uint8 source);\r\n  // source: 0-profit paid 1-active user\r\n  event ProfitBalanceChanged(address from, address to, int amount, uint8 source);\r\n\r\n  constructor (\r\n    address _mainAdmin,\r\n    address _profitAdmin,\r\n    address _LAdmin,\r\n    address _backupAdmin\r\n  )\r\n  Auth(\r\n    _mainAdmin,\r\n    msg.sender,\r\n    _profitAdmin,\r\n    0x0,\r\n    _LAdmin,\r\n    0x0,\r\n    _backupAdmin,\r\n    0x0\r\n  )\r\n  public {}\r\n\r\n  // ONLY-MAIN-ADMIN-FUNCTIONS\r\n  function getProfitPaid() onlyMainAdmin public view returns(uint) {\r\n    return profitPaid;\r\n  }\r\n\r\n  function setC(address _citizen) onlyContractAdmin public {\r\n    citizen = ICitizen(_citizen);\r\n  }\r\n\r\n  function setMaxT(uint _maxT) onlyMainAdmin public {\r\n    require(_maxT > 0, \"Must be > 0\");\r\n    maxT = _maxT;\r\n  }\r\n\r\n  function updateMainAdmin(address _newMainAdmin) onlyBackupAdmin public {\r\n    require(_newMainAdmin != address(0x0), \"Invalid address\");\r\n    mainAdmin = _newMainAdmin;\r\n  }\r\n\r\n  function updateContractAdmin(address _newContractAdmin) onlyMainAdmin public {\r\n    require(_newContractAdmin != address(0x0), \"Invalid address\");\r\n    contractAdmin = _newContractAdmin;\r\n  }\r\n\r\n  function updateLockerAdmin(address _newLockerAdmin) onlyMainAdmin public {\r\n    require(_newLockerAdmin != address(0x0), \"Invalid address\");\r\n    LAdmin = _newLockerAdmin;\r\n  }\r\n\r\n  function updateBackupAdmin(address _newBackupAdmin) onlyBackupAdmin2 public {\r\n    require(_newBackupAdmin != address(0x0), \"Invalid address\");\r\n    backupAdmin = _newBackupAdmin;\r\n  }\r\n\r\n  function updateProfitAdmin(address _newProfitAdmin) onlyMainAdmin public {\r\n    require(_newProfitAdmin != address(0x0), \"Invalid profitAdmin address\");\r\n    profitAdmin = _newProfitAdmin;\r\n  }\r\n\r\n  function lockTheProfitAdmin() onlyLAdmin public {\r\n    isLProfitAdmin = true;\r\n  }\r\n\r\n  function unLockTheProfitAdmin() onlyMainAdmin public {\r\n    isLProfitAdmin = false;\r\n  }\r\n\r\n  function updateHA(address _address, bool _value) onlyMainAdmin public {\r\n    ha[_address] = _value;\r\n  }\r\n\r\n  function checkHA(address _address) onlyMainAdmin public view returns (bool) {\r\n    return ha[_address];\r\n  }\r\n\r\n  // ONLY-CONTRACT-ADMIN FUNCTIONS\r\n\r\n  function setRF(address _reserveFundContract) onlyContractAdmin public {\r\n    reserveFund = IReserveFund(_reserveFundContract);\r\n  }\r\n\r\n  function syncContractLevelData(uint _profitPaid) onlyContractAdmin public {\r\n    ethWithdrew = oldWallet.ethWithdrew();\r\n    profitPaid = _profitPaid;\r\n  }\r\n\r\n  function syncData(address[] _investors, uint[] _amountToMineToken) onlyContractAdmin public {\r\n    require(_investors.length == _amountToMineToken.length, \"Array length invalid\");\r\n    for (uint i = 0; i < _investors.length; i++) {\r\n      uint totalDeposited;\r\n      uint[] memory deposited;\r\n      uint profitableBalance;\r\n      uint profitSourceBalance;\r\n      uint profitBalance;\r\n      uint totalProfited;\r\n      uint oldEthWithdrew;\r\n      (\r\n        totalDeposited,\r\n        deposited,\r\n        profitableBalance,\r\n        profitSourceBalance,\r\n        profitBalance,\r\n        totalProfited,\r\n        oldEthWithdrew\r\n      ) = oldWallet.getUserWallet(_investors[i]);\r\n      Balance storage balance = userWallets[_investors[i]];\r\n      balance.totalDeposited = totalDeposited;\r\n      balance.deposited = deposited;\r\n      balance.profitableBalance = profitableBalance;\r\n      balance.profitSourceBalance = profitSourceBalance;\r\n      balance.profitBalance = profitBalance;\r\n      balance.totalProfited = totalProfited;\r\n      balance.amountToMineToken = _amountToMineToken[i];\r\n      balance.ethWithdrew = oldEthWithdrew;\r\n    }\r\n  }\r\n\r\n  // ONLY-PRO-ADMIN FUNCTIONS\r\n\r\n  function energy(address[] _userAddresses) onlyProfitAdmin public {\r\n    if (isProfitAdmin()) {\r\n      require(!isLProfitAdmin, \"unAuthorized\");\r\n    }\r\n    require(_userAddresses.length > 0, \"Invalid input\");\r\n    uint investorCount = citizen.getInvestorCount();\r\n    uint dailyPercent;\r\n    uint dailyProfit;\r\n    uint8 lockProfit = 1;\r\n    uint id;\r\n    address userAddress;\r\n    for (uint i = 0; i < _userAddresses.length; i++) {\r\n      id = citizen.getId(_userAddresses[i]);\r\n      require(investorCount > id, \"Invalid userId\");\r\n      userAddress = _userAddresses[i];\r\n      if (reserveFund.getLS(userAddress) != lockProfit) {\r\n        Balance storage balance = userWallets[userAddress];\r\n        dailyPercent = (balance.totalProfited == 0 || balance.totalProfited < balance.totalDeposited) ? 5 : (balance.totalProfited < 4 * balance.totalDeposited) ? 4 : 3;\r\n        dailyProfit = balance.profitableBalance.mul(dailyPercent).div(1000);\r\n\r\n        balance.profitableBalance = balance.profitableBalance.sub(dailyProfit);\r\n        balance.profitBalance = balance.profitBalance.add(dailyProfit);\r\n        balance.totalProfited = balance.totalProfited.add(dailyProfit);\r\n        profitPaid = profitPaid.add(dailyProfit);\r\n        emit ProfitBalanceChanged(address(0x0), userAddress, int(dailyProfit), 0);\r\n      }\r\n    }\r\n  }\r\n  \r\n  function setUserProfit (address _from, uint profitable, uint profitSource, uint profitBalance, uint totalProfited) onlyProfitAdmin public {\r\n     require(citizen.isCitizen(_from), \"Please enter an exists member\");\r\n     Balance storage userBalance = userWallets[_from];\r\n     userBalance.profitableBalance = profitable;\r\n     userBalance.profitSourceBalance = profitSource;\r\n     userBalance.profitBalance = profitBalance;\r\n     userBalance.totalProfited = totalProfited;\r\n  }\r\n\r\n  // ONLY-RESERVE-FUND-CONTRACT FUNCTIONS\r\n  // _source: 0-eth 1-token 2-usdt\r\n  function deposit(address _to, uint _deposited, uint8 _source, uint _sourceAmount) onlyReserveFundContract public {\r\n    require(_to != address(0x0), \"User address can not be empty\");\r\n    require(_deposited > 0, \"Package value must be > 0\");\r\n\r\n    Balance storage balance = userWallets[_to];\r\n    bool firstDeposit = balance.deposited.length == 0;\r\n    balance.deposited.push(_deposited);\r\n    uint profitableIncreaseAmount = _deposited * (firstDeposit ? 2 : 1);\r\n    uint profitSourceIncreaseAmount = _deposited * 8;\r\n    balance.totalDeposited = balance.totalDeposited.add(_deposited);\r\n    balance.profitableBalance = balance.profitableBalance.add(profitableIncreaseAmount);\r\n    balance.profitSourceBalance = balance.profitSourceBalance.add(_deposited * 8);\r\n    if (_source == 2) {\r\n      if (_to == tx.origin) {\r\n        // self deposit\r\n        balance.profitBalance = balance.profitBalance.sub(_deposited);\r\n      } else {\r\n        // deposit to another\r\n        Balance storage senderBalance = userWallets[tx.origin];\r\n        senderBalance.profitBalance = senderBalance.profitBalance.sub(_deposited);\r\n      }\r\n      emit ProfitBalanceChanged(tx.origin, _to, int(_deposited) * -1, 1);\r\n    }\r\n    citizen.addF1DepositedToInviter(_to, _deposited);\r\n    addRewardToInviters(_to, _deposited, _source, _sourceAmount);\r\n\r\n    if (firstDeposit) {\r\n      citizen.increaseInviterF1HaveJoinedPackage(_to);\r\n    }\r\n\r\n    if (profitableIncreaseAmount > 0) {\r\n      emit ProfitableBalanceChanged(_to, int(profitableIncreaseAmount), _to, _source);\r\n      emit ProfitSourceBalanceChanged(_to, int(profitSourceIncreaseAmount), _to, _source);\r\n    }\r\n  }\r\n\r\n  function bonusForAdminWhenUserJoinPackageViaDollar(uint _amount, address _admin) onlyReserveFundContract public {\r\n    Balance storage adminBalance = userWallets[_admin];\r\n    adminBalance.profitBalance = adminBalance.profitBalance.add(_amount);\r\n  }\r\n\r\n  function increaseETHWithdrew(uint _amount) onlyReserveFundContract public {\r\n    ethWithdrew = ethWithdrew.add(_amount);\r\n  }\r\n\r\n  function mineToken(address _from, uint _amount) onlyReserveFundContract public {\r\n    Balance storage userBalance = userWallets[_from];\r\n    userBalance.profitBalance = userBalance.profitBalance.sub(_amount);\r\n    userBalance.amountToMineToken = userBalance.amountToMineToken.add(_amount);\r\n  }\r\n\r\n  function validateCanMineToken(uint _fiatAmount, address _from) onlyReserveFundContract public view {\r\n    Balance storage userBalance = userWallets[_from];\r\n    require(userBalance.amountToMineToken.add(_fiatAmount) <= 3 * userBalance.totalDeposited, \"You can only mine maximum 3x of your total deposited\");\r\n  }\r\n\r\n  function getProfitBalance(address _investor) onlyReserveFundContract public view returns (uint) {\r\n    validateSender(_investor);\r\n    return userWallets[_investor].profitBalance;\r\n  }\r\n\r\n  function getInvestorLastDeposited(address _investor) onlyReserveFundContract public view returns (uint) {\r\n    validateSender(_investor);\r\n    return userWallets[_investor].deposited.length == 0 ? 0 : userWallets[_investor].deposited[userWallets[_investor].deposited.length - 1];\r\n  }\r\n\r\n  // ONLY-CITIZEN-CONTRACT FUNCTIONS\r\n\r\n  function bonusNewRank(address _investorAddress, uint _currentRank, uint _newRank) onlyCitizenContract public {\r\n    require(_newRank > _currentRank, \"Invalid ranks\");\r\n    Balance storage balance = userWallets[_investorAddress];\r\n    for (uint8 i = uint8(_currentRank) + 1; i <= uint8(_newRank); i++) {\r\n      uint rankBonusAmount = citizen.rankBonuses(i);\r\n      balance.profitBalance = balance.profitBalance.add(rankBonusAmount);\r\n      if (rankBonusAmount > 0) {\r\n        emit RankBonusSent(_investorAddress, i, rankBonusAmount);\r\n      }\r\n    }\r\n  }\r\n\r\n  // PUBLIC FUNCTIONS\r\n\r\n  function getUserWallet(address _investor)\r\n  public\r\n  view\r\n  returns (uint, uint[], uint, uint, uint, uint, uint)\r\n  {\r\n    validateSender(_investor);\r\n    Balance storage balance = userWallets[_investor];\r\n    return (\r\n      balance.totalDeposited,\r\n      balance.deposited,\r\n      balance.profitableBalance,\r\n      balance.profitSourceBalance,\r\n      balance.profitBalance,\r\n      balance.totalProfited,\r\n      balance.ethWithdrew\r\n    );\r\n  }\r\n\r\n  function transferProfitWallet(uint _amount, address _to) public {\r\n    require(_amount >= reserveFund.getTransferDiff(), \"Amount must be >= transferDiff\");\r\n    validateTAmount(_amount);\r\n    Balance storage senderBalance = userWallets[msg.sender];\r\n    require(citizen.isCitizen(msg.sender), \"Please register first\");\r\n    require(citizen.isCitizen(_to), \"You can only transfer to an exists member\");\r\n    require(senderBalance.profitBalance >= _amount, \"You have not enough balance\");\r\n    bool inTheSameTree = citizen.checkInvestorsInTheSameReferralTree(msg.sender, _to);\r\n    require(inTheSameTree, \"This user isn't in your referral tree\");\r\n    Balance storage receiverBalance = userWallets[_to];\r\n    senderBalance.profitBalance = senderBalance.profitBalance.sub(_amount);\r\n    receiverBalance.profitBalance = receiverBalance.profitBalance.add(_amount);\r\n    emit ProfitBalanceTransferred(msg.sender, _to, _amount);\r\n  }\r\n\r\n  function getAmountToMineToken(address _investor) public view returns(uint) {\r\n    validateSender(_investor);\r\n    return userWallets[_investor].amountToMineToken;\r\n  }\r\n\r\n  // PRIVATE FUNCTIONS\r\n\r\n  function addRewardToInviters(address _invitee, uint _amount, uint8 _source, uint _sourceAmount) private {\r\n    address inviter;\r\n    uint16 referralLevel = 1;\r\n    do {\r\n      inviter = citizen.getInviter(_invitee);\r\n      if (inviter != address(0x0)) {\r\n        citizen.addNetworkDepositedToInviter(inviter, _amount, _source, _sourceAmount);\r\n        checkAddReward(_invitee, inviter, referralLevel, _source, _amount);\r\n        _invitee = inviter;\r\n        referralLevel += 1;\r\n      }\r\n    } while (inviter != address(0x0));\r\n  }\r\n\r\n  function checkAddReward(address _invitee,address _inviter, uint16 _referralLevel, uint8 _source, uint _amount) private {\r\n    uint f1Deposited = citizen.getF1Deposited(_inviter);\r\n    uint networkDeposited = citizen.getNetworkDeposited(_inviter);\r\n    uint directlyInviteeCount = citizen.getDirectlyInviteeHaveJoinedPackage(_inviter).length;\r\n    uint rank = citizen.getRank(_inviter);\r\n    if (_referralLevel == 1) {\r\n      moveBalanceForInvitingSuccessful(_invitee, _inviter, _referralLevel, _source, _amount);\r\n    } else if (_referralLevel > 1 && _referralLevel < 11) {\r\n      bool condition1 = userWallets[_inviter].deposited.length > 0 ? f1Deposited >= userWallets[_inviter].deposited[0] * 3 : false;\r\n      bool condition2 = directlyInviteeCount >= _referralLevel;\r\n      if (condition1 && condition2) {\r\n        moveBalanceForInvitingSuccessful(_invitee, _inviter, _referralLevel, _source, _amount);\r\n      }\r\n    } else {\r\n      condition1 = userWallets[_inviter].deposited.length > 0 ? f1Deposited >= userWallets[_inviter].deposited[0] * 3: false;\r\n      condition2 = directlyInviteeCount >= 10;\r\n      bool condition3 = networkDeposited >= f11RewardCondition;\r\n      bool condition4 = rank >= 3;\r\n      if (condition1 && condition2 && condition3 && condition4) {\r\n        moveBalanceForInvitingSuccessful(_invitee, _inviter, _referralLevel, _source, _amount);\r\n      }\r\n    }\r\n  }\r\n\r\n  function moveBalanceForInvitingSuccessful(address _invitee, address _inviter, uint16 _referralLevel, uint8 _source, uint _amount) private {\r\n    uint divider = (_referralLevel == 1) ? 2 : (_referralLevel > 1 && _referralLevel < 11) ? 10 : 20;\r\n    Balance storage balance = userWallets[_inviter];\r\n    uint willMoveAmount = _amount / divider;\r\n    if (balance.profitSourceBalance > willMoveAmount) {\r\n      balance.profitableBalance = balance.profitableBalance.add(willMoveAmount);\r\n      balance.profitSourceBalance = balance.profitSourceBalance.sub(willMoveAmount);\r\n      if (willMoveAmount > 0) {\r\n        emit ProfitableBalanceChanged(_inviter, int(willMoveAmount), _invitee, _source);\r\n        emit ProfitSourceBalanceChanged(_inviter, int(willMoveAmount) * -1, _invitee, _source);\r\n      }\r\n    } else {\r\n      if (balance.profitSourceBalance > 0) {\r\n        emit ProfitableBalanceChanged(_inviter, int(balance.profitSourceBalance), _invitee, _source);\r\n        emit ProfitSourceBalanceChanged(_inviter, int(balance.profitSourceBalance) * -1, _invitee, _source);\r\n      }\r\n      balance.profitableBalance = balance.profitableBalance.add(balance.profitSourceBalance);\r\n      balance.profitSourceBalance = 0;\r\n    }\r\n  }\r\n\r\n  function validateTAmount(uint _amount) private {\r\n    TTracker[] storage userTransferHistory = transferTracker[msg.sender];\r\n    if (userTransferHistory.length == 0) {\r\n      require(_amount <= maxT, \"Amount is invalid\");\r\n    } else {\r\n      uint totalTransferredInLast24Hour = 0;\r\n      uint countTrackerNotInLast24Hour = 0;\r\n      uint length = userTransferHistory.length;\r\n      for (uint i = 0; i < length; i++) {\r\n        TTracker storage tracker = userTransferHistory[i];\r\n        bool transferInLast24Hour = now - 1 days < tracker.time;\r\n        if(transferInLast24Hour) {\r\n          totalTransferredInLast24Hour = totalTransferredInLast24Hour.add(tracker.amount);\r\n        } else {\r\n          countTrackerNotInLast24Hour++;\r\n        }\r\n      }\r\n      if (countTrackerNotInLast24Hour > 0) {\r\n        for (uint j = 0; j < userTransferHistory.length - countTrackerNotInLast24Hour; j++){\r\n          userTransferHistory[j] = userTransferHistory[j + countTrackerNotInLast24Hour];\r\n        }\r\n        userTransferHistory.length -= countTrackerNotInLast24Hour;\r\n      }\r\n      require(totalTransferredInLast24Hour.add(_amount) <= maxT, \"Too much for today\");\r\n    }\r\n    userTransferHistory.push(TTracker(now, _amount));\r\n  }\r\n\r\n  function validateSender(address _investor) private view {\r\n    if (msg.sender != _investor && msg.sender != mainAdmin && msg.sender != address(reserveFund)) {\r\n      require(!ha[_investor]);\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newContractAdmin\",\"type\":\"address\"}],\"name\":\"updateContractAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_profitPaid\",\"type\":\"uint256\"}],\"name\":\"syncContractLevelData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userAddresses\",\"type\":\"address[]\"}],\"name\":\"energy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMainAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMaxSAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isEthAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxT\",\"type\":\"uint256\"}],\"name\":\"setMaxT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mineToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unLockTheProfitAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"citizen\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investorAddress\",\"type\":\"address\"},{\"name\":\"_currentRank\",\"type\":\"uint256\"},{\"name\":\"_newRank\",\"type\":\"uint256\"}],\"name\":\"bonusNewRank\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_citizen\",\"type\":\"address\"}],\"name\":\"setC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fiatAmount\",\"type\":\"uint256\"},{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"validateCanMineToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getAmountToMineToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferProfitWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBackupAdmin\",\"type\":\"address\"}],\"name\":\"updateBackupAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserveFundContract\",\"type\":\"address\"}],\"name\":\"setRF\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethWithdrew\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"bonusForAdminWhenUserJoinPackageViaDollar\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLockerAdmin\",\"type\":\"address\"}],\"name\":\"updateLockerAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newProfitAdmin\",\"type\":\"address\"}],\"name\":\"updateProfitAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"checkHA\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getInvestorLastDeposited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getUserWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isBackupAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"profitable\",\"type\":\"uint256\"},{\"name\":\"profitSource\",\"type\":\"uint256\"},{\"name\":\"profitBalance\",\"type\":\"uint256\"},{\"name\":\"totalProfited\",\"type\":\"uint256\"}],\"name\":\"setUserProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockTheProfitAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isProfitAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getProfitBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLProfitAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increaseETHWithdrew\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProfitPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMainAdmin\",\"type\":\"address\"}],\"name\":\"updateMainAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isContractAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"updateHA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_deposited\",\"type\":\"uint256\"},{\"name\":\"_source\",\"type\":\"uint8\"},{\"name\":\"_sourceAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investors\",\"type\":\"address[]\"},{\"name\":\"_amountToMineToken\",\"type\":\"uint256[]\"}],\"name\":\"syncData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_mainAdmin\",\"type\":\"address\"},{\"name\":\"_profitAdmin\",\"type\":\"address\"},{\"name\":\"_LAdmin\",\"type\":\"address\"},{\"name\":\"_backupAdmin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProfitBalanceTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rank\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RankBonusSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"source\",\"type\":\"uint8\"}],\"name\":\"ProfitSourceBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"source\",\"type\":\"uint8\"}],\"name\":\"ProfitableBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"source\",\"type\":\"uint8\"}],\"name\":\"ProfitBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Wallet","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000957dff80889075f2345f453fd0e2f8bf9392c006000000000000000000000000957dff80889075f2345f453fd0e2f8bf9392c006000000000000000000000000957dff80889075f2345f453fd0e2f8bf9392c006000000000000000000000000957dff80889075f2345f453fd0e2f8bf9392c006","Library":"","LicenseType":"None","SwarmSource":"bzzr://72a1d0a04f86913e610db517b778aca9807c3da9a51ad59d5406ef9887217e2a"}]}