{"status":"1","message":"OK","result":[{"SourceCode":"{\"Approves.sol\":{\"content\":\"/**\\n\\n    The software and documentation available in this repository (the \\\"Software\\\") is\\n    protected by copyright law and accessible pursuant to the license set forth below.\\n\\n    Copyright © 2019 Staked Securely, Inc. All rights reserved.\\n\\n    Permission is hereby granted, free of charge, to any person or organization\\n    obtaining the Software (the “Licensee”) to privately study, review, and analyze\\n    the Software. Licensee shall not use the Software for any other purpose. Licensee\\n    shall not modify, transfer, assign, share, or sub-license the Software or any\\n    derivative works of the Software.\\n\\n    THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\\n    PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT\\n    HOLDERS BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT,\\n    OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE.\\n\\n*/\\n\\npragma solidity 0.4.25;\\n\\n\\n/// @notice  Inherited by contracts that need to expose the ERC20 \\\"approve()\\\"\\n\\ninterface Approves {\\n\\n  function approve(address token, address beneficiary, uint amount) external;\\n\\n}\\n\"},\"IERC165.sol\":{\"content\":\"pragma solidity 0.4.25;\\n\\n/**\\n * @title IERC165\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\n */\\ninterface IERC165 {\\n    /**\\n     * @notice Query if a contract implements an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @dev Interface identification is specified in ERC-165. This function\\n     * uses less than 30,000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity 0.4.25;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IERC721.sol\":{\"content\":\"pragma solidity 0.4.25;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic interface\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function balanceOf(address owner) public view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\n\\n    function approve(address to, uint256 tokenId) public;\\n    function getApproved(uint256 tokenId) public view returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) public;\\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public;\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes data) public;\\n}\\n\"},\"IERC721Receiver.sol\":{\"content\":\"pragma solidity 0.4.25;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ncontract IERC721Receiver {\\n    /**\\n     * @notice Handle the receipt of an NFT\\n     * @dev The ERC721 smart contract calls this function on the recipient\\n     * after a `safeTransfer`. This function MUST return the function selector,\\n     * otherwise the caller will revert the transaction. The selector to be\\n     * returned can be obtained as `this.onERC721Received.selector`. This\\n     * function MAY throw to revert and reject the transfer.\\n     * Note: the ERC721 contract address is always the message sender.\\n     * @param operator The address which called `safeTransferFrom` function\\n     * @param from The address which previously owned the token\\n     * @param tokenId The NFT identifier which is being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes data) public returns (bytes4);\\n}\\n\"},\"IFeeModel.sol\":{\"content\":\"/**\\n\\n    The software and documentation available in this repository (the \\\"Software\\\") is\\n    protected by copyright law and accessible pursuant to the license set forth below.\\n\\n    Copyright © 2019 Staked Securely, Inc. All rights reserved.\\n\\n    Permission is hereby granted, free of charge, to any person or organization\\n    obtaining the Software (the “Licensee”) to privately study, review, and analyze\\n    the Software. Licensee shall not use the Software for any other purpose. Licensee\\n    shall not modify, transfer, assign, share, or sub-license the Software or any\\n    derivative works of the Software.\\n\\n    THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\\n    PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT\\n    HOLDERS BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT,\\n    OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE.\\n\\n*/\\n\\npragma solidity 0.4.25;\\n\\ninterface IFeeModel {\\n\\n  function updateAllowance(bytes32 key, bytes32 tokenId) external returns(uint);\\n\\n  function takeFee(bytes32 key, bytes32 tokenId, uint valueToWithdraw) external returns(uint);\\n\\n  function updateCumulativeRate(address principalAddress) external returns(uint);\\n\\n}\\n\"},\"INAVCalculator.sol\":{\"content\":\"/**\\n\\n    The software and documentation available in this repository (the \\\"Software\\\") is\\n    protected by copyright law and accessible pursuant to the license set forth below.\\n\\n    Copyright © 2019 Staked Securely, Inc. All rights reserved.\\n\\n    Permission is hereby granted, free of charge, to any person or organization\\n    obtaining the Software (the “Licensee”) to privately study, review, and analyze\\n    the Software. Licensee shall not use the Software for any other purpose. Licensee\\n    shall not modify, transfer, assign, share, or sub-license the Software or any\\n    derivative works of the Software.\\n\\n    THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\\n    PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT\\n    HOLDERS BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT,\\n    OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE.\\n\\n*/\\n\\npragma solidity 0.4.25;\\n\\ninterface INAVCalculator {\\n\\n  function updateYield(bytes32 key, uint yield) external;\\n\\n  function getPortfolioPricePerShare(bytes32 key) external view returns(uint);\\n\\n  function getTotalYieldPerShare(bytes32 key) external view returns(uint);\\n\\n  function getPortfolioUnrealizedYield(bytes32 portfolioKey) external view returns (uint);\\n\\n  function getOpportunityPricePerShare(bytes32 opportunityKey) external view returns (uint);\\n\\n  function getOpportunityYield(\\n    bytes32 key,\\n    bytes32 opportunityKey,\\n    uint amountToWithdraw\\n  )\\n    external\\n    view\\n    returns (uint);\\n\\n function getOpportunityBalance(bytes32 key, bytes32 opportunityKey) external view returns(uint);\\n\\n function calculatePayableAmount(address principalAddress, uint value) external view returns(bool, uint);\\n\\n function onlyTokenOwner(bytes32 tokenId, address origCaller, address msgSender) external view returns (address);\\n\\n function getTokenValue(bytes32 key, bytes32 tokenId) external view returns (uint, uint);\\n\\n}\\n\"},\"IOpportunityManager.sol\":{\"content\":\"/**\\n\\n    The software and documentation available in this repository (the \\\"Software\\\") is\\n    protected by copyright law and accessible pursuant to the license set forth below.\\n\\n    Copyright © 2019 Staked Securely, Inc. All rights reserved.\\n\\n    Permission is hereby granted, free of charge, to any person or organization\\n    obtaining the Software (the “Licensee”) to privately study, review, and analyze\\n    the Software. Licensee shall not use the Software for any other purpose. Licensee\\n    shall not modify, transfer, assign, share, or sub-license the Software or any\\n    derivative works of the Software.\\n\\n    THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\\n    PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT\\n    HOLDERS BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT,\\n    OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE.\\n\\n*/\\n\\npragma solidity 0.4.25;\\n\\ninterface IOpportunityManager {\\n\\n  function buyPosition(\\n    bytes32 key,\\n    address beneficiary,\\n    address opportunity,\\n    address principalToken,\\n    uint value,\\n    bool isERC20\\n  )\\n    external\\n    payable\\n    returns (bytes32);\\n\\n  function increasePosition(\\n    bytes32 key,\\n    bytes32 tokenId,\\n    address opportunity,\\n    address principalToken,\\n    uint value,\\n    bool isERC20\\n  )\\n    external\\n    payable;\\n\\n  function withdrawPosition(\\n    bytes32 key,\\n    bytes32 tokenId,\\n    address opportunity,\\n    address principalToken,\\n    uint valueToWithdraw,\\n    bool isERC20)\\n    external;\\n\\n}\\n\"},\"IOracle.sol\":{\"content\":\"/**\\n\\n    The software and documentation available in this repository (the \\\"Software\\\") is\\n    protected by copyright law and accessible pursuant to the license set forth below.\\n\\n    Copyright © 2019 Staked Securely, Inc. All rights reserved.\\n\\n    Permission is hereby granted, free of charge, to any person or organization\\n    obtaining the Software (the “Licensee”) to privately study, review, and analyze\\n    the Software. Licensee shall not use the Software for any other purpose. Licensee\\n    shall not modify, transfer, assign, share, or sub-license the Software or any\\n    derivative works of the Software.\\n\\n    THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\\n    PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT\\n    HOLDERS BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT,\\n    OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE.\\n\\n*/\\n\\npragma solidity 0.4.25;\\n\\ninterface IOracle {\\n\\n  function withdrawFromProtocols(\\n    bytes32 key,\\n    uint valueToWithdraw,\\n    uint totalValue\\n  )\\n    external\\n    returns (uint);\\n\\n}\\n\"},\"IPositionManager.sol\":{\"content\":\"/**\\n\\n    The software and documentation available in this repository (the \\\"Software\\\") is\\n    protected by copyright law and accessible pursuant to the license set forth below.\\n\\n    Copyright © 2019 Staked Securely, Inc. All rights reserved.\\n\\n    Permission is hereby granted, free of charge, to any person or organization\\n    obtaining the Software (the “Licensee”) to privately study, review, and analyze\\n    the Software. Licensee shall not use the Software for any other purpose. Licensee\\n    shall not modify, transfer, assign, share, or sub-license the Software or any\\n    derivative works of the Software.\\n\\n    THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\\n    PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT\\n    HOLDERS BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT,\\n    OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE.\\n\\n*/\\n\\npragma solidity 0.4.25;\\n\\n\\n/**\\n* Short-term this will be only used to verify contracts upon migrations.\\n* In the future this will be the single source of truth for all contracts,\\n* they\\u0027ll all direct calls to this contract, which will act as a Router.\\n*\\n* Name: Registry\\n* Version: 1.0\\n*/\\n\\ninterface IPositionManager {\\n\\n  function updateTokenUponWithdrawal(\\n      bytes32 opportunityKey,\\n      bytes32 tokenId,\\n      uint valueToWithdraw,\\n      uint pricePerShare,\\n      uint shares,\\n      uint unrealizedYield\\n  )\\n      external;\\n\\n\\n    function createToken(\\n      bytes32 opportunityKey,\\n      address token,\\n      address beneficiary,\\n      uint value,\\n      uint pricePerShare\\n    )\\n      external\\n      returns (bytes32);\\n\\n    function increaseTokenCapital(\\n        bytes32 opportunityKey,\\n        bytes32 tokenId,\\n        uint pricePerShare,\\n        uint value\\n    )\\n        external;\\n\\n    function verifyWithdrawer(\\n      bytes32 opportunityKey,\\n      bytes32 tokenId,\\n      address token,\\n      address sender,\\n      uint pricePerShare,\\n      uint valueToWithdraw,\\n      uint totalValue\\n    )\\n      external\\n      returns (address);\\n\\n}\\n\"},\"IRAYToken.sol\":{\"content\":\"/**\\n\\n    The software and documentation available in this repository (the \\\"Software\\\") is\\n    protected by copyright law and accessible pursuant to the license set forth below.\\n\\n    Copyright © 2019 Staked Securely, Inc. All rights reserved.\\n\\n    Permission is hereby granted, free of charge, to any person or organization\\n    obtaining the Software (the “Licensee”) to privately study, review, and analyze\\n    the Software. Licensee shall not use the Software for any other purpose. Licensee\\n    shall not modify, transfer, assign, share, or sub-license the Software or any\\n    derivative works of the Software.\\n\\n    THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\\n    PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT\\n    HOLDERS BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT,\\n    OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE.\\n\\n*/\\n\\npragma solidity 0.4.25;\\n\\ninterface IRAYToken {\\n\\n\\tfunction mintRAYToken(bytes32 key, address beneficiary) external returns (bytes32);\\n\\n\\tfunction ownerOf(uint256 tokenId) external view returns (address);\\n\\n\\tfunction tokenExists(bytes32 tokenId) external view returns (bool exists);\\n\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n\\tfunction burn(uint256 tokenId) external;\\n\\n}\\n\"},\"IStorage.sol\":{\"content\":\"/**\\n\\n    The software and documentation available in this repository (the \\\"Software\\\") is\\n    protected by copyright law and accessible pursuant to the license set forth below.\\n\\n    Copyright © 2019 Staked Securely, Inc. All rights reserved.\\n\\n    Permission is hereby granted, free of charge, to any person or organization\\n    obtaining the Software (the “Licensee”) to privately study, review, and analyze\\n    the Software. Licensee shall not use the Software for any other purpose. Licensee\\n    shall not modify, transfer, assign, share, or sub-license the Software or any\\n    derivative works of the Software.\\n\\n    THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\\n    PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT\\n    HOLDERS BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT,\\n    OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE.\\n\\n*/\\n\\npragma solidity 0.4.25;\\n\\n\\n/**\\n* Short-term this will be only used to verify contracts upon migrations.\\n* In the future this will be the single source of truth for all contracts,\\n* they\\u0027ll all direct calls to this contract, which will act as a Router.\\n*\\n* Name: Registry\\n* Version: 1.0\\n*/\\n\\ninterface IStorage {\\n\\n  function getIsOracle(address target) external view returns (bool);\\n\\n  function getGovernanceWallet() external view returns (address);\\n\\n  function isValidOpportunity(bytes32 ray, bytes32 opportunityKey) external view returns (bool);\\n\\n  function getVerifier(bytes32 contractName) external view returns (address);\\n\\n  function addOpportunity(bytes32 ray, bytes32 opportunityKey, address _principalAddress) external;\\n\\n  function setValidOpportunity(bytes32 ray, bytes32 opportunityKey) external;\\n\\n  function getTokenKey(bytes32 tokenId) external view returns (bytes32);\\n\\n  function deleteTokenValues(bytes32 ray, bytes32 tokenId) external;\\n\\n  function getOpportunityTokenContract() external view returns (address);\\n\\n  function getPrincipalAddress(bytes32 ray) external view returns (address);\\n\\n  function getIsERC20(address principalAddress) external view returns (bool);\\n\\n  function getOpportunities(bytes32 ray) external view returns (bytes32[]);\\n\\n  function getContractAddress(bytes32 contractId) external view returns (address);\\n\\n  function setTokenKey(bytes32 tokenId, bytes32 ray) external;\\n\\n  function setEntryRate(bytes32 ray, bytes32 tokenId, uint tokenMaturityTime) external;\\n\\n  function setAvailableCapital(bytes32 ray, uint newAvailableCapital) external;\\n\\n  function getAvailableCapital(bytes32 ray) external view returns (uint);\\n\\n  function getWithdrawnYield(bytes32 ray) external view returns (uint);\\n\\n  function getCumulativeRate(bytes32 ray) external view returns (uint);\\n\\n  function getLastUpdatedRate(bytes32 ray) external view returns (uint);\\n\\n  function setWithdrawnYield(bytes32 ray, uint newWithdrawnYield) external;\\n\\n  function setCumulativeRate(bytes32 ray, uint newCumulativeRate) external;\\n\\n  function setLastUpdatedRate(bytes32 ray, uint newLastUpdatedRate) external;\\n\\n  function setRealizedYield(bytes32 ray, uint newRealizedYield) external;\\n\\n  function getRealizedYield(bytes32 ray) external view returns (uint);\\n\\n  function getOpportunityToken(bytes32 ray, bytes32 opportunity) external view returns (bytes32);\\n\\n  function setOpportunityToken(bytes32 ray, bytes32 opportunity, bytes32 tokenId) external;\\n\\n  function getEntryRate(bytes32 ray, bytes32 tokenId) external view returns (uint);\\n\\n  function setTokenAllowance(bytes32 ray, bytes32 tokenId, uint tokenAllowance) external;\\n\\n  function setTokenCapital(bytes32 ray, bytes32 tokenId, uint tokenCapital) external;\\n\\n  function setACPContribution(bytes32 ray, uint newACPContribution) external;\\n\\n  function getACPContribution(bytes32 ray) external view returns (uint);\\n\\n  function getPausedMode(bytes32 ray) external view returns (bool);\\n\\n  function getShareSupply(bytes32 ray) external view returns (uint);\\n\\n  function getTokenShares(bytes32 ray, bytes32 tokenId) external view returns (uint);\\n\\n  function getTokenCapital(bytes32 ray, bytes32 tokenId) external view returns (uint);\\n\\n  function getTokenAllowance(bytes32 ray, bytes32 tokenId) external view returns (uint);\\n\\n  function getRate(bytes32 ray) external view returns (uint);\\n\\n  function setRate(bytes32 ray, uint newRate) external;\\n\\n  function setPausedOn(bytes32 ray) external;\\n\\n  function setPausedOff(bytes32 ray) external;\\n\\n}\\n\"},\"IStorageWrapper.sol\":{\"content\":\"/**\\n\\n    The software and documentation available in this repository (the \\\"Software\\\") is\\n    protected by copyright law and accessible pursuant to the license set forth below.\\n\\n    Copyright © 2019 Staked Securely, Inc. All rights reserved.\\n\\n    Permission is hereby granted, free of charge, to any person or organization\\n    obtaining the Software (the “Licensee”) to privately study, review, and analyze\\n    the Software. Licensee shall not use the Software for any other purpose. Licensee\\n    shall not modify, transfer, assign, share, or sub-license the Software or any\\n    derivative works of the Software.\\n\\n    THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\\n    PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT\\n    HOLDERS BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT,\\n    OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE.\\n\\n*/\\n\\npragma solidity 0.4.25;\\n\\ninterface IStorageWrapper {\\n\\n\\n  /********************* ACCESSOR FUNCTIONS ***********************/\\n\\n\\n  function getVerifier(bytes32 contractName) external view returns (address);\\n\\n\\n  function getContractAddress(bytes32 contractName) external view returns (address);\\n\\n\\n  function getStakedWallet() external view returns (address);\\n\\n\\n  function getIsOracle(address target) external view returns (bool);\\n\\n\\n  function getPrincipalAddress(bytes32 ray) external view returns (address);\\n\\n\\n  /********************* MUTATOR FUNCTIONS ***********************/\\n\\n\\n  function setMinAmount(address principalAddress, uint _minAmount) external;\\n\\n\\n  function setRaised(address principalAddress, uint _raised) external;\\n\\n\\n  function setGovernanceWallet(address newGovernanceWallet) external;\\n\\n\\n  function setOracle(address newOracle, bool action) external;\\n\\n\\n  function setContractAddress(bytes32 contractName, address contractAddress) external;\\n\\n\\n  function setStorageWrapperContract(address theStorageWrapper, bool action) external;\\n\\n\\n  function setVerifier(bytes32 ray, address contractAddress) external;\\n\\n\\n  function setTokenKey(bytes32 tokenId, bytes32 ray) external;\\n\\n\\n  function setIsERC20(address principalAddress, bool _isERC20) external;\\n\\n\\n  function deleteTokenValues(bytes32 ray, bytes32 tokenId) external;\\n\\n\\n  function addOpportunity(bytes32 ray, bytes32 opportunityKey, address principalAddress) external;\\n\\n\\n  function setPrincipalAddress(bytes32 ray, address principalAddress) external;\\n\\n\\n  function setValidOpportunity(bytes32 ray, bytes32 opportunityKey) external;\\n\\n\\n  function setTokenShares(bytes32 ray, bytes32 tokenId, uint tokenShares) external;\\n\\n\\n  function setTokenCapital(bytes32 ray, bytes32 tokenId, uint tokenCapital) external;\\n\\n\\n  function setTokenAllowance(bytes32 ray, bytes32 tokenId, uint tokenAllowance) external;\\n\\n\\n  function setEntryRate(bytes32 ray, bytes32 tokenId, uint entryRate) external;\\n\\n\\n  function setOpportunityToken(bytes32 ray, bytes32 opportunity, bytes32 tokenId) external;\\n\\n\\n  function setPrincipal(bytes32 opportunityKey, uint principalAmount) external;\\n\\n\\n  function setPausedOn(bytes32 ray) external;\\n\\n\\n  function setPausedOff(bytes32 ray) external;\\n\\n\\n  function setRealizedYield(bytes32 ray, uint newRealizedYield) external;\\n\\n\\n  function setWithdrawnYield(bytes32 ray, uint newWithdrawnYield) external;\\n\\n\\n  function setCumulativeRate(address principalAddress, uint newCumulativeRate) external;\\n\\n\\n  function setLastUpdatedRate(address principalAddress, uint newLastUpdatedRate) external;\\n\\n\\n  function setBenchmarkRate(address principalAddress, uint newRate) external;\\n\\n\\n  function setACPContribution(address principalAddress, uint newStakedProfit) external;\\n\\n\\n  function setAvailableCapital(bytes32 ray, uint newAvailableCapital) external;\\n\\n\\n  function setShareSupply(bytes32 ray, uint newShareSupply) external;\\n\\n\\n}\\n\"},\"PortfolioManager.sol\":{\"content\":\"/**\\n\\n    The software and documentation available in this repository (the \\\"Software\\\") is\\n    protected by copyright law and accessible pursuant to the license set forth below.\\n\\n    Copyright © 2019 Staked Securely, Inc. All rights reserved.\\n\\n    Permission is hereby granted, free of charge, to any person or organization\\n    obtaining the Software (the “Licensee”) to privately study, review, and analyze\\n    the Software. Licensee shall not use the Software for any other purpose. Licensee\\n    shall not modify, transfer, assign, share, or sub-license the Software or any\\n    derivative works of the Software.\\n\\n    THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\\n    PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT\\n    HOLDERS BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT,\\n    OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE.\\n\\n*/\\n\\npragma solidity 0.4.25;\\n\\n\\n// external dependencies\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n// internal dependencies\\nimport \\\"./Approves.sol\\\";\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"./IOpportunityManager.sol\\\";\\nimport \\\"./IPositionManager.sol\\\";\\nimport \\\"./IFeeModel.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\nimport \\\"./INAVCalculator.sol\\\";\\nimport \\\"./IRAYToken.sol\\\";\\nimport \\\"./IStorageWrapper.sol\\\";\\nimport \\\"./IStorage.sol\\\";\\n\\n\\n\\n /// @notice  PortfolioManager accepts users tokens and mints RAY Tokens [RAYT].\\n ///          The owner of the loans is the RAYT, not the user\\n ///\\n /// NOTE:    ID\\u0027s for different RAY Combinations are generated by hashing the string\\n ///          of the used protocols names concatenated together in alphabetical order.\\n ///          Ex. A RAY that lends to dydx,compound,nuo UUID = keccak256(\\u0027EthCompoundDydxNuo\\u0027);\\n ///          We also concatenate the ticker of the currency at the front.\\n ///\\n ///          ID\\u0027s are \\u0027keys\\u0027. They unlock the storage of the appropriate portfolio.\\n ///\\n /// TODO:    Gas saving functionality in all contracts [once design is settled]\\n ///\\n /// Author:   Devan Purhar\\n /// Version:  1.0.0\\n\\ncontract PortfolioManager is IERC721Receiver, Upgradeable, Approves {\\n    using SafeMath\\n    for uint256;\\n\\n\\n    /*************** STORAGE VARIABLE DECLARATIONS **************/\\n\\n    /* TODO: Re-order declarations for gas optimization (not important for now) */\\n\\n\\n    // contracts used\\n    bytes32 internal constant RAY_TOKEN_CONTRACT = keccak256(\\\"RAYTokenContract\\\");\\n    bytes32 internal constant FEE_MODEL_CONTRACT = keccak256(\\\"FeeModelContract\\\");\\n    bytes32 internal constant ADMIN_CONTRACT = keccak256(\\\"AdminContract\\\");\\n    bytes32 internal constant POSITION_MANAGER_CONTRACT = keccak256(\\\"PositionManagerContract\\\");\\n    bytes32 internal constant STORAGE_WRAPPER_TWO_CONTRACT = keccak256(\\\"StorageWrapperTwoContract\\\");\\n    bytes32 internal constant NAV_CALCULATOR_CONTRACT = keccak256(\\\"NAVCalculatorContract\\\");\\n    bytes32 internal constant OPPORTUNITY_MANAGER_CONTRACT = keccak256(\\\"OpportunityManagerContract\\\");\\n    bytes32 internal constant ORACLE_CONTRACT = keccak256(\\\"OracleContract\\\");\\n\\n    // don\\u0027t move to _storage since it\\u0027s a constant, calling externally is waste of gas\\n    bytes32 internal constant name = keccak256(\\\"RAY\\\");\\n\\n    IStorage public _storage;\\n    bool public deprecated;\\n\\n\\n    /*************** EVENT DECLARATIONS **************/\\n\\n\\n    event LogPurchaseRAYT(\\n        bytes32 indexed tokenId,\\n        bytes32 indexed portfolioKey,\\n        address indexed beneficiary,\\n        uint value\\n    );\\n\\n    event LogPurchaseOpportunityToken(\\n      bytes32 tokenId,\\n      bytes32 indexed portfolioKey\\n    );\\n\\n    event LogWithdrawFromRAYT(\\n      bytes32 indexed tokenId,\\n      uint value,\\n      uint tokenValue // used to calculate gross return off-chain\\n    );\\n\\n    event LogBurnRAYT(\\n        bytes32 indexed tokenId,\\n        address indexed beneficiary,\\n        uint value,\\n        uint tokenValue // used to calculate gross return off-chain\\n    );\\n\\n    event LogDepositToRAYT(\\n        bytes32 indexed tokenId,\\n        uint value,\\n        uint tokenValue // used to calculate gross return off-chain\\n    );\\n\\n\\n    /*************** MODIFIER DECLARATIONS **************/\\n\\n\\n    /// @notice  Checks if the token id exists within the RAYT token contract\\n    modifier existingRAYT(bytes32 tokenId)\\n    {\\n        require(\\n             IRAYToken(_storage.getContractAddress(RAY_TOKEN_CONTRACT)).tokenExists(tokenId),\\n            \\\"#PortfolioMananger existingRAYT Modifier: This is not a valid RAYT\\\"\\n        );\\n\\n        _;\\n    }\\n\\n\\n    /// @notice  Checks the caller is our Oracle contract\\n    modifier onlyOracle()\\n    {\\n\\n      require(\\n        _storage.getContractAddress(ORACLE_CONTRACT) == msg.sender,\\n        \\\"#NCController onlyOracle Modifier: Only Oracle can call this\\\"\\n      );\\n\\n      _;\\n\\n    }\\n\\n\\n    /// @notice  Checks the caller is our Admin contract\\n    modifier onlyAdmin()\\n    {\\n\\n      require(\\n        _storage.getContractAddress(ADMIN_CONTRACT) == msg.sender,\\n        \\\"#NCController onlyAdmin Modifier: Only Admin can call this\\\"\\n      );\\n\\n      _;\\n\\n    }\\n\\n\\n    /// @notice  Checks the caller is our Governance Wallet\\n    ///\\n    /// @dev     To be removed once fallbacks are\\n    modifier onlyGovernance()\\n    {\\n        require(\\n            msg.sender == _storage.getGovernanceWallet(),\\n            \\\"#PortfolioMananger onlyGovernance Modifier: Only Governance can call this\\\"\\n        );\\n\\n        _;\\n    }\\n\\n\\n    /// @notice  Checks the opportunity entered is valid for the portfolio entered\\n    ///\\n    /// @param   key - The portfolio key\\n    /// @param   opportunityKey - The opportunity key\\n    modifier isValidOpportunity(bytes32 key, bytes32 opportunityKey)\\n    {\\n\\n      require(_storage.isValidOpportunity(key, opportunityKey),\\n      \\\"#PortfolioMananger isValidOpportunity modifier: This is not a valid opportunity for this portfolio\\\");\\n\\n        _;\\n    }\\n\\n\\n    /// @notice  Checks the opportunity address entered is the correct one\\n    ///\\n    /// @param   opportunityKey - The opportunity key\\n    /// @param   opportunity - The contract address of the opportunity\\n    ///\\n    /// TODO: Stop passing in, just access storage and grab from there\\n    modifier isCorrectAddress(bytes32 opportunityKey, address opportunity)\\n    {\\n\\n      require(_storage.getVerifier(opportunityKey) == opportunity,\\n      \\\"#PortfolioMananger isCorrectAddress modifier: This is not the correct address for this opportunity\\\");\\n\\n        _;\\n    }\\n\\n\\n    /// @notice  Use this on public functions only. If somebody creates and uses a portfolio\\u0027s storage\\n    ///          pre-maturely it could ruin the portfolio\\n    ///\\n    /// @param   key - The portfolio key\\n    modifier isValidPortfolio(bytes32 key)\\n    {\\n\\n      require(_storage.getVerifier(key) != address(0),\\n      \\\"#PortfolioMananger isValidPortfolio modifier: This is not a valid portfolio\\\");\\n\\n        _;\\n    }\\n\\n\\n    /// @notice  Checks if the contract has been set to deprecated\\n    modifier notDeprecated()\\n    {\\n        require(\\n             deprecated == false,\\n            \\\"#PortfolioMananger notDeprecated Modifier: In deprecated mode - this contract has been deprecated\\\"\\n        );\\n\\n        _;\\n    }\\n\\n\\n    /////////////////////// FUNCTION DECLARATIONS BEGIN ///////////////////////\\n\\n    /******************* PUBLIC FUNCTIONS *******************/\\n\\n\\n    /// @notice  Sets the Storage contract instance\\n    ///\\n    /// @param   __storage - The Storage contracts address\\n    constructor(\\n      address __storage\\n    )\\n        public\\n    {\\n\\n      _storage = IStorage(__storage);\\n\\n    }\\n\\n\\n    /// @notice  Fallback function to receive Ether\\n    ///\\n    /// @dev     Required to receive Ether from the OpportunityManager upon withdraws\\n    function() external payable {\\n\\n    }\\n\\n\\n\\n    /** --------------- USER ENTRYPOINTS ----------------- **/\\n\\n\\n    /// @notice  Allows users to send ETH or accepted ERC20\\u0027s to this contract and\\n    ///          used as capital. In return the Controller mints and gives them a RAYT which\\n    ///          represents their \\u0027stake\\u0027 in the investing pool. A RAYT maps to many shares.\\n    ///          The price of shares is determined by the NAV.\\n    ///\\n    /// @param   key - The portfolio key\\n    /// @param   beneficiary - The owner of the position, supports third-party buys\\n    /// @param   value - The amount to be invested, need so we can accept ERC20\\u0027s\\n    ///\\n    /// @return   The unique token id of their RAY Token position\\n    function mint(\\n      bytes32 key,\\n      address beneficiary,\\n      uint value\\n    )\\n      external\\n      notDeprecated\\n      isValidPortfolio(key)\\n      payable\\n      returns(bytes32)\\n    {\\n\\n        notPaused(key);\\n        verifyValue(key, msg.sender, value); // verify the amount they claim to have sent in\\n        uint pricePerShare = INAVCalculator(_storage.getContractAddress(NAV_CALCULATOR_CONTRACT)).getPortfolioPricePerShare(key);\\n\\n        // create their RAY Token\\n        bytes32 tokenId = IPositionManager(_storage.getContractAddress(POSITION_MANAGER_CONTRACT)).createToken(\\n            key,\\n            _storage.getContractAddress(RAY_TOKEN_CONTRACT),\\n            beneficiary,\\n            value,\\n            pricePerShare\\n        );\\n\\n        // record what portfolio this token belongs too, not in PositionManager since Opp tokens don\\u0027t need that logic\\n        IStorageWrapper(_storage.getContractAddress(STORAGE_WRAPPER_TWO_CONTRACT)).setTokenKey(tokenId, key);\\n\\n        // record what the rate was when they entered for tracking yield allowances\\n        uint cumulativeRate = IFeeModel(_storage.getContractAddress(FEE_MODEL_CONTRACT)).updateCumulativeRate(_storage.getPrincipalAddress(key));\\n         // not in createToken() b/c Opp Tokens don\\u0027t need this (unless we implement fees on them)\\n        IStorageWrapper(_storage.getContractAddress(STORAGE_WRAPPER_TWO_CONTRACT)).setEntryRate(key, tokenId, cumulativeRate);\\n        // increase the available capital in this portfolio upon this investment\\n        IStorageWrapper(_storage.getContractAddress(STORAGE_WRAPPER_TWO_CONTRACT)).setAvailableCapital(key, _storage.getAvailableCapital(key) + value);\\n\\n        emit LogPurchaseRAYT(tokenId, key, beneficiary, value);\\n\\n        return tokenId;\\n\\n    }\\n\\n\\n    /// @notice  Adds capital to an existing RAYT, this doesn\\u0027t restrict who adds,\\n    ///          addresses besides the owner can add value to the position.\\n    ///\\n    /// @dev     The value added must be in the same coin type as the position\\n    ///\\n    /// @param   tokenId - The unique id of the position\\n    /// @param   value - The amount of value they wish to add\\n    ///\\n    /// TODO: Check if need to check is valid portfolio since if token exists it\\u0027ll have a valid key\\n    function deposit(\\n      bytes32 tokenId,\\n      uint value\\n    )\\n      external\\n      payable\\n      notDeprecated\\n      existingRAYT(tokenId)\\n    {\\n\\n        bytes32 key = _storage.getTokenKey(tokenId);\\n        notPaused(key);\\n        verifyValue(key, msg.sender, value);\\n\\n        // don\\u0027t need the return value of this function (the tokens updated allowance), just need to carry the action out\\n        // since they\\u0027re adding capital, they\\u0027re going to a new \\\"capital stage\\\". Their\\n        // allowance will be calculated based on their new amount of capital from this point on.\\n        IFeeModel(_storage.getContractAddress(FEE_MODEL_CONTRACT)).updateAllowance(key, tokenId);\\n\\n        uint tokenValueBeforeDeposit;\\n        uint pricePerShare;\\n\\n        (tokenValueBeforeDeposit, pricePerShare) = INAVCalculator(_storage.getContractAddress(NAV_CALCULATOR_CONTRACT)).getTokenValue(key, tokenId);\\n\\n        IPositionManager(_storage.getContractAddress(POSITION_MANAGER_CONTRACT)).increaseTokenCapital(\\n            key,\\n            tokenId,\\n            pricePerShare,\\n            value\\n        );\\n\\n        IStorageWrapper(_storage.getContractAddress(STORAGE_WRAPPER_TWO_CONTRACT)).setAvailableCapital(key, _storage.getAvailableCapital(key) + value);\\n\\n        emit LogDepositToRAYT(tokenId, value, tokenValueBeforeDeposit);\\n\\n    }\\n\\n\\n    /// @notice   Part 1 of 3 to withdraw value from a RAY Position\\n    ///\\n    /// @dev      Caller must be the owner of the token or our Payer contract (not finished)\\n    ///\\n    /// @param    tokenId - The id of the position\\n    /// @param    valueToWithdraw - The value to withdraw\\n    /// @param    originalCaller - Unimportant unless Payer is the msg.sender, tells\\n    ///                            us who signed the original message.\\n    ///\\n    /// NOTE:     We no longer enforce a RAY burn to unlock all value of the token\\n    function redeem(\\n      bytes32 tokenId,\\n      uint valueToWithdraw,\\n      address originalCaller\\n    )\\n      external\\n      notDeprecated\\n      existingRAYT(tokenId)\\n      returns(uint)\\n    {\\n\\n        address addressToUse = INAVCalculator(_storage.getContractAddress(NAV_CALCULATOR_CONTRACT)).onlyTokenOwner(tokenId, originalCaller, msg.sender);\\n\\n        uint totalValue;\\n        uint pricePerShare;\\n\\n        bytes32 key = _storage.getTokenKey(tokenId);\\n        (totalValue, pricePerShare) = INAVCalculator(_storage.getContractAddress(NAV_CALCULATOR_CONTRACT)).getTokenValue(key, tokenId);\\n\\n      uint valueAfterFee = redeem2(\\n          key,\\n          tokenId,\\n          pricePerShare,\\n          valueToWithdraw,\\n          totalValue,\\n          addressToUse\\n        );\\n\\n      return valueAfterFee;\\n\\n    }\\n\\n\\n     /// @notice  Implemented to receive ERC721 tokens. Main use case is for people to burn\\n     ///          and withdraw their RAYT and withdraw the underlying value. This function checks\\n     ///          if the RAYT exists. Then it runs validation checks that if fail, would make the\\n     ///          calling RAYT invalid to be burnt and withdrawn. If it passes the checks, it clears\\n     ///          it\\u0027s associated tokenValues data, burns the RAYT, and transfers the capital + yield\\n     ///\\n     /// @dev     Must return hash of the function signature for tx to be valid.\\n     ///\\n     /// @param   from - The last owner of the RAY before becoming us\\n     /// @param   tokenId - the unique id of the position\\n     ///\\n     /// TODO: find value of hash: bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))\\n     ////       and make it a constant.\\n    function onERC721Received\\n    (\\n        address /*operator*/,\\n        address from,\\n        uint256 tokenId,\\n        bytes /*data*/\\n    )\\n        public\\n        notDeprecated\\n        returns(bytes4)\\n    {\\n\\n        bytes32 convertedTokenId = bytes32(tokenId);\\n\\n        // optimization: should create local var to store the RAYT Contract Address rather then calling for it twice or more times\\n\\n        // this if statement verifies we just received a RAYT\\n\\n        // verify the tokenId exists within our token contract, if we don\\u0027t check the msg.sender == RAYT\\n        // then someone can attack us with a different erc721 token/same id vector\\n        if (\\n          (IRAYToken(_storage.getContractAddress(RAY_TOKEN_CONTRACT)).tokenExists(convertedTokenId)) \\u0026\\u0026\\n          (msg.sender == _storage.getContractAddress(RAY_TOKEN_CONTRACT))\\n        ) {\\n\\n            bytes32 key = _storage.getTokenKey(convertedTokenId);\\n\\n            uint totalValue;\\n            uint pricePerShare;\\n            uint valueAfterFee;\\n            (totalValue, pricePerShare) = INAVCalculator(_storage.getContractAddress(NAV_CALCULATOR_CONTRACT)).getTokenValue(key, convertedTokenId);\\n\\n            // require(totalValue \\u003e 0, \\\"#PortfolioMananger onERC721Received(): No value in this RAYT\\\"); // see comment 13 lines below\\n\\n            // we don\\u0027t check for this here. it\\u0027ll say this contract is the beneficiary and not the person who just sent\\n            // us the token. we assume that if they sent us the RAYT, they have ownership, and therefore are the true\\n            // beneficiary. If the sender isn\\u0027t the beneficiary, they at least would have permissions from the true beneficiary\\n            // to do this aciton.\\n            // address beneficiary = IPositionManager(_storage.getContractAddress(POSITION_MANAGER_CONTRACT)).verifyWithdrawer(\\n            //     key,\\n            //     convertedTokenId,\\n            //     _storage.getContractAddress(RAY_TOKEN_CONTRACT),\\n            //     from,\\n            //     pricePerShare,\\n            //     totalValue,\\n            //     totalValue\\n            // );\\n\\n            // we allow ray tokens with zero value to be sent in still simply to burn\\n            // if a users withdraw amount falls within our threshold in PositionManager\\u0027s\\n            // updatetokenuponwithdrawal() it\\u0027ll burn all their shares so this menas it\\u0027s\\n            // possible for a token\\u0027s value to be fully given back without sending it in\\n            // to be burnt (which is fine). We implement the burn to receive all value\\n            // functionality as a general \\\"clean-up\\\" strategy not a hard requirement\\n            if (totalValue \\u003e 0) {\\n\\n              // we don\\u0027t need to consider the dust being returned from withdraw-From-Protocols since\\n              // this token is already at 100% value being withdrawn here, it won\\u0027t be withdrawing\\n              // any of the dust used to flatten the number of shares since it doesn\\u0027t have rights to it\\n              IOracle(_storage.getContractAddress(ORACLE_CONTRACT)).withdrawFromProtocols(key, totalValue, totalValue);\\n\\n              valueAfterFee = IFeeModel(_storage.getContractAddress(FEE_MODEL_CONTRACT)).takeFee(key, convertedTokenId, totalValue);\\n\\n              IPositionManager(_storage.getContractAddress(POSITION_MANAGER_CONTRACT)).updateTokenUponWithdrawal(\\n                  key,\\n                  convertedTokenId,\\n                  totalValue,\\n                  pricePerShare,\\n                  _storage.getTokenShares(key, convertedTokenId),\\n                  INAVCalculator(_storage.getContractAddress(NAV_CALCULATOR_CONTRACT)).getPortfolioUnrealizedYield(key)\\n              );\\n\\n            }\\n\\n            // should delete entire values on the token (shares, capital, owner, existence, etc.)\\n            IStorageWrapper(_storage.getContractAddress(STORAGE_WRAPPER_TWO_CONTRACT)).deleteTokenValues(key, convertedTokenId);\\n\\n            IRAYToken(_storage.getContractAddress(RAY_TOKEN_CONTRACT)).burn(tokenId);\\n\\n            emit LogBurnRAYT(convertedTokenId, from, valueAfterFee, totalValue);\\n\\n            // send them the ETH, this could be 0 if the totalvalue was zero to begin with\\n           // could put this transfer in the bottom of if block for the totalvalue check since it would still be safe\\n           // against re-entrancy since we\\u0027re using transfer()\\n            _transferFunds(key, from, valueAfterFee);\\n\\n        }\\n\\n        return bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"));\\n    }\\n\\n\\n    /** ----------------- ONLY ORACLE MUTATORS ----------------- **/\\n\\n\\n    /// @notice  Entrypoint of the Oracle to tell us where/how to lend\\n    ///\\n    /// @dev  Could pass in sh3 key and use _storage to find the appropriate contract address\\n    ///       but that is an extra external call when we can just do it free beforehand\\n    ///\\n    /// @param  key - The portfolio key we\\u0027re lending for\\n    /// @param  opportunityKey - The opportunity key we\\u0027re lending too\\n    /// @param  opportunity - The contract address of our Opportunity contract\\n    /// @param  value - The amount to lend in-kind\\n    /// @param  addAC - Flag to let us know if we wish to subtract value lent\\n    ///                 from the available capital.\\n    function lend(\\n      bytes32 key,\\n      bytes32 opportunityKey,\\n      address opportunity,\\n      uint value,\\n      bool addAC\\n    )\\n      external\\n      onlyOracle\\n      isValidPortfolio(key)\\n      // notDeprecated --\\u003e called in _lend\\n    {\\n\\n        if (addAC) {\\n\\n          // we don\\u0027t want to call this on rebalances else we\\u0027d have to add capital as we withdrew it and\\n          // then when withdrawing to dish to a client we\\u0027d have to subtract it right back off == waste of gas\\n          IStorageWrapper(_storage.getContractAddress(STORAGE_WRAPPER_TWO_CONTRACT)).setAvailableCapital(key, _storage.getAvailableCapital(key) - value); // it\\u0027s not real re-entrancy risk if I do this after since the external contracts we call our either ours or trusted\\n\\n        }\\n\\n        _lend(key, opportunityKey, opportunity, value);\\n    }\\n\\n\\n    /// @notice  Entrypoint of the Oracle to tell us where/how to withdraw\\n    ///\\n    /// @dev  Could pass in sh3 key and use _storage to find the appropriate contract address\\n    ///       but that is an extra external call when we can just do it free beforehand\\n    ///\\n    /// @param  key - The portfolio key we\\u0027re withdrawing for\\n    /// @param  opportunityKey - The opportunity key we\\u0027re withdrawing from\\n    /// @param  opportunity - The contract address of our Opportunity contract\\n    /// @param  value - The amount to withdraw in-kind\\n    /// @param  addAC - Flag to let us know if we wish to add value withdrawn\\n    ///                 into the available capital.\\n    function withdraw(\\n      bytes32 key,\\n      bytes32 opportunityKey,\\n      address opportunity,\\n      uint value,\\n      bool addAC\\n    )\\n      external\\n      onlyOracle\\n      isValidPortfolio(key)\\n      // notDeprecated --\\u003e called in _withdraw\\n    { // called by oracle to rebalance, withdraw during upgrade, or withdraw-From-Protocols\\n\\n        // if we\\u0027re paused, and the oracle is the one who called withdraw(), we want to re-add the withdrawn funds to availbale capital\\n        // we\\u0027re probably upgrading the opportunity. We don\\u0027t want to re-add to available capital if fee model is the sender b/c that\\n        // means a user is trying to withdraw from the RAY token (meaning the value flows out instead of staying around and being \\u0027available capital\\u0027)\\n        if (addAC) {\\n\\n          IStorageWrapper(_storage.getContractAddress(STORAGE_WRAPPER_TWO_CONTRACT)).setAvailableCapital(key, _storage.getAvailableCapital(key) + value); // if we\\u0027re paused we\\u0027re not\\n\\n        }\\n\\n        _withdraw(key, opportunityKey, opportunity, value);\\n\\n    }\\n\\n\\n    /** ----------------- ONLY ADMIN MUTATORS ----------------- **/\\n\\n\\n    /// @notice  Public wrapper so we can call via our Admin contract\\n    ///\\n    /// @dev   If this is deprecated, should be no value, therefore this function will revert anyway, so we don\\u0027t ned the deprecation flag\\n    /// since it won\\u0027t help us debug the error in prod. since error msgs don\\u0027t show up\\n    function transferFunds(\\n      bytes32 key,\\n      address beneficiary,\\n      uint value\\n    )\\n      external\\n      onlyAdmin\\n    {\\n\\n      _transferFunds(key, beneficiary, value);\\n\\n    }\\n\\n\\n    /// @notice  Approve function for ERC20\\u0027s\\n    ///\\n    /// @dev     Need to approve the OpportunityManager contract\\n    ///\\n    /// @param   token - Contract address of the token\\n    /// @param   beneficiary - The OpportunityManager contract for now\\n    function approve(\\n      address token,\\n      address beneficiary,\\n      uint amount\\n    )\\n      external\\n      onlyAdmin\\n    {\\n\\n      require(\\n        IERC20(token).approve(beneficiary, amount),\\n        \\\"#PortfolioMananger approve: Approval of ERC20 Token failed\\\"\\n      );\\n\\n    }\\n\\n\\n    /// @notice  Approval for ERC721\\u0027s\\n    ///\\n    /// @dev     Used by Admin so it can deprecate this contract, it transfers\\n    ///          all the opporunity tokens to a new contract.\\n    ///\\n    /// @param   token - The contract address of the token\\n    function setApprovalForAll(\\n      address token,\\n      address to,\\n      bool approved\\n    )\\n      external\\n      onlyAdmin\\n    {\\n\\n      IERC721(token).setApprovalForAll(to, approved);\\n\\n    }\\n\\n\\n    function setDeprecated(bool value) external onlyAdmin {\\n\\n        deprecated = value;\\n\\n    }\\n\\n\\n    /********************* INTERNAL FUNCTIONS **********************/\\n\\n\\n    /// @notice  Direct OpportunityManager to lend capital\\n    ///\\n    /// @dev  Could pass in sh3 key and use _storage to find the appropriate contract address\\n    ///       but that is an extra external call when we can just do it free beforehand\\n    ///\\n    /// @param  key - The portfolio key we\\u0027re lending for\\n    /// @param  opportunityKey - The opportunity key we\\u0027re lending too\\n    /// @param  opportunity - The contract address of our Opportunity contract\\n    /// @param  value - The amount to lend in-kind\\n    function _lend(\\n      bytes32 key,\\n      bytes32 opportunityKey,\\n      address opportunity,\\n      uint value\\n    )\\n      internal\\n      notDeprecated\\n      isValidOpportunity(key, opportunityKey)\\n      isCorrectAddress(opportunityKey, opportunity)\\n    {\\n\\n      // should verify address passed in is that opportunities\\n      notPaused(key);\\n      // these checks are more about trustlessness then verifying where were sending\\n\\n      bytes32 tokenId = _storage.getOpportunityToken(key, opportunityKey);\\n      address principalAddress = _storage.getPrincipalAddress(key);\\n      bool isERC20;\\n      uint payableValue;\\n      (isERC20, payableValue) =  INAVCalculator(_storage.getContractAddress(NAV_CALCULATOR_CONTRACT)).calculatePayableAmount(principalAddress, value);\\n\\n      if (tokenId == bytes32(0)) { // if this contract/portfolio don\\u0027t have a position yet, buy one and lend\\n\\n          tokenId = IOpportunityManager(_storage.getContractAddress(OPPORTUNITY_MANAGER_CONTRACT)).buyPosition.value(payableValue)(\\n            opportunityKey,\\n            address(this),\\n            opportunity,\\n            principalAddress,\\n            value,\\n            isERC20\\n          );\\n\\n          IStorageWrapper(_storage.getContractAddress(STORAGE_WRAPPER_TWO_CONTRACT)).setOpportunityToken(key, opportunityKey, tokenId); // we\\u0027ll only have one opportunity token per opporutnity per portfolio\\n\\n          emit LogPurchaseOpportunityToken(tokenId, key);\\n\\n      } else { // else add capital to our existing portfolio\\u0027s position\\n\\n          IOpportunityManager(_storage.getContractAddress(OPPORTUNITY_MANAGER_CONTRACT)).increasePosition.value(payableValue)(\\n            opportunityKey,\\n            tokenId,\\n            opportunity,\\n            principalAddress,\\n            value,\\n            isERC20\\n          );\\n\\n      }\\n\\n    }\\n\\n\\n    /// @notice  Direct OpportunityManager to withdraw funds\\n    ///\\n    /// @dev  Could pass in sh3 key and use _storage to find the appropriate contract address\\n    ///       but that is an extra external call when we can just do it free beforehand\\n    ///\\n    /// @param  key - The portfolio key we\\u0027re withdrawing for\\n    /// @param  opportunityKey - The opportunity key we\\u0027re withdrawing from\\n    /// @param  opportunity - The contract address of our Opportunity contract\\n    /// @param  value - The amount to withdraw in-kind\\n    function _withdraw(\\n      bytes32 key,\\n      bytes32 opportunityKey,\\n      address opportunity,\\n      uint value\\n    )\\n      internal\\n      notDeprecated // need to block this even though nobody should have value left in the cotnract if it\\u0027s deprecated, since the logic could be wrong\\n      isValidOpportunity(key, opportunityKey)\\n      isCorrectAddress(opportunityKey, opportunity)\\n    {\\n\\n        uint yield = INAVCalculator(_storage.getContractAddress(NAV_CALCULATOR_CONTRACT)).getOpportunityYield(key, opportunityKey, value);\\n\\n        bytes32 tokenId = _storage.getOpportunityToken(key, opportunityKey);\\n        address principalAddress = _storage.getPrincipalAddress(key);\\n\\n        IOpportunityManager(_storage.getContractAddress(OPPORTUNITY_MANAGER_CONTRACT)).withdrawPosition(\\n          opportunityKey,\\n          tokenId,\\n          opportunity,\\n          principalAddress,\\n          value,\\n          _storage.getIsERC20(principalAddress)\\n         );\\n\\n        if (yield \\u003e 0) {\\n\\n          INAVCalculator(_storage.getContractAddress(NAV_CALCULATOR_CONTRACT)).updateYield(key, yield);\\n\\n        }\\n\\n    }\\n\\n\\n    /// @notice  Part 2 of 3 to withdraw a tokens value\\n    ///\\n    /// @param   key - The portfolio key of the token\\n    /// @param   tokenId - The unique token we\\u0027re withdrawing from\\n    /// @param   pricePerShare - The current price per share we\\u0027re using\\n    /// @param   valueToWithdraw - THe value being withdrawn in-kind\\n    /// @param   totalValue - The total value of the token\\n    /// @param   addressToUse - Added to support us paying for user transactions\\n    function redeem2(\\n      bytes32 key,\\n      bytes32 tokenId,\\n      uint pricePerShare,\\n      uint valueToWithdraw,\\n      uint totalValue,\\n      address addressToUse\\n    )\\n      internal\\n      returns(uint)\\n    {\\n\\n      address beneficiary = IPositionManager(_storage.getContractAddress(POSITION_MANAGER_CONTRACT)).verifyWithdrawer(\\n          key,\\n          tokenId,\\n          _storage.getContractAddress(RAY_TOKEN_CONTRACT),\\n          addressToUse, // person who called/signed to call this function\\n          pricePerShare,\\n          valueToWithdraw,\\n          totalValue\\n      );\\n\\n      valueToWithdraw += IOracle(_storage.getContractAddress(ORACLE_CONTRACT)).withdrawFromProtocols(key, valueToWithdraw, totalValue);\\n\\n      // call before update Token Upon Withdrawal since that changes the token value\\n      // which we use in take fee to find how much yield they made\\n      uint valueAfterFee = IFeeModel(_storage.getContractAddress(FEE_MODEL_CONTRACT)).takeFee(key, tokenId, valueToWithdraw);\\n\\n      redeem3(key, tokenId, valueToWithdraw, pricePerShare);\\n\\n      emit LogWithdrawFromRAYT(tokenId, valueAfterFee, totalValue);\\n\\n      _transferFunds(key, beneficiary, valueAfterFee);\\n\\n      return valueAfterFee;\\n\\n    }\\n\\n\\n    /// @notice  Part 3 of 3 for withdrawing from a position, updates the tokens storage\\n    ///          like shares, capital, etc.\\n    ///\\n    /// @param  key - The portfolio key we\\u0027re withdrawing from\\n    /// @param  tokenId - The token we\\u0027re withdrawing from\\n    /// @param  valueToWithdraw - The value being withdrawn\\n    /// @param  pricePerShare - The price per share we\\u0027re using to calculate value\\n    function redeem3(\\n      bytes32 key,\\n      bytes32 tokenId,\\n      uint valueToWithdraw,\\n      uint pricePerShare\\n    )\\n      internal\\n    {\\n\\n      IPositionManager(_storage.getContractAddress(POSITION_MANAGER_CONTRACT)).updateTokenUponWithdrawal(\\n          key,\\n          tokenId,\\n          valueToWithdraw,\\n          pricePerShare,\\n          _storage.getTokenShares(key, tokenId),\\n          INAVCalculator(_storage.getContractAddress(NAV_CALCULATOR_CONTRACT)).getPortfolioUnrealizedYield(key)\\n      );\\n\\n    }\\n\\n\\n    /// @notice  Used to transfer ETH or ERC20\\u0027s\\n    ///\\n    /// @param   key - The portfolio key, used to get the coin associated\\n    /// @param   beneficiary - The address to send funds to - is untrusted\\n    /// @param   value - The value to send in-kind\\n    function _transferFunds(\\n      bytes32 key,\\n      address beneficiary,\\n      uint value\\n    )\\n      internal\\n    {\\n\\n      address principalAddress = _storage.getPrincipalAddress(key);\\n\\n      if (_storage.getIsERC20(principalAddress)) {\\n\\n        require(\\n          IERC20(principalAddress).transfer(beneficiary, value),\\n          \\\"#PortfolioMananger _transferFunds(): Transfer of ERC20 Token failed\\\"\\n        );\\n\\n      } else {\\n\\n        beneficiary.transfer(value);\\n\\n      }\\n\\n    }\\n\\n\\n    /// @notice  Verify the amount the sender claims to give to the system is true\\n    ///\\n    /// @dev     Used for ETH and ERC20\\u0027s\\n    ///\\n    /// @param   key - The portfolio key, used to get the coin associated\\n    /// @param   funder - The payer of the transaction\\n    /// @param   inputValue - The value the user said they\\u0027re contributing by parameter\\n    function verifyValue(\\n      bytes32 key,\\n      address funder,\\n      uint inputValue\\n    )\\n      internal\\n    {\\n\\n      address principalAddress = _storage.getPrincipalAddress(key);\\n\\n      if (_storage.getIsERC20(principalAddress)) {\\n\\n        require(\\n          IERC20(principalAddress).transferFrom(funder, address(this), inputValue),\\n          \\\"#PortfolioMananger verifyValue: TransferFrom of ERC20 Token failed\\\"\\n        );\\n\\n      } else {\\n\\n        require(\\n          inputValue == msg.value,\\n          \\\"#PortfolioMananger verifyValue(): ETH value sent does not match input value\\\");\\n\\n      }\\n\\n    }\\n\\n\\n    /// @notice  Checks if the portfolio or this Opportunity has been paused.\\n    ///\\n    /// @dev     Withdrawals are allowed on pauses, lending or accepting value isn\\u0027t\\n    function notPaused(bytes32 key) internal view {\\n\\n      require(\\n             _storage.getPausedMode(name) == false \\u0026\\u0026\\n             _storage.getPausedMode(key) == false,\\n             \\\"#PortfolioMananger notPaused: In withdraw mode - this function has been paused\\\"\\n         );\\n\\n    }\\n\\n\\n    /*************** FALLBACK FUNCTIONS (to be removed before public release) **************/\\n\\n\\n    function fallbackClaim(\\n      uint value,\\n      address principalToken,\\n      bool isERC20\\n    )\\n      external\\n      onlyGovernance\\n    {\\n\\n      if (isERC20) {\\n\\n        require(\\n          IERC20(principalToken).transfer(_storage.getGovernanceWallet(), value),\\n         \\\"PortfolioManager fallbackClaim(): ERC20 Transfer failed\\\"\\n       );\\n\\n      } else {\\n\\n        _storage.getGovernanceWallet().transfer(value);\\n\\n      }\\n\\n    }\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.4.25;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"#SafeMath sub(): This would result in an underflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two unsigned integers, reverts on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"#SafeMath add(): This would result in an overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"},\"Upgradeable.sol\":{\"content\":\"/**\\n\\n    The software and documentation available in this repository (the \\\"Software\\\") is\\n    protected by copyright law and accessible pursuant to the license set forth below.\\n\\n    Copyright © 2019 Staked Securely, Inc. All rights reserved.\\n\\n    Permission is hereby granted, free of charge, to any person or organization\\n    obtaining the Software (the “Licensee”) to privately study, review, and analyze\\n    the Software. Licensee shall not use the Software for any other purpose. Licensee\\n    shall not modify, transfer, assign, share, or sub-license the Software or any\\n    derivative works of the Software.\\n\\n    THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\\n    PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT\\n    HOLDERS BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT,\\n    OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE.\\n\\n*/\\n\\npragma solidity 0.4.25;\\n\\n\\n/// @notice  Inherited by any contract that is upgradeable.\\n///\\n/// @dev     We currently have this method as a safety measure in case we are\\n///          still referencing an old contract somewhere in the system. We call\\n///          call this which turns on a flag that forces all calls to revert.\\n///\\n///          I now think it may be overkill and a waste to have this on every contract\\n///          public function, it should only be on the public-facing open functions\\n///          that the users are interacting with - in case our web-app is pointing\\n///          to the wrong PortfolioManager still. Internally, it shouldn\\u0027t it be needed\\n///          assuming we didn\\u0027t forget to set the references...my only reason to remove\\n///          it from most of the contracts is it costs a ton of extra gas - leaving it\\n///          for now since ToB said it\\u0027s a good safety measure.\\n\\ninterface Upgradeable {\\n\\n\\n  /// @notice  Sets a flag in the contract that reverts all calls to it\\n  function setDeprecated(bool value) external;\\n\\n}\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"deprecated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"name\":\"valueToWithdraw\",\"type\":\"uint256\"},{\"name\":\"originalCaller\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"bytes32\"},{\"name\":\"opportunityKey\",\"type\":\"bytes32\"},{\"name\":\"opportunity\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"addAC\",\"type\":\"bool\"}],\"name\":\"lend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"bytes32\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"bytes32\"},{\"name\":\"opportunityKey\",\"type\":\"bytes32\"},{\"name\":\"opportunity\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"addAC\",\"type\":\"bool\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"bytes32\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_storage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"principalToken\",\"type\":\"address\"},{\"name\":\"isERC20\",\"type\":\"bool\"}],\"name\":\"fallbackClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setDeprecated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"__storage\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"portfolioKey\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogPurchaseRAYT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"portfolioKey\",\"type\":\"bytes32\"}],\"name\":\"LogPurchaseOpportunityToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenValue\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawFromRAYT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenValue\",\"type\":\"uint256\"}],\"name\":\"LogBurnRAYT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenValue\",\"type\":\"uint256\"}],\"name\":\"LogDepositToRAYT\",\"type\":\"event\"}]","ContractName":"PortfolioManager","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000446711e5ed3013743e40342a0462fbdc437cd43f","Library":"","LicenseType":"None","SwarmSource":"bzzr://21cb89740a2bb021bc9b3aa01ed87fec4d93bbfec2147ccc0419094fbe1730b6"}]}