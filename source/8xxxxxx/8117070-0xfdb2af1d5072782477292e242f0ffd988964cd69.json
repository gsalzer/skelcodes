{"status":"1","message":"OK","result":[{"SourceCode":"{\"NOSToken - 2.sol\":{\"content\":\"/**\\r\\n *Submitted for verification at Etherscan.io on 2019-03-22\\r\\n*/\\r\\n\\r\\npragma solidity 0.4.24;\\r\\n\\r\\ncontract owned {\\r\\n    address public owner;\\r\\n\\r\\n    modifier onlyOwner {\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) onlyOwner public {\\r\\n        owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\\r\\n\\r\\ncontract NOSToken is owned {\\r\\n    // Public variables of the token\\r\\n    string public name;\\r\\n    string public symbol;\\r\\n    uint8 public decimals = 8;\\r\\n    // 18 decimals is the strongly suggested default, avoid changing it\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    // This creates an array with all balances\\r\\n    mapping (address =\\u003e uint256) public balanceOf;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public allowance;\\r\\n\\r\\n    // This creates an array with freeze balances\\r\\n    mapping (address =\\u003e uint256) public freezeOf;\\r\\n\\r\\n    // Suspend trading\\r\\n    bool suspendTrading;\\r\\n\\r\\n    // This generates a public event on the blockchain that will notify clients\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    // This notifies clients about the amount burnt\\r\\n    event Burn(address indexed from, uint256 value);\\r\\n\\r\\n    // This notifies clients about the amount unfreeze\\r\\n    event UnFreezeFunds(address target, uint256 value);\\r\\n\\r\\n    // This notifies clients about the amount freeze\\r\\n    event FreezeFunds(address target, uint256 value);\\r\\n\\r\\n    // This generates a public event on the blockchain that will notify clients\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n\\r\\n    /**\\r\\n     * Constrctor function\\r\\n     *\\r\\n     * Initializes contract with initial supply tokens to the creator of the contract\\r\\n     */\\r\\n    constructor(\\r\\n    ) public {\\r\\n        totalSupply = 73000000 * 10 ** uint256(decimals);  // Update total supply with the decimal amount\\r\\n        balanceOf[msg.sender] = totalSupply;                    // Give the creator all initial tokens\\r\\n        name = \\\"Number One Scholar\\\";                                       // Set the name for display purposes\\r\\n        symbol = \\\"NOS\\\";                                   // Set the symbol for display purposes\\r\\n        owner = 0x023C1Fd15F57640E682E882B5C4187Ff44085468;\\r\\n    }\\r\\n    /**\\r\\n     * set suspendTrading\\r\\n     */\\r\\n    function setSuspendTrading(bool _state) public onlyOwner {\\r\\n        suspendTrading = _state;\\r\\n    }\\r\\n    /**\\r\\n     * Internal transfer, only can be called by this contract\\r\\n     */\\r\\n    function _transfer(address _from, address _to, uint _value)  internal {\\r\\n        require(suspendTrading == false);\\r\\n        // Prevent transfer to 0x0 address. Use burn() instead\\r\\n        require(_to != address(0x0));\\r\\n        // Check if the sender has enough\\r\\n        require(balanceOf[_from] \\u003e= freezeOf[_from]);\\r\\n        require(balanceOf[_from] - freezeOf[_from] \\u003e= _value);\\r\\n        // Check for overflows\\r\\n        require(balanceOf[_to] + _value \\u003e balanceOf[_to]);\\r\\n        // Save this for an assertion in the future\\r\\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\\r\\n        // Subtract from the sender\\r\\n        balanceOf[_from] -= _value;\\r\\n        // Add the same to the recipient\\r\\n        balanceOf[_to] += _value;\\r\\n        emit Transfer(_from, _to, _value);\\r\\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\\r\\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Transfer tokens\\r\\n     *\\r\\n     * Send `_value` tokens to `_to` from your account\\r\\n     *\\r\\n     * @param _to The address of the recipient\\r\\n     * @param _value the amount to send\\r\\n     */\\r\\n    function transfer(address _to, uint256 _value) public returns (bool success) {\\r\\n        _transfer(msg.sender, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Transfer tokens from other address\\r\\n     *\\r\\n     * Send `_value` tokens to `_to` in behalf of `_from`\\r\\n     *\\r\\n     * @param _from The address of the sender\\r\\n     * @param _to The address of the recipient\\r\\n     * @param _value the amount to send\\r\\n     */\\r\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\\r\\n        require(_value \\u003c= allowance[_from][msg.sender]);     // Check allowance\\r\\n        allowance[_from][msg.sender] -= _value;\\r\\n        _transfer(_from, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Set allowance for other address\\r\\n     *\\r\\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\\r\\n     *\\r\\n     * @param _spender The address authorized to spend\\r\\n     * @param _value the max amount they can spend\\r\\n     */\\r\\n    function approve(address _spender, uint256 _value) public\\r\\n    returns (bool success) {\\r\\n        allowance[msg.sender][_spender] = _value;\\r\\n        emit Approval(msg.sender, _spender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Set allowance for other address and notify\\r\\n     *\\r\\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\\r\\n     *\\r\\n     * @param _spender The address authorized to spend\\r\\n     * @param _value the max amount they can spend\\r\\n     * @param _extraData some extra information to send to the approved contract\\r\\n     */\\r\\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\\r\\n    public\\r\\n    returns (bool success) {\\r\\n        tokenRecipient spender = tokenRecipient(_spender);\\r\\n        if (approve(_spender, _value)) {\\r\\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * multiTransfer tokens\\r\\n     *\\r\\n     * Send `_value` tokens to `_to` from your account\\r\\n     *\\r\\n     * @param _to The address of the recipient\\r\\n     * @param _value the amount to send\\r\\n     */\\r\\n    function multiTransfer(address[] memory _to, uint256[] memory _value) public returns (bool success) {\\r\\n        uint256 i = 0;\\r\\n        while (i \\u003c _to.length) {\\r\\n            transfer(_to[i], _value[i]);\\r\\n            i += 1;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Destroy tokens\\r\\n     *\\r\\n     * Remove `_value` tokens from the system irreversibly\\r\\n     *\\r\\n     * @param _value the amount of money to burn\\r\\n     */\\r\\n    function burn(uint256 _value) public onlyOwner returns (bool success) {\\r\\n        require(balanceOf[msg.sender] \\u003e= _value);   // Check if the sender has enough\\r\\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\\r\\n        totalSupply -= _value;                      // Updates totalSupply\\r\\n        emit Burn(msg.sender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Destroy tokens from other account\\r\\n     *\\r\\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\\r\\n     *\\r\\n     * @param _from the address of the sender\\r\\n     * @param _value the amount of money to burn\\r\\n     */\\r\\n    function burnFrom(address _from, uint256 _value) public onlyOwner returns (bool success) {\\r\\n        require(balanceOf[_from] \\u003e= freezeOf[_from]);\\r\\n        require(balanceOf[_from] - freezeOf[_from] \\u003e= _value);                // Check if the targeted balance is enough\\r\\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\\r\\n        totalSupply -= _value;                              // Update totalSupply\\r\\n        emit Burn(_from, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Destroy tokens from other accounts\\r\\n     *\\r\\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\\r\\n     *\\r\\n     * @param _from the address of the sender\\r\\n     * @param _value the amount of money to burn\\r\\n     */\\r\\n    function multiBurnFrom(address[] memory _from, uint256[] memory _value) public onlyOwner returns (bool success) {\\r\\n        uint256 i = 0;\\r\\n        while (i \\u003c _from.length) {\\r\\n            burnFrom(_from[i], _value[i]);\\r\\n            i += 1;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice Create `mintedAmount` tokens and send it to `target`\\r\\n    /// @param target Address to receive the tokens\\r\\n    /// @param mintedAmount the amount of tokens it will receive\\r\\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\\r\\n        balanceOf[target] += mintedAmount;\\r\\n        totalSupply += mintedAmount;\\r\\n        emit Transfer(address(0), address(this), mintedAmount);\\r\\n        emit Transfer(address(this), target, mintedAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * mint tokens\\r\\n     *\\r\\n     * mint `_value` tokens from the system irreversibly on behalf of `_from`.\\r\\n     *\\r\\n     * @param _from the address of the sender\\r\\n     * @param _value the amount of money to mint\\r\\n     */\\r\\n    function multiMintToken(address[] memory _from, uint256[] memory _value) public onlyOwner returns (bool success) {\\r\\n        uint256 i = 0;\\r\\n        while (i \\u003c _from.length) {\\r\\n            mintToken(_from[i], _value[i]);\\r\\n            i += 1;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice `freeze? Prevent | Allow` `target` from sending \\u0026 receiving tokens\\r\\n    /// @param target Address to be frozen\\r\\n    /// @param _value value of target Address to be frozen\\r\\n    function freezeToken(address target, uint256 _value) onlyOwner public {\\r\\n        require(balanceOf[target] -freezeOf[target]\\u003e= _value);\\r\\n        freezeOf[target] += _value;\\r\\n        emit FreezeFunds(target, _value);\\r\\n    }\\r\\n\\r\\n    /// @notice `freeze? Prevent | Allow` `target` from sending \\u0026 receiving tokens\\r\\n    /// @param target Address to be frozen\\r\\n    /// @param _value value of target Address to be frozen\\r\\n    function unfreezeToken(address target, uint256 _value) onlyOwner public {\\r\\n        require(freezeOf[target] \\u003e= _value);\\r\\n        freezeOf[target] -= _value;\\r\\n        emit UnFreezeFunds(target, _value);\\r\\n    }\\r\\n}\\r\\n\\r\\n\"},\"NOSToken.sol\":{\"content\":\"/**\\r\\n *Submitted for verification at Etherscan.io on 2019-03-22\\r\\n*/\\r\\n\\r\\npragma solidity 0.4.24;\\r\\n\\r\\ncontract owned {\\r\\n    address public owner;\\r\\n\\r\\n    modifier onlyOwner {\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) onlyOwner public {\\r\\n        owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\\r\\n\\r\\ncontract NOSToken is owned {\\r\\n    // Public variables of the token\\r\\n    string public name;\\r\\n    string public symbol;\\r\\n    uint8 public decimals = 8;\\r\\n    // 18 decimals is the strongly suggested default, avoid changing it\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    // This creates an array with all balances\\r\\n    mapping (address =\\u003e uint256) public balanceOf;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public allowance;\\r\\n\\r\\n    // This creates an array with freeze balances\\r\\n    mapping (address =\\u003e uint256) public freezeOf;\\r\\n\\r\\n    // Suspend trading\\r\\n    bool suspendTrading;\\r\\n\\r\\n    // This generates a public event on the blockchain that will notify clients\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    // This notifies clients about the amount burnt\\r\\n    event Burn(address indexed from, uint256 value);\\r\\n\\r\\n    // This notifies clients about the amount unfreeze\\r\\n    event UnFreezeFunds(address target, uint256 value);\\r\\n\\r\\n    // This notifies clients about the amount freeze\\r\\n    event FreezeFunds(address target, uint256 value);\\r\\n\\r\\n    // This generates a public event on the blockchain that will notify clients\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n\\r\\n    /**\\r\\n     * Constrctor function\\r\\n     *\\r\\n     * Initializes contract with initial supply tokens to the creator of the contract\\r\\n     */\\r\\n    constructor(\\r\\n    ) public {\\r\\n        totalSupply = 73000000 * 10 ** uint256(decimals);  // Update total supply with the decimal amount\\r\\n        balanceOf[msg.sender] = totalSupply;                    // Give the creator all initial tokens\\r\\n        name = \\\"Number One Scholar\\\";                                       // Set the name for display purposes\\r\\n        symbol = \\\"NOS\\\";                                   // Set the symbol for display purposes\\r\\n        owner = 0x023C1Fd15F57640E682E882B5C4187Ff44085468;\\r\\n    }\\r\\n    /**\\r\\n     * set suspendTrading\\r\\n     */\\r\\n    function setSuspendTrading(bool _state) public onlyOwner {\\r\\n        suspendTrading = _state;\\r\\n    }\\r\\n    /**\\r\\n     * Internal transfer, only can be called by this contract\\r\\n     */\\r\\n    function _transfer(address _from, address _to, uint _value)  internal {\\r\\n        require(suspendTrading == false);\\r\\n        // Prevent transfer to 0x0 address. Use burn() instead\\r\\n        require(_to != address(0x0));\\r\\n        // Check if the sender has enough\\r\\n        require(balanceOf[_from] \\u003e= freezeOf[_from]);\\r\\n        require(balanceOf[_from] - freezeOf[_from] \\u003e= _value);\\r\\n        // Check for overflows\\r\\n        require(balanceOf[_to] + _value \\u003e balanceOf[_to]);\\r\\n        // Save this for an assertion in the future\\r\\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\\r\\n        // Subtract from the sender\\r\\n        balanceOf[_from] -= _value;\\r\\n        // Add the same to the recipient\\r\\n        balanceOf[_to] += _value;\\r\\n        emit Transfer(_from, _to, _value);\\r\\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\\r\\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Transfer tokens\\r\\n     *\\r\\n     * Send `_value` tokens to `_to` from your account\\r\\n     *\\r\\n     * @param _to The address of the recipient\\r\\n     * @param _value the amount to send\\r\\n     */\\r\\n    function transfer(address _to, uint256 _value) public returns (bool success) {\\r\\n        _transfer(msg.sender, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Transfer tokens from other address\\r\\n     *\\r\\n     * Send `_value` tokens to `_to` in behalf of `_from`\\r\\n     *\\r\\n     * @param _from The address of the sender\\r\\n     * @param _to The address of the recipient\\r\\n     * @param _value the amount to send\\r\\n     */\\r\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\\r\\n        require(_value \\u003c= allowance[_from][msg.sender]);     // Check allowance\\r\\n        allowance[_from][msg.sender] -= _value;\\r\\n        _transfer(_from, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Set allowance for other address\\r\\n     *\\r\\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\\r\\n     *\\r\\n     * @param _spender The address authorized to spend\\r\\n     * @param _value the max amount they can spend\\r\\n     */\\r\\n    function approve(address _spender, uint256 _value) public\\r\\n    returns (bool success) {\\r\\n        allowance[msg.sender][_spender] = _value;\\r\\n        emit Approval(msg.sender, _spender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Set allowance for other address and notify\\r\\n     *\\r\\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\\r\\n     *\\r\\n     * @param _spender The address authorized to spend\\r\\n     * @param _value the max amount they can spend\\r\\n     * @param _extraData some extra information to send to the approved contract\\r\\n     */\\r\\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\\r\\n    public\\r\\n    returns (bool success) {\\r\\n        tokenRecipient spender = tokenRecipient(_spender);\\r\\n        if (approve(_spender, _value)) {\\r\\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * multiTransfer tokens\\r\\n     *\\r\\n     * Send `_value` tokens to `_to` from your account\\r\\n     *\\r\\n     * @param _to The address of the recipient\\r\\n     * @param _value the amount to send\\r\\n     */\\r\\n    function multiTransfer(address[] memory _to, uint256[] memory _value) public returns (bool success) {\\r\\n        uint256 i = 0;\\r\\n        while (i \\u003c _to.length) {\\r\\n            transfer(_to[i], _value[i]);\\r\\n            i += 1;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Destroy tokens\\r\\n     *\\r\\n     * Remove `_value` tokens from the system irreversibly\\r\\n     *\\r\\n     * @param _value the amount of money to burn\\r\\n     */\\r\\n    function burn(uint256 _value) public onlyOwner returns (bool success) {\\r\\n        require(balanceOf[msg.sender] \\u003e= _value);   // Check if the sender has enough\\r\\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\\r\\n        totalSupply -= _value;                      // Updates totalSupply\\r\\n        emit Burn(msg.sender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Destroy tokens from other account\\r\\n     *\\r\\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\\r\\n     *\\r\\n     * @param _from the address of the sender\\r\\n     * @param _value the amount of money to burn\\r\\n     */\\r\\n    function burnFrom(address _from, uint256 _value) public onlyOwner returns (bool success) {\\r\\n        require(balanceOf[_from] \\u003e= freezeOf[_from]);\\r\\n        require(balanceOf[_from] - freezeOf[_from] \\u003e= _value);                // Check if the targeted balance is enough\\r\\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\\r\\n        totalSupply -= _value;                              // Update totalSupply\\r\\n        emit Burn(_from, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Destroy tokens from other accounts\\r\\n     *\\r\\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\\r\\n     *\\r\\n     * @param _from the address of the sender\\r\\n     * @param _value the amount of money to burn\\r\\n     */\\r\\n    function multiBurnFrom(address[] memory _from, uint256[] memory _value) public onlyOwner returns (bool success) {\\r\\n        uint256 i = 0;\\r\\n        while (i \\u003c _from.length) {\\r\\n            burnFrom(_from[i], _value[i]);\\r\\n            i += 1;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice Create `mintedAmount` tokens and send it to `target`\\r\\n    /// @param target Address to receive the tokens\\r\\n    /// @param mintedAmount the amount of tokens it will receive\\r\\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\\r\\n        balanceOf[target] += mintedAmount;\\r\\n        totalSupply += mintedAmount;\\r\\n        emit Transfer(address(0), address(this), mintedAmount);\\r\\n        emit Transfer(address(this), target, mintedAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * mint tokens\\r\\n     *\\r\\n     * mint `_value` tokens from the system irreversibly on behalf of `_from`.\\r\\n     *\\r\\n     * @param _from the address of the sender\\r\\n     * @param _value the amount of money to mint\\r\\n     */\\r\\n    function multiMintToken(address[] memory _from, uint256[] memory _value) public onlyOwner returns (bool success) {\\r\\n        uint256 i = 0;\\r\\n        while (i \\u003c _from.length) {\\r\\n            mintToken(_from[i], _value[i]);\\r\\n            i += 1;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice `freeze? Prevent | Allow` `target` from sending \\u0026 receiving tokens\\r\\n    /// @param target Address to be frozen\\r\\n    /// @param _value value of target Address to be frozen\\r\\n    function freezeToken(address target, uint256 _value) onlyOwner public {\\r\\n        require(balanceOf[target] -freezeOf[target]\\u003e= _value);\\r\\n        freezeOf[target] += _value;\\r\\n        emit FreezeFunds(target, _value);\\r\\n    }\\r\\n\\r\\n    /// @notice `freeze? Prevent | Allow` `target` from sending \\u0026 receiving tokens\\r\\n    /// @param target Address to be frozen\\r\\n    /// @param _value value of target Address to be frozen\\r\\n    function unfreezeToken(address target, uint256 _value) onlyOwner public {\\r\\n        require(freezeOf[target] \\u003e= _value);\\r\\n        freezeOf[target] -= _value;\\r\\n        emit UnFreezeFunds(target, _value);\\r\\n    }\\r\\n}\\r\\n\\r\\n\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"multiTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"freezeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"multiMintToken\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"unfreezeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"mintedAmount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"multiBurnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setSuspendTrading\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"freezeOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"UnFreezeFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FreezeFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"NOSToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8c079341849695cdac58044a823b75fba3aa8ccb818f3d3e9a50307b1b07d21d"}]}