{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n   /*\r\n   Over solidity version 0.5.0, Cannot assign same function name at constructor;\r\n  function Ownable() public {\r\n  */\r\n  constructor () internal {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n    /**\r\n     * @title Secondary\r\n     * @dev A Secondary contract can only be used by its primary account (the one that created it)\r\n     */\r\n    contract Secondary {\r\n        address private _primary;\r\n    \r\n        event PrimaryTransferred(\r\n            address recipient\r\n        );\r\n    \r\n        /**\r\n         * @dev Sets the primary account to the one that is creating the Secondary contract.\r\n         */\r\n        constructor () internal {\r\n            _primary = msg.sender;\r\n            emit PrimaryTransferred(_primary);\r\n        }\r\n    \r\n        /**\r\n         * @dev Reverts if called from any account other than the primary.\r\n         */\r\n        modifier onlyPrimary() {\r\n            require(msg.sender == _primary);\r\n            _;\r\n        }\r\n    \r\n        /**\r\n         * @return the address of the primary.\r\n         */\r\n        function primary() public view returns (address) {\r\n            return _primary;\r\n        }\r\n    \r\n        /**\r\n         * @dev Transfers contract to a new primary.\r\n         * @param recipient The address of new primary.\r\n         */\r\n        function transferPrimary(address recipient) public onlyPrimary {\r\n            require(recipient != address(0));\r\n            _primary = recipient;\r\n            emit PrimaryTransferred(_primary);\r\n        }\r\n    }\r\n    \r\n    // File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\IERC20.sol\r\n    /**\r\n     * @title ERC20 interface\r\n     * @dev see https://github.com/ethereum/EIPs/issues/20\r\n     */\r\n    \r\n    interface IERC20 {\r\n        function transfer(address to, uint256 value) external returns (bool);\r\n    \r\n        function approve(address spender, uint256 value) external returns (bool);\r\n    \r\n        function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    \r\n        function totalSupply() external view returns (uint256);\r\n    \r\n        function balanceOf(address who) external view returns (uint256);\r\n    \r\n        function allowance(address owner, address spender) external view returns (uint256);\r\n    \r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n        event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    }\r\n    \r\n    \r\n    // File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\r\n    /**\r\n     * @title Standard ERC20 token\r\n     *\r\n     * @dev Implementation of the basic standard token.\r\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n     * Originally based on code by FirstBlood:\r\n     * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n     *\r\n     * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n     * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n     * compliant implementations may not do it.\r\n     */\r\n    /**\r\n     * @title Standard ERC20 token\r\n     *\r\n     * @dev Implementation of the basic standard token.\r\n     * https://eips.ethereum.org/EIPS/eip-20\r\n     * Originally based on code by FirstBlood:\r\n     * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n     *\r\n     * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\r\n     * all accounts just by listening to said events. Note that this isn't required by the specification, and other\r\n     * compliant implementations may not do it.\r\n     */\r\n    contract ERC20 is IERC20 {\r\n        using SafeMath for uint256;\r\n    \r\n        mapping (address => uint256) private _balances;\r\n    \r\n        mapping (address => mapping (address => uint256)) private _allowed;\r\n    \r\n        uint256 private _totalSupply;\r\n    \r\n        /**\r\n         * @dev Total number of tokens in existence\r\n         */\r\n        function totalSupply() public view returns (uint256) {\r\n            return _totalSupply;\r\n        }\r\n    \r\n        /**\r\n         * @dev Gets the balance of the specified address.\r\n         * @param owner The address to query the balance of.\r\n         * @return A uint256 representing the amount owned by the passed address.\r\n         */\r\n        function balanceOf(address owner) public view returns (uint256) {\r\n            return _balances[owner];\r\n        }\r\n    \r\n        /**\r\n         * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n         * @param owner address The address which owns the funds.\r\n         * @param spender address The address which will spend the funds.\r\n         * @return A uint256 specifying the amount of tokens still available for the spender.\r\n         */\r\n        function allowance(address owner, address spender) public view returns (uint256) {\r\n            return _allowed[owner][spender];\r\n        }\r\n    \r\n        /**\r\n         * @dev Transfer token to a specified address\r\n         * @param to The address to transfer to.\r\n         * @param value The amount to be transferred.\r\n         */\r\n        function transfer(address to, uint256 value) public returns (bool) {\r\n            _transfer(msg.sender, to, value);\r\n            return true;\r\n        }\r\n    \r\n        /**\r\n         * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n         * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n         * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n         * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n         * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n         * @param spender The address which will spend the funds.\r\n         * @param value The amount of tokens to be spent.\r\n         */\r\n        function approve(address spender, uint256 value) public returns (bool) {\r\n            _approve(msg.sender, spender, value);\r\n            return true;\r\n        }\r\n    \r\n        /**\r\n         * @dev Transfer tokens from one address to another.\r\n         * Note that while this function emits an Approval event, this is not required as per the specification,\r\n         * and other compliant implementations may not emit the event.\r\n         * @param from address The address which you want to send tokens from\r\n         * @param to address The address which you want to transfer to\r\n         * @param value uint256 the amount of tokens to be transferred\r\n         */\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n            _transfer(from, to, value);\r\n            _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\r\n            return true;\r\n        }\r\n    \r\n        /**\r\n         * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n         * approve should be called when _allowed[msg.sender][spender] == 0. To increment\r\n         * allowed value is better to use this function to avoid 2 calls (and wait until\r\n         * the first transaction is mined)\r\n         * From MonolithDAO Token.sol\r\n         * Emits an Approval event.\r\n         * @param spender The address which will spend the funds.\r\n         * @param addedValue The amount of tokens to increase the allowance by.\r\n         */\r\n        function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n            _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\r\n            return true;\r\n        }\r\n    \r\n        /**\r\n         * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n         * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\r\n         * allowed value is better to use this function to avoid 2 calls (and wait until\r\n         * the first transaction is mined)\r\n         * From MonolithDAO Token.sol\r\n         * Emits an Approval event.\r\n         * @param spender The address which will spend the funds.\r\n         * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n         */\r\n        function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n            _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\r\n            return true;\r\n        }\r\n    \r\n        /**\r\n         * @dev Transfer token for a specified addresses\r\n         * @param from The address to transfer from.\r\n         * @param to The address to transfer to.\r\n         * @param value The amount to be transferred.\r\n         */\r\n        function _transfer(address from, address to, uint256 value) internal {\r\n            require(to != address(0));\r\n    \r\n            _balances[from] = _balances[from].sub(value);\r\n            _balances[to] = _balances[to].add(value);\r\n            emit Transfer(from, to, value);\r\n        }\r\n    \r\n        /**\r\n         * @dev Internal function that mints an amount of the token and assigns it to\r\n         * an account. This encapsulates the modification of balances such that the\r\n         * proper events are emitted.\r\n         * @param account The account that will receive the created tokens.\r\n         * @param value The amount that will be created.\r\n         */\r\n        function _mint(address account, uint256 value) internal {\r\n            require(account != address(0));\r\n    \r\n            _totalSupply = _totalSupply.add(value);\r\n            _balances[account] = _balances[account].add(value);\r\n            emit Transfer(address(0), account, value);\r\n        }\r\n    \r\n        /**\r\n         * @dev Internal function that burns an amount of the token of a given\r\n         * account.\r\n         * @param account The account whose tokens will be burnt.\r\n         * @param value The amount that will be burnt.\r\n         */\r\n        function _burn(address account, uint256 value) internal {\r\n            require(account != address(0));\r\n    \r\n            _totalSupply = _totalSupply.sub(value);\r\n            _balances[account] = _balances[account].sub(value);\r\n            emit Transfer(account, address(0), value);\r\n        }\r\n    \r\n        /**\r\n         * @dev Approve an address to spend another addresses' tokens.\r\n         * @param owner The address that owns the tokens.\r\n         * @param spender The address that will spend the tokens.\r\n         * @param value The number of tokens that can be spent.\r\n         */\r\n        function _approve(address owner, address spender, uint256 value) internal {\r\n            require(spender != address(0));\r\n            require(owner != address(0));\r\n    \r\n            _allowed[owner][spender] = value;\r\n            emit Approval(owner, spender, value);\r\n        }\r\n    \r\n        /**\r\n         * @dev Internal function that burns an amount of the token of a given\r\n         * account, deducting from the sender's allowance for said account. Uses the\r\n         * internal burn function.\r\n         * Emits an Approval event (reflecting the reduced allowance).\r\n         * @param account The account whose tokens will be burnt.\r\n         * @param value The amount that will be burnt.\r\n         */\r\n        function _burnFrom(address account, uint256 value) internal {\r\n            _burn(account, value);\r\n            _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\r\n        }\r\n    }\r\n    \r\n    \r\n    // File: openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Burnable.sol\r\n    /**\r\n     * @title Burnable Token\r\n     * @dev Token that can be irreversibly burned (destroyed).\r\n     */\r\n    contract ERC20Burnable is ERC20 {\r\n        /**\r\n         * @dev Burns a specific amount of tokens.\r\n         * @param value The amount of token to be burned.\r\n         */\r\n        function burn(uint256 value) public {\r\n            _burn(msg.sender, value);\r\n        }\r\n    \r\n        /**\r\n         * @dev Burns a specific amount of tokens from the target address and decrements allowance\r\n         * @param from address The account whose tokens will be burned.\r\n         * @param value uint256 The amount of token to be burned.\r\n         */\r\n        function burnFrom(address from, uint256 value) public {\r\n            _burnFrom(from, value);\r\n        }\r\n    }\r\n    // File: node_modules\\openzeppelin-solidity\\contracts\\access\\Roles.sol\r\n    /**\r\n     * @title Roles\r\n     * @dev Library for managing addresses assigned to a Role.\r\n     */\r\n    library Roles {\r\n        struct Role {\r\n            mapping (address => bool) bearer;\r\n        }\r\n    \r\n        /**\r\n         * @dev give an account access to this role\r\n         */\r\n        function add(Role storage role, address account) internal {\r\n            require(account != address(0));\r\n            require(!has(role, account));\r\n    \r\n            role.bearer[account] = true;\r\n        }\r\n    \r\n        /**\r\n         * @dev remove an account's access to this role\r\n         */\r\n        function remove(Role storage role, address account) internal {\r\n            require(account != address(0));\r\n            require(has(role, account));\r\n    \r\n            role.bearer[account] = false;\r\n        }\r\n    \r\n        /**\r\n         * @dev check if an account has this role\r\n         * @return bool\r\n         */\r\n        function has(Role storage role, address account) internal view returns (bool) {\r\n            require(account != address(0));\r\n            return role.bearer[account];\r\n        }\r\n    }\r\n    \r\n    // File: node_modules\\openzeppelin-solidity\\contracts\\access\\roles\\MinterRole.sol\r\n    contract MinterRole {\r\n        using Roles for Roles.Role;\r\n    \r\n        event MinterAdded(address indexed account);\r\n        event MinterRemoved(address indexed account);\r\n    \r\n        Roles.Role private _minters;\r\n    \r\n        constructor () internal {\r\n            _addMinter(msg.sender);\r\n        }\r\n    \r\n        modifier onlyMinter() {\r\n            require(isMinter(msg.sender));\r\n            _;\r\n        }\r\n    \r\n        function isMinter(address account) public view returns (bool) {\r\n            return _minters.has(account);\r\n        }\r\n    \r\n        function addMinter(address account) public onlyMinter {\r\n            _addMinter(account);\r\n        }\r\n    \r\n        function renounceMinter() public {\r\n            _removeMinter(msg.sender);\r\n        }\r\n    \r\n        function _addMinter(address account) internal {\r\n            _minters.add(account);\r\n            emit MinterAdded(account);\r\n        }\r\n    \r\n        function _removeMinter(address account) internal {\r\n            _minters.remove(account);\r\n            emit MinterRemoved(account);\r\n        }\r\n    }\r\n    \r\n    // File: openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Mintable.sol\r\n    \r\n    /**\r\n     * @title ERC20Mintable\r\n     * @dev ERC20 minting logic\r\n     */\r\n    contract ERC20Mintable is ERC20, MinterRole {\r\n        /**\r\n         * @dev Function to mint tokens\r\n         * @param to The address that will receive the minted tokens.\r\n         * @param value The amount of tokens to mint.\r\n         * @return A boolean that indicates if the operation was successful.\r\n         */\r\n        function mint(address to, uint256 value) public onlyMinter returns (bool) {\r\n            _mint(to, value);\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // File: contracts\\ERC20Frozenable.sol\r\n    \r\n    \r\n    //truffle-flattener Token.sol\r\n    contract ERC20Frozenable is ERC20Burnable, ERC20Mintable, Ownable {\r\n        mapping (address => bool) private _frozenAccount;\r\n        event FrozenFunds(address target, bool frozen);\r\n    \r\n    \r\n        function frozenAccount(address _address) public view returns(bool isFrozen) {\r\n            return _frozenAccount[_address];\r\n        }\r\n    \r\n        function freezeAccount(address target, bool freeze)  public onlyOwner {\r\n            require(_frozenAccount[target] != freeze, \"Same as current\");\r\n            _frozenAccount[target] = freeze;\r\n            emit FrozenFunds(target, freeze);\r\n        }\r\n    \r\n        function _transfer(address from, address to, uint256 value) internal {\r\n            require(!_frozenAccount[from], \"error - frozen\");\r\n            require(!_frozenAccount[to], \"error - frozen\");\r\n            super._transfer(from, to, value);\r\n        }\r\n    \r\n    }\r\n    \r\n    // File: openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Detailed.sol\r\n    \r\n    /**\r\n     * @title ERC20Detailed token\r\n     * @dev The decimals are only for visualization purposes.\r\n     * All the operations are done using the smallest and indivisible token unit,\r\n     * just as on Ethereum all the operations are done in wei.\r\n     */\r\n    contract ERC20Detailed is IERC20 {\r\n        string private _name;\r\n        string private _symbol;\r\n        uint8 private _decimals;\r\n    \r\n        constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n            _name = name;\r\n            _symbol = symbol;\r\n            _decimals = decimals;\r\n        }\r\n    \r\n        /**\r\n         * @return the name of the token.\r\n         */\r\n        function name() public view returns (string memory) {\r\n            return _name;\r\n        }\r\n    \r\n        /**\r\n         * @return the symbol of the token.\r\n         */\r\n        function symbol() public view returns (string memory) {\r\n            return _symbol;\r\n        }\r\n    \r\n        /**\r\n         * @return the number of decimals of the token.\r\n         */\r\n        function decimals() public view returns (uint8) {\r\n            return _decimals;\r\n        }\r\n    }\r\n    \r\n     /**\r\n      * @title Escrow\r\n      * @dev Base escrow contract, holds funds designated for a payee until they\r\n      * withdraw them.\r\n      * @dev Intended usage: This contract (and derived escrow contracts) should be a\r\n      * standalone contract, that only interacts with the contract that instantiated\r\n      * it. That way, it is guaranteed that all Ether will be handled according to\r\n      * the Escrow rules, and there is no need to check for payable functions or\r\n      * transfers in the inheritance tree. The contract that uses the escrow as its\r\n      * payment method should be its primary, and provide public methods redirecting\r\n      * to the escrow's deposit and withdraw.\r\n      */\r\n    contract Escrow is Secondary {\r\n        using SafeMath for uint256;\r\n    \r\n        event Deposited(address indexed payee, uint256 weiAmount);\r\n        event Withdrawn(address indexed payee, uint256 weiAmount);\r\n    \r\n        mapping(address => uint256) private _deposits;\r\n    \r\n        function depositsOf(address payee) public view returns (uint256) {\r\n            return _deposits[payee];\r\n        }\r\n    \r\n        /**\r\n         * @dev Stores the sent amount as credit to be withdrawn.\r\n         * @param payee The destination address of the funds.\r\n         */\r\n        function deposit(address payee) public onlyPrimary payable {\r\n            uint256 amount = msg.value;\r\n            _deposits[payee] = _deposits[payee].add(amount);\r\n    \r\n            emit Deposited(payee, amount);\r\n        }\r\n    \r\n        /**\r\n         * @dev Withdraw accumulated balance for a payee.\r\n         * @param payee The address whose funds will be withdrawn and transferred to.\r\n         */\r\n        function withdraw(address payee) public onlyPrimary {\r\n            uint256 payment = _deposits[payee];\r\n    \r\n            _deposits[payee] = 0;\r\n    \r\n            payee.transfer(payment);\r\n    \r\n            emit Withdrawn(payee, payment);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @title PullPayment\r\n     * @dev Base contract supporting async send for pull payments. Inherit from this\r\n     * contract and use _asyncTransfer instead of send or transfer.\r\n     */\r\n    contract PullPayment {\r\n        Escrow private _escrow;\r\n    \r\n        constructor () internal {\r\n            _escrow = new Escrow();\r\n        }\r\n    \r\n        /**\r\n         * @dev Withdraw accumulated balance.\r\n         * @param payee Whose balance will be withdrawn.\r\n         */\r\n        function withdrawPayments(address payee) public {\r\n            _escrow.withdraw(payee);\r\n        }\r\n    \r\n        /**\r\n         * @dev Returns the credit owed to an address.\r\n         * @param dest The creditor's address.\r\n         */\r\n        function payments(address dest) public view returns (uint256) {\r\n            return _escrow.depositsOf(dest);\r\n        }\r\n    \r\n        /**\r\n         * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n         * @param dest The destination address of the funds.\r\n         * @param amount The amount to transfer.\r\n         */\r\n        function _asyncTransfer(address dest, uint256 amount) internal {\r\n            _escrow.deposit.value(amount)(dest);\r\n        }\r\n    }\r\n    \r\n    contract PaymentSplitter {\r\n        using SafeMath for uint256;\r\n    \r\n        event PayeeAdded(address account, uint256 shares);\r\n        event PaymentReleased(address to, uint256 amount);\r\n        event PaymentReceived(address from, uint256 amount);\r\n    \r\n        uint256 private _totalShares;\r\n        uint256 private _totalReleased;\r\n    \r\n        mapping(address => uint256) private _shares;\r\n        mapping(address => uint256) private _released;\r\n        address[] private _payees;\r\n    \r\n        /**\r\n         * @dev Constructor\r\n         */\r\n        constructor (address[] memory payees, uint256[] memory shares) public payable {\r\n            require(payees.length == shares.length);\r\n            require(payees.length > 0);\r\n    \r\n            for (uint256 i = 0; i < payees.length; i++) {\r\n                _addPayee(payees[i], shares[i]);\r\n            }\r\n        }\r\n    \r\n        /**\r\n         * @dev payable fallback\r\n         */\r\n        function () external payable {\r\n            emit PaymentReceived(msg.sender, msg.value);\r\n        }\r\n    \r\n        /**\r\n         * @return the total shares of the contract.\r\n         */\r\n        function totalShares() public view returns (uint256) {\r\n            return _totalShares;\r\n        }\r\n    \r\n        /**\r\n         * @return the total amount already released.\r\n         */\r\n        function totalReleased() public view returns (uint256) {\r\n            return _totalReleased;\r\n        }\r\n    \r\n        /**\r\n         * @return the shares of an account.\r\n         */\r\n        function shares(address account) public view returns (uint256) {\r\n            return _shares[account];\r\n        }\r\n    \r\n        /**\r\n         * @return the amount already released to an account.\r\n         */\r\n        function released(address account) public view returns (uint256) {\r\n            return _released[account];\r\n        }\r\n    \r\n        /**\r\n         * @return the address of a payee.\r\n         */\r\n        function payee(uint256 index) public view returns (address) {\r\n            return _payees[index];\r\n        }\r\n    \r\n        /**\r\n         * @dev Release one of the payee's proportional payment.\r\n         * @param account Whose payments will be released.\r\n         */\r\n        function release(address account) public {\r\n            require(_shares[account] > 0);\r\n    \r\n            uint256 totalReceived = address(this).balance.add(_totalReleased);\r\n            uint256 payment = totalReceived.mul(_shares[account]).div(_totalShares).sub(_released[account]);\r\n    \r\n            require(payment != 0);\r\n    \r\n            _released[account] = _released[account].add(payment);\r\n            _totalReleased = _totalReleased.add(payment);\r\n    \r\n            account.transfer(payment);\r\n            emit PaymentReleased(account, payment);\r\n        }\r\n    \r\n        /**\r\n         * @dev Add a new payee to the contract.\r\n         * @param account The address of the payee to add.\r\n         * @param shares_ The number of shares owned by the payee.\r\n         */\r\n        function _addPayee(address account, uint256 shares_) private {\r\n            require(account != address(0));\r\n            require(shares_ > 0);\r\n            require(_shares[account] == 0);\r\n    \r\n            _payees.push(account);\r\n            _shares[account] = shares_;\r\n            _totalShares = _totalShares.add(shares_);\r\n            emit PayeeAdded(account, shares_);\r\n        }\r\n    }\r\n    \r\n    contract ConditionalEscrow is Escrow {\r\n        /**\r\n         * @dev Returns whether an address is allowed to withdraw their funds. To be\r\n         * implemented by derived contracts.\r\n         * @param payee The destination address of the funds.\r\n         */\r\n        function withdrawalAllowed(address payee) public view returns (bool);\r\n    \r\n        function withdraw(address payee) public {\r\n            require(withdrawalAllowed(payee));\r\n            super.withdraw(payee);\r\n        }\r\n    }\r\n    \r\n    \r\n    contract RefundEscrow is ConditionalEscrow {\r\n        enum State { Active, Refunding, Closed }\r\n    \r\n        event RefundsClosed();\r\n        event RefundsEnabled();\r\n    \r\n        State private _state;\r\n        address private _beneficiary;\r\n    \r\n        /**\r\n         * @dev Constructor.\r\n         * @param beneficiary The beneficiary of the deposits.\r\n         */\r\n        constructor (address beneficiary) public {\r\n            require(beneficiary != address(0));\r\n            _beneficiary = beneficiary;\r\n            _state = State.Active;\r\n        }\r\n    \r\n        /**\r\n         * @return the current state of the escrow.\r\n         */\r\n        function state() public view returns (State) {\r\n            return _state;\r\n        }\r\n    \r\n        /**\r\n         * @return the beneficiary of the escrow.\r\n         */\r\n        function beneficiary() public view returns (address) {\r\n            return _beneficiary;\r\n        }\r\n    \r\n        /**\r\n         * @dev Stores funds that may later be refunded.\r\n         * @param refundee The address funds will be sent to if a refund occurs.\r\n         */\r\n        function deposit(address refundee) public payable {\r\n            require(_state == State.Active);\r\n            super.deposit(refundee);\r\n        }\r\n    \r\n        /**\r\n         * @dev Allows for the beneficiary to withdraw their funds, rejecting\r\n         * further deposits.\r\n         */\r\n        function close() public onlyPrimary {\r\n            require(_state == State.Active);\r\n            _state = State.Closed;\r\n            emit RefundsClosed();\r\n        }\r\n    \r\n        /**\r\n         * @dev Allows for refunds to take place, rejecting further deposits.\r\n         */\r\n        function enableRefunds() public onlyPrimary {\r\n            require(_state == State.Active);\r\n            _state = State.Refunding;\r\n            emit RefundsEnabled();\r\n        }\r\n    \r\n        /**\r\n         * @dev Withdraws the beneficiary's funds.\r\n         */\r\n        function beneficiaryWithdraw() public {\r\n            require(_state == State.Closed);\r\n            _beneficiary.transfer(address(this).balance);\r\n        }\r\n    \r\n        /**\r\n         * @dev Returns whether refundees can withdraw their deposits (be refunded). The overridden function receives a\r\n         * 'payee' argument, but we ignore it here since the condition is global, not per-payee.\r\n         */\r\n        function withdrawalAllowed(address) public view returns (bool) {\r\n            return _state == State.Refunding;\r\n        }\r\n    }\r\n    // File: contracts\\Token.sol\r\n    //truffle-flattener Token.sol\r\n    contract KtuneTokenBlocks is ERC20Frozenable, ERC20Detailed {\r\n    \r\n        constructor()\r\n        ERC20Detailed(\"K-Tune Token\", \"KTT\", 18)\r\n        public {\r\n        }\r\n    }\r\n\r\n/**\r\n * @title WhitelistableConstraints\r\n * @dev Contract encapsulating the constraints applicable to a Whitelistable contract.\r\n */\r\ncontract WhitelistableConstraints {\r\n\r\n    /**\r\n     * @dev Check if whitelist with specified parameters is allowed.\r\n     * @param _maxWhitelistLength The maximum length of whitelist. Zero means no whitelist.\r\n     * @param _weiWhitelistThresholdBalance The threshold balance triggering whitelist check.\r\n     * @return true if whitelist with specified parameters is allowed, false otherwise\r\n     */\r\n    function isAllowedWhitelist(uint256 _maxWhitelistLength, uint256 _weiWhitelistThresholdBalance)\r\n        public pure returns(bool isReallyAllowedWhitelist) {\r\n        return _maxWhitelistLength > 0 || _weiWhitelistThresholdBalance > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Whitelistable\r\n * @dev Base contract implementing a whitelist to keep track of investors.\r\n * The construction parameters allow for both whitelisted and non-whitelisted contracts:\r\n * 1) maxWhitelistLength = 0 and whitelistThresholdBalance > 0: whitelist disabled\r\n * 2) maxWhitelistLength > 0 and whitelistThresholdBalance = 0: whitelist enabled, full whitelisting\r\n * 3) maxWhitelistLength > 0 and whitelistThresholdBalance > 0: whitelist enabled, partial whitelisting\r\n */\r\ncontract Whitelistable is WhitelistableConstraints {\r\n\r\n    event LogMaxWhitelistLengthChanged(address indexed caller, uint256 indexed maxWhitelistLength);\r\n    event LogWhitelistThresholdBalanceChanged(address indexed caller, uint256 indexed whitelistThresholdBalance);\r\n    event LogWhitelistAddressAdded(address indexed caller, address indexed subscriber);\r\n    event LogWhitelistAddressRemoved(address indexed caller, address indexed subscriber);\r\n\r\n    mapping (address => bool) public whitelist;\r\n\r\n    uint256 public whitelistLength;\r\n\r\n    uint256 public maxWhitelistLength;\r\n\r\n    uint256 public whitelistThresholdBalance;\r\n\r\n    constructor(uint256 _maxWhitelistLength, uint256 _whitelistThresholdBalance) internal {\r\n        require(isAllowedWhitelist(_maxWhitelistLength, _whitelistThresholdBalance), \"parameters not allowed\");\r\n\r\n        maxWhitelistLength = _maxWhitelistLength;\r\n        whitelistThresholdBalance = _whitelistThresholdBalance;\r\n    }\r\n\r\n    /**\r\n     * @return true if whitelist is currently enabled, false otherwise\r\n     */\r\n    function isWhitelistEnabled() public view returns(bool isReallyWhitelistEnabled) {\r\n        return maxWhitelistLength > 0;\r\n    }\r\n\r\n    /**\r\n     * @return true if subscriber is whitelisted, false otherwise\r\n     */\r\n    function isWhitelisted(address _subscriber) public view returns(bool isReallyWhitelisted) {\r\n        return whitelist[_subscriber];\r\n    }\r\n\r\n    function setMaxWhitelistLengthInternal(uint256 _maxWhitelistLength) internal {\r\n        require(isAllowedWhitelist(_maxWhitelistLength, whitelistThresholdBalance),\r\n            \"_maxWhitelistLength not allowed\");\r\n        require(_maxWhitelistLength != maxWhitelistLength, \"_maxWhitelistLength equal to current one\");\r\n\r\n        maxWhitelistLength = _maxWhitelistLength;\r\n\r\n        emit LogMaxWhitelistLengthChanged(msg.sender, maxWhitelistLength);\r\n    }\r\n\r\n    function setWhitelistThresholdBalanceInternal(uint256 _whitelistThresholdBalance) internal {\r\n        require(isAllowedWhitelist(maxWhitelistLength, _whitelistThresholdBalance),\r\n            \"_whitelistThresholdBalance not allowed\");\r\n        require(whitelistLength == 0 || _whitelistThresholdBalance > whitelistThresholdBalance,\r\n            \"_whitelistThresholdBalance not greater than current one\");\r\n\r\n        whitelistThresholdBalance = _whitelistThresholdBalance;\r\n\r\n        emit LogWhitelistThresholdBalanceChanged(msg.sender, _whitelistThresholdBalance);\r\n    }\r\n\r\n    function addToWhitelistInternal(address _subscriber) internal {\r\n        require(_subscriber != address(0), \"_subscriber is zero\");\r\n        require(!whitelist[_subscriber], \"already whitelisted\");\r\n        require(whitelistLength < maxWhitelistLength, \"max whitelist length reached\");\r\n\r\n        whitelistLength++;\r\n\r\n        whitelist[_subscriber] = true;\r\n\r\n        emit LogWhitelistAddressAdded(msg.sender, _subscriber);\r\n    }\r\n\r\n    function removeFromWhitelistInternal(address _subscriber, uint256 _balance) internal {\r\n        require(_subscriber != address(0), \"_subscriber is zero\");\r\n        require(whitelist[_subscriber], \"not whitelisted\");\r\n        require(_balance <= whitelistThresholdBalance, \"_balance greater than whitelist threshold\");\r\n\r\n        assert(whitelistLength > 0);\r\n\r\n        whitelistLength--;\r\n\r\n        whitelist[_subscriber] = false;\r\n\r\n        emit LogWhitelistAddressRemoved(msg.sender, _subscriber);\r\n    }\r\n\r\n    /**\r\n     * @param _subscriber The subscriber for which the balance check is required.\r\n     * @param _balance The balance value to check for allowance.\r\n     * @return true if the balance is allowed for the subscriber, false otherwise\r\n     */\r\n    function isAllowedBalance(address _subscriber, uint256 _balance) public view returns(bool isReallyAllowed) {\r\n        return !isWhitelistEnabled() || _balance <= whitelistThresholdBalance || whitelist[_subscriber];\r\n    }\r\n}\r\n\r\n// Abstract base contract\r\ncontract KYCBase {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => bool) public isKycSigner;\r\n    mapping (uint64 => uint256) public alreadyPayed;\r\n\r\n    event KycVerified(address indexed signer, address buyerAddress, uint64 buyerId, uint maxAmount);\r\n\r\n    constructor(address[] memory kycSigners) internal {\r\n        for (uint i = 0; i < kycSigners.length; i++) {\r\n            isKycSigner[kycSigners[i]] = true;\r\n        }\r\n    }\r\n\r\n    // Must be implemented in descending contract to assign tokens to the buyers. Called after the KYC verification is passed\r\n    function releaseTokensTo(address buyer) internal returns(bool);\r\n\r\n    // This method can be overridden to enable some sender to buy token for a different address\r\n    function senderAllowedFor(address buyer)\r\n        internal view returns(bool)\r\n    {\r\n        return buyer == msg.sender;\r\n    }\r\n\r\n    function buyTokensFor(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)\r\n        public payable returns (bool)\r\n    {\r\n        require(senderAllowedFor(buyerAddress), \"senderAllowedFor\");\r\n        return buyImplementation(buyerAddress, buyerId, maxAmount, v, r, s);\r\n    }\r\n\r\n    function buyTokens(uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)\r\n        public payable returns (bool)\r\n    {\r\n        return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s);\r\n    }\r\n\r\n    function buyImplementation(\r\n        address buyerAddress,\r\n        uint64 buyerId,\r\n        uint maxAmount,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) private returns (bool)\r\n    {\r\n        // check the signature\r\n        bytes32 hash = sha256(\r\n            abi.encodePacked(\r\n                \"Eidoo icoengine authorization\",\r\n                this,\r\n                buyerAddress,\r\n                buyerId,\r\n                maxAmount\r\n            )\r\n        );\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (!isKycSigner[signer]) {\r\n            revert(\"!isKycSigner\");\r\n        } else {\r\n            uint256 totalPayed = alreadyPayed[buyerId].add(msg.value);\r\n            require(totalPayed <= maxAmount, \"totalPayed <= maxAmount\");\r\n            alreadyPayed[buyerId] = totalPayed;\r\n            emit KycVerified(signer, buyerAddress, buyerId, maxAmount);\r\n            return releaseTokensTo(buyerAddress);\r\n        }\r\n    }\r\n\r\n    // No payable fallback function, the tokens must be buyed using the functions buyTokens and buyTokensFor\r\n    /*\r\n    build to fallback function from solidity version over 0.5, have to write external\r\n    now solidity version is 0.5.1\r\n    function () public {\r\n    */\r\n    function () external {\r\n        revert();\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title CrowdsaleKYC\r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\n * Crowdsales have a start and end block, where investors can make\r\n * token purchases and the crowdsale will assign them tokens based\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet\r\n * as they arrive.\r\n */\r\ncontract CrowdsaleKYC is Pausable, Whitelistable, KYCBase {\r\n    using AddressUtils for address;\r\n    using SafeMath for uint256;\r\n\r\n    event LogStartBlockChanged(uint256 indexed startBlock);\r\n    event LogEndBlockChanged(uint256 indexed endBlock);\r\n    event LogMinDepositChanged(uint256 indexed minDeposit);\r\n    event LogTokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 indexed amount, uint256 tokenAmount);\r\n    event AddedSenderAllowed(address semder);\r\n    event RemovedSenderAllowed(address semder);\r\n\r\n    // The token being sold\r\n    KtuneTokenBlocks public token;\r\n\r\n    // The start and end block where investments are allowed (both inclusive)\r\n    uint256 public startBlock;\r\n    uint256 public endBlock;\r\n\r\n    // How many token units a buyer gets per wei\r\n    uint256 public rate;\r\n\r\n    // Amount of raised money in wei\r\n    uint256 public raisedFunds;\r\n\r\n    // Amount of tokens already sold\r\n    uint256 public soldTokens;\r\n\r\n    // Balances in wei deposited by each subscriber\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    // The minimum balance for each subscriber in wei\r\n    uint256 public minDeposit;\r\n\r\n    // Senders allowed for buyTokensFor function\r\n    mapping (address => bool) public isAllowedSender;\r\n\r\n    modifier beforeStart() {\r\n        require(block.number < startBlock, \"already started\");\r\n        _;\r\n    }\r\n\r\n    modifier beforeEnd() {\r\n        require(block.number <= endBlock, \"already ended\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        uint256 _startBlock,\r\n        uint256 _endBlock,\r\n        uint256 _rate,\r\n        uint256 _minDeposit,\r\n        uint256 maxWhitelistLength,\r\n        uint256 whitelistThreshold,\r\n        address[] memory kycSigner\r\n    )\r\n    Whitelistable(maxWhitelistLength, whitelistThreshold)\r\n    KYCBase(kycSigner) internal\r\n    {\r\n        require(_startBlock >= block.number, \"_startBlock is lower than current block.number\");\r\n        require(_endBlock >= _startBlock, \"_endBlock is lower than _startBlock\");\r\n        require(_rate > 0, \"_rate is zero\");\r\n        require(_minDeposit > 0, \"_minDeposit is zero\");\r\n\r\n        startBlock = _startBlock;\r\n        endBlock = _endBlock;\r\n        rate = _rate;\r\n        minDeposit = _minDeposit;\r\n    }\r\n\r\n    //override KYCBase.senderAllowedFor\r\n    function senderAllowedFor(address buyer) internal view returns(bool)\r\n    {\r\n        //revert(appendStr(\"override KYCBase.senderAllowedFor\", toAsciiString(msg.sender), isAllowedSender[buyer]));\r\n        require(buyer == msg.sender, \"Buyer address not equal action address\");\r\n        return isAllowedSender[msg.sender] == true;\r\n    }\r\n\r\n    function addSenderAllowed(address _sender) external onlyOwner {\r\n        isAllowedSender[_sender] = true;\r\n        emit AddedSenderAllowed(_sender);\r\n    }\r\n\r\n    function removeSenderAllowed(address _sender) external onlyOwner {\r\n        delete isAllowedSender[_sender];\r\n        emit RemovedSenderAllowed(_sender);\r\n    }\r\n\r\n    /*\r\n    * @return true if crowdsale event has started\r\n    */\r\n    function hasStarted() public view returns (bool started) {\r\n        return block.number >= startBlock;\r\n    }\r\n\r\n    /*\r\n    * @return true if crowdsale event has ended\r\n    */\r\n    function hasEnded() public view returns (bool ended) {\r\n        return block.number > endBlock;\r\n    }\r\n\r\n    /**\r\n     * Change the crowdsale start block number.\r\n     * @param _startBlock The new start block\r\n     */\r\n    function setStartBlock(uint256 _startBlock) external onlyOwner beforeStart {\r\n        require(_startBlock >= block.number, \"_startBlock < current block\");\r\n        require(_startBlock <= endBlock, \"_startBlock > endBlock\");\r\n        require(_startBlock != startBlock, \"_startBlock == startBlock\");\r\n\r\n        startBlock = _startBlock;\r\n\r\n        emit LogStartBlockChanged(_startBlock);\r\n    }\r\n\r\n    /**\r\n     * Change the crowdsale end block number.\r\n     * @param _endBlock The new end block\r\n     */\r\n    function setEndBlock(uint256 _endBlock) external onlyOwner beforeEnd {\r\n        require(_endBlock >= block.number, \"_endBlock < current block\");\r\n        require(_endBlock >= startBlock, \"_endBlock < startBlock\");\r\n        require(_endBlock != endBlock, \"_endBlock == endBlock\");\r\n\r\n        endBlock = _endBlock;\r\n\r\n        emit LogEndBlockChanged(_endBlock);\r\n    }\r\n\r\n    /**\r\n     * Change the minimum deposit for each subscriber. New value shall be lower than previous.\r\n     * @param _minDeposit The minimum deposit for each subscriber, expressed in wei\r\n     */\r\n    function setMinDeposit(uint256 _minDeposit) external onlyOwner beforeEnd {\r\n        require(0 < _minDeposit && _minDeposit < minDeposit, \"_minDeposit is not in [0, minDeposit]\");\r\n\r\n        minDeposit = _minDeposit;\r\n\r\n        emit LogMinDepositChanged(minDeposit);\r\n    }\r\n\r\n    /**\r\n     * Change the maximum whitelist length. New value shall satisfy the #isAllowedWhitelist conditions.\r\n     * @param maxWhitelistLength The maximum whitelist length\r\n     */\r\n    function setMaxWhitelistLength(uint256 maxWhitelistLength) external onlyOwner beforeEnd {\r\n        setMaxWhitelistLengthInternal(maxWhitelistLength);\r\n    }\r\n\r\n    /**\r\n     * Change the whitelist threshold balance. New value shall satisfy the #isAllowedWhitelist conditions.\r\n     * @param whitelistThreshold The threshold balance (in wei) above which whitelisting is required to invest\r\n     */\r\n    function setWhitelistThresholdBalance(uint256 whitelistThreshold) external onlyOwner beforeEnd {\r\n        setWhitelistThresholdBalanceInternal(whitelistThreshold);\r\n    }\r\n\r\n    /**\r\n     * Add the subscriber to the whitelist.\r\n     * @param subscriber The subscriber to add to the whitelist.\r\n     */\r\n    function addToWhitelist(address subscriber) external onlyOwner beforeEnd {\r\n        addToWhitelistInternal(subscriber);\r\n    }\r\n\r\n    /**\r\n     * Removed the subscriber from the whitelist.\r\n     * @param subscriber The subscriber to remove from the whitelist.\r\n     */\r\n    function removeFromWhitelist(address subscriber) external onlyOwner beforeEnd {\r\n        removeFromWhitelistInternal(subscriber, balanceOf[subscriber]);\r\n    }\r\n\r\n    // // fallback function can be used to buy tokens\r\n    // function () external payable whenNotPaused {\r\n    //     buyTokens(msg.sender);\r\n    // }\r\n\r\n    // No payable fallback function, the tokens must be buyed using the functions buyTokens and buyTokensFor\r\n    function () external {\r\n        revert(\"No payable fallback function\");\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string memory){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0){\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(uint8(48 + i % 10));\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    // low level token purchase function\r\n    // function buyTokens(address beneficiary) public payable whenNotPaused {\r\n    function releaseTokensTo(address beneficiary) internal whenNotPaused returns(bool) {\r\n        require(beneficiary != address(0), \"beneficiary is zero\");\r\n        require(isValidPurchase(beneficiary), \"invalid purchase by beneficiary\");\r\n\r\n        balanceOf[beneficiary] = balanceOf[beneficiary].add(msg.value);\r\n\r\n        raisedFunds = raisedFunds.add(msg.value);\r\n\r\n        uint256 tokenAmount = calculateTokens(msg.value);\r\n\r\n        soldTokens = soldTokens.add(tokenAmount);\r\n\r\n        // revert(appendStr(\"releaseTokensTo\", toAsciiString(beneficiary), uint2str(tokenAmount)));\r\n\r\n        distributeTokens(beneficiary, tokenAmount);\r\n\r\n        //distributeTokens(address(0), 1);\r\n\r\n        emit LogTokenPurchase(msg.sender, beneficiary, msg.value, tokenAmount);\r\n\r\n        forwardFunds(msg.value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides Whitelistable#isAllowedBalance to add minimum deposit logic.\r\n     */\r\n    function isAllowedBalance(address beneficiary, uint256 balance) public view returns (bool isReallyAllowed) {\r\n        bool hasMinimumBalance = balance >= minDeposit;\r\n        return hasMinimumBalance && super.isAllowedBalance(beneficiary, balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Determine if the token purchase is valid or not.\r\n     * @return true if the transaction can buy tokens\r\n     */\r\n    function isValidPurchase(address beneficiary) internal view returns (bool isValid) {\r\n        bool withinPeriod = startBlock <= block.number && block.number <= endBlock;\r\n        bool nonZeroPurchase = msg.value != 0;\r\n        bool isValidBalance = isAllowedBalance(beneficiary, balanceOf[beneficiary].add(msg.value));\r\n\r\n        return withinPeriod && nonZeroPurchase && isValidBalance;\r\n    }\r\n\r\n    // Calculate the token amount given the invested ether amount.\r\n    // Override to create custom fund forwarding mechanisms\r\n    function calculateTokens(uint256 amount) internal view returns (uint256 tokenAmount) {\r\n        return amount.mul(rate);\r\n    }\r\n\r\n    /**\r\n     * @dev Distribute the token amount to the beneficiary.\r\n     * @notice Override to create custom distribution mechanisms\r\n     */\r\n    function distributeTokens(address beneficiary, uint256 tokenAmount) internal {\r\n        token.mint(beneficiary, tokenAmount);\r\n    }\r\n\r\n    // Send ether amount to the fund collection wallet.\r\n    // override to create custom fund forwarding mechanisms\r\n    function forwardFunds(uint256 amount) internal;\r\n}\r\n\r\n/**\r\n * @title CappedCrowdsaleKYC\r\n * @dev Extension of Crowsdale with a max amount of funds raised\r\n */\r\ncontract TokenCappedCrowdsaleKYC is CrowdsaleKYC {\r\n    using SafeMath for uint256;\r\n\r\n    // The maximum token cap, should be initialized in derived contract\r\n    uint256 public tokenCap;\r\n\r\n    // Overriding Crowdsale#hasEnded to add tokenCap logic\r\n    // @return true if crowdsale event has ended\r\n    function hasEnded() public view returns (bool) {\r\n        bool capReached = soldTokens >= tokenCap;\r\n        return super.hasEnded() || capReached;\r\n    }\r\n\r\n    // Overriding Crowdsale#isValidPurchase to add extra cap logic\r\n    // @return true if investors can buy at the moment\r\n    function isValidPurchase(address beneficiary) internal view returns (bool isValid) {\r\n        uint256 tokenAmount = calculateTokens(msg.value);\r\n        bool withinCap = soldTokens.add(tokenAmount) <= tokenCap;\r\n        return withinCap && super.isValidPurchase(beneficiary);\r\n    }\r\n}\r\n\r\n/**\r\n * @title K-TuneCustomCrowdsaleKYC\r\n * @dev Extension of TokenCappedCrowdsaleKYC using values specific for K-Tune Custom ICO crowdsale\r\n */\r\ncontract KTuneCustomCrowdsaleKYC is TokenCappedCrowdsaleKYC {\r\n    using AddressUtils for address;\r\n    using SafeMath for uint256;\r\n\r\n    event LogKTuneCustomCrowdsaleCreated(\r\n        address sender,\r\n        uint256 indexed startBlock,\r\n        uint256 indexed endBlock,\r\n        address indexed wallet\r\n    );\r\n\r\n    // The wallet address or not contract\r\n    address public wallet;\r\n\r\n    constructor(\r\n        uint256 _startBlock,\r\n        uint256 _endBlock,\r\n        uint256 _rate,\r\n        uint256 _minDeposit,\r\n        address _token,\r\n        uint256 _tokenMaximumSupply,\r\n        address _wallet,\r\n        address[] memory _kycSigner\r\n    )\r\n    CrowdsaleKYC(\r\n        _startBlock,\r\n        _endBlock,\r\n        _rate,\r\n        _minDeposit,\r\n        1,\r\n        1,\r\n        _kycSigner\r\n    )\r\n    public {\r\n        require(_token.isContract(), \"_token is not contract\");\r\n        require(_tokenMaximumSupply > 0, \"_tokenMaximumSupply is zero\");\r\n\r\n        token = KtuneTokenBlocks(_token);\r\n        wallet = _wallet;\r\n\r\n        // Assume predefined token supply has been minted and calculate the maximum number of tokens that can be sold\r\n        // tokenCap = _tokenMaximumSupply.sub(token.totalSupply());\r\n        tokenCap = _tokenMaximumSupply;\r\n\r\n        emit LogKTuneCustomCrowdsaleCreated(msg.sender, startBlock, endBlock, _wallet);\r\n    }\r\n\r\n    function grantTokenOwnership(address _client) external onlyOwner returns(bool granted) {\r\n        require(!_client.isContract(), \"_client is contract\");\r\n        require(hasEnded(), \"crowdsale not ended yet\");\r\n\r\n        // Transfer K-TuneCustomERC20 ownership back to the client\r\n        token.transferOwnership(_client);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Overriding Crowdsale#forwardFunds to split net/fee payment.\r\n     */\r\n    function forwardFunds(uint256 amount) internal {\r\n        wallet.transfer(amount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"isAllowedBalance\",\"outputs\":[{\"name\":\"isReallyAllowed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isKycSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isWhitelistEnabled\",\"outputs\":[{\"name\":\"isReallyWhitelistEnabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_subscriber\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"isReallyWhitelisted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasStarted\",\"outputs\":[{\"name\":\"started\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistThresholdBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maxWhitelistLength\",\"type\":\"uint256\"}],\"name\":\"setMaxWhitelistLength\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minDeposit\",\"type\":\"uint256\"}],\"name\":\"setMinDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"alreadyPayed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"removeSenderAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyerAddress\",\"type\":\"address\"},{\"name\":\"buyerId\",\"type\":\"uint64\"},{\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"buyTokensFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAllowedSender\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"addSenderAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endBlock\",\"type\":\"uint256\"}],\"name\":\"setEndBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_maxWhitelistLength\",\"type\":\"uint256\"},{\"name\":\"_weiWhitelistThresholdBalance\",\"type\":\"uint256\"}],\"name\":\"isAllowedWhitelist\",\"outputs\":[{\"name\":\"isReallyAllowedWhitelist\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_client\",\"type\":\"address\"}],\"name\":\"grantTokenOwnership\",\"outputs\":[{\"name\":\"granted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyerId\",\"type\":\"uint64\"},{\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raisedFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxWhitelistLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"name\":\"setStartBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"whitelistThreshold\",\"type\":\"uint256\"}],\"name\":\"setWhitelistThresholdBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_minDeposit\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_tokenMaximumSupply\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_kycSigner\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"startBlock\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"endBlock\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"LogKTuneCustomCrowdsaleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"startBlock\",\"type\":\"uint256\"}],\"name\":\"LogStartBlockChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"endBlock\",\"type\":\"uint256\"}],\"name\":\"LogEndBlockChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"minDeposit\",\"type\":\"uint256\"}],\"name\":\"LogMinDepositChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"LogTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"semder\",\"type\":\"address\"}],\"name\":\"AddedSenderAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"semder\",\"type\":\"address\"}],\"name\":\"RemovedSenderAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyerId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"name\":\"KycVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"maxWhitelistLength\",\"type\":\"uint256\"}],\"name\":\"LogMaxWhitelistLengthChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"whitelistThresholdBalance\",\"type\":\"uint256\"}],\"name\":\"LogWhitelistThresholdBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"LogWhitelistAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"LogWhitelistAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"KTuneCustomCrowdsaleKYC","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000009896800000000000000000000000000000000000000000000000000000000000a7d8c0000000000000000000000000000000000000000000000077432217e683600000000000000000000000000000000000000000000000000077432217e68360000000000000000000000000000014cc8dfaf2258e1b8b2869300dba1b734dc0fe430000000000000000000000000000000000000000007c13bc4b2c133c56000000000000000000000000000000d97a91933f94153cc82312dad0cba83e6f7f61a900000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000dd5ecefcaa0cb5d75f7b72dc9d2ce446d6d005200000000000000000000000004e315e5de2abbf7b745d9628ee60e4355c0fab86","Library":"","LicenseType":"None","SwarmSource":"bzzr://5c5e50a04f2c84f0d0869c0186ab5223f12a8426013186c81aa1170295243303"}]}