{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.6;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n * Code yanked from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/*\r\n  The following two contracts, DAIHardFactory and DAIHardTrade, were audited by Adam Dossa\r\n  in June/July 2019. The results of this audit can be seen at:\r\n  https://github.com/burnable-tech/DAIHard/blob/4f8ef54f297420210a8eae15bd4f76ee051aab13/audit-info/DAIHard_Audit.md\r\n*/\r\n\r\ncontract DAIHardNativeFactory {\r\n    using SafeMath for uint;\r\n\r\n    event NewTrade(uint id, address tradeAddress, address indexed initiator);\r\n\r\n    address payable public founderFeeAddress;\r\n\r\n    constructor(address payable _founderFeeAddress)\r\n    public {\r\n        founderFeeAddress = _founderFeeAddress;\r\n    }\r\n\r\n    struct CreationInfo {\r\n        address address_;\r\n        uint blocknum;\r\n    }\r\n\r\n    CreationInfo[] public createdTrades;\r\n\r\n    function getFounderFee(uint tradeAmount)\r\n    public\r\n    pure\r\n    returns (uint founderFee) {\r\n        return tradeAmount / 200;\r\n    }\r\n\r\n    /*\r\n    The Solidity compiler can't handle much stack depth,\r\n    so we have to pack some args together in annoying ways...\r\n    Hence 'uintArgs' and 'addressArgs'.\r\n\r\n    Here are the layouts for createOpenTrade:\r\n\r\n    uintArgs:\r\n    0 - tradeAmount\r\n    1 - beneficiaryDeposit\r\n    2 - abortPunishment\r\n    3 - pokeReward\r\n    4 - autorecallInterval\r\n    5 - autoabortInterval\r\n    6 - autoreleaseInterval\r\n    7 - devFee\r\n\r\n    addressArgs:\r\n    0 - initiator\r\n    1 - devFeeAddress\r\n    */\r\n\r\n    function createOpenTrade(address payable[2] calldata addressArgs,\r\n                             bool initiatedByCustodian,\r\n                             uint[8] calldata uintArgs,\r\n                             string calldata terms,\r\n                             string calldata _commPubkey\r\n                             )\r\n    external\r\n    payable\r\n    returns (DAIHardNativeTrade) {\r\n        uint[8] memory newUintArgs; // Note that this structure is not the same as the above comment describes. See below in DAIHardNativeTrade.open.\r\n\r\n        if (initiatedByCustodian) {\r\n            // require: msg.value == tradeAmount + pokeReward + getFounderFee(tradeAmount) + devFee\r\n            require(msg.value == uintArgs[0].add(uintArgs[3]).add(getFounderFee(uintArgs[0])).add(uintArgs[7]),\"You didn't include the correct amount of value!\");\r\n\r\n            newUintArgs = [uintArgs[1], uintArgs[2], uintArgs[3], uintArgs[4], uintArgs[5], uintArgs[6], getFounderFee(uintArgs[0]), uintArgs[7]];\r\n            // see uintArgs comment above DAIHardNativeTrade.beginInOpenPhase\r\n        }\r\n        else {\r\n            // require: msg.value == beneficiaryDeposit + pokeReward + getFounderFee(tradeAmount) + devFee\r\n            require(msg.value == uintArgs[1].add(uintArgs[3]).add(getFounderFee(uintArgs[0])).add(uintArgs[7]), \"You didn't include the correct amount of value!\");\r\n\r\n            newUintArgs = [uintArgs[0], uintArgs[2], uintArgs[3], uintArgs[4], uintArgs[5], uintArgs[6], getFounderFee(uintArgs[0]), uintArgs[7]];\r\n            // see uintArgs comment above DAIHardNativeTrade.beginInOpenPhase\r\n        }\r\n\r\n        // Create the new trade and add its creationInfo to createdTrades, and emit an event.\r\n        // This provides a DAIHard interface two options to find all created trades:\r\n        // scan for NewTrade events or read the createdTrades array.\r\n        DAIHardNativeTrade newTrade = new DAIHardNativeTrade(founderFeeAddress, addressArgs[1]);\r\n        createdTrades.push(CreationInfo(address(newTrade), block.number));\r\n        emit NewTrade(createdTrades.length - 1, address(newTrade), addressArgs[0]);\r\n\r\n        // transfer value to the trade and open it\r\n        newTrade.beginInOpenPhase.value(msg.value)(addressArgs[0], initiatedByCustodian, newUintArgs, terms, _commPubkey);\r\n\r\n        return newTrade;\r\n    }\r\n\r\n    /*\r\n    Array layouts for createCommittedTrade:\r\n\r\n    uintArgs:\r\n    0 - tradeAmount\r\n    1 - beneficiaryDeposit\r\n    2 - abortPunishment\r\n    3 - pokeReward\r\n    4 - autoabortInterval\r\n    5 - autoreleaseInterval\r\n    6 - devFee\r\n\r\n    addressArgs:\r\n    0 - custodian\r\n    1 - beneficiary\r\n    2 - devFeeAddress\r\n    */\r\n\r\n    function createCommittedTrade(address payable[3] calldata addressArgs,\r\n                                  bool initiatedByCustodian,\r\n                                  uint[7] calldata uintArgs,\r\n                                  string calldata _terms,\r\n                                  string calldata _initiatorCommPubkey,\r\n                                  string calldata _responderCommPubkey\r\n                                  )\r\n    external\r\n    payable\r\n    returns (DAIHardNativeTrade) {\r\n        //require: msg.value == tradeAmount + beneficiaryDeposit + pokeReward + getFounderFee(tradeAmount) + devFee\r\n        require(msg.value == uintArgs[0].add(uintArgs[1]).add(uintArgs[3]).add(getFounderFee(uintArgs[0]).add(uintArgs[6])),\r\n                \"You didn't include the correct amount of value!\"\r\n                );\r\n\r\n        uint[7] memory newUintArgs = [uintArgs[1], uintArgs[2], uintArgs[3], uintArgs[4], uintArgs[5], getFounderFee(uintArgs[0]), uintArgs[6]];\r\n        // see uintArgs comment above DAIHardNativeTrade.beginInCommittedPhase\r\n\r\n        DAIHardNativeTrade newTrade = new DAIHardNativeTrade(founderFeeAddress, addressArgs[2]);\r\n        createdTrades.push(CreationInfo(address(newTrade), block.number));\r\n\r\n        if (initiatedByCustodian) {\r\n            emit NewTrade(createdTrades.length - 1, address(newTrade), addressArgs[0]);\r\n        }\r\n        else {\r\n            emit NewTrade(createdTrades.length - 1, address(newTrade), addressArgs[1]);\r\n        }\r\n\r\n        newTrade.beginInCommittedPhase.value(msg.value)(addressArgs[0],\r\n                                                        addressArgs[1],\r\n                                                        initiatedByCustodian,\r\n                                                        newUintArgs,\r\n                                                        _terms,\r\n                                                        _initiatorCommPubkey,\r\n                                                        _responderCommPubkey\r\n                                                        );\r\n\r\n        return newTrade;\r\n    }\r\n\r\n    function numTrades()\r\n    external\r\n    view\r\n    returns (uint num) {\r\n        return createdTrades.length;\r\n    }\r\n}\r\n\r\ncontract DAIHardNativeTrade {\r\n    using SafeMath for uint;\r\n\r\n    enum Phase {Creating, Open, Committed, Judgment, Closed}\r\n    Phase public phase;\r\n\r\n    modifier inPhase(Phase p) {\r\n        require(phase == p, \"inPhase check failed.\");\r\n        _;\r\n    }\r\n\r\n    enum ClosedReason {NotClosed, Recalled, Aborted, Released, Burned}\r\n    ClosedReason public closedReason;\r\n\r\n    uint[5] public phaseStartTimestamps;\r\n    uint[5] public phaseStartBlocknums;\r\n\r\n    function changePhase(Phase p)\r\n    internal {\r\n        phase = p;\r\n        phaseStartTimestamps[uint(p)] = block.timestamp;\r\n        phaseStartBlocknums[uint(p)] = block.number;\r\n    }\r\n\r\n    address payable public initiator;\r\n    address payable public responder;\r\n\r\n    // The contract only has two parties, but depending on how it's opened,\r\n    // the initiator for example might be either the custodian OR the beneficiary,\r\n    // so we need four 'role' variables to capture each possible combination.\r\n\r\n    bool public initiatedByCustodian;\r\n    address payable public custodian;\r\n    address payable public beneficiary;\r\n\r\n    modifier onlyInitiator() {\r\n        require(msg.sender == initiator, \"msg.sender is not Initiator.\");\r\n        _;\r\n    }\r\n    modifier onlyResponder() {\r\n        require(msg.sender == responder, \"msg.sender is not Responder.\");\r\n        _;\r\n    }\r\n    modifier onlyCustodian() {\r\n        require (msg.sender == custodian, \"msg.sender is not Custodian.\");\r\n        _;\r\n    }\r\n    modifier onlyBeneficiary() {\r\n        require (msg.sender == beneficiary, \"msg.sender is not Beneficiary.\");\r\n        _;\r\n    }\r\n    modifier onlyContractParty() { // Must be one of the two parties involved in the contract\r\n        // Note this still covers the case in which responder still is 0x0, as msg.sender can never be 0x0,\r\n        // in which case this will revert if msg.sender != initiator.\r\n        require(msg.sender == initiator || msg.sender == responder, \"msg.sender is not a party in this contract.\");\r\n        _;\r\n    }\r\n\r\n    address payable public founderFeeAddress;\r\n    address payable public devFeeAddress;\r\n\r\n    bool public pokeRewardGranted;\r\n\r\n    constructor(address payable _founderFeeAddress, address payable _devFeeAddress)\r\n    public {\r\n        // If gas was not an issue we would leave the next three lines in for explicit clarity,\r\n        // but technically they are a waste of gas, because we're simply setting them to the null values\r\n        // (which happens automatically anyway when the contract is instantiated)\r\n\r\n        // changePhase(Phase.Creating);\r\n        // closedReason = ClosedReason.NotClosed;\r\n        // pokeRewardGranted = false;\r\n\r\n        founderFeeAddress = _founderFeeAddress;\r\n        devFeeAddress = _devFeeAddress;\r\n    }\r\n\r\n    uint public tradeAmount;\r\n    uint public beneficiaryDeposit;\r\n    uint public abortPunishment;\r\n\r\n    uint public autorecallInterval;\r\n    uint public autoabortInterval;\r\n    uint public autoreleaseInterval;\r\n\r\n    uint public pokeReward;\r\n    uint public founderFee;\r\n    uint public devFee;\r\n\r\n    /* ---------------------- CREATING PHASE -----------------------\r\n\r\n    The only reason for this phase is so the Factory can have somewhere\r\n    to send the value before the Trade is truly initiated in the Opened phase.\r\n    We maintain this vestigial remnant from the ERC20 version of DAIHard,\r\n    to help avoid Solidity stack depth errors.\r\n\r\n    The Factory creates the DAIHardNativeTrade and moves it past this state in a single call,\r\n    so any DAIHardNativeTrade made by the factory should never be \"seen\" in this state\r\n    (the DH interface ignores trades not created by the Factory contract).\r\n\r\n    ------------------------------------------------------------ */\r\n\r\n    event Initiated(string terms, string commPubkey);\r\n\r\n    /*\r\n    uintArgs:\r\n    0 - responderDeposit\r\n    1 - abortPunishment\r\n    2 - pokeReward\r\n    3 - autorecallInterval\r\n    4 - autoabortInterval\r\n    5 - autoreleaseInterval\r\n    6 - founderFee\r\n    7 - devFee\r\n    */\r\n\r\n    function beginInOpenPhase(address payable _initiator,\r\n                              bool _initiatedByCustodian,\r\n                              uint[8] calldata uintArgs,\r\n                              string calldata terms,\r\n                              string calldata commPubkey\r\n                              )\r\n    external\r\n    payable\r\n    inPhase(Phase.Creating)\r\n    /* any msg.sender */ {\r\n        uint startingBalance = msg.value;\r\n\r\n        uint responderDeposit = uintArgs[0];\r\n        abortPunishment = uintArgs[1];\r\n        pokeReward = uintArgs[2];\r\n\r\n        autorecallInterval = uintArgs[3];\r\n        autoabortInterval = uintArgs[4];\r\n        autoreleaseInterval = uintArgs[5];\r\n\r\n        founderFee = uintArgs[6];\r\n        devFee = uintArgs[7];\r\n\r\n        require(_initiator != address(0x0), \"0x0 is an invalid initiator address!\");\r\n        initiator = _initiator;\r\n        initiatedByCustodian = _initiatedByCustodian;\r\n\r\n        if (initiatedByCustodian) {\r\n            custodian = initiator;\r\n            tradeAmount = startingBalance.sub(pokeReward.add(founderFee).add(devFee));\r\n            beneficiaryDeposit = responderDeposit;\r\n        }\r\n        else {\r\n            beneficiary = initiator;\r\n            tradeAmount = responderDeposit;\r\n            beneficiaryDeposit = startingBalance.sub(pokeReward.add(founderFee).add(devFee));\r\n        }\r\n\r\n        require(beneficiaryDeposit <= tradeAmount, \"A beneficiaryDeposit greater than tradeAmount is not allowed.\");\r\n        require(abortPunishment <= beneficiaryDeposit, \"An abortPunishment greater than beneficiaryDeposit is not allowed.\");\r\n\r\n        changePhase(Phase.Open);\r\n        emit Initiated(terms, commPubkey);\r\n    }\r\n\r\n    /*\r\n    uintArgs:\r\n    0 - beneficiaryDeposit\r\n    1 - abortPunishment\r\n    2 - pokeReward\r\n    3 - autoabortInterval\r\n    4 - autoreleaseInterval\r\n    5 - founderFee\r\n    6 - devFee\r\n    */\r\n\r\n    function beginInCommittedPhase(address payable _custodian,\r\n                                   address payable _beneficiary,\r\n                                   bool _initiatedByCustodian,\r\n                                   uint[7] calldata uintArgs,\r\n                                   string calldata terms,\r\n                                   string calldata initiatorCommPubkey,\r\n                                   string calldata responderCommPubkey\r\n                                   )\r\n    external\r\n    payable\r\n    inPhase(Phase.Creating)\r\n    /* any msg.sender */{\r\n        uint startingBalance = msg.value;\r\n\r\n        beneficiaryDeposit = uintArgs[0];\r\n        abortPunishment = uintArgs[1];\r\n        pokeReward = uintArgs[2];\r\n\r\n        autoabortInterval = uintArgs[3];\r\n        autoreleaseInterval = uintArgs[4];\r\n\r\n        founderFee = uintArgs[5];\r\n        devFee = uintArgs[6];\r\n\r\n        require(_custodian != address(0x0), \"0x0 is an invalid custodian address!\");\r\n        require(_beneficiary != address(0x0), \"0x0 is an invalid beneficiary address!\");\r\n        custodian = _custodian;\r\n        beneficiary = _beneficiary;\r\n        initiatedByCustodian = _initiatedByCustodian;\r\n\r\n        if (initiatedByCustodian) {\r\n            initiator = custodian;\r\n            responder = beneficiary;\r\n        }\r\n        else {\r\n            initiator = beneficiary;\r\n            responder = custodian;\r\n        }\r\n\r\n        tradeAmount = startingBalance.sub(beneficiaryDeposit.add(pokeReward).add(founderFee).add(devFee));\r\n\r\n        require(beneficiaryDeposit <= tradeAmount, \"A beneficiaryDeposit greater than tradeAmount is not allowed.\");\r\n        require(abortPunishment <= beneficiaryDeposit, \"An abortPunishment greater than beneficiaryDeposit is not allowed.\");\r\n\r\n        changePhase(Phase.Committed);\r\n\r\n        emit Initiated(terms, initiatorCommPubkey);\r\n        emit Committed(responder, responderCommPubkey);\r\n    }\r\n\r\n    /* ---------------------- OPEN PHASE --------------------------\r\n\r\n    In the Open phase, the Initiator (who may be the Custodian or the Beneficiary)\r\n    waits for a Responder (who will claim the remaining role).\r\n    We move to the Commited phase once someone becomes the Responder by executing commit(),\r\n    which requires a successful withdraw of tokens from msg.sender of getResponderDeposit\r\n    (either tradeAmount or beneficiaryDeposit, depending on the role of the responder).\r\n\r\n    At any time in this phase, the Initiator can cancel the whole thing by calling recall().\r\n    This returns the trade's entire balance including fees to the Initiator.\r\n\r\n    After autorecallInterval has passed, the only state change allowed is to recall,\r\n    which at that point can be triggered by anyone via poke().\r\n\r\n    ------------------------------------------------------------ */\r\n\r\n    event Recalled();\r\n    event Committed(address responder, string commPubkey);\r\n\r\n    function recall()\r\n    external\r\n    inPhase(Phase.Open)\r\n    onlyInitiator() {\r\n       _recall();\r\n    }\r\n\r\n    function _recall()\r\n    internal {\r\n        changePhase(Phase.Closed);\r\n        closedReason = ClosedReason.Recalled;\r\n\r\n        emit Recalled();\r\n\r\n        initiator.transfer(getBalance());\r\n        // Note that this will also return the founderFee and devFee to the intiator,\r\n        // as well as the pokeReward if it hasn't yet been sent.\r\n    }\r\n\r\n    function autorecallAvailable()\r\n    public\r\n    view\r\n    inPhase(Phase.Open)\r\n    returns(bool available) {\r\n        return (block.timestamp >= phaseStartTimestamps[uint(Phase.Open)].add(autorecallInterval));\r\n    }\r\n\r\n    function commit(address payable _responder, string calldata commPubkey)\r\n    external\r\n    payable\r\n    inPhase(Phase.Open)\r\n    /* any msg.sender */ {\r\n        require(!autorecallAvailable(), \"autorecallInterval has passed; this offer has expired.\");\r\n\r\n        require(msg.value == getResponderDeposit(), \"You didn't include enough value!\");\r\n\r\n        require(_responder != address(0x0), \"0x0 is an invalid responder address!\");\r\n        responder = _responder;\r\n\r\n        if (initiatedByCustodian) {\r\n            beneficiary = responder;\r\n        }\r\n        else {\r\n            custodian = responder;\r\n        }\r\n\r\n        changePhase(Phase.Committed);\r\n        emit Committed(responder, commPubkey);\r\n    }\r\n\r\n    /* ---------------------- COMMITTED PHASE ---------------------\r\n\r\n    In the Committed phase, the Beneficiary is expected to deliver fiat to the Custodian,\r\n    then call claim().\r\n\r\n    Otherwise, the Beneficiary can call abort(), which cancels the contract,\r\n    incurs a small penalty on both parties, and returns the remainder to each party.\r\n\r\n    After autoabortInterval has passed, the only state change allowed is to abort,\r\n    which can be triggered by anyone via poke().\r\n\r\n    ------------------------------------------------------------ */\r\n\r\n    event Claimed();\r\n    event Aborted();\r\n\r\n    function abort()\r\n    external\r\n    inPhase(Phase.Committed)\r\n    onlyBeneficiary() {\r\n        _abort();\r\n    }\r\n\r\n    function _abort()\r\n    internal {\r\n        changePhase(Phase.Closed);\r\n        closedReason = ClosedReason.Aborted;\r\n\r\n        emit Aborted();\r\n\r\n        // Punish both parties equally by burning abortPunishment.\r\n        // Instead of burning abortPunishment twice, just burn it all in one call (saves gas).\r\n        address(0x0).transfer(abortPunishment*2);\r\n        // Security note: The above line risks overflow, but only if abortPunishment >= (maxUint/2).\r\n        // This should never happen, as abortPunishment <= beneficiaryDeposit <= tradeAmount (as required in both beginIn*Phase functions),\r\n        // which is ultimately limited by the amount the user deposited (which must be far less than maxUint/2).\r\n        // See the note below about avoiding assert() or require() to test this.\r\n\r\n        // Send back deposits minus burned amounts.\r\n        // We use send rather than transfer here, to avoid blocking the function's execution due to one party's failed transfer.\r\n        beneficiary.send(beneficiaryDeposit.sub(abortPunishment));\r\n        custodian.send(tradeAmount.sub(abortPunishment));\r\n\r\n        // Refund everything left over to the initiator\r\n        // This includes the founderFee, devFee, and any pokeReward left.\r\n        initiator.send(getBalance());\r\n    }\r\n\r\n    function autoabortAvailable()\r\n    public\r\n    view\r\n    inPhase(Phase.Committed)\r\n    returns(bool passed) {\r\n        return (block.timestamp >= phaseStartTimestamps[uint(Phase.Committed)].add(autoabortInterval));\r\n    }\r\n\r\n    function claim()\r\n    external\r\n    inPhase(Phase.Committed)\r\n    onlyBeneficiary() {\r\n        require(!autoabortAvailable(), \"The deposit deadline has passed!\");\r\n\r\n        changePhase(Phase.Judgment);\r\n        emit Claimed();\r\n    }\r\n\r\n    /* ---------------------- CLAIMED PHASE -----------------------\r\n\r\n    In the Judgment phase, the Custodian can call release() or burn(),\r\n    and is expected to call burn() only if the Beneficiary did meet the terms\r\n    described in the 'terms' value logged with the Initiated event.\r\n\r\n    After autoreleaseInterval has passed, the only state change allowed is to release,\r\n    which can be triggered by anyone via poke().\r\n\r\n    In the case of a burn, all fees are burned as well.\r\n\r\n    ------------------------------------------------------------ */\r\n\r\n    event Released();\r\n    event Burned();\r\n\r\n    function release()\r\n    external\r\n    inPhase(Phase.Judgment)\r\n    onlyCustodian() {\r\n        _release();\r\n    }\r\n\r\n    function _release()\r\n    internal {\r\n        changePhase(Phase.Closed);\r\n        closedReason = ClosedReason.Released;\r\n\r\n        emit Released();\r\n\r\n        // We use send rather than transfer here, to avoid blocking the function's execution due to one party's failed transfer.\r\n        //If the pokeReward has not been sent, refund it to the initiator\r\n        if (!pokeRewardGranted) {\r\n            initiator.send(pokeReward);\r\n        }\r\n\r\n        // Upon successful resolution of trade, the founderFee is sent to the founders of DAIHard,\r\n        // and the devFee is sent to wherever the original Factory creation call specified.\r\n        founderFeeAddress.send(founderFee);\r\n        devFeeAddress.send(devFee);\r\n\r\n        //Release the remaining balance to the beneficiary.\r\n        beneficiary.send(getBalance());\r\n    }\r\n\r\n    function autoreleaseAvailable()\r\n    public\r\n    view\r\n    inPhase(Phase.Judgment)\r\n    returns(bool available) {\r\n        return (block.timestamp >= phaseStartTimestamps[uint(Phase.Judgment)].add(autoreleaseInterval));\r\n    }\r\n\r\n    function burn()\r\n    external\r\n    inPhase(Phase.Judgment)\r\n    onlyCustodian() {\r\n        require(!autoreleaseAvailable(), \"autorelease has passed; you can no longer call burn.\");\r\n\r\n        internalBurn();\r\n    }\r\n\r\n    function internalBurn()\r\n    internal {\r\n        changePhase(Phase.Closed);\r\n        closedReason = ClosedReason.Burned;\r\n\r\n        emit Burned();\r\n\r\n        address(0x0).transfer(getBalance());\r\n        // Note that this also burns founderFee and devFee.\r\n    }\r\n\r\n    /* ---------------------- ANY-PHASE METHODS ----------------------- */\r\n\r\n    /*\r\n    If the contract is due for some auto___ phase transition,\r\n    anyone can call the poke() function to trigger this transition,\r\n    and the caller will be rewarded with pokeReward.\r\n    */\r\n\r\n    event Poke();\r\n\r\n    function pokeNeeded()\r\n    external\r\n    view\r\n    /* any phase */\r\n    /* any msg.sender */\r\n    returns (bool needed) {\r\n        return (  (phase == Phase.Open      && autorecallAvailable() )\r\n               || (phase == Phase.Committed && autoabortAvailable()  )\r\n               || (phase == Phase.Judgment  && autoreleaseAvailable())\r\n               );\r\n    }\r\n\r\n    function grantPokeRewardToSender()\r\n    internal {\r\n        require(!pokeRewardGranted, \"The poke reward has already been sent!\"); // Extra protection against re-entrancy\r\n        pokeRewardGranted = true;\r\n        msg.sender.transfer(pokeReward);\r\n    }\r\n\r\n    function poke()\r\n    external\r\n    /* any phase */\r\n    /* any msg.sender */\r\n    returns (bool moved) {\r\n        if (phase == Phase.Open && autorecallAvailable()) {\r\n            grantPokeRewardToSender();\r\n            emit Poke();\r\n\r\n            _recall();\r\n            return true;\r\n        }\r\n        else if (phase == Phase.Committed && autoabortAvailable()) {\r\n            grantPokeRewardToSender();\r\n            emit Poke();\r\n\r\n            _abort();\r\n            return true;\r\n        }\r\n        else if (phase == Phase.Judgment && autoreleaseAvailable()) {\r\n            grantPokeRewardToSender();\r\n            emit Poke();\r\n\r\n            _release();\r\n            return true;\r\n        }\r\n        else return false;\r\n    }\r\n\r\n    /*\r\n    StatementLogs allow a starting point for any necessary communication,\r\n    and can be used anytime (even in the Closed phase).\r\n    */\r\n\r\n    event InitiatorStatementLog(string statement);\r\n    event ResponderStatementLog(string statement);\r\n\r\n    function initiatorStatement(string calldata statement)\r\n    external\r\n    /* any phase */\r\n    onlyInitiator() {\r\n        emit InitiatorStatementLog(statement);\r\n    }\r\n\r\n    function responderStatement(string calldata statement)\r\n    external\r\n    /* any phase */\r\n    onlyResponder() {\r\n        emit ResponderStatementLog(statement);\r\n    }\r\n\r\n    /* ---------------------- ANY-PHASE GETTERS ----------------------- */\r\n\r\n    function getResponderDeposit()\r\n    public\r\n    view\r\n    /* any phase */\r\n    /* any msg.sender */\r\n    returns(uint responderDeposit) {\r\n        if (initiatedByCustodian) {\r\n            return beneficiaryDeposit;\r\n        }\r\n        else {\r\n            return tradeAmount;\r\n        }\r\n    }\r\n\r\n    function getState()\r\n    external\r\n    view\r\n    /* any phase */\r\n    /* any msg.sender */\r\n    returns(uint balance, Phase phase, uint phaseStartTimestamp, address responder, ClosedReason closedReason) {\r\n        return (getBalance(), this.phase(), phaseStartTimestamps[uint(this.phase())], this.responder(), this.closedReason());\r\n    }\r\n\r\n    function getBalance()\r\n    public\r\n    view\r\n    /* any phase */\r\n    /* any msg.sender */\r\n    returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getParameters()\r\n    external\r\n    view\r\n    /* any phase */\r\n    /* any msg.sender */\r\n    returns (address initiator,\r\n             bool initiatedByCustodian,\r\n             uint tradeAmount,\r\n             uint beneficiaryDeposit,\r\n             uint abortPunishment,\r\n             uint autorecallInterval,\r\n             uint autoabortInterval,\r\n             uint autoreleaseInterval,\r\n             uint pokeReward\r\n             )\r\n    {\r\n        return (this.initiator(),\r\n                this.initiatedByCustodian(),\r\n                this.tradeAmount(),\r\n                this.beneficiaryDeposit(),\r\n                this.abortPunishment(),\r\n                this.autorecallInterval(),\r\n                this.autoabortInterval(),\r\n                this.autoreleaseInterval(),\r\n                this.pokeReward()\r\n                );\r\n    }\r\n\r\n    function getPhaseStartInfo()\r\n    external\r\n    view\r\n    /* any phase */\r\n    /* any msg.sender */\r\n    returns (uint, uint, uint, uint, uint, uint, uint, uint, uint, uint)\r\n    {\r\n        return (phaseStartBlocknums[0],\r\n                phaseStartBlocknums[1],\r\n                phaseStartBlocknums[2],\r\n                phaseStartBlocknums[3],\r\n                phaseStartBlocknums[4],\r\n                phaseStartTimestamps[0],\r\n                phaseStartTimestamps[1],\r\n                phaseStartTimestamps[2],\r\n                phaseStartTimestamps[3],\r\n                phaseStartTimestamps[4]\r\n                );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"founderFeeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addressArgs\",\"type\":\"address[2]\"},{\"name\":\"initiatedByCustodian\",\"type\":\"bool\"},{\"name\":\"uintArgs\",\"type\":\"uint256[8]\"},{\"name\":\"terms\",\"type\":\"string\"},{\"name\":\"_commPubkey\",\"type\":\"string\"}],\"name\":\"createOpenTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addressArgs\",\"type\":\"address[3]\"},{\"name\":\"initiatedByCustodian\",\"type\":\"bool\"},{\"name\":\"uintArgs\",\"type\":\"uint256[7]\"},{\"name\":\"_terms\",\"type\":\"string\"},{\"name\":\"_initiatorCommPubkey\",\"type\":\"string\"},{\"name\":\"_responderCommPubkey\",\"type\":\"string\"}],\"name\":\"createCommittedTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tradeAmount\",\"type\":\"uint256\"}],\"name\":\"getFounderFee\",\"outputs\":[{\"name\":\"founderFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numTrades\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"createdTrades\",\"outputs\":[{\"name\":\"address_\",\"type\":\"address\"},{\"name\":\"blocknum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_founderFeeAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tradeAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"NewTrade\",\"type\":\"event\"}]","ContractName":"DAIHardNativeFactory","CompilerVersion":"v0.5.6+commit.b259423e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000061f399ed1d5aec3bc9d4b026352d5764181d6b35","Library":"","SwarmSource":"bzzr://38f3d92f79b280772fc42f4d582cf84e065c6ca3afb687cde8507498e11785bd"}]}