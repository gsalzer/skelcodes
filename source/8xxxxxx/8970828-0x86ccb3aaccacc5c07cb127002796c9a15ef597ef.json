{"status":"1","message":"OK","result":[{"SourceCode":"\n// File: contracts/interfaces/SyscoinSuperblocksI.sol\n\npragma solidity ^0.5.13;\n\ninterface SyscoinSuperblocksI {\n\n    // @dev - Superblock status\n    enum Status { Uninitialized, New, InBattle, SemiApproved, Approved, Invalid }\n    struct SuperblockInfo {\n        bytes32 blocksMerkleRoot;\n        uint timestamp;\n        uint mtpTimestamp;\n        bytes32 lastHash;\n        bytes32 parentId;\n        address submitter;\n        uint32 lastBits;\n        uint32 height;\n        Status status;\n    }\n    function propose(\n        bytes32 _blocksMerkleRoot,\n        uint _timestamp,\n        uint _mtpTimestamp,\n        bytes32 _lastHash,\n        uint32 _lastBits,\n        bytes32 _parentId,\n        address submitter\n    ) external returns (uint, bytes32);\n\n    function getSuperblock(bytes32 superblockHash) external view returns (\n        bytes32 _blocksMerkleRoot,\n        uint _timestamp,\n        uint _mtpTimestamp,\n        bytes32 _lastHash,\n        uint32 _lastBits,\n        bytes32 _parentId,\n        address _submitter,\n        Status _status,\n        uint32 _height\n    );\n\n    function relayTx(\n        bytes calldata _txBytes,\n        uint _txIndex,\n        uint[] calldata _txSiblings,\n        bytes calldata _syscoinBlockHeader,\n        uint _syscoinBlockIndex,\n        uint[] calldata _syscoinBlockSiblings,\n        bytes32 _superblockHash\n    ) external returns (uint);\n\n    function confirm(bytes32 _superblockHash, address _validator) external returns (uint);\n    function challenge(bytes32 _superblockHash, address _challenger) external returns (uint);\n    function semiApprove(bytes32 _superblockHash, address _validator) external returns (uint);\n    function invalidate(bytes32 _superblockHash, address _validator) external returns (uint);\n    function getBestSuperblock() external view returns (bytes32);\n    function getChainHeight() external view returns (uint);\n    function getSuperblockHeight(bytes32 superblockHash) external view returns (uint32);\n    function getSuperblockParentId(bytes32 _superblockHash) external view returns (bytes32);\n    function getSuperblockStatus(bytes32 _superblockHash) external view returns (Status);\n    function getSuperblockAt(uint _height) external view returns (bytes32);\n    function getSuperblockTimestamp(bytes32 _superblockHash) external view returns (uint);\n    function getSuperblockMedianTimestamp(bytes32 _superblockHash) external view returns (uint);\n}\n\n// File: contracts/interfaces/SyscoinClaimManagerI.sol\n\npragma solidity ^0.5.13;\n\n\ninterface SyscoinClaimManagerI {\n    function bondDeposit(bytes32 superblockHash, address account, uint amount) external returns (uint);\n    function getDeposit(address account) external view returns (uint);\n    function checkClaimFinished(bytes32 superblockHash) external returns (bool);\n    function sessionDecided(bytes32 superblockHash, address winner, address loser) external;\n}\n\n// File: contracts/interfaces/SyscoinBattleManagerI.sol\n\npragma solidity ^0.5.13;\n\n// @dev - Manages a battle session between superblock submitter and challenger\ninterface SyscoinBattleManagerI {\n    // @dev - Start a battle session\n    function beginBattleSession(bytes32 superblockHash, address submitter, address challenger)\n        external;\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts/SyscoinDepositsManager.sol\n\npragma solidity ^0.5.13;\n\n\ncontract SyscoinDepositsManager {\n\n    using SafeMath for uint;\n\n    mapping(address => uint) public deposits;\n\n    event DepositMade(address who, uint amount);\n    event DepositWithdrawn(address who, uint amount);\n\n    // @dev – fallback to calling makeDeposit when ether is sent directly to contract.\n    function() external payable {\n        makeDeposit();\n    }\n\n    // @dev – returns an account's deposit\n    // @param who – the account's address.\n    // @return – the account's deposit.\n    function getDeposit(address who) external view returns (uint) {\n        return deposits[who];\n    }\n\n    // @dev – allows a user to deposit eth.\n    // @return – sender's updated deposit amount.\n    function makeDeposit() public payable returns (uint) {\n        increaseDeposit(msg.sender, msg.value);\n        return deposits[msg.sender];\n    }\n\n    // @dev – increases an account's deposit.\n    // @return – the given user's updated deposit amount.\n    function increaseDeposit(address who, uint amount) private {\n        deposits[who] = deposits[who].add(amount);\n        emit DepositMade(who, amount);\n    }\n\n    // @dev – allows a user to withdraw eth from their deposit.\n    // @param amount – how much eth to withdraw\n    // @return – sender's updated deposit amount.\n    function withdrawDeposit(uint amount) external returns (uint) {\n        require(deposits[msg.sender] >= amount);\n\n        deposits[msg.sender] = deposits[msg.sender].sub(amount);\n        msg.sender.transfer(amount);\n\n        emit DepositWithdrawn(msg.sender, amount);\n        return deposits[msg.sender];\n    }\n}\n\n// File: contracts/SyscoinErrorCodes.sol\n\npragma solidity ^0.5.13;\n\n// @dev - SyscoinSuperblocks error codes\ncontract SyscoinErrorCodes {\n    // Error codes\n    uint constant ERR_INVALID_HEADER = 10050;\n    uint constant ERR_COINBASE_INDEX = 10060; // coinbase tx index within Bitcoin merkle isn't 0\n    uint constant ERR_NOT_MERGE_MINED = 10070; // trying to check AuxPoW on a block that wasn't merge mined\n    uint constant ERR_FOUND_TWICE = 10080; // 0xfabe6d6d found twice\n    uint constant ERR_NO_MERGE_HEADER = 10090; // 0xfabe6d6d not found\n    uint constant ERR_CHAIN_MERKLE = 10110;\n    uint constant ERR_PARENT_MERKLE = 10120;\n    uint constant ERR_PROOF_OF_WORK = 10130;\n    uint constant ERR_INVALID_HEADER_HASH = 10140;\n    uint constant ERR_PROOF_OF_WORK_AUXPOW = 10150;\n    uint constant ERR_PARSE_TX_OUTPUT_LENGTH = 10160;\n\n\n    uint constant ERR_SUPERBLOCK_OK = 0;\n    uint constant ERR_SUPERBLOCK_MISSING_BLOCKS = 1;\n    uint constant ERR_SUPERBLOCK_BAD_STATUS = 50020;\n    uint constant ERR_SUPERBLOCK_BAD_SYSCOIN_STATUS = 50025;\n    uint constant ERR_SUPERBLOCK_TIMEOUT = 50026;\n    uint constant ERR_SUPERBLOCK_NO_TIMEOUT = 50030;\n    uint constant ERR_SUPERBLOCK_BAD_TIMESTAMP = 50035;\n    uint constant ERR_SUPERBLOCK_INVALID_TIMESTAMP = 50036;\n    uint constant ERR_SUPERBLOCK_INVALID_MERKLE = 50038;\n\n    // The error codes \"ERR_SUPERBLOCK_BAD_PARENT_*\" corresponds to ERR_SUPERBLOCK_BAD_PARENT + superblock.status\n    uint constant ERR_SUPERBLOCK_BAD_PARENT = 50040;\n    uint constant ERR_SUPERBLOCK_BAD_PARENT_UNINITIALIZED = 50040;\n    uint constant ERR_SUPERBLOCK_BAD_PARENT_NEW = 50041;\n    uint constant ERR_SUPERBLOCK_BAD_PARENT_INBATTLE = 50042;\n    uint constant ERR_SUPERBLOCK_BAD_PARENT_INVALID = 50045;\n\n    uint constant ERR_SUPERBLOCK_OWN_CHALLENGE = 50055;\n    uint constant ERR_SUPERBLOCK_BAD_PREV_TIMESTAMP = 50056;\n    uint constant ERR_SUPERBLOCK_BITS_SUPERBLOCK = 50057;\n    uint constant ERR_SUPERBLOCK_BITS_PREVBLOCK = 50058;\n    uint constant ERR_SUPERBLOCK_HASH_SUPERBLOCK = 50059;\n    uint constant ERR_SUPERBLOCK_HASH_PREVBLOCK = 50060;\n    uint constant ERR_SUPERBLOCK_HASH_PREVSUPERBLOCK = 50061;\n    uint constant ERR_SUPERBLOCK_BITS_LASTBLOCK = 50064;\n    uint constant ERR_SUPERBLOCK_MIN_DEPOSIT = 50065;\n    uint constant ERR_SUPERBLOCK_BITS_INTERIM_PREVBLOCK = 50066;\n    uint constant ERR_SUPERBLOCK_HASH_INTERIM_PREVBLOCK = 50067;\n    uint constant ERR_SUPERBLOCK_BAD_TIMESTAMP_AVERAGE = 50068;\n    uint constant ERR_SUPERBLOCK_BAD_TIMESTAMP_MTP = 50069;\n\n    uint constant ERR_SUPERBLOCK_NOT_CLAIMMANAGER = 50070;\n    uint constant ERR_SUPERBLOCK_MISMATCH_TIMESTAMP_MTP = 50071;\n    uint constant ERR_SUPERBLOCK_TOOSMALL_TIMESTAMP_MTP = 50072;\n\n    uint constant ERR_SUPERBLOCK_BAD_CLAIM = 50080;\n    uint constant ERR_SUPERBLOCK_VERIFICATION_PENDING = 50090;\n    uint constant ERR_SUPERBLOCK_CLAIM_DECIDED = 50100;\n    uint constant ERR_SUPERBLOCK_CHALLENGE_EXISTS = 50110;\n\n    uint constant ERR_SUPERBLOCK_BAD_ACCUMULATED_WORK = 50120;\n    uint constant ERR_SUPERBLOCK_BAD_BITS = 50130;\n    uint constant ERR_SUPERBLOCK_MISSING_CONFIRMATIONS = 50140;\n    uint constant ERR_SUPERBLOCK_BAD_LASTBLOCK = 50150;\n    uint constant ERR_SUPERBLOCK_BAD_LASTBLOCK_STATUS = 50160;\n    uint constant ERR_SUPERBLOCK_BAD_BLOCKHEIGHT = 50170;\n    uint constant ERR_SUPERBLOCK_BAD_PREVBLOCK = 50190;\n    uint constant ERR_SUPERBLOCK_BAD_MISMATCH = 50210;\n    uint constant ERR_SUPERBLOCK_INTERIMBLOCK_MISSING = 50220;\n    uint constant ERR_SUPERBLOCK_BAD_INTERIM_PREVHASH = 50230;\n    uint constant ERR_SUPERBLOCK_BAD_INTERIM_BLOCKINDEX = 50240;\n\n\n    // error codes for verifyTx\n    uint constant ERR_BAD_FEE = 20010;\n    uint constant ERR_CONFIRMATIONS = 20020;\n    uint constant ERR_CHAIN = 20030;\n    uint constant ERR_SUPERBLOCK = 20040;\n    uint constant ERR_MERKLE_ROOT = 20050;\n    uint constant ERR_TX_64BYTE = 20060;\n    // error codes for relayTx\n    uint constant ERR_RELAY_VERIFY = 30010;\n    uint constant public minProposalDeposit = 3000000000000000000;\n}\n\n// File: @openzeppelin/upgrades/contracts/Initializable.sol\n\npragma solidity >=0.4.24 <0.6.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: contracts/SyscoinClaimManager.sol\n\npragma solidity ^0.5.13;\n\n\n\n\n\n\n\n\n// @dev - Manager of superblock claims\n//\n// Manages superblocks proposal and challenges\ncontract SyscoinClaimManager is Initializable, SyscoinDepositsManager, SyscoinErrorCodes {\n\n    using SafeMath for uint;\n\n    uint constant MAX_FUTURE_BLOCK_TIME_SYSCOIN = 7200;\n    uint constant MAX_FUTURE_BLOCK_TIME_ETHEREUM = 15;\n\n    struct SuperblockClaim {\n        bytes32 superblockHash;                       // Superblock Id\n        address submitter;                           // Superblock submitter\n        address challenger;                         // Superblock challenger\n        uint createdAt;                             // Superblock creation time\n\n        mapping (address => uint) bondedDeposits;   // Deposit associated to submitter+challenger\n\n        uint challengeTimeout;                      // Claim timeout\n\n        bool verificationOngoing;                   // Challenge session has started\n\n        bool decided;                               // If the claim was decided\n        bool invalid;                               // If superblock is invalid\n    }\n\n    // Active superblock claims\n    mapping (bytes32 => SuperblockClaim) public claims;\n\n    // Superblocks contract\n    SyscoinSuperblocksI public trustedSuperblocks;\n\n    // Battle manager contract\n    SyscoinBattleManagerI public trustedSyscoinBattleManager;\n\n    // Confirmations required to confirm semi approved superblocks\n    uint public superblockConfirmations;\n\n    uint public superblockDelay;    // Delay required to submit superblocks (in seconds)\n    uint public superblockTimeout;  // Timeout for action (in seconds)\n\n    event DepositBonded(bytes32 superblockHash, address account, uint amount);\n    event DepositUnbonded(bytes32 superblockHash, address account, uint amount);\n    event SuperblockClaimCreated(bytes32 superblockHash, address submitter);\n    event SuperblockClaimChallenged(bytes32 superblockHash, address challenger);\n    event SuperblockBattleDecided(bytes32 superblockHash, address winner, address loser);\n    event SuperblockClaimSuccessful(bytes32 superblockHash, address submitter);\n    event SuperblockClaimPending(bytes32 superblockHash, address submitter);\n    event SuperblockClaimFailed(bytes32 superblockHash, address submitter);\n    event VerificationGameStarted(bytes32 superblockHash, address submitter, address challenger);\n\n    event ErrorClaim(bytes32 superblockHash, uint err);\n\n    modifier onlyBattleManager() {\n        require(msg.sender == address(trustedSyscoinBattleManager));\n        _;\n    }\n\n    modifier onlyMeOrBattleManager() {\n        require(msg.sender == address(trustedSyscoinBattleManager) || msg.sender == address(this));\n        _;\n    }\n\n    // @dev – Sets up the contract managing superblock challenges\n    // @param _superblocks Contract that manages superblocks\n    // @param _battleManager Contract that manages battles\n    // @param _superblockDelay Delay to accept a superblock submission (in seconds)\n    // @param _superblockTimeout Time to wait for challenges (in seconds)\n    // @param _superblockConfirmations Confirmations required to confirm semi approved superblocks\n    function init(\n        SyscoinSuperblocksI _superblocks,\n        SyscoinBattleManagerI _syscoinBattleManager,\n        uint _superblockDelay,\n        uint _superblockTimeout,\n        uint _superblockConfirmations\n    ) public initializer {\n        trustedSuperblocks = _superblocks;\n        trustedSyscoinBattleManager = _syscoinBattleManager;\n        superblockDelay = _superblockDelay;\n        superblockTimeout = _superblockTimeout;\n        superblockConfirmations = _superblockConfirmations;\n    }\n\n    // @dev – locks up part of a user's deposit into a claim.\n    // @param superblockHash – claim id.\n    // @param account – user's address.\n    // @param amount – amount of deposit to lock up.\n    // @return – user's deposit bonded for the claim.\n    function bondDeposit(bytes32 superblockHash, address account, uint amount) external onlyMeOrBattleManager returns (uint) {\n        SuperblockClaim storage claim = claims[superblockHash];\n\n        if (!claimExists(claim)) {\n            return ERR_SUPERBLOCK_BAD_CLAIM;\n        }\n\n        if (deposits[account] < amount) {\n            return ERR_SUPERBLOCK_MIN_DEPOSIT;\n        }\n\n        deposits[account] = deposits[account].sub(amount);\n        claim.bondedDeposits[account] = claim.bondedDeposits[account].add(amount);\n        emit DepositBonded(superblockHash, account, amount);\n\n        return ERR_SUPERBLOCK_OK;\n    }\n\n    // @dev – accessor for a claim's bonded deposits.\n    // @param superblockHash – claim id.\n    // @param account – user's address.\n    // @return – user's deposit bonded for the claim.\n    function getBondedDeposit(bytes32 superblockHash, address account) external view returns (uint) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        require(claimExists(claim));\n        return claim.bondedDeposits[account];\n    }\n\n    // @dev – unlocks a user's bonded deposits from a claim.\n    // @param superblockHash – claim id.\n    // @param account – user's address.\n    // @return – user's deposit which was unbonded from the claim.\n    function unbondDeposit(bytes32 superblockHash, address account) private returns (uint, uint) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        if (!claimExists(claim)) {\n            return (ERR_SUPERBLOCK_BAD_CLAIM, 0);\n        }\n        if (!claim.decided) {\n            return (ERR_SUPERBLOCK_BAD_STATUS, 0);\n        }\n\n        uint bondedDeposit = claim.bondedDeposits[account];\n\n        delete claim.bondedDeposits[account];\n        deposits[account] = deposits[account].add(bondedDeposit);\n\n        emit DepositUnbonded(superblockHash, account, bondedDeposit);\n\n        return (ERR_SUPERBLOCK_OK, bondedDeposit);\n    }\n\n    // @dev – Propose a new superblock.\n    //\n    // @param _blocksMerkleRoot Root of the merkle tree of blocks contained in a superblock\n    // @param _timestamp Timestamp of the last block in the superblock\n    // @param _mtpTimestamp Median Timestamp of the last block in the superblock\n    // @param _lastHash Hash of the last block in the superblock\n    // @param _lastBits Difficulty bits of the last block in the superblock bits\n    // @param _parentHash Id of the parent superblock\n    // @return Error code and superblockHash\n    function proposeSuperblock(\n        bytes32 _blocksMerkleRoot,\n        uint _timestamp,\n        uint _mtpTimestamp,\n        bytes32 _lastHash,\n        uint32 _lastBits,\n        bytes32 _parentHash\n    ) external returns (uint, bytes32) {\n        require(address(trustedSuperblocks) != address(0));\n\n        if (deposits[msg.sender] < minProposalDeposit) {\n            emit ErrorClaim(0, ERR_SUPERBLOCK_MIN_DEPOSIT);\n            return (ERR_SUPERBLOCK_MIN_DEPOSIT, 0);\n        }\n\n        if (_mtpTimestamp + superblockDelay > block.timestamp) {\n            emit ErrorClaim(0, ERR_SUPERBLOCK_BAD_TIMESTAMP_MTP);\n            return (ERR_SUPERBLOCK_BAD_TIMESTAMP_MTP, 0);\n        }\n\n        if (block.timestamp + MAX_FUTURE_BLOCK_TIME_SYSCOIN + MAX_FUTURE_BLOCK_TIME_ETHEREUM <= _timestamp) {\n            emit ErrorClaim(0, ERR_SUPERBLOCK_BAD_TIMESTAMP);\n            return (ERR_SUPERBLOCK_BAD_TIMESTAMP, 0);\n        }\n\n        uint err;\n        bytes32 superblockHash;\n        (err, superblockHash) = trustedSuperblocks.propose(_blocksMerkleRoot, _timestamp, _mtpTimestamp, _lastHash, _lastBits, _parentHash, msg.sender);\n        if (err != 0) {\n            emit ErrorClaim(superblockHash, err);\n            return (err, superblockHash);\n        }\n\n\n        SuperblockClaim storage claim = claims[superblockHash];\n        // allow to propose an existing claim only if its invalid and decided and its a different submitter or not on the tip\n        // those are the ones that may actually be stuck and need to be proposed again,\n        // but we want to ensure its not the same submitter submitting the same thing\n        if (claimExists(claim)) {\n            require(claim.invalid == true && claim.decided == true && claim.submitter != msg.sender);\n        }\n\n        claim.superblockHash = superblockHash;\n        claim.submitter = msg.sender;\n        claim.challenger = address(0);\n        claim.decided = false;\n        claim.invalid = false;\n        claim.verificationOngoing = false;\n        claim.createdAt = block.timestamp;\n        claim.challengeTimeout = block.timestamp + superblockTimeout;\n\n        err = this.bondDeposit(superblockHash, msg.sender, minProposalDeposit);\n        require(err == ERR_SUPERBLOCK_OK);\n\n        emit SuperblockClaimCreated(superblockHash, msg.sender);\n\n        return (ERR_SUPERBLOCK_OK, superblockHash);\n    }\n\n    // @dev – challenge a superblock claim.\n    // @param superblockHash – Id of the superblock to challenge.\n    // @return - Error code and claim Id\n    function challengeSuperblock(bytes32 superblockHash) external returns (uint, bytes32) {\n        require(address(trustedSuperblocks) != address(0));\n\n        SuperblockClaim storage claim = claims[superblockHash];\n\n        if (!claimExists(claim)) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\n            return (ERR_SUPERBLOCK_BAD_CLAIM, superblockHash);\n        }\n        if (claim.decided || claim.invalid) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_CLAIM_DECIDED);\n            return (ERR_SUPERBLOCK_CLAIM_DECIDED, superblockHash);\n        }\n        if (claim.verificationOngoing) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_CHALLENGE_EXISTS);\n            return (ERR_SUPERBLOCK_CHALLENGE_EXISTS, superblockHash);\n        }\n        if (deposits[msg.sender] < minProposalDeposit) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_MIN_DEPOSIT);\n            return (ERR_SUPERBLOCK_MIN_DEPOSIT, superblockHash);\n        }\n    \n        uint err = trustedSuperblocks.challenge(superblockHash, msg.sender);\n        if (err != 0) {\n            emit ErrorClaim(superblockHash, err);\n            return (err, 0);\n        }\n\n        err = this.bondDeposit(superblockHash, msg.sender, minProposalDeposit);\n        require(err == ERR_SUPERBLOCK_OK);\n\n        claim.challengeTimeout = block.timestamp + superblockTimeout;\n        claim.challenger = msg.sender;\n        emit SuperblockClaimChallenged(superblockHash, msg.sender);\n\n        trustedSyscoinBattleManager.beginBattleSession(superblockHash, claim.submitter,\n            claim.challenger);\n\n        emit VerificationGameStarted(superblockHash, claim.submitter,\n            claim.challenger);\n\n        claim.verificationOngoing = true;\n        return (ERR_SUPERBLOCK_OK, superblockHash);\n    }\n\n    // @dev – confirm semi approved superblock.\n    //\n    // A semi approved superblock can be confirmed if it has several descendant\n    // superblocks that are also semi-approved.\n    // If none of the descendants were challenged they will also be confirmed.\n    //\n    // @param superblockHash – the claim ID.\n    // @param descendantId - claim ID descendants\n    function confirmClaim(bytes32 superblockHash, bytes32 descendantId) external returns (bool) {\n        uint numSuperblocks = 0;\n        bool confirmDescendants = true;\n        bytes32 id = descendantId;\n        SuperblockClaim storage claim = claims[id];\n        while (id != superblockHash) {\n            if (!claimExists(claim) || claim.invalid) {\n                emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\n                return false;\n            }\n            if (trustedSuperblocks.getSuperblockStatus(id) != SyscoinSuperblocksI.Status.SemiApproved) {\n                emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\n                return false;\n            }\n            if (confirmDescendants && claim.challenger != address(0)) {\n                confirmDescendants = false;\n            }\n            id = trustedSuperblocks.getSuperblockParentId(id);\n            claim = claims[id];\n            numSuperblocks += 1;\n        }\n\n        if (numSuperblocks < superblockConfirmations) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_MISSING_CONFIRMATIONS);\n            return false;\n        }\n        if (trustedSuperblocks.getSuperblockStatus(id) != SyscoinSuperblocksI.Status.SemiApproved) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\n            return false;\n        }\n\n        uint err = trustedSuperblocks.confirm(superblockHash, msg.sender);\n        if (err != ERR_SUPERBLOCK_OK) {\n            emit ErrorClaim(superblockHash, err);\n            return false;\n        }\n        emit SuperblockClaimSuccessful(superblockHash, claim.submitter);\n        doPaySubmitter(superblockHash, claim);\n\n        if (confirmDescendants) {\n            bytes32[] memory descendants = new bytes32[](numSuperblocks);\n            id = descendantId;\n            uint idx = 0;\n            while (id != superblockHash) {\n                descendants[idx] = id;\n                id = trustedSuperblocks.getSuperblockParentId(id);\n                idx += 1;\n            }\n            while (idx > 0) {\n                idx -= 1;\n                id = descendants[idx];\n                claim = claims[id];\n                err = trustedSuperblocks.confirm(id, msg.sender);\n                require(err == ERR_SUPERBLOCK_OK);\n                emit SuperblockClaimSuccessful(id, claim.submitter);\n                doPaySubmitter(id, claim);\n            }\n        }\n\n        return true;\n    }\n\n    // @dev – Reject a semi approved superblock.\n    //\n    // Superblocks that are not in the main chain can be marked as\n    // invalid.\n    //\n    // @param superblockHash – the claim ID.\n    function rejectClaim(bytes32 superblockHash) external returns (bool) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        if (!claimExists(claim)) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\n            return false;\n        }\n\n        uint height = trustedSuperblocks.getSuperblockHeight(superblockHash);\n\n        if (height > trustedSuperblocks.getChainHeight()) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_BLOCKHEIGHT);\n            return false;\n        }\n\n        SyscoinSuperblocksI.Status status = trustedSuperblocks.getSuperblockStatus(superblockHash);\n\n        if (status != SyscoinSuperblocksI.Status.SemiApproved) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_STATUS);\n            return false;\n        }\n\n        if (!claim.decided) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_CLAIM_DECIDED);\n            return false;\n        }\n\n        uint err = trustedSuperblocks.invalidate(superblockHash, claim.submitter);\n        require(err == ERR_SUPERBLOCK_OK);\n        emit SuperblockClaimFailed(superblockHash, claim.submitter);\n        doPayChallenger(superblockHash, claim);\n        claim.invalid = true;\n        return true;\n    }\n\n    // @dev – check whether a claim has successfully withstood all challenges.\n    // If successful without challenges, it will mark the superblock as confirmed.\n    // If successful with at least one challenge, it will mark the superblock as semi-approved.\n    // If verification failed, it will mark the superblock as invalid.\n    //\n    // @param superblockHash – claim ID.\n    function checkClaimFinished(bytes32 superblockHash) external returns (bool) {\n        SuperblockClaim storage claim = claims[superblockHash];\n\n        if (!claimExists(claim) || claim.decided) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_BAD_CLAIM);\n            return false;\n        }\n\n        // check that there is no ongoing verification game.\n        if (claim.verificationOngoing) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_VERIFICATION_PENDING);\n            return false;\n        }\n\n        // an invalid superblock can be rejected immediately\n        if (claim.invalid) {\n            // The superblock is invalid, submitter abandoned\n            // or superblock data is inconsistent\n            claim.decided = true;\n            uint err = trustedSuperblocks.invalidate(superblockHash, claim.submitter);\n            require(err == ERR_SUPERBLOCK_OK);\n            emit SuperblockClaimFailed(superblockHash, claim.submitter);\n            doPayChallenger(superblockHash, claim);\n            return false;\n        }\n\n        // check that the claim has exceeded the claim's specific challenge timeout.\n        if (block.timestamp <= claim.challengeTimeout) {\n            emit ErrorClaim(superblockHash, ERR_SUPERBLOCK_NO_TIMEOUT);\n            return false;\n        }\n\n        claim.decided = true;\n\n        bool confirmImmediately = false;\n        // No challenger and parent approved; confirm immediately\n        if (claim.challenger == address(0)) {\n            bytes32 parentId = trustedSuperblocks.getSuperblockParentId(superblockHash);\n            SyscoinSuperblocksI.Status status = trustedSuperblocks.getSuperblockStatus(parentId);\n            if (status == SyscoinSuperblocksI.Status.Approved) {\n                confirmImmediately = true;\n            }\n        }\n\n        if (confirmImmediately) {\n            uint err = trustedSuperblocks.confirm(superblockHash, msg.sender);\n            require(err == ERR_SUPERBLOCK_OK);\n            address submitter = claim.submitter;\n            unbondDeposit(superblockHash, submitter);\n            emit SuperblockClaimSuccessful(superblockHash, submitter);\n        } else {\n            uint err = trustedSuperblocks.semiApprove(superblockHash, msg.sender);\n            require(err == ERR_SUPERBLOCK_OK);\n            emit SuperblockClaimPending(superblockHash, claim.submitter);\n        }\n        return true;\n    }\n\n\n    // @dev – called when a battle session has ended.\n    //\n    // @param superblockHash - claim Id\n    // @param winner – winner of verification game.\n    // @param loser – loser of verification game.\n    function sessionDecided(bytes32 superblockHash, address winner, address loser) external onlyBattleManager {\n        SuperblockClaim storage claim = claims[superblockHash];\n\n        require(claimExists(claim));\n\n        claim.verificationOngoing = false;\n        address submitter = claim.submitter;\n\n        if (submitter == loser) {\n            claim.invalid = true;\n        } else if (submitter != winner) {\n            revert();\n        }\n        emit SuperblockBattleDecided(superblockHash, winner, loser);\n    }\n\n    // @dev - Pay challenger\n    function doPayChallenger(bytes32 superblockHash, SuperblockClaim storage claim) private {\n        address challenger = claim.challenger;\n        address submitter = claim.submitter;\n\n        if (challenger != address(0)) {\n            uint reward = claim.bondedDeposits[submitter];\n            claim.bondedDeposits[challenger] = claim.bondedDeposits[challenger].add(reward);\n            unbondDeposit(superblockHash, challenger);\n        }\n        delete claim.bondedDeposits[submitter];\n    }\n\n    // @dev - Pay submitter with challenger deposit\n    function doPaySubmitter(bytes32 superblockHash, SuperblockClaim storage claim) private {\n        address challenger = claim.challenger;\n        address submitter = claim.submitter;\n\n        if (challenger != address(0)) {\n            uint reward = claim.bondedDeposits[challenger];\n            claim.bondedDeposits[challenger] = 0;\n            claim.bondedDeposits[submitter] = claim.bondedDeposits[submitter].add(reward);\n\n            unbondDeposit(superblockHash, challenger);\n        }\n        unbondDeposit(superblockHash, submitter);\n    }\n\n    // @dev - Check if a superblock can be semi approved by calling checkClaimFinished\n    function getInBattleAndSemiApprovable(bytes32 superblockHash) external view returns (bool) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        return (trustedSuperblocks.getSuperblockStatus(superblockHash) == SyscoinSuperblocksI.Status.InBattle &&\n            !claim.invalid && !claim.verificationOngoing && block.timestamp > claim.challengeTimeout\n            && claim.challenger != address(0));\n    }\n\n    // @dev – Check if a claim exists\n    function claimExists(SuperblockClaim storage claim) private view returns (bool) {\n        return (claim.submitter != address(0));\n    }\n\n    // @dev - Return a given superblock's submitter\n    function getClaimSubmitter(bytes32 superblockHash) external view returns (address) {\n        return claims[superblockHash].submitter;\n    }\n\n    // @dev - Return superblock submission timestamp\n    function getNewSuperblockEventTimestamp(bytes32 superblockHash) external view returns (uint) {\n        return claims[superblockHash].createdAt;\n    }\n\n    // @dev - Return whether or not a claim has already been made\n    function getClaimExists(bytes32 superblockHash) external view returns (bool) {\n        return claimExists(claims[superblockHash]);\n    }\n\n    // @dev - Return claim status\n    function getClaimDecided(bytes32 superblockHash) external view returns (bool) {\n        return claims[superblockHash].decided;\n    }\n\n    // @dev - Check if a claim is invalid\n    function getClaimInvalid(bytes32 superblockHash) external view returns (bool) {\n        // TODO: see if this is redundant with superblock status\n        return claims[superblockHash].invalid;\n    }\n\n\n    function getClaimChallenger(bytes32 superblockHash) external view returns (address) {\n        SuperblockClaim storage claim = claims[superblockHash];\n        return claim.challenger;\n    }\n}\n","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositBonded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositUnbonded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"err\",\"type\":\"uint256\"}],\"name\":\"ErrorClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"}],\"name\":\"SuperblockBattleDecided\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"}],\"name\":\"SuperblockClaimChallenged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"}],\"name\":\"SuperblockClaimCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"}],\"name\":\"SuperblockClaimFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"}],\"name\":\"SuperblockClaimPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"}],\"name\":\"SuperblockClaimSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"}],\"name\":\"VerificationGameStarted\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bondDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"challengeSuperblock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"checkClaimFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"challengeTimeout\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"verificationOngoing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"decided\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"invalid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"descendantId\",\"type\":\"bytes32\"}],\"name\":\"confirmClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBondedDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getClaimChallenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getClaimDecided\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getClaimExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getClaimInvalid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getClaimSubmitter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getInBattleAndSemiApprovable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"getNewSuperblockEventTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract SyscoinSuperblocksI\",\"name\":\"_superblocks\",\"type\":\"address\"},{\"internalType\":\"contract SyscoinBattleManagerI\",\"name\":\"_syscoinBattleManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_superblockDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_superblockTimeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_superblockConfirmations\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"makeDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minProposalDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_blocksMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mtpTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_lastHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_lastBits\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_parentHash\",\"type\":\"bytes32\"}],\"name\":\"proposeSuperblock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"}],\"name\":\"rejectClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"superblockHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"}],\"name\":\"sessionDecided\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superblockConfirmations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superblockDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superblockTimeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trustedSuperblocks\",\"outputs\":[{\"internalType\":\"contract SyscoinSuperblocksI\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trustedSyscoinBattleManager\",\"outputs\":[{\"internalType\":\"contract SyscoinBattleManagerI\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SyscoinClaimManager","CompilerVersion":"v0.5.13+commit.5b0b510c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://f1c683aff6522f7c8c17edff251c58829d89ba5e25160d78c760b9d8e17ef239"}]}