{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.3;\r\n\r\ninterface IERC20Mintable {\r\n    function mint(address _receiver, uint256 _amount) external returns (bool);\r\n}\r\n\r\ncontract MerkleDistributor {\r\n    bytes32[] public merkleRoots;\r\n\r\n    event Claimed(\r\n        uint256 merkleIndex,\r\n        uint256 index,\r\n        address account,\r\n        uint256 amount\r\n    );\r\n    event NewMerkleRoot(uint256 merkleIndex, bytes32 root);\r\n\r\n    // This is a packed array of booleans.\r\n    mapping(uint256 => mapping(uint256 => uint256)) private claimedBitMap;\r\n\r\n    address public owner;\r\n    IERC20Mintable public token;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor(address _owner, IERC20Mintable _token) public {\r\n        owner = _owner;\r\n        token = _token;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function addMerkleRoot(bytes32 _merkleRoot) public onlyOwner {\r\n        merkleRoots.push(_merkleRoot);\r\n        emit NewMerkleRoot(merkleRoots.length - 1, _merkleRoot);\r\n    }\r\n\r\n    function isClaimed(uint256 merkleIndex, uint256 index)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 claimedWordIndex = index / 256;\r\n        uint256 claimedBitIndex = index % 256;\r\n        uint256 claimedWord = claimedBitMap[merkleIndex][claimedWordIndex];\r\n        uint256 mask = (1 << claimedBitIndex);\r\n        return claimedWord & mask == mask;\r\n    }\r\n\r\n    function _setClaimed(uint256 merkleIndex, uint256 index) private {\r\n        uint256 claimedWordIndex = index / 256;\r\n        uint256 claimedBitIndex = index % 256;\r\n        claimedBitMap[merkleIndex][claimedWordIndex] =\r\n            claimedBitMap[merkleIndex][claimedWordIndex] |\r\n            (1 << claimedBitIndex);\r\n    }\r\n\r\n    function claim(\r\n        uint256 merkleIndex,\r\n        uint256 index,\r\n        address receiver,\r\n        uint256 amount,\r\n        bytes32[] calldata merkleProof\r\n    ) external {\r\n        require(\r\n            merkleIndex < merkleRoots.length,\r\n            \"MerkleDistributor: Invalid merkleIndex\"\r\n        );\r\n        require(\r\n            !isClaimed(merkleIndex, index),\r\n            \"MerkleDistributor: Drop already claimed.\"\r\n        );\r\n\r\n        // Verify the merkle proof.\r\n        bytes32 node = keccak256(abi.encodePacked(index, receiver, amount));\r\n        require(\r\n            verify(merkleProof, merkleRoots[merkleIndex], node),\r\n            \"MerkleDistributor: Invalid proof.\"\r\n        );\r\n\r\n        // Mark it claimed and send the token.\r\n        _setClaimed(merkleIndex, index);\r\n        token.mint(receiver, amount);\r\n\r\n        emit Claimed(merkleIndex, index, receiver, amount);\r\n    }\r\n\r\n    function verify(\r\n        bytes32[] calldata proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(\r\n                    abi.encodePacked(computedHash, proofElement)\r\n                );\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(\r\n                    abi.encodePacked(proofElement, computedHash)\r\n                );\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Mintable\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"NewMerkleRoot\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"addMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"merkleRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20Mintable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MerkleDistributor","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000037bfdba7a1b25fd735c3ea11a0d1c9d8be50e2620000000000000000000000001337c30c27fa619e66449bc95a69d2b1916124dd","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e614db678fb84dbbd74b223cfbf0252f136aa5202415a17dbd43dce61fc751e9"}]}