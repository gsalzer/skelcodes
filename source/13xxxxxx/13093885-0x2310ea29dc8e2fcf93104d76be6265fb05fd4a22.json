{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\nstruct StakeConfig {\r\n    uint256 collateral;\r\n    uint256 reward;\r\n    uint256 lockTime;\r\n    uint256 activeCollateral;  \r\n    uint256 rewPaid; \r\n}\r\n\r\nstruct GeneralDetails {\r\n    StakeConfig t1;\r\n    StakeConfig t2;\r\n    StakeConfig t3;\r\n    \r\n    string _name;\r\n    string _symbol;\r\n    uint8 _decimals;\r\n    uint256 _totalSupply;\r\n    bool _isPaused;\r\n    uint256 _totalStake;   \r\n    uint256 _activeStakers;\r\n    uint256 _refPaid;\r\n    uint256 _totalRewardPaid;\r\n    \r\n    address _validatorAdd;\r\n    string _validatorApi;\r\n    uint256 _maxSupply;\r\n    uint256 _maxTxLimit;\r\n    uint256 _rewardDuration;\r\n    uint256 _refCom;\r\n    uint256 _voteApproveRate;    \r\n    uint256 _propDuration;\r\n    uint256 _changeDate;\r\n    uint256 _swapOut;\r\n    uint256 _swapIn;\r\n    uint256 _supplyTime;\r\n    uint256 _otherSupply;\r\n    address _stakeAddress;\r\n}\r\n\r\nstruct StakeDetails {\r\n    uint256 date;  \r\n    uint256 rewDate;\r\n    uint256 collateral;\r\n    uint256 pendingRew;\r\n    uint256 activeRew;\r\n    uint256 refRew;\r\n    uint256 rewPaid;\r\n}\r\n\r\nstruct UserDetails {\r\n    StakeDetails t1;\r\n    StakeDetails t2;\r\n    StakeDetails t3;\r\n    \r\n    uint256 _balances;\r\n    uint256 voteStatus;\r\n    uint256 propStatus;\r\n    uint256 stakeNonce;\r\n    address refAdd;\r\n    uint256 refPaid;\r\n    uint256 refCount;\r\n    address[] refList;\r\n} \r\n\r\nstruct VoteData {\r\n    address account;\r\n    uint256 cycle;\r\n    uint256 startDate;\r\n    uint256 endDate;\r\n    uint256 value;\r\n    uint256 voteCount;\r\n    string info;\r\n    uint256 status;\r\n}\r\n\r\nabstract contract Context {\r\n    \r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    \r\n}\r\n\r\ninterface AFTS {\r\n    \r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);      \r\n\r\n    function isPaused() external view returns (bool);\r\n    \r\n    function generalDetails() external view returns(GeneralDetails memory);\r\n\r\n    function userDetails(address account) external view returns(UserDetails memory);  \r\n    \r\n    function voteCycleDetails(uint256 cycle, string memory config) external view returns (VoteData memory);\r\n    \r\n    function swapInfo(uint256 nonceOut, bytes32 txid, uint256 method, address account) external view returns (uint256);\r\n    \r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    \r\n    function burn(uint256 amount, uint256 swapNonce, uint256 chainId) external returns (bool);\r\n    \r\n    function transferMulti(address[] memory to, uint256[] memory amount) external returns (bool);  \r\n    \r\n    function transferMultiFrom(address sender, address[] memory to, uint256[] memory amount) external returns (bool);    \r\n    \r\n    function stake(uint256[] memory info, address refAdd, bytes memory sig) external returns (bool);\r\n    \r\n    function propose(string memory config, string memory info, uint256 value, address account) external returns (bool);\r\n    \r\n    function vote(string memory config) external returns (bool);\r\n    \r\n    function mint(bytes32 txid, uint256 swapNonce, uint256 amount, uint256 fees, uint256 fromId, bytes memory sig) external returns (bool);   \r\n    \r\n    function protocolUpdate(uint256[] memory newConfig, address account, address stakeAddress, string memory info, uint256 status) external returns (bool);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);    \r\n    \r\n    event Proposer(address indexed from, string config, uint256 value, address account);\r\n    \r\n    event Voter(address indexed from, string config);    \r\n    \r\n}\r\n\r\ncontract MYDA is Context, AFTS {\r\n    \r\n    GeneralDetails _general;\r\n    \r\n    mapping(string =>  uint256) private _genConfig;\r\n    \r\n    mapping(address =>  UserDetails) private _user;\r\n    \r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    mapping(uint256 =>  StakeConfig) _stakeConfig;\r\n    \r\n    mapping(address =>  mapping(uint256 =>  StakeDetails)) private _stake;\r\n    \r\n    mapping(address =>  mapping(bytes32 => uint256)) private _swapIn;\r\n    \r\n    mapping(address =>  mapping(uint256 => uint256)) private _swapOut;\r\n    \r\n    mapping(address =>  mapping(uint256 =>  mapping(string =>  uint256))) private _userVote;\r\n    \r\n    mapping(uint256 =>  mapping(string =>  VoteData)) private _vote;\r\n    \r\n    mapping(string =>  uint256) private _voteCycle;\r\n    \r\n    constructor () {\r\n        _general._name = \"MYDA\";\r\n        _general._symbol = \"MYDA\";\r\n        _general._decimals = 18;\r\n        _general._validatorAdd = _msgSender();\r\n        _general._validatorApi = \"https://validator.mydacoin.com/\";\r\n        //_general._totalSupply = 100000000*1e18;\r\n        _genConfig[\"maxSupply\"] = 100000000*1e18;\r\n        _genConfig[\"maxTxLimit\"] = 200;\r\n        _genConfig[\"rewardDuration\"] = 86400;\r\n        _genConfig[\"refCom\"] = 10;  \r\n        _genConfig[\"voteApproveRate\"] = 70; \r\n        _genConfig[\"propDuration\"] = 2592000;\r\n        _stakeConfig[1].collateral = 5000*1e18;\r\n        _stakeConfig[2].collateral = 10000*1e18;\r\n        _stakeConfig[3].collateral = 20000*1e18;\r\n        _stakeConfig[1].lockTime = 2592000;\r\n        _stakeConfig[2].lockTime = 7776000;\r\n        _stakeConfig[3].lockTime = 15552000;\r\n        _stakeConfig[1].reward = 8.25*1e18;\r\n        _stakeConfig[2].reward = 33*1e18;\r\n        _stakeConfig[3].reward = 99*1e18;\r\n        _general._isPaused = false;\r\n        _general._stakeAddress = 0x7F7512BDcC61861DfEC5ad7C124899c72fC86FD6;\r\n        //_transfer(address(0), _general._stakeAddress, 100000000*1e18, 0);\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _general._name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _general._symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint256) {\r\n        return _general._decimals;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _general._totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _user[account]._balances;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    \r\n    function isPaused() public view virtual override returns (bool) {\r\n        return _general._isPaused;\r\n    }   \r\n\r\n    function generalDetails() public view virtual override returns(GeneralDetails memory){\r\n        GeneralDetails memory gendet = _general;\r\n        gendet.t1 = _stakeConfig[1];\r\n        gendet.t2 = _stakeConfig[2];\r\n        gendet.t3 = _stakeConfig[3];\r\n        gendet._maxSupply = _genConfig[\"maxSupply\"];\r\n        gendet._maxTxLimit = _genConfig[\"maxTxLimit\"];\r\n        gendet._rewardDuration = _genConfig[\"rewardDuration\"];\r\n        gendet._refCom = _genConfig[\"refCom\"];  \r\n        gendet._voteApproveRate = _genConfig[\"voteApproveRate\"]; \r\n        gendet._propDuration = _genConfig[\"propDuration\"];\r\n        return gendet;\r\n    }\r\n    \r\n    function userDetails(address account) public view virtual override returns(UserDetails memory){\r\n        UserDetails memory userdet = _user[account];\r\n        userdet.t1 = _stake[account][1];\r\n        userdet.t2 = _stake[account][2];\r\n        userdet.t3 = _stake[account][3];\r\n        return userdet;\r\n    }  \r\n  \r\n    function voteCycleDetails(uint256 cycle, string memory config) public view virtual override returns (VoteData memory) {\r\n        \r\n        if(cycle == 0){\r\n            cycle = _voteCycle[config];\r\n        }\r\n        \r\n        return _vote[cycle][config];\r\n    }  \r\n    \r\n    function swapInfo(uint256 nonceOut, bytes32 txid, uint256 method, address account) public view virtual override returns (uint256) {\r\n        \r\n        if(method == 0){\r\n            return _swapOut[account][nonceOut];\r\n        } else {\r\n            return _swapIn[account][txid];\r\n        }\r\n    }    \r\n\r\n    function _transfer(address sender, address recipient, uint256 amount, uint8 method) internal virtual {\r\n        require(!_general._isPaused, \"Contract is Paused\");\r\n        \r\n        if(method == 1){\r\n            require(sender != address(0), \"from zero address\");\r\n            require(recipient != address(0), \"to zero address\");\r\n        }\r\n        \r\n        if(sender != address(0)){\r\n            require(_user[sender]._balances >= amount, \"amount exceeds balance\");\r\n            _user[sender]._balances -= amount;\r\n        }\r\n        \r\n        if(recipient != address(0)){\r\n            _user[recipient]._balances += amount;\r\n        }\r\n        \r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(!_general._isPaused, \"Contract is Paused\");\r\n        require(owner != address(0), \"from zero address\");\r\n        require(spender != address(0), \"to zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    \r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {     \r\n        _transfer(_msgSender(), recipient, amount, 1);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        require(_allowances[sender][_msgSender()] >= amount, \"amount exceeds allowance\");\r\n        _transfer(sender, recipient, amount, 1);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\r\n        return true;\r\n    }\r\n    \r\n    function _transferMulti(address sender, address[] memory to, uint256[] memory amount, uint8 method, address spender) internal virtual {\r\n        require(sender != address(0), \"from zero address\");\r\n\t\trequire(_genConfig[\"maxTxLimit\"] >= to.length, \"greater than _maxTxLimit\");        \r\n\t\trequire(to.length == amount.length, \"array length not equal\");\r\n\t\tuint256 sum_;\r\n\t\t\r\n        for (uint8 g; g < to.length; g++) {\r\n            require(to[g] != address(0), \"to zero address\");\r\n            sum_ += amount[g];            \r\n        }\r\n        \r\n        require(_user[sender]._balances >= sum_, \"amount exceeds balance\");\r\n        \r\n        if(method == 1){\r\n            require(_allowances[sender][spender] >= sum_, \"amount exceeds allowance\");\r\n            _approve(sender, spender, _allowances[sender][_msgSender()] - sum_);            \r\n        }\r\n        \r\n\t\tfor (uint8 i; i < to.length; i++) {\r\n\t\t    _transfer(sender, to[i], amount[i], 0);\r\n\t\t}        \r\n    }   \r\n   \r\n\tfunction transferMulti(address[] memory to, uint256[] memory amount) public virtual override returns (bool) {\r\n\t\t_transferMulti(_msgSender(), to, amount, 0, address(0));\r\n        return true;\r\n\t}\r\n\t\r\n\tfunction transferMultiFrom(address sender, address[] memory to, uint256[] memory amount) public virtual override returns (bool) {\r\n\t\t_transferMulti(sender, to, amount, 1, _msgSender());\r\n        return true;\r\n\t}  \r\n\t\r\n    function stake(uint256[] memory info, address refAdd, bytes memory sig) public virtual override returns (bool) {//0-tier,1-qty,2-method,3-otherSupply\r\n        _sigValidate(sig, keccak256(abi.encodePacked(_msgSender(), info[0], info[1], info[2], info[3], block.chainid, _user[_msgSender()].stakeNonce + 1, true)), _general._validatorAdd);\r\n        _user[_msgSender()].stakeNonce += 1;\r\n        if(_general._supplyTime < block.timestamp){\r\n            _general._supplyTime = block.timestamp;\r\n            _general._otherSupply = info[3];\r\n        }\r\n        _stakeProcess(_msgSender(), info[0], info[1], refAdd, info[2]);\r\n        return true;\r\n    }  \r\n    \r\n    function _stakeProcess(address recipient, uint256 tier, uint256 qty, address refAdd, uint256 method) internal virtual {\r\n        require(!_general._isPaused, \"Contract is Paused\");\r\n        require(recipient != address(0), \"from zero address\");\r\n        require(tier > 0 && tier < 4, \"Invalid Tier\");\r\n        require(method >= 0 && method < 4, \"Invalid Method\");\r\n        \r\n        if(method >=0 && method < 2){\r\n            require(qty > 0, \"Invalid Qty\");\r\n        }\r\n        \r\n        uint256 stakeReward;\r\n        uint256 collateral;\r\n        uint256 tempReward;\r\n        uint256 diff;\r\n        uint256 refRew;\r\n        collateral = _stake[recipient][tier].collateral;\r\n        refRew = _stake[recipient][tier].refRew;\r\n        \r\n        if(_user[recipient].refAdd == address(0) && refAdd != address(0) && refAdd != recipient){\r\n            _user[recipient].refAdd = refAdd;\r\n            _user[refAdd].refList.push(recipient);\r\n            _user[refAdd].refCount += 1;\r\n        }\r\n        \r\n        diff = (block.timestamp - _stake[recipient][tier].rewDate) / _genConfig[\"rewardDuration\"];\r\n        stakeReward = (((diff * _stakeConfig[tier].reward) * collateral) / _stakeConfig[tier].collateral) + _stake[recipient][tier].pendingRew;  \r\n        \r\n        if(method < 2){\r\n            \r\n            if(method == 0){\r\n                require(!(_stake[_msgSender()][tier].collateral > 0), \"Already Staking\");\r\n            } else {\r\n                require(_stake[_msgSender()][tier].collateral > 0, \"Staking Inactive\");\r\n            }\r\n            \r\n            _transfer(recipient, address(0), (_stakeConfig[tier].collateral * qty), 0);\r\n            tempReward = ((_stakeConfig[tier].lockTime / _genConfig[\"rewardDuration\"]) * _stakeConfig[tier].reward) * qty;\r\n            refRew = ((tempReward * _genConfig[\"refCom\"]) / 100);\r\n            \r\n            if(_user[_general._stakeAddress]._balances < (tempReward)){\r\n                require(((_general._totalSupply + _general._otherSupply) + tempReward) <= _genConfig[\"maxSupply\"], \"Exceeds maxSupply\");\r\n            }\r\n            \r\n            if(_user[recipient].refAdd != address(0)){\r\n                if(_user[_general._stakeAddress]._balances < (tempReward + refRew)){\r\n                    require(((_general._totalSupply + _general._otherSupply) + tempReward + refRew) <= _genConfig[\"maxSupply\"], \"Exceeds maxSupply\");\r\n                }\r\n                _stake[_user[recipient].refAdd][tier].refRew += refRew;\r\n                _user[_user[recipient].refAdd].refPaid += refRew;\r\n                _general._refPaid += refRew;\r\n            }  \r\n            \r\n            if(method == 1){\r\n                _stake[recipient][tier].pendingRew += stakeReward;\r\n            }\r\n            \r\n            _stake[recipient][tier].date = block.timestamp;\r\n            _stake[recipient][tier].rewDate = block.timestamp;\r\n            _stake[recipient][tier].collateral += (_stakeConfig[tier].collateral * qty);\r\n            _stakeConfig[tier].activeCollateral += (_stakeConfig[tier].collateral * qty);\r\n            _user[recipient].propStatus = (tier == 3)?1:_user[recipient].propStatus;\r\n            _general._totalStake += (_stakeConfig[tier].collateral * qty);\r\n            \r\n            if(_user[recipient].voteStatus == 0){\r\n                _user[recipient].voteStatus = 1;\r\n                _general._activeStakers += 1;\r\n            }   \r\n            \r\n        } else {\r\n            require(block.timestamp >= (_stake[_msgSender()][tier].date + _stakeConfig[tier].lockTime), \"Stake not matured\");\r\n            require(_stake[_msgSender()][tier].collateral > 0, \"Staking Inactive\");\r\n                \r\n            if(_user[_general._stakeAddress]._balances < (stakeReward + refRew)){\r\n                if(_user[_general._stakeAddress]._balances > 0){\r\n                    stakeReward = _user[_general._stakeAddress]._balances;\r\n                } else { \r\n                    stakeReward = 0;\r\n                }                                \r\n            } else {\r\n                stakeReward = stakeReward + refRew;\r\n            }\r\n            \r\n            if(stakeReward > 0){\r\n                _transfer(_general._stakeAddress, recipient, stakeReward, 1);\r\n            } else {\r\n                stakeReward = (((diff * _stakeConfig[tier].reward) * collateral) / _stakeConfig[tier].collateral) + _stake[recipient][tier].pendingRew;\r\n                \r\n                if(((_general._totalSupply + _general._otherSupply)) < _general._maxSupply){\r\n                    if(((_general._totalSupply + _general._otherSupply) + stakeReward + refRew) > _genConfig[\"maxSupply\"]){\r\n                        if((_genConfig[\"maxSupply\"] - (_general._totalSupply + _general._otherSupply)) > 0){\r\n                            stakeReward = _genConfig[\"maxSupply\"] - (_general._totalSupply + _general._otherSupply);\r\n                        } else { \r\n                            stakeReward = 0;\r\n                        }\r\n                    } else {\r\n                        stakeReward = stakeReward + refRew;\r\n                    }     \r\n                    \r\n                    if(stakeReward > 0){\r\n                        _general._totalSupply += stakeReward;\r\n                        _transfer(address(0), recipient, stakeReward, 0);\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            if(method == 2){\r\n                _transfer(address(0), recipient, collateral, 0);\r\n                _stake[recipient][tier].collateral = 0;\r\n                _stake[recipient][tier].date = 0;\r\n                _stake[recipient][tier].rewDate = 0;\r\n                _general._totalStake -= collateral;\r\n                _stakeConfig[tier].activeCollateral -= collateral;\r\n                _user[recipient].propStatus = (tier == 3)?0:_user[recipient].propStatus;  \r\n                if(_stake[recipient][1].collateral == 0 && _stake[recipient][2].collateral == 0 && _stake[recipient][3].collateral == 0){\r\n                    _user[recipient].voteStatus = 0;\r\n                    _general._activeStakers -= 1;\r\n                }\r\n            } else {\r\n                _stake[recipient][tier].rewDate = block.timestamp;\r\n            }\r\n            \r\n            _stake[recipient][tier].rewPaid += stakeReward;\r\n            _stakeConfig[tier].rewPaid += stakeReward;\r\n            _stake[recipient][tier].refRew = 0;\r\n            _stake[recipient][tier].pendingRew = 0;\r\n            _general._totalRewardPaid += stakeReward;             \r\n        }\r\n    }        \r\n\r\n    function propose(string memory config, string memory info, uint256 value, address account) public virtual override returns (bool) {\r\n        _propose(_msgSender(), config, info, value, account);\r\n        return true;\r\n    }\r\n    \r\n    function _propose(address sender, string memory config, string memory info, uint256 value, address account) internal {\r\n        require(_user[sender].propStatus == 1 && _general._activeStakers >= 100, \"Can't Propose\");\r\n        uint256 date = block.timestamp;\r\n        uint256 cycle = _voteCycle[config];\r\n        require((date - _vote[cycle][config].startDate) > _genConfig[\"propDuration\"], \"Old Active\");\r\n        _vote[cycle][config].status = 3;\r\n        _voteCycle[config] += 1;\r\n        cycle = _voteCycle[config];\r\n        _vote[cycle][config].cycle = _voteCycle[config];\r\n        _vote[cycle][config].startDate = date; \r\n        \r\n        if(keccak256(bytes(config)) == keccak256(bytes(\"validatorAdd\"))){\r\n            _vote[cycle][config].account = account;\r\n        } else {\r\n            _vote[cycle][config].value = value; \r\n        }  \r\n        \r\n        _vote[cycle][config].status = 1;\r\n        _vote[cycle][config].info = info;\r\n        emit Proposer(sender, config, value, account);        \r\n    }\r\n\r\n    function vote(string memory config) public virtual override returns (bool) {\r\n        _voteProcess(_msgSender(), config);\r\n        return true;\r\n    } \r\n    \r\n    function _voteProcess(address sender, string memory config) internal {\r\n        require(_user[sender].voteStatus == 1, \"Can't Vote\");\r\n        uint256 date = block.timestamp;\r\n        uint256 cycle = _voteCycle[config];\r\n        require(_vote[cycle][config].status == 1, \"Voting Finished\");\r\n        require(_userVote[sender][cycle][config] == 0, \"Already Voted\");\r\n        _userVote[sender][cycle][config] = 1;\r\n        _vote[cycle][config].voteCount += 1;\r\n        \r\n        if(_vote[cycle][config].voteCount >= ((_general._activeStakers * _genConfig[\"voteApproveRate\"]) / 100)){\r\n            \r\n            if(keccak256(bytes(config)) == keccak256(bytes(\"maxSupply\"))){\r\n                require(keccak256(bytes(config)) == keccak256(bytes(\"maxSupply\")) && _general._totalSupply < _vote[cycle][config].value, \"less than totalSupply\");\r\n            }   \r\n            \r\n            _vote[cycle][config].status = 2;\r\n            _vote[cycle][config].endDate = date;\r\n            _general._changeDate = date;\r\n            \r\n            if(keccak256(bytes(config)) == keccak256(bytes(\"t1Collateral\"))){\r\n                _stakeConfig[1].collateral = _vote[cycle][config].value;\r\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t2Collateral\"))){\r\n                _stakeConfig[2].collateral = _vote[cycle][config].value;\r\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t3Collateral\"))){\r\n                _stakeConfig[3].collateral = _vote[cycle][config].value;\r\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t1Reward\"))){\r\n                _stakeConfig[1].reward = _vote[cycle][config].value;\r\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t2Reward\"))){\r\n                _stakeConfig[2].reward = _vote[cycle][config].value;\r\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t3Reward\"))){\r\n                _stakeConfig[3].reward = _vote[cycle][config].value;\r\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t1LockTime\"))){\r\n                _stakeConfig[1].lockTime = _vote[cycle][config].value;\r\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t2LockTime\"))){\r\n                _stakeConfig[2].lockTime = _vote[cycle][config].value;\r\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"t3LockTime\"))){\r\n                _stakeConfig[3].lockTime = _vote[cycle][config].value;\r\n            } else if(keccak256(bytes(config)) == keccak256(bytes(\"validatorAdd\"))){\r\n                _general._validatorAdd = _vote[cycle][config].account;\r\n                _general._validatorApi = _vote[cycle][config].info;\r\n            } else {\r\n                _genConfig[config] = _vote[_voteCycle[config]][config].value;\r\n            }           \r\n        }        \r\n        emit Voter(sender, config);        \r\n    }\r\n\r\n    function _splitSignature(bytes memory sig) internal pure returns (uint8, bytes32, bytes32) {\r\n        require(sig.length == 65);\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n       return (v, r, s);\r\n    }       \r\n   \r\n    function _sigValidate(bytes memory sig, bytes32 hash, address account) internal pure {\r\n        (uint8 v, bytes32 r, bytes32 s) = _splitSignature(sig);\r\n        require(ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), v, r, s) == account, \"Not Authorized\");\r\n    }\r\n\r\n    function burn(uint256 amount, uint256 swapNonce, uint256 chainId) public virtual override returns (bool) {\r\n        _burn(_msgSender(), amount, swapNonce, chainId);\r\n        return true;\r\n    }\r\n\r\n    function _burn(address sender, uint256 amount, uint256 swapNonce, uint256 chainId) internal {\r\n        _transfer(sender, address(0), amount, 0);\r\n        \r\n        if(swapNonce > 0){\r\n            _swapOut[sender][swapNonce] = chainId;\r\n            _general._swapOut += amount;\r\n        }\r\n        \r\n        _general._totalSupply -= amount;\r\n    }    \r\n    \r\n    function mint(bytes32 txid, uint256 swapNonce, uint256 amount, uint256 fees, uint256 fromId, bytes memory sig) public virtual override returns (bool) {\r\n        _mint(_msgSender(), txid, swapNonce, amount, fees, fromId, sig);\r\n        return true;\r\n    }  \r\n    \r\n    function _mint(address sender, bytes32 txid, uint256 swapNonce, uint256 amount, uint256 fees, uint256 fromId, bytes memory sig) internal {\r\n        require(!_general._isPaused, \"Contract is Paused\");\r\n        require(_swapIn[sender][txid] == 0, \"Already Swapped\");\r\n        _sigValidate(sig, keccak256(abi.encodePacked(sender, txid, swapNonce, amount, fees, fromId, block.chainid, true)), _general._validatorAdd);\r\n        _transfer(address(0), sender, amount - fees, 0);\r\n        _transfer(address(0), _general._validatorAdd, fees, 0);\r\n        _general._totalSupply += amount;\r\n        _swapIn[sender][txid] = swapNonce;\r\n        _general._swapIn += amount;\r\n    }    \r\n    \r\n    function protocolUpdate(uint256[] memory newConfig, address account, address stakeAddress, string memory info, uint256 status) public virtual override returns (bool) {\r\n        require(_msgSender() == _general._validatorAdd, \"Only Validator Allowed\");\r\n        \r\n        if(newConfig.length == 16){\r\n            _genConfig[\"maxSupply\"] = newConfig[0];\r\n            _genConfig[\"maxTxLimit\"] = newConfig[1];\r\n            _genConfig[\"rewardDuration\"] = newConfig[2];\r\n            _genConfig[\"refCom\"] = newConfig[3];  \r\n            _genConfig[\"voteApproveRate\"] = newConfig[4]; \r\n            _genConfig[\"propDuration\"] = newConfig[5];\r\n            _stakeConfig[1].collateral = newConfig[6];\r\n            _stakeConfig[1].lockTime = newConfig[7];\r\n            _stakeConfig[1].reward = newConfig[8];\r\n            _stakeConfig[2].collateral = newConfig[9];\r\n            _stakeConfig[2].lockTime = newConfig[10];\r\n            _stakeConfig[2].reward = newConfig[11];\r\n            _stakeConfig[3].collateral = newConfig[12];\r\n            _stakeConfig[3].lockTime = newConfig[13];\r\n            _stakeConfig[3].reward = newConfig[14];\r\n            _general._changeDate = newConfig[15];\r\n        }\r\n        \r\n        if(account != address(0)){\r\n           _general._validatorAdd = account;\r\n           _general._validatorApi = info;\r\n        }\r\n        \r\n        if(stakeAddress != address(0)){\r\n           _general._stakeAddress = stakeAddress;\r\n        }\r\n        \r\n        if(status > 0){\r\n            _general._isPaused = (status == 1)?true:false;\r\n        }\r\n        \r\n        return true;\r\n    } \r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"config\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Proposer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"config\",\"type\":\"string\"}],\"name\":\"Voter\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generalDetails\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewPaid\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeConfig\",\"name\":\"t1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewPaid\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeConfig\",\"name\":\"t2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewPaid\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeConfig\",\"name\":\"t3\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isPaused\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_totalStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_activeStakers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_refPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalRewardPaid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_validatorAdd\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_validatorApi\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTxLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_refCom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_voteApproveRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_propDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_changeDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_supplyTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_otherSupply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_stakeAddress\",\"type\":\"address\"}],\"internalType\":\"struct GeneralDetails\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"txid\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"swapNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"config\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"newConfig\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakeAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"protocolUpdate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"info\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"refAdd\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonceOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"txid\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"method\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"swapInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"transferMulti\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"transferMultiFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"userDetails\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingRew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeRew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refRew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewPaid\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeDetails\",\"name\":\"t1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingRew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeRew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refRew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewPaid\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeDetails\",\"name\":\"t2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingRew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeRew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refRew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewPaid\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeDetails\",\"name\":\"t3\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_balances\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteStatus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"propStatus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeNonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"refAdd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"refPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refCount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"refList\",\"type\":\"address[]\"}],\"internalType\":\"struct UserDetails\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"config\",\"type\":\"string\"}],\"name\":\"vote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"config\",\"type\":\"string\"}],\"name\":\"voteCycleDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteCount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"internalType\":\"struct VoteData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MYDA","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7c4dd436db6b371db313dffbbee98c44047c937e17884f9283066e4c8bc47390"}]}