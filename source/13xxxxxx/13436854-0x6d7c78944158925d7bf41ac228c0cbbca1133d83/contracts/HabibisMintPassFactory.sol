// SPDX-License-Identifier: MIT

/*
                                                                                                                                     
                                                ..',:cccc:'.                                                                                
                                            .,:ox0KXXXXK0Ox:.                                                                               
                                         .;oOKXNXXKK00Okdl;''.                                                                              
                                       .lOKXXXKK0Okxdoc;,'...,,.                                                                            
                                      'x00OOOkxxolc:;,'.......::.                                                                           
                                      ;kkxdolc::;,,''''........:c.                                                                          
                                      .dOxdl:;;,,,,''''.........lo.                                                                         
                                       ckxlc;;,,,,''''''........'od'                                                                        
                                       ,xxl:;,,''''''''''''......'ol.                                                                       
                                       .okoc;;,,'''''''''''.......cOkdxxxxddoolc:,...                                                       
                                        :kdlc;;,,,''''''''.......:OXNNNNNNNNNNNNNXKOxdl:,.                                                  
                                        .ddlc:;;,,,,,,'''........:dOKKKKXXXXXXXXXXXXXXXXKOdl;.                                              
                                        .co:cc::;;;;,,,''......':oxO000KKKKKKKKKKKKKKKKK00OOOkd:.                                           
                                         .cloolcc::;,,'.....,:ldxkO000O0000000000OOkkkkOOOkxxkOOkl;.                                        
                                          .dKX0Odlc:;;;::clodxxkOO000O0000000OOkkkkxxxkOOkxooodxxddo:.                                      
                                        .:ONNXK0kxddddddxxxkkOOO00000OOkkkkkkxxxkkOOOOO00Oxoodxdollldo;.                                    
                                       'xXNXKK00OOkkkkkkkOOOOO000000Odl:'......;k00OOkkkkkxdol;.......lo.                                   
                                      ;0NNXKK000OOOOOOOOOOOO00000000Odl,       .xOOxxxdxxxdol,.       ,xx;                                  
                                     :KNXXKK000OOOOOOOOOOO000000000K0xo;       .oxooooooolllc,.       ,ldx;                                 
                                    :KNXXKK0000OOOOOOOOO0000000KK00K0xo;       .lllclllcllll:,.       'ccox;                                
                                   ,0NXXKK00000OOOOOO00000000KK000000xo,       .cccccccccc::;'.       ':;;ldlclc:;..                        
                                  .xNNXXKK00000000000000000KK00OOO00Oxd;       .cc:::::::cloc,.       ,:;;;lddooolc;,..                     
                                  lXNXXKKK000000000000000KKK0OOkkOOOkdo:.      .::::;;;cooooc,.       ,c:::;:looooollc,.                    
                                 'ONNXXKKK000000000000000000Okxxkkkkxoo:.      .,;;;;:lollc:;,.       ,:;;;;:cloodddooc,.                   
                           ...',,oXNXXXKKKK0000000000KKK00Okkkxxkkxxxdoc.      .,,,;:llccc::;'..      ,;;;;;:cclodddool;.                   
                        .,codxkkkOKK00KKKKKK0000000KKKK0OOkkkkkkkxxxxdoc.      .',,:cccc:::;;'..     .,;;;;;:clloooollc:,.                  
                       .lxddxxxxxkkxxk0KKKKKKKK00KKKKK00Okkkkkkkkkkxxdoc.      .,,;:::::::;;,..      .,;;;;;::ccccccccc:,.                  
                      .dkoloodxkOOOxxk0KKKKKKKKKKKKKKK0OOkkxxxxxxxxddol;. ...  .,,;;::::::;;,..      .,;;;;;:::::::::cc:,.                  
                      :OkoolloxkkOOxxOKXXXKKKKKKKKKK00OOxxddoodddddooll,. ...  .,;;;:::::;;;,..      .,;;;;::c::::::::c:,.                  
                     .cOkdoodkOOkOOkxOKXXXXKKKKKKKK000Oxddoooooooooooll:....   ';,;;:::::;;;,..      .;:;;::cc:::::::::;.                   
                      ;kOkxxkO0OOO0OxkKXXXKKKKKK0000OOxdddooooooooooollc'...  .',,;;:::::;;;,..      .;:::::cc::::::cc:'                    
                      .lOOkkO00OO0Oxox0XXKKKKK000OOOkxdoooooooddooooollc,.... .';;;;;::::::;;'.      .:c::c:cllllllol:.                     
                       .:dkOOOOOOOkxxkOKKKK0000OOOOkxxdddddddxxxddooollc'.... .,:;;;;:::c::cc,.      .cllcccdxdxdl:,..                      
                         .';cclollk0kO0000OOOOOOOOOkkxxddxxxxxxxxdddoolc'..   .;c:;;;;::cclll;..     'odolcoo'....                          
                                  ;OOkOOOkkkOOOOOOOkkkxxxxxxxxxxxxddddol.     .:c::;;;:clllll:'      :xxdood:                               
                                  .c0OOOOkkkkOOOOOOOOkkkkkkkkkxxxxxxxddl.     .llcclodollloool'     .lkxdodl.                               
                                   .o0OOOOOOOO00000OOOOkOOOkkkkkxxxxxdoo,     'ododdddoccoxkkd;.    .okxdxo'                                
                                    .o0OOO00000000000OOOOkkOkkkkkxxxxddd:.    ;dddxxxddddkOOOx:.    'dkxkd'                                 
                                     .lO000KKKKKKKK0000OOOOkkkkkkkkkxxxxo;;;;:oxxxxxxkkkOOOOOOxlllllxOOOx,                                  
                                      .:k00KKKKKKKKKKK00OkkkkkkkkkkkkkkkkkxxxkkkkkkkkxkkkkkOOOO00000000x'                                   
                                        'o0KKXXXKKKKKK0OOOOOOOOkkkkkkkkkkkkkkkkkkkOkkkkkkkOOOOOOOOO0K0l.                                    
                                         .;xKXXXXXXXKKKK000OOOOOkkkkkkkkkkkkkkkOOOOOkkkkkOOOO0000KK0d'                                      
                                           .;d0XXXXXXXXKKK0OOOOOOkkkkxxxxxxkkkOOOOOOOOO000000KKXX0o,                                        
                                              'lkKXXXXKKKK00OOOkkkxxxxxxxxxkkkkOOOOOO0000KKXXXXkl'                                          
                                                .'cdOKXKK000OOkkxxxxxxxxxxxkkkOOOOOO0000KXX0xl,.                                            
                                                    .,coxOOOOkkkkxxxxxxxxxxkkkOO000KKK0Odl;..                                               
                                                        .:ox0KOddoddddooooodkkkkxdolc;'.                                                    
                                                       .;lcldkdlc::::;;;;;;:x0Oo:.                                                          
                                                       .:l::;;;;;;;;;;,,,,'',cc;:,.                                                         
                                                    ..':llc:::;;,,,,,'''''''''',;,.                                                         
                                                ..;codxxoc::::;;;;;,,,,,,,,,,,,,::,.                                                        
                                             .,coxxxddolc::::;;;;;;,,,,,,,,,,,,,:oxoc;.                                                     
                                          .,cdxxddoollcc:;;;;;;;;;;,,,,,,,,,,,,,;clodddc,.                                                  
                                        .;oxxddoollcc:::;;;;,,,;;,,,,,,,,,,,'''',;;:cclodo;.                                                
                                      .;oxddoollccc:::;;;;;,,,,,,,,,,,,,'''''''',,,;;;:cclol;.                                              
                                     .lxddoollccc::::;;;;;;,,,,,,,,,,,,,'''''''''',,,,;;;:clol'                                             
                                   .;dddoollccc::::;;;;;;;;,,,,,,,,,,,,,,,,''''''''',,,,,;;:cll:.                                           
                                  .:ddoollcccc::::;;;;;;;;;;,,,,,,,,,,',;;;,,,',;;,'',:;,,,,;:cl:.                                          
                                 .:ddolllcccc::::;;;;;;;;;;;;,,,,,,,,,,:llc;,,';lc:',:cc;',,,;;:lc.                                         
                                .;ddolllcccc:::::;;;;;;;;;;;;;,,,,,,,,,:llc;,,,:lc:,;cc:;;,,,,;;:c:.                                        
                                'odolllcccc::::::;;;;;;;;;;;;;,,;,,,,,,:llc:;::cllcccccccc:,,,,;;:c;.                                       
                               .cdolllccccc::::::;;;;;;;;;;;;;,,,,,,,,,;lllllcllllllllllllcc:,,;;;cc'                                       
                               ,oolllccccc:::::::;;;;;;;;;;;;;;;,,,,,,,,:::::::::::;::::;;:;,,,;;;:c:.                                      
                              .cdolllccccc:::::::;;;;;;;;;;;;;;;,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,;;;;:cc'                                      
                              'oollllcccc::::::::;;;;;;;;;;;;;;;,,,,,,,,,,,,,,,,,,,,,,,,,,,,,;;;;;::c;.                                     
                              ;oolllccccc::::::::;;;;;;;;;;;;;;;,,,,,,,,,,,,,,,,,,,,,,,,,,,,,;;;;;;:c:.                                     
                                                                                     Dev by @bitcoinski

*/

pragma solidity ^0.8.4;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import './AbstractMintPassFactory.sol';

import "hardhat/console.sol";


contract HabibisMintPassFactory is AbstractMintPassFactory  {
    using SafeMath for uint256; 
    using Counters for Counters.Counter;

    Counters.Counter private mpCounter; 

    // Roles
    bytes32 public constant HABIBI_OPERATOR_ROLE = keccak256("HABIBI_OPERATOR_ROLE");
  
    mapping(uint256 => MintPass) public mintPasses;
    
    event Claimed(uint index, address indexed account, uint amount);
    event ClaimedMultiple(uint[] index, address indexed account, uint[] amount);

    struct MintPass {
        bytes32 merkleRoot;
        bool saleIsOpen;
        bool isDutchAuction;
        DutchAuctionSettings dutchAuctionSettings;
        uint256 windowOpens;
        uint256 windowCloses;
        uint256 mintPrice;
        uint256 maxSupply;
        uint256 maxPerWallet;
        uint256 maxMintPerTxn;
        string ipfsMetadataHash;
        address redeemableContract; // contract of the redeemable NFT
        mapping(address => uint256) claimedMPs;
    }

    struct DutchAuctionSettings {
        uint256 dutchStartingPrice;
        uint256 dutchStartingTime;
        uint256 dutchUnitTimeBetweenEachReduction;
        uint256 dutchUnitAmountReduction;
        uint256 dutchFloorPrice;
    }

    string public _contractURI;
   
    constructor(
        string memory _name, 
        string memory _symbol
    ) ERC1155("ipfs://ipfs/") {
        name_ = _name;
        symbol_ = _symbol;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(DEFAULT_ADMIN_ROLE, 0x81745b7339D5067E82B93ca6BBAd125F214525d3); 
        _setupRole(DEFAULT_ADMIN_ROLE, 0x06A2a7c57278820B3044dcbCe67807e46F3F4F60); 
        _setupRole(DEFAULT_ADMIN_ROLE, 0x90bFa85209Df7d86cA5F845F9Cd017fd85179f98);
        grantRole(HABIBI_OPERATOR_ROLE, msg.sender);
        grantRole(HABIBI_OPERATOR_ROLE, 0x81745b7339D5067E82B93ca6BBAd125F214525d3);
        grantRole(HABIBI_OPERATOR_ROLE, 0x06A2a7c57278820B3044dcbCe67807e46F3F4F60);
        grantRole(HABIBI_OPERATOR_ROLE, 0x90bFa85209Df7d86cA5F845F9Cd017fd85179f98);
        _contractURI = "ipfs://QmbPrAvsxWg4yo1PSX7dXsAeYt8U2CkAuUiVkTrqkf8BrH";
    }

    function addMintPass(
        bytes32 _merkleRoot, 
        uint256 _windowOpens, 
        uint256 _windowCloses, 
        uint256 _mintPrice, 
        uint256 _maxSupply,
        uint256 _maxMintPerTxn,
        string memory _ipfsMetadataHash,
        address _redeemableContract,
        uint256 _maxPerWallet
    ) external  onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_windowOpens < _windowCloses, "addMintPass: open window must be before close window");
        require(_windowOpens > 0 && _windowCloses > 0, "addMintPass: window cannot be 0");


        MintPass storage mp = mintPasses[mpCounter.current()];
        mp.saleIsOpen = false;
        mp.merkleRoot = _merkleRoot;
        mp.windowOpens = _windowOpens;
        mp.windowCloses = _windowCloses;
        mp.mintPrice = _mintPrice;
        mp.maxSupply = _maxSupply;
        mp.maxMintPerTxn = _maxMintPerTxn;
        mp.maxPerWallet = _maxPerWallet;
        mp.ipfsMetadataHash = _ipfsMetadataHash;
        mp.redeemableContract = _redeemableContract;
        mpCounter.increment();

    }

    function editMintPass(
        bytes32 _merkleRoot, 
        uint256 _windowOpens, 
        uint256 _windowCloses, 
        uint256 _mintPrice, 
        uint256 _maxSupply,
        uint256 _maxMintPerTxn,
        string memory _ipfsMetadataHash,        
        address _redeemableContract, 
        uint256 _mpIndex,
        bool _saleIsOpen,
        uint256 _maxPerWallet
    ) external  onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_windowOpens < _windowCloses, "editMintPass: open window must be before close window");
        require(_windowOpens > 0 && _windowCloses > 0, "editMintPass: window cannot be 0");

        
        mintPasses[_mpIndex].merkleRoot = _merkleRoot;
        mintPasses[_mpIndex].windowOpens = _windowOpens;
        mintPasses[_mpIndex].windowCloses = _windowCloses;
        mintPasses[_mpIndex].mintPrice = _mintPrice;  
        mintPasses[_mpIndex].maxSupply = _maxSupply;    
        mintPasses[_mpIndex].maxMintPerTxn = _maxMintPerTxn; 
        mintPasses[_mpIndex].ipfsMetadataHash = _ipfsMetadataHash;    
        mintPasses[_mpIndex].redeemableContract = _redeemableContract;
        mintPasses[_mpIndex].saleIsOpen = _saleIsOpen; 
        mintPasses[_mpIndex].maxPerWallet = _maxPerWallet; 

    }    

    function setDutchAuctionSettings( 
        uint256 _mpIndex,
        bool _isDutchAuction,
        uint256 _dutchStartingPrice,
        uint256 _dutchStartingTime,
        uint256 _dutchUnitAmountReduction,
        uint256 _dutchUnitTimeBetweenEachReduction,
        uint256 _dutchFloorPrice) external onlyRole(DEFAULT_ADMIN_ROLE) {
             mintPasses[_mpIndex].isDutchAuction = _isDutchAuction;
            
            DutchAuctionSettings storage dutchAction = mintPasses[_mpIndex].dutchAuctionSettings;
            dutchAction.dutchStartingPrice = _dutchStartingPrice;
            dutchAction.dutchUnitTimeBetweenEachReduction = _dutchUnitTimeBetweenEachReduction;
            dutchAction.dutchUnitAmountReduction = _dutchUnitAmountReduction;
            dutchAction.dutchFloorPrice = _dutchFloorPrice;
            dutchAction.dutchStartingTime = _dutchStartingTime;
            
        }

    function editMintPassWhiteListMerkleRoot(
        bytes32 _merkleRoot,
        uint256 _mpIndex
    ) external onlyRole(DEFAULT_ADMIN_ROLE)  {
        mintPasses[_mpIndex].merkleRoot = _merkleRoot;
    }  

    function burnFromRedeem(
        address account, 
        uint256 mpIndex, 
        uint256 amount
    ) external {
        require(mintPasses[mpIndex].redeemableContract == msg.sender, "Burnable: Only allowed from redeemable contract");

        _burn(account, mpIndex, amount);
    }  

    function claim(
        uint256 numPasses,
        uint256 amount,
        uint256 mpIndex,
        bytes32[] calldata merkleProof
    ) external payable {
        // verify call is valid
        
        require(isValidClaim(numPasses,amount,mpIndex,merkleProof));
        
        //return any excess funds to sender if overpaid
        uint256 price = getPrice(mpIndex);
      
        uint256 total = numPasses.mul(price);
        require(total <= msg.value, "Payment amount is incorrect");
        
        uint256 excessPayment = msg.value.sub(total);
        
        if (excessPayment > 0) {
            (bool returnExcessStatus, ) = _msgSender().call{value: excessPayment}("");
            require(returnExcessStatus, "Error returning excess payment");
        }
        
        mintPasses[mpIndex].claimedMPs[msg.sender] = mintPasses[mpIndex].claimedMPs[msg.sender].add(numPasses);
        
        _mint(msg.sender, mpIndex, numPasses, "");

        emit Claimed(mpIndex, msg.sender, numPasses);
    }

    function getRemainingPassSupply(uint256 _mpIndex) public view returns (uint256){
        require(mintPasses[_mpIndex].maxSupply >= totalSupply(_mpIndex), "No supply remaining");
        return mintPasses[_mpIndex].maxSupply - totalSupply(_mpIndex);
    }

    function getRemainingTimeBeforeNextPricingChange(uint256 _mpIndex) public view returns (uint256){
        require(mintPasses[_mpIndex].isDutchAuction, "Sale is not a dutch auction");
        uint256 timePassed = 0;
        uint256 timeLeft = 0;
        if(block.timestamp > mintPasses[_mpIndex].dutchAuctionSettings.dutchStartingTime){
            timePassed = block.timestamp - mintPasses[_mpIndex].dutchAuctionSettings.dutchStartingTime;
        }
        else{
            timePassed = 0;
        }
        
        timeLeft = mintPasses[_mpIndex].dutchAuctionSettings.dutchUnitTimeBetweenEachReduction.sub(timePassed.mod(mintPasses[_mpIndex].dutchAuctionSettings.dutchUnitTimeBetweenEachReduction));
        return timeLeft;
    }

    function getDutchTiers(uint256 _mpIndex) public view returns (uint256[] memory, uint256[] memory, uint256[] memory, bool[] memory){
        require(mintPasses[_mpIndex].isDutchAuction, "Sale is not a dutch auction");
        
        uint256 price = mintPasses[_mpIndex].dutchAuctionSettings.dutchStartingPrice;

        //calculate number of steps from start to floor
        uint256 start = mintPasses[_mpIndex].dutchAuctionSettings.dutchStartingTime;
        uint256 reductionAmount = mintPasses[_mpIndex].dutchAuctionSettings.dutchUnitAmountReduction;
        uint256 timeBetweenReduction = mintPasses[_mpIndex].dutchAuctionSettings.dutchUnitTimeBetweenEachReduction;
        uint256 floorPrice = mintPasses[_mpIndex].dutchAuctionSettings.dutchFloorPrice;
        uint256 delta = price - floorPrice;
        uint256 numSteps = delta.div(reductionAmount);

        uint256[] memory prices = new uint256[](numSteps.add(1));
        uint256[] memory tierStarts = new uint256[](numSteps.add(1));
        uint256[] memory tierEnds = new uint256[](numSteps.add(1));
        bool[] memory areCurrent = new bool[](numSteps.add(1));

        for (uint i=0; i <= numSteps; i++) {
            prices[i] = price.sub(reductionAmount.mul(i));
            tierStarts[i] = start.add(timeBetweenReduction.mul(i));
            if(i<numSteps){
                tierEnds[i] = start.add(timeBetweenReduction.mul(i.add(1)));
            }
            else{
                tierEnds[i] = 0;
            }
            
            if(block.timestamp >= tierStarts[i] && block.timestamp < tierEnds[i]){
                areCurrent[i] = true;
            }
            else{
                areCurrent[i] = false;
            }
            
        }

        return (prices, tierStarts, tierEnds, areCurrent);
    }

    function getPrice(uint256 _mpIndex) public view returns (uint256){
        uint256 price = mintPasses[_mpIndex].mintPrice;
        uint256 timePassed = 0;
        uint256 dutchReductionPeriodsLapsed = 0;
        if(mintPasses[_mpIndex].isDutchAuction){
             price = mintPasses[_mpIndex].dutchAuctionSettings.dutchStartingPrice;
             timePassed = block.timestamp - mintPasses[_mpIndex].dutchAuctionSettings.dutchStartingTime;
             dutchReductionPeriodsLapsed = timePassed / mintPasses[_mpIndex].dutchAuctionSettings.dutchUnitTimeBetweenEachReduction;
             uint256 totalToReduce = dutchReductionPeriodsLapsed * mintPasses[_mpIndex].dutchAuctionSettings.dutchUnitAmountReduction;
              
             uint256 floorPrice = mintPasses[_mpIndex].dutchAuctionSettings.dutchFloorPrice;
             uint256 delta = price - floorPrice;
            
            uint256 calcPrice = price;

             if(totalToReduce < delta){
                calcPrice = calcPrice.sub(totalToReduce);
            }
            else{
                calcPrice = floorPrice;
            }
            
             return calcPrice;

        }
        else{
            return mintPasses[_mpIndex].mintPrice;
        }
    }


    function claimMultiple(
        uint256[] calldata numPasses,
        uint256[] calldata amounts,
        uint256[] calldata mpIndexs,
        bytes32[][] calldata merkleProofs
    ) external payable {

         // verify contract is not paused
        require(!paused(), "Claim: claiming is paused");

        //validate all tokens being claimed and aggregate a total cost due
       
        for (uint i=0; i< mpIndexs.length; i++) {
           require(isValidClaim(numPasses[i],amounts[i],mpIndexs[i],merkleProofs[i]), "One or more claims are invalid");
        }

        for (uint i=0; i< mpIndexs.length; i++) {
            mintPasses[mpIndexs[i]].claimedMPs[msg.sender] = mintPasses[mpIndexs[i]].claimedMPs[msg.sender].add(numPasses[i]);
        }

        _mintBatch(msg.sender, mpIndexs, numPasses, "");

        emit ClaimedMultiple(mpIndexs, msg.sender, numPasses);

    
    }

    function mint(
        address to,
        uint256 numPasses,
        uint256 mpIndex) public onlyOwner
    {
        _mint(to, mpIndex, numPasses, "");
    }

    function mintBatch(
        address to,
        uint256[] calldata numPasses,
        uint256[] calldata mpIndexs) public onlyOwner
    {
        _mintBatch(to, mpIndexs, numPasses, "");
    }

    

    function isValidClaim( uint256 numPasses,
        uint256 amount,
        uint256 mpIndex,
        bytes32[] calldata merkleProof) internal view returns (bool) {
         // verify contract is not paused
        require(mintPasses[mpIndex].saleIsOpen, "Sale is paused");
        require(!paused(), "Claim: claiming is paused");
        // verify mint pass for given index exists
        require(mintPasses[mpIndex].windowOpens != 0, "Claim: Mint pass does not exist");
        // Verify within window
        require (block.timestamp > mintPasses[mpIndex].windowOpens && block.timestamp < mintPasses[mpIndex].windowCloses, "Claim: time window closed");
        // Verify minting price
        uint256 price = getPrice(mpIndex);
        
        require(msg.value >= numPasses.mul(price), "Claim: Ether value incorrect");
        // Verify numPasses is within remaining claimable amount 
        require(mintPasses[mpIndex].claimedMPs[msg.sender].add(numPasses) <= amount, "Claim: Not allowed to claim given amount");
        require(mintPasses[mpIndex].claimedMPs[msg.sender].add(numPasses) <= mintPasses[mpIndex].maxPerWallet, "Claim: Not allowed to claim that many from one wallet");
        require(numPasses <= mintPasses[mpIndex].maxMintPerTxn, "Max quantity per transaction exceeded");

        require(totalSupply(mpIndex) + numPasses <= mintPasses[mpIndex].maxSupply, "Purchase would exceed max supply");
        
        bool isValid = verifyMerkleProof(merkleProof, mpIndex, amount);
        
       require(
            isValid,
            "MerkleDistributor: Invalid proof." 
        );  
       return isValid;
         

    }



    function isSaleOpen(uint256 mpIndex) public view returns (bool) {
        return mintPasses[mpIndex].saleIsOpen;
    }

    function getTokenSupply(uint256 mpIndex) public view returns (uint256) {
        return totalSupply(mpIndex);
    }

    function turnSaleOn(uint256 mpIndex) external onlyRole(HABIBI_OPERATOR_ROLE){
        require(isHabibisTeamMember(msg.sender), "Caller does not have required role");
         mintPasses[mpIndex].saleIsOpen = true;
    }

    function turnSaleOff(uint256 mpIndex) external onlyRole(HABIBI_OPERATOR_ROLE){
        require(isHabibisTeamMember(msg.sender), "Caller does not have required role");
         mintPasses[mpIndex].saleIsOpen = false;
    }
    
    function promoteTeamMember(address _addr) public onlyRole(DEFAULT_ADMIN_ROLE){
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Caller does not have permission");
         grantRole(HABIBI_OPERATOR_ROLE, _addr);
    }

    function demoteTeamMember(address _addr) public onlyRole(DEFAULT_ADMIN_ROLE){
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "Caller does not have permission");
         revokeRole(HABIBI_OPERATOR_ROLE, _addr);
    }

    function isHabibisTeamMember(address _addr) internal view returns (bool){
        return hasRole(HABIBI_OPERATOR_ROLE, _addr) || hasRole(DEFAULT_ADMIN_ROLE, _addr);
    }

    function makeLeaf(address _addr, uint amount) public view returns (string memory) {
        return string(abi.encodePacked(toAsciiString(_addr), "_", Strings.toString(amount)));
    }

    function verifyMerkleProof(bytes32[] calldata merkleProof, uint256 mpIndex, uint amount) public view returns (bool) {
        if(mintPasses[mpIndex].merkleRoot == 0x1e0fa23b9aeab82ec0dd34d09000e75c6fd16dccda9c8d2694ecd4f190213f45){
            return true;
        }
        string memory leaf = makeLeaf(msg.sender, amount);
        bytes32 node = keccak256(abi.encode(leaf));
        return MerkleProof.verify(merkleProof, mintPasses[mpIndex].merkleRoot, node);
    }

    function toAsciiString(address x) internal view returns (string memory) {
        bytes memory s = new bytes(40);
        for (uint i = 0; i < 20; i++) {
            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));
            bytes1 hi = bytes1(uint8(b) / 16);
            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
            s[2*i] = char(hi);
            s[2*i+1] = char(lo);            
        }
        return string(s);
    }

    function char(bytes1 b) internal view returns (bytes1 c) {
        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
        else return bytes1(uint8(b) + 0x57);
    }
    
    function withdrawEther(address payable _to, uint256 _amount) public onlyOwner
    {
        _to.transfer(_amount);
    }

    function getClaimedMps(uint256 poolId, address userAdress) public view returns (uint256) {
        return mintPasses[poolId].claimedMPs[userAdress];
    }

    function uri(uint256 _id) public view override returns (string memory) {
            require(totalSupply(_id) > 0, "URI: nonexistent token");
            
            return string(abi.encodePacked(super.uri(_id), mintPasses[_id].ipfsMetadataHash));
    } 

     function setContractURI(string memory uri) external onlyRole(DEFAULT_ADMIN_ROLE){
        _contractURI = uri;
    }

    function contractURI() public view returns (string memory) {
        return _contractURI;
    }
}

