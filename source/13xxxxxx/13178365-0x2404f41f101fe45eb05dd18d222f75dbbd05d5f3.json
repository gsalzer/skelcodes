{"status":"1","message":"OK","result":[{"SourceCode":"{\"interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\n// Reflection\\ninterface IReflect {\\n    function tokenFromReflection(uint256 rAmount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getRate() external view returns (uint256);\\n}\\n\\n/// ChainLink ETH/USD oracle\\ninterface IChainLink {\\n    // chainlink ETH/USD oracle\\n    // answer|int256 :  216182781556 - 8 decimals\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\\n/// USDT is not ERC-20 compliant, not returning true on transfers\\ninterface IUsdt {\\n    function transfer(address, uint256) external;\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\\n// Check ETH send to first presale\\n// Yes, there is a typo\\ninterface IPresale1 {\\n    function blanceOf(address user) external view returns (uint256 amt);\\n}\\n\\n// Check tokens bought in second presale\\n// There is bug in ETH deposits, we need handle it\\n// Also \\\"tokensBoughtOf\\\" calculation is broken, so we do all math\\ninterface IPresale2 {\\n    function ethDepositOf(address user) external view returns (uint256 amt);\\n\\n    function usdDepositOf(address user) external view returns (uint256 amt);\\n}\\n\\n// Check final sale tokens bought\\ninterface ISale {\\n    function tokensBoughtOf(address user) external view returns (uint256 amt);\\n}\\n\\ninterface IClaimSale {\\n    function addLock(\\n        address user,\\n        uint256 reflection,\\n        uint256 locktime\\n    ) external;\\n}\\n\"},\"owned.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\ncontract Owned {\\n    address public owner;\\n    address public newOwner;\\n\\n    event OwnershipChanged(address from, address to);\\n\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipChanged(address(0), msg.sender);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        _;\\n    }\\n\\n    // owner can give super-rights to someone\\n    function giveOwnership(address user) external onlyOwner {\\n        require(user != address(0), \\\"User renounceOwnership\\\");\\n        newOwner = user;\\n    }\\n\\n    // new owner need to accept\\n    function acceptOwnership() external {\\n        require(msg.sender == newOwner, \\\"Only NewOwner\\\");\\n        emit OwnershipChanged(owner, newOwner);\\n        owner = msg.sender;\\n        delete newOwner;\\n    }\\n}\\n\"},\"reentryGuard.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\ncontract Guarded {\\n    uint256 constant NOT_ENTERED = 1;\\n    uint256 constant ENTERED = 2;\\n    uint256 entryState = NOT_ENTERED;\\n\\n    modifier guarded() {\\n        require(entryState == NOT_ENTERED, \\\"Reentry\\\");\\n        entryState = ENTERED;\\n        _;\\n        entryState = NOT_ENTERED;\\n    }\\n}\\n\"},\"team-stake.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\n/**\\nApes Together Strong!\\n\\nAbout BigShortBets DeFi project:\\n\\nWe are creating a social\\u0026trading p2p platform that guarantees encrypted interaction between investors.\\nLogging in is possible via a cryptocurrency wallet (e.g. Metamask).\\nThe security level is one comparable to the Tor network.\\n\\nhttps://bigsb.io/ - Our Tool\\nhttps://bigshortbets.com - Project\\u0026Team info\\n\\nVideo explainer:\\nhttps://youtu.be/wbhUo5IvKdk\\n\\nZaorski, You Son of a bitch I’m in …\\n*/\\n\\npragma solidity 0.8.7;\\n\\nimport \\\"./owned.sol\\\";\\nimport \\\"./interfaces.sol\\\";\\nimport \\\"./reentryGuard.sol\\\";\\n\\ncontract TeamStake is Owned, Guarded {\\n    address immutable token;\\n\\n    constructor(address _token) {\\n        token = _token;\\n    }\\n\\n    /// Claim fees, keep contract balance at 10% of total supply\\n    function claim() external onlyOwner guarded {\\n        uint256 amt = claimable();\\n        require(amt \\u003e 0, \\\"Nothing to claim\\\");\\n        bool success = IERC20(token).transfer(msg.sender, amt);\\n        require(success, \\\"Transer failed\\\");\\n    }\\n\\n    /// We can only claim fees and we keep contract balance at 10% of supply\\n    function claimable() public view returns (uint256) {\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        uint256 supply = IERC20(token).totalSupply();\\n        if (balance \\u003e supply / 10) {\\n            return (balance - (supply / 10));\\n        } else return 0;\\n    }\\n\\n    /**\\n    @dev Function to recover accidentally send ERC20 tokens\\n    @param erc20 ERC20 token address\\n    */\\n    function rescueERC20(address erc20) external onlyOwner {\\n        require(erc20 != token, \\\"Lol, nope!\\\");\\n        uint256 amt = IERC20(erc20).balanceOf(address(this));\\n        require(amt \\u003e 0, \\\"Nothing to rescue\\\");\\n        IUsdt(erc20).transfer(owner, amt);\\n    }\\n\\n    /**\\n    @dev Function to recover any ETH send to contract\\n    */\\n    function rescueETH() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n}\\n\\n//This is fine!\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"giveOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"}],\"name\":\"rescueERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TeamStake","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000131157c6760f78f7ddf877c0019eba175ba4b6f6","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3c76911975bcf4ca6e06b925dd7778701e1573f1094a5d9e5a2298114c91ee47"}]}