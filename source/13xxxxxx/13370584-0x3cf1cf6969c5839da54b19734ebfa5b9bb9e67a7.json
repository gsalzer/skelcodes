{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed _owner, address indexed newOwner);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface tokenRecipient {\r\n    function receiveApproval(\r\n        address _from,\r\n        uint256 _value,\r\n        address _token,\r\n        bytes _extraData\r\n    ) public;\r\n}\r\n\r\ncontract TokenERC {\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    constructor() public {}\r\n    /**\r\n     * @dev Moves tokens `_value` from `_from` to `_to`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_to` cannot be the zero address.\r\n     * - `_from` must have a balance of at least `_value`.\r\n     */\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n        require(_to != 0x0);\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to].add(_value) > balanceOf[_to]);\r\n        uint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\r\n    }\r\n    /**\r\n     * @dev Moves tokens `_value` from `sender` to `_to`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address _to, uint256 _value) public {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n    /**\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have allowance for `_from`'s tokens of at least `_value`.\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]); // Check allowance\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    /**\r\n     * @dev Sets `_value` as the allowance of `_spender` over the `owner` s tokens.\r\n     *\r\n     */\r\n    function approve(address _spender, uint256 _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(\r\n        address _spender,\r\n        uint256 _value,\r\n        bytes _extraData\r\n    ) public returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\ncontract MyAdvancedToken is owned, TokenERC {\r\n    /**\r\n     * @dev name of the token.\r\n     */\r\n    string public name = \"MERITO\";\r\n    /**\r\n     * @dev symbol of the token.\r\n     */\r\n    string public symbol = \"MERI\";\r\n    /**\r\n     * @dev decimal of the token.\r\n     */\r\n    uint8 public decimals = 18;\r\n    /**\r\n     * @dev price of the token related to ERC.\r\n     */\r\n    uint256 public tokenPrice = 320;\r\n    /**\r\n     * @dev total supply of the token.\r\n     */\r\n    uint256 public totalSupply = 1500000000e18;\r\n    /**\r\n     * @dev status of the token lockup.\r\n     */\r\n    uint public lockedStatus = 0;\r\n    /**\r\n     * @dev Structure of the locked list.\r\n     */\r\n    struct LockList {\r\n        address account;\r\n        uint256 amount;\r\n    }\r\n    /**\r\n     * @dev lockuped account list.\r\n     */\r\n    LockList[] public lockupAccount;\r\n    /**\r\n     * @dev Sets balance of the owner.\r\n     */\r\n    constructor() public {\r\n        balanceOf[msg.sender] = totalSupply;\r\n    }\r\n    /**\r\n     * @dev Purcahse token and transfer when user send ERC to the contract address.\r\n     *  \r\n     * Requirements:\r\n     *\r\n     * - `msg.value` bigger than zero address.\r\n     */\r\n    function() public payable {\r\n        require(msg.value > 0);\r\n        uint256 amount = msg.value.mul(tokenPrice);\r\n        _transfer(owner, msg.sender, amount); // makes the transfers\r\n        (owner).transfer(address(this).balance);\r\n    }\r\n    /**\r\n     * @dev Moves tokens `_value` from `_from` to `_to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `lockedStatus` cannot be the 1.\r\n     * - `_to` cannot be the zero address.\r\n     * - Unlocked Amount of `_from` must bigger than `_value`.\r\n     */\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n        require(lockedStatus != 1);\r\n        require(_to != 0x0);\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to].add(_value) > balanceOf[_to]);\r\n        require(getUnlockedAmount(_from) >= _value);\r\n        uint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n    /** @dev Creates `mintedAmount` tokens and assigns them to `target`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     */\r\n    function mint(address target, uint256 mintedAmount) public onlyOwner {\r\n        balanceOf[target] = balanceOf[target].add(mintedAmount);\r\n        totalSupply = totalSupply.add(mintedAmount);\r\n        emit Transfer(0, this, mintedAmount);\r\n        emit Transfer(this, target, mintedAmount);\r\n    }\r\n    /** @dev Send `amount` tokens to `target` from owner\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the owner and `to` set to the target.\r\n     * Requirements:\r\n     *\r\n     * - Balance of `onwer` has to be bigger than amount.\r\n     */\r\n    function sendToken(address target, uint256 amount) public onlyOwner {\r\n        require(balanceOf[owner] >= amount);\r\n        require(target != 0x0);\r\n        _transfer(owner, target, amount);\r\n        emit Transfer(owner, target, amount);\r\n    }\r\n    function sendFrom(address from, uint256 amount) public onlyOwner {\r\n        require(from != 0x0);\r\n        require(balanceOf[from] >= amount);\r\n        _transfer(from, owner, amount);\r\n        emit Transfer(from, owner, amount);\r\n    }\r\n    /** @dev Remove all amount of tokens from target\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the target and `to` set to the owner.\r\n     */\r\n    function removeAllToken(address target) public onlyOwner {\r\n        _transfer(target, owner, balanceOf[target]);\r\n        emit Transfer(target, owner, balanceOf[target]);\r\n    }\r\n    /** @dev Remove `amount` of tokens from target\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the target and `to` set to the owner.\r\n     * Requirements:\r\n     *\r\n     * - Balance of `target` has to be bigger than amount.\r\n     */\r\n    function removeToken(address target, uint256 amount) public onlyOwner {\r\n        require(balanceOf[target] >= amount);\r\n        _transfer(target, owner, amount);\r\n        emit Transfer(target, owner, amount);\r\n    }\r\n    /** @dev Set lockup status of the all account as 1\r\n     *\r\n     */\r\n    function lockAll () public onlyOwner {\r\n        lockedStatus = 1;\r\n    }\r\n    /** @dev Set lockup status of the all account as 0\r\n     *\r\n     */\r\n    function unlockAll () public onlyOwner {\r\n        lockedStatus = 0;\r\n    }\r\n    /** @dev Lockup `amount` of the token from `account`\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Balance of `account` has to be bigger than `amount`.\r\n     */\r\n    function lockAccount (address account, uint256 amount) public onlyOwner {\r\n      require(balanceOf[account] >= amount);\r\n      uint flag = 0;\r\n      for (uint i = 0; i < lockupAccount.length; i++) {\r\n        if (lockupAccount[i].account == account) {\r\n          lockupAccount[i].amount = amount;\r\n          flag = flag + 1;\r\n          break;\r\n        }\r\n      }\r\n      if(flag == 0) {\r\n        lockupAccount.push(LockList(account, amount));\r\n      }\r\n    }\r\n    /** @dev Return amount of locked tokens from `account`\r\n     *\r\n     */\r\n    function getLockedAmount(address account) public view returns (uint256) {\r\n      uint256 res = 0;\r\n      for (uint i = 0; i < lockupAccount.length; i++) {\r\n        if (lockupAccount[i].account == account) {\r\n          res = lockupAccount[i].amount;\r\n          break;\r\n        }\r\n      }\r\n      return res;\r\n    }\r\n    /** @dev Return amount of unlocked tokens from `account`\r\n     *\r\n     */\r\n    function getUnlockedAmount(address account) public view returns (uint256) {\r\n      uint256 res = 0;\r\n      res = balanceOf[account].sub(getLockedAmount(account));\r\n      return res;\r\n    }\r\n    /** @dev Return number of locked account\r\n     *\r\n     */\r\n    function getLockedListLength() public view returns(uint) {\r\n        return lockupAccount.length;\r\n    } \r\n    /** @dev Owner can set the token price as `_tokenPrice`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_tokenPrice` has to be bigger than zero.\r\n     */\r\n    function setTokenPrice(uint256 _tokenPrice) public onlyOwner {\r\n        require(_tokenPrice > 0);\r\n        tokenPrice = _tokenPrice;\r\n    }\r\n    /** @dev Withdraw `amount` of ERC from smart contract to owner.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Balance of the smart contract has to be bigger than `amount`.\r\n     */\r\n    function withdrawBalance(uint256 amount) public onlyOwner {\r\n        require(address(this).balance >= amount);\r\n        (owner).transfer(amount);\r\n    }\r\n    /** @dev Withdraw all amount of ERC from smart contract to owner.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Balance of the smart contract has to be bigger than zero.\r\n     */\r\n    function withdrawAll() public onlyOwner {\r\n        require(address(this).balance >= 0);\r\n        (owner).transfer(address(this).balance);\r\n    }\r\n    /**\r\n     * @dev Destroys `_value` tokens from sender, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - sender must have at least `_value` tokens.\r\n     */\r\n    function burn(uint256 _value) external {\r\n        require(balanceOf[msg.sender] >= _value);\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        emit Transfer(msg.sender, address(0), _value);\r\n    }\r\n    /**\r\n     * @dev Destroys `_value` tokens from `_from`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_from` must have at least `_value` tokens.\r\n     */\r\n    function burnFrom(address _from, uint256 _value) external {\r\n        require(balanceOf[_from] >= _value);\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        emit Transfer(_from, address(0), _value);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"removeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"mintedAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUnlockedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenPrice\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLockedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockupAccount\",\"outputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"lockAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"removeAllToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLockedListLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"MyAdvancedToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://d41472be656fb044bfd408cbc8a10514becc21169d8e1b2e5782b0a87fdead4a"}]}