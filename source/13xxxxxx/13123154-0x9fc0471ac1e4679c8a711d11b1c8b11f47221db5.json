{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/producers/editions/allocated/AllocatedEditionsFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {ITributaryRegistry} from \\\"../../../interface/ITributaryRegistry.sol\\\";\\nimport {Governable} from \\\"../../../lib/Governable.sol\\\";\\nimport {AllocatedEditionsProxy} from \\\"./AllocatedEditionsProxy.sol\\\";\\nimport {AllocatedEditionsStorage} from \\\"./AllocatedEditionsStorage.sol\\\";\\nimport {IERC2309} from \\\"../../../external/interface/IERC2309.sol\\\";\\n\\n/**\\n * @title AllocatedEditionsFactory\\n * @author MirrorXYZ\\n */\\ncontract AllocatedEditionsFactory is Governable, IERC2309 {\\n    //======== Structs ========\\n\\n    struct Parameters {\\n        // NFT Metadata\\n        bytes nftMetaData;\\n        // Edition Data\\n        uint256 allocation;\\n        uint256 quantity;\\n        uint256 price;\\n        // Admint Data\\n        bytes adminData;\\n    }\\n\\n    //======== Events ========\\n\\n    event AllocatedEditionDeployed(\\n        address allocatedEditionProxy,\\n        string name,\\n        string symbol,\\n        address operator\\n    );\\n\\n    //======== Mutable storage =========\\n\\n    /// @notice Gets set within the block, accessed from the proxy and then deleted.\\n    Parameters public parameters;\\n\\n    /// @notice Minimum fee percentage collected by the treasury when withdrawing funds.\\n    uint256 public minFeePercentage = 250;\\n\\n    /// @notice Contract logic for the edition deployed. \\n    address public logic;\\n\\n    address public tributaryRegistry;\\n\\n    address public treasuryConfig;\\n\\n    /// @notice Base URI with NFT data\\n    string baseURI;\\n\\n    /// @notice OpenSea Proxy Registry\\n    address public proxyRegistry;\\n\\n    //======== Constructor =========\\n    constructor(\\n        address owner_,\\n        address logic_,\\n        address tributaryRegistry_,\\n        address treasuryConfig_,\\n        string memory baseURI_,\\n        address proxyRegistry_\\n    ) Governable(owner_) {\\n        logic = logic_;\\n        tributaryRegistry = tributaryRegistry_;\\n        treasuryConfig = treasuryConfig_;\\n        baseURI = baseURI_;\\n        proxyRegistry = proxyRegistry_;\\n    }\\n\\n    //======== Configuration =========\\n\\n    function setMinimumFeePercentage(uint256 newMinFeePercentage)\\n        public\\n        onlyGovernance\\n    {\\n        minFeePercentage = newMinFeePercentage;\\n    }\\n\\n    function setLogic(address newLogic) public onlyGovernance {\\n        logic = newLogic;\\n    }\\n\\n    function setTreasuryConfig(address newTreasuryConfig)\\n        public\\n        onlyGovernance\\n    {\\n        treasuryConfig = newTreasuryConfig;\\n    }\\n\\n    function setTributaryRegistry(address newTributaryRegistry)\\n        public\\n        onlyGovernance\\n    {\\n        tributaryRegistry = newTributaryRegistry;\\n    }\\n\\n    function setProxyRegistry(address newProxyRegistry)\\n        public\\n        onlyGovernance\\n    {\\n        proxyRegistry = newProxyRegistry;\\n    }\\n\\n    //======== Proxy Deployments =========\\n\\n    /// @notice Creates an edition by deploying a new proxy.\\n   function createEdition(\\n        AllocatedEditionsStorage.NFTMetadata memory metadata,\\n        AllocatedEditionsStorage.EditionData memory editionData,\\n        AllocatedEditionsStorage.AdminData memory adminData\\n    ) external returns (address allocatedEditionsProxy) {\\n        require(\\n            adminData.feePercentage >= minFeePercentage,\\n            \\\"fee is too low\\\"\\n        );\\n\\n        require(editionData.allocation < editionData.quantity, \\\"allocation must be less than quantity\\\");\\n\\n        parameters = Parameters({\\n            // NFT Metadata\\n            nftMetaData: abi.encode(\\n                metadata.name,\\n                metadata.symbol,\\n                baseURI,\\n                metadata.contentHash\\n            ),\\n            // Edition Data\\n            allocation: editionData.allocation,\\n            quantity: editionData.quantity,\\n            price: editionData.price,\\n            // Admin Data\\n            adminData: abi.encode(\\n                adminData.operator,\\n                adminData.tributary,\\n                adminData.fundingRecipient,\\n                adminData.feePercentage,\\n                treasuryConfig\\n            )\\n        });\\n\\n        // deploys proxy\\n        allocatedEditionsProxy = address(\\n            new AllocatedEditionsProxy{\\n                salt: keccak256(abi.encode(metadata.symbol, adminData.operator))\\n            }(adminData.operator, proxyRegistry)\\n        );\\n\\n        delete parameters;\\n\\n        emit AllocatedEditionDeployed(\\n            allocatedEditionsProxy,\\n            metadata.name,\\n            metadata.symbol,\\n            adminData.operator\\n        );\\n\\n        ITributaryRegistry(tributaryRegistry).registerTributary(\\n            allocatedEditionsProxy,\\n            adminData.tributary\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ITributaryRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ITributaryRegistry {\\n    function addRegistrar(address registrar) external;\\n\\n    function removeRegistrar(address registrar) external;\\n\\n    function addSingletonProducer(address producer) external;\\n\\n    function removeSingletonProducer(address producer) external;\\n\\n    function registerTributary(address producer, address tributary) external;\\n\\n    function producerToTributary(address producer)\\n        external\\n        returns (address tributary);\\n\\n    function singletonProducer(address producer) external returns (bool);\\n\\n    function changeTributary(address producer, address newTributary) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {Ownable} from \\\"../lib/Ownable.sol\\\";\\nimport {IGovernable} from \\\"../lib/interface/IGovernable.sol\\\";\\n\\ncontract Governable is Ownable, IGovernable {\\n    // ============ Mutable Storage ============\\n\\n    // Mirror governance contract.\\n    address public override governor;\\n\\n    // ============ Modifiers ============\\n\\n    modifier onlyGovernance() {\\n        require(isOwner() || isGovernor(), \\\"caller is not governance\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovernor() {\\n        require(isGovernor(), \\\"caller is not governor\\\");\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    constructor(address owner_) Ownable(owner_) {}\\n\\n    // ============ Administration ============\\n\\n    function changeGovernor(address governor_) public override onlyGovernance {\\n        governor = governor_;\\n    }\\n\\n    // ============ Utility Functions ============\\n\\n    function isGovernor() public view override returns (bool) {\\n        return msg.sender == governor;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/editions/allocated/AllocatedEditionsProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {IERC2309} from \\\"../../../external/interface/IERC2309.sol\\\";\\nimport {AllocatedEditionsStorage} from \\\"./AllocatedEditionsStorage.sol\\\";\\nimport {IAllocatedEditionsFactory} from \\\"./interface/IAllocatedEditionsFactory.sol\\\";\\nimport {Governable} from \\\"../../../lib/Governable.sol\\\";\\nimport {Pausable} from \\\"../../../lib/Pausable.sol\\\";\\nimport {IAllocatedEditionsLogicEvents} from \\\"./interface/IAllocatedEditionsLogic.sol\\\";\\nimport {IERC721Events} from \\\"../../../external/interface/IERC721.sol\\\";\\n\\n/**\\n * @title AllocatedEditionsProxy\\n * @author MirrorXYZ\\n */\\ncontract AllocatedEditionsProxy is\\n    AllocatedEditionsStorage,\\n    Governable,\\n    Pausable,\\n    IAllocatedEditionsLogicEvents,\\n    IERC721Events,\\n    IERC2309\\n{\\n    event Upgraded(address indexed implementation);\\n\\n    /// @notice IERC721Metadata\\n    string public name;\\n    string public symbol;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    constructor(address owner_, address proxyRegistry_)\\n        Governable(owner_)\\n        Pausable(true)\\n    {\\n        address implementation = IAllocatedEditionsFactory(msg.sender).logic();\\n        assembly {\\n            sstore(_IMPLEMENTATION_SLOT, implementation)\\n        }\\n\\n        emit Upgraded(implementation);\\n\\n        proxyRegistry = proxyRegistry_;\\n\\n        bytes memory nftMetaData;\\n        bytes memory adminData;\\n\\n        (\\n            // NFT Metadata\\n            nftMetaData,\\n            // Edition Data\\n            allocation,\\n            quantity,\\n            price,\\n            // Admin data\\n            adminData\\n        ) = IAllocatedEditionsFactory(msg.sender).parameters();\\n\\n        (name, symbol, baseURI, contentHash) = abi.decode(\\n            nftMetaData,\\n            (string, string, string, bytes32)\\n        );\\n\\n        (\\n            operator,\\n            tributary,\\n            fundingRecipient,\\n            feePercentage,\\n            treasuryConfig\\n        ) = abi.decode(\\n            adminData,\\n            (address, address, address, uint256, address)\\n        );\\n\\n        if (allocation > 0) {\\n            nextTokenId = allocation;\\n\\n            emit ConsecutiveTransfer(0, allocation - 1, address(0), operator);\\n        }\\n    }\\n\\n    fallback() external payable {\\n        assembly {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, 0, calldatasize())\\n            let result := delegatecall(\\n                gas(),\\n                sload(_IMPLEMENTATION_SLOT),\\n                ptr,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            let size := returndatasize()\\n            returndatacopy(ptr, 0, size)\\n\\n            switch result\\n            case 0 {\\n                revert(ptr, size)\\n            }\\n            default {\\n                return(ptr, size)\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/producers/editions/allocated/AllocatedEditionsStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title AllocatedEditionsStorage\\n * @author MirrorXYZ\\n */\\ncontract AllocatedEditionsStorage {\\n    // ============ Structs ============\\n\\n    /// @notice Contains general data about the NFT.\\n    struct NFTMetadata {\\n        string name;\\n        string symbol;\\n        bytes32 contentHash;\\n    }\\n\\n    /// @notice Contains information pertaining to the edition spec.\\n    struct EditionData {\\n        // The number of tokens pre-allocated to the minter.\\n        uint256 allocation;\\n        // The maximum number of tokens that can be sold.\\n        uint256 quantity;\\n        // The price at which each token will be sold, in ETH.\\n        uint256 price;\\n    }\\n\\n    /// @notice Contains information about funds disbursement.\\n    struct AdminData {\\n        // Operator of this contract, receives premint.\\n        address operator;\\n        // Address that receive gov tokens via treasury.\\n        address tributary;\\n        // The account that will receive sales revenue.\\n        address payable fundingRecipient;\\n        // The fee taken when withdrawing funds\\n        uint256 feePercentage;\\n    }\\n\\n    // ============ Storage for Setup ============\\n\\n    /// @notice NFTMetadata`\\n    string public baseURI;\\n    bytes32 contentHash;\\n\\n    /// @notice EditionData\\n    uint256 public allocation;\\n    uint256 public quantity;\\n    uint256 public price;\\n\\n    /// @notice EditionConfig\\n    address public operator;\\n    address public tributary;\\n    address payable public fundingRecipient;\\n    uint256 feePercentage;\\n\\n    /// @notice Treasury Config, provided at setup, for finding the treasury address.\\n    address treasuryConfig;\\n\\n    // ============ Mutable Runtime Storage ============\\n\\n    /// @notice `nextTokenId` increments with each token purchased, globally across all editions.\\n    uint256 internal nextTokenId;\\n    /// @notice The number of tokens that have moved outside of the pre-mint allocation.\\n    uint256 internal allocationsTransferred = 0;\\n\\n    /**\\n     * @notice A special mapping of burned tokens, to take care of burning within\\n     * the tokenId range of the allocation.\\n     */\\n    mapping(uint256 => bool) internal _burned;\\n\\n    // ============ Mutable Internal NFT Storage ============\\n\\n    mapping(uint256 => address) internal _owners;\\n    mapping(address => uint256) internal _balances;\\n    mapping(uint256 => address) internal _tokenApprovals;\\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\\n\\n    /// @notice Only allow one purchase per account.\\n    mapping(address => bool) internal purchased;\\n\\n    // ============ Delegation logic ============\\n    address public logic;\\n\\n    // OpenSea's Proxy Registry\\n    address public proxyRegistry;\\n}\\n\"\r\n    },\r\n    \"contracts/external/interface/IERC2309.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IERC2309 {\\n    event ConsecutiveTransfer(\\n        uint256 indexed fromTokenId,\\n        uint256 toTokenId,\\n        address indexed fromAddress,\\n        address indexed toAddress\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ncontract Ownable {\\n    address public owner;\\n    address private nextOwner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    // modifiers\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize contract by setting transaction submitter as initial owner.\\n     */\\n    constructor(address owner_) {\\n        owner = owner_;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Initiate ownership transfer by setting nextOwner.\\n     */\\n    function transferOwnership(address nextOwner_) external onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    /**\\n     * @dev Cancel ownership transfer by deleting nextOwner.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    /**\\n     * @dev Accepts ownership transfer by setting owner.\\n     */\\n    function acceptOwnership() external onlyNextOwner {\\n        delete nextOwner;\\n\\n        owner = msg.sender;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Renounce ownership by setting owner to zero address.\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        owner = address(0);\\n\\n        emit OwnershipTransferred(owner, address(0));\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the next owner.\\n     */\\n    function isNextOwner() public view returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/interface/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IGovernable {\\n    function changeGovernor(address governor_) external;\\n\\n    function isGovernor() external view returns (bool);\\n\\n    function governor() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/producers/editions/allocated/interface/IAllocatedEditionsFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {AllocatedEditionsStorage} from \\\"../AllocatedEditionsStorage.sol\\\";\\n\\ninterface IAllocatedEditionsFactory {\\n    function logic() external returns (address);\\n\\n    // AllocatedEditions data\\n    function parameters()\\n        external\\n        returns (\\n            // NFT Metadata\\n            bytes memory nftMetaData,\\n            // Edition Data\\n            uint256 allocation,\\n            uint256 quantity,\\n            uint256 price,\\n            // Config\\n            bytes memory configData\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IPausableEvents {\\n    /// @notice Emitted when the pause is triggered by `account`.\\n    event Paused(address account);\\n\\n    /// @notice Emitted when the pause is lifted by `account`.\\n    event Unpaused(address account);\\n}\\n\\ninterface IPausable {\\n    function paused() external returns (bool);\\n}\\n\\ncontract Pausable is IPausable, IPausableEvents {\\n    bool public override paused;\\n\\n    // Modifiers\\n\\n    modifier whenNotPaused() {\\n        require(!paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /// @notice Initializes the contract in unpaused state.\\n    constructor(bool paused_) {\\n        paused = paused_;\\n    }\\n\\n    // ============ Internal Functions ============\\n\\n    function _pause() internal whenNotPaused {\\n        paused = true;\\n\\n        emit Paused(msg.sender);\\n    }\\n\\n    function _unpause() internal whenPaused {\\n        paused = false;\\n\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/editions/allocated/interface/IAllocatedEditionsLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IAllocatedEditionsLogicEvents {\\n    event EditionPurchased(\\n        uint256 indexed tokenId,\\n        uint256 amountPaid,\\n        address buyer,\\n        address receiver\\n    );\\n\\n    event EditionCreatorChanged(\\n        address indexed previousCreator,\\n        address indexed newCreator\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/external/interface/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IERC721 {\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IERC721Events {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n}\\n\\ninterface IERC721Metadata {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\nabstract contract ERC165 is IERC165 {\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"logic_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tributaryRegistry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasuryConfig_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"proxyRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"allocatedEditionProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"AllocatedEditionDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor_\",\"type\":\"address\"}],\"name\":\"changeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"contentHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct AllocatedEditionsStorage.NFTMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct AllocatedEditionsStorage.EditionData\",\"name\":\"editionData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tributary\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundingRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"}],\"internalType\":\"struct AllocatedEditionsStorage.AdminData\",\"name\":\"adminData\",\"type\":\"tuple\"}],\"name\":\"createEdition\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"allocatedEditionsProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parameters\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"nftMetaData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"adminData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLogic\",\"type\":\"address\"}],\"name\":\"setLogic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinFeePercentage\",\"type\":\"uint256\"}],\"name\":\"setMinimumFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newProxyRegistry\",\"type\":\"address\"}],\"name\":\"setProxyRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTreasuryConfig\",\"type\":\"address\"}],\"name\":\"setTreasuryConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTributaryRegistry\",\"type\":\"address\"}],\"name\":\"setTributaryRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tributaryRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AllocatedEditionsFactory","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"0000000000000000000000002330ee705ffd040bb0cba8cb7734dfe00e7c4b57000000000000000000000000a8023f3e6d45257d1a7ae0523249c196c454e6f900000000000000000000000070cde508babc967605ddc7228cb93014ffea5ef800000000000000000000000081b251169d134ba5c9b7e28fc38138ba979a9afe00000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a5409ec958c83c3f309868babaca7c86dcb077c1000000000000000000000000000000000000000000000000000000000000002768747470733a2f2f6d6972726f722d6170692e636f6d2f65646974696f6e732f637573746f6d2f00000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}