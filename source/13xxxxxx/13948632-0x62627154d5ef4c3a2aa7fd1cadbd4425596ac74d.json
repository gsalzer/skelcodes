{"status":"1","message":"OK","result":[{"SourceCode":"{\"AbiDecoder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\nimport \\\"./Strings.sol\\\";\\n\\nlibrary AbiDecoder {\\n  /**\\n   * @notice Extract all params from calldata given a list of param types and raw calldata bytes\\n   */\\n  function getParamsFromCalldata(\\n    string[] memory paramTypes,\\n    bytes calldata data\\n  ) public pure returns (bytes[] memory) {\\n    uint256 numberOfParams = paramTypes.length;\\n    bytes[] memory results = new bytes[](numberOfParams);\\n    for (uint256 paramIdx = 0; paramIdx \\u003c numberOfParams; paramIdx++) {\\n      string memory paramType = paramTypes[paramIdx];\\n      bytes memory param = getParamFromCalldata(data, paramType, paramIdx);\\n      results[paramIdx] = param;\\n    }\\n    return results;\\n  }\\n\\n  /**\\n   * @notice Extract param bytes given calldata, param type and param index\\n   */\\n  function getParamFromCalldata(\\n    bytes calldata data,\\n    string memory paramType,\\n    uint256 paramIdx\\n  ) public pure returns (bytes memory) {\\n    uint256 paramsStartIdx = 0x04; // Start after method selector\\n    uint256 paramOffset = 0x20 * paramIdx;\\n    bytes memory paramDescriptorValue = bytes(\\n      data[paramsStartIdx + paramOffset:paramsStartIdx + paramOffset + 0x20]\\n    );\\n\\n    bool paramTypeIsStringOrBytes = Strings.stringsEqual(paramType, \\\"bytes\\\") ||\\n      Strings.stringsEqual(paramType, \\\"string\\\");\\n    bool paramTypeIsStringArrayOrBytesArray = Strings.stringsEqual(\\n      paramType,\\n      \\\"bytes[]\\\"\\n    ) || Strings.stringsEqual(paramType, \\\"string[]\\\");\\n    bool _paramTypeIsArray = paramTypeIsArray(paramType);\\n\\n    uint256 paramStartIdx = uint256(bytes32(paramDescriptorValue)) + 0x04;\\n    if (paramTypeIsStringOrBytes) {\\n      return extractParamForBytesType(data, paramStartIdx);\\n    } else if (paramTypeIsStringArrayOrBytesArray) {\\n      return extractParamForBytesArrayType(data, paramStartIdx);\\n    } else if (_paramTypeIsArray) {\\n      return extractParamForSimpleArray(data, paramStartIdx);\\n    } else {\\n      return paramDescriptorValue;\\n    }\\n  }\\n\\n  /**\\n   * @notice Extract param for \\\"bytes\\\" and \\\"string\\\" types given calldata and a param start index\\n   */\\n  function extractParamForBytesType(bytes calldata data, uint256 paramStartIdx)\\n    public\\n    pure\\n    returns (bytes memory)\\n  {\\n    uint256 paramEndIdx = paramStartIdx + 0x20;\\n    bytes32 bytesLengthBytes = bytes32(data[paramStartIdx:paramEndIdx]);\\n    uint256 bytesLength = uint256(bytesLengthBytes);\\n    bytes memory dataToAdd = abi.encodePacked(\\n      uint256(0x20),\\n      bytes32(bytesLengthBytes)\\n    );\\n    uint256 numberOfRowsOfBytes = (bytesLength / 32) + 1;\\n    for (uint256 rowIdx; rowIdx \\u003c numberOfRowsOfBytes; rowIdx++) {\\n      uint256 rowStartIdx = paramEndIdx + (0x20 * rowIdx);\\n      dataToAdd = abi.encodePacked(\\n        dataToAdd,\\n        data[rowStartIdx:rowStartIdx + 0x20]\\n      );\\n    }\\n    return dataToAdd;\\n  }\\n\\n  /**\\n   * @notice Extract param for \\\"bytes[]\\\" and \\\"string[]\\\" types given calldata and a param start index\\n   */\\n  function extractParamForBytesArrayType(\\n    bytes calldata data,\\n    uint256 paramStartIdx\\n  ) public pure returns (bytes memory) {\\n    uint256 paramEndIdx = paramStartIdx + 0x20;\\n    bytes32 arrayLengthBytes = bytes32(data[paramStartIdx:paramEndIdx]);\\n    uint256 arrayLength = uint256(arrayLengthBytes);\\n    bytes memory dataToAdd = abi.encodePacked(\\n      uint256(0x20),\\n      bytes32(arrayLengthBytes)\\n    );\\n    uint256 lastOffsetStartIdx = paramEndIdx + (0x20 * arrayLength) - 0x20;\\n    uint256 lastOffset = uint256(\\n      bytes32(data[lastOffsetStartIdx:lastOffsetStartIdx + 0x20])\\n    );\\n    bytes32 lastElementBytesLengthBytes = bytes32(\\n      data[paramEndIdx + lastOffset:paramEndIdx + lastOffset + 0x20]\\n    );\\n    uint256 lastElementBytesLength = uint256(lastElementBytesLengthBytes);\\n    uint256 numberOfRowsOfBytesForLastElement = (lastElementBytesLength / 32) +\\n      1;\\n    uint256 dataEndIdx = paramEndIdx +\\n      lastOffset +\\n      0x20 +\\n      (0x20 * numberOfRowsOfBytesForLastElement);\\n    dataToAdd = abi.encodePacked(dataToAdd, data[paramEndIdx:dataEndIdx]);\\n    return dataToAdd;\\n  }\\n\\n  /**\\n   * @notice Extract param for \\\"*[]\\\" types given calldata and a param start index, assuming each element is 32 bytes\\n   */\\n  function extractParamForSimpleArray(\\n    bytes calldata data,\\n    uint256 paramStartIdx\\n  ) public pure returns (bytes memory) {\\n    uint256 paramEndIdx = paramStartIdx + 0x20;\\n    bytes32 arrayLengthBytes = bytes32(data[paramStartIdx:paramEndIdx]);\\n    uint256 arrayLength = uint256(arrayLengthBytes);\\n    bytes memory dataToAdd = abi.encodePacked(\\n      uint256(0x20),\\n      bytes32(arrayLengthBytes)\\n    );\\n    for (uint256 rowIdx; rowIdx \\u003c arrayLength; rowIdx++) {\\n      uint256 rowStartIdx = paramEndIdx + (0x20 * rowIdx);\\n      dataToAdd = abi.encodePacked(\\n        dataToAdd,\\n        data[rowStartIdx:rowStartIdx + 0x20]\\n      );\\n    }\\n    return dataToAdd;\\n  }\\n\\n  /**\\n   * @notice Check to see if the last two characters of a string are \\\"[]\\\"\\n   */\\n  function paramTypeIsArray(string memory paramType)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    bytes32 lastTwoCharacters;\\n    assembly {\\n      let len := mload(paramType)\\n      lastTwoCharacters := mload(add(add(paramType, 0x20), sub(len, 2)))\\n    }\\n    return lastTwoCharacters == bytes32(bytes(\\\"[]\\\"));\\n  }\\n}\\n\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nlibrary Strings {\\n  /**\\n   * @notice Search for a needle in a haystack\\n   * @param haystack The string to search\\n   * @param needle The string to search for\\n   */\\n  function stringStartsWith(string memory haystack, string memory needle)\\n    public\\n    pure\\n    returns (bool)\\n  {\\n    return indexOfStringInString(needle, haystack) == 0;\\n  }\\n\\n  /**\\n   * @notice Case insensitive string search\\n   * @param needle The string to search for\\n   * @param haystack The string to search\\n   * @return Returns -1 if no match is found, otherwise returns the index of the match\\n   */\\n  function indexOfStringInString(string memory needle, string memory haystack)\\n    public\\n    pure\\n    returns (int256)\\n  {\\n    bytes memory _needle = bytes(needle);\\n    bytes memory _haystack = bytes(haystack);\\n    if (_haystack.length \\u003c _needle.length) {\\n      return -1;\\n    }\\n    bool _match;\\n    for (uint256 haystackIdx; haystackIdx \\u003c _haystack.length; haystackIdx++) {\\n      for (uint256 needleIdx; needleIdx \\u003c _needle.length; needleIdx++) {\\n        uint8 needleChar = uint8(_needle[needleIdx]);\\n        if (haystackIdx + needleIdx \\u003e= _haystack.length) {\\n          return -1;\\n        }\\n        uint8 haystackChar = uint8(_haystack[haystackIdx + needleIdx]);\\n        if (needleChar == haystackChar) {\\n          _match = true;\\n          if (needleIdx == _needle.length - 1) {\\n            return int256(haystackIdx);\\n          }\\n        } else {\\n          _match = false;\\n          break;\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n\\n  /**\\n   * @notice Check to see if two strings are exactly equal\\n   */\\n  function stringsEqual(string memory input1, string memory input2)\\n    public\\n    pure\\n    returns (bool)\\n  {\\n    uint256 input1Length = bytes(input1).length;\\n    uint256 input2Length = bytes(input2).length;\\n    uint256 maxLength;\\n    if (input1Length \\u003e input2Length) {\\n      maxLength = input1Length;\\n    } else {\\n      maxLength = input2Length;\\n    }\\n    uint256 numberOfRowsToCompare = (maxLength / 32) + 1;\\n    bytes32 input1Bytes32;\\n    bytes32 input2Bytes32;\\n    for (uint256 rowIdx; rowIdx \\u003c numberOfRowsToCompare; rowIdx++) {\\n      uint256 offset = 0x20 * (rowIdx + 1);\\n      assembly {\\n        input1Bytes32 := mload(add(input1, offset))\\n        input2Bytes32 := mload(add(input2, offset))\\n      }\\n      if (input1Bytes32 != input2Bytes32) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  function atoi(string memory a, uint8 base) public pure returns (uint256 i) {\\n    require(base == 2 || base == 8 || base == 10 || base == 16);\\n    bytes memory buf = bytes(a);\\n    for (uint256 p = 0; p \\u003c buf.length; p++) {\\n      uint8 digit = uint8(buf[p]) - 0x30;\\n      if (digit \\u003e 10) {\\n        digit -= 7;\\n      }\\n      require(digit \\u003c base);\\n      i *= base;\\n      i += digit;\\n    }\\n    return i;\\n  }\\n\\n  function itoa(uint256 i, uint8 base) public pure returns (string memory a) {\\n    require(base == 2 || base == 8 || base == 10 || base == 16);\\n    if (i == 0) {\\n      return \\\"0\\\";\\n    }\\n    bytes memory buf = new bytes(256);\\n    uint256 p = 0;\\n    while (i \\u003e 0) {\\n      uint8 digit = uint8(i % base);\\n      uint8 ascii = digit + 0x30;\\n      if (digit \\u003e 9) {\\n        ascii += 7;\\n      }\\n      buf[p++] = bytes1(ascii);\\n      i /= base;\\n    }\\n    uint256 length = p;\\n    for (p = 0; p \\u003c length / 2; p++) {\\n      buf[p] ^= buf[length - 1 - p];\\n      buf[length - 1 - p] ^= buf[p];\\n      buf[p] ^= buf[length - 1 - p];\\n    }\\n    return string(buf);\\n  }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"paramStartIdx\",\"type\":\"uint256\"}],\"name\":\"extractParamForBytesArrayType\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"paramStartIdx\",\"type\":\"uint256\"}],\"name\":\"extractParamForBytesType\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"paramStartIdx\",\"type\":\"uint256\"}],\"name\":\"extractParamForSimpleArray\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"paramType\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"paramIdx\",\"type\":\"uint256\"}],\"name\":\"getParamFromCalldata\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"paramTypes\",\"type\":\"string[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getParamsFromCalldata\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"AbiDecoder","CompilerVersion":"v0.8.11+commit.d7f03943","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"Strings:dbedc4ee481be454dc3ecd2f9b00e9315467a483","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f0ccc543b523ae950b09adf6a9e3c7b14651aeac296b62a24b0e99a74d27b57b"}]}