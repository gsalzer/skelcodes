{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.15\r\n\"\"\"\r\n@title Voting Escrow Delegation\r\n@author Curve Finance\r\n@license MIT\r\n@dev Provides test functions only available in test mode (`brownie test`)\r\n\"\"\"\r\n\r\n\r\ninterface ERC721Receiver:\r\n    def onERC721Received(\r\n        _operator: address, _from: address, _token_id: uint256, _data: Bytes[4096]\r\n    ) -> bytes32:\r\n        nonpayable\r\n\r\ninterface VotingEscrow:\r\n    def balanceOf(_account: address) -> int256: view\r\n    def locked__end(_addr: address) -> uint256: view\r\n\r\n\r\nevent Approval:\r\n    _owner: indexed(address)\r\n    _approved: indexed(address)\r\n    _token_id: indexed(uint256)\r\n\r\nevent ApprovalForAll:\r\n    _owner: indexed(address)\r\n    _operator: indexed(address)\r\n    _approved: bool\r\n\r\nevent Transfer:\r\n    _from: indexed(address)\r\n    _to: indexed(address)\r\n    _token_id: indexed(uint256)\r\n\r\nevent BurnBoost:\r\n    _delegator: indexed(address)\r\n    _receiver: indexed(address)\r\n    _token_id: indexed(uint256)\r\n\r\nevent DelegateBoost:\r\n    _delegator: indexed(address)\r\n    _receiver: indexed(address)\r\n    _token_id: indexed(uint256)\r\n    _amount: uint256\r\n    _cancel_time: uint256\r\n    _expire_time: uint256\r\n\r\nevent ExtendBoost:\r\n    _delegator: indexed(address)\r\n    _receiver: indexed(address)\r\n    _token_id: indexed(uint256)\r\n    _amount: uint256\r\n    _expire_time: uint256\r\n    _cancel_time: uint256\r\n\r\nevent TransferBoost:\r\n    _from: indexed(address)\r\n    _to: indexed(address)\r\n    _token_id: indexed(uint256)\r\n    _amount: uint256\r\n    _expire_time: uint256\r\n\r\nevent GreyListUpdated:\r\n    _receiver: indexed(address)\r\n    _delegator: indexed(address)\r\n    _status: bool\r\n\r\n\r\nstruct Boost:\r\n    # [bias uint128][slope int128]\r\n    delegated: uint256\r\n    received: uint256\r\n    # [total active delegations 128][next expiry 128]\r\n    expiry_data: uint256\r\n\r\nstruct Token:\r\n    # [bias uint128][slope int128]\r\n    data: uint256\r\n    # [delegator pos 128][cancel time 128]\r\n    dinfo: uint256\r\n    # [global 128][local 128]\r\n    position: uint256\r\n    expire_time: uint256\r\n\r\nstruct Point:\r\n    bias: int256\r\n    slope: int256\r\n\r\n\r\nIDENTITY_PRECOMPILE: constant(address) = 0x0000000000000000000000000000000000000004\r\nMAX_PCT: constant(uint256) = 10_000\r\nWEEK: constant(uint256) = 86400 * 7\r\nVOTING_ESCROW: constant(address) = 0xc8418aF6358FFddA74e09Ca9CC3Fe03Ca6aDC5b0\r\n\r\n\r\nbalanceOf: public(HashMap[address, uint256])\r\ngetApproved: public(HashMap[uint256, address])\r\nisApprovedForAll: public(HashMap[address, HashMap[address, bool]])\r\nownerOf: public(HashMap[uint256, address])\r\n\r\nname: public(String[32])\r\nsymbol: public(String[32])\r\nbase_uri: public(String[128])\r\n\r\ntotalSupply: public(uint256)\r\n# use totalSupply to determine the length\r\ntokenByIndex: public(HashMap[uint256, uint256])\r\n# use balanceOf to determine the length\r\ntokenOfOwnerByIndex: public(HashMap[address, uint256[MAX_UINT256]])\r\n\r\nboost: HashMap[address, Boost]\r\nboost_tokens: HashMap[uint256, Token]\r\n\r\ntoken_of_delegator_by_index: public(HashMap[address, uint256[MAX_UINT256]])\r\ntotal_minted: public(HashMap[address, uint256])\r\n# address => timestamp => # of delegations expiring\r\naccount_expiries: public(HashMap[address, HashMap[uint256, uint256]])\r\n\r\nadmin: public(address)  # Can and will be a smart contract\r\nfuture_admin: public(address)\r\n\r\n# The grey list - per-user black and white lists\r\n# users can make this a blacklist or a whitelist - defaults to blacklist\r\n# gray_list[_receiver][_delegator]\r\n# by default is blacklist, with no delegators blacklisted\r\n# if [_receiver][ZERO_ADDRESS] is False = Blacklist, True = Whitelist\r\n# if this is a blacklist, receivers disallow any delegations from _delegator if it is True\r\n# if this is a whitelist, receivers only allow delegations from _delegator if it is True\r\n# Delegation will go through if: not (grey_list[_receiver][ZERO_ADDRESS] ^ grey_list[_receiver][_delegator])\r\ngrey_list: public(HashMap[address, HashMap[address, bool]])\r\n\r\n\r\n@external\r\ndef __init__(_name: String[32], _symbol: String[32], _base_uri: String[128]):\r\n    self.name = _name\r\n    self.symbol = _symbol\r\n    self.base_uri = _base_uri\r\n\r\n    self.admin = msg.sender\r\n\r\n\r\n@internal\r\ndef _approve(_owner: address, _approved: address, _token_id: uint256):\r\n    self.getApproved[_token_id] = _approved\r\n    log Approval(_owner, _approved, _token_id)\r\n\r\n\r\n@view\r\n@internal\r\ndef _is_approved_or_owner(_spender: address, _token_id: uint256) -> bool:\r\n    owner: address = self.ownerOf[_token_id]\r\n    return (\r\n        _spender == owner\r\n        or _spender == self.getApproved[_token_id]\r\n        or self.isApprovedForAll[owner][_spender]\r\n    )\r\n\r\n\r\n@internal\r\ndef _update_enumeration_data(_from: address, _to: address, _token_id: uint256):\r\n    delegator: address = convert(shift(_token_id, -96), address)\r\n    position_data: uint256 = self.boost_tokens[_token_id].position\r\n    local_pos: uint256 = position_data % 2 ** 128\r\n    global_pos: uint256 = shift(position_data, -128)\r\n    # position in the delegator array of minted tokens\r\n    delegator_pos: uint256 = shift(self.boost_tokens[_token_id].dinfo, -128)\r\n\r\n    if _from == ZERO_ADDRESS:\r\n        # minting - This is called before updates to balance and totalSupply\r\n        local_pos = self.balanceOf[_to]\r\n        global_pos = self.totalSupply\r\n        position_data = shift(global_pos, 128) + local_pos\r\n        # this is a new token so we get the index of a new spot\r\n        delegator_pos = self.total_minted[delegator]\r\n\r\n        self.tokenByIndex[global_pos] = _token_id\r\n        self.tokenOfOwnerByIndex[_to][local_pos] = _token_id\r\n        self.boost_tokens[_token_id].position = position_data\r\n\r\n        # we only mint tokens in the create_boost fn, and this is called\r\n        # before we update the cancel_time so we can just set the value\r\n        # of dinfo to the shifted position\r\n        self.boost_tokens[_token_id].dinfo = shift(delegator_pos, 128)\r\n        self.token_of_delegator_by_index[delegator][delegator_pos] = _token_id\r\n        self.total_minted[delegator] = delegator_pos + 1\r\n\r\n    elif _to == ZERO_ADDRESS:\r\n        # burning - This is called after updates to balance and totalSupply\r\n        # we operate on both the global array and local array\r\n        last_global_index: uint256 = self.totalSupply\r\n        last_local_index: uint256 = self.balanceOf[_from]\r\n        last_delegator_pos: uint256 = self.total_minted[delegator] - 1\r\n\r\n        if global_pos != last_global_index:\r\n            # swap - set the token we're burnings position to the token in the last index\r\n            last_global_token: uint256 = self.tokenByIndex[last_global_index]\r\n            last_global_token_pos: uint256 = self.boost_tokens[last_global_token].position\r\n            # update the global position of the last global token\r\n            self.boost_tokens[last_global_token].position = shift(global_pos, 128) + (last_global_token_pos % 2 ** 128)\r\n            self.tokenByIndex[global_pos] = last_global_token\r\n        self.tokenByIndex[last_global_index] = 0\r\n\r\n        if local_pos != last_local_index:\r\n            # swap - set the token we're burnings position to the token in the last index\r\n            last_local_token: uint256 = self.tokenOfOwnerByIndex[_from][last_local_index]\r\n            last_local_token_pos: uint256 = self.boost_tokens[last_local_token].position\r\n            # update the local position of the last local token\r\n            self.boost_tokens[last_local_token].position = shift(last_local_token_pos / 2 ** 128, 128) + local_pos\r\n            self.tokenOfOwnerByIndex[_from][local_pos] = last_local_token\r\n        self.tokenOfOwnerByIndex[_from][last_local_index] = 0\r\n        self.boost_tokens[_token_id].position = 0\r\n\r\n        if delegator_pos != last_delegator_pos:\r\n            last_delegator_token: uint256 = self.token_of_delegator_by_index[delegator][last_delegator_pos]\r\n            last_delegator_token_dinfo: uint256 = self.boost_tokens[last_delegator_token].dinfo\r\n            # update the last tokens position data and maintain the correct cancel time\r\n            self.boost_tokens[last_delegator_token].dinfo = shift(delegator_pos, 128) + (last_delegator_token_dinfo % 2 ** 128)\r\n            self.token_of_delegator_by_index[delegator][delegator_pos] = last_delegator_token\r\n        self.token_of_delegator_by_index[delegator][last_delegator_pos] = 0\r\n        self.boost_tokens[_token_id].dinfo = 0  # we are burning the token so we can just set to 0\r\n        self.total_minted[delegator] = last_delegator_pos\r\n\r\n    else:\r\n        # transfering - called between balance updates\r\n        from_last_index: uint256 = self.balanceOf[_from]\r\n\r\n        if local_pos != from_last_index:\r\n            # swap - set the token we're burnings position to the token in the last index\r\n            last_local_token: uint256 = self.tokenOfOwnerByIndex[_from][from_last_index]\r\n            last_local_token_pos: uint256 = self.boost_tokens[last_local_token].position\r\n            # update the local position of the last local token\r\n            self.boost_tokens[last_local_token].position = shift(last_local_token_pos / 2 ** 128, 128) + local_pos\r\n            self.tokenOfOwnerByIndex[_from][local_pos] = last_local_token\r\n        self.tokenOfOwnerByIndex[_from][from_last_index] = 0\r\n\r\n        # to is simple we just add to the end of the list\r\n        local_pos = self.balanceOf[_to]\r\n        self.tokenOfOwnerByIndex[_to][local_pos] = _token_id\r\n        self.boost_tokens[_token_id].position = shift(global_pos, 128) + local_pos\r\n\r\n\r\n@internal\r\ndef _burn(_token_id: uint256):\r\n    owner: address = self.ownerOf[_token_id]\r\n\r\n    self._approve(owner, ZERO_ADDRESS, _token_id)\r\n\r\n    self.balanceOf[owner] -= 1\r\n    self.ownerOf[_token_id] = ZERO_ADDRESS\r\n    self.totalSupply -= 1\r\n\r\n    self._update_enumeration_data(owner, ZERO_ADDRESS, _token_id)\r\n\r\n    log Transfer(owner, ZERO_ADDRESS, _token_id)\r\n\r\n\r\n@internal\r\ndef _mint(_to: address, _token_id: uint256):\r\n    assert _to != ZERO_ADDRESS  # dev: minting to ZERO_ADDRESS disallowed\r\n    assert self.ownerOf[_token_id] == ZERO_ADDRESS  # dev: token exists\r\n\r\n    self._update_enumeration_data(ZERO_ADDRESS, _to, _token_id)\r\n\r\n    self.balanceOf[_to] += 1\r\n    self.ownerOf[_token_id] = _to\r\n    self.totalSupply += 1\r\n\r\n    log Transfer(ZERO_ADDRESS, _to, _token_id)\r\n\r\n\r\n@internal\r\ndef _mint_boost(_token_id: uint256, _delegator: address, _receiver: address, _bias: int256, _slope: int256, _cancel_time: uint256, _expire_time: uint256):\r\n    is_whitelist: uint256 = convert(self.grey_list[_receiver][ZERO_ADDRESS], uint256)\r\n    delegator_status: uint256 = convert(self.grey_list[_receiver][_delegator], uint256)\r\n    assert not convert(bitwise_xor(is_whitelist, delegator_status), bool)  # dev: mint boost not allowed\r\n\r\n    data: uint256 = shift(convert(_bias, uint256), 128) + convert(abs(_slope), uint256)\r\n    self.boost[_delegator].delegated += data\r\n    self.boost[_receiver].received += data\r\n\r\n    token: Token = self.boost_tokens[_token_id]\r\n    token.data = data\r\n    token.dinfo = token.dinfo + _cancel_time\r\n    token.expire_time = _expire_time\r\n    self.boost_tokens[_token_id] = token\r\n\r\n\r\n@internal\r\ndef _burn_boost(_token_id: uint256, _delegator: address, _receiver: address, _bias: int256, _slope: int256):\r\n    token: Token = self.boost_tokens[_token_id]\r\n    expire_time: uint256 = token.expire_time\r\n\r\n    if expire_time == 0:\r\n        return\r\n\r\n    self.boost[_delegator].delegated -= token.data\r\n    self.boost[_receiver].received -= token.data\r\n\r\n    token.data = 0\r\n    # maintain the same position in the delegator array, but remove the cancel time\r\n    token.dinfo = shift(token.dinfo / 2 ** 128, 128)\r\n    token.expire_time = 0\r\n    self.boost_tokens[_token_id] = token\r\n\r\n    # update the next expiry data\r\n    expiry_data: uint256 = self.boost[_delegator].expiry_data\r\n    next_expiry: uint256 = expiry_data % 2 ** 128\r\n    active_delegations: uint256 = shift(expiry_data, -128) - 1\r\n\r\n    expiries: uint256 = self.account_expiries[_delegator][expire_time]\r\n\r\n    if active_delegations != 0 and expire_time == next_expiry and expiries == 0:\r\n        # Will be passed if\r\n        # active_delegations == 0, no more active boost tokens\r\n        # or\r\n        # expire_time != next_expiry, the cancelled boost token isn't the next expiring boost token\r\n        # or\r\n        # expiries != 0, the cancelled boost token isn't the only one expiring at expire_time\r\n        for i in range(1, 513):  # ~10 years\r\n            # we essentially allow for a boost token be expired for up to 6 years\r\n            # 10 yrs - 4 yrs (max vecRV lock time) = ~ 6 yrs\r\n            if i == 512:\r\n                raise \"Failed to find next expiry\"\r\n            week_ts: uint256 = expire_time + WEEK * (i + 1)\r\n            if self.account_expiries[_delegator][week_ts] > 0:\r\n                next_expiry = week_ts\r\n                break\r\n    elif active_delegations == 0:\r\n        next_expiry = 0\r\n\r\n    self.boost[_delegator].expiry_data = shift(active_delegations, 128) + next_expiry\r\n    self.account_expiries[_delegator][expire_time] = expiries - 1\r\n\r\n\r\n@internal\r\ndef _transfer_boost(_from: address, _to: address, _bias: int256, _slope: int256):\r\n    data: uint256 = shift(convert(_bias, uint256), 128) + convert(abs(_slope), uint256)\r\n    self.boost[_from].received -= data\r\n    self.boost[_to].received += data\r\n\r\n\r\n@pure\r\n@internal\r\ndef _deconstruct_bias_slope(_data: uint256) -> Point:\r\n    return Point({bias: convert(shift(_data, -128), int256), slope: -convert(_data % 2 ** 128, int256)})\r\n\r\n\r\n@pure\r\n@internal\r\ndef _calc_bias_slope(_x: int256, _y: int256, _expire_time: int256) -> Point:\r\n    # SLOPE: (y2 - y1) / (x2 - x1)\r\n    # BIAS: y = mx + b -> y - mx = b\r\n    slope: int256 = -_y / (_expire_time - _x)\r\n    return Point({bias: _y - slope * _x, slope: slope})\r\n\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _token_id: uint256):\r\n    assert self.ownerOf[_token_id] == _from  # dev: _from is not owner\r\n    assert _to != ZERO_ADDRESS  # dev: transfers to ZERO_ADDRESS are disallowed\r\n\r\n    delegator: address = convert(shift(_token_id, -96), address)\r\n    is_whitelist: uint256 = convert(self.grey_list[_to][ZERO_ADDRESS], uint256)\r\n    delegator_status: uint256 = convert(self.grey_list[_to][delegator], uint256)\r\n    assert not convert(bitwise_xor(is_whitelist, delegator_status), bool)  # dev: transfer boost not allowed\r\n\r\n    # clear previous token approval\r\n    self._approve(_from, ZERO_ADDRESS, _token_id)\r\n\r\n    self.balanceOf[_from] -= 1\r\n    self._update_enumeration_data(_from, _to, _token_id)\r\n    self.balanceOf[_to] += 1\r\n    self.ownerOf[_token_id] = _to\r\n\r\n    tpoint: Point = self._deconstruct_bias_slope(self.boost_tokens[_token_id].data)\r\n    tvalue: int256 = tpoint.slope * convert(block.timestamp, int256) + tpoint.bias\r\n\r\n    # if the boost value is negative, reset the slope and bias\r\n    if tvalue > 0:\r\n        self._transfer_boost(_from, _to, tpoint.bias, tpoint.slope)\r\n        # y = mx + b -> y - b = mx -> (y - b)/m = x -> -b / m = x (x-intercept)\r\n        expiry: uint256 = convert(-tpoint.bias / tpoint.slope, uint256)\r\n        log TransferBoost(_from, _to, _token_id, convert(tvalue, uint256), expiry)\r\n    else:\r\n        self._burn_boost(_token_id, delegator, _from, tpoint.bias, tpoint.slope)\r\n        log BurnBoost(delegator, _from, _token_id)\r\n\r\n    log Transfer(_from, _to, _token_id)\r\n\r\n\r\n@internal\r\ndef _cancel_boost(_token_id: uint256, _caller: address):\r\n    receiver: address = self.ownerOf[_token_id]\r\n    assert receiver != ZERO_ADDRESS  # dev: token does not exist\r\n    delegator: address = convert(shift(_token_id, -96), address)\r\n\r\n    token: Token = self.boost_tokens[_token_id]\r\n    tpoint: Point = self._deconstruct_bias_slope(token.data)\r\n    tvalue: int256 = tpoint.slope * convert(block.timestamp, int256) + tpoint.bias\r\n\r\n    # if not (the owner or operator or the boost value is negative)\r\n    if not (_caller == receiver or self.isApprovedForAll[receiver][_caller] or tvalue <= 0):\r\n        if _caller == delegator or self.isApprovedForAll[delegator][_caller]:\r\n            # if delegator or operator, wait till after cancel time\r\n            assert (token.dinfo % 2 ** 128) <= block.timestamp  # dev: must wait for cancel time\r\n        else:\r\n            # All others are disallowed\r\n            raise \"Not allowed!\"\r\n    self._burn_boost(_token_id, delegator, receiver, tpoint.bias, tpoint.slope)\r\n\r\n    log BurnBoost(delegator, receiver, _token_id)\r\n\r\n\r\n@internal\r\ndef _set_delegation_status(_receiver: address, _delegator: address, _status: bool):\r\n    self.grey_list[_receiver][_delegator] = _status\r\n    log GreyListUpdated(_receiver, _delegator, _status)\r\n\r\n\r\n@pure\r\n@internal\r\ndef _uint_to_string(_value: uint256) -> String[78]:\r\n    # NOTE: Odd that this works with a raw_call inside, despite being marked\r\n    # a pure function\r\n    if _value == 0:\r\n        return \"0\"\r\n\r\n    buffer: Bytes[78] = b\"\"\r\n    digits: uint256 = 78\r\n\r\n    for i in range(78):\r\n        # go forward to find the # of digits, and set it\r\n        # only if we have found the last index\r\n        if digits == 78 and _value / 10 ** i == 0:\r\n            digits = i\r\n\r\n        value: uint256 = ((_value / 10 ** (77 - i)) % 10) + 48\r\n        char: Bytes[1] = slice(convert(value, bytes32), 31, 1)\r\n        buffer = raw_call(\r\n            IDENTITY_PRECOMPILE,\r\n            concat(buffer, char),\r\n            max_outsize=78,\r\n            is_static_call=True\r\n        )\r\n\r\n    return convert(slice(buffer, 78 - digits, digits), String[78])\r\n\r\n\r\n@external\r\ndef approve(_approved: address, _token_id: uint256):\r\n    \"\"\"\r\n    @notice Change or reaffirm the approved address for an NFT.\r\n    @dev The zero address indicates there is no approved address.\r\n        Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n        operator of the current owner.\r\n    @param _approved The new approved NFT controller.\r\n    @param _token_id The NFT to approve.\r\n    \"\"\"\r\n    owner: address = self.ownerOf[_token_id]\r\n    assert (\r\n        msg.sender == owner or self.isApprovedForAll[owner][msg.sender]\r\n    )  # dev: must be owner or operator\r\n    self._approve(owner, _approved, _token_id)\r\n\r\n\r\n@external\r\ndef safeTransferFrom(_from: address, _to: address, _token_id: uint256, _data: Bytes[4096] = b\"\"):\r\n    \"\"\"\r\n    @notice Transfers the ownership of an NFT from one address to another address\r\n    @dev Throws unless `msg.sender` is the current owner, an authorized\r\n        operator, or the approved address for this NFT. Throws if `_from` is\r\n        not the current owner. Throws if `_to` is the zero address. Throws if\r\n        `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n        checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n        `onERC721Received` on `_to` and throws if the return value is not\r\n        `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    @param _from The current owner of the NFT\r\n    @param _to The new owner\r\n    @param _token_id The NFT to transfer\r\n    @param _data Additional data with no specified format, sent in call to `_to`, max length 4096\r\n    \"\"\"\r\n    assert self._is_approved_or_owner(msg.sender, _token_id)  # dev: neither owner nor approved\r\n    self._transfer(_from, _to, _token_id)\r\n\r\n    if _to.is_contract:\r\n        response: bytes32 = ERC721Receiver(_to).onERC721Received(\r\n            msg.sender, _from, _token_id, _data\r\n        )\r\n        assert slice(response, 0, 4) == method_id(\r\n            \"onERC721Received(address,address,uint256,bytes)\"\r\n        )  # dev: invalid response\r\n\r\n\r\n@external\r\ndef setApprovalForAll(_operator: address, _approved: bool):\r\n    \"\"\"\r\n    @notice Enable or disable approval for a third party (\"operator\") to manage\r\n        all of `msg.sender`'s assets.\r\n    @dev Emits the ApprovalForAll event. Multiple operators per account are allowed.\r\n    @param _operator Address to add to the set of authorized operators.\r\n    @param _approved True if the operator is approved, false to revoke approval.\r\n    \"\"\"\r\n    self.isApprovedForAll[msg.sender][_operator] = _approved\r\n    log ApprovalForAll(msg.sender, _operator, _approved)\r\n\r\n\r\n@external\r\ndef transferFrom(_from: address, _to: address, _token_id: uint256):\r\n    \"\"\"\r\n    @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n        TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n        THEY MAY BE PERMANENTLY LOST\r\n    @dev Throws unless `msg.sender` is the current owner, an authorized\r\n        operator, or the approved address for this NFT. Throws if `_from` is\r\n        not the current owner. Throws if `_to` is the ZERO_ADDRESS.\r\n    @param _from The current owner of the NFT\r\n    @param _to The new owner\r\n    @param _token_id The NFT to transfer\r\n    \"\"\"\r\n    assert self._is_approved_or_owner(msg.sender, _token_id)  # dev: neither owner nor approved\r\n    self._transfer(_from, _to, _token_id)\r\n\r\n\r\n@view\r\n@external\r\ndef tokenURI(_token_id: uint256) -> String[256]:\r\n    return concat(self.base_uri, self._uint_to_string(_token_id))\r\n\r\n\r\n@external\r\ndef burn(_token_id: uint256):\r\n    \"\"\"\r\n    @notice Destroy a token\r\n    @dev Only callable by the token owner, their operator, or an approved account.\r\n        Burning a token with a currently active boost, burns the boost.\r\n    @param _token_id The token to burn\r\n    \"\"\"\r\n    assert self._is_approved_or_owner(msg.sender, _token_id)  # dev: neither owner nor approved\r\n\r\n    tdata: uint256 = self.boost_tokens[_token_id].data\r\n    if tdata != 0:\r\n        tpoint: Point = self._deconstruct_bias_slope(tdata)\r\n\r\n        delegator: address = convert(shift(_token_id, -96), address)\r\n        owner: address = self.ownerOf[_token_id]\r\n\r\n        self._burn_boost(_token_id, delegator, owner, tpoint.bias, tpoint.slope)\r\n\r\n        log BurnBoost(delegator, owner, _token_id)\r\n\r\n    self._burn(_token_id)\r\n\r\n\r\n#@ if mode == \"test\":\r\n@external\r\ndef _mint_for_testing(_to: address, _token_id: uint256):\r\n    self._mint(_to, _token_id)\r\n\r\n\r\n@external\r\ndef _burn_for_testing(_token_id: uint256):\r\n    self._burn(_token_id)\r\n\r\n\r\n@view\r\n@external\r\ndef uint_to_string(_value: uint256) -> String[78]:\r\n    return self._uint_to_string(_value)\r\n\r\n#@ endif\r\n\r\n\r\n@external\r\ndef create_boost(\r\n    _delegator: address,\r\n    _receiver: address,\r\n    _percentage: int256,\r\n    _cancel_time: uint256,\r\n    _expire_time: uint256,\r\n    _id: uint256,\r\n):\r\n    \"\"\"\r\n    @notice Create a boost and delegate it to another account.\r\n    @dev Delegated boost can become negative, and requires active management, else\r\n        the adjusted veCRV balance of the delegator's account will decrease until reaching 0\r\n    @param _delegator The account to delegate boost from\r\n    @param _receiver The account to receive the delegated boost\r\n    @param _percentage Since veCRV is a constantly decreasing asset, we use percentage to determine\r\n        the amount of delegator's boost to delegate\r\n    @param _cancel_time A point in time before _expire_time in which the delegator or their operator\r\n        can cancel the delegated boost\r\n    @param _expire_time The point in time, atleast a day in the future, at which the value of the boost\r\n        will reach 0. After which the negative value is deducted from the delegator's account (and the\r\n        receiver's received boost only) until it is cancelled. This value is rounded down to the nearest\r\n        WEEK.\r\n    @param _id The token id, within the range of [0, 2 ** 96). Useful for contracts given operator status\r\n        to have specific ranges.\r\n    \"\"\"\r\n    assert msg.sender == _delegator or self.isApprovedForAll[_delegator][msg.sender]  # dev: only delegator or operator\r\n\r\n    expire_time: uint256 = (_expire_time / WEEK) * WEEK\r\n\r\n    expiry_data: uint256 = self.boost[_delegator].expiry_data\r\n    next_expiry: uint256 = expiry_data % 2 ** 128\r\n\r\n    if next_expiry == 0:\r\n        next_expiry = MAX_UINT256\r\n\r\n    assert block.timestamp < next_expiry  # dev: negative boost token is in circulation\r\n    assert _percentage > 0  # dev: percentage must be greater than 0 bps\r\n    assert _percentage <= MAX_PCT  # dev: percentage must be less than 10_000 bps\r\n    assert _cancel_time <= expire_time  # dev: cancel time is after expiry\r\n\r\n    assert expire_time >= block.timestamp + WEEK  # dev: boost duration must be atleast WEEK\r\n    assert expire_time <= VotingEscrow(VOTING_ESCROW).locked__end(_delegator)  # dev: boost expiration is past voting escrow lock expiry\r\n    assert _id < 2 ** 96  # dev: id out of bounds\r\n\r\n    # [delegator address 160][cancel_time uint40][id uint56]\r\n    token_id: uint256 = shift(convert(_delegator, uint256), 96) + _id\r\n    # check if the token exists here before we expend more gas by minting it\r\n    self._mint(_receiver, token_id)\r\n\r\n    # delegated slope and bias\r\n    point: Point = self._deconstruct_bias_slope(self.boost[_delegator].delegated)\r\n\r\n    time: int256 = convert(block.timestamp, int256)\r\n\r\n    # delegated boost will be positive, if any of circulating boosts are negative\r\n    # we have already reverted\r\n    delegated_boost: int256 = point.slope * time + point.bias\r\n    y: int256 = _percentage * (VotingEscrow(VOTING_ESCROW).balanceOf(_delegator) - delegated_boost) / MAX_PCT\r\n    assert y > 0  # dev: no boost\r\n\r\n    point = self._calc_bias_slope(time, y, convert(expire_time, int256))\r\n    assert point.slope < 0  # dev: invalid slope\r\n\r\n    self._mint_boost(token_id, _delegator, _receiver, point.bias, point.slope, _cancel_time, expire_time)\r\n\r\n    # increase the number of expiries for the user\r\n    if expire_time < next_expiry:\r\n        next_expiry = expire_time\r\n\r\n    active_delegations: uint256 = shift(expiry_data, -128)\r\n    self.account_expiries[_delegator][expire_time] += 1\r\n    self.boost[_delegator].expiry_data = shift(active_delegations + 1, 128) + next_expiry\r\n\r\n    log DelegateBoost(_delegator, _receiver, token_id, convert(y, uint256), _cancel_time, _expire_time)\r\n\r\n\r\n@external\r\ndef extend_boost(_token_id: uint256, _percentage: int256, _expire_time: uint256, _cancel_time: uint256):\r\n    \"\"\"\r\n    @notice Extend the boost of an existing boost or expired boost\r\n    @dev The extension can not decrease the value of the boost. If there are\r\n        any outstanding negative value boosts which cause the delegable boost\r\n        of an account to be negative this call will revert\r\n    @param _token_id The token to extend the boost of\r\n    @param _percentage The percentage of delegable boost to delegate\r\n        AFTER burning the token's current boost\r\n    @param _expire_time The new time at which the boost value will become\r\n        0, and eventually negative. Must be greater than the previous expiry time,\r\n        and atleast a WEEK from now, and less than the veCRV lock expiry of the\r\n        delegator's account. This value is rounded down to the nearest WEEK.\r\n    \"\"\"\r\n    delegator: address = convert(shift(_token_id, -96), address)\r\n    receiver: address = self.ownerOf[_token_id]\r\n\r\n    assert msg.sender == delegator or self.isApprovedForAll[delegator][msg.sender]  # dev: only delegator or operator\r\n    assert receiver != ZERO_ADDRESS  # dev: boost token does not exist\r\n    assert _percentage > 0  # dev: percentage must be greater than 0 bps\r\n    assert _percentage <= MAX_PCT  # dev: percentage must be less than 10_000 bps\r\n\r\n    # timestamp when delegating account's voting escrow ends - also our second point (lock_expiry, 0)\r\n    token: Token = self.boost_tokens[_token_id]\r\n\r\n    expire_time: uint256 = (_expire_time / WEEK) * WEEK\r\n\r\n    assert _cancel_time <= expire_time  # dev: cancel time is after expiry\r\n    assert expire_time >= block.timestamp + WEEK  # dev: boost duration must be atleast one day\r\n    assert expire_time <= VotingEscrow(VOTING_ESCROW).locked__end(delegator) # dev: boost expiration is past voting escrow lock expiry\r\n\r\n    point: Point = self._deconstruct_bias_slope(token.data)\r\n\r\n    time: int256 = convert(block.timestamp, int256)\r\n    tvalue: int256 = point.slope * time + point.bias\r\n\r\n    # Can extend a token by increasing it's amount but not it's expiry time\r\n    assert expire_time >= token.expire_time  # dev: new expiration must be greater than old token expiry\r\n\r\n    # if we are extending an unexpired boost, the cancel time must the same or greater\r\n    # else we can adjust the cancel time to our preference\r\n    if _cancel_time < (token.dinfo % 2 ** 128):\r\n        assert block.timestamp >= token.expire_time  # dev: cancel time reduction disallowed\r\n\r\n    # storage variables have been updated: next_expiry + active_delegations\r\n    self._burn_boost(_token_id, delegator, receiver, point.bias, point.slope)\r\n\r\n    expiry_data: uint256 = self.boost[delegator].expiry_data\r\n    next_expiry: uint256 = expiry_data % 2 ** 128\r\n\r\n    if next_expiry == 0:\r\n        next_expiry = MAX_UINT256\r\n\r\n    assert block.timestamp < next_expiry  # dev: negative outstanding boosts\r\n\r\n    # delegated slope and bias\r\n    point = self._deconstruct_bias_slope(self.boost[delegator].delegated)\r\n\r\n    # verify delegated boost isn't negative, else it'll inflate out vecrv balance\r\n    delegated_boost: int256 = point.slope * time + point.bias\r\n    y: int256 = _percentage * (VotingEscrow(VOTING_ESCROW).balanceOf(delegator) - delegated_boost) / MAX_PCT\r\n    # a delegator can snipe the exact moment a token expires and create a boost\r\n    # with 10_000 or some percentage of their boost, which is perfectly fine.\r\n    # this check is here so the user can't extend a boost unless they actually\r\n    # have any to give\r\n    assert y > 0  # dev: no boost\r\n    assert y >= tvalue  # dev: cannot reduce value of boost\r\n\r\n    point = self._calc_bias_slope(time, y, convert(expire_time, int256))\r\n    assert point.slope < 0  # dev: invalid slope\r\n\r\n    self._mint_boost(_token_id, delegator, receiver, point.bias, point.slope, _cancel_time, expire_time)\r\n\r\n    # increase the number of expiries for the user\r\n    if expire_time < next_expiry:\r\n        next_expiry = expire_time\r\n\r\n    active_delegations: uint256 = shift(expiry_data, -128)\r\n    self.account_expiries[delegator][expire_time] += 1\r\n    self.boost[delegator].expiry_data = shift(active_delegations + 1, 128) + next_expiry\r\n\r\n    log ExtendBoost(delegator, receiver, _token_id, convert(y, uint256), expire_time, _cancel_time)\r\n\r\n\r\n@external\r\ndef cancel_boost(_token_id: uint256):\r\n    \"\"\"\r\n    @notice Cancel an outstanding boost\r\n    @dev This does not burn the token, only the boost it represents. The owner\r\n        of the token or their operator can cancel a boost at any time. The\r\n        delegator or their operator can only cancel a token after the cancel\r\n        time. Anyone can cancel the boost if the value of it is negative.\r\n    @param _token_id The token to cancel\r\n    \"\"\"\r\n    self._cancel_boost(_token_id, msg.sender)\r\n\r\n\r\n@external\r\ndef batch_cancel_boosts(_token_ids: uint256[256]):\r\n    \"\"\"\r\n    @notice Cancel many outstanding boosts\r\n    @dev This does not burn the token, only the boost it represents. The owner\r\n        of the token or their operator can cancel a boost at any time. The\r\n        delegator or their operator can only cancel a token after the cancel\r\n        time. Anyone can cancel the boost if the value of it is negative.\r\n    @param _token_ids A list of 256 token ids to nullify. The list must\r\n        be padded with 0 values if less than 256 token ids are provided.\r\n    \"\"\"\r\n\r\n    for _token_id in _token_ids:\r\n        if _token_id == 0:\r\n            break\r\n        self._cancel_boost(_token_id, msg.sender)\r\n\r\n\r\n@external\r\ndef set_delegation_status(_receiver: address, _delegator: address, _status: bool):\r\n    \"\"\"\r\n    @notice Set or reaffirm the blacklist/whitelist status of a delegator for a receiver.\r\n    @dev Setting delegator as the ZERO_ADDRESS enables users to deactive delegations globally\r\n        and enable the white list. The ability of a delegator to delegate to a receiver\r\n        is determined by ~(grey_list[_receiver][ZERO_ADDRESS] ^ grey_list[_receiver][_delegator]).\r\n    @param _receiver The account which we will be updating it's list\r\n    @param _delegator The account to disallow/allow delegations from\r\n    @param _status Boolean of the status to set the _delegator account to\r\n    \"\"\"\r\n    assert msg.sender == _receiver or self.isApprovedForAll[_receiver][msg.sender]\r\n    self._set_delegation_status(_receiver, _delegator, _status)\r\n\r\n\r\n@external\r\ndef batch_set_delegation_status(_receiver: address, _delegators: address[256], _status: uint256[256]):\r\n    \"\"\"\r\n    @notice Set or reaffirm the blacklist/whitelist status of multiple delegators for a receiver.\r\n    @dev Setting delegator as the ZERO_ADDRESS enables users to deactive delegations globally\r\n        and enable the white list. The ability of a delegator to delegate to a receiver\r\n        is determined by ~(grey_list[_receiver][ZERO_ADDRESS] ^ grey_list[_receiver][_delegator]).\r\n    @param _receiver The account which we will be updating it's list\r\n    @param _delegators List of 256 accounts to disallow/allow delegations from\r\n    @param _status List of 256 0s and 1s (booleans) of the status to set the _delegator_i account to.\r\n        if the value is not 0 or 1, execution will break, effectively stopping at the index.\r\n\r\n    \"\"\"\r\n    assert msg.sender == _receiver or self.isApprovedForAll[_receiver][msg.sender]  # dev: only receiver or operator\r\n\r\n    for i in range(256):\r\n        if _status[i] > 1:\r\n            break\r\n        self._set_delegation_status(_receiver, _delegators[i], convert(_status[i], bool))\r\n\r\n\r\n@view\r\n@external\r\ndef adjusted_balance_of(_account: address) -> uint256:\r\n    \"\"\"\r\n    @notice Adjusted veCRV balance after accounting for delegations and boosts\r\n    @dev If boosts/delegations have a negative value, they're effective value is 0\r\n    @param _account The account to query the adjusted balance of\r\n    \"\"\"\r\n    next_expiry: uint256 = self.boost[_account].expiry_data % 2 ** 128\r\n    if next_expiry != 0 and next_expiry < block.timestamp:\r\n        # if the account has a negative boost in circulation\r\n        # we over penalize by setting their adjusted balance to 0\r\n        # this is because we don't want to iterate to find the real\r\n        # value\r\n        return 0\r\n\r\n    adjusted_balance: int256 = VotingEscrow(VOTING_ESCROW).balanceOf(_account)\r\n\r\n    boost: Boost = self.boost[_account]\r\n    time: int256 = convert(block.timestamp, int256)\r\n\r\n    if boost.delegated != 0:\r\n        dpoint: Point = self._deconstruct_bias_slope(boost.delegated)\r\n\r\n        # we take the absolute value, since delegated boost can be negative\r\n        # if any outstanding negative boosts are in circulation\r\n        # this can inflate the vecrv balance of a user\r\n        # taking the absolute value has the effect that it costs\r\n        # a user to negatively impact another's vecrv balance\r\n        adjusted_balance -= abs(dpoint.slope * time + dpoint.bias)\r\n\r\n    if boost.received != 0:\r\n        rpoint: Point = self._deconstruct_bias_slope(boost.received)\r\n\r\n        # similar to delegated boost, our received boost can be negative\r\n        # if any outstanding negative boosts are in our possession\r\n        # However, unlike delegated boost, we do not negatively impact\r\n        # our adjusted balance due to negative boosts. Instead we take\r\n        # whichever is greater between 0 and the value of our received\r\n        # boosts.\r\n        adjusted_balance += max(rpoint.slope * time + rpoint.bias, empty(int256))\r\n\r\n    # since we took the absolute value of our delegated boost, it now instead of\r\n    # becoming negative is positive, and will continue to increase ...\r\n    # meaning if we keep a negative outstanding delegated balance for long\r\n    # enought it will not only decrease our vecrv_balance but also our received\r\n    # boost, however we return the maximum between our adjusted balance and 0\r\n    # when delegating boost, received boost isn't used for determining how\r\n    # much we can delegate.\r\n    return convert(max(adjusted_balance, empty(int256)), uint256)\r\n\r\n\r\n@view\r\n@external\r\ndef delegated_boost(_account: address) -> uint256:\r\n    \"\"\"\r\n    @notice Query the total effective delegated boost value of an account.\r\n    @dev This value can be greater than the veCRV balance of\r\n        an account if the account has outstanding negative\r\n        value boosts.\r\n    @param _account The account to query\r\n    \"\"\"\r\n    dpoint: Point = self._deconstruct_bias_slope(self.boost[_account].delegated)\r\n    time: int256 = convert(block.timestamp, int256)\r\n    return convert(abs(dpoint.slope * time + dpoint.bias), uint256)\r\n\r\n\r\n@view\r\n@external\r\ndef received_boost(_account: address) -> uint256:\r\n    \"\"\"\r\n    @notice Query the total effective received boost value of an account\r\n    @dev This value can be 0, even with delegations which have a large value,\r\n        if the account has any outstanding negative value boosts.\r\n    @param _account The account to query\r\n    \"\"\"\r\n    rpoint: Point = self._deconstruct_bias_slope(self.boost[_account].received)\r\n    time: int256 = convert(block.timestamp, int256)\r\n    return convert(max(rpoint.slope * time + rpoint.bias, empty(int256)), uint256)\r\n\r\n\r\n@view\r\n@external\r\ndef token_boost(_token_id: uint256) -> int256:\r\n    \"\"\"\r\n    @notice Query the effective value of a boost\r\n    @dev The effective value of a boost is negative after it's expiration\r\n        date.\r\n    @param _token_id The token id to query\r\n    \"\"\"\r\n    tpoint: Point = self._deconstruct_bias_slope(self.boost_tokens[_token_id].data)\r\n    time: int256 = convert(block.timestamp, int256)\r\n    return tpoint.slope * time + tpoint.bias\r\n\r\n\r\n@view\r\n@external\r\ndef token_expiry(_token_id: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Query the timestamp of a boost token's expiry\r\n    @dev The effective value of a boost is negative after it's expiration\r\n        date.\r\n    @param _token_id The token id to query\r\n    \"\"\"\r\n    return self.boost_tokens[_token_id].expire_time\r\n\r\n\r\n@view\r\n@external\r\ndef token_cancel_time(_token_id: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Query the timestamp of a boost token's cancel time. This is\r\n        the point at which the delegator can nullify the boost. A receiver\r\n        can cancel a token at any point. Anyone can nullify a token's boost\r\n        after it's expiration.\r\n    @param _token_id The token id to query\r\n    \"\"\"\r\n    return self.boost_tokens[_token_id].dinfo % 2 ** 128\r\n\r\n\r\n@view\r\n@external\r\ndef calc_boost_bias_slope(\r\n    _delegator: address,\r\n    _percentage: int256,\r\n    _expire_time: int256,\r\n    _extend_token_id: uint256 = 0\r\n) -> (int256, int256):\r\n    \"\"\"\r\n    @notice Calculate the bias and slope for a boost.\r\n    @param _delegator The account to delegate boost from\r\n    @param _percentage The percentage of the _delegator's delegable\r\n        veCRV to delegate.\r\n    @param _expire_time The time at which the boost value of the token\r\n        will reach 0, and subsequently become negative\r\n    @param _extend_token_id OPTIONAL token id, which if set will first nullify\r\n        the boost of the token, before calculating the bias and slope. Useful\r\n        for calculating the new bias and slope when extending a token, or\r\n        determining the bias and slope of a subsequent token after cancelling\r\n        an existing one. Will have no effect if _delegator is not the delegator\r\n        of the token.\r\n    \"\"\"\r\n    time: int256 = convert(block.timestamp, int256)\r\n    assert _percentage > 0  # dev: percentage must be greater than 0\r\n    assert _percentage <= MAX_PCT  # dev: percentage must be less than or equal to 100%\r\n    assert _expire_time > time + WEEK  # dev: Invalid min expiry time\r\n\r\n    lock_expiry: int256 = convert(VotingEscrow(VOTING_ESCROW).locked__end(_delegator), int256)\r\n    assert _expire_time <= lock_expiry\r\n\r\n    ddata: uint256 = self.boost[_delegator].delegated\r\n\r\n    if _extend_token_id != 0 and convert(shift(_extend_token_id, -96), address) == _delegator:\r\n        # decrease the delegated bias and slope by the token's bias and slope\r\n        # only if it is the delegator's and it is within the bounds of existence\r\n        ddata -= self.boost_tokens[_extend_token_id].data\r\n\r\n    dpoint: Point = self._deconstruct_bias_slope(ddata)\r\n\r\n    delegated_boost: int256 = dpoint.slope * time + dpoint.bias\r\n    assert delegated_boost >= 0  # dev: outstanding negative boosts\r\n\r\n    y: int256 = _percentage * (VotingEscrow(VOTING_ESCROW).balanceOf(_delegator) - delegated_boost) / MAX_PCT\r\n    assert y > 0  # dev: no boost\r\n\r\n    slope: int256 = -y / (_expire_time - time)\r\n    assert slope < 0  # dev: invalid slope\r\n\r\n    bias: int256 = y - slope * time\r\n\r\n    return bias, slope\r\n\r\n\r\n@pure\r\n@external\r\ndef get_token_id(_delegator: address, _id: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Simple method to get the token id's mintable by a delegator\r\n    @param _delegator The address of the delegator\r\n    @param _id The id value, must be less than 2 ** 96\r\n    \"\"\"\r\n    assert _id < 2 ** 96  # dev: invalid _id\r\n    return shift(convert(_delegator, uint256), 96) + _id\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_addr: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of contract to `addr`\r\n    @param _addr Address to have ownership transferred to\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    self.future_admin = _addr\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership():\r\n    \"\"\"\r\n    @notice Accept admin role, only callable by future admin\r\n    \"\"\"\r\n    future_admin: address = self.future_admin\r\n    assert msg.sender == future_admin\r\n    self.admin = future_admin\r\n\r\n\r\n@external\r\ndef set_base_uri(_base_uri: String[128]):\r\n    assert msg.sender == self.admin\r\n    self.base_uri = _base_uri","ABI":"[{\"name\":\"Approval\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_approved\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_token_id\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApprovalForAll\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_operator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_approved\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_to\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_token_id\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"BurnBoost\",\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_token_id\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"DelegateBoost\",\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_token_id\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_cancel_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_expire_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ExtendBoost\",\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_token_id\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_expire_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_cancel_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TransferBoost\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_to\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_token_id\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_expire_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"GreyListUpdated\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_delegator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_status\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_base_uri\",\"type\":\"string\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_token_id\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":42555},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"safeTransferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_token_id\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"safeTransferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_token_id\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"setApprovalForAll\",\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":37846},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_token_id\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":4948641},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tokenURI\",\"inputs\":[{\"name\":\"_token_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":1386084},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burn\",\"inputs\":[{\"name\":\"_token_id\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":2932661},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"_mint_for_testing\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_token_id\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":861446},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"_burn_for_testing\",\"inputs\":[{\"name\":\"_token_id\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":921023},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"uint_to_string\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":1370397},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"create_boost\",\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_percentage\",\"type\":\"int256\"},{\"name\":\"_cancel_time\",\"type\":\"uint256\"},{\"name\":\"_expire_time\",\"type\":\"uint256\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":1186793},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"extend_boost\",\"inputs\":[{\"name\":\"_token_id\",\"type\":\"uint256\"},{\"name\":\"_percentage\",\"type\":\"int256\"},{\"name\":\"_expire_time\",\"type\":\"uint256\"},{\"name\":\"_cancel_time\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":2335636},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"cancel_boost\",\"inputs\":[{\"name\":\"_token_id\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":4014713},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"batch_cancel_boosts\",\"inputs\":[{\"name\":\"_token_ids\",\"type\":\"uint256[256]\"}],\"outputs\":[],\"gas\":1027671435},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_delegation_status\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_delegator\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":41231},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"batch_set_delegation_status\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_delegators\",\"type\":\"address[256]\"},{\"name\":\"_status\",\"type\":\"uint256[256]\"}],\"outputs\":[],\"gas\":9771652},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"adjusted_balance_of\",\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":17024},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"delegated_boost\",\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":4400},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"received_boost\",\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":4436},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token_boost\",\"inputs\":[{\"name\":\"_token_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"gas\":4969},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token_expiry\",\"inputs\":[{\"name\":\"_token_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3079},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token_cancel_time\",\"inputs\":[{\"name\":\"_token_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3177},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_boost_bias_slope\",\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"},{\"name\":\"_percentage\",\"type\":\"int256\"},{\"name\":\"_expire_time\",\"type\":\"int256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_boost_bias_slope\",\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"},{\"name\":\"_percentage\",\"type\":\"int256\"},{\"name\":\"_expire_time\",\"type\":\"int256\"},{\"name\":\"_extend_token_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"get_token_id\",\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":1330},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":38235},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[],\"outputs\":[],\"gas\":38180},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_base_uri\",\"inputs\":[{\"name\":\"_base_uri\",\"type\":\"string\"}],\"outputs\":[],\"gas\":179322},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3383},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"getApproved\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3313},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"isApprovedForAll\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3658},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ownerOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3373},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":11241},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":11271},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"base_uri\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":18132},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3378},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tokenByIndex\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3523},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tokenOfOwnerByIndex\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3698},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token_of_delegator_by_index\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3728},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"total_minted\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3713},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"account_expiries\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3858},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3558},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3588},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"grey_list\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":4048}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.15","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000016766546585320426f6f73742044656c65676174696f6e00000000000000000000000000000000000000000000000000000000000000000000000000000000000a7665465853426f6f7374000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":""}]}