{"status":"1","message":"OK","result":[{"SourceCode":"// hevm: flattened sources of src/AutoLineJob.sol\r\n// SPDX-License-Identifier: AGPL-3.0-or-later\r\npragma solidity =0.8.9 >=0.8.0;\r\n\r\n////// src/interfaces/IJob.sol\r\n// Copyright (C) 2021 Dai Foundation\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n/* pragma solidity >=0.8.0; */\r\n\r\n/// @title Maker Keeper Network Job\r\n/// @notice A job represents an independant unit of work that can be done by a keeper\r\ninterface IJob {\r\n\r\n    /// @notice Executes this unit of work\r\n    /// @dev Should revert iff workable() returns canWork of false\r\n    /// @param network The name of the external keeper network\r\n    /// @param args Custom arguments supplied to the job, should be copied from workable response\r\n    function work(bytes32 network, bytes calldata args) external;\r\n\r\n    /// @notice Ask this job if it has a unit of work available\r\n    /// @dev This should never revert, only return false if nothing is available\r\n    /// @dev This should normally be a view, but sometimes that's not possible\r\n    /// @param network The name of the external keeper network\r\n    /// @return canWork Returns true if a unit of work is available\r\n    /// @return args The custom arguments to be provided to work() or an error string if canWork is false\r\n    function workable(bytes32 network) external returns (bool canWork, bytes memory args);\r\n\r\n}\r\n\r\n////// src/AutoLineJob.sol\r\n// Copyright (C) 2021 Dai Foundation\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n/* pragma solidity 0.8.9; */\r\n\r\n/* import {IJob} from \"./interfaces/IJob.sol\"; */\r\n\r\ninterface SequencerLike_2 {\r\n    function isMaster(bytes32 network) external view returns (bool);\r\n}\r\n\r\ninterface IlkRegistryLike_1 {\r\n    function list() external view returns (bytes32[] memory);\r\n}\r\n\r\ninterface AutoLineLike_1 {\r\n    function vat() external view returns (address);\r\n    function ilks(bytes32) external view returns (uint256, uint256, uint48, uint48, uint48);\r\n    function exec(bytes32) external returns (uint256);\r\n}\r\n\r\ninterface VatLike_2 {\r\n    function ilks(bytes32) external view returns (uint256, uint256, uint256, uint256, uint256);\r\n}\r\n\r\n/// @title Trigger autoline updates based on thresholds\r\ncontract AutoLineJob is IJob {\r\n\r\n    uint256 constant internal BPS = 10 ** 4;\r\n    \r\n    SequencerLike_2 public immutable sequencer;\r\n    IlkRegistryLike_1 public immutable ilkRegistry;\r\n    AutoLineLike_1 public immutable autoline;\r\n    VatLike_2 public immutable vat;\r\n    uint256 public immutable thi;                       // % above the previously exec'ed debt level\r\n    uint256 public immutable tlo;                       // % below the previously exec'ed debt level\r\n\r\n    // --- Errors ---\r\n    error NotMaster(bytes32 network);\r\n    error OutsideThreshold(uint256 line, uint256 nextLine);\r\n\r\n    constructor(address _sequencer, address _ilkRegistry, address _autoline, uint256 _thi, uint256 _tlo) {\r\n        sequencer = SequencerLike_2(_sequencer);\r\n        ilkRegistry = IlkRegistryLike_1(_ilkRegistry);\r\n        autoline = AutoLineLike_1(_autoline);\r\n        vat = VatLike_2(autoline.vat());\r\n        thi = _thi;\r\n        tlo = _tlo;\r\n    }\r\n\r\n    function work(bytes32 network, bytes calldata args) external override {\r\n        if (!sequencer.isMaster(network)) revert NotMaster(network);\r\n        \r\n        bytes32 ilk = abi.decode(args, (bytes32));\r\n\r\n        (,,, uint256 line,) = vat.ilks(ilk);\r\n        uint256 nextLine = autoline.exec(ilk);\r\n\r\n        // Execution is not enough\r\n        // We need to be over the threshold amounts\r\n        (uint256 maxLine, uint256 gap,,,) = autoline.ilks(ilk);\r\n        if (\r\n            nextLine != maxLine &&\r\n            nextLine < line + gap * thi / BPS &&\r\n            nextLine + gap * tlo / BPS > line\r\n        ) revert OutsideThreshold(line, nextLine);\r\n    }\r\n\r\n    function workable(bytes32 network) external view override returns (bool, bytes memory) {\r\n        if (!sequencer.isMaster(network)) return (false, bytes(\"Network is not master\"));\r\n        \r\n        bytes32[] memory ilks = ilkRegistry.list();\r\n        for (uint256 i = 0; i < ilks.length; i++) {\r\n            bytes32 ilk = ilks[i];\r\n\r\n            (uint256 Art, uint256 rate,, uint256 line,) = vat.ilks(ilk);\r\n            uint256 debt = Art * rate;\r\n            (uint256 maxLine, uint256 gap, uint48 ttl, uint48 last, uint48 lastInc) = autoline.ilks(ilk);\r\n            uint256 nextLine = debt + gap;\r\n            if (nextLine > maxLine) nextLine = maxLine;\r\n\r\n            // Check autoline rules\r\n            if (maxLine == 0) continue;                     // Ilk is not enabled\r\n            if (last == block.number) continue;             // Already triggered this block\r\n            if (line == nextLine ||                         // No change in line\r\n                nextLine > line &&                          // Increase in line\r\n                block.timestamp < lastInc + ttl) continue;  // TTL hasn't expired\r\n\r\n            // Check if current debt level is inside our do-nothing range\r\n            // Re-arranged to remove any subtraction (and thus underflow)\r\n            // Exception if we are at the maxLine\r\n            if (\r\n                nextLine != maxLine &&\r\n                nextLine < line + gap * thi / BPS &&\r\n                nextLine + gap * tlo / BPS > line\r\n            ) continue;\r\n\r\n            // Good to adjust!\r\n            return (true, abi.encode(ilk));\r\n        }\r\n\r\n        return (false, bytes(\"No ilks ready\"));\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sequencer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ilkRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_autoline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_thi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tlo\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"network\",\"type\":\"bytes32\"}],\"name\":\"NotMaster\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"line\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextLine\",\"type\":\"uint256\"}],\"name\":\"OutsideThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"autoline\",\"outputs\":[{\"internalType\":\"contract AutoLineLike_1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ilkRegistry\",\"outputs\":[{\"internalType\":\"contract IlkRegistryLike_1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencer\",\"outputs\":[{\"internalType\":\"contract SequencerLike_2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tlo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vat\",\"outputs\":[{\"internalType\":\"contract VatLike_2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"network\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"args\",\"type\":\"bytes\"}],\"name\":\"work\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"network\",\"type\":\"bytes32\"}],\"name\":\"workable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AutoLineJob","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009566eb72e47e3e20643c0b1dfbee04da5c7e47320000000000000000000000005a464c28d19848f44199d003bef5ecc87d090f87000000000000000000000000c7bdd1f2b16447dcf3de045c4a039a60ec2f0ba300000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000001388","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c494ac13e10dd09209b96071527e18e9a7d8a0c794de970eda7fc308609afc8b"}]}