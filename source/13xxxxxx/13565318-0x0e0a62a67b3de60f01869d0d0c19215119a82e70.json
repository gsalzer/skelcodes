{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BoringHelper.sol\": {\r\n      \"content\": \"\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.6;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n// Copyright (c) 2021 BoringCrypto\\r\\n// Twitter: @Boring_Crypto\\r\\n\\r\\n// Version 22-Mar-2021\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function allowance(address holder, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function owner() external view returns (address);\\r\\n    \\r\\n    function nonces(address user) external view returns (uint256);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IMasterChef {\\r\\n    function BONUS_MULTIPLIER() external view returns (uint256);\\r\\n\\r\\n    function bonusEndBlock() external view returns (uint256);\\r\\n\\r\\n    function devaddr() external view returns (address);\\r\\n\\r\\n    function migrator() external view returns (address);\\r\\n\\r\\n    function owner() external view returns (address);\\r\\n\\r\\n    function startBlock() external view returns (uint256);\\r\\n\\r\\n    function sushi() external view returns (address);\\r\\n\\r\\n    function sushiPerBlock() external view returns (uint256);\\r\\n\\r\\n    function totalAllocPoint() external view returns (uint256);\\r\\n\\r\\n    function poolLength() external view returns (uint256);\\r\\n\\r\\n    function poolInfo(uint256 nr)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        );\\r\\n\\r\\n    function userInfo(uint256 nr, address who) external view returns (uint256, uint256);\\r\\n\\r\\n    function pendingSushi(uint256 nr, address who) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IPair is IERC20 {\\r\\n    function token0() external view returns (IERC20);\\r\\n\\r\\n    function token1() external view returns (IERC20);\\r\\n\\r\\n    function getReserves()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint112,\\r\\n            uint112,\\r\\n            uint32\\r\\n        );\\r\\n}\\r\\n\\r\\ninterface IFactory {\\r\\n    function allPairsLength() external view returns (uint256);\\r\\n\\r\\n    function allPairs(uint256 i) external view returns (IPair);\\r\\n\\r\\n    function getPair(IERC20 token0, IERC20 token1) external view returns (IPair);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n\\r\\n    function feeToSetter() external view returns (address);\\r\\n}\\r\\n\\r\\nlibrary BoringMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n        require((c = a + b) >= b);\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n        require((c = a - b) <= a);\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n        require(b == 0 || (c = a * b) / b == a);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ownable {\\r\\n    address public immutable owner;\\r\\n\\r\\n    constructor() {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner == msg.sender);\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary BoringERC20 {\\r\\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\\r\\n        if (data.length >= 64) {\\r\\n            return abi.decode(data, (string));\\r\\n        } else if (data.length == 32) {\\r\\n            uint8 i = 0;\\r\\n            while (i < 32 && data[i] != 0) {\\r\\n                i++;\\r\\n            }\\r\\n            bytes memory bytesArray = new bytes(i);\\r\\n            for (i = 0; i < 32 && data[i] != 0; i++) {\\r\\n                bytesArray[i] = data[i];\\r\\n            }\\r\\n            return string(bytesArray);\\r\\n        } else {\\r\\n            return \\\"?\\\";\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function symbol(IERC20 token) internal view returns (string memory) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\\r\\n        return success ? returnDataToString(data) : \\\"???\\\";\\r\\n    }\\r\\n\\r\\n    function name(IERC20 token) internal view returns (string memory) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\\r\\n        return success ? returnDataToString(data) : \\\"???\\\";\\r\\n    }\\r\\n\\r\\n    function decimals(IERC20 token) internal view returns (uint8) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\\r\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\r\\n    }\\r\\n\\r\\n    function DOMAIN_SEPARATOR(IERC20 token) internal view returns (bytes32) {\\r\\n        (bool success, bytes memory data) = address(token).staticcall{gas: 10000}(abi.encodeWithSelector(0x3644e515));\\r\\n        return success && data.length == 32 ? abi.decode(data, (bytes32)) : bytes32(0);\\r\\n    }\\r\\n\\r\\n    // function nonces(IERC20 token, address owner) internal view returns (uint256) {\\r\\n    //     (bool success, bytes memory data) = address(token).staticcall{gas: 5000}(abi.encodeWithSelector(0x7ecebe00, owner));\\r\\n    //     return success && data.length == 32 ? abi.decode(data, (uint256)) : uint256(-1); // Use max uint256 to signal failure to retrieve nonce (probably not supported)\\r\\n    // }\\r\\n}\\r\\n\\r\\nlibrary BoringPair {\\r\\n    function factory(IPair pair) internal view returns (IFactory) {\\r\\n        (bool success, bytes memory data) = address(pair).staticcall(abi.encodeWithSelector(0xc45a0155));\\r\\n        return success && data.length == 32 ? abi.decode(data, (IFactory)) : IFactory(0);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IStrategy {\\r\\n    function skim(uint256 amount) external;\\r\\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\\r\\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\\r\\n    function exit(uint256 balance) external returns (int256 amountAdded);\\r\\n}\\r\\n\\r\\ninterface IBentoBox {\\r\\n\\r\\n    function balanceOf(IERC20, address) external view returns (uint256);\\r\\n\\r\\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\\r\\n\\r\\n    function claimOwnership() external;\\r\\n\\r\\n    function deploy(\\r\\n        address masterContract,\\r\\n        bytes calldata data,\\r\\n        bool useCreate2\\r\\n    ) external payable;\\r\\n\\r\\n    function deposit(\\r\\n        IERC20 token_,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 share\\r\\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\\r\\n\\r\\n    function harvest(\\r\\n        IERC20 token,\\r\\n        bool balance,\\r\\n        uint256 maxChangeAmount\\r\\n    ) external;\\r\\n\\r\\n    function masterContractApproved(address, address) external view returns (bool);\\r\\n\\r\\n    function masterContractOf(address) external view returns (address);\\r\\n\\r\\n    function nonces(address) external view returns (uint256);\\r\\n\\r\\n    function owner() external view returns (address);\\r\\n\\r\\n    function pendingOwner() external view returns (address);\\r\\n\\r\\n    function pendingStrategy(IERC20) external view returns (IStrategy);\\r\\n\\r\\n    function permitToken(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    function registerProtocol() external;\\r\\n\\r\\n    function setMasterContractApproval(\\r\\n        address user,\\r\\n        address masterContract,\\r\\n        bool approved,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\\r\\n\\r\\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\\r\\n\\r\\n    function strategy(IERC20) external view returns (IStrategy);\\r\\n\\r\\n    function strategyData(IERC20)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint64 strategyStartDate,\\r\\n            uint64 targetPercentage,\\r\\n            uint128 balance\\r\\n        );\\r\\n\\r\\n    function toAmount(\\r\\n        IERC20 token,\\r\\n        uint256 share,\\r\\n        bool roundUp\\r\\n    ) external view returns (uint256 amount);\\r\\n\\r\\n    function toShare(\\r\\n        IERC20 token,\\r\\n        uint256 amount,\\r\\n        bool roundUp\\r\\n    ) external view returns (uint256 share);\\r\\n\\r\\n    function totals(IERC20) external view returns (uint128 elastic, uint128 base);\\r\\n\\r\\n    function transfer(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 share\\r\\n    ) external;\\r\\n\\r\\n    function transferMultiple(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address[] calldata tos,\\r\\n        uint256[] calldata shares\\r\\n    ) external;\\r\\n\\r\\n    function transferOwnership(\\r\\n        address newOwner,\\r\\n        bool direct,\\r\\n        bool renounce\\r\\n    ) external;\\r\\n\\r\\n    function whitelistMasterContract(address masterContract, bool approved) external;\\r\\n\\r\\n    function whitelistedMasterContracts(address) external view returns (bool);\\r\\n\\r\\n    function withdraw(\\r\\n        IERC20 token_,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 share\\r\\n    ) external returns (uint256 amountOut, uint256 shareOut);\\r\\n}\\r\\n\\r\\nstruct Rebase {\\r\\n    uint128 elastic;\\r\\n    uint128 base;\\r\\n}\\r\\n\\r\\nstruct AccrueInfo {\\r\\n    uint64 interestPerSecond;\\r\\n    uint64 lastAccrued;\\r\\n    uint128 feesEarnedFraction;\\r\\n}\\r\\n\\r\\ninterface IOracle {\\r\\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\\r\\n\\r\\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\\r\\n\\r\\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\\r\\n\\r\\n    function symbol(bytes calldata data) external view returns (string memory);\\r\\n\\r\\n    function name(bytes calldata data) external view returns (string memory);\\r\\n}\\r\\n\\r\\ninterface IKashiPair {\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\r\\n    function accrue() external;\\r\\n\\r\\n    function accrueInfo() external view returns (AccrueInfo memory info);\\r\\n\\r\\n    function addAsset(\\r\\n        address to,\\r\\n        bool skim,\\r\\n        uint256 share\\r\\n    ) external returns (uint256 fraction);\\r\\n\\r\\n    function addCollateral(\\r\\n        address to,\\r\\n        bool skim,\\r\\n        uint256 share\\r\\n    ) external;\\r\\n\\r\\n    function allowance(address, address) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function asset() external view returns (IERC20);\\r\\n\\r\\n    function balanceOf(address) external view returns (uint256);\\r\\n\\r\\n    function bentoBox() external view returns (IBentoBox);\\r\\n\\r\\n    function borrow(address to, uint256 amount) external returns (uint256 part, uint256 share);\\r\\n\\r\\n    function claimOwnership() external;\\r\\n\\r\\n    function collateral() external view returns (IERC20);\\r\\n\\r\\n    function cook(\\r\\n        uint8[] calldata actions,\\r\\n        uint256[] calldata values,\\r\\n        bytes[] calldata datas\\r\\n    ) external payable returns (uint256 value1, uint256 value2);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function exchangeRate() external view returns (uint256);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n\\r\\n    function getInitData(\\r\\n        IERC20 collateral_,\\r\\n        IERC20 asset_,\\r\\n        address oracle_,\\r\\n        bytes calldata oracleData_\\r\\n    ) external pure returns (bytes memory data);\\r\\n\\r\\n    function init(bytes calldata data) external payable;\\r\\n\\r\\n    function isSolvent(address user, bool open) external view returns (bool);\\r\\n\\r\\n    function liquidate(\\r\\n        address[] calldata users,\\r\\n        uint256[] calldata borrowParts,\\r\\n        address to,\\r\\n        address swapper,\\r\\n        bool open\\r\\n    ) external;\\r\\n\\r\\n    function masterContract() external view returns (address);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function nonces(address) external view returns (uint256);\\r\\n\\r\\n    function oracle() external view returns (IOracle);\\r\\n\\r\\n    function oracleData() external view returns (bytes memory);\\r\\n\\r\\n    function owner() external view returns (address);\\r\\n\\r\\n    function pendingOwner() external view returns (address);\\r\\n\\r\\n    function permit(\\r\\n        address owner_,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    function removeAsset(address to, uint256 fraction) external returns (uint256 share);\\r\\n\\r\\n    function removeCollateral(address to, uint256 share) external;\\r\\n\\r\\n    function repay(\\r\\n        address to,\\r\\n        bool skim,\\r\\n        uint256 part\\r\\n    ) external returns (uint256 amount);\\r\\n\\r\\n    function setFeeTo(address newFeeTo) external;\\r\\n\\r\\n    function setSwapper(address swapper, bool enable) external;\\r\\n\\r\\n    function swappers(address) external view returns (bool);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function totalAsset() external view returns (Rebase memory total);\\r\\n\\r\\n    function totalBorrow() external view returns (Rebase memory total);\\r\\n\\r\\n    function totalCollateralShare() external view returns (uint256);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function transferOwnership(\\r\\n        address newOwner,\\r\\n        bool direct,\\r\\n        bool renounce\\r\\n    ) external;\\r\\n\\r\\n    function updateExchangeRate() external returns (bool updated, uint256 rate);\\r\\n\\r\\n    function userBorrowPart(address) external view returns (uint256);\\r\\n\\r\\n    function userCollateralShare(address) external view returns (uint256);\\r\\n\\r\\n    function withdrawFees() external;\\r\\n}\\r\\n/*\\r\\n[\\r\\n\\\"0x0000000000000000000000000000000000000000\\\",\\r\\n\\\"0x0000000000000000000000000000000000000000\\\",\\r\\n\\\"0x0b3f868e0be5597d5db7feb59e1cadbb0fdda50a\\\",\\r\\n\\\"0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270\\\",\\r\\n\\\"0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6\\\",\\r\\n\\\"0xc35dadb65012ec5796536bd9864ed8773abc74c4\\\",\\r\\n\\\"0x5757371414417b8c6caad45baef941abc7d3ab32\\\",\\r\\n\\\"0x0000000000000000000000000000000000000000\\\",\\r\\n\\\"0x0319000133d3ada02600f0875d2cf03d442c3367\\\"\\r\\n]\\r\\n\\\"0x0000000000000000000000000000000000000000\\\",\\\"0x0000000000000000000000000000000000000000\\\",\\\"0x0b3f868e0be5597d5db7feb59e1cadbb0fdda50a\\\",\\\"0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270\\\",\\\"0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6\\\",\\\"0xc35dadb65012ec5796536bd9864ed8773abc74c4\\\",\\\"0x5757371414417b8c6caad45baef941abc7d3ab32\\\",\\\"0x0000000000000000000000000000000000000000\\\",\\\"0x0319000133d3ada02600f0875d2cf03d442c3367\\\"\\r\\n*/\\r\\ncontract BoringHelperV1 is Ownable {\\r\\n    using BoringMath for uint256;\\r\\n    using BoringERC20 for IERC20;\\r\\n    using BoringERC20 for IPair;\\r\\n    using BoringPair for IPair;\\r\\n\\r\\n    IMasterChef public chef; // IMasterChef(0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd);\\r\\n    address public maker; // ISushiMaker(0xE11fc0B43ab98Eb91e9836129d1ee7c3Bc95df50);\\r\\n    IERC20 public sushi; // ISushiToken(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2);\\r\\n    IERC20 public WETH; // 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n    IERC20 public WBTC; // 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\\r\\n    IFactory public sushiFactory; // IFactory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);\\r\\n    IFactory public uniV2Factory; // IFactory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\\r\\n    IERC20 public bar; // 0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272;\\r\\n    IBentoBox public bentoBox; // 0xB5891167796722331b7ea7824F036b3Bdcb4531C\\r\\n\\r\\n    constructor(\\r\\n        IMasterChef chef_,\\r\\n        address maker_,\\r\\n        IERC20 sushi_,\\r\\n        IERC20 WETH_,\\r\\n        IERC20 WBTC_,\\r\\n        IFactory sushiFactory_,\\r\\n        IFactory uniV2Factory_,\\r\\n        IERC20 bar_,\\r\\n        IBentoBox bentoBox_\\r\\n    ) {\\r\\n        chef = chef_;\\r\\n        maker = maker_;\\r\\n        sushi = sushi_;\\r\\n        WETH = WETH_;\\r\\n        WBTC = WBTC_;\\r\\n        sushiFactory = sushiFactory_;\\r\\n        uniV2Factory = uniV2Factory_;\\r\\n        bar = bar_;\\r\\n        bentoBox = bentoBox_;\\r\\n    }\\r\\n\\r\\n    function setContracts(\\r\\n        IMasterChef chef_,\\r\\n        address maker_,\\r\\n        IERC20 sushi_,\\r\\n        IERC20 WETH_,\\r\\n        IERC20 WBTC_,\\r\\n        IFactory sushiFactory_,\\r\\n        IFactory uniV2Factory_,\\r\\n        IERC20 bar_,\\r\\n        IBentoBox bentoBox_\\r\\n    ) public onlyOwner {\\r\\n        chef = chef_;\\r\\n        maker = maker_;\\r\\n        sushi = sushi_;\\r\\n        WETH = WETH_;\\r\\n        WBTC = WBTC_;\\r\\n        sushiFactory = sushiFactory_;\\r\\n        uniV2Factory = uniV2Factory_;\\r\\n        bar = bar_;\\r\\n        bentoBox = bentoBox_;\\r\\n    }\\r\\n\\r\\n    function getETHRate(IERC20 token) public view returns (uint256) {\\r\\n        if (token == WETH) {\\r\\n            return 1e18;\\r\\n        }\\r\\n        IPair pairUniV2;\\r\\n        IPair pairSushi;\\r\\n        if (uniV2Factory != IFactory(0)) {\\r\\n            pairUniV2 = IPair(uniV2Factory.getPair(token, WETH));\\r\\n        }\\r\\n        if (sushiFactory != IFactory(0)) {\\r\\n            pairSushi = IPair(sushiFactory.getPair(token, WETH));\\r\\n        }\\r\\n        if (address(pairUniV2) == address(0) && address(pairSushi) == address(0)) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint112 reserve0;\\r\\n        uint112 reserve1;\\r\\n        IERC20 token0;\\r\\n        if (address(pairUniV2) != address(0)) {\\r\\n            (uint112 reserve0UniV2, uint112 reserve1UniV2, ) = pairUniV2.getReserves();\\r\\n            reserve0 += reserve0UniV2;\\r\\n            reserve1 += reserve1UniV2;\\r\\n            token0 = pairUniV2.token0();\\r\\n        }\\r\\n\\r\\n        if (address(pairSushi) != address(0)) {\\r\\n            (uint112 reserve0Sushi, uint112 reserve1Sushi, ) = pairSushi.getReserves();\\r\\n            reserve0 += reserve0Sushi;\\r\\n            reserve1 += reserve1Sushi;\\r\\n            if (token0 == IERC20(0)) {\\r\\n                token0 = pairSushi.token0();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (token0 == WETH) {\\r\\n            return (uint256(reserve1) * 1e18) / reserve0;\\r\\n        } else {\\r\\n            return (uint256(reserve0) * 1e18) / reserve1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    struct Factory {\\r\\n        IFactory factory;\\r\\n        uint256 allPairsLength;\\r\\n    }\\r\\n\\r\\n    struct UIInfo {\\r\\n        uint256 ethBalance;\\r\\n        uint256 sushiBalance;\\r\\n        uint256 sushiBarBalance;\\r\\n        uint256 xsushiBalance;\\r\\n        uint256 xsushiSupply;\\r\\n        uint256 sushiBarAllowance;\\r\\n        Factory[] factories;\\r\\n        uint256 ethRate;\\r\\n        uint256 sushiRate;\\r\\n        uint256 btcRate;\\r\\n        uint256 pendingSushi;\\r\\n        uint256 blockTimeStamp;\\r\\n        bool[] masterContractApproved;\\r\\n    }\\r\\n\\r\\n    bytes public a = \\\"ok\\\";\\r\\n\\r\\n    function test() public view returns (bytes memory) {\\r\\n        return a;\\r\\n    }\\r\\n\\r\\n    function getUIInfo(\\r\\n        address who,\\r\\n        IFactory[] calldata factoryAddresses,\\r\\n        IERC20 currency,\\r\\n        address[] calldata masterContracts\\r\\n    ) public view returns (UIInfo memory) {\\r\\n\\r\\n        UIInfo memory info;\\r\\n        info.ethBalance = who.balance;\\r\\n\\r\\n        info.factories = new Factory[](factoryAddresses.length);\\r\\n        for (uint256 i = 0; i < factoryAddresses.length; i++) {\\r\\n            IFactory factory = factoryAddresses[i];\\r\\n            info.factories[i].factory = factory;\\r\\n            info.factories[i].allPairsLength = factory.allPairsLength();\\r\\n        }\\r\\n\\r\\n        info.masterContractApproved = new bool[](masterContracts.length);\\r\\n        for (uint256 i = 0; i < masterContracts.length; i++) {\\r\\n            info.masterContractApproved[i] = bentoBox.masterContractApproved(masterContracts[i], who);\\r\\n        }\\r\\n\\r\\n        if (currency != IERC20(0)) {\\r\\n            info.ethRate = getETHRate(currency);\\r\\n        }\\r\\n\\r\\n        if (WBTC != IERC20(0)) {\\r\\n            info.btcRate = getETHRate(WBTC);\\r\\n        }\\r\\n\\r\\n        if (sushi != IERC20(0)) {\\r\\n            info.sushiRate = getETHRate(sushi);\\r\\n            info.sushiBalance = sushi.balanceOf(who);\\r\\n            info.sushiBarBalance = sushi.balanceOf(address(bar));\\r\\n            info.sushiBarAllowance = sushi.allowance(who, address(bar));\\r\\n        }\\r\\n\\r\\n        if (bar != IERC20(0)) {\\r\\n            info.xsushiBalance = bar.balanceOf(who);\\r\\n            info.xsushiSupply = bar.totalSupply();\\r\\n        }\\r\\n\\r\\n        if (chef != IMasterChef(0)) {\\r\\n            uint256 poolLength = chef.poolLength();\\r\\n            uint256 pendingSushi;\\r\\n            for (uint256 i = 0; i < poolLength; i++) {\\r\\n                try chef.pendingSushi(i, who) {\\r\\n                    pendingSushi += chef.pendingSushi(i, who);\\r\\n                } catch {}\\r\\n            }\\r\\n            info.pendingSushi = pendingSushi;\\r\\n        }\\r\\n        info.blockTimeStamp = block.timestamp;\\r\\n\\r\\n        return info;\\r\\n    }\\r\\n\\r\\n    struct Balance {\\r\\n        IERC20 token;\\r\\n        uint256 balance;\\r\\n        uint256 bentoBalance;\\r\\n    }\\r\\n\\r\\n    struct BalanceFull {\\r\\n        IERC20 token;\\r\\n        uint256 totalSupply;\\r\\n        uint256 balance;\\r\\n        uint256 bentoBalance;\\r\\n        uint256 bentoAllowance;\\r\\n        uint256 nonce;\\r\\n        uint128 bentoAmount;\\r\\n        uint128 bentoShare;\\r\\n        uint256 rate;\\r\\n    }\\r\\n\\r\\n    struct TokenInfo {\\r\\n        IERC20 token;\\r\\n        uint256 decimals;\\r\\n        string name;\\r\\n        string symbol;\\r\\n        bytes32 DOMAIN_SEPARATOR;\\r\\n    }\\r\\n\\r\\n    function getTokenInfo(address[] calldata addresses) public view returns (TokenInfo[] memory) {\\r\\n        TokenInfo[] memory infos = new TokenInfo[](addresses.length);\\r\\n\\r\\n        for (uint256 i = 0; i < addresses.length; i++) {\\r\\n            IERC20 token = IERC20(addresses[i]);\\r\\n            infos[i].token = token;\\r\\n            infos[i].name = token.name();\\r\\n            infos[i].symbol = token.symbol();\\r\\n            infos[i].decimals = token.decimals();\\r\\n            infos[i].DOMAIN_SEPARATOR = token.DOMAIN_SEPARATOR();\\r\\n        }\\r\\n\\r\\n        return infos;\\r\\n    }\\r\\n\\r\\n    function findBalances(address who, address[] calldata addresses) public view returns (Balance[] memory) {\\r\\n        Balance[] memory balances = new Balance[](addresses.length);\\r\\n\\r\\n        uint256 len = addresses.length;\\r\\n        for (uint256 i = 0; i < len; i++) {\\r\\n            IERC20 token = IERC20(addresses[i]);\\r\\n            balances[i].token = token;\\r\\n            balances[i].balance = token.balanceOf(who);\\r\\n            balances[i].bentoBalance = bentoBox.balanceOf(token, who);\\r\\n        }\\r\\n\\r\\n        return balances;\\r\\n    }\\r\\n\\r\\n    function getBalances(address who, IERC20[] calldata addresses) public view returns (BalanceFull[] memory) {\\r\\n        \\r\\n        BalanceFull[] memory balances = new BalanceFull[](addresses.length);\\r\\n        \\r\\n        for (uint256 i = 0; i < addresses.length; i++) {\\r\\n            IERC20 token = addresses[i];\\r\\n            balances[i].token = token;\\r\\n            balances[i].rate = getETHRate(token);\\r\\n            try token.totalSupply()                          { balances[i].totalSupply = token.totalSupply(); }                               catch { balances[i].totalSupply = 0; }\\r\\n            try token.balanceOf(who)                         { balances[i].balance = token.balanceOf(who); }                                  catch { balances[i].balance = 0; }\\r\\n            try token.allowance(who, address(bentoBox))      { balances[i].bentoAllowance = token.allowance(who, address(bentoBox)); }        catch { balances[i].bentoAllowance = 0; }\\r\\n            try token.nonces(who)                            { balances[i].nonce = token.nonces(who); }                                       catch { balances[i].nonce = uint256(-1); }\\r\\n            try bentoBox.balanceOf(token, who)               { balances[i].bentoBalance = bentoBox.balanceOf(token, who); }                   catch { balances[i].bentoBalance = 0; }\\r\\n            try bentoBox.totals(token)                       { (balances[i].bentoAmount, balances[i].bentoShare) = bentoBox.totals(token); }  catch { (balances[i].bentoAmount, balances[i].bentoShare) = (0, 0); }\\r\\n        }\\r\\n\\r\\n        return balances;\\r\\n    }\\r\\n\\r\\n    struct PairBase {\\r\\n        IPair token;\\r\\n        IERC20 token0;\\r\\n        IERC20 token1;\\r\\n        uint256 totalSupply;\\r\\n    }\\r\\n\\r\\n    function getPairs(\\r\\n        IFactory factory,\\r\\n        uint256 fromID,\\r\\n        uint256 toID\\r\\n    ) public view returns (PairBase[] memory) {\\r\\n        PairBase[] memory pairs = new PairBase[](toID - fromID);\\r\\n\\r\\n        for (uint256 id = fromID; id < toID; id++) {\\r\\n            IPair token = factory.allPairs(id);\\r\\n            uint256 i = id - fromID;\\r\\n            pairs[i].token = token;\\r\\n            pairs[i].token0 = token.token0();\\r\\n            pairs[i].token1 = token.token1();\\r\\n            pairs[i].totalSupply = token.totalSupply();\\r\\n        }\\r\\n        return pairs;\\r\\n    }\\r\\n\\r\\n    struct PairPoll {\\r\\n        IPair token;\\r\\n        uint256 reserve0;\\r\\n        uint256 reserve1;\\r\\n        uint256 totalSupply;\\r\\n        uint256 balance;\\r\\n    }\\r\\n\\r\\n    function pollPairs(address who, IPair[] calldata addresses) public view returns (PairPoll[] memory) {\\r\\n        PairPoll[] memory pairs = new PairPoll[](addresses.length);\\r\\n        for (uint256 i = 0; i < addresses.length; i++) {\\r\\n            IPair token = addresses[i];\\r\\n            pairs[i].token = token;\\r\\n            (uint256 reserve0, uint256 reserve1, ) = token.getReserves();\\r\\n            pairs[i].reserve0 = reserve0;\\r\\n            pairs[i].reserve1 = reserve1;\\r\\n            pairs[i].balance = token.balanceOf(who);\\r\\n            pairs[i].totalSupply = token.totalSupply();\\r\\n        }\\r\\n        return pairs;\\r\\n    }\\r\\n\\r\\n    struct PoolsInfo {\\r\\n        uint256 totalAllocPoint;\\r\\n        uint256 poolLength;\\r\\n    }\\r\\n\\r\\n    struct PoolInfo {\\r\\n        uint256 pid;\\r\\n        IPair lpToken;\\r\\n        uint256 allocPoint;\\r\\n        bool isPair;\\r\\n        IFactory factory;\\r\\n        IERC20 token0;\\r\\n        IERC20 token1;\\r\\n        string name;\\r\\n        string symbol;\\r\\n        uint8 decimals;\\r\\n    }\\r\\n\\r\\n    function getPools(uint256[] calldata pids) public view returns (PoolsInfo memory, PoolInfo[] memory) {\\r\\n        PoolsInfo memory info;\\r\\n        info.totalAllocPoint = chef.totalAllocPoint();\\r\\n        uint256 poolLength = chef.poolLength();\\r\\n        info.poolLength = poolLength;\\r\\n\\r\\n        PoolInfo[] memory pools = new PoolInfo[](pids.length);\\r\\n\\r\\n        for (uint256 i = 0; i < pids.length; i++) {\\r\\n            pools[i].pid = pids[i];\\r\\n            (address lpToken, uint256 allocPoint, , ) = chef.poolInfo(pids[i]);\\r\\n            IPair uniV2 = IPair(lpToken);\\r\\n            pools[i].lpToken = uniV2;\\r\\n            pools[i].allocPoint = allocPoint;\\r\\n\\r\\n            pools[i].name = uniV2.name();\\r\\n            pools[i].symbol = uniV2.symbol();\\r\\n            pools[i].decimals = uniV2.decimals();\\r\\n\\r\\n            pools[i].factory = uniV2.factory();\\r\\n            if (pools[i].factory != IFactory(0)) {\\r\\n                pools[i].isPair = true;\\r\\n                pools[i].token0 = uniV2.token0();\\r\\n                pools[i].token1 = uniV2.token1();\\r\\n            }\\r\\n        }\\r\\n        return (info, pools);\\r\\n    }\\r\\n\\r\\n    struct PoolFound {\\r\\n        uint256 pid;\\r\\n        uint256 balance;\\r\\n    }\\r\\n\\r\\n    function findPools(address who, uint256[] calldata pids) public view returns (PoolFound[] memory) {\\r\\n        PoolFound[] memory pools = new PoolFound[](pids.length);\\r\\n\\r\\n        for (uint256 i = 0; i < pids.length; i++) {\\r\\n            pools[i].pid = pids[i];\\r\\n            (pools[i].balance, ) = chef.userInfo(pids[i], who);\\r\\n        }\\r\\n\\r\\n        return pools;\\r\\n    }\\r\\n\\r\\n    struct UserPoolInfo {\\r\\n        uint256 pid;\\r\\n        uint256 balance; // Balance of pool tokens\\r\\n        uint256 totalSupply; // Token staked lp tokens\\r\\n        uint256 lpBalance; // Balance of lp tokens not staked\\r\\n        uint256 lpTotalSupply; // TotalSupply of lp tokens\\r\\n        uint256 lpAllowance; // LP tokens approved for masterchef\\r\\n        uint256 reserve0;\\r\\n        uint256 reserve1;\\r\\n        uint256 rewardDebt;\\r\\n        uint256 pending; // Pending SUSHI\\r\\n    }\\r\\n\\r\\n    function pollPools(address who, uint256[] calldata pids) public view returns (UserPoolInfo[] memory) {\\r\\n        UserPoolInfo[] memory pools = new UserPoolInfo[](pids.length);\\r\\n\\r\\n        for (uint256 i = 0; i < pids.length; i++) {\\r\\n            (uint256 amount, ) = chef.userInfo(pids[i], who);\\r\\n            pools[i].balance = amount;\\r\\n            try chef.pendingSushi(pids[i], who) {\\r\\n                pools[i].pending = chef.pendingSushi(pids[i], who);\\r\\n            } catch {}\\r\\n\\r\\n            (address lpToken, , , ) = chef.poolInfo(pids[i]);\\r\\n            pools[i].pid = pids[i];\\r\\n            IPair uniV2 = IPair(lpToken);\\r\\n            IFactory factory = uniV2.factory();\\r\\n            if (factory != IFactory(0)) {\\r\\n                pools[i].totalSupply = uniV2.balanceOf(address(chef));\\r\\n                pools[i].lpAllowance = uniV2.allowance(who, address(chef));\\r\\n                pools[i].lpBalance = uniV2.balanceOf(who);\\r\\n                pools[i].lpTotalSupply = uniV2.totalSupply();\\r\\n\\r\\n                (uint112 reserve0, uint112 reserve1, ) = uniV2.getReserves();\\r\\n                pools[i].reserve0 = reserve0;\\r\\n                pools[i].reserve1 = reserve1;\\r\\n            }\\r\\n        }\\r\\n        return pools;\\r\\n    }\\r\\n\\r\\n    struct KashiPairPoll {\\r\\n        IERC20 collateral;\\r\\n        IERC20 asset;\\r\\n        IOracle oracle;\\r\\n        bytes oracleData;\\r\\n        uint256 totalCollateralShare;\\r\\n        uint256 userCollateralShare;\\r\\n        Rebase totalAsset;\\r\\n        uint256 userAssetFraction;\\r\\n        Rebase totalBorrow;\\r\\n        uint256 userBorrowPart;\\r\\n        uint256 currentExchangeRate;\\r\\n        uint256 spotExchangeRate;\\r\\n        uint256 oracleExchangeRate;\\r\\n        AccrueInfo accrueInfo;\\r\\n    }\\r\\n\\r\\n    function pollKashiPairs(address who, IKashiPair[] calldata pairsIn) public view returns (KashiPairPoll[] memory) {\\r\\n        uint256 len = pairsIn.length;\\r\\n        KashiPairPoll[] memory pairs = new KashiPairPoll[](len);\\r\\n\\r\\n        for (uint256 i = 0; i < len; i++) {\\r\\n            IKashiPair pair = pairsIn[i];\\r\\n            pairs[i].collateral = pair.collateral();\\r\\n            pairs[i].asset = pair.asset();\\r\\n            pairs[i].oracle = pair.oracle();\\r\\n            pairs[i].oracleData = pair.oracleData();\\r\\n            pairs[i].totalCollateralShare = pair.totalCollateralShare();\\r\\n            pairs[i].userCollateralShare = pair.userCollateralShare(who);\\r\\n            pairs[i].totalAsset = pair.totalAsset();\\r\\n            pairs[i].userAssetFraction = pair.balanceOf(who);\\r\\n            pairs[i].totalBorrow = pair.totalBorrow();\\r\\n            pairs[i].userBorrowPart = pair.userBorrowPart(who);\\r\\n\\r\\n            pairs[i].currentExchangeRate = pair.exchangeRate();\\r\\n            (, pairs[i].oracleExchangeRate) = pair.oracle().peek(pair.oracleData());\\r\\n            pairs[i].spotExchangeRate = pair.oracle().peekSpot(pair.oracleData());\\r\\n            pairs[i].accrueInfo = pair.accrueInfo();\\r\\n        }\\r\\n\\r\\n        return pairs;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IMasterChef\",\"name\":\"chef_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"sushi_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"WETH_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"WBTC_\",\"type\":\"address\"},{\"internalType\":\"contract IFactory\",\"name\":\"sushiFactory_\",\"type\":\"address\"},{\"internalType\":\"contract IFactory\",\"name\":\"uniV2Factory_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"bar_\",\"type\":\"address\"},{\"internalType\":\"contract IBentoBox\",\"name\":\"bentoBox_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"WBTC\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"a\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bar\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bentoBox\",\"outputs\":[{\"internalType\":\"contract IBentoBox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chef\",\"outputs\":[{\"internalType\":\"contract IMasterChef\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"findBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bentoBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringHelperV1.Balance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"pids\",\"type\":\"uint256[]\"}],\"name\":\"findPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringHelperV1.PoolFound[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"getBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bentoBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bentoAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"bentoAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"bentoShare\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringHelperV1.BalanceFull[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getETHRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toID\",\"type\":\"uint256\"}],\"name\":\"getPairs\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IPair\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringHelperV1.PairBase[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pids\",\"type\":\"uint256[]\"}],\"name\":\"getPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalAllocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolLength\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringHelperV1.PoolsInfo\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"contract IPair\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPair\",\"type\":\"bool\"},{\"internalType\":\"contract IFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"}],\"internalType\":\"struct BoringHelperV1.PoolInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"getTokenInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"DOMAIN_SEPARATOR\",\"type\":\"bytes32\"}],\"internalType\":\"struct BoringHelperV1.TokenInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"contract IFactory[]\",\"name\":\"factoryAddresses\",\"type\":\"address[]\"},{\"internalType\":\"contract IERC20\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"masterContracts\",\"type\":\"address[]\"}],\"name\":\"getUIInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ethBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sushiBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sushiBarBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xsushiBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xsushiSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sushiBarAllowance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract IFactory\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allPairsLength\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringHelperV1.Factory[]\",\"name\":\"factories\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"ethRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sushiRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"btcRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingSushi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimeStamp\",\"type\":\"uint256\"},{\"internalType\":\"bool[]\",\"name\":\"masterContractApproved\",\"type\":\"bool[]\"}],\"internalType\":\"struct BoringHelperV1.UIInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"contract IKashiPair[]\",\"name\":\"pairsIn\",\"type\":\"address[]\"}],\"name\":\"pollKashiPairs\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"oracleData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateralShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userCollateralShare\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"elastic\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"base\",\"type\":\"uint128\"}],\"internalType\":\"struct Rebase\",\"name\":\"totalAsset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"userAssetFraction\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"elastic\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"base\",\"type\":\"uint128\"}],\"internalType\":\"struct Rebase\",\"name\":\"totalBorrow\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"userBorrowPart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotExchangeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oracleExchangeRate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"interestPerSecond\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastAccrued\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"feesEarnedFraction\",\"type\":\"uint128\"}],\"internalType\":\"struct AccrueInfo\",\"name\":\"accrueInfo\",\"type\":\"tuple\"}],\"internalType\":\"struct BoringHelperV1.KashiPairPoll[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"contract IPair[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"pollPairs\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IPair\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringHelperV1.PairPoll[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"pids\",\"type\":\"uint256[]\"}],\"name\":\"pollPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"}],\"internalType\":\"struct BoringHelperV1.UserPoolInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMasterChef\",\"name\":\"chef_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"sushi_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"WETH_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"WBTC_\",\"type\":\"address\"},{\"internalType\":\"contract IFactory\",\"name\":\"sushiFactory_\",\"type\":\"address\"},{\"internalType\":\"contract IFactory\",\"name\":\"uniV2Factory_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"bar_\",\"type\":\"address\"},{\"internalType\":\"contract IBentoBox\",\"name\":\"bentoBox_\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushi\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiFactory\",\"outputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"test\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniV2Factory\",\"outputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BoringHelperV1","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c2edad668740f1aa35e4d8f227fb8e17dca888cd000000000000000000000000e11fc0b43ab98eb91e9836129d1ee7c3bc95df500000000000000000000000006b3595068778dd592e39a122f4f5a5cf09c90fe2000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f0000000000000000000000008798249c2e607446efb7ad49ec89dd1865ff4272000000000000000000000000f5bce5077908a1b7370b9ae04adc565ebd643966","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}