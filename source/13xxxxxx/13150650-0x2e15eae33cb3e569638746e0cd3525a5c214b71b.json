{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/VotingIlluvium.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {ICorePool} from \\\"./ICorePool.sol\\\";\\n\\ncontract VotingIlluvium {\\n    string public constant name = \\\"Voting Illuvium\\\";\\n    string public constant symbol = \\\"vILV\\\";\\n\\n    uint256 public constant decimals = 18;\\n\\n    address public constant ILV = 0x767FE9EDC9E0dF98E07454847909b5E959D7ca0E;\\n    address public constant ILV_POOL = 0x25121EDDf746c884ddE4619b573A7B10714E2a36;\\n    address public constant LP_POOL = 0x8B4d8443a0229349A9892D4F7CbE89eF5f843F72;\\n    address public constant TOKEN_LOCKING = 0xd3b23dBDC485E7559235aBC58c0a3e737e4Aa592;\\n\\n    function balanceOf(address _account) external view returns (uint256 balance) {\\n        uint256 ilvBalance = IERC20(ILV).balanceOf(_account);\\n        uint256 ilvPoolBalance = ICorePool(ILV_POOL).balanceOf(_account);\\n        uint256 lpPoolBalance = _lpToILV(ICorePool(LP_POOL).balanceOf(_account));\\n        uint256 lockedBalance = IERC20(TOKEN_LOCKING).balanceOf(_account);\\n\\n        balance = ilvBalance + ilvPoolBalance + lpPoolBalance + lockedBalance;\\n    }\\n\\n    function totalSupply() external view returns (uint256) {\\n        return IERC20(ILV).totalSupply();\\n    }\\n\\n    function _lpToILV(uint256 _lpBalance) internal view returns (uint256 ilvAmount) {\\n          address _poolToken = ICorePool(LP_POOL).poolToken();\\n\\n          uint256 totalLP = IERC20(_poolToken).totalSupply();\\n          uint256 ilvInLP = IERC20(ILV).balanceOf(_poolToken);\\n          ilvAmount= (ilvInLP * _lpBalance) / totalLP;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/ICorePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport \\\"./IPool.sol\\\";\\n\\ninterface ICorePool is IPool {\\n    function vaultRewardsPerToken() external view returns (uint256);\\n\\n    function poolTokenReserve() external view returns (uint256);\\n\\n    function stakeAsPool(address _staker, uint256 _amount) external;\\n\\n    function receiveVaultRewards(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\n\\n/**\\n * @title Illuvium Pool\\n *\\n * @notice An abstraction representing a pool, see IlluviumPoolBase for details\\n *\\n * @author Pedro Bergamini, reviewed by Basil Gorin\\n */\\ninterface IPool {\\n    /**\\n     * @dev Deposit is a key data structure used in staking,\\n     *      it represents a unit of stake with its amount, weight and term (time interval)\\n     */\\n    struct Deposit {\\n        // @dev token amount staked\\n        uint256 tokenAmount;\\n        // @dev stake weight\\n        uint256 weight;\\n        // @dev locking period - from\\n        uint64 lockedFrom;\\n        // @dev locking period - until\\n        uint64 lockedUntil;\\n        // @dev indicates if the stake was created as a yield reward\\n        bool isYield;\\n    }\\n\\n    // for the rest of the functions see Soldoc in IlluviumPoolBase\\n\\n    function silv() external view returns (address);\\n\\n    function poolToken() external view returns (address);\\n\\n    function isFlashPool() external view returns (bool);\\n\\n    function weight() external view returns (uint32);\\n\\n    function lastYieldDistribution() external view returns (uint64);\\n\\n    function yieldRewardsPerWeight() external view returns (uint256);\\n\\n    function usersLockingWeight() external view returns (uint256);\\n\\n    function pendingYieldRewards(address _user) external view returns (uint256);\\n\\n    function balanceOf(address _user) external view returns (uint256);\\n\\n    function getDeposit(address _user, uint256 _depositId) external view returns (Deposit memory);\\n\\n    function getDepositsLength(address _user) external view returns (uint256);\\n\\n    function stake(\\n        uint256 _amount,\\n        uint64 _lockedUntil,\\n        bool useSILV\\n    ) external;\\n\\n    function unstake(\\n        uint256 _depositId,\\n        uint256 _amount,\\n        bool useSILV\\n    ) external;\\n\\n    function sync() external;\\n\\n    function processRewards(bool useSILV) external;\\n\\n    function setWeight(uint32 _weight) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"ILV\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ILV_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LP_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_LOCKING\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VotingIlluvium","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}