{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"Base64.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// [MIT License]\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos \\u003cbrecht@loopring.org\\u003e\\nlibrary Base64 {\\n    bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"},\"Daemonica.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// https://kanon.art - K21\\n// https://daemonica.io\\n//\\n//\\n//                                   $@@@@@@@@@@@$$$\\n//                               $$@@@@@@$$$$$$$$$$$$$$##\\n//                           $$$$$$$$$$$$$$$$$#########***\\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\\n//                     ##$$$$$$$$$$$$#######****!!!!=========\\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\\n//                 *#################*#***!*!!======;;;:::\\n//                ################********!!!!====;;;:::~~~~~\\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\\n//            ******#**********!*!!!!=!===;;::~~~-,........\\n//           ***************!*!!!!====;;:::~~-,,..........\\n//         !************!!!!!!===;;::~~--,............\\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\\n//        =!!!!!!!!!=!==;;;::~~-,,...........\\n//        =!!!!!!!!!====;;;;:::~~--,........\\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\\n//          ---~~~-----,,,,,........,---,.\\n//           ,,--------,,,,,,.........\\n//             .,,,,,,,,,,,,......\\n//                ...............\\n//                    .........\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n\\nimport \\\"./OccultMath.sol\\\";\\nimport \\\"./Helpers.sol\\\";\\n\\n\\ninterface IBase64 is IERC721Enumerable, IERC721Metadata {}\\n\\ninterface IDaemonica {\\n  function getTau(address _hodler) external view returns (string[] memory);\\n  function getTheta(uint256 _tokenId, uint8 _modulo, string[] memory _tau) external view returns (uint8[8][8] memory);\\n  function isQualified(address _hodler) external view returns (bool);\\n}\\n\\n\\n/** @title Daemonica contract\\n  * @author @0xAnimist\\n  * @notice \\\"Daemonica generates an ever-changing 8 x 8 numerical matrix from base64-encoded\\n  * onchain art. Each matrix is associated with an \\\"Entity,\\\" which in turn can cast \\\"Xe_ntities.\\\"\\n  * The n dimensional relationships that exist within and between each Entity and Xe_ntity can be\\n  * freely interpreted and understood. Use Daemonica however you wish.\\\" –artist\\n  */\\ncontract Daemonica is Ownable, ReentrancyGuard {\\n\\n  uint8 public totalDims = 0;\\n\\n  uint8 public totalAddedDims = 0;\\n  uint8 public maxAddableDims = 128;\\n  mapping (string =\\u003e address) public dimAdder;\\n\\n\\n  uint8 public totalOwnerAddedDims = 0;\\n  uint8 public maxOwnerAddableDims = 128;\\n  bool public presale = true;\\n\\n  address public artist;\\n  uint256 public artistBalance = 0;\\n  uint256 public ownerBalance = 0;\\n\\n  mapping (string =\\u003e IBase64) private dims;\\n  mapping (uint8 =\\u003e string) private symbolStringByIndex;\\n  mapping (string =\\u003e uint8) private symbolIndexByString;\\n\\n\\n  /** @notice Allows only the artist to broadcast a message\\n    * @param  _artist Artists\\u0027s address\\n    * @param  _message Artist\\u0027s message\\n    */\\n  event Broadcast(address indexed _artist, string _message);\\n\\n\\n  /** @notice Only the artist can call function\\n    */\\n  modifier onlyArtist() {\\n    require(artist == _msgSender(), \\\"caller is not the artist\\\");\\n    _;\\n  }\\n\\n  /** @notice Only the artist or owner can call function\\n    */\\n  modifier onlyAdmin() {\\n    require(artist == _msgSender() || owner() == _msgSender(), \\\"caller is not the artist or owner\\\");\\n    _;\\n  }\\n\\n\\n  /** @notice Requires dim with symbol _symbol to be initialized\\n    * @param  _symbol Symbol associated with the dim\\u0027s contract\\n    */\\n  modifier dimExists(string memory _symbol) {\\n    require(Helpers.compareStrings(symbolStringByIndex[symbolIndexByString[_symbol]],_symbol), \\\"dim not exist\\\");\\n    _;\\n  }\\n\\n\\n  /** @notice Allows only the artist to broadcast a message\\n    * @param  _message Artist\\u0027s message\\n    */\\n  function artistBroadcast(string memory _message) external onlyArtist {\\n    emit Broadcast(msg.sender, _message);\\n  }\\n\\n\\n  /** @notice Allows the owner to set the presale flag\\n    * @param  _value the new value\\n    */\\n  function setPresale(bool _value) external onlyOwner {\\n    presale = _value;\\n  }\\n\\n\\n  /** @notice Returns lists of all dims by symbol and address\\n    * @dev    different contracts with the same symbol cannot be registered, only the first registered will be accepted\\n    * @return string array of each dim symbol\\n    * @return address array of each dim contract address\\n    */\\n  function getDims() external view returns (string[] memory, address[] memory) {\\n    string[] memory symbols = new string[](totalDims);\\n    address[] memory addresses = new address[](totalDims);\\n    for(uint8 i = 0; i \\u003c totalDims; i++){\\n      symbols[i] = symbolStringByIndex[i];\\n      addresses[i] = address(dims[symbols[i]]);\\n    }\\n    return (symbols, addresses);\\n  }\\n\\n\\n  /** @notice Registers a new dim\\n    * @dev    different contracts with the same symbol cannot be registered, only the first registered will be accepted\\n    * @param  _address  Contract address of dim to register\\n    */\\n  function registerDim(address _address) internal {\\n    IBase64 dim = IBase64(_address);\\n\\n    //name the new dim symbolically and increment the dims counter\\n    string memory symbol = dim.symbol();\\n    require(!Helpers.compareStrings(dim.symbol(), \\\"\\\"), \\\"requires symbol\\\");\\n    require(!Helpers.compareStrings(symbolStringByIndex[symbolIndexByString[symbol]],symbol), \\\"symbol already registered\\\");\\n\\n    //ensure the new dim is base64 encoded\\n    require(isValidLootverseURI(dim.tokenURI(1)));//test it against the first token\\n\\n    symbolStringByIndex[totalDims] = symbol;\\n    symbolIndexByString[symbol] = totalDims;\\n    totalDims++;\\n\\n    dims[symbol] = dim;\\n    dimAdder[symbol] = _msgSender();\\n  }\\n\\n\\n  /** @notice Allows owner to add a dim with a quota of maxOwnerAddableDims\\n    * @param  _address  Contract address of dim to register\\n    */\\n  function adminAddDim(address _address) external onlyAdmin {\\n    require(totalOwnerAddedDims \\u003c maxOwnerAddableDims, \\\"owner quota exceeded\\\");\\n    registerDim(_address);\\n    totalOwnerAddedDims++;\\n  }\\n\\n\\n  /** @notice Anyone can add a valid dim for 1 ether\\n    * @param  _address  Contract address of dim to register\\n    */\\n  function addDim(address _address) external payable nonReentrant {\\n    require(!presale, \\\"not yet\\\");\\n    require(msg.value \\u003e= 1 ether, \\\"costs 1 eth\\\");\\n    require(totalAddedDims \\u003c maxAddableDims, \\\"public quota exceeded\\\");\\n    registerDim(_address);\\n    totalAddedDims++;\\n    ownerBalance += msg.value/2;\\n    artistBalance += msg.value/2;//TODO (msg.value - msg.value/2);\\n  }\\n\\n  /** @notice Refunds a dimAdder if owner has to delete the dim the added in case\\n    * of emergency\\n    * @param  _symbol Symbol of the dim being removed that needs refunding\\n    */\\n  function refund(string memory _symbol) internal {\\n    require(address(this).balance \\u003e= 1 ether, \\\"owner cannot afford refund\\\");\\n    payable(dimAdder[_symbol]).transfer(1 ether);\\n\\n    uint256 half = (1 ether)/2;\\n    if(ownerBalance \\u003e= half){\\n      if(artistBalance \\u003e= half){\\n        ownerBalance -= half;\\n        artistBalance -= half;\\n      }else{\\n        ownerBalance -= (1 ether) - artistBalance;\\n        artistBalance = 0;\\n      }\\n    }else{\\n      artistBalance -= (1 ether) - ownerBalance;\\n      ownerBalance = 0;\\n    }\\n  }\\n\\n\\n  /** @notice Allows owner to remove a dim and refund the dimAdder\\n    * @dev  Emergency use only\\n    * @param  _symbol Symbol of the dim to remove\\n    */\\n  function adminRemoveDim(string memory _symbol) external onlyAdmin dimExists(_symbol) {\\n    require(totalDims \\u003e 0, \\\"no dims\\\");\\n\\n    refund(_symbol);\\n\\n    delete(dims[_symbol]);//delete the interface\\n    //refactor the mappings\\n    for(uint8 i = symbolIndexByString[_symbol]; i \\u003c totalDims; i++){\\n      symbolStringByIndex[i] = symbolStringByIndex[i+1];\\n      symbolIndexByString[symbolStringByIndex[i]] = i;\\n    }\\n    //delete the mappings\\n    delete(symbolIndexByString[_symbol]);\\n    delete(symbolStringByIndex[totalDims]);\\n    //decrement the count\\n    totalDims--;\\n\\n\\n  }\\n\\n\\n  /** @notice Returns true if the given tokenURI() return value has a valid base64 header, payload, and its contract has a valid symbol\\n    * @param  _str  Return value from tokenURI() to test\\n    * @return  true or false\\n    */\\n  function isValidLootverseURI(string memory _str) internal pure returns (bool) {\\n    require(Helpers.compareStrings(\\\"data:application/json;base64,\\\", Helpers.substring(_str, 0, 29)), \\u0027Invalid prefix\\u0027);\\n    string memory payload = Helpers.substring(_str, 29, 0);\\n    require( OccultMath.isValidBase64String(payload), \\\"non-base64 chars\\\");\\n    return true;\\n  }\\n\\n\\n  /** @notice Returns true if _hodler holds tokens from any dim in _animolist\\n    * @param  _hodler would be _hodler\\n    * @return True or false\\n    */\\n  function isQualified(address _hodler) external view returns (bool){\\n    for(uint8 i = 0; i \\u003c totalDims; i++){\\n      if(dims[symbolStringByIndex[i]].balanceOf(_hodler) \\u003e 0){\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n\\n  /** @notice 𝜏 = tau, a rarely used Greek symbol, *facta bruta* :( 𝜏 symbolizes  ( life | regeneration | resurrection | the power to find new life paths or choices )+. A striking phonetic relationship exists between 𝜏 and \\\"tao\\\", the Chinese term for ( the way | the true path | inner compass )+. *Hic et nunc*, the Daemonican way is death * life, or θ𝜏=X(ξ).\\n    * @dev    Returns any dims in which the _hodler owns at least one token of any tokenId\\n    * @param  _hodler entity hodler\\n    * @return A string array of the symbols of one or more tokens from each dim held by the hodler\\n    */\\n  function getTau(address _hodler) public view returns (string[] memory){\\n    string[] memory tau;\\n    uint8 count = 0;\\n\\n    if(_hodler == address(0)){//no hodler, default to first dim\\n      tau = new string[](1);\\n      tau[count++] = symbolStringByIndex[0];\\n      return tau;\\n    }else{\\n      tau = new string[](totalDims);\\n\\n      for(uint8 i = 0; i \\u003c totalDims; i++){\\n        if(dims[symbolStringByIndex[i]].balanceOf(_hodler) \\u003e 0){\\n          tau[count++] = symbolStringByIndex[i];\\n        }\\n      }\\n\\n      if(count == 0){//default to first dim\\n        string[] memory output = new string[](1);\\n        output[0] = symbolStringByIndex[0];\\n        return output;\\n      }else{//splice to length\\n        string[] memory output = new string[](count);\\n        for(uint8 i = 0; i \\u003c count; i++){\\n          output[i] = tau[i];\\n        }\\n        return output;\\n      }\\n    }\\n  }\\n\\n\\n  /** @notice θ = theta, symbol of change in angle or rotation. *Thanatos* (death) hides in this symbol. There is no ξ without θ, no *existentialia* without change. θ is also therefore a talismanic sign for passage to the “underworld”, to a realm closer to life’s origins.\\n    * @dev    Returns theta, the 8x8 base-_modulo frequency matrix of an entity\\n    * @param  _tokenId  tokenId of the entity being queried\\n    * @param  _modulo   caps all values at base-_modulo\\n    * @param  _tau      tau is the dimensions of _tokenId\\u0027s hodler\\n    */\\n  function getTheta(uint256 _tokenId, uint8 _modulo, string[] memory _tau) external view returns (uint8[8][8] memory) {\\n    bytes[] memory bytePayloads = new bytes[](_tau.length);\\n\\n    for(uint8 i = 0; i \\u003c _tau.length; i++){\\n      bytePayloads[i] = bytes(Helpers.substring(dims[_tau[i]].tokenURI(_tokenId), 29, 0));\\n    }\\n\\n    uint8[8][8] memory thetas = OccultMath.sixtyFourier(bytePayloads, _modulo);\\n\\n    return thetas;\\n  }\\n\\n\\n  /** @notice Allows owner to withdraw available balance\\n    */\\n  function ownerWithdrawAvailableBalance() public nonReentrant onlyOwner {\\n      uint256 b = ownerBalance;\\n      ownerBalance = 0;\\n      payable(msg.sender).transfer(b);\\n  }\\n\\n  /** @notice Allows artist to withdraw available balance\\n    */\\n  function artistWithdrawAvailableBalance() public nonReentrant onlyArtist {\\n      uint256 b = artistBalance;\\n      artistBalance = 0;\\n      payable(msg.sender).transfer(b);\\n  }\\n\\n\\n  /** @notice Daemonica constructor\\n    * @param _artist The Ethereum address of the artist\\n    */\\n  constructor (address _artist) {\\n    artist = _artist;\\n  }\\n\\n\\n}\\n\"},\"Entity.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// https://kanon.art - K21\\n// https://daemonica.io\\n//\\n//\\n//                                   $@@@@@@@@@@@$$$\\n//                               $$@@@@@@$$$$$$$$$$$$$$##\\n//                           $$$$$$$$$$$$$$$$$#########***\\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\\n//                     ##$$$$$$$$$$$$#######****!!!!=========\\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\\n//                 *#################*#***!*!!======;;;:::\\n//                ################********!!!!====;;;:::~~~~~\\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\\n//            ******#**********!*!!!!=!===;;::~~~-,........\\n//           ***************!*!!!!====;;:::~~-,,..........\\n//         !************!!!!!!===;;::~~--,............\\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\\n//        =!!!!!!!!!=!==;;;::~~-,,...........\\n//        =!!!!!!!!!====;;;;:::~~--,........\\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\\n//          ---~~~-----,,,,,........,---,.\\n//           ,,--------,,,,,,.........\\n//             .,,,,,,,,,,,,......\\n//                ...............\\n//                    .........\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./ERC721Enumerable.sol\\\";\\n\\n\\nimport \\\"./OccultMath.sol\\\";\\nimport \\\"./Base64.sol\\\";\\nimport \\\"./Daemonica.sol\\\";\\nimport \\\"./Manifest.sol\\\";\\nimport \\\"./Xe_ntity.sol\\\";\\nimport \\\"./Helpers.sol\\\";\\nimport \\\"./Sacred.sol\\\";\\n\\n\\ninterface IEntity is IERC721Enumerable, IERC721Metadata {\\n  function getModulo() external view returns (uint8);\\n  function getTick(uint256 _tokenId, uint256 _tick) external view returns (uint8[8][8] memory, string[] memory, uint256);\\n}\\n\\n\\n/** @title Daemonica Entity contract\\n  * @author @0xAnimist\\n  * @notice Orchestrates the manifestation of n-dimensional Daemonica entities\\n  */\\ncontract Entity is ERC721Enumerable, ReentrancyGuard, Ownable {\\n\\n  bool public initialized = false;\\n\\n  IDaemonica daemonica;\\n  IXe_ntity xe_ntity;\\n\\n  address public artist;\\n  uint256 public artistBalance = 0;\\n  uint256 public ownerBalance = 0;\\n\\n  bool public publicsale = false;\\n  uint256 public maxperhodler = 3;\\n  uint256 public maxperanimo = 3;\\n\\n  uint256 public entitySupply;\\n  uint256 public ownerArtistQuota = 320;\\n  uint256 public ownerArtistClaimed = 0;\\n  uint256 public maxEntities = 4108;//4428-320\\n  uint8 public modulo;\\n  uint256 public offering;\\n\\n  struct Tick {\\n    uint256 newday;//timestamp\\n    uint256 xe_ntityId;//0 for self\\n    string[] tau;//dims\\n  }\\n\\n  mapping (uint256 =\\u003e Tick[]) public ticks;\\n\\n\\n\\n   /** @notice Xe_ntity interface loaded on initialization\\n     */\\n   modifier onlyInitialized() {\\n     require(initialized, \\\"not initialized\\\");\\n     _;\\n   }\\n\\n\\n   /**  @notice Set the value of the publicsale flag\\n     *  @dev Only owner\\n     *  @param _publicsale New value of the publicsale flag\\n     *  @param _maxperhodler New value of the per-address maximum\\n     *  @param _maxperanimo New value of the per-animo maximum\\n     */\\n   function setSaleTerms(bool _publicsale, uint256 _maxperhodler, uint256 _maxperanimo) external onlyOwner {\\n     _publicsale = _publicsale;\\n     maxperhodler = _maxperhodler;\\n     maxperanimo = _maxperanimo;\\n   }\\n\\n   /**  @notice Increase the total entity supply up to a limit maxEntities - artistQuota - ownerQuota\\n     *  @dev Only owner\\n     *  @param _addition Number of entities to add\\n     */\\n   function increaseSupply(uint256 _addition) external onlyOwner {\\n     require((_addition + entitySupply) \\u003c= 4108, \\\"too many\\\");\\n     entitySupply += _addition;\\n   }\\n\\n\\n   /**  @notice Returns modulo state variable\\n     *  @return modulo\\n     */\\n   function getModulo() external view returns (uint8){\\n     return modulo;\\n   }\\n\\n   /**  @notice Returns current tick for an entity with _tokenId\\n     *  @param  _tokenId  TokenId of the entity\\n     *  @return The current tick\\n     */\\n   function getTickCount(uint256 _tokenId) public view returns (uint256){\\n     if(_exists(_tokenId)){\\n       return (ticks[_tokenId].length - 1);\\n     }else{\\n       return 0;\\n     }\\n   }\\n\\n   /**  @notice Returns an entity\\u0027s theta and tau for a given tick value\\n     *  @dev  Future tick values are returned with the present value of tau\\n     *  @param  _tokenId tokenId of the entity\\n     *  @param  _tick Tick value\\n     *  @return theta values (8x8 matrix of numbers from 0 to modulo)\\n     *  @return tau array of dims\\n     */\\n   function getTick(uint256 _tokenId, uint256 _tick) public view returns (uint8[8][8] memory, string[] memory, uint256) {\\n     string[] memory tau;\\n     uint8[8][8] memory theta;\\n     uint256 newday;\\n\\n     //future ticks default to present\\n     if(!_exists(_tokenId)){\\n       //require(_tick == 0, \\\"no future without animo\\\");\\n       tau = daemonica.getTau(address(0));\\n       newday = 0;\\n       theta = daemonica.getTheta(_tokenId, modulo, tau);\\n       return (theta, tau, newday);\\n     }else{\\n       if(_tick \\u003c getTickCount(_tokenId)){//all past ticks\\n         tau = ticks[_tokenId][_tick].tau;\\n         newday = ticks[_tokenId][_tick].newday;\\n       }else{//current and future ticks\\n         tau = daemonica.getTau(ownerOf(_tokenId));//all current and future ticks use current tau\\n         newday = block.timestamp;\\n       }\\n     }\\n\\n     theta = daemonica.getTheta(_tokenId, modulo, tau);\\n\\n     for(uint256 i = 0; i \\u003c _tick; i++){\\n       theta = OccultMath.sub888(theta, OccultMath.syzygy888(theta, modulo));\\n     }\\n\\n     return (theta, tau, newday);\\n   }\\n\\n\\n\\n   /**  @notice Calculates and returns base64 encoded entity metadata and image SVG\\n     *  @dev Uses the Manifest library\\n     *  @param _tokenId tokenId of the entity to render\\n     */\\n   function tokenURI(uint256 _tokenId) override public view returns (string memory) {\\n     return tokenURI(_tokenId, getTickCount(_tokenId));\\n   }\\n\\n\\n\\n   /**  @notice Calculates and returns base64 encoded entity metadata and image SVG for a given moment in the entity\\u0027s timeline\\n     *  @dev Uses the Manifest library\\n     *  @param _tokenId tokenId of the entity to render\\n     *  @param _tick Moment in the entity\\u0027s timeline to render\\n     */\\n   function tokenURI(uint256 _tokenId, uint256 _tick) public view returns (string memory) {\\n     uint8[8][8] memory theta;\\n     string[] memory tau;\\n     uint256 newday;\\n\\n     if(_exists(_tokenId)){\\n       (theta, tau, newday) = getTick(_tokenId, _tick);\\n       return Manifest.entity(_tokenId, theta, tau, _tick, newday);\\n     }else{\\n       tau = daemonica.getTau(address(0));\\n       theta = daemonica.getTheta(_tokenId, modulo, tau);\\n       return Manifest.entity(_tokenId, theta, tau, 0, 0);\\n     }\\n   }\\n\\n   /**  @notice Mints the next available entity if msg.sender and msg.value qualifies\\n     */\\n  function animo() external payable {\\n    animoMulti(1);\\n  }\\n\\n\\n   /**  @notice Mints the next available _n entities if msg.sender and msg.value qualifies\\n     *  @dev _n is gated by maxperanimo and maxperhodler\\n     *  @param _n The number of entities to mint\\n     */\\n  function animoMulti(uint256 _n) public payable nonReentrant {\\n    if(_msgSender() == owner()){\\n      require((ownerArtistClaimed + _n) \\u003c ownerArtistQuota, \\\"no more, owner and artist\\\");\\n    }else{\\n      if(maxperanimo \\u003e 0){\\n        require(_n \\u003c= maxperanimo, \\\"too many at one time\\\");\\n      }\\n      require((totalSupply() + _n) \\u003c= entitySupply, \\\"no more\\\");\\n      require((offering * _n) \\u003c= msg.value, \\\"insufficient offering\\\");\\n      require(daemonica.isQualified(_msgSender()), \\\"must hodl \\u003e= 1 qualified token\\\");\\n      if(maxperhodler \\u003e 0){//maxperhodler == 0 == unlimited\\n        require((balanceOf(_msgSender()) + _n) \\u003c= maxperhodler, \\\"quota exceeded\\\");\\n      }\\n      ownerBalance += msg.value/2;\\n      artistBalance += (msg.value - (msg.value/2));\\n    }\\n\\n    for(uint256 i = 0; i \\u003c _n; i++){\\n      _safeMint(_msgSender(), totalSupply());//start at 0\\n      ticks[totalSupply()-1].push(Tick(block.timestamp, 0, daemonica.getTau(_msgSender())));\\n    }\\n\\n  }\\n\\n\\n  /**  @notice Casts an entity with a xe_ntity\\n    *  @param _tokenId tokenId of the entity to cast\\n    */\\n  function cast(uint256 _tokenId) external payable nonReentrant onlyInitialized {\\n    require(offering / 10 \\u003c= msg.value, \\\"offer up\\\");\\n    require(ownerOf(_tokenId) == _msgSender(), \\\"not hodler\\\");//also throws if !_exists()\\n\\n    string[] memory tau = daemonica.getTau(_msgSender());\\n    uint256 xe_ntityId = xe_ntity.cast(_msgSender(), _tokenId, (ticks[_tokenId].length-1));\\n    ticks[_tokenId].push(Tick(block.timestamp, xe_ntityId, tau));\\n\\n    ownerBalance += msg.value/2;\\n    artistBalance += (msg.value - msg.value/2);\\n  }\\n\\n\\n  /** @notice Allows owner or artist to withdraw available balance\\n    */\\n  function withdrawAvailableBalance() external nonReentrant {\\n    if(_msgSender() == owner()){\\n      uint256 b = ownerBalance;\\n      ownerBalance = 0;\\n      payable(_msgSender()).transfer(b);\\n    }else if(_msgSender() == artist){\\n      uint256 b = artistBalance;\\n      artistBalance = 0;\\n      payable(_msgSender()).transfer(b);\\n    }\\n  }\\n\\n\\n  /**  @notice Initializes the Xe_ntity interface\\n    *  @param _xe_ntityAddress address of the Xe_ntity contract\\n    */\\n  function initialize(address _xe_ntityAddress) external onlyOwner {\\n    require(!initialized, \\\"already initialized\\\");\\n    xe_ntity = IXe_ntity(_xe_ntityAddress);\\n    initialized = true;\\n  }\\n\\n\\n\\n  /**  @notice Entity constructor\\n    *  @param _artist address of the artist\\n    *  @param _entitySupply initial supply of entities\\n    *  @param _modulo puts a ceiling on entity matrix values\\n    *  @param _offering cost of animo/minting an entity and 1/10 cost of casting an entity and minting a xe_ntity\\n    *  @param _daemonicaAddress address of the Daemonica contract\\n    */\\n  constructor(\\n    address _artist,\\n    uint256 _entitySupply,\\n    uint256 _modulo,\\n    uint256 _offering,\\n    address _daemonicaAddress\\n  ) ERC721(\\\"Daemonican Entities\\\", \\\"DAE0\\\") Ownable() {\\n      //STATE\\n      artist = address(_artist);\\n      entitySupply = _entitySupply;\\n      modulo = uint8(_modulo);\\n      offering = _offering;\\n      daemonica = IDaemonica(_daemonicaAddress);\\n  }\\n\\n}\\n\"},\"ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"},\"ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 =\\u003e address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address =\\u003e uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 =\\u003e address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length \\u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``\\u0027s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``\\u0027s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"},\"ERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 =\\u003e uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 =\\u003e uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        require(index \\u003c ERC721.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        require(index \\u003c ERC721Enumerable.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``\\u0027s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``\\u0027s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension\\u0027s ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = ERC721.balanceOf(to);\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension\\u0027s token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension\\u0027s ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from\\u0027s tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\\u0027s index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension\\u0027s token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an \\u0027if\\u0027 statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\\u0027s index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n}\\n\"},\"Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// https://kanon.art - K21\\n// https://daemonica.io\\n//\\n//\\n//                                   $@@@@@@@@@@@$$$\\n//                               $$@@@@@@$$$$$$$$$$$$$$##\\n//                           $$$$$$$$$$$$$$$$$#########***\\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\\n//                     ##$$$$$$$$$$$$#######****!!!!=========\\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\\n//                 *#################*#***!*!!======;;;:::\\n//                ################********!!!!====;;;:::~~~~~\\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\\n//            ******#**********!*!!!!=!===;;::~~~-,........\\n//           ***************!*!!!!====;;:::~~-,,..........\\n//         !************!!!!!!===;;::~~--,............\\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\\n//        =!!!!!!!!!=!==;;;::~~-,,...........\\n//        =!!!!!!!!!====;;;;:::~~--,........\\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\\n//          ---~~~-----,,,,,........,---,.\\n//           ,,--------,,,,,,.........\\n//             .,,,,,,,,,,,,......\\n//                ...............\\n//                    .........\\n\\npragma solidity ^0.8.0;\\n\\n\\n/** @title Daemonica helper functions\\n  * @author @0xAnimist\\n  * @notice Misc support for Daemonica contract suite\\n  */\\nlibrary Helpers{\\n\\n  /** @notice Converts boolean to a string\\n    * @param  value The boolean value\\n    * @return A string that reads \\\"true\\\" or \\\"false\\\"\\n    */\\n  function boolToString(bool value) public pure returns (string memory) {\\n    if(value){\\n      return \\\"true\\\";\\n    }else{\\n      return \\\"false\\\";\\n    }\\n  }\\n\\n  /** @notice Converts uint256 to a string\\n    * @param  value The uint256 value\\n    * @return A string that represents the numerical value of the input\\n    */\\n  function toString(uint256 value) public pure returns (string memory) {\\n  // Inspired by OraclizeAPI\\u0027s implementation - MIT license\\n  // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n      if (value == 0) {\\n          return \\\"0\\\";\\n      }\\n      uint256 temp = value;\\n      uint256 digits;\\n      while (temp != 0) {\\n          digits++;\\n          temp /= 10;\\n      }\\n      bytes memory buffer = new bytes(digits);\\n      while (value != 0) {\\n          digits -= 1;\\n          buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n          value /= 10;\\n      }\\n      return string(buffer);\\n  }\\n\\n  /** @notice Converts uint8 to a string\\n    * @param  value The uint8 value\\n    * @return A string that represents the numerical value of the input\\n    */\\n  function toString8(uint8 value) public pure returns (string memory) {\\n    if (value == 0) {\\n      return \\\"00\\\";\\n    }\\n\\n    uint8 temp = value;\\n    uint8 digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer;\\n    if(digits == 1){\\n      buffer = new bytes(2);\\n      buffer[0] = bytes1(uint8(48));\\n      buffer[1] = bytes1(uint8(48 + uint8(value % 10)));\\n    }else{\\n      buffer = new bytes(digits);\\n      while (value != 0) {\\n        digits -= 1;\\n        buffer[digits] = bytes1(uint8(48 + uint8(value % 10)));\\n        value /= 10;\\n      }\\n    }\\n\\n    return string(buffer);\\n  }\\n\\n\\n\\n  /** @notice Returns a _delimiter delimited string of all the values in an 8 uint8 long array\\n    * @param  _array Array of uint8 values to concatenate\\n    * @param  _delimiter String to delimit each value\\n    * @return Concatenated string of all the values delimited by _delimiter\\n    */\\n  function stringifyRow(uint8[8] memory _array, string memory _delimiter) internal pure returns (string memory) {\\n    string memory output = string(abi.encodePacked(\\n      \\u0027\\u003ctspan x=\\\"153\\\"\\u003e\\u0027,toString8(_array[0]),\\u0027\\u003c/tspan\\u003e\\u0027,_delimiter,\\n      \\u0027\\u003ctspan x=\\\"198\\\"\\u003e\\u0027,toString8(_array[1]),\\u0027\\u003c/tspan\\u003e\\u0027,_delimiter,\\n      \\u0027\\u003ctspan x=\\\"243\\\"\\u003e\\u0027,toString8(_array[2]),\\u0027\\u003c/tspan\\u003e\\u0027,_delimiter\\n    ));\\n\\n    output = string(abi.encodePacked(\\n      output,\\n      \\u0027\\u003ctspan x=\\\"288\\\"\\u003e\\u0027,toString8(_array[3]),\\u0027\\u003c/tspan\\u003e\\u0027,_delimiter,\\n      \\u0027\\u003ctspan x=\\\"333\\\"\\u003e\\u0027,toString8(_array[4]),\\u0027\\u003c/tspan\\u003e\\u0027,_delimiter,\\n      \\u0027\\u003ctspan x=\\\"378\\\"\\u003e\\u0027,toString8(_array[5]),\\u0027\\u003c/tspan\\u003e\\u0027,_delimiter\\n    ));\\n\\n    return string(abi.encodePacked(\\n      output,\\n      \\u0027\\u003ctspan x=\\\"423\\\"\\u003e\\u0027,toString8(_array[6]),\\u0027\\u003c/tspan\\u003e\\u0027,_delimiter,\\n      \\u0027\\u003ctspan x=\\\"468\\\"\\u003e\\u0027,toString8(_array[7]),\\u0027\\u003c/tspan\\u003e\\u0027,_delimiter\\n    ));\\n  }\\n\\n  /** @notice Compares two strings\\n    * @param  _a First string to compare\\n    * @param  _b Second string to compare\\n    * @return True if equal, false if not\\n    */\\n  function compareStrings(string memory _a, string memory _b) public pure returns (bool) {\\n    return (keccak256(abi.encodePacked((_a))) == keccak256(abi.encodePacked((_b))));\\n  }\\n\\n\\n  /** @notice Returns a substring of the given string\\n    * @param  str The string\\n    * @param  startIndex Starting index determining the substring to return\\n    * @param  endIndex Ending index determining the substring to return\\n    * @return Substring parsed from the string\\n    */\\n  function substring(string memory str, uint startIndex, uint endIndex) public pure returns (string memory) {\\n      bytes memory strBytes = bytes(str);\\n      if(endIndex == 0){\\n        endIndex = strBytes.length;\\n      }\\n      bytes memory result = new bytes(endIndex-startIndex);\\n      for(uint i = startIndex; i \\u003c endIndex; i++) {\\n          result[i-startIndex] = strBytes[i];\\n      }\\n      return string(result);\\n  }\\n\\n\\n  /** @notice Returns a pseudorandom number from a string input\\n    * @param  input A string to seed the pseudorandom number generator\\n    * @return  A pseudorandom uint256 number based on the input string\\n    */\\n  function random(string memory input) internal pure returns (uint256) {\\n      return uint256(keccak256(abi.encodePacked(input)));\\n  }\\n\\n\\n}\\n\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``\\u0027s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"},\"IERC721Custodian.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// https://kanon.art - K21\\n// https://daemonica.io\\n//\\n//\\n//                                   $@@@@@@@@@@@$$$\\n//                               $$@@@@@@$$$$$$$$$$$$$$##\\n//                           $$$$$$$$$$$$$$$$$#########***\\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\\n//                     ##$$$$$$$$$$$$#######****!!!!=========\\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\\n//                 *#################*#***!*!!======;;;:::\\n//                ################********!!!!====;;;:::~~~~~\\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\\n//            ******#**********!*!!!!=!===;;::~~~-,........\\n//           ***************!*!!!!====;;:::~~-,,..........\\n//         !************!!!!!!===;;::~~--,............\\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\\n//        =!!!!!!!!!=!==;;;::~~-,,...........\\n//        =!!!!!!!!!====;;;;:::~~--,........\\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\\n//          ---~~~-----,,,,,........,---,.\\n//           ,,--------,,,,,,.........\\n//             .,,,,,,,,,,,,......\\n//                ...............\\n//                    .........\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC721 NFT Custodian contract interface\\n * @author 0xAnimist\\n * @notice For binding two NFTs together\\n */\\ninterface IERC721Custodian is IERC721 {\\n\\n  /** @notice Returns the guardian token contract and tokenId for a given source\\n    * @param _sourceContract The ERC721 source contract for a token in guardianship\\n    * @param _sourceTokenId The tokenId of a ERC721 source token in guardianship\\n    * @return The contract address of the guardian token\\n    * @return The tokenId of the guardian token\\n    */\\n  function getGuardianToken(\\n    address _sourceContract,\\n    uint256 _sourceTokenId\\n  ) external view returns (address, uint256);\\n\\n\\n  /** @notice Returns the owner address of a guardian token\\n    * @param _sourceContract The ERC721 source contract for a token in guardianship\\n    * @param _sourceTokenId The tokenId of a ERC721 source token in guardianship\\n    * @return The Ethereum address of the guardian token\\u0027s owner\\n    */\\n  function getGuardianOwner(\\n    address _sourceContract,\\n    uint256 _sourceTokenId\\n  ) external view returns (address);\\n\\n\\n  /** @notice Returns the message sent by the source NFT owner when they put it\\n    * into guardianship\\n    * @param _sourceContract The ERC721 source contract for a token in guardianship\\n    * @param _xe_ntityId The tokenId of a ERC721 source token in guardianship\\n    * @return The message\\n    */\\n  function getBindingMessage(\\n    address _sourceContract,\\n    uint256 _xe_ntityId\\n  ) external view returns (bytes memory);\\n\\n\\n  /** @notice Binds the source NFT to the guardian NFT, giving the guardian token\\n    * owner the right to claim it at any time by unbinding\\n    * @param _sourceContract The ERC721 source contract for a token in guardianship\\n    * @param _sourceTokenId The tokenId of a ERC721 source token in guardianship\\n    * @param _guardianContract The ERC721 guardian contract\\n    * @param _guardianTokenId The tokenId of a ERC721 guardian token\\n    */\\n  function bind(\\n    address _sourceContract,\\n    uint256 _sourceTokenId,\\n    address _guardianContract,\\n    uint256 _guardianTokenId\\n  ) external;\\n\\n\\n  /** @notice Binds the source NFT to the guardian NFT with a message, giving the\\n    * guardian token owner the right to claim it at any time by unbinding\\n    * @param _sourceContract The ERC721 source contract for a token in guardianship\\n    * @param _sourceTokenId The tokenId of a ERC721 source token in guardianship\\n    * @param _guardianContract The ERC721 guardian contract\\n    * @param _guardianTokenId The tokenId of a ERC721 guardian token\\n    * @param _data The message\\n    */\\n  function bind(\\n    address _sourceContract,\\n    uint256 _sourceTokenId,\\n    address _guardianContract,\\n    uint256 _guardianTokenId,\\n    bytes memory _data\\n  ) external;\\n\\n\\n  /** @notice Unbinds the source NFT from the guardian NFT, giving the guardian\\n    * token owner the ownership of the source NFT\\n    * @param _sourceContract The ERC721 source contract for a token in guardianship\\n    * @param _sourceTokenId The tokenId of a ERC721 source token in guardianship\\n    */\\n  function unbind(\\n    address _sourceContract,\\n    uint256 _sourceTokenId\\n  ) external;\\n\\n\\n  /** @notice Unbinds the source NFT from the guardian NFT with a message, giving\\n    * the guardian token owner the ownership of the source NFT\\n    * @param _sourceContract The ERC721 source contract for a token in guardianship\\n    * @param _sourceTokenId The tokenId of a ERC721 source token in guardianship\\n    * @param _data The message\\n    */\\n  function unbind(\\n    address _sourceContract,\\n    uint256 _sourceTokenId,\\n    bytes memory _data\\n  ) external;\\n\\n}\\n\"},\"IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``\\u0027s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"},\"IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"},\"IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"},\"Manifest.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// https://kanon.art - K21\\n// https://daemonica.io\\n//\\n//\\n//                                   $@@@@@@@@@@@$$$\\n//                               $$@@@@@@$$$$$$$$$$$$$$##\\n//                           $$$$$$$$$$$$$$$$$#########***\\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\\n//                     ##$$$$$$$$$$$$#######****!!!!=========\\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\\n//                 *#################*#***!*!!======;;;:::\\n//                ################********!!!!====;;;:::~~~~~\\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\\n//            ******#**********!*!!!!=!===;;::~~~-,........\\n//           ***************!*!!!!====;;:::~~-,,..........\\n//         !************!!!!!!===;;::~~--,............\\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\\n//        =!!!!!!!!!=!==;;;::~~-,,...........\\n//        =!!!!!!!!!====;;;;:::~~--,........\\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\\n//          ---~~~-----,,,,,........,---,.\\n//           ,,--------,,,,,,.........\\n//             .,,,,,,,,,,,,......\\n//                ...............\\n//                    .........\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Base64.sol\\\";\\nimport \\\"./Helpers.sol\\\";\\nimport \\\"./Sacred.sol\\\";\\n\\n\\n\\n/** @title Daemonica Manifest library\\n  * @author @0xAnimist\\n  * @notice Manifests Daemonica entities\\n  */\\nlibrary Manifest {\\n\\n   string public constant DELIMITER = \\\" \\\";\\n\\n\\n   /** @notice Packs numerical matrix values into a DELIMITER-delimited string\\n     * @param _theta The 8 x 8 matrix of uint8 values\\n     * @return String representation of the matrix\\n     */\\n   function packSvg(uint8[8][8] memory _theta) public pure returns (string memory) {\\n     string[17] memory parts;\\n     parts[0] = \\u0027\\u003csvg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 666 888\\\"\\u003e\\u003cstyle\\u003e.en { fill: #973036; font-family: serif; font-size: 30px; letter-spacing: 3px; white-space: pre; text-align: justify; text-justify: inter-word;}\\u003c/style\\u003e\\u003crect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"black\\\"/\\u003e\\u003ctext y=\\\"150\\\" class=\\\"en\\\"\\u003e\\u0027;\\n\\n     parts[1] = Helpers.stringifyRow(_theta[0], DELIMITER);//row 0\\n\\n     parts[2] = \\u0027\\u003c/text\\u003e\\u003ctext y=\\\"195\\\" class=\\\"en\\\"\\u003e\\u0027;\\n\\n     parts[3] = Helpers.stringifyRow(_theta[1], DELIMITER);//row 1\\n\\n     parts[4] = \\u0027\\u003c/text\\u003e\\u003ctext y=\\\"240\\\" class=\\\"en\\\"\\u003e\\u0027;\\n\\n     parts[5] = Helpers.stringifyRow(_theta[2], DELIMITER);//row 2\\n\\n     parts[6] = \\u0027\\u003c/text\\u003e\\u003ctext y=\\\"285\\\" class=\\\"en\\\"\\u003e\\u0027;\\n\\n     parts[7] = Helpers.stringifyRow(_theta[3], DELIMITER);//row 3\\n\\n     parts[8] = \\u0027\\u003c/text\\u003e\\u003ctext y=\\\"330\\\" class=\\\"en\\\"\\u003e\\u0027;\\n\\n     parts[9] = Helpers.stringifyRow(_theta[4], DELIMITER);//row 4\\n\\n     parts[10] = \\u0027\\u003c/text\\u003e\\u003ctext y=\\\"375\\\" class=\\\"en\\\"\\u003e\\u0027;\\n\\n     parts[11] = Helpers.stringifyRow(_theta[5], DELIMITER);//row 5\\n\\n     parts[12] = \\u0027\\u003c/text\\u003e\\u003ctext y=\\\"420\\\" class=\\\"en\\\"\\u003e\\u0027;\\n\\n     parts[13] = Helpers.stringifyRow(_theta[6], DELIMITER);//row 6\\n\\n     parts[14] = \\u0027\\u003c/text\\u003e\\u003ctext y=\\\"465\\\" class=\\\"en\\\"\\u003e\\u0027;\\n\\n     parts[15] = Helpers.stringifyRow(_theta[7], DELIMITER);//row 7\\n\\n     parts[16] = \\u0027\\u003c/text\\u003e\\u003c/svg\\u003e\\u0027;\\n\\n     string memory output = string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3], parts[4], parts[5], parts[6], parts[7], parts[8]));\\n     output = string(abi.encodePacked(output, parts[9], parts[10], parts[11], parts[12], parts[13], parts[14], parts[15], parts[16]));\\n\\n     return output;\\n   }\\n\\n\\n   /** @notice Packs an entity\\u0027s attributes into a string for rendering as metadata\\n     * @param _tau The dims of an entity at the given moment in 3d time\\n     * @param _tick The tick value of an entity at the given moment in 3d time\\n     */\\n   function packAttributes(string[] memory _tau, uint256 _tick) public pure returns (string memory) {\\n     string memory attributes = string(abi.encodePacked(\\n       \\u0027\\\"attributes\\\": [{ \\\"tick\\\": \\u0027,\\n       Helpers.toString(_tick),\\n       \\u0027},{ \\\"trait_type\\\": \\\"dimensions\\\", \\\"value\\\": \\u0027,\\n       Helpers.toString(_tau.length),\\n       \\u0027}\\u0027\\n     ));\\n\\n     if(_tau.length \\u003e 0){\\n       for(uint8 i = 0; i \\u003c _tau.length-1; i++){\\n         attributes = string(abi.encodePacked(attributes, \\u0027,{ \\\"trait_type\\\": \\\"dimension\\\", \\\"value\\\": \\\"\\u0027, _tau[i], \\u0027\\\"}\\u0027));\\n       }\\n       return string(abi.encodePacked(attributes, \\u0027,{ \\\"trait_type\\\": \\\"dimension\\\", \\\"value\\\": \\\"\\u0027, _tau[_tau.length-1], \\u0027\\\"}],\\u0027));\\n     }else{\\n       return string(abi.encodePacked(attributes, \\u0027],\\u0027));\\n     }\\n   }\\n\\n\\n   /** @notice Manifests a Daemonica entity\\n     * @param _tokenId The _tokenId of the entity to render\\n     * @param _theta The matrix of frequency values of the entity at the given moment in 3d time\\n     * @param _tau The dims of an entity at the given moment in 3d time\\n     * @param _tick The tick value of an entity at the given moment in 3d time\\n     * @param _newday The corresponding block.timestamp to the given moment in 3d time\\n     */\\n   function entity(\\n     uint256 _tokenId,\\n     uint8[8][8] memory _theta,\\n     string[] memory _tau,\\n     uint256 _tick,\\n     uint256 _newday\\n   ) public pure returns (string memory) {\\n     string memory svg = packSvg(_theta);\\n\\n     string memory attributes;\\n\\n     if(_newday \\u003e 0){\\n       attributes = string(abi.encodePacked(\\n         \\u0027\\\"manifested\\\": \\u0027,\\n         Helpers.toString(_newday),\\n         \\u0027,\\u0027,\\n         attributes,\\n         packAttributes(_tau, _tick)\\n       ));\\n     }else{\\n       attributes = string(abi.encodePacked(\\u0027\\\"manifested\\\": 0,\\u0027));\\n     }\\n\\n     string memory json = Base64.encode(\\n       bytes(\\n         string(\\n           abi.encodePacked(\\n             \\u0027{\\\"name\\\": \\\"\\u0027,\\n             Sacred.callBy(_tokenId),\\n             \\u0027\\\", \\\"description\\\": \\\"Daemonican entity \\u0027,\\n             Helpers.toString(_tokenId),\\n             \\u0027\\\\u002F8888: \\u0027,\\n             \\u0027\\\\u03BE = Xi, *in intentione recta*. Ludwig Wittgenstein used \\\\u03BE as a variable in Tractatus Logico-Philosophicus to represent aspects of his \\\\u201Cpropositions\\\\u201D. He was a mystic who hid his incantations in his philosophy, like how 6.522 + 2.003 = 7. A Daemonican entity is also a proposition, *qualitas occulta*.\\u0027,\\n             \\u0027\\\", \\u0027,\\n             attributes,\\n             \\u0027\\\"image\\\": \\\"data:image/svg+xml;base64,\\u0027,\\n             Base64.encode(bytes(svg)), \\u0027\\\"}\\u0027\\n           )\\n         )\\n       )\\n     );\\n\\n     return string(abi.encodePacked(\\u0027data:application/json;base64,\\u0027, json));\\n   }\\n\\n}\\n\"},\"OccultMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// https://kanon.art - K21\\n// https://daemonica.io\\n//\\n//\\n//                                   $@@@@@@@@@@@$$$\\n//                               $$@@@@@@$$$$$$$$$$$$$$##\\n//                           $$$$$$$$$$$$$$$$$#########***\\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\\n//                     ##$$$$$$$$$$$$#######****!!!!=========\\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\\n//                 *#################*#***!*!!======;;;:::\\n//                ################********!!!!====;;;:::~~~~~\\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\\n//            ******#**********!*!!!!=!===;;::~~~-,........\\n//           ***************!*!!!!====;;:::~~-,,..........\\n//         !************!!!!!!===;;::~~--,............\\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\\n//        =!!!!!!!!!=!==;;;::~~-,,...........\\n//        =!!!!!!!!!====;;;;:::~~--,........\\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\\n//          ---~~~-----,,,,,........,---,.\\n//           ,,--------,,,,,,.........\\n//             .,,,,,,,,,,,,......\\n//                ...............\\n//                    .........\\n\\npragma solidity ^0.8.0;\\n\\n\\n/*\\n * @title OccultMath library\\n * @author @0xAnimist\\n * @notice Unsafe Math\\n */\\nlibrary OccultMath {\\n\\n  string public constant defaultTic = \\\":\\\";\\n  string public constant defaultNthPrimeOpen = \\\"(\\\";\\n  string public constant defaultNthPrimeClose = \\\")\\\";\\n  string public constant defaultDeplex = \\\"-P\\\";\\n\\n  struct Index {\\n    uint8 i;\\n    uint8 j;\\n  }\\n\\n\\n  /** @notice Slices an array\\n    * @param _array The array\\n    * @param _length The length of the resulting array\\n    * @return An array with the first _length values of the input array, _array\\n    */\\n  function slice(uint256[] memory _array, uint256 _length) public pure returns (uint256[] memory){\\n    uint256[] memory output = new uint256[](_length);\\n\\n    for (uint256 i = 0; i \\u003c _length; i++) {\\n        output[i] = _array[i];\\n    }\\n\\n    return output;\\n  }\\n\\n\\n  /** @notice Square root of a number\\n    * @param y The number\\n    * @return z Square root of the number, y\\n    */\\n  function sqrt(uint256 y) public pure returns (uint256 z) {\\n      if (y \\u003e 3) {\\n          z = y;\\n          uint256 x = y / 2 + 1;\\n          while (x \\u003c z) {\\n              z = x;\\n              x = (y / x + x) / 2;\\n          }\\n      } else if (y != 0) {\\n          z = 1;\\n      }\\n  }\\n\\n\\n  /** @notice Returns the smallest factor of a number\\n    * @param _number The number\\n    * @return Smallest factor of the number, _number\\n    */\\n  function smallestFactor(uint _number) public pure returns (uint256){\\n    require(_number \\u003e= 2, \\\"Number must be greater than or equal to 2\\\");\\n\\n    if((_number % 2) == 0){\\n      return 2;\\n    }\\n\\n    uint end = sqrt(_number);\\n\\n\\t\\tfor(uint i = 3; i \\u003c= end; i += 2) {\\n\\t\\t\\tif (_number % i == 0)\\n\\t\\t\\t\\treturn i;\\n\\t\\t}\\n\\t\\treturn _number;\\n\\t}\\n\\n\\n  /** @notice Returns an array of the factors of a number\\n    * @param _number The number\\n    * @return Array of factors of the number, _number\\n    */\\n  function factorize(uint256 _number) public pure returns (uint256[] memory){\\n    uint n = _number;\\n    uint[] memory factors = new uint[](100);\\n    uint len = 0;\\n\\n\\t\\twhile (n \\u003e 1) {\\n\\t\\t\\tuint smallest = smallestFactor(n);\\n      require(len \\u003c 100, \\\"factor overflow\\\");\\n      factors[len] = smallest;\\n      len = len + 1;\\n      n = n / smallest;\\n\\t\\t}\\n\\n    uint[] memory output = slice(factors, len);\\n\\n\\t\\treturn output;\\n  }\\n\\n\\n  /** @notice Returns an array of the prime numbers between _first and _last\\n    * @param _first The smallest number to consider\\n    * @param _last The largest number to consider\\n    * @return Array of prime numbers between _first and _last\\n    */\\n  function listPrimes(uint256 _first, uint256 _last) public pure returns (uint256[] memory){\\n    // Validate input and initialize storage for primes\\n    require(_first \\u003e 1, \\\"The starting number must be a positive integer greater than 1\\\");\\n    require(_last \\u003e _first, \\\"The range of search values must be greater than 0\\\");\\n\\n    uint firstPrime = 2;\\n\\n    uint len = _last - firstPrime + 1;\\n    uint256[] memory list = new uint256[](len);\\n\\n    // Generate list of all natural numbers in [_first, _first+_total]\\n    for(uint i = 0; i \\u003c len; i++){\\n      list[i] = i + firstPrime;\\n    }\\n\\n    // Find primes and eliminate their multiples\\n    uint256 limit = sqrt(len);\\n    for(uint256 i = 0; i \\u003c= limit; i++) {\\n      if(list[i] != 0) {\\n        for(uint256 pos = i + list[i]; pos \\u003c len; pos += list[i]) {\\n          list[pos] = 0;\\n        }\\n      }\\n    }\\n\\n    uint256 primesTotal = 0;\\n    uint256 primesIndex = 0;\\n\\n    for(uint256 i = 0; i \\u003c len; i++){\\n      if(list[i] != 0){\\n        primesTotal++;\\n      }\\n    }\\n\\n    uint256[] memory primesList = new uint256[](primesTotal);\\n\\n    // Populate primes[] with all prime numbers in order\\n    for (uint256 i = 0; i \\u003c len; i++) {\\n      if(list[i] != 0){\\n        primesList[primesIndex++] = list[i];\\n      }\\n    }\\n\\n    // Trim primes from given start and return\\n    if (_first != 2) {\\n      uint returnTotal = 0;\\n      for(uint i = 0; i \\u003c primesTotal; i++){\\n        if(primesList[i] \\u003e= _first){\\n          returnTotal = returnTotal + 1;\\n        }\\n      }\\n\\n      uint256[] memory sliced = new uint256[](returnTotal);\\n      uint diff = primesTotal - returnTotal;\\n\\n      for (uint256 i = 0; i \\u003c returnTotal; i++) {\\n        sliced[i] = primesList[i+diff];\\n      }\\n      return sliced;\\n    }\\n\\n    return primesList;\\n  }\\n\\n\\n  /** @notice Returns the base-_base syzygetic pair of a given 8 x 8 matrix of uint8 values\\n    * @param _entity The matrix of an entity\\n    * @param _base The numerical base of the operation\\n    * @return The base-_base syzygetic pair matrix\\n    */\\n  function syzygy888(uint8[8][8] memory _entity, uint8 _base) public pure returns (uint8[8][8] memory) {\\n    uint8[8][8] memory pair;\\n    for(uint8 i = 0; i \\u003c 8; i++){\\n      for(uint8 j = 0; j \\u003c 8; j++){\\n        require(_entity[i][j] \\u003c _base, \\\"entity value out of range\\\");\\n        pair[i][j] = _base - 1 - _entity[i][j];\\n      }\\n    }\\n    return pair;\\n  }\\n\\n\\n  /** @notice Returns the base-_base syzygetic pair of a given uint8 value\\n    * @param _i The uint8 value\\n    * @param _base The numerical base of the operation\\n    * @return The base-_base syzygetic pair value\\n    */\\n  function getSyzygyPartner8(uint8 _i, uint8 _base) public pure returns (uint8) {\\n    require(_i \\u003c= _base, \\\"pair out of range\\\");\\n    return _base - 1 - _i;\\n  }\\n\\n\\n  /** @notice Returns the absolute value of the difference between uint8 values in\\n    * corresponding cells in two 8 x 8 matrices\\n    * @param _a The first matrix\\n    * @param _b The second matrix\\n    * @return The matrix of absolute value differences\\n    */\\n  function sub888(uint8[8][8] memory _a, uint8[8][8] memory _b) public pure returns (uint8[8][8] memory) {\\n    uint8[8][8] memory diff;\\n    for(uint8 i = 0; i \\u003c 8; i++){\\n      for(uint8 j = 0; j \\u003c 8; j++){\\n        if(_a[i][j] \\u003e= _b[i][j]){\\n          diff[i][j] = _a[i][j] - _b[i][j];\\n        }else{\\n          diff[i][j] = _b[i][j] - _a[i][j];\\n        }\\n      }\\n    }\\n    return diff;\\n\\n  }\\n\\n\\n\\n  /** @notice Implements the canonical version of D.C. Barker\\u0027s Tic Xenotation\\n    * @param _number The number to encode\\n    * @return The encoded string value\\n    */\\n  function encodeTX(uint256 _number) public view returns (string memory) {\\n    return encodeTX(_number, defaultTic, defaultNthPrimeOpen, defaultNthPrimeClose, defaultDeplex);\\n  }\\n\\n\\n  /** @notice Implements a customizable version of D.C. Barker\\u0027s Tic Xenotation\\n    * @param _number The number to encode\\n    * @param tic The tic string\\n    * @param nthPrimeOpen Open parenthesis\\n    * @param nthPrimeClose Close parenthesis\\n    * @param deplexToken Deplex token\\n    * @return The encoded string value\\n    */\\n  function encodeTX(\\n    uint256 _number,\\n    string memory tic,//canonically \\\":\\\"\\n    string memory nthPrimeOpen,//canonically \\\"(\\\"\\n    string memory nthPrimeClose,//canonically \\\")\\\"\\n    string memory deplexToken//canonically \\\"-P\\\"\\n  ) public view returns (string memory) {\\n    //zero\\n    if(_number == 0){\\n      return string(abi.encodePacked(nthPrimeOpen, nthPrimeOpen, deplexToken, nthPrimeClose, nthPrimeClose, tic));\\n    }\\n\\n    //one\\n    if(_number == 1){\\n      return string(abi.encodePacked(nthPrimeOpen, deplexToken, nthPrimeClose, tic));\\n    }\\n\\n    //1st prime\\n    if(_number == 2){\\n      return tic;\\n    }\\n\\n    //2nd prime\\n    if(_number == 3){\\n      return string(abi.encodePacked(nthPrimeOpen, tic, nthPrimeClose));\\n    }\\n\\n    //initialize primes\\n    uint256[] memory primes = listPrimes(2, _number);\\n\\n    //initialize hyprimes\\n    uint256[] memory hyprimes = new uint256[](primes[primes.length-1]+1);\\n    for(uint256 i = 0; i \\u003c primes.length; i++){\\n      hyprimes[primes[i]] = i+1; //+1 because primes is 0-based array and hyprimes is 1-based\\n    }\\n\\n    if(primes[primes.length-1] == _number){//ie. if _number is prime it would be the last in the primes array\\n      //nth prime\\n      uint256 ordinate = hyprimes[_number];\\n\\n      string memory output;\\n\\n      if(hyprimes[ordinate] != 0){//ie. if ordinate is prime\\n        //_number is hyprime\\n        output = string(\\n          abi.encodePacked(\\n            encodeTX(\\n              ordinate,\\n              tic,\\n              nthPrimeOpen,\\n              nthPrimeClose,\\n              deplexToken\\n            )));\\n      }else{\\n        //_number is !hyprime\\n        uint[] memory ordinateFactors = factorize(ordinate);\\n\\n        for(uint i = 0; i \\u003c ordinateFactors.length; i++){\\n          output = string(\\n            abi.encodePacked(\\n              encodeTX(\\n                ordinateFactors[i],\\n                tic,\\n                nthPrimeOpen,\\n                nthPrimeClose,\\n                deplexToken\\n              ), output));\\n        }\\n      }\\n      return string(abi.encodePacked(nthPrimeOpen, output, nthPrimeClose));\\n    }else{\\n      uint[] memory factors = factorize(_number);\\n      string memory output = encodeTX(\\n        factors[0],\\n        tic,\\n        nthPrimeOpen,\\n        nthPrimeClose,\\n        deplexToken\\n      );\\n\\n      for(uint i = 1; i \\u003c factors.length; i++){\\n        //encode left to right from the largest factor to the smallest\\n        output = string(\\n          abi.encodePacked(\\n            encodeTX(\\n              factors[i],\\n              tic,\\n              nthPrimeOpen,\\n              nthPrimeClose,\\n              deplexToken\\n            ), output));\\n      }\\n\\n      return output;\\n    }\\n  }\\n\\n\\n  /** @notice Returns the 2d base64 8 x 8 alphanumeric gematria matrix\\n    * @return The Gematrix\\n    */\\n  function getGEMATRIX() public pure returns (uint8[8][8] memory){\\n\\n    uint8[8][8] memory GEMATRIX = [\\n      [ 65,  66,  67,  68,  69,  70,  71,  72], // A B C D E F G H\\n      [ 73,  74,  75,  76,  77,  78,  79,  80], // I J K L M N O P\\n      [ 81,  82,  83,  84,  85,  86,  87,  88], // Q R S T U V W X\\n      [ 89,  90,  97,  98,  99, 100, 101, 102], // Y Z a b c d e f\\n      [103, 104, 105, 106, 107, 108, 109, 110], // g h i j k l m n\\n      [111, 112, 113, 114, 115, 116, 117, 118], // o p q r s t u v\\n      [119, 120, 121, 122,  48,  49,  50,  51], // w x y z 0 1 2 3\\n      [ 52,  53,  54,  55,  56,  57,  43,  47]  // 4 5 6 7 8 9 + /\\n    ];\\n\\n    return GEMATRIX;\\n  }\\n\\n\\n  /** @notice An occult Fourier transform that onverts base64 tokenURI values of\\n    * an array of onchain NFTs into base-_modulo frequency values conformal mapped\\n    * (surjective) to the Gematrix\\n    * @dev For doing onchain art exegesis\\n    * @return The resulting 8 x 8 uint8 matrix of frequency values\\n    */\\n  function sixtyFourier(bytes[] memory _tokenURIs, uint8 _modulo) public pure returns (uint8[8][8] memory) {\\n    require(_modulo \\u003c= 256, \\\"Mod \\u003e 2^8\\\");//modulo cannot exceed max value of uint8\\n    uint8[8][8] memory GEMATRIX = getGEMATRIX();\\n\\n    //build a linear index of the GEMATRIX\\n    Index[] memory index = new Index[](123);//122 is the highest value in the GEMATRIX\\n\\n    //fill in the index values that point on map\\n    for(uint8 i = 0; i \\u003c 8; i++){\\n      for(uint8 j = 0; j \\u003c 8; j++){\\n        index[GEMATRIX[i][j]] = Index(i,j);\\n      }\\n    }\\n\\n    //construct the frequency cipher\\n    uint8[8][8] memory frequencies;\\n    uint8 zero = 0;\\n\\n    for(uint8 t = 0; t \\u003c _tokenURIs.length; t++){\\n\\n      for(uint256 b = 0; b \\u003c _tokenURIs[t].length; b++){\\n        uint8 char = uint8(bytes1(_tokenURIs[t][b]));\\n        if(char != 61){//skip \\\"=\\\"\\n          uint8 i = index[char].i;//TODO plex variable down uint8 i = index[uint8(_tokenURIs[t][d])].i\\n          uint8 j = index[char].j;//TODO plex variable down uint8 j = index[uint8(_tokenURIs[t][d])].j;\\n\\n          //map frequency onto a _modulo-degree circle\\n          //since we are counting one-by-one, this is equivalent to % _modulo\\n          if(frequencies[i][j] == (_modulo - 1)){\\n            frequencies[i][j] = zero;\\n          }else{\\n            frequencies[i][j]++;\\n          }\\n        }\\n\\n      }\\n    }\\n\\n    return frequencies;\\n  }\\n\\n\\n  function isBase64Character(bytes1 _c) public pure returns (bool) {\\n    uint8 _cint = uint8(_c);\\n    //+\\n    if(_cint == 43 || _cint == 47){//+/\\n      return true;\\n    }else if(_cint \\u003e= 48 \\u0026\\u0026 _cint \\u003c= 57){//0-9\\n      return true;\\n    }else if(_cint \\u003e= 65 \\u0026\\u0026 _cint \\u003c= 90){//A-Z\\n      return true;\\n    }else if(_cint \\u003e= 97 \\u0026\\u0026 _cint \\u003c= 122) {//a-z\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n\\n  function isValidBase64String(string memory _string) public pure returns (bool) {\\n    bytes memory data = bytes(_string);\\n    require( (data.length % 4) == 0, \\\"!= %4\\\");\\n\\n    for (uint i = 0; i \\u003c data.length; i++) {\\n      bytes1 c = data[i];\\n      if(!isBase64Character(c)){\\n        if(i \\u003e= (data.length - 3)){//last two bytes may be = for padding\\n          if(uint8(c) != 61){//=\\n            return false;\\n          }\\n        }else{\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"},\"Sacred.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// https://kanon.art - K21\\n// https://daemonica.io\\n//\\n//\\n//                                   $@@@@@@@@@@@$$$\\n//                               $$@@@@@@$$$$$$$$$$$$$$##\\n//                           $$$$$$$$$$$$$$$$$#########***\\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\\n//                     ##$$$$$$$$$$$$#######****!!!!=========\\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\\n//                 *#################*#***!*!!======;;;:::\\n//                ################********!!!!====;;;:::~~~~~\\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\\n//            ******#**********!*!!!!=!===;;::~~~-,........\\n//           ***************!*!!!!====;;:::~~-,,..........\\n//         !************!!!!!!===;;::~~--,............\\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\\n//        =!!!!!!!!!=!==;;;::~~-,,...........\\n//        =!!!!!!!!!====;;;;:::~~--,........\\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\\n//          ---~~~-----,,,,,........,---,.\\n//           ,,--------,,,,,,.........\\n//             .,,,,,,,,,,,,......\\n//                ...............\\n//                    .........\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Helpers.sol\\\";\\n\\n\\n/*\\n * @title Sacred contract\\n * @author @0xAnimist\\n * @notice Used for pseudorandomly assigning sacred names\\n */\\nlibrary Sacred {\\n\\n  uint8 public constant tokensPerName = 4;\\n  uint8 public constant totalNgrams = 89;\\n  string public constant nameDelimiter = \\\".\\\";\\n\\n\\n  /** @notice Returns a sacred syllable from a host of languages, ancient and\\n    * contemporary, based on the _index\\n    * @param _index The index value from 0-88\\n    * @return The sacred syllable ngram\\n    */\\n  function ngram(uint8 _index) public pure returns (string memory) {\\n    string[totalNgrams] memory ngrams = [\\n      //Sanskrit sacred seeds\\n      \\\"\\\\u0101\\\\u1E25\\\",//birth of the universe\\n      \\\"o\\\\u1E43\\\",//opening syllable\\n      \\\"h\\\\u016B\\\\u1E43\\\",//closing syllable\\n      \\\"dh\\\\u012B\\\\u1E25\\\",//perfect wisdom\\n      \\\"pha\\\\u1E6D\\\",//ancient magical word\\n      \\\"au\\\",//Sanskrit, \\\"o\\\"\\n\\n      //Sanskrit consonants, Egyptian and Maori terms\\n      \\\"akh\\\",//Egyptian\\n      \\\"ua\\\",//Egyptian: \\\"one who becomes eight\\\" / \\\"growth comes to be\\\"\\n      \\\"kh\\\",//Egyptian: \\\"pool of water rises up\\\"\\n      \\\"qet\\\",//Egyptian: fire, grain, Serpent, \\\"pedestal gives circle\\\"\\n      \\\"ka\\\",//Sanskrit, Egypt\\n      \\\"kha\\\",//Sanskrit\\n      \\\"ba\\\",//Sanskrit, Egypt\\n      \\\"bha\\\",//Sanskrit\\n      \\\"la\\\",//Sanskrit\\n      \\\"\\\\u1E6Da\\\",//Sanskrit\\n      \\\"\\\\u1E6Dha\\\",//Sanskrit\\n      \\\"pa\\\",//Sanskrit, Maori\\n      \\\"pha\\\",//Sanskrit\\n      \\\"ga\\\",//Sanskrit\\n      \\\"gha\\\",//Sanskrit\\n      \\\"ja\\\",//Sanskrit\\n      \\\"jha\\\",//Sanskrit\\n      \\\"\\\\u1E0Da\\\",//Sanskrit\\n      \\\"\\\\u1E0Dha\\\",//Sanskrit\\n      \\\"\\\\u00F1a\\\",//Sanskrit\\n      \\\"ya\\\",//Sanskrit, Dogon\\n      \\\"ra\\\",//Sanskrit, Egyptian\\n      \\\"\\\\u015Ba\\\",//Sanskrit\\n\\n      //Dogon\\n      \\\"\\\\u0119mm\\\\u0119\\\",//from female sorghum\\n      \\\"p\\\\u014D\\\",//digitaria\\n      \\\"sigi\\\",//Sigui, Sirius\\n      \\\"tolo\\\",//star\\n\\n      //Angels\\n      \\\"el\\\",\\n      \\\"ael\\\",\\n      \\\"iel\\\",\\n      \\\"al\\\",\\n      \\\"iah\\\",\\n      \\\"vehu\\\",\\n      \\\"jel\\\",\\n      \\\"nik\\\",\\n      \\\"sit\\\",\\n      \\\"man\\\",\\n      \\\"leu\\\",\\n\\n      //Goetia\\n      \\\"mon\\\",\\n      \\\"eth\\\",\\n      \\\"deus\\\",\\n      \\\"aga\\\",\\n      \\\"bar\\\",\\n      \\\"ast\\\",\\n      \\\"mur\\\",\\n      \\\"ion\\\",\\n      \\\"tri\\\",\\n      \\\"nab\\\",\\n      \\\"ius\\\",\\n\\n      //Faerie\\n      \\\"tit\\\",\\n      \\\"mabd\\\",\\n      \\\"elf\\\",\\n      \\\"gno\\\",\\n      \\\"tua\\\",\\n      \\\"d\\\\u00E9\\\",\\n      \\\"aos\\\",\\n      \\\"s\\\\u00ED\\\",\\n\\n      //Q\\u0027ero\\n      \\\"ayni\\\",\\n      \\\"hua\\\",\\n      \\\"nee\\\",\\n      \\\"ska\\\",\\n\\n      //Greek\\n      \\\"nym\\\",\\n      \\\"pan\\\",\\n      \\\"syb\\\",\\n\\n      //Urbit\\n      \\\"zod\\\",\\n      \\\"bin\\\",\\n      \\\"ryx\\\",\\n\\n      //Chinese\\n      \\\"tian\\\",\\n      \\\"ren\\\",\\n      \\\"jing\\\",\\n      \\\"dao\\\",\\n      \\\"zhi\\\",\\n      \\\"ye\\\",\\n      \\\"xu\\\",\\n      \\\"shi\\\",\\n      \\\"gu\\\\u01D0\\\",\\n\\n      //Shintoism\\n      \\\"ama\\\",\\n      \\\"chi\\\",\\n      \\\"edo\\\",\\n      \\\"gi\\\",\\n      \\\"kon\\\",\\n      \\\"oni\\\",\\n      \\\"sei\\\"\\n    ];\\n\\n    return ngrams[_index];\\n  }\\n\\n\\n  /** @notice Pseudorandomly selects and punctuates an ngram\\n    * @param _tokenId The _tokenId of the token name to reveal\\n    * @param _index The index of the ngram (for names with \\u003e 1 ngram)\\n    * @return The resulting ngram\\n    */\\n  function pluckNGram(uint256 _tokenId, uint256 _index) public pure returns (string memory) {\\n      uint256 rand = Helpers.random(string(abi.encodePacked(Helpers.toString(_index), Helpers.toString(_tokenId))));\\n      string memory output = ngram(uint8(rand % totalNgrams));\\n      //punctuate pseudorandomly\\n      if(_index \\u003c (tokensPerName - 1)){\\n        uint256 daemonicPotential  = rand % 33;\\n        if (daemonicPotential \\u003e= 13) {\\n            output = string(abi.encodePacked(output, nameDelimiter));\\n        }\\n      }\\n\\n      return output;\\n  }\\n\\n\\n  /** @notice Reveals the name of a token\\n    * @param _tokenId The _tokenId of the token name to reveal\\n    * @return The name of _tokenId\\n    */\\n  function callBy(uint256 _tokenId) public pure returns (string memory) {\\n    string memory name = \\\"\\\";\\n\\n    for(uint i = 0; i \\u003c tokensPerName; i++){\\n      name = string(abi.encodePacked(name, pluckNGram(_tokenId, i)));\\n    }\\n\\n    return name;\\n  }\\n\\n\\n}\\n\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp \\u003e\\u003e= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value \\u0026 0xf];\\n            value \\u003e\\u003e= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"},\"Xe_ntity.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// https://kanon.art - K21\\n// https://daemonica.io\\n//\\n//\\n//                                   $@@@@@@@@@@@$$$\\n//                               $$@@@@@@$$$$$$$$$$$$$$##\\n//                           $$$$$$$$$$$$$$$$$#########***\\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\\n//                     ##$$$$$$$$$$$$#######****!!!!=========\\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\\n//                 *#################*#***!*!!======;;;:::\\n//                ################********!!!!====;;;:::~~~~~\\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\\n//            ******#**********!*!!!!=!===;;::~~~-,........\\n//           ***************!*!!!!====;;:::~~-,,..........\\n//         !************!!!!!!===;;::~~--,............\\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\\n//        =!!!!!!!!!=!==;;;::~~-,,...........\\n//        =!!!!!!!!!====;;;;:::~~--,........\\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\\n//          ---~~~-----,,,,,........,---,.\\n//           ,,--------,,,,,,.........\\n//             .,,,,,,,,,,,,......\\n//                ...............\\n//                    .........\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ERC721Enumerable.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\n\\nimport \\\"./IERC721Custodian.sol\\\";\\n\\nimport \\\"./OccultMath.sol\\\";\\nimport \\\"./Entity.sol\\\";\\nimport \\\"./Base64.sol\\\";\\nimport \\\"./Helpers.sol\\\";\\n\\n\\ninterface IXe_ntity {\\n  function cast(address _hodler, uint256 _entityId, uint256 _tick) external returns (uint256);\\n}\\n\\n/**\\n * @title Daemonica Xe_ntity contract\\n * @author @0xAnimist\\n * @notice Orchestrates the casting and binding of n-dimensional Daemonica xe_entities\\n */\\ncontract Xe_ntity is ERC721Enumerable, ReentrancyGuard, Ownable {\\n\\n  IEntity entity;\\n  IERC721Custodian custodian;\\n  bool public bindable = false;\\n\\n  address public artist;\\n  uint256 public offering;\\n  bool public initialized = false;\\n  uint256 public artistBalance = 0;\\n  uint256 public ownerBalance = 0;\\n\\n  string private tic = \\\"*\\\";\\n  string private nthPrimeOpen = \\\"`   `\\\";\\n  string private nthPrimeClose = \\\"     \\\";\\n  string private deplexToken = \\\"ha\\\";\\n  string private ROW_DELIMITER = \\\"no\\\";\\n  string private COL_DELIMITER = \\\"ys\\\";\\n\\n\\n  /*\\n   *  \\\"Quasiparticle of intensive multiplicity. Tics (or castings) are intrinsically\\n   *  several components of autonomously numbering anorganic populations, propagating\\n   *  by contagion between segmentary divisions in the order of nature. Ticks –\\n   *  as nonqualitative differentially-decomposable counting marks – each designate\\n   *  a multitude comprehended as a singular variation in tic(k)-density.\\\"\\n   *  -Ccru, *Ccru: Writings 1997-2003*, Time Spiral Press\\n   */\\n  struct Cast {\\n    uint256 tick;\\n    uint256 entityId;\\n  }\\n  mapping (uint256 =\\u003e Cast) public castings;\\n\\n\\n  /** @notice Only the Daemonica entity contract can call function\\n    */\\n  modifier onlyEntity() {\\n    require(msg.sender == address(entity), \\\"onlyEntity\\\");//TODO _msgSender()\\n    _;\\n  }\\n\\n\\n  /** @notice Only the Daemonica xe_ntity hodler can call function\\n    */\\n  modifier onlyHodler(uint256 _xe_ntityId) {\\n    require(_exists(_xe_ntityId), \\\"does not exist\\\");\\n    require(ownerOf(_xe_ntityId) == _msgSender(), \\\"not hodler\\\");\\n    _;\\n  }\\n\\n\\n  /** @notice Returns the attributes of the xe_ntity with _tokenId\\n    * @param _tokenId The _tokenId of the xe_ntity\\n    * @return Attributes for rendering with tokenURI\\n    */\\n  function packAttributes(uint256 _tokenId) public view returns (string memory) {\\n    return string(abi.encodePacked(\\n      \\u0027\\\"attributes\\\": [{ \\\"entity\\\": \\u0027,\\n      Helpers.toString(castings[_tokenId].entityId),\\n      \\u0027},{ \\\"tick\\\": \\u0027,\\n      Helpers.toString(castings[_tokenId].entityId),\\n      \\u0027}],\\u0027\\n    ));\\n  }\\n\\n\\n  /**  @notice Calculates and returns base64 encoded xe_ntity metadata and image SVG\\n    *  encoded using Tic Xenotation from the OccultMath library\\n    *  @param _tokenId tokenId of the xe_ntity to render\\n    */\\n  function tokenURI(uint256 _tokenId) override public view returns (string memory) {\\n     string memory X = \\\"\\\";\\n\\n     if(_exists(_tokenId)){\\n       uint8[8][8] memory theta;\\n       (theta,,) = entity.getTick(castings[_tokenId].entityId, castings[_tokenId].tick);\\n\\n       uint8[8][8] memory antiTheta = OccultMath.syzygy888(theta, entity.getModulo());\\n\\n       for(uint8 i = 0; i \\u003c 8; i++){\\n         for(uint8 j = 0; j \\u003c 8; j++){\\n           X = string(abi.encodePacked(\\n             X,\\n             OccultMath.encodeTX(antiTheta[i][j], tic, nthPrimeOpen, nthPrimeClose, deplexToken),\\n             COL_DELIMITER\\n           ));\\n         }\\n         X = string(abi.encodePacked(X, ROW_DELIMITER));\\n       }\\n     }else{\\n       X = \\\"not yet cast\\\";\\n     }\\n\\n     string memory prefix = \\u0027\\u003csvg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 666 888\\\"\\u003e\\u003cstyle\\u003e.xen { color: black; font-family: serif; font-size: 19px; line-height: 19px; white-space: break-spaces; }\\u003c/style\\u003e\\u003crect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"red\\\" /\\u003e\\u003cforeignObject x=\\\"90\\\" y=\\\"90\\\" width=\\\"486\\\" height=\\\"798\\\" class=\\\"xen\\\"\\u003e\\u003cdiv xmlns=\\\"http://www.w3.org/1999/xhtml\\\"\\u003e\\u0027;\\n\\n     string memory postfix = \\u0027\\u003c/div\\u003e\\u003c/foreignObject\\u003e\\u003c/svg\\u003e\\u0027;\\n\\n     string memory output = string(abi.encodePacked(prefix, X, postfix));\\n\\n     string memory json = Base64.encode(\\n       bytes(\\n         string(\\n           abi.encodePacked(\\n             \\u0027{\\\"name\\\": \\\"Xe_ntity #\\u0027,\\n             Helpers.toString(_tokenId),\\n             \\u0027\\\", \\\"description\\\": \\\"Functions are secularized incantations as code. A Xe_ntity is X where X(entity) = entity^. Participants that own an entity can cast a xe_ntity from it, transforming the entity in the process. *Ens divinum cognoscibile per inspirationem est subiectum*=?\\\",\\u0027,\\n             packAttributes(_tokenId),\\n             \\u0027\\\"image\\\": \\\"data:image/svg+xml;base64,\\u0027,\\n             Base64.encode(bytes(output)), \\u0027\\\"}\\u0027\\n           )\\n         )\\n       )\\n     );\\n\\n     return string(abi.encodePacked(\\u0027data:application/json;base64,\\u0027, json));\\n\\n  }\\n\\n  /**  @notice Casts an entity with a xe_ntity, minting the xe_ntity\\n    *  @param _hodler Owner of the entity\\n    *  @param _entityId tokenId of the entity to cast\\n    *  @param _tick 3d time parameter that chronicles how many casts the entity has undergone\\n    */\\n  function cast(address _hodler, uint256 _entityId, uint256 _tick) external nonReentrant onlyEntity returns (uint256){\\n    _safeMint(_hodler, totalSupply()+1);//start at 1\\n    castings[totalSupply()] = Cast(_tick, _entityId);\\n    return totalSupply();\\n  }\\n\\n\\n  /**  @notice Binds the ownership of a xe_ntity to another ERC721 NFT\\n    * @param _xe_ntityId The tokenId of the xe_ntity to bind\\n    * @param _guardianContract The ERC721 guardian contract\\n    * @param _guardianTokenId The tokenId of a ERC721 guardian token\\n    */\\n  function bind(\\n    uint256 _xe_ntityId,\\n    address _guardianContract,\\n    uint256 _guardianTokenId\\n  ) public payable {\\n    bind(_xe_ntityId, _guardianContract, _guardianTokenId, \\\"\\\");\\n  }\\n\\n\\n  /**  @notice Binds the ownership of a xe_ntity to another ERC721 NFT with a message\\n    * @param _xe_ntityId The tokenId of the xe_ntity to bind\\n    * @param _guardianContract The ERC721 guardian contract\\n    * @param _guardianTokenId The tokenId of a ERC721 guardian token\\n    * @param _data The message\\n    */\\n  function bind(\\n    uint256 _xe_ntityId,\\n    address _guardianContract,\\n    uint256 _guardianTokenId,\\n    bytes memory _data\\n  ) public payable nonReentrant {\\n    require(bindable, \\\"not bindable\\\");\\n    require(_msgSender() == ownerOf(_xe_ntityId), \\\"not yours to bind\\\");\\n    require(msg.value \\u003e= offering, \\\"insufficient offering\\\");\\n\\n    custodian.bind(address(this), _xe_ntityId, _guardianContract, _guardianTokenId, _data);\\n\\n    ownerBalance += msg.value/2;\\n    artistBalance += (msg.value - (msg.value/2));\\n  }\\n\\n\\n  /** @notice Unbinds the xe_ntity from the guardian NFT, giving the guardian\\n    * token owner the ownership of the xe_ntity\\n    * @param _xe_ntityId The tokenId of the bound xe_ntity\\n    */\\n  function unbind(\\n    uint256 _xe_ntityId\\n  ) public payable {\\n    unbind(_xe_ntityId, \\\"\\\");\\n  }\\n\\n\\n  /** @notice Unbinds the xe_ntity from the guardian NFT with a message, giving\\n    * the guardian token owner the ownership of the xe_ntity\\n    * @param _xe_ntityId The tokenId of the bound xe_ntity\\n    * @param _data The message\\n    */\\n  function unbind(\\n    uint256 _xe_ntityId,\\n    bytes memory _data\\n  ) public payable nonReentrant {\\n    require(_msgSender() == custodian.getGuardianOwner(address(this), _xe_ntityId), \\\"not yours to unbind\\\");\\n    require(msg.value \\u003e= offering, \\\"insufficient offering\\\");\\n\\n    custodian.unbind(address(this), _xe_ntityId, _data);\\n\\n    ownerBalance += msg.value/2;\\n    artistBalance += (msg.value - (msg.value/2));\\n  }\\n\\n\\n  /** @notice Returns the guardian token contract and tokenId for a given xe_ntity\\n    * @param _xe_ntityId The tokenId of the bound xe_ntity\\n    * @return The contract address of the guardian token\\n    * @return The tokenId of the guardian token\\n    */\\n  function getGuardianToken(\\n    uint256 _xe_ntityId\\n  ) external view returns (address, uint256) {\\n    return custodian.getGuardianToken(address(this), _xe_ntityId);\\n  }\\n\\n\\n  /** @notice Returns the owner address of a guardian token\\n    * @param _xe_ntityId The tokenId of the bound xe_ntity\\n    * @return The Ethereum address of the guardian token\\u0027s owner\\n    */\\n  function getGuardianOwner(\\n    uint256 _xe_ntityId\\n  ) external view returns (address) {\\n    return custodian.getGuardianOwner(address(this), _xe_ntityId);\\n  }\\n\\n\\n  /** @notice Returns the message sent by the source NFT owner when they put it\\n    * into guardianship\\n    * @param _xe_ntityId The tokenId of the bound xe_ntity\\n    * @return The message\\n    */\\n  function getBindingMessage(\\n    uint256 _xe_ntityId\\n  ) external view returns (bytes memory) {\\n    return custodian.getBindingMessage(address(this), _xe_ntityId);\\n  }\\n\\n  /** @notice Sets the address of the guardian contract and initiates binding\\n    * @param _custodianAddress The Ethereum address of the guardian contract\\n    * @param _bindable The new value of the bindable flag\\n    */\\n  function setCustodian(address _custodianAddress, bool _bindable) external onlyOwner {\\n    custodian = IERC721Custodian(_custodianAddress);\\n    bindable = _bindable;\\n  }\\n\\n\\n  /** @notice Allows owner or artist to withdraw available balance\\n    */\\n  function withdrawAvailableBalance() external nonReentrant {\\n    if(_msgSender() == owner()){\\n      uint256 b = ownerBalance;\\n      ownerBalance = 0;\\n      payable(_msgSender()).transfer(b);\\n    }else if(_msgSender() == artist){\\n      uint256 b = artistBalance;\\n      artistBalance = 0;\\n      payable(_msgSender()).transfer(b);\\n    }\\n  }\\n\\n  /**  @notice Initializes the Entity interface\\n    *  @param _entityAddress address of the Entity contract\\n    */\\n  function initialize(address _entityAddress) external onlyOwner {\\n    require(!initialized, \\\"already initialized\\\");\\n    entity = IEntity(_entityAddress);\\n    initialized = true;\\n  }\\n\\n\\n  /**  @notice Xe_ntity constructor\\n    *  @param _artist address of the artist\\n    *  @param _offering cost of binding a xe_ntity\\n    */\\n  constructor(address _artist, uint256 _offering) ERC721(\\\"Daemonic Xe_ntities\\\", \\\"XEN0\\\") Ownable() {\\n    artist = _artist;\\n    offering = _offering;\\n  }\\n\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_artist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offering\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"artist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"artistBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_xe_ntityId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_guardianContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_guardianTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"bind\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_xe_ntityId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_guardianContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_guardianTokenId\",\"type\":\"uint256\"}],\"name\":\"bind\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bindable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hodler\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_entityId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tick\",\"type\":\"uint256\"}],\"name\":\"cast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"castings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tick\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"entityId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_xe_ntityId\",\"type\":\"uint256\"}],\"name\":\"getBindingMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_xe_ntityId\",\"type\":\"uint256\"}],\"name\":\"getGuardianOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_xe_ntityId\",\"type\":\"uint256\"}],\"name\":\"getGuardianToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entityAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offering\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"packAttributes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_custodianAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bindable\",\"type\":\"bool\"}],\"name\":\"setCustodian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_xe_ntityId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"unbind\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_xe_ntityId\",\"type\":\"uint256\"}],\"name\":\"unbind\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAvailableBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Xe_ntity","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002f59aa8b33b0db6ef148f9be2b88a896bd908e9b000000000000000000000000000000000000000000000000001f438daa060000","EVMVersion":"Default","Library":"OccultMath:2175b6b2219dcaaf7020cde8f2b59e0a6f373d45;Helpers:30d432918c74193032c0cd03935b02a3e026b933","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://92e9988b2565cb2c31880566e86082c195bcf63e54fa43a54a30cad604b543ed"}]}