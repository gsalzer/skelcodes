{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CENNZnetBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n// Proof of a witnessed event by CENNZnet validators\\nstruct CENNZnetEventProof {\\n    // The Id (nonce) of the event\\n    uint256 eventId;\\n    // The validator set Id which witnessed the event\\n    uint32 validatorSetId;\\n    // v,r,s are sparse arrays expected to align w public key in 'validators'\\n    // i.e. v[i], r[i], s[i] matches the i-th validator[i]\\n    // v part of validator signatures\\n    uint8[] v;\\n    // r part of validator signatures\\n    bytes32[] r;\\n    // s part of validator signatures\\n    bytes32[] s;\\n}\\n\\n// Provides methods for verifying messages from the CENNZnet validator set\\ncontract CENNZnetBridge is Ownable {\\n    // map from validator set nonce to validator ECDSA addresses (i.e bridge session keys)\\n    // these should be in sorted order matching `pallet_session::Module<T>::validators()`\\n    // signatures from a threshold of these addresses are considered approved by the CENNZnet protocol\\n    mapping(uint => address[]) public validators;\\n    // Nonce for validator set changes\\n    uint32 public activeValidatorSetId;\\n    // Message nonces.\\n    // CENNZnet will only validate one message per nonce.\\n    // Claiming out of order is ok.\\n    mapping(uint => bool) public eventIds;\\n    // Fee for CENNZnet message verification\\n    // Offsets bridge upkeep costs i.e updating the validator set\\n    uint public verificationFee = 1e15;\\n    // Acceptance threshold in %\\n    uint public thresholdPercent = 61;\\n    // Number of eras before a bridge message will be considered expired\\n    uint public proofTTL = 3;\\n    // Whether the bridge is active or not\\n    bool public active = true;\\n    // Max reward paid out to successful caller of `setValidator`\\n    uint public maxRewardPayout = 1e18;\\n\\n    event SetValidators(address[], uint reward, uint32 validatorSetId);\\n\\n    // Verify a message was authorised by CENNZnet validators.\\n    // Callable by anyone.\\n    // Caller must provide `verificationFee`.\\n    // Requires signatures from a threshold CENNZnet validators at proof.validatorSetId.\\n    // Requires proof is not older than `proofTTL` eras\\n    // Halts on failure\\n    //\\n    // Parameters:\\n    // - message: the unhashed message data packed wide w validatorSetId & eventId e.g. `abi.encode(arg0, arg2, validatorSetId, eventId);`\\n    // - proof: Signed witness material generated by CENNZnet proving 'message'\\n    function verifyMessage(bytes memory message, CENNZnetEventProof memory proof) payable external {\\n        require(active, \\\"bridge inactive\\\");\\n        uint256 eventId = proof.eventId;\\n        require(!eventIds[eventId], \\\"eventId replayed\\\");\\n        require(msg.value >= verificationFee || msg.sender == address(this), \\\"must supply verification fee\\\");\\n        uint32 validatorSetId = proof.validatorSetId;\\n        require(validatorSetId <= activeValidatorSetId, \\\"future validator set\\\");\\n        require(activeValidatorSetId - validatorSetId <= proofTTL, \\\"expired proof\\\");\\n\\n        address[] memory _validators = validators[validatorSetId];\\n\\n        // audit item #1\\n        require(_validators.length > 0, \\\"invalid validator set\\\");\\n\\n        bytes32 digest = keccak256(message);\\n        uint acceptanceTreshold = (_validators.length * thresholdPercent / 100);\\n        uint witnessCount;\\n        bytes32 ommited;\\n\\n        for (uint i; i < _validators.length; i++) {\\n            // check signature omitted == bytes32(0)\\n            if(proof.r[i] != ommited) {\\n                // check signature\\n                require(_validators[i] == ecrecover(digest, proof.v[i], proof.r[i], proof.s[i]), \\\"signature invalid\\\");\\n                witnessCount += 1;\\n                // have we got proven consensus?\\n                if(witnessCount >= acceptanceTreshold) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        require(witnessCount >= acceptanceTreshold, \\\"not enough signatures\\\");\\n        eventIds[eventId] = true;\\n    }\\n\\n    // Update the known CENNZnet validator set\\n    //\\n    // Requires signatures from a threshold of current CENNZnet validators\\n    // v,r,s are sparse arrays expected to align w addresses / public key in 'validators'\\n    // i.e. v[i], r[i], s[i] matches the i-th validator[i]\\n    // ~6,737,588 gas\\n    function setValidators(\\n        address[] memory newValidators,\\n        uint32 newValidatorSetId,\\n        CENNZnetEventProof memory proof\\n    ) external payable {\\n        require(newValidators.length > 0, \\\"empty validator set\\\");\\n        require(newValidatorSetId > activeValidatorSetId , \\\"validator set id replayed\\\");\\n\\n        bytes memory message = abi.encode(newValidators, newValidatorSetId, proof.validatorSetId, proof.eventId);\\n        this.verifyMessage(message, proof);\\n\\n        // update\\n        validators[newValidatorSetId] = newValidators;\\n        activeValidatorSetId = newValidatorSetId;\\n\\n        // return accumulated fees to the sender as a reward, capped at `maxRewardPayout`\\n        uint reward = Math.min(address(this).balance, maxRewardPayout);\\n        (bool sent, ) = msg.sender.call{value: reward}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");\\n\\n        emit SetValidators(newValidators, reward, newValidatorSetId);\\n    }\\n\\n    // Admin functions\\n\\n    // force set the active CENNZnet validator set\\n    function forceActiveValidatorSet(address[] memory _validators, uint32 validatorSetId) external onlyOwner {\\n        require(_validators.length > 0, \\\"empty validator set\\\");\\n        require(validatorSetId >= activeValidatorSetId, \\\"set is historic\\\");\\n        validators[validatorSetId] = _validators;\\n        activeValidatorSetId = validatorSetId;\\n    }\\n\\n    // Force set a historic CENNZnet validator set\\n    // Sets older than proofTTL are not modifiable (since they cannot produce valid proofs any longer)\\n    function forceHistoricValidatorSet(address[] memory _validators, uint32 validatorSetId) external onlyOwner {\\n        require(_validators.length > 0, \\\"empty validator set\\\");\\n        require(validatorSetId + proofTTL > activeValidatorSetId, \\\"set is inactive\\\");\\n        validators[validatorSetId] = _validators;\\n    }\\n\\n    // Set the TTL for historic validator set proofs\\n    function setProofTTL(uint newTTL) external onlyOwner {\\n        proofTTL = newTTL;\\n    }\\n\\n    // Set the max reward payout for `setValidator` incentive\\n    function setMaxRewardPayout(uint newMaxRewardPayout) external onlyOwner {\\n        maxRewardPayout = newMaxRewardPayout;\\n    }\\n\\n    // Set the fee for verify messages\\n    function setVerificationFee(uint newFee) external onlyOwner {\\n        verificationFee = newFee;\\n    }\\n\\n    // Set the threshold % required for proof verification\\n    function setThreshold(uint newThresholdPercent) external onlyOwner {\\n        require(newThresholdPercent <= 100, \\\"percent must be <= 100\\\");\\n        thresholdPercent = newThresholdPercent;\\n    }\\n\\n    // Activate/deactivate the bridge\\n    function setActive(bool active_) external onlyOwner {\\n        active = active_;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"validatorSetId\",\"type\":\"uint32\"}],\"name\":\"SetValidators\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeValidatorSetId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eventIds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_validators\",\"type\":\"address[]\"},{\"internalType\":\"uint32\",\"name\":\"validatorSetId\",\"type\":\"uint32\"}],\"name\":\"forceActiveValidatorSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_validators\",\"type\":\"address[]\"},{\"internalType\":\"uint32\",\"name\":\"validatorSetId\",\"type\":\"uint32\"}],\"name\":\"forceHistoricValidatorSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRewardPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proofTTL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"active_\",\"type\":\"bool\"}],\"name\":\"setActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxRewardPayout\",\"type\":\"uint256\"}],\"name\":\"setMaxRewardPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTTL\",\"type\":\"uint256\"}],\"name\":\"setProofTTL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newThresholdPercent\",\"type\":\"uint256\"}],\"name\":\"setThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"newValidators\",\"type\":\"address[]\"},{\"internalType\":\"uint32\",\"name\":\"newValidatorSetId\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validatorSetId\",\"type\":\"uint32\"},{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CENNZnetEventProof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"name\":\"setValidators\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setVerificationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thresholdPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verificationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"eventId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validatorSetId\",\"type\":\"uint32\"},{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CENNZnetEventProof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"name\":\"verifyMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"CENNZnetBridge","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}