{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/TokenReleaser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// We'll actually use ERC777, but any IERC20 instance (including ERC777)\\n// is supported.\\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\\n\\n\\ncontract TokenReleaser {\\n\\n\\n    event TokensBook(address beneficiary , uint256 tokenAmount, uint8 releaseType); \\n\\n    struct ReleaseType\\n     {  uint256 tokenLockTime             ; // lockup time after the release time starts.\\n\\n        uint256 tokenReleaseDuration      ; // vesting time during which the token will be gradually released.\\n                                            // if 0, it means everything available at once. \\n\\n        uint256 immediateAccessTimeWindow ; // When the release time starts, the beneficiary will have immediate access to \\n     }                                      // all the tokens to be released to him during the his `immediateAccessTimeWindow`.\\n\\n    struct Beneficiary\\n     {  uint8   releaseType           ;     // public sale, seed round ...\\n        uint256 tokensAlreadyReleased ;\\n        uint256 tokenBookedAmount     ;\\n     }\\n\\n\\n\\n\\n    uint16 constant SEED_ROUND                      = 0;\\n    uint16 constant PRIVATE_ROUND                   = 1;\\n    uint16 constant STRATEGIC_ROUND                 = 2;\\n    uint16 constant PUBLIC_SALE                     = 3;\\n    uint16 constant COMPANY_RESERVE                 = 4;\\n    uint16 constant TEAM_AND_ADVISORS               = 5;\\n    uint16 constant STRATEGIC_PARTNERS              = 6;\\n    uint16 constant FOUNDERS_AND_EARLY_CONTRIBUTORS = 7;\\n    uint16 constant MINING_RESERVE                  = 8;\\n\\n    uint16 constant MAX_RELEASE_TYPE                = 9;    \\n\\n    ReleaseType[MAX_RELEASE_TYPE]   public tokenomic;\\n\\n    uint256                         public avaliableTokensToRelease;\\n    IERC20                          public tokenContract;\\n    mapping(address => Beneficiary) public beneficiaries;\\n    uint256                         public releaseStartTime;\\n    \\n    function setTokenomics(uint256 avaliableTokens) private{\\n\\n        // NOTICE: we take a month to be equivalent to 30 days, regardless of actual calendar months.\\n        // In particular, 12 month would not sum up a whole year, but 360 days.\\n\\n\\n        tokenomic[ SEED_ROUND                     ] = ReleaseType\\n         ({ tokenLockTime             :  0 * 30 days\\n          , tokenReleaseDuration      : 24 * 30 days \\n          , immediateAccessTimeWindow :  1 * 30 days\\n          }\\n         );\\n\\n        tokenomic[ PRIVATE_ROUND                  ] = ReleaseType\\n         ({ tokenLockTime             :  0 * 30 days\\n          , tokenReleaseDuration      : 12 * 30 days\\n          , immediateAccessTimeWindow :  1 * 30 days\\n          }\\n         );\\n\\n        tokenomic[ STRATEGIC_ROUND                ] = ReleaseType\\n         ({ tokenLockTime             :  0 * 30 days\\n          , tokenReleaseDuration      : 12 * 30 days\\n          , immediateAccessTimeWindow :  1 * 30 days\\n          }\\n         );\\n\\n        tokenomic[ PUBLIC_SALE                    ] = ReleaseType\\n         ({ tokenLockTime             :  0 * 30 days\\n          , tokenReleaseDuration      :  0 * 30 days\\n          , immediateAccessTimeWindow :  0 * 30 days \\n          } // as `tokenReleaseDuration == 0` everything is available as soon as the release time starts. \\n         );\\n\\n        tokenomic[ COMPANY_RESERVE                ] = ReleaseType\\n         ({ tokenLockTime             :  0 * 30 days\\n          , tokenReleaseDuration      : 36 * 30 days\\n          , immediateAccessTimeWindow :  1 * 30 days\\n          }\\n         );\\n\\n        tokenomic[ TEAM_AND_ADVISORS              ] = ReleaseType\\n         ({ tokenLockTime             : 12 * 30 days\\n          , tokenReleaseDuration      : 36 * 30 days\\n          , immediateAccessTimeWindow :  0 * 30 days\\n          }\\n         );\\n\\n        tokenomic[ STRATEGIC_PARTNERS             ] = ReleaseType\\n         ({ tokenLockTime             : 12 * 30 days\\n          , tokenReleaseDuration      : 36 * 30 days\\n          , immediateAccessTimeWindow :  0 * 30 days\\n          }\\n         );\\n\\n        tokenomic[ FOUNDERS_AND_EARLY_CONTRIBUTORS] = ReleaseType\\n         ({ tokenLockTime             : 12 * 30 days\\n          , tokenReleaseDuration      : 48 * 30 days\\n          , immediateAccessTimeWindow :  0 * 30 days\\n          }\\n         );\\n\\n        tokenomic[ MINING_RESERVE                 ] = ReleaseType\\n         ({ tokenLockTime             :  6 * 30 days\\n          , tokenReleaseDuration      : 60 * 30 days\\n          , immediateAccessTimeWindow :  0 * 30 days\\n          }\\n         );\\n\\n        avaliableTokensToRelease = avaliableTokens;\\n        \\n        releaseStartTime = 0;\\n    }\\n    \\n    \\n    //////////////////////////////////////////////////////////////////////////////////////////\\n    \\n    function releaseToken() external{\\n        \\n        require( releaseStartTime > 0\\n               , 'Release time has not started yet'\\n               )\\n        ;\\n\\n        Beneficiary memory beneficiary = beneficiaries[msg.sender];\\n        \\n        require( beneficiary.tokenBookedAmount != 0\\n               , 'Address doesnt belong to a beneficiary set by an admin.'\\n               )\\n        ;\\n\\n\\n        ReleaseType memory releaseType    = tokenomic[beneficiary.releaseType];\\n        \\n        // Date the tokens locktime finish for the beneficiary. \\n        uint256 startTime = releaseType.tokenLockTime + releaseStartTime;\\n        \\n        // After the locktime has finished, there's a time window defined as `tokenReleaseDuration`. \\n        // `timeCompleted` is how much of that time window has been completed.\\n        // A beneficiary can only release a fraction of his token proportional to how much of this time window\\n        // has been completed (or the totality of them if it is completed).\\n        uint256 timeCompleted  = 0;\\n        uint256 unlockedTokens = 0;\\n\\n        if (block.timestamp >= startTime){\\n            timeCompleted = block.timestamp - startTime;\\n\\n            // Time completed is the maximum between the time it has passed since start, and \\n            // the immediateAccessTimeWindow, capped to a max of tokenReleaseDuration.\\n            if (timeCompleted < releaseType.immediateAccessTimeWindow){\\n                timeCompleted = releaseType.immediateAccessTimeWindow;\\n            }\\n        \\n            if (timeCompleted >= releaseType.tokenReleaseDuration){\\n                timeCompleted = releaseType.tokenReleaseDuration;\\n            }\\n\\n            // `tokenReleaseDuration == 0` means everything is available right after the release lock time\\n            if (releaseType.tokenReleaseDuration == 0){\\n                unlockedTokens = beneficiary.tokenBookedAmount;\\n            } else {\\n                unlockedTokens = (timeCompleted * beneficiary.tokenBookedAmount) / releaseType.tokenReleaseDuration;\\n            }\\n        }\\n\\n        uint256 toRelease      =  unlockedTokens - beneficiary.tokensAlreadyReleased;\\n        \\n        beneficiaries[msg.sender].tokensAlreadyReleased += toRelease;\\n        \\n        tokenContract.transfer( msg.sender, toRelease );\\n        \\n    }\\n    \\n    //////////////////////////////////////////////////////////////////////////////////////////\\n    address public adminA; // active admin\\n    address public adminB; // backup admin\\n    address public adminT; // temporary admin, only used during key rotation for one of the other admins.\\n    event NewAdminA(address adminA );\\n    event NewAdminB(address adminB );\\n    event NewAdminT(address adminT );\\n    \\n    modifier adminOnly(){\\n        require( (msg.sender == adminA) || (msg.sender == adminB) || (msg.sender == adminT) \\n               , 'Only admins allowed'\\n               )\\n        ;\\n        _;\\n    }\\n\\n    function changeAdminA(address newAdminA) external adminOnly{\\n        if (adminA != newAdminA){\\n           emit NewAdminA(newAdminA);\\n        }\\n        adminA = newAdminA;\\n    }\\n\\n    function changeAdminB(address newAdminB) external adminOnly{\\n        if (adminB != newAdminB){\\n           emit NewAdminB(newAdminB);\\n        }\\n        adminB = newAdminB;\\n    }\\n\\n    function changeAdminT(address newAdminT) external adminOnly{\\n        if (adminT != newAdminT){\\n           emit NewAdminB(newAdminT);\\n        }\\n        adminT = newAdminT;\\n    }\\n\\n\\n\\n    function bookTokensFor( address beneficiary , uint256 tokenAmount, uint8 releaseType ) external adminOnly{\\n        require( avaliableTokensToRelease >= tokenAmount \\n               , 'Not enough token to book'\\n               )\\n        ;\\n        require( beneficiaries[beneficiary].tokenBookedAmount == 0\\n               , 'Beneficiaries can only be set once'\\n               )\\n        ;\\n        require( releaseType < MAX_RELEASE_TYPE\\n               , 'Invalid release schedule'\\n               )\\n        ;\\n        require( tokenAmount > 0\\n               , 'More than 0 token needs to be booked to set a beneficiary'\\n               )\\n        ;\\n        avaliableTokensToRelease -= tokenAmount;\\n        \\n        emit TokensBook(beneficiary, tokenAmount, releaseType);\\n        beneficiaries[beneficiary] = Beneficiary(releaseType,0,tokenAmount);\\n\\n    }\\n\\n    event ReleaseTimeStarted();\\n    \\n\\n    function startReleaseTime() external adminOnly{\\n        require( releaseStartTime == 0\\n               , 'Release time has already started'\\n               )\\n        ;\\n        releaseStartTime = block.timestamp;\\n        emit ReleaseTimeStarted();\\n    }\\n\\n    //////////////////////////////////////////////////////////////////////////////////////////\\n    \\n    constructor(address _adminA, address _adminB, IERC20 _contract, uint256 avaliableTokens){\\n        tokenContract  = _contract;\\n        adminA         = _adminA;\\n        adminB         = _adminB;\\n        setTokenomics(avaliableTokens);\\n    }\\n}\\n\\n\\n\\n\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adminB\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"avaliableTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adminA\",\"type\":\"address\"}],\"name\":\"NewAdminA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adminB\",\"type\":\"address\"}],\"name\":\"NewAdminB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adminT\",\"type\":\"address\"}],\"name\":\"NewAdminT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ReleaseTimeStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"releaseType\",\"type\":\"uint8\"}],\"name\":\"TokensBook\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"adminA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avaliableTokensToRelease\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"beneficiaries\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"releaseType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"tokensAlreadyReleased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBookedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"releaseType\",\"type\":\"uint8\"}],\"name\":\"bookTokensFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdminA\",\"type\":\"address\"}],\"name\":\"changeAdminA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdminB\",\"type\":\"address\"}],\"name\":\"changeAdminB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdminT\",\"type\":\"address\"}],\"name\":\"changeAdminT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startReleaseTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenomic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenLockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenReleaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"immediateAccessTimeWindow\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenReleaser","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"0000000000000000000000003c159347b33cababdb6980081f9408759833129b000000000000000000000000e147f1ae58466a64ca13af6534fc1651ecd0af43000000000000000000000000f0a523b9ff458de2041efc125765568aa6710f51000000000000000000000000000000000000000018d0bf423c03d8de00000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}