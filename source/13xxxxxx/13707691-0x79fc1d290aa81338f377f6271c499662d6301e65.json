{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/bridge/QBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/IQBridgeHandler.sol\\\";\\nimport \\\"../library/PausableUpgradeable.sol\\\";\\nimport \\\"../library/AccessControlIndexUpgradeable.sol\\\";\\nimport \\\"../library/SafeToken.sol\\\";\\n\\n\\ncontract QBridge is PausableUpgradeable, AccessControlIndexUpgradeable {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    bytes32 public constant RELAYER_ROLE = keccak256(\\\"RELAYER_ROLE\\\");\\n\\n    uint public constant MAX_RELAYERS = 200;\\n\\n    enum ProposalStatus {Inactive, Active, Passed, Executed, Cancelled}\\n\\n    struct Proposal {\\n        ProposalStatus _status;\\n        uint200 _yesVotes;      // bitmap, 200 maximum votes\\n        uint8 _yesVotesTotal;\\n        uint40 _proposedBlock; // 1099511627775 maximum block\\n    }\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    uint8 public domainID;\\n    uint8 public relayerThreshold;\\n    uint128 public fee;\\n    uint40 public expiry;\\n\\n    mapping(uint8 => uint64) public _depositCounts; // destinationDomainID => number of deposits\\n    mapping(bytes32 => address) public resourceIDToHandlerAddress; // resourceID => handler address\\n    mapping(uint72 => mapping(bytes32 => Proposal)) private _proposals; // destinationDomainID + depositNonce => dataHash => Proposal\\n\\n    /* ========== EVENTS ========== */\\n\\n    event RelayerThresholdChanged(uint256 newThreshold);\\n    event RelayerAdded(address relayer);\\n    event RelayerRemoved(address relayer);\\n    event Deposit(uint8 destinationDomainID, bytes32 resourceID, uint64 depositNonce, address indexed user, bytes data);\\n    event ProposalEvent(uint8 originDomainID, uint64 depositNonce, ProposalStatus status, bytes32 dataHash);\\n    event ProposalVote(uint8 originDomainID, uint64 depositNonce, ProposalStatus status, bytes32 dataHash);\\n    event FailedHandlerExecution(bytes lowLevelData);\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize(uint8 _domainID, uint8 _relayerThreshold, uint128 _fee, uint40 _expiry) external initializer {\\n        __PausableUpgradeable_init();\\n        __AccessControl_init();\\n\\n        domainID = _domainID;\\n        relayerThreshold = _relayerThreshold;\\n        fee = _fee;\\n        expiry = _expiry;\\n\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyRelayers() {\\n        require(hasRole(RELAYER_ROLE, msg.sender), \\\"QBridge: caller is not the relayer\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwnerOrRelayers() {\\n        require(owner() == msg.sender || hasRole(RELAYER_ROLE, msg.sender), \\\"QBridge: caller is not the owner or relayer\\\");\\n        _;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setRelayerThreshold(uint8 newThreshold) external onlyOwner {\\n        relayerThreshold = newThreshold;\\n        emit RelayerThresholdChanged(newThreshold);\\n    }\\n\\n    function addRelayer(address relayer) external onlyOwner {\\n        require(!hasRole(RELAYER_ROLE, relayer), \\\"QBridge: duplicated relayer\\\");\\n        require(totalRelayers() < MAX_RELAYERS, \\\"QBridge: relayers limit reached\\\");\\n        grantRole(RELAYER_ROLE, relayer);\\n        emit RelayerAdded(relayer);\\n    }\\n\\n    function removeRelayer(address relayer) external onlyOwner {\\n        require(hasRole(RELAYER_ROLE, relayer), \\\"QBridge: invalid relayer\\\");\\n        revokeRole(RELAYER_ROLE, relayer);\\n        emit RelayerRemoved(relayer);\\n    }\\n\\n    function setResource(address handlerAddress, bytes32 resourceID, address tokenAddress) external onlyOwner {\\n        resourceIDToHandlerAddress[resourceID] = handlerAddress;\\n        IQBridgeHandler(handlerAddress).setResource(resourceID, tokenAddress);\\n    }\\n\\n    function setBurnable(address handlerAddress, address tokenAddress) external onlyOwner {\\n        IQBridgeHandler(handlerAddress).setBurnable(tokenAddress);\\n    }\\n\\n    function setDepositNonce(uint8 _domainID, uint64 nonce) external onlyOwner {\\n        require(nonce > _depositCounts[_domainID], \\\"QBridge: decrements not allowed\\\");\\n        _depositCounts[_domainID] = nonce;\\n    }\\n\\n    function setFee(uint128 newFee) external onlyOwner {\\n        fee = newFee;\\n    }\\n\\n    function manualRelease(address handlerAddress, address tokenAddress, address recipient, uint amount) external onlyOwner {\\n        IQBridgeHandler(handlerAddress).withdraw(tokenAddress, recipient, amount);\\n    }\\n\\n    function sweep() external onlyOwner {\\n        SafeToken.safeTransferETH(msg.sender, address(this).balance);\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function isRelayer(address relayer) external view returns (bool) {\\n        return hasRole(RELAYER_ROLE, relayer);\\n    }\\n\\n    function totalRelayers() public view returns (uint) {\\n        return AccessControlIndexUpgradeable.getRoleMemberCount(RELAYER_ROLE);\\n    }\\n\\n    /**\\n        @notice Returns a proposalID.\\n        @param _domainID Chain ID.\\n        @param nonce ID of proposal generated by proposal's origin Bridge contract.\\n     */\\n    function combinedProposalId(uint8 _domainID, uint64 nonce) public pure returns (uint72 proposalID) {\\n        proposalID = (uint72(nonce) << 8) | uint72(_domainID);\\n    }\\n\\n    /**\\n        @notice Returns a proposal.\\n        @param originDomainID Chain ID deposit originated from.\\n        @param depositNonce ID of proposal generated by proposal's origin Bridge contract.\\n        @param dataHash Hash of data to be provided when deposit proposal is executed.\\n     */\\n    function getProposal(uint8 originDomainID, uint64 depositNonce, bytes32 dataHash, address relayer) external view returns (Proposal memory proposal, bool hasVoted) {\\n        uint72 proposalID = combinedProposalId(originDomainID, depositNonce);\\n        proposal = _proposals[proposalID][dataHash];\\n        hasVoted = _hasVoted(proposal, relayer);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n        @notice Initiates a transfer using a specified handler contract.\\n        @notice Only callable when Bridge is not paused.\\n        @param destinationDomainID ID of chain deposit will be bridged to.\\n        @param resourceID ResourceID used to find address of handler to be used for deposit.\\n        @param data Additional data to be passed to specified handler.\\n        @notice Emits {Deposit} event with all necessary parameters\\n     */\\n    function deposit(uint8 destinationDomainID, bytes32 resourceID, bytes calldata data) external payable notPaused {\\n        require(msg.value == fee, \\\"QBridge: invalid fee\\\");\\n\\n        address handler = resourceIDToHandlerAddress[resourceID];\\n        require(handler != address(0), \\\"QBridge: invalid resourceID\\\");\\n\\n        uint64 depositNonce = ++_depositCounts[destinationDomainID];\\n\\n        IQBridgeHandler(handler).deposit(resourceID, msg.sender, data);\\n        emit Deposit(destinationDomainID, resourceID, depositNonce, msg.sender, data);\\n    }\\n\\n    /**\\n        @notice When called, {msg.sender} will be marked as voting in favor of proposal.\\n        @notice Only callable by relayers when Bridge is not paused.\\n        @param originDomainID ID of chain deposit originated from.\\n        @param depositNonce ID of deposited generated by origin Bridge contract.\\n        @param data Data originally provided when deposit was made.\\n        @notice Proposal must not have already been passed or executed.\\n        @notice {msg.sender} must not have already voted on proposal.\\n        @notice Emits {ProposalEvent} event with status indicating the proposal status.\\n        @notice Emits {ProposalVote} event.\\n     */\\n    function voteProposal(uint8 originDomainID, uint64 depositNonce, bytes32 resourceID, bytes calldata data) external onlyRelayers notPaused {\\n        address handlerAddress = resourceIDToHandlerAddress[resourceID];\\n        require(handlerAddress != address(0), \\\"QBridge: invalid handler\\\");\\n\\n        uint72 proposalID = combinedProposalId(originDomainID, depositNonce);\\n        bytes32 dataHash = keccak256(abi.encodePacked(handlerAddress, data));\\n        Proposal memory proposal = _proposals[proposalID][dataHash];\\n\\n        if (proposal._status == ProposalStatus.Passed) {\\n            executeProposal(originDomainID, depositNonce, resourceID, data, true);\\n            return;\\n        }\\n\\n        require(uint(proposal._status) <= 1, \\\"QBridge: proposal already executed/cancelled\\\");\\n        require(!_hasVoted(proposal, msg.sender), \\\"QBridge: relayer already voted\\\");\\n\\n        if (proposal._status == ProposalStatus.Inactive) {\\n            proposal = Proposal({_status : ProposalStatus.Active, _yesVotes : 0, _yesVotesTotal : 0, _proposedBlock : uint40(block.number)});\\n            emit ProposalEvent(originDomainID, depositNonce, ProposalStatus.Active, dataHash);\\n        } else if (uint40(block.number.sub(proposal._proposedBlock)) > expiry) {\\n            proposal._status = ProposalStatus.Cancelled;\\n            emit ProposalEvent(originDomainID, depositNonce, ProposalStatus.Cancelled, dataHash);\\n        }\\n\\n        if (proposal._status != ProposalStatus.Cancelled) {\\n            proposal._yesVotes = _bitmap(proposal._yesVotes, _relayerBit(msg.sender));\\n            proposal._yesVotesTotal++;\\n            emit ProposalVote(originDomainID, depositNonce, proposal._status, dataHash);\\n\\n            if (proposal._yesVotesTotal >= relayerThreshold) {\\n                proposal._status = ProposalStatus.Passed;\\n                emit ProposalEvent(originDomainID, depositNonce, ProposalStatus.Passed, dataHash);\\n            }\\n        }\\n        _proposals[proposalID][dataHash] = proposal;\\n\\n        if (proposal._status == ProposalStatus.Passed) {\\n            executeProposal(originDomainID, depositNonce, resourceID, data, false);\\n        }\\n    }\\n\\n    /**\\n        @notice Executes a deposit proposal that is considered passed using a specified handler contract.\\n        @notice Only callable by relayers when Bridge is not paused.\\n        @param originDomainID ID of chain deposit originated from.\\n        @param depositNonce ID of deposited generated by origin Bridge contract.\\n        @param resourceID ResourceID to be used when making deposits.\\n        @param data Data originally provided when deposit was made.\\n        @param revertOnFail Decision if the transaction should be reverted in case of handler's executeProposal is reverted or not.\\n        @notice Proposal must have Passed status.\\n        @notice Hash of {data} must equal proposal's {dataHash}.\\n        @notice Emits {ProposalEvent} event with status {Executed}.\\n        @notice Emits {FailedExecution} event with the failed reason.\\n     */\\n    function executeProposal(uint8 originDomainID, uint64 depositNonce, bytes32 resourceID, bytes calldata data, bool revertOnFail) public onlyRelayers notPaused {\\n        address handlerAddress = resourceIDToHandlerAddress[resourceID];\\n        uint72 proposalID = combinedProposalId(originDomainID, depositNonce);\\n        bytes32 dataHash = keccak256(abi.encodePacked(handlerAddress, data));\\n        Proposal storage proposal = _proposals[proposalID][dataHash];\\n\\n        require(proposal._status == ProposalStatus.Passed, \\\"QBridge: Proposal must have Passed status\\\");\\n\\n        proposal._status = ProposalStatus.Executed;\\n        IQBridgeHandler handler = IQBridgeHandler(handlerAddress);\\n\\n        if (revertOnFail) {\\n            handler.executeProposal(resourceID, data);\\n        } else {\\n            try handler.executeProposal(resourceID, data) {\\n            } catch (bytes memory lowLevelData) {\\n                proposal._status = ProposalStatus.Passed;\\n                emit FailedHandlerExecution(lowLevelData);\\n                return;\\n            }\\n        }\\n        emit ProposalEvent(originDomainID, depositNonce, ProposalStatus.Executed, dataHash);\\n    }\\n\\n    /**\\n        @notice Cancels a deposit proposal that has not been executed yet.\\n        @notice Only callable by relayers when Bridge is not paused.\\n        @param originDomainID ID of chain deposit originated from.\\n        @param depositNonce ID of deposited generated by origin Bridge contract.\\n        @param dataHash Hash of data originally provided when deposit was made.\\n        @notice Proposal must be past expiry threshold.\\n        @notice Emits {ProposalEvent} event with status {Cancelled}.\\n     */\\n    function cancelProposal(uint8 originDomainID, uint64 depositNonce, bytes32 dataHash) public onlyOwnerOrRelayers {\\n        uint72 proposalID = combinedProposalId(originDomainID, depositNonce);\\n        Proposal memory proposal = _proposals[proposalID][dataHash];\\n        ProposalStatus currentStatus = proposal._status;\\n\\n        require(currentStatus == ProposalStatus.Active || currentStatus == ProposalStatus.Passed, \\\"QBridge: cannot be cancelled\\\");\\n        require(uint40(block.number.sub(proposal._proposedBlock)) > expiry, \\\"QBridge: not at expiry threshold\\\");\\n\\n        proposal._status = ProposalStatus.Cancelled;\\n        _proposals[proposalID][dataHash] = proposal;\\n        emit ProposalEvent(originDomainID, depositNonce, ProposalStatus.Cancelled, dataHash);\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _relayerBit(address relayer) private view returns (uint) {\\n        if (relayer == address(0)) return 0;\\n        return uint(1) << AccessControlIndexUpgradeable.getRoleMemberIndex(RELAYER_ROLE, relayer).sub(1);\\n    }\\n\\n    function _hasVoted(Proposal memory proposal, address relayer) private view returns (bool) {\\n        return (_relayerBit(relayer) & uint(proposal._yesVotes)) > 0;\\n    }\\n\\n    function _bitmap(uint200 source, uint bit) internal pure returns (uint200) {\\n        uint value = source | bit;\\n        require(value < 2 ** 200, \\\"QBridge: value does not fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQBridgeHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface IQBridgeHandler {\\n    /**\\n        @notice Correlates {resourceID} with {contractAddress}.\\n        @param resourceID ResourceID to be used when making deposits.\\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\\n     */\\n    function setResource(bytes32 resourceID, address contractAddress) external;\\n\\n    /**\\n        @notice Marks {contractAddress} as mintable/burnable.\\n        @param contractAddress Address of contract to be used when making or executing deposits.\\n     */\\n    function setBurnable(address contractAddress) external;\\n\\n    /**\\n        @notice It is intended that deposit are made using the Bridge contract.\\n        @param depositer Address of account making the deposit in the Bridge contract.\\n        @param data Consists of additional data needed for a specific deposit.\\n     */\\n    function deposit(bytes32 resourceID, address depositer, bytes calldata data) external;\\n\\n    /**\\n        @notice It is intended that proposals are executed by the Bridge contract.\\n        @param data Consists of additional data needed for a specific deposit execution.\\n     */\\n    function executeProposal(bytes32 resourceID, bytes calldata data) external;\\n\\n    /**\\n        @notice Used to manually release funds from ERC safes.\\n        @param tokenAddress Address of token contract to release.\\n        @param recipient Address to release tokens to.\\n        @param amount the amount of ERC20 tokens to release.\\n     */\\n    function withdraw(address tokenAddress, address recipient, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/library/PausableUpgradeable.sol\": {\r\n      \"content\": \"/*\\n   ____            __   __        __   _\\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\\n _\\\\ \\\\ / // // _ \\\\/ __// _ \\\\/ -_)/ __// / \\\\ \\\\ /\\n/___/ \\\\_, //_//_/\\\\__//_//_/\\\\__/ \\\\__//_/ /_\\\\_\\\\\\n     /___/\\n\\n* Docs: https://docs.synthetix.io/\\n*\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2020 Synthetix\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.2;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\n\\nabstract contract PausableUpgradeable is OwnableUpgradeable {\\n    uint public lastPauseTime;\\n    bool public paused;\\n\\n    event PauseChanged(bool isPaused);\\n\\n    modifier notPaused {\\n        require(!paused, \\\"PausableUpgradeable: cannot be performed while the contract is paused\\\");\\n        _;\\n    }\\n\\n    function __PausableUpgradeable_init() internal initializer {\\n        __Ownable_init();\\n        require(owner() != address(0), \\\"PausableUpgradeable: owner must be set\\\");\\n    }\\n\\n    function setPaused(bool _paused) external onlyOwner {\\n        if (_paused == paused) {\\n            return;\\n        }\\n\\n        paused = _paused;\\n        if (paused) {\\n            lastPauseTime = now;\\n        }\\n\\n        emit PauseChanged(paused);\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/library/AccessControlIndexUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol\\\";\\n\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlIndexUpgradeable is Initializable, ContextUpgradeable {\\n    function __AccessControl_init() internal initializer {\\n        __Context_init_unchained();\\n        __AccessControl_init_unchained();\\n    }\\n\\n    function __AccessControl_init_unchained() internal initializer {\\n    }\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n    using AddressUpgradeable for address;\\n\\n    struct RoleData {\\n        EnumerableSetUpgradeable.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the index of the account that have `role`.\\n     */\\n    function getRoleMemberIndex(bytes32 role, address account) public view returns (uint256) {\\n        return _roles[role].members._inner._indexes[bytes32(uint256(account))];\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/library/SafeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\ninterface ERC20Interface {\\n    function balanceOf(address user) external view returns (uint);\\n}\\n\\nlibrary SafeToken {\\n    function myBalance(address token) internal view returns (uint) {\\n        return ERC20Interface(token).balanceOf(address(this));\\n    }\\n\\n    function balanceOf(address token, address user) internal view returns (uint) {\\n        return ERC20Interface(token).balanceOf(user);\\n    }\\n\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeApprove\\\");\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeTransfer\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeTransferFrom\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success, ) = to.call{ value: value }(new bytes(0));\\n        require(success, \\\"!safeTransferETH\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\n\"\r\n    },\r\n    \"contracts/tester/QubitPresaleTester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\\\";\\nimport \\\"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol\\\";\\nimport \\\"../interfaces/IPancakeRouter02.sol\\\";\\nimport \\\"../interfaces/IPancakeFactory.sol\\\";\\nimport \\\"../interfaces/IPancakePair.sol\\\";\\nimport \\\"../interfaces/IPresaleLocker.sol\\\";\\nimport \\\"../interfaces/IQubitPresale.sol\\\";\\nimport \\\"../interfaces/IPriceCalculator.sol\\\";\\nimport \\\"../library/SafeToken.sol\\\";\\n\\ncontract QubitPresaleTester is IQubitPresale, OwnableUpgradeable, ReentrancyGuardUpgradeable {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANTS ============= */\\n\\n    address public constant BUNNY = 0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51;\\n    address public constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public constant DEAD = 0x000000000000000000000000000000000000dEaD;\\n\\n    address public constant BUNNY_WBNB_LP = 0x5aFEf8567414F29f0f927A0F2787b188624c10E2;\\n    address public constant QBT_WBNB_LP = 0x67EFeF66A55c4562144B9AcfCFbc62F9E4269b3e;\\n\\n    address public constant DEPLOYER = 0xbeE397129374D0b4db7bf1654936951e5bdfe5a6;\\n\\n    IPancakeRouter02 private constant router = IPancakeRouter02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n    IPancakeFactory private constant factory = IPancakeFactory(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73);\\n    IPriceCalculator public constant priceCalculator = IPriceCalculator(0x20E5E35ba29dC3B540a1aee781D0814D5c77Bce6);\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    uint public startTime;\\n    uint public endTime;\\n    uint public presaleAmountUSD;\\n    uint public totalBunnyBnbLp;\\n    uint public qbtAmount;\\n    uint public override qbtBnbLpAmount;\\n    uint public override lpPriceAtArchive;\\n    uint private _distributionCursor;\\n\\n    mapping(address => uint) public bunnyBnbLpOf;\\n    mapping(address => bool) public claimedOf;\\n    address[] public accountList;\\n    bool public archived;\\n\\n    IPresaleLocker public qbtBnbLocker;\\n\\n    mapping(address => uint) public refundLpOf;\\n    address public QBT;\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Deposit(address indexed user, uint amount);\\n    event Distributed(uint length, uint remain);\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize(\\n        uint _startTime,\\n        uint _endTime,\\n        uint _presaleAmountUSD,\\n        uint _qbtAmount,\\n        address _qbtAddress\\n    ) external initializer {\\n        __Ownable_init();\\n        __ReentrancyGuard_init();\\n\\n        startTime = _startTime;\\n        endTime = _endTime;\\n        presaleAmountUSD = _presaleAmountUSD;\\n        qbtAmount = _qbtAmount;\\n        QBT = _qbtAddress;\\n\\n        BUNNY_WBNB_LP.safeApprove(address(router), uint(~0));\\n        QBT.safeApprove(address(router), uint(~0));\\n        BUNNY.safeApprove(address(router), uint(~0));\\n        WBNB.safeApprove(address(router), uint(~0));\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function allocationOf(address _user) public view override returns (uint) {\\n        return totalBunnyBnbLp == 0 ? 0 : bunnyBnbLpOf[_user].mul(1e18).div(totalBunnyBnbLp);\\n    }\\n\\n    function refundOf(address _user) public view override returns (uint) {\\n        uint lpPriceNow = lpPriceAtArchive;\\n        if (lpPriceAtArchive == 0) {\\n            (, lpPriceNow) = priceCalculator.valueOfAsset(BUNNY_WBNB_LP, 1e18);\\n        }\\n\\n        if (totalBunnyBnbLp.mul(lpPriceNow).div(1e18) <= presaleAmountUSD) {\\n            return 0;\\n        }\\n\\n        uint lpAmountToPay = presaleAmountUSD.mul(allocationOf(_user)).div(lpPriceNow);\\n        return bunnyBnbLpOf[_user].sub(lpAmountToPay);\\n    }\\n\\n    function accountListLength() external view override returns (uint) {\\n        return accountList.length;\\n    }\\n\\n    function presaleDataOf(address account) public view returns (PresaleData memory) {\\n        PresaleData memory presaleData;\\n        presaleData.startTime = startTime;\\n        presaleData.endTime = endTime;\\n        presaleData.userLpAmount = bunnyBnbLpOf[account];\\n        presaleData.totalLpAmount = totalBunnyBnbLp;\\n        presaleData.claimedOf = claimedOf[account];\\n        presaleData.refundLpAmount = refundLpOf[account];\\n        presaleData.qbtBnbLpAmount = qbtBnbLpAmount;\\n\\n        return presaleData;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function setQubitBnbLocker(address _qubitBnbLocker) public override onlyOwner {\\n        require(_qubitBnbLocker != address(0), \\\"QubitPresale: invalid address\\\");\\n\\n        qbtBnbLocker = IPresaleLocker(_qubitBnbLocker);\\n        qbtBnbLocker.setPresaleEndTime(endTime);\\n        QBT_WBNB_LP.safeApprove(address(qbtBnbLocker), uint(~0));\\n    }\\n\\n    function setPresaleAmountUSD(uint _presaleAmountUSD) public override onlyOwner {\\n        require(block.timestamp < startTime, \\\"QubitPresale: already started\\\");\\n\\n        presaleAmountUSD = _presaleAmountUSD;\\n    }\\n\\n    function setPeriod(uint _start, uint _end) public override onlyOwner {\\n        require(block.timestamp < startTime, \\\"QubitPresale: already started\\\");\\n        require(block.timestamp < _start && _start < _end, \\\"QubitPresale: invalid time values\\\");\\n        require(address(qbtBnbLocker) != address(0), \\\"QubitPresale: QbtBnbLocker must be set\\\");\\n\\n        startTime = _start;\\n        endTime = _end;\\n\\n        qbtBnbLocker.setPresaleEndTime(endTime);\\n    }\\n\\n    function setQbtAmount(uint _qbtAmount) public override onlyOwner {\\n        require(block.timestamp < startTime, \\\"QubitPresale: already started\\\");\\n\\n        qbtAmount = _qbtAmount;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function deposit(uint _amount) public override {\\n        require(block.timestamp > startTime && block.timestamp < endTime, \\\"QubitPresale: not in presale\\\");\\n        require(_amount > 0, \\\"QubitPresale: invalid amount\\\");\\n\\n        if (bunnyBnbLpOf[msg.sender] == 0) {\\n            accountList.push(msg.sender);\\n        }\\n        bunnyBnbLpOf[msg.sender] = bunnyBnbLpOf[msg.sender].add(_amount);\\n        totalBunnyBnbLp = totalBunnyBnbLp.add(_amount);\\n\\n        BUNNY_WBNB_LP.safeTransferFrom(msg.sender, address(this), _amount);\\n        emit Deposit(msg.sender, _amount);\\n    }\\n\\n    function archive() public override onlyOwner returns (uint bunnyAmount, uint wbnbAmount) {\\n        require(!archived && qbtBnbLpAmount == 0, \\\"QubitPresale: already archived\\\");\\n        require(IBEP20(QBT).balanceOf(address(this)) == qbtAmount, \\\"QubitPresale: lack of QBT\\\");\\n        require(block.timestamp > endTime, \\\"QubitPresale: not harvest time\\\");\\n        (, lpPriceAtArchive) = priceCalculator.valueOfAsset(BUNNY_WBNB_LP, 1e18);\\n        require(lpPriceAtArchive > 0, \\\"QubitPresale: invalid lp price\\\");\\n        uint presaleAmount = presaleAmountUSD.div(lpPriceAtArchive).mul(1e18);\\n\\n        // burn manually transferred LP token\\n        if (IPancakePair(BUNNY_WBNB_LP).balanceOf(BUNNY_WBNB_LP) > 0) {\\n            IPancakePair(BUNNY_WBNB_LP).burn(DEPLOYER);\\n        }\\n\\n        uint amount = Math.min(totalBunnyBnbLp, presaleAmount);\\n        (bunnyAmount, wbnbAmount) = router.removeLiquidity(BUNNY, WBNB, amount, 0, 0, address(this), block.timestamp);\\n        BUNNY.safeTransfer(DEAD, bunnyAmount);\\n\\n        uint qbtAmountFixed = presaleAmount < totalBunnyBnbLp\\n            ? qbtAmount\\n            : qbtAmount.mul(totalBunnyBnbLp).div(presaleAmount);\\n        (, , qbtBnbLpAmount) = router.addLiquidity(\\n            QBT,\\n            WBNB,\\n            qbtAmountFixed,\\n            wbnbAmount,\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        archived = true;\\n    }\\n\\n    function distribute(uint distributeThreshold) external override onlyOwner {\\n        require(block.timestamp > endTime, \\\"QubitPresale: not harvest time\\\");\\n        require(archived, \\\"QubitPresale: not yet archived\\\");\\n        uint start = _distributionCursor;\\n        uint totalUserCount = accountList.length;\\n        uint remain = totalUserCount > _distributionCursor ? totalUserCount - _distributionCursor : 0;\\n        uint length = Math.min(remain, distributeThreshold);\\n        for (uint i = start; i < start + length; i++) {\\n            address account = accountList[i];\\n            if (!claimedOf[account]) {\\n                claimedOf[account] = true;\\n\\n                uint refundingLpAmount = refundOf(account);\\n                if (refundingLpAmount > 0 && refundLpOf[account] == 0) {\\n                    refundLpOf[account] = refundingLpAmount;\\n                    BUNNY_WBNB_LP.safeTransfer(account, refundingLpAmount);\\n                }\\n\\n                uint depositLpAmount = qbtBnbLpAmount.mul(allocationOf(account)).div(1e18);\\n                if (depositLpAmount > 0) {\\n                    delete bunnyBnbLpOf[account];\\n                    // block qbtBnbLocker for test\\n                    // qbtBnbLocker.depositBehalf(account, depositLpAmount);\\n                }\\n            }\\n            _distributionCursor++;\\n        }\\n        remain = totalUserCount > _distributionCursor ? totalUserCount - _distributionCursor : 0;\\n        emit Distributed(length, remain);\\n    }\\n\\n    function sweep(uint _lpAmount, uint _offerAmount) public override onlyOwner {\\n        require(_lpAmount <= IBEP20(BUNNY_WBNB_LP).balanceOf(address(this)), \\\"QubitPresale: not enough token 0\\\");\\n        require(_offerAmount <= IBEP20(QBT).balanceOf(address(this)), \\\"QubitPresale: not enough token 1\\\");\\n        BUNNY_WBNB_LP.safeTransfer(msg.sender, _lpAmount);\\n        QBT.safeTransfer(msg.sender, _offerAmount);\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal initializer {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.4.0;\\n\\ninterface IBEP20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the token decimals.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the token symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the bep token owner.\\n     */\\n    function getOwner() external view returns (address);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address _owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport './IBEP20.sol';\\nimport '../../math/SafeMath.sol';\\nimport '../../utils/Address.sol';\\n\\n/**\\n * @title SafeBEP20\\n * @dev Wrappers around BEP20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeBEP20 for IBEP20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeBEP20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IBEP20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IBEP20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IBEP20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IBEP20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            'SafeBEP20: approve from non-zero to non-zero allowance'\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IBEP20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IBEP20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\\n            value,\\n            'SafeBEP20: decreased allowance below zero'\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, 'SafeBEP20: low-level call failed');\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), 'SafeBEP20: BEP20 operation did not succeed');\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPancakeRouter02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2;\\n\\nimport \\\"./IPancakeRouter01.sol\\\";\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPancakeFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface IPancakeFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPancakePair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IPancakePair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address owner) external view returns (uint);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n\\n    function transfer(address to, uint value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint value,\\n        uint deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint);\\n\\n    function price1CumulativeLast() external view returns (uint);\\n\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n\\n    function swap(\\n        uint amount0Out,\\n        uint amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPresaleLocker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\ninterface IPresaleLocker {\\n    function setPresale(address _presaleContract) external;\\n\\n    function setPresaleEndTime(uint endTime) external;\\n\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function withdrawableBalanceOf(address account) external view returns (uint);\\n\\n    function depositBehalf(address account, uint balance) external;\\n\\n    function withdraw(uint amount) external;\\n\\n    function withdrawAll() external;\\n\\n    function recoverToken(address tokenAddress, uint tokenAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQubitPresale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\ninterface IQubitPresale {\\n    struct PresaleData {\\n        uint startTime;\\n        uint endTime;\\n        uint userLpAmount;\\n        uint totalLpAmount;\\n        bool claimedOf;\\n        uint refundLpAmount;\\n        uint qbtBnbLpAmount;\\n    }\\n\\n    function lpPriceAtArchive() external view returns (uint);\\n\\n    function qbtBnbLpAmount() external view returns (uint);\\n\\n    function allocationOf(address _user) external view returns (uint);\\n\\n    function refundOf(address _user) external view returns (uint);\\n\\n    function accountListLength() external view returns (uint);\\n\\n    function setQubitBnbLocker(address _qubitBnbLocker) external;\\n\\n    function setPresaleAmountUSD(uint _limitAmount) external;\\n\\n    function setPeriod(uint _start, uint _end) external;\\n\\n    function setQbtAmount(uint _qbtAmount) external;\\n\\n    function deposit(uint _amount) external;\\n\\n    function archive() external returns (uint bunnyAmount, uint wbnbAmount);\\n\\n    function distribute(uint distributeThreshold) external;\\n\\n    function sweep(uint _lpAmount, uint _offerAmount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\ninterface IPriceCalculator {\\n    struct ReferenceData {\\n        uint lastData;\\n        uint lastUpdated;\\n    }\\n\\n    function priceOf(address asset) external view returns (uint);\\n    function pricesOf(address[] memory assets) external view returns (uint[] memory);\\n\\n    function getUnderlyingPrice(address qToken) external view returns (uint);\\n    function getUnderlyingPrices(address[] memory qTokens) external view returns (uint[] memory);\\n\\n    function valueOfAsset(address asset, uint amount) external view returns (uint valueInBNB, uint valueInUSD);\\n    function unsafeValueOfAsset(address asset, uint amount) external view returns (uint valueInBNB, uint valueInUSD);\\n}\\n\"\r\n    },\r\n    \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, 'SafeMath: addition overflow');\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, 'SafeMath: subtraction overflow');\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, 'SafeMath: division by zero');\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, 'SafeMath: modulo by zero');\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@pancakeswap/pancake-swap-lib/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}('');\\n        require(success, 'Address: unable to send value, recipient may have reverted');\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, 'Address: low-level call failed');\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, 'Address: insufficient balance for call');\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 weiValue,\\n        string memory errorMessage\\n    ) private returns (bytes memory) {\\n        require(isContract(target), 'Address: call to non-contract');\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPancakeRouter01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        returns (\\n            uint amountA,\\n            uint amountB,\\n            uint liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint amountToken,\\n            uint amountETH,\\n            uint liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function quote(\\n        uint amountA,\\n        uint reserveA,\\n        uint reserveB\\n    ) external pure returns (uint amountB);\\n\\n    function getAmountOut(\\n        uint amountIn,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountOut);\\n\\n    function getAmountIn(\\n        uint amountOut,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountIn);\\n\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/tester/QValidatorTester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\nimport \\\"../interfaces/IPriceCalculator.sol\\\";\\nimport \\\"../interfaces/IQValidator.sol\\\";\\nimport \\\"../interfaces/IQToken.sol\\\";\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../library/QConstant.sol\\\";\\n\\ncontract QValidatorTester is IQValidator, OwnableUpgradeable {\\n    using SafeMath for uint;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address public constant USDT = 0x55d398326f99059fF775485246999027B3197955;\\n    address public constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n    address public constant BUNNY = 0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51;\\n    address public constant CAKE = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\\n    address public constant BNB = 0x0000000000000000000000000000000000000000;\\n    address public constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IQore public qore;\\n    IPriceCalculator oracle;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() external initializer {\\n        __Ownable_init();\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function getAccountLiquidity(address account) external view override returns (uint collateralInUSD, uint supplyInUSD, uint borrowInUSD) {\\n        collateralInUSD = 0;\\n        borrowInUSD = 0;\\n\\n        address[] memory assets = qore.marketListOf(account);\\n        uint[] memory prices = oracle.getUnderlyingPrices(assets);\\n        for (uint i = 0; i < assets.length; i++) {\\n            require(prices[i] != 0, \\\"QValidator: price error\\\");\\n            QConstant.AccountSnapshot memory snapshot = IQToken(payable(assets[i])).accountSnapshot(account);\\n\\n            uint collateralFactor = qore.marketInfoOf(payable(assets[i])).collateralFactor;\\n            uint collateralValuePerShareInUSD = snapshot.exchangeRate.mul(prices[i]).mul(collateralFactor).div(1e36);\\n\\n            collateralInUSD = collateralInUSD.add(snapshot.qTokenBalance.mul(collateralValuePerShareInUSD).div(1e18));\\n            supplyInUSD = supplyInUSD.add(snapshot.qTokenBalance.mul(snapshot.exchangeRate).mul(prices[i]).div(1e36));\\n            borrowInUSD = borrowInUSD.add(snapshot.borrowBalance.mul(prices[i]).div(1e18));\\n        }\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setQore(address _qore) external onlyOwner {\\n        require(_qore != address(0), \\\"QValidator: invalid qore address\\\");\\n        require(address(qore) == address(0), \\\"QValidator: qore already set\\\");\\n        qore = IQore(_qore);\\n    }\\n\\n    function setOracle(address _oracle) external onlyOwner {\\n        require(_oracle != address(0), \\\"QValidator: invalid oracle address\\\");\\n        oracle = IPriceCalculator(_oracle);\\n    }\\n\\n    /* ========== ALLOWED FUNCTIONS ========== */\\n\\n    function redeemAllowed(\\n        address qToken,\\n        address redeemer,\\n        uint redeemAmount\\n    ) external override returns (bool) {\\n        (, uint shortfall) = _getAccountLiquidityInternal(redeemer, qToken, redeemAmount, 0);\\n        return shortfall == 0;\\n    }\\n\\n    function borrowAllowed(\\n        address qToken,\\n        address borrower,\\n        uint borrowAmount\\n    ) external override returns (bool) {\\n        require(qore.checkMembership(borrower, address(qToken)), \\\"QValidator: enterMarket required\\\");\\n        require(oracle.getUnderlyingPrice(address(qToken)) > 0, \\\"QValidator: Underlying price error\\\");\\n\\n        // Borrow cap of 0 corresponds to unlimited borrowing\\n        uint borrowCap = qore.marketInfoOf(qToken).borrowCap;\\n        if (borrowCap != 0) {\\n            uint totalBorrows = IQToken(payable(qToken)).accruedTotalBorrow();\\n            uint nextTotalBorrows = totalBorrows.add(borrowAmount);\\n            require(nextTotalBorrows < borrowCap, \\\"QValidator: market borrow cap reached\\\");\\n        }\\n\\n        (, uint shortfall) = _getAccountLiquidityInternal(borrower, qToken, 0, borrowAmount);\\n        return shortfall == 0;\\n    }\\n\\n    function liquidateAllowed(\\n        address qToken,\\n        address borrower,\\n        uint liquidateAmount,\\n        uint closeFactor\\n    ) external override returns (bool) {\\n        // The borrower must have shortfall in order to be liquidate\\n        (, uint shortfall) = _getAccountLiquidityInternal(borrower, address(0), 0, 0);\\n        require(shortfall != 0, \\\"QValidator: Insufficient shortfall\\\");\\n\\n        // The liquidator may not repay more than what is allowed by the closeFactor\\n        uint borrowBalance = IQToken(payable(qToken)).accruedBorrowBalanceOf(borrower);\\n        uint maxClose = closeFactor.mul(borrowBalance).div(1e18);\\n        return liquidateAmount <= maxClose;\\n    }\\n\\n    function qTokenAmountToSeize(\\n        address qTokenBorrowed,\\n        address qTokenCollateral,\\n        uint amount\\n    ) external override returns (uint seizeQAmount) {\\n        uint priceBorrowed = oracle.getUnderlyingPrice(qTokenBorrowed);\\n        uint priceCollateral = oracle.getUnderlyingPrice(qTokenCollateral);\\n        require(priceBorrowed != 0 && priceCollateral != 0, \\\"QValidator: price error\\\");\\n\\n        uint exchangeRate = IQToken(payable(qTokenCollateral)).accruedExchangeRate();\\n        require(exchangeRate != 0, \\\"QValidator: exchangeRate of qTokenCollateral is zero\\\");\\n\\n        // seizeQTokenAmount = amount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\\n        return amount.mul(qore.liquidationIncentive()).mul(priceBorrowed).div(priceCollateral.mul(exchangeRate));\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _getAccountLiquidityInternal(\\n        address account,\\n        address qToken,\\n        uint redeemAmount,\\n        uint borrowAmount\\n    ) private returns (uint liquidity, uint shortfall) {\\n        uint accCollateralValueInUSD;\\n        uint accBorrowValueInUSD;\\n\\n        address[] memory assets = qore.marketListOf(account);\\n        uint[] memory prices = oracle.getUnderlyingPrices(assets);\\n        for (uint i = 0; i < assets.length; i++) {\\n            require(prices[i] != 0, \\\"QValidator: price error\\\");\\n            QConstant.AccountSnapshot memory snapshot = IQToken(payable(assets[i])).accruedAccountSnapshot(account);\\n\\n            uint collateralValuePerShareInUSD = snapshot\\n                .exchangeRate\\n                .mul(prices[i])\\n                .mul(qore.marketInfoOf(payable(assets[i])).collateralFactor)\\n                .div(1e36);\\n            accCollateralValueInUSD = accCollateralValueInUSD.add(\\n                snapshot.qTokenBalance.mul(collateralValuePerShareInUSD).div(1e18)\\n            );\\n            accBorrowValueInUSD = accBorrowValueInUSD.add(snapshot.borrowBalance.mul(prices[i]).div(1e18));\\n\\n            if (assets[i] == qToken) {\\n                accBorrowValueInUSD = accBorrowValueInUSD.add(redeemAmount.mul(collateralValuePerShareInUSD).div(1e18));\\n                accBorrowValueInUSD = accBorrowValueInUSD.add(borrowAmount.mul(prices[i]).div(1e18));\\n            }\\n        }\\n\\n        liquidity = accCollateralValueInUSD > accBorrowValueInUSD\\n            ? accCollateralValueInUSD.sub(accBorrowValueInUSD)\\n            : 0;\\n        shortfall = accCollateralValueInUSD > accBorrowValueInUSD\\n            ? 0\\n            : accBorrowValueInUSD.sub(accCollateralValueInUSD);\\n    }\\n\\n    function getAccountLiquidityTester(\\n        address account,\\n        address qToken,\\n        uint redeemAmount,\\n        uint borrowAmount\\n    ) external returns (uint liquidity, uint shortfall) {\\n        uint accCollateralValueInUSD;\\n        uint accBorrowValueInUSD;\\n\\n        address[] memory assets = qore.marketListOf(account);\\n        uint[] memory prices = getUnderlyingPricesTester(assets);\\n        for (uint i = 0; i < assets.length; i++) {\\n            require(prices[i] != 0, \\\"QValidator: price error\\\");\\n            QConstant.AccountSnapshot memory snapshot = IQToken(payable(assets[i])).accruedAccountSnapshot(account);\\n\\n            uint collateralValuePerShareInUSD = snapshot\\n                .exchangeRate\\n                .mul(prices[i])\\n                .mul(qore.marketInfoOf(payable(assets[i])).collateralFactor)\\n                .div(1e36);\\n            accCollateralValueInUSD = accCollateralValueInUSD.add(\\n                snapshot.qTokenBalance.mul(collateralValuePerShareInUSD).div(1e18)\\n            );\\n            accBorrowValueInUSD = accBorrowValueInUSD.add(snapshot.borrowBalance.mul(prices[i]).div(1e18));\\n\\n            if (assets[i] == qToken) {\\n                accBorrowValueInUSD = accBorrowValueInUSD.add(redeemAmount.mul(collateralValuePerShareInUSD).div(1e18));\\n                accBorrowValueInUSD = accBorrowValueInUSD.add(borrowAmount.mul(prices[i]).div(1e18));\\n            }\\n        }\\n\\n        liquidity = accCollateralValueInUSD > accBorrowValueInUSD\\n            ? accCollateralValueInUSD.sub(accBorrowValueInUSD)\\n            : 0;\\n        shortfall = accCollateralValueInUSD > accBorrowValueInUSD\\n            ? 0\\n            : accBorrowValueInUSD.sub(accCollateralValueInUSD);\\n    }\\n\\n    function getUnderlyingPricesTester(address[] memory assets) public view returns (uint[] memory) {\\n        uint[] memory returnValue = new uint[](assets.length);\\n        for (uint i = 0; i < assets.length; i++) {\\n            IQToken qToken = IQToken(payable(assets[i]));\\n            address addr = qToken.underlying();\\n            if (addr == USDT) {\\n                returnValue[i] = 1e18;\\n            } else if (addr == BUNNY) {\\n                returnValue[i] = 25e18;\\n            } else if (addr == CAKE) {\\n                returnValue[i] = 20e18;\\n            } else if (addr == BUSD) {\\n                returnValue[i] = 1e18;\\n            } else if (addr == USDT) {\\n                returnValue[i] = 1e18;\\n            } else if (addr == BNB || addr == WBNB) {\\n                returnValue[i] = 400e18;\\n            } else {\\n                returnValue[i] = 0;\\n            }\\n        }\\n        return returnValue;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\ninterface IQValidator {\\n    function redeemAllowed(\\n        address qToken,\\n        address redeemer,\\n        uint redeemAmount\\n    ) external returns (bool);\\n\\n    function borrowAllowed(\\n        address qToken,\\n        address borrower,\\n        uint borrowAmount\\n    ) external returns (bool);\\n\\n    function liquidateAllowed(\\n        address qTokenBorrowed,\\n        address borrower,\\n        uint repayAmount,\\n        uint closeFactor\\n    ) external returns (bool);\\n\\n    function qTokenAmountToSeize(\\n        address qTokenBorrowed,\\n        address qTokenCollateral,\\n        uint actualRepayAmount\\n    ) external returns (uint qTokenAmount);\\n\\n    function getAccountLiquidity(address account) external view returns (uint collateralInUSD, uint supplyInUSD, uint borrowInUSD);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"../library/QConstant.sol\\\";\\n\\ninterface IQToken {\\n    function underlying() external view returns (address);\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function accountSnapshot(address account) external view returns (QConstant.AccountSnapshot memory);\\n\\n    function underlyingBalanceOf(address account) external view returns (uint);\\n\\n    function borrowBalanceOf(address account) external view returns (uint);\\n\\n    function borrowRatePerSec() external view returns (uint);\\n\\n    function supplyRatePerSec() external view returns (uint);\\n\\n    function totalBorrow() external view returns (uint);\\n\\n    function totalReserve() external view returns (uint);\\n\\n    function reserveFactor() external view returns (uint);\\n\\n    function exchangeRate() external view returns (uint);\\n\\n    function getCash() external view returns (uint);\\n\\n    function getAccInterestIndex() external view returns (uint);\\n\\n    function accruedAccountSnapshot(address account) external returns (QConstant.AccountSnapshot memory);\\n\\n    function accruedUnderlyingBalanceOf(address account) external returns (uint);\\n\\n    function accruedBorrowBalanceOf(address account) external returns (uint);\\n\\n    function accruedTotalBorrow() external returns (uint);\\n\\n    function accruedExchangeRate() external returns (uint);\\n\\n    function approve(address spender, uint amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function transfer(address dst, uint amount) external returns (bool);\\n\\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\\n\\n    function supply(address account, uint underlyingAmount) external payable returns (uint);\\n\\n    function redeemToken(address account, uint qTokenAmount) external returns (uint);\\n\\n    function redeemUnderlying(address account, uint underlyingAmount) external returns (uint);\\n\\n    function borrow(address account, uint amount) external returns (uint);\\n\\n    function repayBorrow(address account, uint amount) external payable returns (uint);\\n\\n    function repayBorrowBehalf(address payer, address borrower, uint amount) external payable returns (uint);\\n\\n    function liquidateBorrow(address qTokenCollateral, address liquidator, address borrower, uint amount) external payable returns (uint qAmountToSeize);\\n\\n    function seize(address liquidator, address borrower, uint qTokenAmount) external;\\n\\n    function transferTokensInternal(address spender, address src, address dst, uint amount) external;\\n\\n    function supplyBehalf(address sender, address supplier, uint uAmount) external payable returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\n\\nimport \\\"../library/QConstant.sol\\\";\\n\\ninterface IQore {\\n    function qValidator() external view returns (address);\\n\\n    function allMarkets() external view returns (address[] memory);\\n    function marketListOf(address account) external view returns (address[] memory);\\n    function marketInfoOf(address qToken) external view returns (QConstant.MarketInfo memory);\\n    function checkMembership(address account, address qToken) external view returns (bool);\\n    function accountLiquidityOf(address account) external view returns (uint collateralInUSD, uint supplyInUSD, uint borrowInUSD);\\n\\n    function distributionInfoOf(address market) external view returns (QConstant.DistributionInfo memory);\\n    function accountDistributionInfoOf(address market, address account) external view returns (QConstant.DistributionAccountInfo memory);\\n    function apyDistributionOf(address market, address account) external view returns (QConstant.DistributionAPY memory);\\n    function distributionSpeedOf(address qToken) external view returns (uint supplySpeed, uint borrowSpeed);\\n    function boostedRatioOf(address market, address account) external view returns (uint boostedSupplyRatio, uint boostedBorrowRatio);\\n\\n    function closeFactor() external view returns (uint);\\n    function liquidationIncentive() external view returns (uint);\\n\\n    function accruedQubit(address account) external view returns (uint);\\n    function accruedQubit(address market, address account) external view returns (uint);\\n\\n    function enterMarkets(address[] memory qTokens) external;\\n    function exitMarket(address qToken) external;\\n\\n    function supply(address qToken, uint underlyingAmount) external payable returns (uint);\\n    function redeemToken(address qToken, uint qTokenAmount) external returns (uint redeemed);\\n    function redeemUnderlying(address qToken, uint underlyingAmount) external returns (uint redeemed);\\n    function borrow(address qToken, uint amount) external;\\n    function repayBorrow(address qToken, uint amount) external payable;\\n    function repayBorrowBehalf(address qToken, address borrower, uint amount) external payable;\\n    function liquidateBorrow(address qTokenBorrowed, address qTokenCollateral, address borrower, uint amount) external payable;\\n\\n    function claimQubit() external;\\n    function claimQubit(address market) external;\\n\\n    function transferTokens(address spender, address src, address dst, uint amount) external;\\n\\n    function supplyAndBorrowBehalf(address account, address supplyToken, uint supplyAmount, address borrowToken, uint borrowAmount) external payable returns (uint);\\n    function supplyAndBorrowBNB(address account, address supplyToken, uint supplyAmount, uint borrowAmount) external payable returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/library/QConstant.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nlibrary QConstant {\\n    uint public constant CLOSE_FACTOR_MIN = 5e16;\\n    uint public constant CLOSE_FACTOR_MAX = 9e17;\\n    uint public constant COLLATERAL_FACTOR_MAX = 9e17;\\n\\n    struct MarketInfo {\\n        bool isListed;\\n        uint borrowCap;\\n        uint collateralFactor;\\n    }\\n\\n    struct BorrowInfo {\\n        uint borrow;\\n        uint interestIndex;\\n    }\\n\\n    struct AccountSnapshot {\\n        uint qTokenBalance;\\n        uint borrowBalance;\\n        uint exchangeRate;\\n    }\\n\\n    struct AccrueSnapshot {\\n        uint totalBorrow;\\n        uint totalReserve;\\n        uint accInterestIndex;\\n    }\\n\\n    struct DistributionInfo {\\n        uint supplySpeed;\\n        uint borrowSpeed;\\n        uint totalBoostedSupply;\\n        uint totalBoostedBorrow;\\n        uint accPerShareSupply;\\n        uint accPerShareBorrow;\\n        uint accruedAt;\\n    }\\n\\n    struct DistributionAccountInfo {\\n        uint accruedQubit;\\n        uint boostedSupply; // effective(boosted) supply balance of user  (since last_action)\\n        uint boostedBorrow; // effective(boosted) borrow balance of user  (since last_action)\\n        uint accPerShareSupply; // Last integral value of Qubit rewards per share. ∫(qubitRate(t) / totalShare(t) dt) from 0 till (last_action)\\n        uint accPerShareBorrow; // Last integral value of Qubit rewards per share. ∫(qubitRate(t) / totalShare(t) dt) from 0 till (last_action)\\n    }\\n\\n    struct DistributionAPY {\\n        uint apySupplyQBT;\\n        uint apyBorrowQBT;\\n        uint apyAccountSupplyQBT;\\n        uint apyAccountBorrowQBT;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/SimpleQTokenTester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nimport \\\"../library/QConstant.sol\\\";\\npragma experimental ABIEncoderV2;\\n\\ncontract SimpleQTokenTester {\\n    address public underlying;\\n    uint public qTokenBalance;\\n    uint public borrowBalance;\\n    uint public exchangeRate;\\n    uint public exchangeRateStored;\\n    uint public totalBorrow;\\n\\n    constructor(address _underlying) public {\\n        underlying = _underlying;\\n        exchangeRateStored = 50000000000000000;\\n    }\\n\\n    function getAccountSnapshot(address)\\n        public\\n        view\\n        returns (\\n            uint,\\n            uint,\\n            uint\\n        )\\n    {\\n        return (qTokenBalance, borrowBalance, exchangeRate);\\n    }\\n\\n    function setAccountSnapshot(\\n        uint _qTokenBalance,\\n        uint _borrowBalance,\\n        uint _exchangeRate\\n    ) public {\\n        qTokenBalance = _qTokenBalance;\\n        borrowBalance = _borrowBalance;\\n        exchangeRate = _exchangeRate;\\n        totalBorrow = _borrowBalance;\\n    }\\n\\n    function borrowBalanceOf(address) public view returns (uint) {\\n        return borrowBalance;\\n    }\\n\\n    function accruedAccountSnapshot(address) external view returns (QConstant.AccountSnapshot memory) {\\n        QConstant.AccountSnapshot memory snapshot;\\n        snapshot.qTokenBalance = qTokenBalance;\\n        snapshot.borrowBalance = borrowBalance;\\n        snapshot.exchangeRate = exchangeRate;\\n        return snapshot;\\n    }\\n\\n    function accruedTotalBorrow() public view returns (uint) {\\n        return totalBorrow;\\n    }\\n\\n    function accruedBorrowBalanceOf(address) public view returns (uint) {\\n        return borrowBalance;\\n    }\\n\\n    function accruedExchangeRate() public view returns (uint) {\\n        return exchangeRate;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/QTokenTester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\n\\nimport \\\"../interfaces/IPancakeRouter02.sol\\\";\\nimport \\\"../interfaces/IQDistributor.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../library/QConstant.sol\\\";\\nimport \\\"../library/SafeToken.sol\\\";\\nimport \\\"../markets/QMarket.sol\\\";\\n\\ncontract QTokenTester is QMarket {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    // for test\\n    function setQDistributor(address _qDistributor) external onlyOwner {\\n        require(_qDistributor != address(0), \\\"QTokenTester: invalid qDistributor address\\\");\\n        qDistributor = IQDistributor(_qDistributor);\\n    }\\n\\n    /* ========== CONSTANT ========== */\\n\\n    IQDistributor public qDistributor;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n\\n    mapping(address => mapping(address => uint)) private _transferAllowances;\\n\\n    /* ========== EVENT ========== */\\n\\n    event Mint(address minter, uint mintAmount);\\n    event Redeem(address account, uint underlyingAmount, uint qTokenAmount);\\n\\n    event Borrow(address account, uint ammount, uint accountBorrow);\\n    event RepayBorrow(address payer, address borrower, uint amount, uint accountBorrow);\\n    event LiquidateBorrow(\\n        address liquidator,\\n        address borrower,\\n        uint amount,\\n        address qTokenCollateral,\\n        uint seizeAmount\\n    );\\n\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) external initializer {\\n        __QMarket_init();\\n\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function allowance(address account, address spender) external view override returns (uint) {\\n        return _transferAllowances[account][spender];\\n    }\\n\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function transfer(address dst, uint amount) external override accrue nonReentrant returns (bool) {\\n        qore.transferTokens(msg.sender, msg.sender, dst, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint amount\\n    ) external override accrue nonReentrant returns (bool) {\\n        qore.transferTokens(msg.sender, src, dst, amount);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint amount) external override returns (bool) {\\n        _transferAllowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function supply(address account, uint uAmount)\\n        external\\n        payable\\n        override\\n        accrue\\n        onlyQore\\n        nonReentrant\\n        returns (uint)\\n    {\\n        uint exchangeRate = exchangeRate();\\n        uAmount = underlying == address(WBNB) ? msg.value : uAmount;\\n        uAmount = _doTransferIn(account, uAmount);\\n        uint qAmount = uAmount.mul(1e18).div(exchangeRate);\\n\\n        totalSupply = totalSupply.add(qAmount);\\n        accountBalances[account] = accountBalances[account].add(qAmount);\\n\\n        emit Mint(account, qAmount);\\n        emit Transfer(address(this), account, qAmount);\\n        return qAmount;\\n    }\\n\\n    function redeemToken(address redeemer, uint qAmount) external override accrue onlyQore nonReentrant returns (uint) {\\n        return _redeem(redeemer, qAmount, 0);\\n    }\\n\\n    function redeemUnderlying(address redeemer, uint uAmount)\\n        external\\n        override\\n        accrue\\n        onlyQore\\n        nonReentrant\\n        returns (uint)\\n    {\\n        return _redeem(redeemer, 0, uAmount);\\n    }\\n\\n    function borrow(address account, uint amount) external override accrue onlyQore nonReentrant returns (uint) {\\n        require(getCash() >= amount, \\\"QToken: borrow amount exceeds cash\\\");\\n        updateBorrowInfo(account, amount, 0);\\n        _doTransferOut(account, amount);\\n\\n        emit Borrow(account, amount, borrowBalanceOf(account));\\n        return amount;\\n    }\\n\\n    function repayBorrow(address account, uint amount)\\n        external\\n        payable\\n        override\\n        accrue\\n        onlyQore\\n        nonReentrant\\n        returns (uint)\\n    {\\n        if (amount == uint(-1)) {\\n            amount = borrowBalanceOf(account);\\n        }\\n        return _repay(account, account, underlying == address(WBNB) ? msg.value : amount);\\n    }\\n\\n    function repayBorrowBehalf(\\n        address payer,\\n        address borrower,\\n        uint amount\\n    ) external payable override accrue onlyQore nonReentrant returns (uint) {\\n        if (amount == uint(-1)) {\\n            amount = borrowBalanceOf(borrower);\\n        }\\n        return _repay(payer, borrower, underlying == address(WBNB) ? msg.value : amount);\\n    }\\n\\n    function liquidateBorrow(\\n        address qTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint amount\\n    ) external payable override accrue onlyQore nonReentrant returns (uint qAmountToSeize) {\\n        require(borrower != liquidator, \\\"QToken: cannot liquidate yourself\\\");\\n\\n        amount = underlying == address(WBNB) ? msg.value : amount;\\n        amount = _repay(liquidator, borrower, amount);\\n        require(amount > 0 && amount < uint(-1), \\\"QToken: invalid repay amount\\\");\\n\\n        qAmountToSeize = IQValidator(qore.qValidator()).qTokenAmountToSeize(address(this), qTokenCollateral, amount);\\n        require(\\n            IQToken(payable(qTokenCollateral)).balanceOf(borrower) >= qAmountToSeize,\\n            \\\"QToken: too much seize amount\\\"\\n        );\\n        emit LiquidateBorrow(liquidator, borrower, amount, qTokenCollateral, qAmountToSeize);\\n    }\\n\\n    function seize(\\n        address liquidator,\\n        address borrower,\\n        uint qAmount\\n    ) external override accrue onlyQore nonReentrant {\\n        accountBalances[borrower] = accountBalances[borrower].sub(qAmount);\\n        accountBalances[liquidator] = accountBalances[liquidator].add(qAmount);\\n\\n        emit Transfer(borrower, liquidator, qAmount);\\n    }\\n\\n    function transferTokensInternal(\\n        address spender,\\n        address src,\\n        address dst,\\n        uint amount\\n    ) external override onlyQore {\\n        require(\\n            src != dst && IQValidator(qore.qValidator()).redeemAllowed(address(this), src, amount),\\n            \\\"QToken: cannot transfer\\\"\\n        );\\n        require(amount != 0, \\\"QToken: zero amount\\\");\\n\\n        uint _allowance = spender == src ? uint(-1) : _transferAllowances[src][spender];\\n        uint _allowanceNew = _allowance.sub(amount, \\\"QToken: transfer amount exceeds allowance\\\");\\n\\n        accountBalances[src] = accountBalances[src].sub(amount);\\n        accountBalances[dst] = accountBalances[dst].add(amount);\\n\\n        qDistributor.notifyTransferred(address(this), src, dst);\\n\\n        if (_allowance != uint(-1)) {\\n            _transferAllowances[src][msg.sender] = _allowanceNew;\\n        }\\n        emit Transfer(src, dst, amount);\\n    }\\n\\n    function supplyBehalf(address sender, address supplier, uint uAmount) external payable override accrue onlyQore returns (uint) {\\n        uint exchangeRate = exchangeRate();\\n        uAmount = underlying == address(WBNB) ? msg.value : uAmount;\\n        uAmount = _doTransferIn(sender, uAmount);\\n        uint qAmount = uAmount.mul(1e18).div(exchangeRate);\\n        updateSupplyInfo(supplier, qAmount, 0);\\n\\n        emit Mint(supplier, qAmount);\\n        emit Transfer(address(0), supplier, qAmount);\\n        return qAmount;\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _doTransferIn(address from, uint amount) private returns (uint) {\\n        if (underlying == address(WBNB)) {\\n            require(msg.value >= amount, \\\"QToken: value mismatch\\\");\\n            return Math.min(msg.value, amount);\\n        } else {\\n            uint balanceBefore = IBEP20(underlying).balanceOf(address(this));\\n            underlying.safeTransferFrom(from, address(this), amount);\\n            return IBEP20(underlying).balanceOf(address(this)).sub(balanceBefore);\\n        }\\n    }\\n\\n    function _doTransferOut(address to, uint amount) private {\\n        if (underlying == address(WBNB)) {\\n            SafeToken.safeTransferETH(to, amount);\\n        } else {\\n            underlying.safeTransfer(to, amount);\\n        }\\n    }\\n\\n    function _redeem(\\n        address account,\\n        uint qAmountIn,\\n        uint uAmountIn\\n    ) private returns (uint) {\\n        require(qAmountIn == 0 || uAmountIn == 0, \\\"QToken: one of qAmountIn or uAmountIn must be zero\\\");\\n        require(totalSupply >= qAmountIn, \\\"QToken: not enough total supply\\\");\\n        require(getCash() >= uAmountIn || uAmountIn == 0, \\\"QToken: not enough underlying\\\");\\n        require(\\n            getCash() >= qAmountIn.mul(exchangeRate()).div(1e18) || qAmountIn == 0,\\n            \\\"QToken: not enough underlying\\\"\\n        );\\n\\n        uint qAmountToRedeem = qAmountIn > 0 ? qAmountIn : uAmountIn.mul(1e18).div(exchangeRate());\\n        uint uAmountToRedeem = qAmountIn > 0 ? qAmountIn.mul(exchangeRate()).div(1e18) : uAmountIn;\\n\\n        require(\\n            IQValidator(qore.qValidator()).redeemAllowed(address(this), account, qAmountToRedeem),\\n            \\\"QToken: cannot redeem\\\"\\n        );\\n\\n        totalSupply = totalSupply.sub(qAmountToRedeem);\\n        accountBalances[account] = accountBalances[account].sub(qAmountToRedeem);\\n        _doTransferOut(account, uAmountToRedeem);\\n\\n        emit Transfer(account, address(this), qAmountToRedeem);\\n        emit Redeem(account, uAmountToRedeem, qAmountToRedeem);\\n        return uAmountToRedeem;\\n    }\\n\\n    function _repay(\\n        address payer,\\n        address borrower,\\n        uint amount\\n    ) private returns (uint) {\\n        uint borrowBalance = borrowBalanceOf(borrower);\\n        uint repayAmount = Math.min(borrowBalance, amount);\\n        repayAmount = _doTransferIn(payer, repayAmount);\\n        updateBorrowInfo(borrower, 0, repayAmount);\\n\\n        if (underlying == address(WBNB)) {\\n            uint refundAmount = amount > repayAmount ? amount.sub(repayAmount) : 0;\\n            if (refundAmount > 0) {\\n                _doTransferOut(payer, refundAmount);\\n            }\\n        }\\n\\n        emit RepayBorrow(payer, borrower, repayAmount, borrowBalanceOf(borrower));\\n        return repayAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"../library/QConstant.sol\\\";\\n\\ninterface IQDistributor {\\n    function accruedQubit(address[] calldata markets, address account) external view returns (uint);\\n    function distributionInfoOf(address market) external view returns (QConstant.DistributionInfo memory);\\n    function accountDistributionInfoOf(address market, address account) external view returns (QConstant.DistributionAccountInfo memory);\\n    function apyDistributionOf(address market, address account) external view returns (QConstant.DistributionAPY memory);\\n    function boostedRatioOf(address market, address account) external view returns (uint boostedSupplyRatio, uint boostedBorrowRatio);\\n\\n    function notifySupplyUpdated(address market, address user) external;\\n    function notifyBorrowUpdated(address market, address user) external;\\n    function notifyTransferred(address qToken, address sender, address receiver) external;\\n\\n    function claimQubit(address[] calldata markets, address account) external;\\n    function kick(address user) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface IWETH {\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function deposit() external payable;\\n    function withdraw(uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/markets/QMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\\\";\\n\\nimport \\\"../interfaces/IQValidator.sol\\\";\\nimport \\\"../interfaces/IRateModel.sol\\\";\\nimport \\\"../interfaces/IQToken.sol\\\";\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../library/QConstant.sol\\\";\\n\\nabstract contract QMarket is IQToken, OwnableUpgradeable, ReentrancyGuardUpgradeable {\\n    using SafeMath for uint;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    uint internal constant RESERVE_FACTOR_MAX = 1e18;\\n    uint internal constant DUST = 1000;\\n\\n    address internal constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address internal constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IQore public qore;\\n    IRateModel public rateModel;\\n    address public override underlying;\\n\\n    uint public override totalSupply;\\n    uint public override totalReserve;\\n    uint private _totalBorrow;\\n\\n    mapping(address => uint) internal accountBalances;\\n    mapping(address => QConstant.BorrowInfo) internal accountBorrows;\\n\\n    uint public override reserveFactor;\\n    uint private lastAccruedTime;\\n    uint private accInterestIndex;\\n\\n    /* ========== Event ========== */\\n\\n    event RateModelUpdated(address newRateModel);\\n    event ReserveFactorUpdated(uint newReserveFactor);\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    receive() external payable {}\\n\\n    function __QMarket_init() internal initializer {\\n        __Ownable_init();\\n        __ReentrancyGuard_init();\\n\\n        lastAccruedTime = block.timestamp;\\n        accInterestIndex = 1e18;\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier accrue() {\\n        if (block.timestamp > lastAccruedTime && address(rateModel) != address(0)) {\\n            uint borrowRate = rateModel.getBorrowRate(getCashPrior(), _totalBorrow, totalReserve);\\n            uint interestFactor = borrowRate.mul(block.timestamp.sub(lastAccruedTime));\\n            uint pendingInterest = _totalBorrow.mul(interestFactor).div(1e18);\\n\\n            _totalBorrow = _totalBorrow.add(pendingInterest);\\n            totalReserve = totalReserve.add(pendingInterest.mul(reserveFactor).div(1e18));\\n            accInterestIndex = accInterestIndex.add(interestFactor.mul(accInterestIndex).div(1e18));\\n            lastAccruedTime = block.timestamp;\\n        }\\n        _;\\n    }\\n\\n    modifier onlyQore() {\\n        require(msg.sender == address(qore), \\\"QToken: only Qore Contract\\\");\\n        _;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setQore(address _qore) public onlyOwner {\\n        require(_qore != address(0), \\\"QMarket: invalid qore address\\\");\\n        require(address(qore) == address(0), \\\"QMarket: qore already set\\\");\\n        qore = IQore(_qore);\\n    }\\n\\n    function setUnderlying(address _underlying) public onlyOwner {\\n        require(_underlying != address(0), \\\"QMarket: invalid underlying address\\\");\\n        require(underlying == address(0), \\\"QMarket: set underlying already\\\");\\n        underlying = _underlying;\\n    }\\n\\n    function setRateModel(address _rateModel) public accrue onlyOwner {\\n        require(_rateModel != address(0), \\\"QMarket: invalid rate model address\\\");\\n        rateModel = IRateModel(_rateModel);\\n        emit RateModelUpdated(_rateModel);\\n    }\\n\\n    function setReserveFactor(uint _reserveFactor) public accrue onlyOwner {\\n        require(_reserveFactor <= RESERVE_FACTOR_MAX, \\\"QMarket: invalid reserve factor\\\");\\n        reserveFactor = _reserveFactor;\\n        emit ReserveFactorUpdated(_reserveFactor);\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function balanceOf(address account) external view override returns (uint) {\\n        return accountBalances[account];\\n    }\\n\\n    function accountSnapshot(address account) external view override returns (QConstant.AccountSnapshot memory) {\\n        QConstant.AccountSnapshot memory snapshot;\\n        snapshot.qTokenBalance = accountBalances[account];\\n        snapshot.borrowBalance = borrowBalanceOf(account);\\n        snapshot.exchangeRate = exchangeRate();\\n        return snapshot;\\n    }\\n\\n    function underlyingBalanceOf(address account) external view override returns (uint) {\\n        return accountBalances[account].mul(exchangeRate()).div(1e18);\\n    }\\n\\n    function borrowBalanceOf(address account) public view override returns (uint) {\\n        QConstant.AccrueSnapshot memory snapshot = pendingAccrueSnapshot();\\n        QConstant.BorrowInfo storage info = accountBorrows[account];\\n\\n        if (info.borrow == 0) return 0;\\n        return info.borrow.mul(snapshot.accInterestIndex).div(info.interestIndex);\\n    }\\n\\n    function borrowRatePerSec() external view override returns (uint) {\\n        QConstant.AccrueSnapshot memory snapshot = pendingAccrueSnapshot();\\n        return rateModel.getBorrowRate(getCashPrior(), snapshot.totalBorrow, snapshot.totalReserve);\\n    }\\n\\n    function supplyRatePerSec() external view override returns (uint) {\\n        QConstant.AccrueSnapshot memory snapshot = pendingAccrueSnapshot();\\n        return rateModel.getSupplyRate(getCashPrior(), snapshot.totalBorrow, snapshot.totalReserve, reserveFactor);\\n    }\\n\\n    function totalBorrow() public view override returns (uint) {\\n        QConstant.AccrueSnapshot memory snapshot = pendingAccrueSnapshot();\\n        return snapshot.totalBorrow;\\n    }\\n\\n    function exchangeRate() public view override returns (uint) {\\n        if (totalSupply == 0) return 1e18;\\n        QConstant.AccrueSnapshot memory snapshot = pendingAccrueSnapshot();\\n        return getCashPrior().add(snapshot.totalBorrow).sub(snapshot.totalReserve).mul(1e18).div(totalSupply);\\n    }\\n\\n    function getCash() public view override returns (uint) {\\n        return getCashPrior();\\n    }\\n\\n    function getAccInterestIndex() public view override returns (uint) {\\n        QConstant.AccrueSnapshot memory snapshot = pendingAccrueSnapshot();\\n        return snapshot.accInterestIndex;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function accruedAccountSnapshot(address account)\\n        external\\n        override\\n        accrue\\n        returns (QConstant.AccountSnapshot memory)\\n    {\\n        QConstant.AccountSnapshot memory snapshot;\\n        QConstant.BorrowInfo storage info = accountBorrows[account];\\n        if (info.interestIndex != 0) {\\n            info.borrow = info.borrow.mul(accInterestIndex).div(info.interestIndex);\\n            info.interestIndex = accInterestIndex;\\n        }\\n\\n        snapshot.qTokenBalance = accountBalances[account];\\n        snapshot.borrowBalance = info.borrow;\\n        snapshot.exchangeRate = exchangeRate();\\n        return snapshot;\\n    }\\n\\n    function accruedUnderlyingBalanceOf(address account) external override accrue returns (uint) {\\n        return accountBalances[account].mul(exchangeRate()).div(1e18);\\n    }\\n\\n    function accruedBorrowBalanceOf(address account) external override accrue returns (uint) {\\n        QConstant.BorrowInfo storage info = accountBorrows[account];\\n        if (info.interestIndex != 0) {\\n            info.borrow = info.borrow.mul(accInterestIndex).div(info.interestIndex);\\n            info.interestIndex = accInterestIndex;\\n        }\\n        return info.borrow;\\n    }\\n\\n    function accruedTotalBorrow() external override accrue returns (uint) {\\n        return _totalBorrow;\\n    }\\n\\n    function accruedExchangeRate() external override accrue returns (uint) {\\n        return exchangeRate();\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function updateBorrowInfo(\\n        address account,\\n        uint addAmount,\\n        uint subAmount\\n    ) internal {\\n        QConstant.BorrowInfo storage info = accountBorrows[account];\\n        if (info.interestIndex == 0) {\\n            info.interestIndex = accInterestIndex;\\n        }\\n\\n        info.borrow = info.borrow.mul(accInterestIndex).div(info.interestIndex).add(addAmount).sub(subAmount);\\n        info.interestIndex = accInterestIndex;\\n        _totalBorrow = _totalBorrow.add(addAmount).sub(subAmount);\\n\\n        info.borrow = (info.borrow < DUST) ? 0 : info.borrow;\\n        _totalBorrow = (_totalBorrow < DUST) ? 0 : _totalBorrow;\\n    }\\n\\n    function updateSupplyInfo(\\n        address account,\\n        uint addAmount,\\n        uint subAmount\\n    ) internal {\\n        accountBalances[account] = accountBalances[account].add(addAmount).sub(subAmount);\\n        totalSupply = totalSupply.add(addAmount).sub(subAmount);\\n\\n        totalSupply = (totalSupply < DUST) ? 0 : totalSupply;\\n    }\\n\\n    function getCashPrior() internal view returns (uint) {\\n        return\\n            underlying == address(WBNB)\\n                ? address(this).balance.sub(msg.value)\\n                : IBEP20(underlying).balanceOf(address(this));\\n    }\\n\\n    function pendingAccrueSnapshot() internal view returns (QConstant.AccrueSnapshot memory) {\\n        QConstant.AccrueSnapshot memory snapshot;\\n        snapshot.totalBorrow = _totalBorrow;\\n        snapshot.totalReserve = totalReserve;\\n        snapshot.accInterestIndex = accInterestIndex;\\n\\n        if (block.timestamp > lastAccruedTime && _totalBorrow > 0) {\\n            uint borrowRate = rateModel.getBorrowRate(getCashPrior(), _totalBorrow, totalReserve);\\n            uint interestFactor = borrowRate.mul(block.timestamp.sub(lastAccruedTime));\\n            uint pendingInterest = _totalBorrow.mul(interestFactor).div(1e18);\\n\\n            snapshot.totalBorrow = _totalBorrow.add(pendingInterest);\\n            snapshot.totalReserve = totalReserve.add(pendingInterest.mul(reserveFactor).div(1e18));\\n            snapshot.accInterestIndex = accInterestIndex.add(interestFactor.mul(accInterestIndex).div(1e18));\\n        }\\n        return snapshot;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\ninterface IRateModel {\\n    function getBorrowRate(\\n        uint cash,\\n        uint borrows,\\n        uint reserves\\n    ) external view returns (uint);\\n\\n    function getSupplyRate(\\n        uint cash,\\n        uint borrows,\\n        uint reserves,\\n        uint reserveFactor\\n    ) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/markets/QToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\n\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../library/SafeToken.sol\\\";\\nimport \\\"./QMarket.sol\\\";\\n\\ncontract QToken is QMarket {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n\\n    mapping(address => mapping(address => uint)) private _transferAllowances;\\n\\n    /* ========== EVENT ========== */\\n\\n    event Mint(address minter, uint mintAmount);\\n    event Redeem(address account, uint underlyingAmount, uint qTokenAmount);\\n\\n    event Borrow(address account, uint ammount, uint accountBorrow);\\n    event RepayBorrow(address payer, address borrower, uint amount, uint accountBorrow);\\n    event LiquidateBorrow(\\n        address liquidator,\\n        address borrower,\\n        uint amount,\\n        address qTokenCollateral,\\n        uint seizeAmount\\n    );\\n\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) external initializer {\\n        __QMarket_init();\\n\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function allowance(address account, address spender) external view override returns (uint) {\\n        return _transferAllowances[account][spender];\\n    }\\n\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function transfer(address dst, uint amount) external override accrue nonReentrant returns (bool) {\\n        qore.transferTokens(msg.sender, msg.sender, dst, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint amount\\n    ) external override accrue nonReentrant returns (bool) {\\n        qore.transferTokens(msg.sender, src, dst, amount);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint amount) external override returns (bool) {\\n        _transferAllowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function supply(address account, uint uAmount) external payable override accrue onlyQore returns (uint) {\\n        uint exchangeRate = exchangeRate();\\n        uAmount = underlying == address(WBNB) ? msg.value : uAmount;\\n        uAmount = _doTransferIn(account, uAmount);\\n        uint qAmount = uAmount.mul(1e18).div(exchangeRate);\\n        updateSupplyInfo(account, qAmount, 0);\\n\\n        emit Mint(account, qAmount);\\n        emit Transfer(address(0), account, qAmount);\\n        return qAmount;\\n    }\\n\\n    function redeemToken(address redeemer, uint qAmount) external override accrue onlyQore returns (uint) {\\n        return _redeem(redeemer, qAmount, 0);\\n    }\\n\\n    function redeemUnderlying(address redeemer, uint uAmount) external override accrue onlyQore returns (uint) {\\n        return _redeem(redeemer, 0, uAmount);\\n    }\\n\\n    function borrow(address account, uint amount) external override accrue onlyQore returns (uint) {\\n        require(getCash() >= amount, \\\"QToken: borrow amount exceeds cash\\\");\\n        updateBorrowInfo(account, amount, 0);\\n        _doTransferOut(account, amount);\\n\\n        emit Borrow(account, amount, borrowBalanceOf(account));\\n        return amount;\\n    }\\n\\n    function repayBorrow(address account, uint amount) external payable override accrue onlyQore returns (uint) {\\n        if (amount == uint(-1)) {\\n            amount = borrowBalanceOf(account);\\n        }\\n        return _repay(account, account, underlying == address(WBNB) ? msg.value : amount);\\n    }\\n\\n    function repayBorrowBehalf(\\n        address payer,\\n        address borrower,\\n        uint amount\\n    ) external payable override accrue onlyQore returns (uint) {\\n        return _repay(payer, borrower, underlying == address(WBNB) ? msg.value : amount);\\n    }\\n\\n    function liquidateBorrow(\\n        address qTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint amount\\n    ) external payable override accrue onlyQore returns (uint qAmountToSeize) {\\n        require(borrower != liquidator, \\\"QToken: cannot liquidate yourself\\\");\\n\\n        amount = underlying == address(WBNB) ? msg.value : amount;\\n        amount = _repay(liquidator, borrower, amount);\\n        require(amount > 0 && amount < uint(-1), \\\"QToken: invalid repay amount\\\");\\n\\n        qAmountToSeize = IQValidator(qore.qValidator()).qTokenAmountToSeize(address(this), qTokenCollateral, amount);\\n        require(\\n            IQToken(payable(qTokenCollateral)).balanceOf(borrower) >= qAmountToSeize,\\n            \\\"QToken: too much seize amount\\\"\\n        );\\n        emit LiquidateBorrow(liquidator, borrower, amount, qTokenCollateral, qAmountToSeize);\\n    }\\n\\n    function seize(\\n        address liquidator,\\n        address borrower,\\n        uint qAmount\\n    ) external override accrue onlyQore nonReentrant {\\n        accountBalances[borrower] = accountBalances[borrower].sub(qAmount);\\n        accountBalances[liquidator] = accountBalances[liquidator].add(qAmount);\\n\\n        emit Transfer(borrower, liquidator, qAmount);\\n    }\\n\\n    function transferTokensInternal(\\n        address spender,\\n        address src,\\n        address dst,\\n        uint amount\\n    ) external override onlyQore {\\n        require(\\n            src != dst && IQValidator(qore.qValidator()).redeemAllowed(address(this), src, amount),\\n            \\\"QToken: cannot transfer\\\"\\n        );\\n        require(amount != 0, \\\"QToken: zero amount\\\");\\n\\n        uint _allowance = spender == src ? uint(-1) : _transferAllowances[src][spender];\\n        uint _allowanceNew = _allowance.sub(amount, \\\"QToken: transfer amount exceeds allowance\\\");\\n\\n        accountBalances[src] = accountBalances[src].sub(amount);\\n        accountBalances[dst] = accountBalances[dst].add(amount);\\n\\n        if (_allowance != uint(-1)) {\\n            _transferAllowances[src][spender] = _allowanceNew;\\n        }\\n        emit Transfer(src, dst, amount);\\n    }\\n\\n    function supplyBehalf(address sender, address supplier, uint uAmount) external payable override accrue onlyQore returns (uint) {\\n        uint exchangeRate = exchangeRate();\\n        uAmount = underlying == address(WBNB) ? msg.value : uAmount;\\n        uAmount = _doTransferIn(sender, uAmount);\\n        uint qAmount = uAmount.mul(1e18).div(exchangeRate);\\n        updateSupplyInfo(supplier, qAmount, 0);\\n\\n        emit Mint(supplier, qAmount);\\n        emit Transfer(address(0), supplier, qAmount);\\n        return qAmount;\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _doTransferIn(address from, uint amount) private returns (uint) {\\n        if (underlying == address(WBNB)) {\\n            require(msg.value >= amount, \\\"QToken: value mismatch\\\");\\n            return Math.min(msg.value, amount);\\n        } else {\\n            uint balanceBefore = IBEP20(underlying).balanceOf(address(this));\\n            underlying.safeTransferFrom(from, address(this), amount);\\n            uint balanceAfter = IBEP20(underlying).balanceOf(address(this));\\n            require(balanceAfter.sub(balanceBefore) <= amount);\\n            return balanceAfter.sub(balanceBefore);\\n        }\\n    }\\n\\n    function _doTransferOut(address to, uint amount) private {\\n        if (underlying == address(WBNB)) {\\n            SafeToken.safeTransferETH(to, amount);\\n        } else {\\n            underlying.safeTransfer(to, amount);\\n        }\\n    }\\n\\n    function _redeem(\\n        address account,\\n        uint qAmountIn,\\n        uint uAmountIn\\n    ) private returns (uint) {\\n        require(qAmountIn == 0 || uAmountIn == 0, \\\"QToken: one of qAmountIn or uAmountIn must be zero\\\");\\n        require(totalSupply >= qAmountIn, \\\"QToken: not enough total supply\\\");\\n        require(getCash() >= uAmountIn || uAmountIn == 0, \\\"QToken: not enough underlying\\\");\\n        require(\\n            getCash() >= qAmountIn.mul(exchangeRate()).div(1e18) || qAmountIn == 0,\\n            \\\"QToken: not enough underlying\\\"\\n        );\\n\\n        uint qAmountToRedeem = qAmountIn > 0 ? qAmountIn : uAmountIn.mul(1e18).div(exchangeRate());\\n        uint uAmountToRedeem = qAmountIn > 0 ? qAmountIn.mul(exchangeRate()).div(1e18) : uAmountIn;\\n\\n        require(\\n            IQValidator(qore.qValidator()).redeemAllowed(address(this), account, qAmountToRedeem),\\n            \\\"QToken: cannot redeem\\\"\\n        );\\n\\n        updateSupplyInfo(account, 0, qAmountToRedeem);\\n        _doTransferOut(account, uAmountToRedeem);\\n\\n        emit Transfer(account, address(0), qAmountToRedeem);\\n        emit Redeem(account, uAmountToRedeem, qAmountToRedeem);\\n        return uAmountToRedeem;\\n    }\\n\\n    function _repay(\\n        address payer,\\n        address borrower,\\n        uint amount\\n    ) private returns (uint) {\\n        uint borrowBalance = borrowBalanceOf(borrower);\\n        uint repayAmount = Math.min(borrowBalance, amount);\\n        repayAmount = _doTransferIn(payer, repayAmount);\\n        updateBorrowInfo(borrower, 0, repayAmount);\\n\\n        if (underlying == address(WBNB)) {\\n            uint refundAmount = amount > repayAmount ? amount.sub(repayAmount) : 0;\\n            if (refundAmount > 0) {\\n                _doTransferOut(payer, refundAmount);\\n            }\\n        }\\n\\n        emit RepayBorrow(payer, borrower, repayAmount, borrowBalanceOf(borrower));\\n        return repayAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/QDistributorTester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"../interfaces/IQDistributor.sol\\\";\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../interfaces/IQubitLocker.sol\\\";\\nimport \\\"../interfaces/IPriceCalculator.sol\\\";\\nimport \\\"../library/WhitelistUpgradeable.sol\\\";\\nimport \\\"../markets/QToken.sol\\\";\\n\\n\\n\\ncontract QDistributorTester is IQDistributor, WhitelistUpgradeable, ReentrancyGuardUpgradeable {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ======= TEST FUNCTIONS ====== */\\n    function setEffectiveSupply(\\n        address market,\\n        address user,\\n        uint effectiveSupply\\n    ) public {\\n        accountDistributions[market][user].boostedSupply = effectiveSupply;\\n    }\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address private constant QBT = 0x17B7163cf1Dbd286E262ddc68b553D899B93f526;\\n\\n    uint public constant BOOST_PORTION = 150;\\n    uint public constant BOOST_MAX = 250;\\n\\n    address private constant QORE = 0x21824518e7E443812586c96aB5B05E9F91831E06;\\n    IPriceCalculator public constant priceCalculator = IPriceCalculator(0x20E5E35ba29dC3B540a1aee781D0814D5c77Bce6);\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(address => QConstant.DistributionInfo) distributions;\\n    mapping(address => mapping(address => QConstant.DistributionAccountInfo)) accountDistributions;\\n\\n    IQubitLocker public qubitLocker;\\n    IQore public qore;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier updateDistributionOf(address market) {\\n        QConstant.DistributionInfo storage dist = distributions[market];\\n        if (dist.accruedAt == 0) {\\n            dist.accruedAt = block.timestamp;\\n        }\\n\\n        uint timeElapsed = block.timestamp > dist.accruedAt ? block.timestamp.sub(dist.accruedAt) : 0;\\n        if (timeElapsed > 0) {\\n            if (dist.totalBoostedSupply > 0) {\\n                dist.accPerShareSupply = dist.accPerShareSupply.add(\\n                    dist.supplySpeed.mul(timeElapsed).mul(1e18).div(dist.totalBoostedSupply)\\n                );\\n            }\\n\\n            if (dist.totalBoostedBorrow > 0) {\\n                dist.accPerShareBorrow = dist.accPerShareBorrow.add(\\n                    dist.borrowSpeed.mul(timeElapsed).mul(1e18).div(dist.totalBoostedBorrow)\\n                );\\n            }\\n        }\\n        dist.accruedAt = block.timestamp;\\n        _;\\n    }\\n\\n    modifier onlyQore() {\\n        require(msg.sender == address(qore), \\\"QDistributor: caller is not Qore\\\");\\n        _;\\n    }\\n\\n    modifier onlyMarket() {\\n        bool fromMarket = false;\\n        address[] memory markets = qore.allMarkets();\\n        for (uint i = 0; i < markets.length; i++) {\\n            if (msg.sender == markets[i]) {\\n                fromMarket = true;\\n            }\\n        }\\n        require(fromMarket == true, \\\"QDistributor: caller should be market\\\");\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event QubitDistributionSpeedUpdated(address indexed qToken, uint supplySpeed, uint borrowSpeed);\\n    event QubitClaimed(address indexed user, uint amount);\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() external initializer {\\n        __WhitelistUpgradeable_init();\\n        __ReentrancyGuard_init();\\n        qore = IQore(QORE);\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function accruedQubit(address[] calldata markets, address account) external view override returns (uint) {\\n        uint amount = 0;\\n        for (uint i = 0; i < markets.length; i++) {\\n            amount = amount.add(_accruedQubit(markets[i], account));\\n        }\\n        return amount;\\n    }\\n\\n    function distributionInfoOf(address market) external view override returns (QConstant.DistributionInfo memory) {\\n        return distributions[market];\\n    }\\n\\n    function accountDistributionInfoOf(address market, address account) external view override returns (QConstant.DistributionAccountInfo memory) {\\n        return accountDistributions[market][account];\\n    }\\n\\n    function apyDistributionOf(address market, address account) external view override returns (QConstant.DistributionAPY memory) {\\n        (uint apySupplyQBT, uint apyBorrowQBT) = _calculateMarketDistributionAPY(market);\\n        (uint apyAccountSupplyQBT, uint apyAccountBorrowQBT) = _calculateAccountDistributionAPY(market, account);\\n        return QConstant.DistributionAPY(apySupplyQBT, apyBorrowQBT, apyAccountSupplyQBT, apyAccountBorrowQBT);\\n    }\\n\\n    function boostedRatioOf(address market, address account) external view override returns (uint boostedSupplyRatio, uint boostedBorrowRatio) {\\n        uint accountSupply = IQToken(market).balanceOf(account);\\n        uint accountBorrow = IQToken(market).borrowBalanceOf(account).mul(1e18).div(IQToken(market).getAccInterestIndex());\\n\\n        boostedSupplyRatio = accountSupply > 0 ? accountDistributions[market][account].boostedSupply.mul(1e18).div(accountSupply).mul(250).div(100) : 0;\\n        boostedBorrowRatio = accountBorrow > 0 ? accountDistributions[market][account].boostedBorrow.mul(1e18).div(accountBorrow).mul(250).div(100) : 0;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setQubitLocker(address _locker) external onlyOwner {\\n        require(address(_locker) != address(0), \\\"QDistributor: invalid locker\\\");\\n        qubitLocker = IQubitLocker(_locker);\\n    }\\n\\n    function setQore(address _qore) external onlyOwner {\\n        require(address(_qore) != address(0), \\\"QDistributor: invalid qore\\\");\\n        require(address(qore) == address(0), \\\"QValidator: qore already set\\\");\\n        qore = IQore(_qore);\\n    }\\n\\n    function setQubitDistributionSpeed(\\n        address qToken,\\n        uint supplySpeed,\\n        uint borrowSpeed\\n    ) external onlyOwner updateDistributionOf(qToken) {\\n        QConstant.DistributionInfo storage dist = distributions[qToken];\\n        dist.supplySpeed = supplySpeed;\\n        dist.borrowSpeed = borrowSpeed;\\n        emit QubitDistributionSpeedUpdated(qToken, supplySpeed, borrowSpeed);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function notifySupplyUpdated(address market, address user)\\n        external\\n        override\\n        nonReentrant\\n        onlyQore\\n        updateDistributionOf(market)\\n    {\\n        QConstant.DistributionInfo storage dist = distributions[market];\\n        QConstant.DistributionAccountInfo storage userInfo = accountDistributions[market][user];\\n\\n        if (userInfo.boostedSupply > 0) {\\n            uint accQubitPerShare = dist.accPerShareSupply.sub(userInfo.accPerShareSupply);\\n            userInfo.accruedQubit = userInfo.accruedQubit.add(accQubitPerShare.mul(userInfo.boostedSupply).div(1e18));\\n        }\\n        userInfo.accPerShareSupply = dist.accPerShareSupply;\\n\\n        uint boostedSupply = _calculateBoostedSupply(market, user);\\n        dist.totalBoostedSupply = dist.totalBoostedSupply.add(boostedSupply).sub(userInfo.boostedSupply);\\n        userInfo.boostedSupply = boostedSupply;\\n    }\\n\\n    function notifyBorrowUpdated(address market, address user)\\n        external\\n        override\\n        nonReentrant\\n        onlyQore\\n        updateDistributionOf(market)\\n    {\\n        QConstant.DistributionInfo storage dist = distributions[market];\\n        QConstant.DistributionAccountInfo storage userInfo = accountDistributions[market][user];\\n\\n        if (userInfo.boostedBorrow > 0) {\\n            uint accQubitPerShare = dist.accPerShareBorrow.sub(userInfo.accPerShareBorrow);\\n            userInfo.accruedQubit = userInfo.accruedQubit.add(accQubitPerShare.mul(userInfo.boostedBorrow).div(1e18));\\n        }\\n        userInfo.accPerShareBorrow = dist.accPerShareBorrow;\\n\\n        uint boostedBorrow = _calculateBoostedBorrow(market, user);\\n        dist.totalBoostedBorrow = dist.totalBoostedBorrow.add(boostedBorrow).sub(userInfo.boostedBorrow);\\n        userInfo.boostedBorrow = boostedBorrow;\\n    }\\n\\n    function notifyTransferred(\\n        address qToken,\\n        address sender,\\n        address receiver\\n    ) external override nonReentrant onlyMarket updateDistributionOf(qToken) {\\n        QConstant.DistributionInfo storage dist = distributions[qToken];\\n        QConstant.DistributionAccountInfo storage senderInfo = accountDistributions[qToken][sender];\\n        QConstant.DistributionAccountInfo storage receiverInfo = accountDistributions[qToken][receiver];\\n\\n        if (senderInfo.boostedSupply > 0) {\\n            uint accQubitPerShare = dist.accPerShareSupply.sub(senderInfo.accPerShareSupply);\\n            senderInfo.accruedQubit = senderInfo.accruedQubit.add(\\n                accQubitPerShare.mul(senderInfo.boostedSupply).div(1e18)\\n            );\\n        }\\n        senderInfo.accPerShareSupply = dist.accPerShareSupply;\\n\\n        if (receiverInfo.boostedSupply > 0) {\\n            uint accQubitPerShare = dist.accPerShareSupply.sub(receiverInfo.accPerShareSupply);\\n            receiverInfo.accruedQubit = receiverInfo.accruedQubit.add(\\n                accQubitPerShare.mul(receiverInfo.boostedSupply).div(1e18)\\n            );\\n        }\\n        receiverInfo.accPerShareSupply = dist.accPerShareSupply;\\n\\n        uint boostedSenderSupply = _calculateBoostedSupply(qToken, sender);\\n        uint boostedReceiverSupply = _calculateBoostedSupply(qToken, receiver);\\n        dist.totalBoostedSupply = dist\\n            .totalBoostedSupply\\n            .add(boostedSenderSupply)\\n            .add(boostedReceiverSupply)\\n            .sub(senderInfo.boostedSupply)\\n            .sub(receiverInfo.boostedSupply);\\n        senderInfo.boostedSupply = boostedSenderSupply;\\n        receiverInfo.boostedSupply = boostedReceiverSupply;\\n    }\\n\\n    function claimQubit(address[] calldata markets, address account) external override onlyQore {\\n        uint amount = 0;\\n        for (uint i = 0; i < markets.length; i++) {\\n            amount = amount.add(_claimQubit(markets[i], account));\\n        }\\n\\n        amount = Math.min(amount, IBEP20(QBT).balanceOf(address(this)));\\n        QBT.safeTransfer(account, amount);\\n        emit QubitClaimed(account, amount);\\n    }\\n\\n    function kick(address user) external override nonReentrant {\\n        require(qubitLocker.scoreOf(user) == 0, \\\"QDistributor: kick not allowed\\\");\\n\\n        address[] memory markets = qore.allMarkets();\\n        for (uint i = 0; i < markets.length; i++) {\\n            address market = markets[i];\\n            _updateSupplyOf(market, user);\\n            _updateBorrowOf(market, user);\\n        }\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _accruedQubit(address market, address user) private view returns (uint) {\\n        QConstant.DistributionInfo memory dist = distributions[market];\\n        QConstant.DistributionAccountInfo memory userInfo = accountDistributions[market][user];\\n\\n        uint amount = userInfo.accruedQubit;\\n        uint accPerShareSupply = dist.accPerShareSupply;\\n        uint accPerShareBorrow = dist.accPerShareBorrow;\\n\\n        uint timeElapsed = block.timestamp > dist.accruedAt ? block.timestamp.sub(dist.accruedAt) : 0;\\n        if (\\n            timeElapsed > 0 ||\\n            (accPerShareSupply != userInfo.accPerShareSupply) ||\\n            (accPerShareBorrow != userInfo.accPerShareBorrow)\\n        ) {\\n            if (dist.totalBoostedSupply > 0) {\\n                accPerShareSupply = accPerShareSupply.add(\\n                    dist.supplySpeed.mul(timeElapsed).mul(1e18).div(dist.totalBoostedSupply)\\n                );\\n\\n                uint pendingQubit = userInfo.boostedSupply.mul(accPerShareSupply.sub(userInfo.accPerShareSupply)).div(\\n                    1e18\\n                );\\n                amount = amount.add(pendingQubit);\\n            }\\n\\n            if (dist.totalBoostedBorrow > 0) {\\n                accPerShareBorrow = accPerShareBorrow.add(\\n                    dist.borrowSpeed.mul(timeElapsed).mul(1e18).div(dist.totalBoostedBorrow)\\n                );\\n\\n                uint pendingQubit = userInfo.boostedBorrow.mul(accPerShareBorrow.sub(userInfo.accPerShareBorrow)).div(\\n                    1e18\\n                );\\n                amount = amount.add(pendingQubit);\\n            }\\n        }\\n        return amount;\\n    }\\n\\n    function _claimQubit(address market, address user) private returns (uint amount) {\\n        bool hasBoostedSupply = accountDistributions[market][user].boostedSupply > 0;\\n        bool hasBoostedBorrow = accountDistributions[market][user].boostedBorrow > 0;\\n        if (hasBoostedSupply) _updateSupplyOf(market, user);\\n        if (hasBoostedBorrow) _updateBorrowOf(market, user);\\n\\n        QConstant.DistributionAccountInfo storage userInfo = accountDistributions[market][user];\\n        amount = amount.add(userInfo.accruedQubit);\\n        userInfo.accruedQubit = 0;\\n\\n        return amount;\\n    }\\n\\n    function _calculateMarketDistributionAPY(address market) private view returns (uint apySupplyQBT, uint apyBorrowQBT) {\\n        // base supply QBT APY == average supply QBT APY * (Total balance / total Boosted balance)\\n        // base supply QBT APY == (qubitRate * 365 days * price Of Qubit) / (Total balance * exchangeRate * price of asset) * (Total balance / Total Boosted balance)\\n        // base supply QBT APY == (qubitRate * 365 days * price Of Qubit) / (Total boosted balance * exchangeRate * price of asset)\\n        uint numerSupply = distributions[market].supplySpeed.mul(365 days).mul(priceCalculator.priceOf(QBT));\\n        uint denomSupply = distributions[market].totalBoostedSupply.mul(IQToken(market).exchangeRate()).mul(priceCalculator.getUnderlyingPrice(market)).div(1e36);\\n        apySupplyQBT = denomSupply > 0 ? numerSupply.div(denomSupply) : 0;\\n\\n        // base borrow QBT APY == average borrow QBT APY * (Total balance / total Boosted balance)\\n        // base borrow QBT APY == (qubitRate * 365 days * price Of Qubit) / (Total balance * exchangeRate * price of asset) * (Total balance / Total Boosted balance)\\n        // base borrow QBT APY == (qubitRate * 365 days * price Of Qubit) / (Total boosted balance * exchangeRate * price of asset)\\n        uint numerBorrow = distributions[market].borrowSpeed.mul(365 days).mul(priceCalculator.priceOf(QBT));\\n        uint denomBorrow = distributions[market].totalBoostedBorrow.mul(IQToken(market).getAccInterestIndex()).mul(priceCalculator.getUnderlyingPrice(market)).div(1e36);\\n        apyBorrowQBT = denomBorrow > 0 ? numerBorrow.div(denomBorrow) : 0;\\n    }\\n\\n    function _calculateAccountDistributionAPY(address market, address account) private view returns (uint apyAccountSupplyQBT, uint apyAccountBorrowQBT) {\\n        if (account == address(0)) return (0, 0);\\n        (uint apySupplyQBT, uint apyBorrowQBT) = _calculateMarketDistributionAPY(market);\\n\\n        // user supply QBT APY == ((qubitRate * 365 days * price Of Qubit) / (Total boosted balance * exchangeRate * price of asset) ) * my boosted balance  / my balance\\n        uint accountSupply = IQToken(market).balanceOf(account);\\n        apyAccountSupplyQBT = accountSupply > 0 ? apySupplyQBT.mul(accountDistributions[market][account].boostedSupply).div(accountSupply) : 0;\\n\\n        // user borrow QBT APY == (qubitRate * 365 days * price Of Qubit) / (Total boosted balance * interestIndex * price of asset) * my boosted balance  / my balance\\n        uint accountBorrow = IQToken(market).borrowBalanceOf(account).mul(1e18).div(IQToken(market).getAccInterestIndex());\\n        apyAccountBorrowQBT = accountBorrow > 0 ? apyBorrowQBT.mul(accountDistributions[market][account].boostedBorrow).div(accountBorrow) : 0;\\n    }\\n\\n\\n    function _calculateBoostedSupply(address market, address user) private view returns (uint) {\\n        uint defaultSupply = IQToken(market).balanceOf(user);\\n        uint boostedSupply = defaultSupply;\\n\\n        uint userScore = qubitLocker.scoreOf(user);\\n        (uint totalScore, ) = qubitLocker.totalScore();\\n        if (userScore > 0 && totalScore > 0) {\\n            uint scoreBoosted = IQToken(market).totalSupply().mul(userScore).div(totalScore).mul(BOOST_PORTION).div(\\n                100\\n            );\\n            boostedSupply = boostedSupply.add(scoreBoosted);\\n        }\\n        return Math.min(boostedSupply, defaultSupply.mul(BOOST_MAX).div(100));\\n    }\\n\\n    function _calculateBoostedBorrow(address market, address user) private view returns (uint) {\\n        uint accInterestIndex = IQToken(market).getAccInterestIndex();\\n        uint defaultBorrow = IQToken(market).borrowBalanceOf(user).mul(1e18).div(accInterestIndex);\\n        uint boostedBorrow = defaultBorrow;\\n\\n        uint userScore = qubitLocker.scoreOf(user);\\n        (uint totalScore, ) = qubitLocker.totalScore();\\n        if (userScore > 0 && totalScore > 0) {\\n            uint totalBorrow = IQToken(market).totalBorrow().mul(1e18).div(accInterestIndex);\\n            uint scoreBoosted = totalBorrow.mul(userScore).div(totalScore).mul(BOOST_PORTION).div(100);\\n            boostedBorrow = boostedBorrow.add(scoreBoosted);\\n        }\\n        return Math.min(boostedBorrow, defaultBorrow.mul(BOOST_MAX).div(100));\\n    }\\n\\n    function _updateSupplyOf(address market, address user) private updateDistributionOf(market) {\\n        QConstant.DistributionInfo storage dist = distributions[market];\\n        QConstant.DistributionAccountInfo storage userInfo = accountDistributions[market][user];\\n\\n        if (userInfo.boostedSupply > 0) {\\n            uint accQubitPerShare = dist.accPerShareSupply.sub(userInfo.accPerShareSupply);\\n            userInfo.accruedQubit = userInfo.accruedQubit.add(accQubitPerShare.mul(userInfo.boostedSupply).div(1e18));\\n        }\\n        userInfo.accPerShareSupply = dist.accPerShareSupply;\\n\\n        uint boostedSupply = _calculateBoostedSupply(market, user);\\n        dist.totalBoostedSupply = dist.totalBoostedSupply.add(boostedSupply).sub(userInfo.boostedSupply);\\n        userInfo.boostedSupply = boostedSupply;\\n    }\\n\\n    function _updateBorrowOf(address market, address user) private updateDistributionOf(market) {\\n        QConstant.DistributionInfo storage dist = distributions[market];\\n        QConstant.DistributionAccountInfo storage userInfo = accountDistributions[market][user];\\n\\n        if (userInfo.boostedBorrow > 0) {\\n            uint accQubitPerShare = dist.accPerShareBorrow.sub(userInfo.accPerShareBorrow);\\n            userInfo.accruedQubit = userInfo.accruedQubit.add(accQubitPerShare.mul(userInfo.boostedBorrow).div(1e18));\\n        }\\n        userInfo.accPerShareBorrow = dist.accPerShareBorrow;\\n\\n        uint boostedBorrow = _calculateBoostedBorrow(market, user);\\n        dist.totalBoostedBorrow = dist.totalBoostedBorrow.add(boostedBorrow).sub(userInfo.boostedBorrow);\\n        userInfo.boostedBorrow = boostedBorrow;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQubitLocker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\ninterface IQubitLocker {\\n    struct CheckPoint {\\n        uint totalWeightedBalance;\\n        uint slope;\\n        uint ts;\\n    }\\n\\n    function totalBalance() external view returns (uint);\\n\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function expiryOf(address account) external view returns (uint);\\n\\n    function availableOf(address account) external view returns (uint);\\n\\n    function totalScore() external view returns (uint score, uint slope);\\n\\n    function scoreOf(address account) external view returns (uint);\\n\\n    function deposit(uint amount, uint unlockTime) external;\\n\\n    function extendLock(uint expiryTime) external;\\n\\n    function withdraw() external;\\n\\n    function depositBehalf(address account, uint amount, uint unlockTime) external;\\n\\n    function withdrawBehalf(address account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/library/WhitelistUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\ncontract WhitelistUpgradeable is OwnableUpgradeable {\\n    mapping(address => bool) private _whitelist;\\n    bool private _disable; // default - false means whitelist feature is working on. if true no more use of whitelist\\n\\n    event Whitelisted(address indexed _address, bool whitelist);\\n    event EnableWhitelist();\\n    event DisableWhitelist();\\n\\n    modifier onlyWhitelisted() {\\n        require(_disable || _whitelist[msg.sender], \\\"Whitelist: caller is not on the whitelist\\\");\\n        _;\\n    }\\n\\n    function __WhitelistUpgradeable_init() internal initializer {\\n        __Ownable_init();\\n    }\\n\\n    function isWhitelist(address _address) public view returns (bool) {\\n        return _whitelist[_address];\\n    }\\n\\n    function setWhitelist(address _address, bool _on) external onlyOwner {\\n        _whitelist[_address] = _on;\\n\\n        emit Whitelisted(_address, _on);\\n    }\\n\\n    function disableWhitelist(bool disable) external onlyOwner {\\n        _disable = disable;\\n        if (disable) {\\n            emit DisableWhitelist();\\n        } else {\\n            emit EnableWhitelist();\\n        }\\n    }\\n\\n    uint[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/staking/QubitReservoir.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\\\";\\nimport \\\"../library/WhitelistUpgradeable.sol\\\";\\nimport \\\"../library/SafeToken.sol\\\";\\n\\ncontract QubitReservoir is WhitelistUpgradeable {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address private constant QBT = 0x17B7163cf1Dbd286E262ddc68b553D899B93f526;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    address public receiver;\\n\\n    uint public startAt;\\n    uint public ratePerSec;\\n    uint public ratePerSec2;\\n    uint public ratePerSec3;\\n    uint public dripped;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize(\\n        address _receiver,\\n        uint _ratePerSec,\\n        uint _ratePerSec2,\\n        uint _ratePerSec3,\\n        uint _startAt\\n    ) external initializer {\\n        __WhitelistUpgradeable_init();\\n\\n        require(_receiver != address(0), \\\"QubitReservoir: invalid receiver\\\");\\n        require(_ratePerSec > 0, \\\"QubitReservoir: invalid rate\\\");\\n\\n        receiver = _receiver;\\n        ratePerSec = _ratePerSec;\\n        ratePerSec2 = _ratePerSec2;\\n        ratePerSec3 = _ratePerSec3;\\n        startAt = _startAt;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function getDripInfo()\\n        external\\n        view\\n        returns (\\n            uint,\\n            uint,\\n            uint\\n        )\\n    {\\n        if (block.timestamp < startAt || block.timestamp.sub(startAt) <= 30 days) {\\n            return (startAt, ratePerSec, dripped);\\n        } else if (30 days < block.timestamp.sub(startAt) && block.timestamp.sub(startAt) <= 60 days) {\\n            return (startAt, ratePerSec2, dripped);\\n        } else {\\n            return (startAt, ratePerSec3, dripped);\\n        }\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function drip() public onlyOwner returns (uint) {\\n        require(block.timestamp >= startAt, \\\"QubitReservoir: not started\\\");\\n\\n        uint balance = IBEP20(QBT).balanceOf(address(this));\\n        uint totalDrip;\\n        if (block.timestamp.sub(startAt) <= 30 days) {\\n            totalDrip = ratePerSec.mul(block.timestamp.sub(startAt));\\n        } else if (block.timestamp.sub(startAt) <= 60 days) {\\n            totalDrip = ratePerSec.mul(30 days);\\n            totalDrip = totalDrip.add(ratePerSec2.mul(block.timestamp.sub(startAt + 30 days)));\\n        } else {\\n            totalDrip = ratePerSec.mul(30 days);\\n            totalDrip = totalDrip.add(ratePerSec2.mul(30 days));\\n            totalDrip = totalDrip.add(ratePerSec3.mul(block.timestamp.sub(startAt + 60 days)));\\n        }\\n\\n        uint amountToDrip = Math.min(balance, totalDrip.sub(dripped));\\n        dripped = dripped.add(amountToDrip);\\n        QBT.safeTransfer(receiver, amountToDrip);\\n        return amountToDrip;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/QTokenBulkTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\\\";\\n\\ncontract QTokenBulkTransfer {\\n    function bulkSend(\\n        address qToken,\\n        uint amount,\\n        address[] memory accounts\\n    ) external {\\n        require(IBEP20(qToken).balanceOf(address(this)) > 0, \\\"no balance\\\");\\n\\n        for (uint i = 0; i < accounts.length; i++) {\\n            IBEP20(qToken).transfer(accounts[i], amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/QubitDevWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\\\";\\nimport \\\"../library/WhitelistUpgradeable.sol\\\";\\nimport \\\"../library/SafeToken.sol\\\";\\nimport \\\"../interfaces/IQubitPool.sol\\\";\\nimport \\\"../interfaces/IQore.sol\\\";\\n\\ncontract QubitDevWallet is WhitelistUpgradeable {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address internal constant QBT = 0x17B7163cf1Dbd286E262ddc68b553D899B93f526;\\n    IQubitPool public constant QubitPool = IQubitPool(0x33F93897e914a7482A262Ef10A94319840EB8D05);\\n    IQore public constant Qore = IQore(0xF70314eb9c7Fe7D88E6af5aa7F898b3A162dcd48);\\n    address internal constant qQBT = 0xcD2CD343CFbe284220677C78A08B1648bFa39865;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() external initializer {\\n        __WhitelistUpgradeable_init();\\n        IBEP20(QBT).approve(address(QubitPool), uint(- 1));\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function deposit(uint _amount) public {\\n        QBT.safeTransferFrom(msg.sender, address(this), _amount);\\n\\n        QubitPool.deposit(_amount);\\n    }\\n\\n    function harvest() public onlyOwner {\\n        uint _before = QBT.balanceOf(address(this));\\n        QubitPool.getReward();\\n        uint amountQBT = QBT.balanceOf(address(this)).sub(_before);\\n\\n        QubitPool.deposit(amountQBT);\\n    }\\n\\n    function withdrawBQBT(uint _amount) public onlyOwner {\\n        QubitPool.withdraw(_amount);\\n        address(QubitPool).safeTransfer(msg.sender, _amount);\\n    }\\n\\n    function approveQBTMarket() public onlyOwner {\\n        IBEP20(QBT).approve(qQBT, uint(- 1));\\n    }\\n\\n    function supply(uint _amount) public {\\n        QBT.safeTransferFrom(msg.sender, address(this), _amount);\\n\\n        Qore.supply(qQBT, _amount);\\n    }\\n\\n    function redeemToken(uint _qAmount) public onlyOwner {\\n        uint uAmountToRedeem = Qore.redeemToken(qQBT, _qAmount);\\n        QBT.safeTransfer(msg.sender, uAmountToRedeem);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQubitPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n  ___                      _   _\\n | _ )_  _ _ _  _ _ _  _  | | | |\\n | _ \\\\ || | ' \\\\| ' \\\\ || | |_| |_|\\n |___/\\\\_,_|_||_|_||_\\\\_, | (_) (_)\\n                    |__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2020 BunnyFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"./IVaultController.sol\\\";\\n\\ninterface IQubitPool is IVaultController {\\n\\n    /* ========== Dashboard ========== */\\n    function balance() external view returns (uint);\\n    function principalOf(address account) external view returns (uint);\\n    function withdrawableBalanceOf(address account) external view returns (uint);\\n    function earned(address account) external view returns (uint);\\n    function priceShare() external view returns (uint);\\n    function depositedAt(address account) external view returns (uint);\\n    function rewardsToken() external view returns (address);\\n\\n    /* ========== Interface ========== */\\n    function deposit(uint _amount) external;\\n    function getReward() external;\\n    function stake(uint _amount) external;\\n    function notifyRewardAmount(uint reward) external;\\n    function withdraw(uint _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/*\\n  ___                      _   _\\n | _ )_  _ _ _  _ _ _  _  | | | |\\n | _ \\\\ || | ' \\\\| ' \\\\ || | |_| |_|\\n |___/\\\\_,_|_||_|_||_\\\\_, | (_) (_)\\n                    |__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2020 BunnyFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\ninterface IVaultController {\\n    function minter() external view returns (address);\\n    function bunnyChef() external view returns (address);\\n    function stakingToken() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/tester/ReentrancyTesterForRedeem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../interfaces/IBEP20.sol\\\";\\n\\n\\ncontract ReentrancyTesterForRedeem {\\n    using SafeMath for uint;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address public constant USDT = 0x55d398326f99059fF775485246999027B3197955;\\n    address public constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n    address public constant BUNNY = 0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51;\\n    address public constant CAKE = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\\n    address public constant BNB = 0x0000000000000000000000000000000000000000;\\n    address public constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public constant qore = 0xF70314eb9c7Fe7D88E6af5aa7F898b3A162dcd48;\\n    address public constant qCAKE = 0xaB9eb4AE93B705b0A74d3419921bBec97F51b264;\\n    address public constant qBNB = 0xbE1B5D17777565D67A5D2793f879aBF59Ae5D351;\\n\\n    /* ========== STATE VARIABLES ========== */\\n    bool public receiveCalled = false;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    constructor() public {}\\n\\n    //    receive() external payable {\\n\\n    //        receiveCalled = true;\\n    //        IQore(qore).redeemToken(qBNB, uint(1).mul(1e18));\\n\\n    //    }\\n    receive() external payable {\\n\\n        receiveCalled = true;\\n        IQore(qore).redeemUnderlying(qBNB, uint(1).mul(1e18));\\n\\n    }\\n\\n    /* ========== FUNCTIONS ========== */\\n\\n    function resetReceiveCalled() external {\\n        receiveCalled = false;\\n    }\\n\\n    function callSupply(address qToken, uint uAmount) external payable {\\n        IQore(qore).supply{ value: msg.value }(qToken, uAmount);\\n    }\\n\\n    function callRepayBorrowBehalf(\\n        address qToken,\\n        address borrower,\\n        uint amount\\n    ) external payable {\\n        IQore(qore).repayBorrowBehalf{ value: msg.value }(qToken, borrower, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.4.0;\\n\\ninterface IBEP20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint);\\n\\n    /**\\n     * @dev Returns the token decimals.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the token symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the bep token owner.\\n     */\\n    function getOwner() external view returns (address);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address _owner, address spender) external view returns (uint);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\"\r\n    },\r\n    \"contracts/tester/ReentrancyTesterForLiquidateBorrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../interfaces/IBEP20.sol\\\";\\n\\n\\ncontract ReentrancyTesterForLiquidateBorrow {\\n    using SafeMath for uint;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address public constant USDT = 0x55d398326f99059fF775485246999027B3197955;\\n    address public constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n    address public constant BUNNY = 0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51;\\n    address public constant CAKE = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\\n    address public constant BNB = 0x0000000000000000000000000000000000000000;\\n    address public constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public constant qore = 0xF70314eb9c7Fe7D88E6af5aa7F898b3A162dcd48;\\n    address public constant qCAKE = 0xaB9eb4AE93B705b0A74d3419921bBec97F51b264;\\n    address public constant qBNB = 0xbE1B5D17777565D67A5D2793f879aBF59Ae5D351;\\n\\n    /* ========== STATE VARIABLES ========== */\\n    bool public receiveCalled = false;\\n\\n    address public liquidation_borrower;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    constructor(address _borrower) public {\\n        liquidation_borrower = _borrower;\\n    }\\n\\n    receive() external payable {\\n\\n        receiveCalled = true;\\n        IQore(qore).liquidateBorrow(qBNB, qBNB, liquidation_borrower, uint(1).mul(1e18));\\n\\n    }\\n\\n    /* ========== FUNCTIONS ========== */\\n\\n    function resetReceiveCalled() external {\\n        receiveCalled = false;\\n    }\\n\\n    function callSupply(address qToken, uint uAmount) external payable {\\n        IQore(qore).supply{ value: msg.value }(qToken, uAmount);\\n    }\\n\\n    function callRepayBorrowBehalf(\\n        address qToken,\\n        address borrower,\\n        uint amount\\n    ) external payable {\\n        IQore(qore).repayBorrowBehalf{ value: msg.value }(qToken, borrower, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/ReentrancyTesterForBorrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../interfaces/IBEP20.sol\\\";\\n\\n\\ncontract ReentrancyTesterForBorrow {\\n    using SafeMath for uint;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address public constant USDT = 0x55d398326f99059fF775485246999027B3197955;\\n    address public constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n    address public constant BUNNY = 0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51;\\n    address public constant CAKE = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\\n    address public constant BNB = 0x0000000000000000000000000000000000000000;\\n    address public constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public constant qore = 0xF70314eb9c7Fe7D88E6af5aa7F898b3A162dcd48;\\n    address public constant qCAKE = 0xaB9eb4AE93B705b0A74d3419921bBec97F51b264;\\n    address public constant qBNB = 0xbE1B5D17777565D67A5D2793f879aBF59Ae5D351;\\n\\n    /* ========== STATE VARIABLES ========== */\\n    bool public receiveCalled = false;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    constructor() public {}\\n\\n    receive() external payable {\\n\\n        receiveCalled = true;\\n        IQore(qore).borrow(qBNB, uint(1).mul(1e18));\\n\\n    }\\n\\n    /* ========== FUNCTIONS ========== */\\n\\n    function resetReceiveCalled() external {\\n        receiveCalled = false;\\n    }\\n\\n    function callSupply(address qToken, uint uAmount) external payable {\\n        IQore(qore).supply{ value: msg.value }(qToken, uAmount);\\n    }\\n\\n    function callRepayBorrowBehalf(\\n        address qToken,\\n        address borrower,\\n        uint amount\\n    ) external payable {\\n        IQore(qore).repayBorrowBehalf{ value: msg.value }(qToken, borrower, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/ReentrancyTester2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../interfaces/IBEP20.sol\\\";\\n\\n\\ncontract ReentrancyTester2 {\\n    using SafeMath for uint;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address public constant USDT = 0x55d398326f99059fF775485246999027B3197955;\\n    address public constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n    address public constant BUNNY = 0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51;\\n    address public constant CAKE = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\\n    address public constant BNB = 0x0000000000000000000000000000000000000000;\\n    address public constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public constant qore = 0xF70314eb9c7Fe7D88E6af5aa7F898b3A162dcd48;\\n    address public constant qCAKE = 0xaB9eb4AE93B705b0A74d3419921bBec97F51b264;\\n    address public constant qBNB = 0xbE1B5D17777565D67A5D2793f879aBF59Ae5D351;\\n\\n    /* ========== STATE VARIABLES ========== */\\n    bool public receiveCalled = false;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    constructor() public {}\\n\\n    receive() external payable {\\n\\n        receiveCalled = true;\\n        IQore(qore).borrow(qBNB, uint(1).mul(1e18));\\n    }\\n\\n    /* ========== FUNCTIONS ========== */\\n\\n    function resetReceiveCalled() external {\\n        receiveCalled = false;\\n    }\\n\\n    function deposit() external payable {}\\n\\n    function callLiquidateBorrow(\\n        address qTokenBorrowed,\\n        address qTokenCollateral,\\n        address borrower,\\n        uint amount\\n    ) external payable {\\n        IQore(qore).liquidateBorrow{ value: msg.value }(qTokenBorrowed, qTokenCollateral, borrower, amount);\\n    }\\n\\n    function callSupply(address qToken, uint uAmount) external payable {\\n        IQore(qore).supply{ value: msg.value }(qToken, uAmount);\\n    }\\n\\n    function callBorrow(address qToken, uint amount) external {\\n        IQore(qore).borrow(qToken, amount);\\n    }\\n\\n    function callRepayBorrow(address qToken, uint amount) external payable {\\n        IQore(qore).repayBorrow{ value: msg.value }(qToken, amount);\\n    }\\n\\n    function callRepayBorrowBehalf(\\n        address qToken,\\n        address borrower,\\n        uint amount\\n    ) external payable {\\n        IQore(qore).repayBorrowBehalf{ value: msg.value }(qToken, borrower, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/ReentrancyTester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../interfaces/IBEP20.sol\\\";\\n\\n\\ncontract ReentrancyTester {\\n    using SafeMath for uint;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address public constant USDT = 0x55d398326f99059fF775485246999027B3197955;\\n    address public constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n    address public constant BUNNY = 0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51;\\n    address public constant CAKE = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\\n    address public constant BNB = 0x0000000000000000000000000000000000000000;\\n    address public constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public constant qore = 0xF70314eb9c7Fe7D88E6af5aa7F898b3A162dcd48;\\n    address public constant qCAKE = 0xaB9eb4AE93B705b0A74d3419921bBec97F51b264;\\n\\n    /* ========== STATE VARIABLES ========== */\\n    bool public receiveCalled = false;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    constructor() public {}\\n\\n    receive() external payable {\\n\\n        receiveCalled = true;\\n    }\\n\\n    /* ========== FUNCTIONS ========== */\\n\\n    function resetReceiveCalled() external {\\n        receiveCalled = false;\\n    }\\n\\n    function deposit() external payable {}\\n\\n    function callLiquidateBorrow(\\n        address qTokenBorrowed,\\n        address qTokenCollateral,\\n        address borrower,\\n        uint amount\\n    ) external payable {\\n        IQore(qore).liquidateBorrow{ value: msg.value }(qTokenBorrowed, qTokenCollateral, borrower, amount);\\n    }\\n\\n    function callSupply(address qToken, uint uAmount) external payable {\\n        IQore(qore).supply{ value: msg.value }(qToken, uAmount);\\n    }\\n\\n    function callBorrow(address qToken, uint amount) external {\\n        IQore(qore).borrow(qToken, amount);\\n    }\\n\\n    function callRepayBorrow(address qToken, uint amount) external payable {\\n        IQore(qore).repayBorrow{ value: msg.value }(qToken, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/QoreTester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../interfaces/IQToken.sol\\\";\\nimport \\\"../interfaces/IQValidator.sol\\\";\\nimport \\\"../interfaces/IFlashLoanReceiver.sol\\\";\\n\\nimport \\\"../QoreAdmin.sol\\\";\\n\\ncontract QoreTester is QoreAdmin {\\n    using SafeMath for uint;\\n\\n    function notifySupplyUpdated(address market, address user) external {\\n        qDistributor.notifySupplyUpdated(market, user);\\n    }\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address internal constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    uint public constant FLASHLOAN_FEE = 5e14;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(address => address[]) public marketListOfUsers; // (account => qTokenAddress[])\\n    mapping(address => mapping(address => bool)) public usersOfMarket; // (qTokenAddress => (account => joined))\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() external initializer {\\n        __Qore_init();\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyMemberOfMarket(address qToken) {\\n        require(usersOfMarket[qToken][msg.sender], \\\"Qore: must enter market\\\");\\n        _;\\n    }\\n\\n    modifier onlyMarket() {\\n        bool fromMarket = false;\\n        for (uint i = 0; i < markets.length; i++) {\\n            if (msg.sender == markets[i]) {\\n                fromMarket = true;\\n                break;\\n            }\\n        }\\n        require(fromMarket == true, \\\"Qore: caller should be market\\\");\\n        _;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function allMarkets() external view override returns (address[] memory) {\\n        return markets;\\n    }\\n\\n    function marketInfoOf(address qToken) external view override returns (QConstant.MarketInfo memory) {\\n        return marketInfos[qToken];\\n    }\\n\\n    function marketListOf(address account) external view override returns (address[] memory) {\\n        return marketListOfUsers[account];\\n    }\\n\\n    function checkMembership(address account, address qToken) external view override returns (bool) {\\n        return usersOfMarket[qToken][account];\\n    }\\n\\n    function accountLiquidityOf(address account) external view override returns (uint collateralInUSD, uint supplyInUSD, uint borrowInUSD) {\\n        return IQValidator(qValidator).getAccountLiquidity(account);\\n    }\\n\\n    function distributionInfoOf(address market) external view override returns (QConstant.DistributionInfo memory) {\\n        return IQDistributor(qDistributor).distributionInfoOf(market);\\n    }\\n\\n    function accountDistributionInfoOf(address market, address account) external view override returns (QConstant.DistributionAccountInfo memory) {\\n        return IQDistributor(qDistributor).accountDistributionInfoOf(market, account);\\n    }\\n\\n    function apyDistributionOf(address market, address account) external view override returns (QConstant.DistributionAPY memory) {\\n        return IQDistributor(qDistributor).apyDistributionOf(market, account);\\n    }\\n\\n    function distributionSpeedOf(address qToken) external view override returns (uint supplySpeed, uint borrowSpeed) {\\n        QConstant.DistributionInfo memory distribution = IQDistributor(qDistributor).distributionInfoOf(qToken);\\n        return (distribution.supplySpeed, distribution.borrowSpeed);\\n    }\\n\\n    function boostedRatioOf(address market, address account) external view override returns (uint boostedSupplyRatio, uint boostedBorrowRatio) {\\n        return IQDistributor(qDistributor).boostedRatioOf(market, account);\\n    }\\n\\n    function accruedQubit(address account) external view override returns (uint) {\\n        return IQDistributor(qDistributor).accruedQubit(markets, account);\\n    }\\n\\n    function accruedQubit(address market, address account) external view override returns (uint) {\\n        address[] memory _markets = new address[](1);\\n        _markets[0] = market;\\n        return IQDistributor(qDistributor).accruedQubit(_markets, account);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function enterMarkets(address[] memory qTokens) public override {\\n        for (uint i = 0; i < qTokens.length; i++) {\\n            _enterMarket(payable(qTokens[i]), msg.sender);\\n        }\\n    }\\n\\n    function exitMarket(address qToken) external override onlyListedMarket(qToken) onlyMemberOfMarket(qToken) {\\n        QConstant.AccountSnapshot memory snapshot = IQToken(qToken).accruedAccountSnapshot(msg.sender);\\n        require(snapshot.borrowBalance == 0, \\\"Qore: borrow balance must be zero\\\");\\n        require(\\n            IQValidator(qValidator).redeemAllowed(qToken, msg.sender, snapshot.qTokenBalance),\\n            \\\"Qore: cannot redeem\\\"\\n        );\\n\\n        delete usersOfMarket[qToken][msg.sender];\\n        _removeUserMarket(qToken, msg.sender);\\n        emit MarketExited(qToken, msg.sender);\\n    }\\n\\n    function supply(address qToken, uint uAmount) external payable override onlyListedMarket(qToken) returns (uint) {\\n        uAmount = IQToken(qToken).underlying() == address(WBNB) ? msg.value : uAmount;\\n\\n        uint qAmount = IQToken(qToken).supply{ value: msg.value }(msg.sender, uAmount);\\n        qDistributor.notifySupplyUpdated(qToken, msg.sender);\\n\\n        return qAmount;\\n    }\\n\\n    function redeemToken(address qToken, uint qAmount) external override onlyListedMarket(qToken) returns (uint) {\\n        uint uAmountRedeem = IQToken(qToken).redeemToken(msg.sender, qAmount);\\n        qDistributor.notifySupplyUpdated(qToken, msg.sender);\\n\\n        return uAmountRedeem;\\n    }\\n\\n    function redeemUnderlying(address qToken, uint uAmount) external override onlyListedMarket(qToken) returns (uint) {\\n        uint uAmountRedeem = IQToken(qToken).redeemUnderlying(msg.sender, uAmount);\\n        qDistributor.notifySupplyUpdated(qToken, msg.sender);\\n\\n        return uAmountRedeem;\\n    }\\n\\n    function borrow(address qToken, uint amount) external override onlyListedMarket(qToken) {\\n        _enterMarket(qToken, msg.sender);\\n        require(IQValidator(qValidator).borrowAllowed(qToken, msg.sender, amount), \\\"Qore: cannot borrow\\\");\\n\\n        IQToken(payable(qToken)).borrow(msg.sender, amount);\\n        qDistributor.notifyBorrowUpdated(qToken, msg.sender);\\n    }\\n\\n    function repayBorrow(address qToken, uint amount) external payable override onlyListedMarket(qToken) {\\n        IQToken(payable(qToken)).repayBorrow{ value: msg.value }(msg.sender, amount);\\n        qDistributor.notifyBorrowUpdated(qToken, msg.sender);\\n    }\\n\\n    function repayBorrowBehalf(\\n        address qToken,\\n        address borrower,\\n        uint amount\\n    ) external payable override onlyListedMarket(qToken) {\\n        IQToken(payable(qToken)).repayBorrowBehalf{ value: msg.value }(msg.sender, borrower, amount);\\n        qDistributor.notifyBorrowUpdated(qToken, borrower);\\n    }\\n\\n    function liquidateBorrow(\\n        address qTokenBorrowed,\\n        address qTokenCollateral,\\n        address borrower,\\n        uint amount\\n    ) external payable override nonReentrant {\\n        amount = IQToken(qTokenBorrowed).underlying() == address(WBNB) ? msg.value : amount;\\n        require(marketInfos[qTokenBorrowed].isListed && marketInfos[qTokenCollateral].isListed, \\\"Qore: invalid market\\\");\\n        require(usersOfMarket[qTokenCollateral][borrower], \\\"Qore: not a collateral\\\");\\n        require(marketInfos[qTokenCollateral].collateralFactor > 0, \\\"Qore: not a collateral\\\");\\n        require(\\n            IQValidator(qValidator).liquidateAllowed(qTokenBorrowed, borrower, amount, closeFactor),\\n            \\\"Qore: cannot liquidate borrow\\\"\\n        );\\n\\n        uint qAmountToSeize = IQToken(qTokenBorrowed).liquidateBorrow{ value: msg.value }(\\n            qTokenCollateral,\\n            msg.sender,\\n            borrower,\\n            amount\\n        );\\n        IQToken(qTokenCollateral).seize(msg.sender, borrower, qAmountToSeize);\\n        qDistributor.notifyTransferred(qTokenCollateral, borrower, msg.sender);\\n        qDistributor.notifyBorrowUpdated(qTokenBorrowed, borrower);\\n    }\\n\\n    function claimQubit() external override nonReentrant {\\n        qDistributor.claimQubit(markets, msg.sender);\\n    }\\n\\n    function claimQubit(address market) external override nonReentrant {\\n        address[] memory _markets = new address[](1);\\n        _markets[0] = market;\\n        qDistributor.claimQubit(_markets, msg.sender);\\n    }\\n\\n    function transferTokens(address spender, address src, address dst, uint amount) external override nonReentrant onlyMarket {\\n        IQToken(msg.sender).transferTokensInternal(spender, src, dst, amount);\\n        qDistributor.notifyTransferred(msg.sender, src, dst);\\n    }\\n\\n\\n    /* ========== RESTRICTED FUNCTION FOR WHITELIST ========== */\\n\\n    function supplyAndBorrowBehalf(address account, address supplyMarket, uint supplyAmount, address borrowMarket, uint borrowAmount)\\n    external\\n    payable\\n    override\\n    onlyListedMarket(supplyMarket)\\n    onlyListedMarket(borrowMarket)\\n    onlyWhitelisted\\n    nonReentrant\\n    returns (uint)\\n    {\\n        address underlying = IQToken(supplyMarket).underlying();\\n        uint uAmount = underlying == address(WBNB) ? msg.value : supplyAmount;\\n\\n        uint qAmount = IQToken(supplyMarket).supplyBehalf{ value: msg.value }(msg.sender, account, uAmount);\\n\\n        _enterMarket(supplyMarket, account);\\n\\n        require(_borrowAllowed(supplyMarket, supplyAmount, borrowMarket, borrowAmount), \\\"Qore: cannot borrow\\\");\\n        IQToken(borrowMarket).borrow(account, borrowAmount);\\n\\n        qDistributor.notifySupplyUpdated(supplyMarket, account);\\n        qDistributor.notifyBorrowUpdated(borrowMarket, account);\\n        return qAmount;\\n    }\\n\\n    function supplyAndBorrowBNB(address account, address supplyMarket, uint supplyAmount, uint borrowAmount)\\n    external\\n    payable\\n    override\\n    onlyListedMarket(supplyMarket)\\n    onlyWhitelisted\\n    nonReentrant\\n    returns (uint)\\n    {\\n        require(borrowAmount <= 5e16, \\\"exceed maximum amount\\\");\\n        address underlying = IQToken(supplyMarket).underlying();\\n        uint uAmount = underlying == address(WBNB) ? msg.value : supplyAmount;\\n        uint qAmount = IQToken(supplyMarket).supplyBehalf{ value: msg.value }(msg.sender, account, uAmount);\\n\\n        _enterMarket(supplyMarket, account);\\n\\n        address qBNB = 0xbE1B5D17777565D67A5D2793f879aBF59Ae5D351;\\n        _enterMarket(qBNB, account);\\n\\n        require(_borrowAllowed(supplyMarket, supplyAmount, qBNB, borrowAmount), \\\"Qore: cannot borrow\\\");\\n        IQToken(qBNB).borrow(account, borrowAmount); // borrow 0.05 BNB\\n        // no reward update to reduce gasfee\\n        // qDistributor.notifySupplyUpdated(supplyMarket, account);\\n        // qDistributor.notifyBorrowUpdated(0xbE1B5D17777565D67A5D2793f879aBF59Ae5D351, account);\\n\\n        return qAmount;\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _enterMarket(address qToken, address _account) internal onlyListedMarket(qToken) {\\n        if (!usersOfMarket[qToken][_account]) {\\n            usersOfMarket[qToken][_account] = true;\\n            marketListOfUsers[_account].push(qToken);\\n            emit MarketEntered(qToken, _account);\\n        }\\n    }\\n\\n    function _removeUserMarket(address qTokenToExit, address _account) private {\\n        require(marketListOfUsers[_account].length > 0, \\\"Qore: cannot pop user market\\\");\\n\\n        address[] memory updatedMarkets = new address[](marketListOfUsers[_account].length - 1);\\n        uint counter = 0;\\n        for (uint i = 0; i < marketListOfUsers[_account].length; i++) {\\n            if (marketListOfUsers[_account][i] != qTokenToExit) {\\n                updatedMarkets[counter++] = marketListOfUsers[_account][i];\\n            }\\n        }\\n        marketListOfUsers[_account] = updatedMarkets;\\n    }\\n\\n    function _borrowAllowed(address supplyMarket, uint supplyAmount, address borrowMarket, uint borrowAmount) internal view returns (bool){\\n        // Borrow cap of 0 corresponds to unlimited borrowing\\n        uint borrowCap = marketInfos[borrowMarket].borrowCap;\\n        if (borrowCap != 0) {\\n            uint totalBorrows = IQToken(payable(borrowMarket)).totalBorrow();\\n            uint nextTotalBorrows = totalBorrows.add(borrowAmount);\\n            require(nextTotalBorrows < borrowCap, \\\"Qore: market borrow cap reached\\\");\\n        }\\n\\n        address[] memory markets = new address[](2);\\n        markets[0] = supplyMarket;\\n        markets[1] = borrowMarket;\\n        uint[] memory prices = priceCalculator.getUnderlyingPrices(markets);\\n        uint collateralValueInUSD = prices[0].mul(supplyAmount).mul(marketInfos[supplyMarket].collateralFactor).div(1e36);\\n        uint borrowValueInUSD = prices[1].mul(borrowAmount).div(1e18);\\n\\n        return collateralValueInUSD >= borrowValueInUSD;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFlashLoanReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\n\\ninterface IFlashLoanReceiver {\\n    function executeOperation(\\n        address[] calldata markets,\\n        uint256[] calldata amounts,\\n        uint256[] calldata fees,\\n        address initiator,\\n        bytes calldata params\\n    ) external returns (bool);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/QoreAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"./interfaces/IQore.sol\\\";\\nimport \\\"./interfaces/IQDistributor.sol\\\";\\nimport \\\"./interfaces/IPriceCalculator.sol\\\";\\nimport \\\"./library/WhitelistUpgradeable.sol\\\";\\nimport { QConstant } from \\\"./library/QConstant.sol\\\";\\nimport \\\"./interfaces/IQToken.sol\\\";\\n\\nabstract contract QoreAdmin is IQore, WhitelistUpgradeable, ReentrancyGuardUpgradeable {\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    IPriceCalculator public constant priceCalculator = IPriceCalculator(0x20E5E35ba29dC3B540a1aee781D0814D5c77Bce6);\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    address public keeper;\\n    address public override qValidator;\\n    IQDistributor public qDistributor;\\n\\n    address[] public markets; // qTokenAddress[]\\n    mapping(address => QConstant.MarketInfo) public marketInfos; // (qTokenAddress => MarketInfo)\\n\\n    uint public override closeFactor;\\n    uint public override liquidationIncentive;\\n\\n    /* ========== Event ========== */\\n\\n    event MarketListed(address qToken);\\n    event MarketEntered(address qToken, address account);\\n    event MarketExited(address qToken, address account);\\n\\n    event CloseFactorUpdated(uint newCloseFactor);\\n    event CollateralFactorUpdated(address qToken, uint newCollateralFactor);\\n    event LiquidationIncentiveUpdated(uint newLiquidationIncentive);\\n    event BorrowCapUpdated(address indexed qToken, uint newBorrowCap);\\n    event KeeperUpdated(address newKeeper);\\n    event QValidatorUpdated(address newQValidator);\\n    event QDistributorUpdated(address newQDistributor);\\n    event FlashLoan(address indexed target,\\n        address indexed initiator,\\n        address indexed asset,\\n        uint amount,\\n        uint premium);\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyKeeper() {\\n        require(msg.sender == keeper || msg.sender == owner(), \\\"Qore: caller is not the owner or keeper\\\");\\n        _;\\n    }\\n\\n    modifier onlyListedMarket(address qToken) {\\n        require(marketInfos[qToken].isListed, \\\"Qore: invalid market\\\");\\n        _;\\n    }\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function __Qore_init() internal initializer {\\n        __WhitelistUpgradeable_init();\\n        __ReentrancyGuard_init();\\n\\n        closeFactor = 5e17;\\n        liquidationIncentive = 11e17;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setKeeper(address _keeper) external onlyKeeper {\\n        require(_keeper != address(0), \\\"Qore: invalid keeper address\\\");\\n        keeper = _keeper;\\n        emit KeeperUpdated(_keeper);\\n    }\\n\\n    function setQValidator(address _qValidator) external onlyKeeper {\\n        require(_qValidator != address(0), \\\"Qore: invalid qValidator address\\\");\\n        qValidator = _qValidator;\\n        emit QValidatorUpdated(_qValidator);\\n    }\\n\\n    function setQDistributor(address _qDistributor) external onlyKeeper {\\n        require(_qDistributor != address(0), \\\"Qore: invalid qDistributor address\\\");\\n        qDistributor = IQDistributor(_qDistributor);\\n        emit QDistributorUpdated(_qDistributor);\\n    }\\n\\n    function setCloseFactor(uint newCloseFactor) external onlyKeeper {\\n        require(\\n            newCloseFactor >= QConstant.CLOSE_FACTOR_MIN && newCloseFactor <= QConstant.CLOSE_FACTOR_MAX,\\n            \\\"Qore: invalid close factor\\\"\\n        );\\n        closeFactor = newCloseFactor;\\n        emit CloseFactorUpdated(newCloseFactor);\\n    }\\n\\n    function setCollateralFactor(address qToken, uint newCollateralFactor)\\n        external\\n        onlyKeeper\\n        onlyListedMarket(qToken)\\n    {\\n        require(newCollateralFactor <= QConstant.COLLATERAL_FACTOR_MAX, \\\"Qore: invalid collateral factor\\\");\\n        if (newCollateralFactor != 0 && priceCalculator.getUnderlyingPrice(qToken) == 0) {\\n            revert(\\\"Qore: invalid underlying price\\\");\\n        }\\n\\n        marketInfos[qToken].collateralFactor = newCollateralFactor;\\n        emit CollateralFactorUpdated(qToken, newCollateralFactor);\\n    }\\n\\n    function setLiquidationIncentive(uint newLiquidationIncentive) external onlyKeeper {\\n        liquidationIncentive = newLiquidationIncentive;\\n        emit LiquidationIncentiveUpdated(newLiquidationIncentive);\\n    }\\n\\n    function setMarketBorrowCaps(address[] calldata qTokens, uint[] calldata newBorrowCaps) external onlyKeeper {\\n        require(qTokens.length != 0 && qTokens.length == newBorrowCaps.length, \\\"Qore: invalid data\\\");\\n\\n        for (uint i = 0; i < qTokens.length; i++) {\\n            marketInfos[qTokens[i]].borrowCap = newBorrowCaps[i];\\n            emit BorrowCapUpdated(qTokens[i], newBorrowCaps[i]);\\n        }\\n    }\\n\\n    function listMarket(\\n        address payable qToken,\\n        uint borrowCap,\\n        uint collateralFactor\\n    ) external onlyKeeper {\\n        require(!marketInfos[qToken].isListed, \\\"Qore: already listed market\\\");\\n        for (uint i = 0; i < markets.length; i++) {\\n            require(markets[i] != qToken, \\\"Qore: already listed market\\\");\\n        }\\n\\n        marketInfos[qToken] = QConstant.MarketInfo({\\n            isListed: true,\\n            borrowCap: borrowCap,\\n            collateralFactor: collateralFactor\\n        });\\n        markets.push(qToken);\\n        emit MarketListed(qToken);\\n    }\\n\\n    function removeMarket(address payable qToken) external onlyKeeper {\\n        require(marketInfos[qToken].isListed, \\\"Qore: unlisted market\\\");\\n        require(IQToken(qToken).totalSupply() == 0 && IQToken(qToken).totalBorrow() == 0, \\\"Qore: cannot remove market\\\");\\n\\n        uint length = markets.length;\\n        for (uint i = 0; i < length; i++) {\\n            if (markets[i] == qToken) {\\n                markets[i] = markets[length - 1];\\n                markets.pop();\\n                delete marketInfos[qToken];\\n                break;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/SimplePriceCalculatorTester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"../interfaces/IQToken.sol\\\";\\n\\n\\n\\ncontract SimplePriceCalculatorTester {\\n    address public constant USDT = 0x55d398326f99059fF775485246999027B3197955;\\n    address public constant USDC = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;\\n    address public constant DAI = 0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3;\\n    address public constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n    address public constant BUNNY = 0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51;\\n    address public constant CAKE = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\\n    address public constant BNB = 0x0000000000000000000000000000000000000000;\\n    address public constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public constant ETH = 0x2170Ed0880ac9A755fd29B2688956BD959F933F8;\\n    address public constant BTC = 0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c;\\n    address public constant MDX = 0x9C65AB58d8d978DB963e63f2bfB7121627e3a739;\\n\\n    uint public priceBunny;\\n    uint public priceCake;\\n    uint public priceBNB;\\n    uint public priceETH;\\n    uint public priceBTC;\\n    uint public priceMDX;\\n\\n    constructor() public {\\n        priceBunny = 20e18;\\n        priceCake = 15e18;\\n        priceBNB = 400e18;\\n        priceETH = 3000e18;\\n        priceBTC = 40000e18;\\n        priceMDX = 142e16;\\n    }\\n\\n    function setUnderlyingPrice(address qTokenAddress, uint price) public {\\n        IQToken qToken = IQToken(qTokenAddress);\\n        address addr = qToken.underlying();\\n        if (addr == BUNNY) {\\n            priceBunny = price;\\n        } else if (addr == CAKE) {\\n            priceCake = price;\\n        } else if (addr == BNB || addr == WBNB) {\\n            priceBNB = price;\\n        } else if (addr == ETH) {\\n            priceETH = price;\\n        } else if (addr == BTC) {\\n            priceBTC = price;\\n        } else if (addr == MDX) {\\n            priceMDX = price;\\n        }\\n    }\\n\\n    function getUnderlyingPrice(address qTokenAddress) public view returns (uint) {\\n        IQToken qToken = IQToken(qTokenAddress);\\n        address addr = qToken.underlying();\\n        if (addr == BUNNY) {\\n            return priceBunny;\\n        } else if (addr == CAKE) {\\n            return priceCake;\\n        } else if (addr == BUSD) {\\n            return 1e18;\\n        } else if (addr == USDT || addr == USDC || addr == DAI) {\\n            return 1e18;\\n        } else if (addr == ETH) {\\n            return priceETH;\\n        } else if (addr == BTC) {\\n            return priceBTC;\\n        } else if (addr == MDX) {\\n            return priceMDX;\\n        } else if (addr == BNB || addr == WBNB) {\\n            return priceBNB;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function getUnderlyingPrices(address[] memory assets) public view returns (uint[] memory) {\\n        uint[] memory returnValue = new uint[](assets.length);\\n        for (uint i = 0; i < assets.length; i++) {\\n            IQToken qToken = IQToken(payable(assets[i]));\\n            address addr = qToken.underlying();\\n            if (addr == BUNNY) {\\n                returnValue[i] = priceBunny;\\n            } else if (addr == CAKE) {\\n                returnValue[i] = priceCake;\\n            } else if (addr == BUSD || addr == USDC || addr == DAI) {\\n                returnValue[i] = 1e18;\\n            } else if (addr == USDT) {\\n                returnValue[i] = 1e18;\\n            } else if (addr == BNB || addr == WBNB) {\\n                returnValue[i] = priceBNB;\\n            } else if (addr == ETH) {\\n                returnValue[i] = priceETH;\\n            } else if (addr == BTC) {\\n                returnValue[i] = priceBTC;\\n            } else if (addr == MDX) {\\n                returnValue[i] = priceMDX;\\n            } else {\\n                returnValue[i] = 0;\\n            }\\n        }\\n        return returnValue;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/QTokenTransferTester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IQToken.sol\\\";\\nimport \\\"../interfaces/IBEP20.sol\\\";\\n\\n\\ncontract QTokenTransferTester {\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address public constant USDT = 0x55d398326f99059fF775485246999027B3197955;\\n    address public constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n    address public constant BUNNY = 0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51;\\n    address public constant CAKE = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\\n    address public constant BNB = 0x0000000000000000000000000000000000000000;\\n    address public constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public constant qore = 0xF70314eb9c7Fe7D88E6af5aa7F898b3A162dcd48;\\n    address public constant qCAKE = 0xaB9eb4AE93B705b0A74d3419921bBec97F51b264;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    constructor() public {}\\n\\n    function transfer(\\n        address qToken,\\n        address sender,\\n        address receiver,\\n        uint amount\\n    ) external {\\n        IQToken(qToken).transferFrom(sender, receiver, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/FlashLoanReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/IBEP20.sol\\\";\\nimport \\\"../interfaces/IFlashLoanReceiver.sol\\\";\\nimport \\\"../interfaces/IQToken.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../library/SafeToken.sol\\\";\\n\\n\\ncontract FlashLoanReceiver is IFlashLoanReceiver {\\n    using SafeMath for uint;\\n\\n    address private constant qBNB = 0xbE1B5D17777565D67A5D2793f879aBF59Ae5D351;\\n    address private constant qBTC = 0xd055D32E50C57B413F7c2a4A052faF6933eA7927;\\n    address private constant qETH = 0xb4b77834C73E9f66de57e6584796b034D41Ce39A;\\n    address private constant qUSDC = 0x1dd6E079CF9a82c91DaF3D8497B27430259d32C2;\\n    address private constant qUSDT = 0x99309d2e7265528dC7C3067004cC4A90d37b7CC3;\\n    address private constant qDAI = 0x474010701715658fC8004f51860c90eEF4584D2B;\\n    address private constant qBUSD = 0xa3A155E76175920A40d2c8c765cbCB1148aeB9D1;\\n    address private constant qCAKE = 0xaB9eb4AE93B705b0A74d3419921bBec97F51b264;\\n    address private constant qQBT = 0xcD2CD343CFbe284220677C78A08B1648bFa39865;\\n    address private constant qMDX = 0xFF858dB0d6aA9D3fCA13F6341a1693BE4416A550;\\n\\n    address private constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address private constant BTC = 0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c;\\n    address private constant ETH = 0x2170Ed0880ac9A755fd29B2688956BD959F933F8;\\n    address private constant DAI = 0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3;  // BUSD pair\\n    address private constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n    address private constant USDT = 0x55d398326f99059fF775485246999027B3197955;\\n    address private constant USDC = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d; // BUSD pair\\n    address private constant CAKE = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\\n    address private constant QBT = 0x17B7163cf1Dbd286E262ddc68b553D899B93f526;\\n    address private constant MDX = 0x9C65AB58d8d978DB963e63f2bfB7121627e3a739;\\n\\n    address private constant Qore = 0xF70314eb9c7Fe7D88E6af5aa7F898b3A162dcd48;\\n\\n    constructor() public {\\n        for (uint i = 0; i < underlyingTokens().length; i++) {\\n            address underlying = underlyingTokens()[i];\\n            IBEP20(underlying).approve(Qore, uint(- 1));\\n            IBEP20(underlying).approve(qTokens()[i], uint(- 1));\\n        }\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function underlyingTokens() public pure returns (address[10] memory) {\\n        return [WBNB, BTC, ETH, DAI, USDC, BUSD, USDT, CAKE, QBT, MDX];\\n    }\\n\\n    function qTokens() public pure returns (address[10] memory) {\\n        return [qBNB, qBTC, qETH, qDAI, qUSDC, qBUSD, qUSDT, qCAKE, qQBT, qMDX];\\n    }\\n\\n    receive() external payable {\\n\\n    }\\n\\n    /* ========== Qubit Flashloan Callback FUNCTION ========== */\\n\\n    function executeOperation(\\n        address[] calldata markets,\\n        uint256[] calldata amounts,\\n        uint256[] calldata fees,\\n        address,\\n        bytes calldata\\n    ) external override returns (bool) {\\n\\n        for (uint i = 0; i < markets.length; i++) {\\n            uint amountIncludingFee = amounts[i].add(fees[i]);\\n            address underlying = IQToken(markets[i]).underlying();\\n            if (underlying == address(WBNB)) {\\n                IWETH(underlying).deposit{value:amountIncludingFee}();\\n//                SafeToken.safeTransferETH(markets[0], amountIncludingFee);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidation/QLiquidationV2Testnet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"../library/SafeToken.sol\\\";\\nimport \\\"../library/WhitelistUpgradeable.sol\\\";\\n\\nimport \\\"../interfaces/IBEP20.sol\\\";\\nimport \\\"../interfaces/IPancakePair.sol\\\";\\nimport \\\"../interfaces/IPancakeRouter02.sol\\\";\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../interfaces/IQToken.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../interfaces/IPriceCalculator.sol\\\";\\nimport \\\"../interfaces/IFlashLoanReceiver.sol\\\";\\n\\n\\ncontract QLiquidationV2Testnet is WhitelistUpgradeable, ReentrancyGuardUpgradeable, IFlashLoanReceiver {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANTS ============= */\\n\\n    IQore public constant Qore = IQore(0x995cCA2cD0C269fdEe7d057A8A7aaA1586ecEf51);\\n    IPriceCalculator public constant PriceCalculatorBSC = IPriceCalculator(0x20E5E35ba29dC3B540a1aee781D0814D5c77Bce6);\\n\\n    IPancakeRouter02 private constant ROUTER = IPancakeRouter02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3);\\n\\n    address private constant qBNB = 0x14fA6A83A08B763B8A430e1fAeafe009D266F280;\\n    address private constant qETH = 0xAf9A0488D21A3cec2012f3E6Fe632B65Aa6Ea61D;\\n    address private constant qUSDT = 0x93848E23F0a70891A67a98a6CEBb47Fa55A51508;\\n    address private constant qDAI = 0xfc743504c7FF5526e3Ba97617F6e6Bf8fD8cfdF0;\\n    address private constant qBUSD = 0x5B8BA405976b3A798F47DAE502e1982502aF64c5;\\n    address private constant qQBT = 0x2D076EC4FE501927c5bea2A5bA8902e5e7A9B727;\\n\\n    address private constant WBNB = 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;\\n\\n    address private constant ETH = 0x8BaBbB98678facC7342735486C851ABD7A0d17Ca;\\n    address private constant DAI = 0x8a9424745056Eb399FD19a0EC26A14316684e274;  // BUSD pair\\n    address private constant BUSD = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7;\\n    address private constant USDT = 0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684;\\n\\n\\n    address private constant QBT = 0xF523e4478d909968090a232eB380E2dd6f802518;\\n\\n\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(address => address) private _routePairAddresses;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    receive() external payable {}\\n\\n    function initialize() external initializer {\\n        __WhitelistUpgradeable_init();\\n        __ReentrancyGuard_init();\\n\\n        for (uint i = 0; i < underlyingTokens().length; i++) {\\n            address underlying = underlyingTokens()[i];\\n            if (underlying != QBT) {\\n                IBEP20(underlying).approve(address(ROUTER), uint(- 1));\\n            }\\n            IBEP20(underlying).approve(qTokens()[i], uint(- 1));\\n            IBEP20(underlying).approve(address(Qore), uint(- 1));\\n        }\\n\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function underlyingTokens() public pure returns (address[6] memory) {\\n        return [WBNB, ETH, DAI, BUSD, USDT, QBT];\\n    }\\n\\n    function qTokens() public pure returns (address[6] memory) {\\n        return [qBNB, qETH, qDAI, qBUSD, qUSDT, qQBT];\\n    }\\n\\n    /* ========== RESTRICTED FUNCTION ========== */\\n\\n    function setRoutePairAddress(address token, address route) external onlyOwner {\\n        require(route != address(0), \\\"QLiquidation: invalid route address\\\");\\n        _routePairAddresses[token] = route;\\n    }\\n\\n    /* ========== Flashloan Callback FUNCTION ========== */\\n\\n    function executeOperation(\\n        address[] calldata,\\n        uint256[] calldata,\\n        uint256[] calldata fees,\\n        address,\\n        bytes calldata params\\n    ) external override returns (bool) {\\n        require(fees.length == 1, \\\"QLiquidationV2 : invalid request\\\");\\n        (address qTokenBorrowed, address qTokenCollateral, address borrower, uint amount) = abi.decode(params, (address, address, address, uint));\\n\\n        _liquidate(qTokenBorrowed, qTokenCollateral, borrower, amount);\\n\\n        if (qTokenBorrowed != qTokenCollateral) {\\n            _swapToRepayFlashloan(qTokenCollateral, qTokenBorrowed, amount.add(fees[0]));\\n        }\\n        else if (qTokenBorrowed == qBNB) {\\n            IWETH(WBNB).deposit{value:amount.add(fees[0])}();\\n        }\\n\\n        return true;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function liquidate(address qTokenBorrowed, address qTokenCollateral, address borrow, uint amount) external onlyWhitelisted nonReentrant {\\n        _flashloanQubit(qTokenBorrowed, qTokenCollateral, borrow, amount);\\n    }\\n\\n    function autoLiquidate(address account) external onlyWhitelisted nonReentrant {\\n        (uint collateralInUSD, , uint borrowInUSD) = Qore.accountLiquidityOf(account);\\n        require(borrowInUSD > collateralInUSD, \\\"QLiquidation: Insufficient shortfall\\\");\\n\\n        (address qTokenBorrowed, address qTokenCollateral, uint liquidateAmount) = _getTargetMarkets(account);\\n        _flashloanQubit(qTokenBorrowed, qTokenCollateral, account, liquidateAmount);\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _liquidate(address qTokenBorrowed, address qTokenCollateral, address borrower, uint amount) private {\\n        uint qTokenCollateralBalance = IQToken(qTokenCollateral).balanceOf(address(this));\\n        if (IQToken(qTokenBorrowed).underlying() == WBNB) {\\n            Qore.liquidateBorrow{value : amount}(qTokenBorrowed, qTokenCollateral, borrower, 0);\\n        } else {\\n            Qore.liquidateBorrow(qTokenBorrowed, qTokenCollateral, borrower, amount);\\n        }\\n\\n        _redeemToken(qTokenCollateral, IQToken(qTokenCollateral).balanceOf(address(this)).sub(qTokenCollateralBalance));\\n    }\\n\\n    function _getTargetMarkets(address account) private view returns (address qTokenBorrowed, address qTokenCollateral, uint liquidateAmount) {\\n        uint maxSupplied;\\n        uint maxBorrowed;\\n        address[] memory markets = Qore.marketListOf(account);\\n        for (uint i = 0; i < markets.length; i++) {\\n            uint borrow = IQToken(markets[i]).borrowBalanceOf(account);\\n            uint supply = IQToken(markets[i]).underlyingBalanceOf(account);\\n\\n            if (borrow > 0 && borrow > maxBorrowed) {\\n                maxBorrowed = borrow;\\n                qTokenBorrowed = markets[i];\\n            }\\n\\n            uint collateralFactor = Qore.marketInfoOf(markets[i]).collateralFactor;\\n            if (collateralFactor > 0 && supply > 0 && supply > maxSupplied) {\\n                maxSupplied = supply;\\n                qTokenCollateral = markets[i];\\n            }\\n        }\\n        liquidateAmount = _getAvailableAmounts(qTokenBorrowed, qTokenCollateral, maxBorrowed, maxSupplied);\\n        return (qTokenBorrowed, qTokenCollateral, liquidateAmount);\\n    }\\n\\n    function _getAvailableAmounts(address qTokenBorrowed, address qTokenCollateral, uint borrowAmount, uint supplyAmount) private view returns (uint closeAmount) {\\n        uint borrowPrice = PriceCalculatorBSC.getUnderlyingPrice(qTokenBorrowed);\\n        uint supplyPrice = PriceCalculatorBSC.getUnderlyingPrice(qTokenCollateral);\\n        require(supplyPrice != 0 && borrowPrice != 0, \\\"QLiquidation: price error\\\");\\n\\n        uint borrowValue = borrowPrice.mul(borrowAmount).div(1e18);\\n        uint supplyValue = supplyPrice.mul(supplyAmount).div(1e18);\\n\\n        uint maxCloseValue = borrowValue.mul(Qore.closeFactor()).div(1e18);\\n        uint maxCloseValueWithIncentive = maxCloseValue.mul(110).div(100);\\n        return closeAmount = maxCloseValueWithIncentive < supplyValue ? maxCloseValue.mul(1e18).div(borrowPrice)\\n                                                                      : supplyValue.mul(90).div(100).mul(1e18).div(borrowPrice);\\n    }\\n\\n    function _flashloanQubit(address _qTokenBorrowed, address _qTokenCollateral, address borrower, uint amount) private {\\n        address[] memory _markets = new address[](1);\\n        _markets[0] = _qTokenBorrowed;\\n\\n        uint[] memory _amounts = new uint[](1);\\n        _amounts[0] = amount;\\n//        Qore.flashLoan(address(this), _markets, _amounts,\\n//            abi.encode(_qTokenBorrowed, _qTokenCollateral, borrower, amount)\\n//        );\\n    }\\n\\n    function _redeemToken(address _qTokenCollateral, uint amount) private returns (uint) {\\n        IBEP20 collateralToken = IBEP20(IQToken(_qTokenCollateral).underlying());\\n\\n        uint collateralBalance = collateralToken.balanceOf(address(this));\\n        Qore.redeemToken(_qTokenCollateral, amount);\\n\\n        return collateralToken.balanceOf(address(this)).sub(collateralBalance);\\n    }\\n\\n    function _swapToRepayFlashloan(address _qTokenCollateral, address _qTokenBorrowed, uint repayAmount) private {\\n        address collateralToken = IQToken(_qTokenCollateral).underlying();\\n        address borrowedToken = IQToken(_qTokenBorrowed).underlying();\\n\\n        if (collateralToken == WBNB) {\\n            if (_routePairAddresses[borrowedToken] != address(0)) {\\n                address[] memory path = new address[](3);\\n                path[0] = WBNB;\\n                path[1] = _routePairAddresses[borrowedToken];\\n                path[2] = borrowedToken;\\n                ROUTER.swapETHForExactTokens{value : address(this).balance}(repayAmount, path, address(this), block.timestamp);\\n            }\\n            else {\\n                address[] memory path = new address[](2);\\n                path[0] = WBNB;\\n                path[1] = borrowedToken;\\n                ROUTER.swapETHForExactTokens{value : address(this).balance}(repayAmount, path, address(this), block.timestamp);\\n            }\\n        } else if (borrowedToken == WBNB) {\\n            if (_routePairAddresses[collateralToken] != address(0)) {\\n                address[] memory path = new address[](3);\\n                path[0] = collateralToken;\\n                path[1] = _routePairAddresses[collateralToken];\\n                path[2] = WBNB;\\n\\n                ROUTER.swapTokensForExactTokens(repayAmount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp);\\n            } else {\\n                address[] memory path = new address[](2);\\n                path[0] = collateralToken;\\n                path[1] = WBNB;\\n\\n                ROUTER.swapTokensForExactTokens(repayAmount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp);\\n            }\\n        }\\n        else {\\n            if ( (borrowedToken == DAI && collateralToken == BUSD) || (collateralToken == DAI && borrowedToken == BUSD) ||\\n                (borrowedToken == BUSD && (collateralToken == USDT)) ||\\n                (collateralToken == BUSD && (borrowedToken == USDT)) ||\\n                (borrowedToken == USDT && (collateralToken == BUSD)) ||\\n                (collateralToken == USDT && (borrowedToken == BUSD)) ) {\\n                address[] memory path = new address[](2);\\n                path[0] = collateralToken;\\n                path[1] = borrowedToken;\\n\\n                ROUTER.swapTokensForExactTokens(repayAmount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp);\\n            } else {\\n                // first swap to WBNB,\\n                uint WBNBamount;\\n                if (_routePairAddresses[borrowedToken] != address(0)) {\\n                    address[] memory path = new address[](3);\\n                    path[0] = WBNB;\\n                    path[1] = _routePairAddresses[borrowedToken];\\n                    path[2] = borrowedToken;\\n\\n                    WBNBamount = ROUTER.getAmountsIn(repayAmount, path)[0];\\n                } else {\\n                    address[] memory path = new address[](2);\\n                    path[0] = WBNB;\\n                    path[1] = borrowedToken;\\n\\n                    WBNBamount = ROUTER.getAmountsIn(repayAmount, path)[0];\\n                }\\n\\n                if (_routePairAddresses[collateralToken] != address(0)) {\\n                    address[] memory path = new address[](3);\\n                    path[0] = collateralToken;\\n                    path[1] = _routePairAddresses[collateralToken];\\n                    path[2] = WBNB;\\n\\n                    ROUTER.swapTokensForExactTokens(WBNBamount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp);\\n                } else {\\n                    address[] memory path = new address[](2);\\n                    path[0] = collateralToken;\\n                    path[1] = WBNB;\\n\\n                    ROUTER.swapTokensForExactTokens(WBNBamount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp);\\n                }\\n\\n                // then swap WBNB to borrowedToken\\n                if (_routePairAddresses[borrowedToken] != address(0)) {\\n                    address[] memory path = new address[](3);\\n                    path[0] = WBNB;\\n                    path[1] = _routePairAddresses[borrowedToken];\\n                    path[2] = borrowedToken;\\n\\n                    ROUTER.swapTokensForExactTokens(repayAmount, IBEP20(WBNB).balanceOf(address(this)), path, address(this), block.timestamp);\\n                } else {\\n                    address[] memory path = new address[](2);\\n                    path[0] = WBNB;\\n                    path[1] = borrowedToken;\\n\\n                    ROUTER.swapTokensForExactTokens(repayAmount, IBEP20(WBNB).balanceOf(address(this)), path, address(this), block.timestamp);\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Qore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./interfaces/IQToken.sol\\\";\\nimport \\\"./interfaces/IQValidator.sol\\\";\\nimport \\\"./interfaces/IFlashLoanReceiver.sol\\\";\\nimport \\\"./library/SafeToken.sol\\\";\\n\\nimport \\\"./QoreAdmin.sol\\\";\\n\\ncontract Qore is QoreAdmin {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address internal constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n\\n    uint public constant FLASHLOAN_FEE = 5e14; // 0.05%\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(address => address[]) public marketListOfUsers; // (account => qTokenAddress[])\\n    mapping(address => mapping(address => bool)) public usersOfMarket; // (qTokenAddress => (account => joined))\\n    address[] public totalUserList; // do not use\\n\\n    mapping(address => uint) public supplyCap;\\n\\n    /* ========== Event ========== */\\n\\n    event SupplyCapUpdated(address indexed qToken, uint newSupplyCap);\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() external initializer {\\n        __Qore_init();\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyMemberOfMarket(address qToken) {\\n        require(usersOfMarket[qToken][msg.sender], \\\"Qore: must enter market\\\");\\n        _;\\n    }\\n\\n    modifier onlyMarket() {\\n        bool fromMarket = false;\\n        for (uint i = 0; i < markets.length; i++) {\\n            if (msg.sender == markets[i]) {\\n                fromMarket = true;\\n                break;\\n            }\\n        }\\n        require(fromMarket == true, \\\"Qore: caller should be market\\\");\\n        _;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function allMarkets() external view override returns (address[] memory) {\\n        return markets;\\n    }\\n\\n    function marketInfoOf(address qToken) external view override returns (QConstant.MarketInfo memory) {\\n        return marketInfos[qToken];\\n    }\\n\\n    function marketListOf(address account) external view override returns (address[] memory) {\\n        return marketListOfUsers[account];\\n    }\\n\\n    function checkMembership(address account, address qToken) external view override returns (bool) {\\n        return usersOfMarket[qToken][account];\\n    }\\n\\n    function accountLiquidityOf(address account) external view override returns (uint collateralInUSD, uint supplyInUSD, uint borrowInUSD) {\\n        return IQValidator(qValidator).getAccountLiquidity(account);\\n    }\\n\\n    function distributionInfoOf(address market) external view override returns (QConstant.DistributionInfo memory) {\\n        return qDistributor.distributionInfoOf(market);\\n    }\\n\\n    function accountDistributionInfoOf(address market, address account) external view override returns (QConstant.DistributionAccountInfo memory) {\\n        return qDistributor.accountDistributionInfoOf(market, account);\\n    }\\n\\n    function apyDistributionOf(address market, address account) external view override returns (QConstant.DistributionAPY memory) {\\n        return qDistributor.apyDistributionOf(market, account);\\n    }\\n\\n    function distributionSpeedOf(address qToken) external view override returns (uint supplySpeed, uint borrowSpeed) {\\n        QConstant.DistributionInfo memory distribution = qDistributor.distributionInfoOf(qToken);\\n        return (distribution.supplySpeed, distribution.borrowSpeed);\\n    }\\n\\n    function boostedRatioOf(address market, address account) external view override returns (uint boostedSupplyRatio, uint boostedBorrowRatio) {\\n        return qDistributor.boostedRatioOf(market, account);\\n    }\\n\\n    function accruedQubit(address account) external view override returns (uint) {\\n        return qDistributor.accruedQubit(markets, account);\\n    }\\n\\n    function accruedQubit(address market, address account) external view override returns (uint) {\\n        address[] memory _markets = new address[](1);\\n        _markets[0] = market;\\n        return qDistributor.accruedQubit(_markets, account);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function enterMarkets(address[] memory qTokens) public override {\\n        for (uint i = 0; i < qTokens.length; i++) {\\n            _enterMarket(payable(qTokens[i]), msg.sender);\\n        }\\n    }\\n\\n    function exitMarket(address qToken) external override onlyListedMarket(qToken) onlyMemberOfMarket(qToken) {\\n        QConstant.AccountSnapshot memory snapshot = IQToken(qToken).accruedAccountSnapshot(msg.sender);\\n        require(snapshot.borrowBalance == 0, \\\"Qore: borrow balance must be zero\\\");\\n        require(\\n            IQValidator(qValidator).redeemAllowed(qToken, msg.sender, snapshot.qTokenBalance),\\n            \\\"Qore: cannot redeem\\\"\\n        );\\n\\n        _removeUserMarket(qToken, msg.sender);\\n        emit MarketExited(qToken, msg.sender);\\n    }\\n\\n    function supply(address qToken, uint uAmount)\\n        external\\n        payable\\n        override\\n        onlyListedMarket(qToken)\\n        nonReentrant\\n        returns (uint)\\n    {\\n        uAmount = IQToken(qToken).underlying() == address(WBNB) ? msg.value : uAmount;\\n\\n        if (supplyCap[qToken] != 0) {\\n            require(IQToken(qToken).totalSupply().mul(IQToken(qToken).exchangeRate())\\n            .div(1e18).add(uAmount) <= supplyCap[qToken], \\\"Qore: market supply cap reached\\\");\\n        }\\n        uint qAmount = IQToken(qToken).supply{ value: msg.value }(msg.sender, uAmount);\\n        qDistributor.notifySupplyUpdated(qToken, msg.sender);\\n\\n        return qAmount;\\n    }\\n\\n    function redeemToken(address qToken, uint qAmount)\\n        external\\n        override\\n        onlyListedMarket(qToken)\\n        nonReentrant\\n        returns (uint)\\n    {\\n        uint uAmountRedeem = IQToken(qToken).redeemToken(msg.sender, qAmount);\\n        qDistributor.notifySupplyUpdated(qToken, msg.sender);\\n\\n        return uAmountRedeem;\\n    }\\n\\n    function redeemUnderlying(address qToken, uint uAmount)\\n        external\\n        override\\n        onlyListedMarket(qToken)\\n        nonReentrant\\n        returns (uint)\\n    {\\n        uint uAmountRedeem = IQToken(qToken).redeemUnderlying(msg.sender, uAmount);\\n        qDistributor.notifySupplyUpdated(qToken, msg.sender);\\n\\n        return uAmountRedeem;\\n    }\\n\\n    function borrow(address qToken, uint amount) external override onlyListedMarket(qToken) nonReentrant {\\n        _enterMarket(qToken, msg.sender);\\n        require(IQValidator(qValidator).borrowAllowed(qToken, msg.sender, amount), \\\"Qore: cannot borrow\\\");\\n\\n        IQToken(payable(qToken)).borrow(msg.sender, amount);\\n        qDistributor.notifyBorrowUpdated(qToken, msg.sender);\\n    }\\n\\n    function repayBorrow(address qToken, uint amount) external payable override onlyListedMarket(qToken) nonReentrant {\\n        IQToken(payable(qToken)).repayBorrow{ value: msg.value }(msg.sender, amount);\\n        qDistributor.notifyBorrowUpdated(qToken, msg.sender);\\n    }\\n\\n    function repayBorrowBehalf(\\n        address qToken,\\n        address borrower,\\n        uint amount\\n    ) external payable override onlyListedMarket(qToken) nonReentrant {\\n        IQToken(payable(qToken)).repayBorrowBehalf{ value: msg.value }(msg.sender, borrower, amount);\\n        qDistributor.notifyBorrowUpdated(qToken, borrower);\\n    }\\n\\n    function liquidateBorrow(\\n        address qTokenBorrowed,\\n        address qTokenCollateral,\\n        address borrower,\\n        uint amount\\n    ) external payable override nonReentrant {\\n        amount = IQToken(qTokenBorrowed).underlying() == address(WBNB) ? msg.value : amount;\\n        require(marketInfos[qTokenBorrowed].isListed && marketInfos[qTokenCollateral].isListed, \\\"Qore: invalid market\\\");\\n        require(usersOfMarket[qTokenCollateral][borrower], \\\"Qore: not a collateral\\\");\\n        require(marketInfos[qTokenCollateral].collateralFactor > 0, \\\"Qore: not a collateral\\\");\\n        require(\\n            IQValidator(qValidator).liquidateAllowed(qTokenBorrowed, borrower, amount, closeFactor),\\n            \\\"Qore: cannot liquidate borrow\\\"\\n        );\\n\\n        uint qAmountToSeize = IQToken(qTokenBorrowed).liquidateBorrow{ value: msg.value }(\\n            qTokenCollateral,\\n            msg.sender,\\n            borrower,\\n            amount\\n        );\\n        IQToken(qTokenCollateral).seize(msg.sender, borrower, qAmountToSeize);\\n        qDistributor.notifyTransferred(qTokenCollateral, borrower, msg.sender);\\n        qDistributor.notifyBorrowUpdated(qTokenBorrowed, borrower);\\n    }\\n\\n    function claimQubit() external override nonReentrant {\\n        qDistributor.claimQubit(markets, msg.sender);\\n    }\\n\\n    function claimQubit(address market) external override nonReentrant {\\n        address[] memory _markets = new address[](1);\\n        _markets[0] = market;\\n        qDistributor.claimQubit(_markets, msg.sender);\\n    }\\n\\n    function transferTokens(address spender, address src, address dst, uint amount) external override nonReentrant onlyMarket {\\n        IQToken(msg.sender).transferTokensInternal(spender, src, dst, amount);\\n        qDistributor.notifyTransferred(msg.sender, src, dst);\\n    }\\n\\n    /* ========== RESTRICTED FUNCTION ========== */\\n\\n    function setSupplyCap(address qToken, uint newSupplyCap) external onlyKeeper {\\n        supplyCap[qToken] = newSupplyCap;\\n        emit SupplyCapUpdated(qToken, newSupplyCap);\\n    }\\n\\n    /* ========== RESTRICTED FUNCTION FOR WHITELIST ========== */\\n\\n    function supplyAndBorrowBehalf(address account, address supplyMarket, uint supplyAmount, address borrowMarket, uint borrowAmount)\\n        external\\n        payable\\n        override\\n        onlyListedMarket(supplyMarket)\\n        onlyListedMarket(borrowMarket)\\n        onlyWhitelisted\\n        nonReentrant\\n        returns (uint)\\n    {\\n        address underlying = IQToken(supplyMarket).underlying();\\n        uint uAmount = underlying == address(WBNB) ? msg.value : supplyAmount;\\n\\n        uint qAmount = IQToken(supplyMarket).supplyBehalf{ value: msg.value }(msg.sender, account, uAmount);\\n\\n        _enterMarket(supplyMarket, account);\\n\\n        require(_borrowAllowed(supplyMarket, supplyAmount, borrowMarket, borrowAmount), \\\"Qore: cannot borrow\\\");\\n        IQToken(borrowMarket).borrow(account, borrowAmount);\\n\\n        qDistributor.notifySupplyUpdated(supplyMarket, account);\\n        qDistributor.notifyBorrowUpdated(borrowMarket, account);\\n        return qAmount;\\n    }\\n\\n    function supplyAndBorrowBNB(address account, address supplyMarket, uint supplyAmount, uint borrowAmount)\\n        external\\n        payable\\n        override\\n        onlyListedMarket(supplyMarket)\\n        onlyWhitelisted\\n        nonReentrant\\n        returns (uint)\\n    {\\n        require(borrowAmount <= 5e16, \\\"exceed maximum amount\\\");\\n        address underlying = IQToken(supplyMarket).underlying();\\n        uint uAmount = underlying == address(WBNB) ? msg.value : supplyAmount;\\n        uint qAmount = IQToken(supplyMarket).supplyBehalf{ value: msg.value }(msg.sender, account, uAmount);\\n\\n        _enterMarket(supplyMarket, account);\\n\\n        address qBNB = 0xbE1B5D17777565D67A5D2793f879aBF59Ae5D351;\\n        _enterMarket(qBNB, account);\\n\\n        require(_borrowAllowed(supplyMarket, supplyAmount, qBNB, borrowAmount), \\\"Qore: cannot borrow\\\");\\n        IQToken(qBNB).borrow(account, borrowAmount);\\n        // no reward update to reduce gasfee\\n        // qDistributor.notifySupplyUpdated(supplyMarket, account);\\n        // qDistributor.notifyBorrowUpdated(0xbE1B5D17777565D67A5D2793f879aBF59Ae5D351, account);\\n\\n        return qAmount;\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _enterMarket(address qToken, address _account) internal onlyListedMarket(qToken) {\\n        if (!usersOfMarket[qToken][_account]) {\\n            usersOfMarket[qToken][_account] = true;\\n            marketListOfUsers[_account].push(qToken);\\n            emit MarketEntered(qToken, _account);\\n        }\\n    }\\n\\n    function _removeUserMarket(address qTokenToExit, address _account) private {\\n        require(marketListOfUsers[_account].length > 0, \\\"Qore: cannot pop user market\\\");\\n        delete usersOfMarket[qTokenToExit][_account];\\n\\n        uint length = marketListOfUsers[_account].length;\\n        for (uint i = 0; i < length; i++) {\\n            if (marketListOfUsers[_account][i] == qTokenToExit) {\\n                marketListOfUsers[_account][i] = marketListOfUsers[_account][length - 1];\\n                marketListOfUsers[_account].pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _borrowAllowed(address supplyMarket, uint supplyAmount, address borrowMarket, uint borrowAmount) internal view returns (bool){\\n        // Borrow cap of 0 corresponds to unlimited borrowing\\n        uint borrowCap = marketInfos[borrowMarket].borrowCap;\\n        if (borrowCap != 0) {\\n            uint totalBorrows = IQToken(payable(borrowMarket)).totalBorrow();\\n            uint nextTotalBorrows = totalBorrows.add(borrowAmount);\\n            require(nextTotalBorrows < borrowCap, \\\"Qore: market borrow cap reached\\\");\\n        }\\n\\n        address[] memory markets = new address[](2);\\n        markets[0] = supplyMarket;\\n        markets[1] = borrowMarket;\\n        uint[] memory prices = priceCalculator.getUnderlyingPrices(markets);\\n        uint collateralValueInUSD = prices[0].mul(supplyAmount).mul(marketInfos[supplyMarket].collateralFactor).div(1e36);\\n        uint borrowValueInUSD = prices[1].mul(borrowAmount).div(1e18);\\n\\n        return collateralValueInUSD >= borrowValueInUSD;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/library/QValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\nimport \\\"../interfaces/IPriceCalculator.sol\\\";\\nimport \\\"../interfaces/IQValidator.sol\\\";\\nimport \\\"../interfaces/IQToken.sol\\\";\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../library/QConstant.sol\\\";\\n\\ncontract QValidator is IQValidator, OwnableUpgradeable {\\n    using SafeMath for uint;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    IPriceCalculator public constant oracle = IPriceCalculator(0x20E5E35ba29dC3B540a1aee781D0814D5c77Bce6);\\n    address private constant qQBT = 0xcD2CD343CFbe284220677C78A08B1648bFa39865;\\n    uint private constant qbtPriceCollateralCap = 15e16;\\n    address private constant qBunny = 0xceB82D224a531525C838BF0ACdc33B2C8d550c47;\\n    uint private constant bunnyPriceCollateralCap = 5e18;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IQore public qore;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() external initializer {\\n        __Ownable_init();\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function getAccountLiquidity(address account) external view override returns (uint collateralInUSD, uint supplyInUSD, uint borrowInUSD) {\\n        collateralInUSD = 0;\\n        supplyInUSD = 0;\\n        borrowInUSD = 0;\\n\\n        address[] memory assets = qore.marketListOf(account);\\n        uint[] memory prices = oracle.getUnderlyingPrices(assets);\\n        for (uint i = 0; i < assets.length; i++) {\\n            require(prices[i] != 0, \\\"QValidator: price error\\\");\\n            QConstant.AccountSnapshot memory snapshot = IQToken(payable(assets[i])).accountSnapshot(account);\\n            \\n            uint priceCollateral;\\n            if (assets[i] == qQBT && prices[i] > qbtPriceCollateralCap) {\\n                priceCollateral = qbtPriceCollateralCap;\\n            } else if (assets[i] == qBunny && prices[i] > bunnyPriceCollateralCap) {\\n                priceCollateral = bunnyPriceCollateralCap;\\n            } else {\\n                priceCollateral = prices[i];\\n            }\\n\\n            uint collateralFactor = qore.marketInfoOf(payable(assets[i])).collateralFactor;\\n            uint collateralValuePerShareInUSD = snapshot.exchangeRate.mul(priceCollateral).mul(collateralFactor).div(1e36);\\n\\n            collateralInUSD = collateralInUSD.add(snapshot.qTokenBalance.mul(collateralValuePerShareInUSD).div(1e18));\\n            supplyInUSD = supplyInUSD.add(snapshot.qTokenBalance.mul(snapshot.exchangeRate).mul(prices[i]).div(1e36));\\n            borrowInUSD = borrowInUSD.add(snapshot.borrowBalance.mul(prices[i]).div(1e18));\\n        }\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setQore(address _qore) external onlyOwner {\\n        require(_qore != address(0), \\\"QValidator: invalid qore address\\\");\\n        require(address(qore) == address(0), \\\"QValidator: qore already set\\\");\\n        qore = IQore(_qore);\\n    }\\n\\n    /* ========== ALLOWED FUNCTIONS ========== */\\n\\n    function redeemAllowed(\\n        address qToken,\\n        address redeemer,\\n        uint redeemAmount\\n    ) external override returns (bool) {\\n        (, uint shortfall) = _getAccountLiquidityInternal(redeemer, qToken, redeemAmount, 0);\\n        return shortfall == 0;\\n    }\\n\\n    function borrowAllowed(\\n        address qToken,\\n        address borrower,\\n        uint borrowAmount\\n    ) external override returns (bool) {\\n        require(qore.checkMembership(borrower, address(qToken)), \\\"QValidator: enterMarket required\\\");\\n        require(oracle.getUnderlyingPrice(address(qToken)) > 0, \\\"QValidator: Underlying price error\\\");\\n\\n        // Borrow cap of 0 corresponds to unlimited borrowing\\n        uint borrowCap = qore.marketInfoOf(qToken).borrowCap;\\n        if (borrowCap != 0) {\\n            uint totalBorrows = IQToken(payable(qToken)).accruedTotalBorrow();\\n            uint nextTotalBorrows = totalBorrows.add(borrowAmount);\\n            require(nextTotalBorrows < borrowCap, \\\"QValidator: market borrow cap reached\\\");\\n        }\\n\\n        (, uint shortfall) = _getAccountLiquidityInternal(borrower, qToken, 0, borrowAmount);\\n        return shortfall == 0;\\n    }\\n\\n    function liquidateAllowed(\\n        address qToken,\\n        address borrower,\\n        uint liquidateAmount,\\n        uint closeFactor\\n    ) external override returns (bool) {\\n        // The borrower must have shortfall in order to be liquidate\\n        (, uint shortfall) = _getAccountLiquidityInternal(borrower, address(0), 0, 0);\\n        require(shortfall != 0, \\\"QValidator: Insufficient shortfall\\\");\\n\\n        // The liquidator may not repay more than what is allowed by the closeFactor\\n        uint borrowBalance = IQToken(payable(qToken)).accruedBorrowBalanceOf(borrower);\\n        uint maxClose = closeFactor.mul(borrowBalance).div(1e18);\\n        return liquidateAmount <= maxClose;\\n    }\\n\\n    function qTokenAmountToSeize(\\n        address qTokenBorrowed,\\n        address qTokenCollateral,\\n        uint amount\\n    ) external override returns (uint seizeQAmount) {\\n        uint priceBorrowed = oracle.getUnderlyingPrice(qTokenBorrowed);\\n        uint priceCollateral = oracle.getUnderlyingPrice(qTokenCollateral);\\n        require(priceBorrowed != 0 && priceCollateral != 0, \\\"QValidator: price error\\\");\\n\\n        uint exchangeRate = IQToken(payable(qTokenCollateral)).accruedExchangeRate();\\n        require(exchangeRate != 0, \\\"QValidator: exchangeRate of qTokenCollateral is zero\\\");\\n\\n        // seizeQTokenAmount = amount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\\n        return amount.mul(qore.liquidationIncentive()).mul(priceBorrowed).div(priceCollateral.mul(exchangeRate));\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _getAccountLiquidityInternal(\\n        address account,\\n        address qToken,\\n        uint redeemAmount,\\n        uint borrowAmount\\n    ) private returns (uint liquidity, uint shortfall) {\\n        uint accCollateralValueInUSD;\\n        uint accBorrowValueInUSD;\\n\\n        address[] memory assets = qore.marketListOf(account);\\n        uint[] memory prices = oracle.getUnderlyingPrices(assets);\\n        for (uint i = 0; i < assets.length; i++) {\\n            require(prices[i] != 0, \\\"QValidator: price error\\\");\\n            QConstant.AccountSnapshot memory snapshot = IQToken(payable(assets[i])).accruedAccountSnapshot(account);\\n\\n            uint collateralValuePerShareInUSD;\\n            if (assets[i] == qQBT && prices[i] > qbtPriceCollateralCap) {\\n                collateralValuePerShareInUSD = snapshot\\n                .exchangeRate\\n                .mul(qbtPriceCollateralCap)\\n                .mul(qore.marketInfoOf(payable(assets[i])).collateralFactor)\\n                .div(1e36);\\n            }\\n            else if (assets[i] == qBunny && prices[i] > bunnyPriceCollateralCap) {\\n                collateralValuePerShareInUSD = snapshot\\n                .exchangeRate\\n                .mul(bunnyPriceCollateralCap)\\n                .mul(qore.marketInfoOf(payable(assets[i])).collateralFactor)\\n                .div(1e36);\\n            }\\n            else {\\n                collateralValuePerShareInUSD = snapshot\\n                .exchangeRate\\n                .mul(prices[i])\\n                .mul(qore.marketInfoOf(payable(assets[i])).collateralFactor)\\n                .div(1e36);\\n            }\\n\\n            accCollateralValueInUSD = accCollateralValueInUSD.add(\\n                snapshot.qTokenBalance.mul(collateralValuePerShareInUSD).div(1e18)\\n            );\\n            accBorrowValueInUSD = accBorrowValueInUSD.add(snapshot.borrowBalance.mul(prices[i]).div(1e18));\\n\\n            if (assets[i] == qToken) {\\n                accBorrowValueInUSD = accBorrowValueInUSD.add(redeemAmount.mul(collateralValuePerShareInUSD).div(1e18));\\n                accBorrowValueInUSD = accBorrowValueInUSD.add(borrowAmount.mul(prices[i]).div(1e18));\\n            }\\n        }\\n\\n        liquidity = accCollateralValueInUSD > accBorrowValueInUSD\\n        ? accCollateralValueInUSD.sub(accBorrowValueInUSD)\\n        : 0;\\n        shortfall = accCollateralValueInUSD > accBorrowValueInUSD\\n        ? 0\\n        : accBorrowValueInUSD.sub(accCollateralValueInUSD);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/presale/QubitPresale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\\\";\\nimport \\\"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol\\\";\\nimport \\\"../interfaces/IPancakeRouter02.sol\\\";\\nimport \\\"../interfaces/IPancakeFactory.sol\\\";\\nimport \\\"../interfaces/IPancakePair.sol\\\";\\nimport \\\"../interfaces/IPresaleLocker.sol\\\";\\nimport \\\"../interfaces/IQubitPresale.sol\\\";\\nimport \\\"../interfaces/IPriceCalculator.sol\\\";\\nimport \\\"../library/SafeToken.sol\\\";\\n\\ncontract QubitPresale is IQubitPresale, OwnableUpgradeable, ReentrancyGuardUpgradeable {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANTS ============= */\\n\\n    address public constant BUNNY = 0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51;\\n    address public constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public constant QBT = 0x17B7163cf1Dbd286E262ddc68b553D899B93f526;\\n    address public constant DEAD = 0x000000000000000000000000000000000000dEaD;\\n\\n    address public constant BUNNY_WBNB_LP = 0x5aFEf8567414F29f0f927A0F2787b188624c10E2;\\n    address public constant QBT_WBNB_LP = 0x67EFeF66A55c4562144B9AcfCFbc62F9E4269b3e;\\n\\n    address public constant DEPLOYER = 0xbeE397129374D0b4db7bf1654936951e5bdfe5a6;\\n\\n    IPancakeRouter02 private constant router = IPancakeRouter02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n    IPancakeFactory private constant factory = IPancakeFactory(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73);\\n    IPriceCalculator public constant priceCalculator = IPriceCalculator(0x20E5E35ba29dC3B540a1aee781D0814D5c77Bce6);\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    uint public startTime;\\n    uint public endTime;\\n    uint public presaleAmountUSD;\\n    uint public totalBunnyBnbLp;\\n    uint public qbtAmount;\\n    uint public override qbtBnbLpAmount;\\n    uint public override lpPriceAtArchive;\\n    uint private _distributionCursor;\\n\\n    mapping(address => uint) public bunnyBnbLpOf;\\n    mapping(address => bool) public claimedOf;\\n    address[] public accountList;\\n    bool public archived;\\n\\n    IPresaleLocker public qbtBnbLocker;\\n\\n    mapping(address => uint) public refundLpOf;\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Deposit(address indexed user, uint amount);\\n    event Distributed(uint length, uint remain);\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize(\\n        uint _startTime,\\n        uint _endTime,\\n        uint _presaleAmountUSD,\\n        uint _qbtAmount\\n    ) external initializer {\\n        __Ownable_init();\\n        __ReentrancyGuard_init();\\n\\n        startTime = _startTime;\\n        endTime = _endTime;\\n        presaleAmountUSD = _presaleAmountUSD;\\n        qbtAmount = _qbtAmount;\\n\\n        BUNNY_WBNB_LP.safeApprove(address(router), uint(~0));\\n        QBT.safeApprove(address(router), uint(~0));\\n        BUNNY.safeApprove(address(router), uint(~0));\\n        WBNB.safeApprove(address(router), uint(~0));\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function allocationOf(address _user) public view override returns (uint) {\\n        return totalBunnyBnbLp == 0 ? 0 : bunnyBnbLpOf[_user].mul(1e18).div(totalBunnyBnbLp);\\n    }\\n\\n    function refundOf(address _user) public view override returns (uint) {\\n        uint lpPriceNow = lpPriceAtArchive;\\n        if (lpPriceAtArchive == 0) {\\n            (, lpPriceNow) = priceCalculator.valueOfAsset(BUNNY_WBNB_LP, 1e18);\\n        }\\n\\n        if (totalBunnyBnbLp.mul(lpPriceNow).div(1e18) <= presaleAmountUSD) {\\n            return 0;\\n        }\\n\\n        uint lpAmountToPay = presaleAmountUSD.mul(allocationOf(_user)).div(lpPriceNow);\\n        return bunnyBnbLpOf[_user].sub(lpAmountToPay);\\n    }\\n\\n    function accountListLength() external view override returns (uint) {\\n        return accountList.length;\\n    }\\n\\n    function presaleDataOf(address account) public view returns (PresaleData memory) {\\n        PresaleData memory presaleData;\\n        presaleData.startTime = startTime;\\n        presaleData.endTime = endTime;\\n        presaleData.userLpAmount = bunnyBnbLpOf[account];\\n        presaleData.totalLpAmount = totalBunnyBnbLp;\\n        presaleData.claimedOf = claimedOf[account];\\n        presaleData.refundLpAmount = refundLpOf[account];\\n        presaleData.qbtBnbLpAmount = qbtBnbLpAmount;\\n\\n        return presaleData;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function setQubitBnbLocker(address _qubitBnbLocker) public override onlyOwner {\\n        require(_qubitBnbLocker != address(0), \\\"QubitPresale: invalid address\\\");\\n\\n        qbtBnbLocker = IPresaleLocker(_qubitBnbLocker);\\n        qbtBnbLocker.setPresaleEndTime(endTime);\\n        QBT_WBNB_LP.safeApprove(address(qbtBnbLocker), uint(~0));\\n    }\\n\\n    function setPresaleAmountUSD(uint _presaleAmountUSD) public override onlyOwner {\\n        require(block.timestamp < startTime, \\\"QubitPresale: already started\\\");\\n\\n        presaleAmountUSD = _presaleAmountUSD;\\n    }\\n\\n    function setPeriod(uint _start, uint _end) public override onlyOwner {\\n        require(block.timestamp < startTime, \\\"QubitPresale: already started\\\");\\n        require(block.timestamp < _start && _start < _end, \\\"QubitPresale: invalid time values\\\");\\n        require(address(qbtBnbLocker) != address(0), \\\"QubitPresale: QbtBnbLocker must be set\\\");\\n\\n        startTime = _start;\\n        endTime = _end;\\n\\n        qbtBnbLocker.setPresaleEndTime(endTime);\\n    }\\n\\n    function setQbtAmount(uint _qbtAmount) public override onlyOwner {\\n        require(block.timestamp < startTime, \\\"QubitPresale: already started\\\");\\n\\n        qbtAmount = _qbtAmount;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function deposit(uint _amount) public override {\\n        require(block.timestamp > startTime && block.timestamp < endTime, \\\"QubitPresale: not in presale\\\");\\n        require(_amount > 0, \\\"QubitPresale: invalid amount\\\");\\n\\n        if (bunnyBnbLpOf[msg.sender] == 0) {\\n            accountList.push(msg.sender);\\n        }\\n        bunnyBnbLpOf[msg.sender] = bunnyBnbLpOf[msg.sender].add(_amount);\\n        totalBunnyBnbLp = totalBunnyBnbLp.add(_amount);\\n\\n        BUNNY_WBNB_LP.safeTransferFrom(msg.sender, address(this), _amount);\\n        emit Deposit(msg.sender, _amount);\\n    }\\n\\n    function archive() public override onlyOwner returns (uint bunnyAmount, uint wbnbAmount) {\\n        require(!archived && qbtBnbLpAmount == 0, \\\"QubitPresale: already archived\\\");\\n        require(IBEP20(QBT).balanceOf(address(this)) == qbtAmount, \\\"QubitPresale: lack of QBT\\\");\\n        require(block.timestamp > endTime, \\\"QubitPresale: not harvest time\\\");\\n        (, lpPriceAtArchive) = priceCalculator.valueOfAsset(BUNNY_WBNB_LP, 1e18);\\n        require(lpPriceAtArchive > 0, \\\"QubitPresale: invalid lp price\\\");\\n        uint presaleAmount = presaleAmountUSD.div(lpPriceAtArchive).mul(1e18);\\n\\n        // burn manually transferred LP token\\n        if (IPancakePair(BUNNY_WBNB_LP).balanceOf(BUNNY_WBNB_LP) > 0) {\\n            IPancakePair(BUNNY_WBNB_LP).burn(DEPLOYER);\\n        }\\n\\n        uint amount = Math.min(totalBunnyBnbLp, presaleAmount);\\n        (bunnyAmount, wbnbAmount) = router.removeLiquidity(BUNNY, WBNB, amount, 0, 0, address(this), block.timestamp);\\n        BUNNY.safeTransfer(DEAD, bunnyAmount);\\n\\n        uint qbtAmountFixed = presaleAmount < totalBunnyBnbLp\\n            ? qbtAmount\\n            : qbtAmount.mul(totalBunnyBnbLp).div(presaleAmount);\\n        (, , qbtBnbLpAmount) = router.addLiquidity(\\n            QBT,\\n            WBNB,\\n            qbtAmountFixed,\\n            wbnbAmount,\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        archived = true;\\n    }\\n\\n    function distribute(uint distributeThreshold) external override onlyOwner {\\n        require(block.timestamp > endTime, \\\"QubitPresale: not harvest time\\\");\\n        require(archived, \\\"QubitPresale: not yet archived\\\");\\n        uint start = _distributionCursor;\\n        uint totalUserCount = accountList.length;\\n        uint remain = totalUserCount > _distributionCursor ? totalUserCount - _distributionCursor : 0;\\n        uint length = Math.min(remain, distributeThreshold);\\n        for (uint i = start; i < start + length; i++) {\\n            address account = accountList[i];\\n            if (!claimedOf[account]) {\\n                claimedOf[account] = true;\\n\\n                uint refundingLpAmount = refundOf(account);\\n                if (refundingLpAmount > 0 && refundLpOf[account] == 0) {\\n                    refundLpOf[account] = refundingLpAmount;\\n                    BUNNY_WBNB_LP.safeTransfer(account, refundingLpAmount);\\n                }\\n\\n                uint depositLpAmount = qbtBnbLpAmount.mul(allocationOf(account)).div(1e18);\\n                if (depositLpAmount > 0) {\\n                    delete bunnyBnbLpOf[account];\\n                    qbtBnbLocker.depositBehalf(account, depositLpAmount);\\n                }\\n            }\\n            _distributionCursor++;\\n        }\\n        remain = totalUserCount > _distributionCursor ? totalUserCount - _distributionCursor : 0;\\n        emit Distributed(length, remain);\\n    }\\n\\n    function sweep(uint _lpAmount, uint _offerAmount) public override onlyOwner {\\n        require(_lpAmount <= IBEP20(BUNNY_WBNB_LP).balanceOf(address(this)), \\\"QubitPresale: not enough token 0\\\");\\n        require(_offerAmount <= IBEP20(QBT).balanceOf(address(this)), \\\"QubitPresale: not enough token 1\\\");\\n        BUNNY_WBNB_LP.safeTransfer(msg.sender, _lpAmount);\\n        QBT.safeTransfer(msg.sender, _offerAmount);\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n}\\n\"\r\n    },\r\n    \"contracts/liquidation/QLiquidationV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"../library/SafeToken.sol\\\";\\nimport \\\"../library/WhitelistUpgradeable.sol\\\";\\n\\nimport \\\"../interfaces/IBEP20.sol\\\";\\nimport \\\"../interfaces/IPancakePair.sol\\\";\\nimport \\\"../interfaces/IPancakeRouter02.sol\\\";\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../interfaces/IQToken.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../interfaces/IPriceCalculator.sol\\\";\\nimport \\\"../interfaces/IFlashLoanReceiver.sol\\\";\\n\\n\\ncontract QLiquidationV2 is WhitelistUpgradeable, ReentrancyGuardUpgradeable, IFlashLoanReceiver {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANTS ============= */\\n\\n    IQore public constant Qore = IQore(0xF70314eb9c7Fe7D88E6af5aa7F898b3A162dcd48);\\n    IPriceCalculator public constant PriceCalculatorBSC = IPriceCalculator(0x20E5E35ba29dC3B540a1aee781D0814D5c77Bce6);\\n\\n    IPancakeRouter02 private constant ROUTER = IPancakeRouter02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n    IPancakeRouter02 private constant ROUTER_MDEX = IPancakeRouter02(0x7DAe51BD3E3376B8c7c4900E9107f12Be3AF1bA8);\\n\\n    address private constant qBNB = 0xbE1B5D17777565D67A5D2793f879aBF59Ae5D351;\\n    address private constant qBTC = 0xd055D32E50C57B413F7c2a4A052faF6933eA7927;\\n    address private constant qETH = 0xb4b77834C73E9f66de57e6584796b034D41Ce39A;\\n    address private constant qUSDC = 0x1dd6E079CF9a82c91DaF3D8497B27430259d32C2;\\n    address private constant qUSDT = 0x99309d2e7265528dC7C3067004cC4A90d37b7CC3;\\n    address private constant qDAI = 0x474010701715658fC8004f51860c90eEF4584D2B;\\n    address private constant qBUSD = 0xa3A155E76175920A40d2c8c765cbCB1148aeB9D1;\\n    address private constant qCAKE = 0xaB9eb4AE93B705b0A74d3419921bBec97F51b264;\\n    address private constant qQBT = 0xcD2CD343CFbe284220677C78A08B1648bFa39865;\\n    address private constant qMDX = 0xFF858dB0d6aA9D3fCA13F6341a1693BE4416A550;\\n\\n    address private constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address private constant BTC = 0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c;\\n    address private constant ETH = 0x2170Ed0880ac9A755fd29B2688956BD959F933F8;\\n    address private constant DAI = 0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3;  // BUSD pair\\n    address private constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n    address private constant USDT = 0x55d398326f99059fF775485246999027B3197955;\\n    address private constant USDC = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d; // BUSD pair\\n    address private constant CAKE = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\\n    address private constant QBT = 0x17B7163cf1Dbd286E262ddc68b553D899B93f526;\\n    address private constant MDX = 0x9C65AB58d8d978DB963e63f2bfB7121627e3a739;\\n\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(address => address) private _routePairAddresses;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    receive() external payable {}\\n\\n    function initialize() external initializer {\\n        __WhitelistUpgradeable_init();\\n        __ReentrancyGuard_init();\\n\\n        for (uint i = 0; i < underlyingTokens().length; i++) {\\n            address underlying = underlyingTokens()[i];\\n            if (underlying != MDX && underlying != QBT) {\\n                IBEP20(underlying).approve(address(ROUTER), uint(- 1));\\n            }\\n            IBEP20(underlying).approve(qTokens()[i], uint(- 1));\\n            IBEP20(underlying).approve(address(Qore), uint(- 1));\\n        }\\n\\n        IBEP20(WBNB).approve(address(ROUTER_MDEX), uint(- 1));\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function underlyingTokens() public pure returns (address[10] memory) {\\n        return [WBNB, BTC, ETH, DAI, USDC, BUSD, USDT, CAKE, QBT, MDX];\\n    }\\n\\n    function qTokens() public pure returns (address[10] memory) {\\n        return [qBNB, qBTC, qETH, qDAI, qUSDC, qBUSD, qUSDT, qCAKE, qQBT, qMDX];\\n    }\\n\\n    /* ========== RESTRICTED FUNCTION ========== */\\n\\n    function setRoutePairAddress(address token, address route) external onlyOwner {\\n        require(route != address(0), \\\"QLiquidation: invalid route address\\\");\\n        _routePairAddresses[token] = route;\\n    }\\n\\n    /* ========== Flashloan Callback FUNCTION ========== */\\n\\n    function executeOperation(\\n        address[] calldata,\\n        uint256[] calldata,\\n        uint256[] calldata fees,\\n        address,\\n        bytes calldata params\\n    ) external override returns (bool) {\\n        require(fees.length == 1, \\\"QLiquidationV2 : invalid request\\\");\\n        (address qTokenBorrowed, address qTokenCollateral, address borrower, uint amount) = abi.decode(params, (address, address, address, uint));\\n\\n        _liquidate(qTokenBorrowed, qTokenCollateral, borrower, amount);\\n\\n        if (qTokenBorrowed != qTokenCollateral) {\\n            if (qTokenBorrowed == qMDX) {\\n                _swapToMDX(qTokenCollateral, amount.add(fees[0]));\\n            }\\n            else {\\n                _swapToRepayFlashloan(qTokenCollateral, qTokenBorrowed, amount.add(fees[0]));\\n            }\\n        }\\n        else if (qTokenBorrowed == qBNB) {\\n            IWETH(WBNB).deposit{value:amount.add(fees[0])}();\\n        }\\n\\n        return true;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function liquidate(address qTokenBorrowed, address qTokenCollateral, address borrow, uint amount) external onlyWhitelisted nonReentrant {\\n        _flashloanQubit(qTokenBorrowed, qTokenCollateral, borrow, amount);\\n    }\\n\\n    function autoLiquidate(address account) external onlyWhitelisted nonReentrant {\\n        (uint collateralInUSD, , uint borrowInUSD) = Qore.accountLiquidityOf(account);\\n        require(borrowInUSD > collateralInUSD, \\\"QLiquidation: Insufficient shortfall\\\");\\n\\n        (address qTokenBorrowed, address qTokenCollateral, uint liquidateAmount) = _getTargetMarkets(account);\\n        _flashloanQubit(qTokenBorrowed, qTokenCollateral, account, liquidateAmount);\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _liquidate(address qTokenBorrowed, address qTokenCollateral, address borrower, uint amount) private {\\n        uint qTokenCollateralBalance = IQToken(qTokenCollateral).balanceOf(address(this));\\n        if (IQToken(qTokenBorrowed).underlying() == WBNB) {\\n            Qore.liquidateBorrow{value : amount}(qTokenBorrowed, qTokenCollateral, borrower, 0);\\n        } else {\\n            Qore.liquidateBorrow(qTokenBorrowed, qTokenCollateral, borrower, amount);\\n        }\\n\\n        _redeemToken(qTokenCollateral, IQToken(qTokenCollateral).balanceOf(address(this)).sub(qTokenCollateralBalance));\\n    }\\n\\n    function _getTargetMarkets(address account) private view returns (address qTokenBorrowed, address qTokenCollateral, uint liquidateAmount) {\\n        uint maxSupplied;\\n        uint maxBorrowed;\\n        address[] memory markets = Qore.marketListOf(account);\\n        for (uint i = 0; i < markets.length; i++) {\\n            uint borrow = IQToken(markets[i]).borrowBalanceOf(account);\\n            uint supply = IQToken(markets[i]).underlyingBalanceOf(account);\\n\\n            if (borrow > 0 && borrow > maxBorrowed) {\\n                maxBorrowed = borrow;\\n                qTokenBorrowed = markets[i];\\n            }\\n\\n            uint collateralFactor = Qore.marketInfoOf(markets[i]).collateralFactor;\\n            if (collateralFactor > 0 && supply > 0 && supply > maxSupplied) {\\n                maxSupplied = supply;\\n                qTokenCollateral = markets[i];\\n            }\\n        }\\n        liquidateAmount = _getAvailableAmounts(qTokenBorrowed, qTokenCollateral, maxBorrowed, maxSupplied);\\n        return (qTokenBorrowed, qTokenCollateral, liquidateAmount);\\n    }\\n\\n    function _getAvailableAmounts(address qTokenBorrowed, address qTokenCollateral, uint borrowAmount, uint supplyAmount) private view returns (uint closeAmount) {\\n        uint borrowPrice = PriceCalculatorBSC.getUnderlyingPrice(qTokenBorrowed);\\n        uint supplyPrice = PriceCalculatorBSC.getUnderlyingPrice(qTokenCollateral);\\n        require(supplyPrice != 0 && borrowPrice != 0, \\\"QLiquidation: price error\\\");\\n\\n        uint borrowValue = borrowPrice.mul(borrowAmount).div(1e18);\\n        uint supplyValue = supplyPrice.mul(supplyAmount).div(1e18);\\n\\n        uint maxCloseValue = borrowValue.mul(Qore.closeFactor()).div(1e18);\\n        uint maxCloseValueWithIncentive = maxCloseValue.mul(110).div(100);\\n        return closeAmount = maxCloseValueWithIncentive < supplyValue ? maxCloseValue.mul(1e18).div(borrowPrice)\\n                                                                      : supplyValue.mul(90).div(100).mul(1e18).div(borrowPrice);\\n    }\\n\\n    function _flashloanQubit(address _qTokenBorrowed, address _qTokenCollateral, address borrower, uint amount) private {\\n        address[] memory _markets = new address[](1);\\n        _markets[0] = _qTokenBorrowed;\\n\\n        uint[] memory _amounts = new uint[](1);\\n        _amounts[0] = amount;\\n//        Qore.flashLoan(address(this), _markets, _amounts,\\n//            abi.encode(_qTokenBorrowed, _qTokenCollateral, borrower, amount)\\n//        );\\n    }\\n\\n    function _redeemToken(address _qTokenCollateral, uint amount) private returns (uint) {\\n        IBEP20 collateralToken = IBEP20(IQToken(_qTokenCollateral).underlying());\\n\\n        uint collateralBalance = collateralToken.balanceOf(address(this));\\n        Qore.redeemToken(_qTokenCollateral, amount);\\n\\n        return collateralToken.balanceOf(address(this)).sub(collateralBalance);\\n    }\\n\\n    function _swapToMDX(address _qTokenCollateral, uint repayAmount) private {\\n        address collateralToken = IQToken(_qTokenCollateral).underlying();\\n        if (collateralToken == WBNB) {\\n            address[] memory path = new address[](2);\\n            path[0] = WBNB;\\n            path[1] = MDX;\\n            ROUTER_MDEX.swapETHForExactTokens{value : address(this).balance}(repayAmount, path, address(this), block.timestamp);\\n        } else {\\n            uint WBNBamount;\\n            {\\n                address[] memory path = new address[](2);\\n                path[0] = WBNB;\\n                path[1] = MDX;\\n                WBNBamount = ROUTER_MDEX.getAmountsIn(repayAmount, path)[0];\\n            }\\n\\n            if (_routePairAddresses[collateralToken] != address(0)) {\\n                address[] memory path = new address[](3);\\n                path[0] = collateralToken;\\n                path[1] = _routePairAddresses[collateralToken];\\n                path[2] = WBNB;\\n\\n                ROUTER.swapTokensForExactTokens(WBNBamount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp)[2];\\n            } else {\\n                address[] memory path = new address[](2);\\n                path[0] = collateralToken;\\n                path[1] = WBNB;\\n\\n                ROUTER.swapTokensForExactTokens(WBNBamount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp)[1];\\n            }\\n\\n            address[] memory path = new address[](2);\\n            path[0] = WBNB;\\n            path[1] = MDX;\\n\\n            ROUTER_MDEX.swapTokensForExactTokens(repayAmount, IBEP20(WBNB).balanceOf(address(this)), path, address(this), block.timestamp);\\n        }\\n    }\\n\\n    function _swapToRepayFlashloan(address _qTokenCollateral, address _qTokenBorrowed, uint repayAmount) private {\\n        address collateralToken = IQToken(_qTokenCollateral).underlying();\\n        address borrowedToken = IQToken(_qTokenBorrowed).underlying();\\n\\n        if (collateralToken == WBNB) {\\n            if (_routePairAddresses[borrowedToken] != address(0)) {\\n                address[] memory path = new address[](3);\\n                path[0] = WBNB;\\n                path[1] = _routePairAddresses[borrowedToken];\\n                path[2] = borrowedToken;\\n                ROUTER.swapETHForExactTokens{value : address(this).balance}(repayAmount, path, address(this), block.timestamp);\\n            }\\n            else {\\n                address[] memory path = new address[](2);\\n                path[0] = WBNB;\\n                path[1] = borrowedToken;\\n                ROUTER.swapETHForExactTokens{value : address(this).balance}(repayAmount, path, address(this), block.timestamp);\\n            }\\n        } else if (borrowedToken == WBNB) {\\n            if (_routePairAddresses[collateralToken] != address(0)) {\\n                address[] memory path = new address[](3);\\n                path[0] = collateralToken;\\n                path[1] = _routePairAddresses[collateralToken];\\n                path[2] = WBNB;\\n\\n                ROUTER.swapTokensForExactTokens(repayAmount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp);\\n            } else {\\n                address[] memory path = new address[](2);\\n                path[0] = collateralToken;\\n                path[1] = WBNB;\\n\\n                ROUTER.swapTokensForExactTokens(repayAmount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp);\\n            }\\n        }\\n        else {\\n            if ( (borrowedToken == ETH && (collateralToken == USDC || collateralToken == BTC)) ||\\n                (collateralToken == ETH && (borrowedToken == USDC || borrowedToken == BTC)) ||\\n                (borrowedToken == BTC && (collateralToken == ETH || collateralToken == BUSD)) ||\\n                (collateralToken == BTC && (borrowedToken == ETH || borrowedToken == BUSD)) ||\\n                (borrowedToken == DAI && collateralToken == BUSD) || (collateralToken == DAI && borrowedToken == BUSD) ||\\n                (borrowedToken == BUSD && (collateralToken == CAKE || collateralToken == BTC || collateralToken == USDT || collateralToken == USDC)) ||\\n                (collateralToken == BUSD && (borrowedToken == CAKE || borrowedToken == BTC || borrowedToken == USDT || borrowedToken == USDC)) ||\\n                (borrowedToken == USDT && (collateralToken == BUSD || collateralToken == CAKE || collateralToken == USDC)) ||\\n                (collateralToken == USDT && (borrowedToken == BUSD || borrowedToken == CAKE || borrowedToken == USDC)) ||\\n                (borrowedToken == USDC && (collateralToken == ETH || collateralToken == BUSD || collateralToken == USDT)) ||\\n                (collateralToken == USDC && (borrowedToken == ETH || borrowedToken == BUSD || borrowedToken == USDT)) ) {\\n                address[] memory path = new address[](2);\\n                path[0] = collateralToken;\\n                path[1] = borrowedToken;\\n\\n                ROUTER.swapTokensForExactTokens(repayAmount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp);\\n            } else {\\n                // first swap to WBNB,\\n                uint WBNBamount;\\n                if (_routePairAddresses[borrowedToken] != address(0)) {\\n                    address[] memory path = new address[](3);\\n                    path[0] = WBNB;\\n                    path[1] = _routePairAddresses[borrowedToken];\\n                    path[2] = borrowedToken;\\n\\n                    WBNBamount = ROUTER.getAmountsIn(repayAmount, path)[0];\\n                } else {\\n                    address[] memory path = new address[](2);\\n                    path[0] = WBNB;\\n                    path[1] = borrowedToken;\\n\\n                    WBNBamount = ROUTER.getAmountsIn(repayAmount, path)[0];\\n                }\\n\\n                if (_routePairAddresses[collateralToken] != address(0)) {\\n                    address[] memory path = new address[](3);\\n                    path[0] = collateralToken;\\n                    path[1] = _routePairAddresses[collateralToken];\\n                    path[2] = WBNB;\\n\\n                    ROUTER.swapTokensForExactTokens(WBNBamount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp);\\n                } else {\\n                    address[] memory path = new address[](2);\\n                    path[0] = collateralToken;\\n                    path[1] = WBNB;\\n\\n                    ROUTER.swapTokensForExactTokens(WBNBamount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp);\\n                }\\n\\n                // then swap WBNB to borrowedToken\\n                if (_routePairAddresses[borrowedToken] != address(0)) {\\n                    address[] memory path = new address[](3);\\n                    path[0] = WBNB;\\n                    path[1] = _routePairAddresses[borrowedToken];\\n                    path[2] = borrowedToken;\\n\\n                    ROUTER.swapTokensForExactTokens(repayAmount, IBEP20(WBNB).balanceOf(address(this)), path, address(this), block.timestamp);\\n                } else {\\n                    address[] memory path = new address[](2);\\n                    path[0] = WBNB;\\n                    path[1] = borrowedToken;\\n\\n                    ROUTER.swapTokensForExactTokens(repayAmount, IBEP20(WBNB).balanceOf(address(this)), path, address(this), block.timestamp);\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/liquidation/QLiquidationTestnet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"../library/SafeToken.sol\\\";\\nimport \\\"../library/WhitelistUpgradeable.sol\\\";\\n\\nimport \\\"../interfaces/IBEP20.sol\\\";\\nimport \\\"../interfaces/ISwapCallee.sol\\\";\\nimport \\\"../interfaces/IPancakePair.sol\\\";\\nimport \\\"../interfaces/IPancakeRouter02.sol\\\";\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../interfaces/IQToken.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../interfaces/IPriceCalculator.sol\\\";\\n\\n\\ncontract QLiquidationTestnet is ISwapCallee, WhitelistUpgradeable, ReentrancyGuardUpgradeable {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANTS ============= */\\n\\n    IQore public constant Qore = IQore(0x995cCA2cD0C269fdEe7d057A8A7aaA1586ecEf51);\\n    IPriceCalculator public constant PriceCalculatorBSC = IPriceCalculator(0x20E5E35ba29dC3B540a1aee781D0814D5c77Bce6);\\n\\n    IPancakeRouter02 private constant ROUTER = IPancakeRouter02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3);\\n\\n    address private constant qBNB = 0x14fA6A83A08B763B8A430e1fAeafe009D266F280;\\n//    address private constant qETH = 0xAf9A0488D21A3cec2012f3E6Fe632B65Aa6Ea61D;\\n    address private constant qUSDT = 0x93848E23F0a70891A67a98a6CEBb47Fa55A51508;\\n//    address private constant qDAI = 0xfc743504c7FF5526e3Ba97617F6e6Bf8fD8cfdF0;\\n    address private constant qBUSD = 0x5B8BA405976b3A798F47DAE502e1982502aF64c5;\\n    address private constant qQBT = 0x2D076EC4FE501927c5bea2A5bA8902e5e7A9B727;\\n\\n//    address private constant BUNNY_BNB = 0x5aFEf8567414F29f0f927A0F2787b188624c10E2;\\n    address private constant WBNB_BUSD = 0xe0e92035077c39594793e61802a350347c320cf2;\\n\\n    address private constant WBNB = 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd;\\n\\n//    address private constant ETH = 0x8BaBbB98678facC7342735486C851ABD7A0d17Ca;\\n//    address private constant DAI = 0x8a9424745056Eb399FD19a0EC26A14316684e274;  // BUSD pair\\n    address private constant BUSD = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7;\\n    address private constant USDT = 0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684;\\n    address private constant QBT = 0xF523e4478d909968090a232eB380E2dd6f802518;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(address => address) private _routePairAddresses;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    receive() external payable {}\\n\\n    function initialize() external initializer {\\n        __WhitelistUpgradeable_init();\\n        __ReentrancyGuard_init();\\n\\n        for (uint i = 0; i < underlyingTokens().length; i++) {\\n            address underlying = underlyingTokens()[i];\\n            IBEP20(underlying).approve(address(ROUTER), uint(- 1));\\n            IBEP20(underlying).approve(qTokens()[i], uint(- 1));\\n        }\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function underlyingTokens() public pure returns (address[4] memory) {\\n        return [WBNB, BUSD, USDT, QBT];\\n    }\\n\\n    function qTokens() public pure returns (address[4] memory) {\\n        return [qBNB, qBUSD, qUSDT, qQBT];\\n    }\\n\\n    /* ========== RESTRICTED FUNCTION ========== */\\n\\n    function setRoutePairAddress(address token, address route) external onlyOwner {\\n        require(route != address(0), \\\"QLiquidationTestnet: invalid route address\\\");\\n        _routePairAddresses[token] = route;\\n    }\\n\\n    function approveTokenForRouter(address token) external onlyOwner {\\n        IBEP20(token).approve(address(ROUTER), uint(- 1));\\n    }\\n\\n    /* ========== Pancake Callback FUNCTION ========== */\\n\\n    function pancakeCall(address, uint, uint, bytes calldata data) external override {\\n        require(msg.sender == WBNB_BUSD, \\\"QLiquidation: only used for WBNB_BUSD\\\");\\n        (address qTokenBorrowed, address qTokenCollateral, address borrower, uint loanBalance, uint amount) = abi.decode(data, (address, address, address, uint, uint));\\n\\n        uint liquidateBalance = Math.min(_swapWBNBtoBorrowToken(qTokenBorrowed, loanBalance), amount);\\n        _liquidate(qTokenBorrowed, qTokenCollateral, borrower, liquidateBalance);\\n\\n        _repayToSwap(\\n            qTokenCollateral,\\n            loanBalance.mul(10000).div(9975).add(1),\\n            msg.sender\\n        );\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function liquidate(address qTokenBorrowed, address qTokenCollateral, address borrow, uint amount) external onlyWhitelisted nonReentrant {\\n        _flashloan(qTokenBorrowed, qTokenCollateral, borrow, amount);\\n    }\\n\\n    function autoLiquidate(address account) external onlyWhitelisted nonReentrant {\\n        (uint collateralInUSD, , uint borrowInUSD) = Qore.accountLiquidityOf(account);\\n        require(borrowInUSD > collateralInUSD, \\\"QLiquidation: Insufficient shortfall\\\");\\n\\n        (address qTokenBorrowed, address qTokenCollateral, uint liquidateAmount) = _getTargetMarkets(account);\\n        _flashloan(qTokenBorrowed, qTokenCollateral, account, liquidateAmount);\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _liquidate(address qTokenBorrowed, address qTokenCollateral, address borrower, uint amount) private {\\n        uint qTokenCollateralBalance = IQToken(qTokenCollateral).balanceOf(address(this));\\n\\n        if (IQToken(qTokenBorrowed).underlying() == WBNB) {\\n            IWETH(WBNB).withdraw(amount);\\n            Qore.liquidateBorrow{value : amount}(qTokenBorrowed, qTokenCollateral, borrower, 0);\\n        } else {\\n            Qore.liquidateBorrow(qTokenBorrowed, qTokenCollateral, borrower, amount);\\n        }\\n\\n        _redeemToken(qTokenCollateral, IQToken(qTokenCollateral).balanceOf(address(this)).sub(qTokenCollateralBalance));\\n    }\\n\\n    function _getTargetMarkets(address account) private view returns (address qTokenBorrowed, address qTokenCollateral, uint liquidateAmount) {\\n        uint maxSupplied;\\n        uint maxBorrowed;\\n        address[] memory markets = Qore.marketListOf(account);\\n        for (uint i = 0; i < markets.length; i++) {\\n            uint borrow = IQToken(markets[i]).borrowBalanceOf(account);\\n            uint supply = IQToken(markets[i]).underlyingBalanceOf(account);\\n\\n            if (borrow > 0 && borrow > maxBorrowed) {\\n                maxBorrowed = borrow;\\n                qTokenBorrowed = markets[i];\\n            }\\n\\n            uint collateralFactor = Qore.marketInfoOf(markets[i]).collateralFactor;\\n            if (collateralFactor > 0 && supply > 0 && supply > maxSupplied) {\\n                maxSupplied = supply;\\n                qTokenCollateral = markets[i];\\n            }\\n        }\\n        liquidateAmount = _getAvailableAmounts(qTokenBorrowed, qTokenCollateral, maxBorrowed, maxSupplied);\\n        return (qTokenBorrowed, qTokenCollateral, liquidateAmount);\\n    }\\n\\n    function _getAvailableAmounts(address qTokenBorrowed, address qTokenCollateral, uint borrowAmount, uint supplyAmount) private view returns (uint closeAmount) {\\n        uint borrowPrice = PriceCalculatorBSC.getUnderlyingPrice(qTokenBorrowed);\\n        uint supplyPrice = PriceCalculatorBSC.getUnderlyingPrice(qTokenCollateral);\\n        require(supplyPrice != 0 && borrowPrice != 0, \\\"QLiquidation: price error\\\");\\n\\n        uint borrowValue = borrowPrice.mul(borrowAmount).div(1e18);\\n        uint supplyValue = supplyPrice.mul(supplyAmount).div(1e18);\\n\\n        uint maxCloseValue = borrowValue.mul(Qore.closeFactor()).div(1e18);\\n        uint maxCloseValueWithIncentive = maxCloseValue.mul(110).div(100);\\n        return closeAmount = maxCloseValueWithIncentive < supplyValue ? maxCloseValue.mul(1e18).div(borrowPrice)\\n                                                                      : supplyValue.mul(90).div(100).mul(1e18).div(borrowPrice);\\n    }\\n\\n    function _swapWBNBtoBorrowToken(address _qTokenBorrowed, uint loanBalance) private returns (uint liquidateBalance) {\\n        address underlying = IQToken(_qTokenBorrowed).underlying();\\n        liquidateBalance = 0;\\n        if (underlying == WBNB) {\\n            liquidateBalance = loanBalance;\\n        } else {\\n            uint before = IBEP20(underlying).balanceOf(address(this));\\n\\n            address[] memory path = new address[](2);\\n            path[0] = WBNB;\\n            path[1] = underlying;\\n\\n            ROUTER.swapExactTokensForTokens(loanBalance, 0, path, address(this), block.timestamp);\\n            liquidateBalance = IBEP20(underlying).balanceOf(address(this)).sub(before);\\n        }\\n    }\\n\\n    function _flashloan(address _qTokenBorrowed, address _qTokenCollateral, address borrower, uint amount) private {\\n        address _underlying = IQToken(_qTokenBorrowed).underlying();\\n\\n        uint borrowBalance;\\n        if (_underlying == WBNB) {\\n            borrowBalance = amount;\\n        } else {\\n            address[] memory path = new address[](2);\\n            path[0] = WBNB;\\n            path[1] = _underlying;\\n\\n            borrowBalance = ROUTER.getAmountsIn(amount, path)[0];\\n        }\\n\\n        IPancakePair(WBNB_BUSD).swap(\\n            0, borrowBalance, address(this),\\n            abi.encode(_qTokenBorrowed, _qTokenCollateral, borrower, borrowBalance, amount)\\n        );\\n\\n    }\\n\\n    function _redeemToken(address _qTokenCollateral, uint amount) private returns (uint) {\\n        IBEP20 collateralToken = IBEP20(IQToken(_qTokenCollateral).underlying());\\n\\n        uint collateralBalance = collateralToken.balanceOf(address(this));\\n        Qore.redeemToken(_qTokenCollateral, amount);\\n\\n        if (address(collateralToken) == WBNB) {\\n            IWETH(WBNB).deposit{value : address(this).balance}();\\n        }\\n\\n        return collateralToken.balanceOf(address(this)).sub(collateralBalance);\\n    }\\n\\n    function _repayToSwap(address _qTokenCollateral, uint repayAmount, address to) private {\\n        address collateralToken = IQToken(_qTokenCollateral).underlying();\\n\\n        if (collateralToken != WBNB) {\\n            address[] memory path = new address[](2);\\n            path[0] = collateralToken;\\n            path[1] = WBNB;\\n\\n            ROUTER.swapTokensForExactTokens(repayAmount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp);\\n        }\\n\\n        require(IBEP20(WBNB).balanceOf(address(this)) >= repayAmount, \\\"QLiquidation: can't repay to pancake\\\");\\n        WBNB.safeTransfer(to, repayAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwapCallee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface ISwapCallee {\\n    function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/liquidation/QLiquidation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"../library/SafeToken.sol\\\";\\nimport \\\"../library/WhitelistUpgradeable.sol\\\";\\n\\nimport \\\"../interfaces/IBEP20.sol\\\";\\nimport \\\"../interfaces/ISwapCallee.sol\\\";\\nimport \\\"../interfaces/IPancakePair.sol\\\";\\nimport \\\"../interfaces/IPancakeRouter02.sol\\\";\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../interfaces/IQToken.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../interfaces/IPriceCalculator.sol\\\";\\n\\n\\ncontract QLiquidation is ISwapCallee, WhitelistUpgradeable, ReentrancyGuardUpgradeable {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANTS ============= */\\n\\n    IQore public constant Qore = IQore(0xF70314eb9c7Fe7D88E6af5aa7F898b3A162dcd48);\\n    IPriceCalculator public constant PriceCalculatorBSC = IPriceCalculator(0x20E5E35ba29dC3B540a1aee781D0814D5c77Bce6);\\n\\n    IPancakeRouter02 private constant ROUTER = IPancakeRouter02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n    IPancakeRouter02 private constant ROUTER_MDEX = IPancakeRouter02(0x7DAe51BD3E3376B8c7c4900E9107f12Be3AF1bA8);\\n\\n    address private constant qBNB = 0xbE1B5D17777565D67A5D2793f879aBF59Ae5D351;\\n    address private constant qBTC = 0xd055D32E50C57B413F7c2a4A052faF6933eA7927;\\n    address private constant qETH = 0xb4b77834C73E9f66de57e6584796b034D41Ce39A;\\n    address private constant qUSDC = 0x1dd6E079CF9a82c91DaF3D8497B27430259d32C2;\\n    address private constant qUSDT = 0x99309d2e7265528dC7C3067004cC4A90d37b7CC3;\\n    address private constant qDAI = 0x474010701715658fC8004f51860c90eEF4584D2B;\\n    address private constant qBUSD = 0xa3A155E76175920A40d2c8c765cbCB1148aeB9D1;\\n    address private constant qCAKE = 0xaB9eb4AE93B705b0A74d3419921bBec97F51b264;\\n    address private constant qQBT = 0xcD2CD343CFbe284220677C78A08B1648bFa39865;\\n    address private constant qMDX = 0xFF858dB0d6aA9D3fCA13F6341a1693BE4416A550;\\n    address private constant qBUNNY = 0xceB82D224a531525C838BF0ACdc33B2C8d550c47;\\n\\n    address private constant BUNNY_BNB = 0x5aFEf8567414F29f0f927A0F2787b188624c10E2;\\n    address private constant CAKE_BNB = 0x0eD7e52944161450477ee417DE9Cd3a859b14fD0;\\n\\n    address private constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address private constant BTC = 0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c;\\n    address private constant ETH = 0x2170Ed0880ac9A755fd29B2688956BD959F933F8;\\n    address private constant DAI = 0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3;  // BUSD pair\\n    address private constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n    address private constant USDT = 0x55d398326f99059fF775485246999027B3197955;\\n    address private constant USDC = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d; // BUSD pair\\n    address private constant CAKE = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\\n    address private constant QBT = 0x17B7163cf1Dbd286E262ddc68b553D899B93f526;\\n    address private constant MDX = 0x9C65AB58d8d978DB963e63f2bfB7121627e3a739;\\n    address private constant BUNNY = 0xC9849E6fdB743d08fAeE3E34dd2D1bc69EA11a51;\\n\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(address => address) private _routePairAddresses;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    receive() external payable {}\\n\\n    function initialize() external initializer {\\n        __WhitelistUpgradeable_init();\\n        __ReentrancyGuard_init();\\n\\n        for (uint i = 0; i < underlyingTokens().length; i++) {\\n            address underlying = underlyingTokens()[i];\\n            if (underlying != MDX && underlying != QBT) {\\n                IBEP20(underlying).approve(address(ROUTER), uint(- 1));\\n            }\\n            IBEP20(underlying).approve(qTokens()[i], uint(- 1));\\n        }\\n\\n        IBEP20(WBNB).approve(address(ROUTER_MDEX), uint(- 1));\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function underlyingTokens() public pure returns (address[11] memory) {\\n        return [WBNB, BTC, ETH, DAI, USDC, BUSD, USDT, CAKE, QBT, MDX, BUNNY];\\n    }\\n\\n    function qTokens() public pure returns (address[11] memory) {\\n        return [qBNB, qBTC, qETH, qDAI, qUSDC, qBUSD, qUSDT, qCAKE, qQBT, qMDX, qBUNNY];\\n    }\\n\\n    /* ========== RESTRICTED FUNCTION ========== */\\n\\n    function setRoutePairAddress(address token, address route) external onlyOwner {\\n        require(route != address(0), \\\"QLiquidation: invalid route address\\\");\\n        _routePairAddresses[token] = route;\\n    }\\n\\n    function approveTokenForRouter(address token) external onlyOwner {\\n        IBEP20(token).approve(address(ROUTER), uint(- 1));\\n    }\\n\\n    function approveToken(address token) external onlyOwner {\\n        for (uint i = 0; i < underlyingTokens().length; i++) {\\n            address underlying = underlyingTokens()[i];\\n            if (underlying == token) {\\n                IBEP20(underlying).approve(address(ROUTER), uint(- 1));\\n                IBEP20(underlying).approve(qTokens()[i], uint(- 1));\\n            }\\n        }\\n    }\\n\\n    /* ========== Pancake Callback FUNCTION ========== */\\n\\n    function pancakeCall(address, uint, uint, bytes calldata data) external override {\\n        require(msg.sender == BUNNY_BNB || msg.sender == CAKE_BNB, \\\"QLiquidation: only used for BUNNY_BNB or CAKE_BNB\\\");\\n        (address qTokenBorrowed, address qTokenCollateral, address borrower, uint loanBalance, uint amount) = abi.decode(data, (address, address, address, uint, uint));\\n\\n        uint liquidateBalance = Math.min(_swapWBNBtoBorrowToken(qTokenBorrowed, loanBalance), amount);\\n        _liquidate(qTokenBorrowed, qTokenCollateral, borrower, liquidateBalance);\\n\\n        _repayToSwap(\\n            qTokenCollateral,\\n            loanBalance.mul(10000).div(9975).add(1),\\n            msg.sender\\n        );\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function liquidate(address qTokenBorrowed, address qTokenCollateral, address borrow, uint amount) external onlyWhitelisted nonReentrant {\\n        _flashloan(qTokenBorrowed, qTokenCollateral, borrow, amount);\\n    }\\n\\n    function autoLiquidate(address account) external onlyWhitelisted nonReentrant {\\n        (uint collateralInUSD, , uint borrowInUSD) = Qore.accountLiquidityOf(account);\\n        require(borrowInUSD > collateralInUSD, \\\"QLiquidation: Insufficient shortfall\\\");\\n\\n        (address qTokenBorrowed, address qTokenCollateral, uint liquidateAmount) = _getTargetMarkets(account);\\n        _flashloan(qTokenBorrowed, qTokenCollateral, account, liquidateAmount);\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _liquidate(address qTokenBorrowed, address qTokenCollateral, address borrower, uint amount) private {\\n        uint qTokenCollateralBalance = IQToken(qTokenCollateral).balanceOf(address(this));\\n        if (IQToken(qTokenBorrowed).underlying() == WBNB) {\\n            IWETH(WBNB).withdraw(amount);\\n            Qore.liquidateBorrow{value : amount}(qTokenBorrowed, qTokenCollateral, borrower, 0);\\n        } else {\\n            Qore.liquidateBorrow(qTokenBorrowed, qTokenCollateral, borrower, amount);\\n        }\\n\\n        _redeemToken(qTokenCollateral, IQToken(qTokenCollateral).balanceOf(address(this)).sub(qTokenCollateralBalance));\\n    }\\n\\n    function _getTargetMarkets(address account) private view returns (address qTokenBorrowed, address qTokenCollateral, uint liquidateAmount) {\\n        uint maxSupplied;\\n        uint maxBorrowed;\\n        address[] memory markets = Qore.marketListOf(account);\\n        for (uint i = 0; i < markets.length; i++) {\\n            uint borrow = IQToken(markets[i]).borrowBalanceOf(account);\\n            uint supply = IQToken(markets[i]).underlyingBalanceOf(account);\\n\\n            if (borrow > 0 && borrow > maxBorrowed) {\\n                maxBorrowed = borrow;\\n                qTokenBorrowed = markets[i];\\n            }\\n\\n            uint collateralFactor = Qore.marketInfoOf(markets[i]).collateralFactor;\\n            if (collateralFactor > 0 && supply > 0 && supply > maxSupplied) {\\n                maxSupplied = supply;\\n                qTokenCollateral = markets[i];\\n            }\\n        }\\n        liquidateAmount = _getAvailableAmounts(qTokenBorrowed, qTokenCollateral, maxBorrowed, maxSupplied);\\n        return (qTokenBorrowed, qTokenCollateral, liquidateAmount);\\n    }\\n\\n    function _getAvailableAmounts(address qTokenBorrowed, address qTokenCollateral, uint borrowAmount, uint supplyAmount) private view returns (uint closeAmount) {\\n        uint borrowPrice = PriceCalculatorBSC.getUnderlyingPrice(qTokenBorrowed);\\n        uint supplyPrice = PriceCalculatorBSC.getUnderlyingPrice(qTokenCollateral);\\n        require(supplyPrice != 0 && borrowPrice != 0, \\\"QLiquidation: price error\\\");\\n\\n        uint borrowValue = borrowPrice.mul(borrowAmount).div(1e18);\\n        uint supplyValue = supplyPrice.mul(supplyAmount).div(1e18);\\n\\n        uint maxCloseValue = borrowValue.mul(Qore.closeFactor()).div(1e18);\\n        uint maxCloseValueWithIncentive = maxCloseValue.mul(110).div(100);\\n        return closeAmount = maxCloseValueWithIncentive < supplyValue ? maxCloseValue.mul(1e18).div(borrowPrice)\\n                                                                      : supplyValue.mul(90).div(100).mul(1e18).div(borrowPrice);\\n    }\\n\\n    function _swapWBNBtoBorrowToken(address _qTokenBorrowed, uint loanBalance) private returns (uint liquidateBalance) {\\n        address underlying = IQToken(_qTokenBorrowed).underlying();\\n        liquidateBalance = 0;\\n        if (underlying == WBNB) {\\n            liquidateBalance = loanBalance;\\n        } else if (underlying == MDX) {\\n            uint before = IBEP20(underlying).balanceOf(address(this));\\n\\n            address[] memory path = new address[](3);\\n            path[0] = WBNB;\\n            path[1] = BUSD;\\n            path[2] = underlying;\\n\\n            ROUTER_MDEX.swapExactTokensForTokens(loanBalance, 0, path, address(this), block.timestamp);\\n            liquidateBalance = IBEP20(underlying).balanceOf(address(this)).sub(before);\\n        } else {\\n            uint before = IBEP20(underlying).balanceOf(address(this));\\n\\n            address[] memory path = new address[](2);\\n            path[0] = WBNB;\\n            path[1] = underlying;\\n\\n            ROUTER.swapExactTokensForTokens(loanBalance, 0, path, address(this), block.timestamp);\\n            liquidateBalance = IBEP20(underlying).balanceOf(address(this)).sub(before);\\n        }\\n    }\\n\\n    function _flashloan(address _qTokenBorrowed, address _qTokenCollateral, address borrower, uint amount) private {\\n        address _underlying = IQToken(_qTokenBorrowed).underlying();\\n\\n        uint borrowBalance;\\n        if (_underlying == WBNB) {\\n            borrowBalance = amount;\\n        } else if (_underlying == MDX) {\\n            address[] memory path = new address[](3);\\n            path[0] = WBNB;\\n            path[1] = BUSD;\\n            path[2] = _underlying;\\n\\n            borrowBalance = ROUTER_MDEX.getAmountsIn(amount, path)[0];\\n        } else if (_routePairAddresses[_underlying] != address(0)) {\\n            address[] memory path = new address[](3);\\n            path[0] = WBNB;\\n            path[1] = _routePairAddresses[_underlying];\\n            path[2] = _underlying;\\n\\n            borrowBalance = ROUTER.getAmountsIn(amount, path)[0];\\n        } else {\\n            address[] memory path = new address[](2);\\n            path[0] = WBNB;\\n            path[1] = _underlying;\\n\\n            borrowBalance = ROUTER.getAmountsIn(amount, path)[0];\\n        }\\n\\n        address flashLoanPool = _qTokenBorrowed == qCAKE || _qTokenCollateral == qCAKE ? BUNNY_BNB : CAKE_BNB;\\n\\n        IPancakePair(flashLoanPool).swap(\\n            borrowBalance, 0, address(this),\\n            abi.encode(_qTokenBorrowed, _qTokenCollateral, borrower, borrowBalance, amount)\\n        );\\n\\n    }\\n\\n    function _redeemToken(address _qTokenCollateral, uint amount) private returns (uint) {\\n        IBEP20 collateralToken = IBEP20(IQToken(_qTokenCollateral).underlying());\\n\\n        uint collateralBalance = collateralToken.balanceOf(address(this));\\n        Qore.redeemToken(_qTokenCollateral, amount);\\n\\n        if (address(collateralToken) == WBNB) {\\n            IWETH(WBNB).deposit{value : address(this).balance}();\\n        }\\n\\n        return collateralToken.balanceOf(address(this)).sub(collateralBalance);\\n    }\\n\\n    function _repayToSwap(address _qTokenCollateral, uint repayAmount, address to) private {\\n        address collateralToken = IQToken(_qTokenCollateral).underlying();\\n\\n        if (collateralToken != WBNB && _routePairAddresses[collateralToken] != address(0)) {\\n            address[] memory path = new address[](3);\\n            path[0] = collateralToken;\\n            path[1] = _routePairAddresses[collateralToken];\\n            path[2] = WBNB;\\n\\n            ROUTER.swapTokensForExactTokens(repayAmount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp);\\n        } else if (collateralToken != WBNB) {\\n            address[] memory path = new address[](2);\\n            path[0] = collateralToken;\\n            path[1] = WBNB;\\n\\n            ROUTER.swapTokensForExactTokens(repayAmount, IBEP20(collateralToken).balanceOf(address(this)), path, address(this), block.timestamp);\\n        }\\n\\n        require(IBEP20(WBNB).balanceOf(address(this)) >= repayAmount, \\\"QLiquidation: can't repay to pancake\\\");\\n        WBNB.safeTransfer(to, repayAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/QubitLocker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"../interfaces/IQubitLocker.sol\\\";\\nimport \\\"../library/WhitelistUpgradeable.sol\\\";\\nimport \\\"../library/SafeToken.sol\\\";\\n\\ncontract QubitLocker is IQubitLocker, WhitelistUpgradeable, ReentrancyGuardUpgradeable {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANTS ============= */\\n\\n    address public constant QBT = 0x17B7163cf1Dbd286E262ddc68b553D899B93f526;\\n\\n    uint public constant LOCK_UNIT_BASE = 7 days;\\n    uint public constant LOCK_UNIT_MAX = 2 * 365 days;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(address => uint) public balances;\\n    mapping(address => uint) public expires;\\n\\n    uint public override totalBalance;\\n\\n    uint private _lastTotalScore;\\n    uint private _lastSlope;\\n    uint private _lastTimestamp;\\n    mapping(uint => uint) private _slopeChanges;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() external initializer {\\n        __WhitelistUpgradeable_init();\\n        __ReentrancyGuard_init();\\n        _lastTimestamp = block.timestamp;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function balanceOf(address account) external view override returns (uint) {\\n        return balances[account];\\n    }\\n\\n    function expiryOf(address account) external view override returns (uint) {\\n        return expires[account];\\n    }\\n\\n    function availableOf(address account) external view override returns (uint) {\\n        return expires[account] < block.timestamp ? balances[account] : 0;\\n    }\\n\\n    function totalScore() public view override returns (uint score, uint slope) {\\n        score = _lastTotalScore;\\n        slope = _lastSlope;\\n\\n        uint prevTimestamp = _lastTimestamp;\\n        uint nextTimestamp = truncateExpiry(_lastTimestamp).add(LOCK_UNIT_BASE);\\n        while (nextTimestamp < block.timestamp) {\\n            uint deltaScore = nextTimestamp.sub(prevTimestamp).mul(slope);\\n            score = score < deltaScore ? 0 : score.sub(deltaScore);\\n            slope = slope.sub(_slopeChanges[nextTimestamp]);\\n\\n            prevTimestamp = nextTimestamp;\\n            nextTimestamp = nextTimestamp.add(LOCK_UNIT_BASE);\\n        }\\n\\n        uint deltaScore = block.timestamp > prevTimestamp ? block.timestamp.sub(prevTimestamp).mul(slope) : 0;\\n        score = score > deltaScore ? score.sub(deltaScore) : 0;\\n    }\\n\\n    /**\\n     * @notice Calculate time-weighted balance of account\\n     * @param account Account of which the balance will be calculated\\n     */\\n    function scoreOf(address account) external view override returns (uint) {\\n        if (expires[account] < block.timestamp) return 0;\\n        return expires[account].sub(block.timestamp).mul(balances[account].div(LOCK_UNIT_MAX));\\n    }\\n\\n    function truncateExpiry(uint time) public pure returns (uint) {\\n        return time.div(LOCK_UNIT_BASE).mul(LOCK_UNIT_BASE);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function deposit(uint amount, uint expiry) external override nonReentrant {\\n        require(amount > 0, \\\"QubitLocker: invalid amount\\\");\\n\\n        expiry = balances[msg.sender] == 0 ? truncateExpiry(expiry) : expires[msg.sender];\\n        require(block.timestamp < expiry && expiry <= block.timestamp + LOCK_UNIT_MAX, \\\"QubitLocker: invalid expiry\\\");\\n\\n        _slopeChanges[expiry] = _slopeChanges[expiry].add(amount.div(LOCK_UNIT_MAX));\\n        _updateTotalScore(amount, expiry);\\n\\n        QBT.safeTransferFrom(msg.sender, address(this), amount);\\n        totalBalance = totalBalance.add(amount);\\n\\n        balances[msg.sender] = balances[msg.sender].add(amount);\\n        expires[msg.sender] = expiry;\\n    }\\n\\n    function extendLock(uint nextExpiry) external override nonReentrant {\\n        uint amount = balances[msg.sender];\\n        require(amount > 0, \\\"QubitLocker: zero balance\\\");\\n\\n        uint prevExpiry = expires[msg.sender];\\n        nextExpiry = truncateExpiry(nextExpiry);\\n        require(block.timestamp < prevExpiry, \\\"QubitLocker: expired lock\\\");\\n        require(\\n            Math.max(prevExpiry, block.timestamp) < nextExpiry && nextExpiry <= block.timestamp + LOCK_UNIT_MAX,\\n            \\\"QubitLocker: invalid expiry time\\\"\\n        );\\n\\n        uint slopeChange = (_slopeChanges[prevExpiry] < amount.div(LOCK_UNIT_MAX))\\n            ? _slopeChanges[prevExpiry]\\n            : amount.div(LOCK_UNIT_MAX);\\n        _slopeChanges[prevExpiry] = _slopeChanges[prevExpiry].sub(slopeChange);\\n        _slopeChanges[nextExpiry] = _slopeChanges[nextExpiry].add(slopeChange);\\n        _updateTotalScoreExtendingLock(amount, prevExpiry, nextExpiry);\\n        expires[msg.sender] = nextExpiry;\\n    }\\n\\n    /**\\n     * @notice Withdraw all tokens for `msg.sender`\\n     * @dev Only possible if the lock has expired\\n     */\\n    function withdraw() external override nonReentrant {\\n        require(balances[msg.sender] > 0 && block.timestamp >= expires[msg.sender], \\\"QubitLocker: invalid state\\\");\\n        _updateTotalScore(0, 0);\\n\\n        uint amount = balances[msg.sender];\\n        totalBalance = totalBalance.sub(amount);\\n        delete balances[msg.sender];\\n        delete expires[msg.sender];\\n        QBT.safeTransfer(msg.sender, amount);\\n    }\\n\\n    function depositBehalf(address account, uint amount, uint expiry) external override onlyWhitelisted nonReentrant {\\n        require(amount > 0, \\\"QubitLocker: invalid amount\\\");\\n\\n        expiry = balances[account] == 0 ? truncateExpiry(expiry) : expires[account];\\n        require(block.timestamp < expiry && expiry <= block.timestamp + LOCK_UNIT_MAX, \\\"QubitLocker: invalid expiry\\\");\\n\\n        _slopeChanges[expiry] = _slopeChanges[expiry].add(amount.div(LOCK_UNIT_MAX));\\n        _updateTotalScore(amount, expiry);\\n\\n        QBT.safeTransferFrom(msg.sender, address(this), amount);\\n        totalBalance = totalBalance.add(amount);\\n\\n        balances[account] = balances[account].add(amount);\\n        expires[account] = expiry;\\n    }\\n\\n    function withdrawBehalf(address account) external override onlyWhitelisted nonReentrant {\\n        require(balances[account] > 0 && block.timestamp >= expires[account], \\\"QubitLocker: invalid state\\\");\\n        _updateTotalScore(0, 0);\\n\\n        uint amount = balances[account];\\n        totalBalance = totalBalance.sub(amount);\\n        delete balances[account];\\n        delete expires[account];\\n        QBT.safeTransfer(account, amount);\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _updateTotalScore(uint newAmount, uint nextExpiry) private {\\n        (uint score, uint slope) = totalScore();\\n\\n        if (newAmount > 0) {\\n            uint slopeChange = newAmount.div(LOCK_UNIT_MAX);\\n            uint newAmountDeltaScore = nextExpiry.sub(block.timestamp).mul(slopeChange);\\n\\n            slope = slope.add(slopeChange);\\n            score = score.add(newAmountDeltaScore);\\n        }\\n\\n        _lastTotalScore = score;\\n        _lastSlope = slope;\\n        _lastTimestamp = block.timestamp;\\n    }\\n\\n    function _updateTotalScoreExtendingLock(uint amount, uint prevExpiry, uint nextExpiry) private {\\n        (uint score, uint slope) = totalScore();\\n\\n        uint deltaScore = nextExpiry.sub(prevExpiry).mul(amount.div(LOCK_UNIT_MAX));\\n        score = score.add(deltaScore);\\n\\n        _lastTotalScore = score;\\n        _lastSlope = slope;\\n        _lastTimestamp = block.timestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/QubitDevReservoir.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\\\";\\nimport \\\"../library/WhitelistUpgradeable.sol\\\";\\nimport \\\"../library/SafeToken.sol\\\";\\nimport \\\"../interfaces/IQubitLocker.sol\\\";\\n\\ncontract QubitDevReservoir is WhitelistUpgradeable {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address internal constant QBT = 0x17B7163cf1Dbd286E262ddc68b553D899B93f526;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    address public receiver;\\n    IQubitLocker public qubitLocker;\\n\\n    uint public startAt;\\n    uint public ratePerSec;\\n    uint public dripped;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize(\\n        address _receiver,\\n        uint _ratePerSec,\\n        uint _startAt\\n    ) external initializer {\\n        __WhitelistUpgradeable_init();\\n\\n        require(_receiver != address(0), \\\"QubitDevReservoir: invalid receiver\\\");\\n        require(_ratePerSec > 0, \\\"QubitDevReservoir: invalid rate\\\");\\n\\n        receiver = _receiver;\\n        ratePerSec = _ratePerSec;\\n        startAt = _startAt;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setLocker(address _qubitLocker) external onlyOwner {\\n        require(_qubitLocker != address(0), \\\"QubitDevReservoir: invalid locker address\\\");\\n        qubitLocker = IQubitLocker(_qubitLocker);\\n        IBEP20(QBT).approve(_qubitLocker, uint(-1));\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function getDripInfo()\\n        external\\n        view\\n        returns (\\n            uint,\\n            uint,\\n            uint\\n        )\\n    {\\n        return (startAt, ratePerSec, dripped);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function drip() public onlyOwner returns (uint) {\\n        require(block.timestamp >= startAt, \\\"QubitDevReservoir: not started\\\");\\n\\n        uint balance = IBEP20(QBT).balanceOf(address(this));\\n        uint totalDrip = ratePerSec.mul(block.timestamp.sub(startAt));\\n        uint amountToDrip = Math.min(balance, totalDrip.sub(dripped));\\n        dripped = dripped.add(amountToDrip);\\n        QBT.safeTransfer(receiver, amountToDrip);\\n        return amountToDrip;\\n    }\\n\\n    function dripToLocker() public onlyOwner returns (uint) {\\n        require(address(qubitLocker) != address(0), \\\"QubitDevReservoir: no locker assigned\\\");\\n        require(block.timestamp >= startAt, \\\"QubitDevReservoir: not started\\\");\\n        uint balance = IBEP20(QBT).balanceOf(address(this));\\n        uint totalDrip = ratePerSec.mul(block.timestamp.sub(startAt));\\n        uint amountToDrip = Math.min(balance, totalDrip.sub(dripped));\\n        dripped = dripped.add(amountToDrip);\\n\\n        if (qubitLocker.expiryOf(receiver) > block.timestamp) {\\n            qubitLocker.depositBehalf(receiver, amountToDrip, 0);\\n            return amountToDrip;\\n        } else {\\n            qubitLocker.depositBehalf(receiver, amountToDrip, block.timestamp + 365 days * 2);\\n            return amountToDrip;\\n        }\\n    }\\n\\n    function setStartAt(uint _startAt) public onlyOwner {\\n        require(startAt <= _startAt, \\\"QubitDevReservoir: invalid startAt\\\");\\n        startAt = _startAt;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/QPromise.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"../library/WhitelistUpgradeable.sol\\\";\\nimport \\\"../library/SafeToken.sol\\\";\\nimport \\\"../interfaces/IBEP20.sol\\\";\\n\\ncontract QPromise is WhitelistUpgradeable, ReentrancyGuardUpgradeable {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    struct TokenData {\\n        address asset;\\n        uint amount;\\n    }\\n\\n    mapping(address => TokenData) private _swaps;\\n    mapping(address => TokenData) private _repays;\\n    mapping(address => bool) public completes;\\n\\n    /* ========== EVENTS ========== */\\n\\n    event RepaymentClaimed(address indexed user, address asset, uint amount);\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() external initializer {\\n        __WhitelistUpgradeable_init();\\n        __ReentrancyGuard_init();\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setData(address[] memory accounts, TokenData[] memory receives, TokenData[] memory repays) external onlyOwner {\\n        require(accounts.length != 0 && accounts.length == receives.length && accounts.length == repays.length, \\\"QRepayment: invalid data\\\");\\n        for (uint i = 0; i < accounts.length; i++) {\\n            _swaps[accounts[i]] = receives[i];\\n            _repays[accounts[i]] = repays[i];\\n        }\\n    }\\n\\n    function sweep(address asset) external onlyOwner {\\n        uint balance = IBEP20(asset).balanceOf(address(this));\\n        if (balance > 0) {\\n            asset.safeTransfer(msg.sender, balance);\\n        }\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function infoOf(address account) external view returns (bool didClaim, address swapAsset, uint swapAmount, address repayAsset, uint repayAmount) {\\n        return (completes[account], _swaps[account].asset, _swaps[account].amount, _repays[account].asset, _repays[account].amount);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function claim() external nonReentrant {\\n        require(!completes[msg.sender], \\\"QRepayment: already claimed\\\");\\n        completes[msg.sender] = true;\\n\\n        address swapToken = _swaps[msg.sender].asset;\\n        uint swapAmount = _swaps[msg.sender].amount;\\n        delete _swaps[msg.sender];\\n\\n        address repayToken = _repays[msg.sender].asset;\\n        uint repayAmount = _repays[msg.sender].amount;\\n        delete _repays[msg.sender];\\n\\n        swapToken.safeTransferFrom(msg.sender, address(this), swapAmount);\\n        repayToken.safeTransfer(msg.sender, repayAmount);\\n\\n        emit RepaymentClaimed(msg.sender, repayToken, repayAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/QDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"../library/WhitelistUpgradeable.sol\\\";\\nimport \\\"../library/SafeToken.sol\\\";\\nimport \\\"../interfaces/IBEP20.sol\\\";\\nimport \\\"../interfaces/IQDistributor.sol\\\";\\nimport \\\"../interfaces/IQubitLocker.sol\\\";\\nimport \\\"../interfaces/IQToken.sol\\\";\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../interfaces/IPriceCalculator.sol\\\";\\n\\ncontract QDistributor is IQDistributor, WhitelistUpgradeable, ReentrancyGuardUpgradeable {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address private constant QBT = 0x17B7163cf1Dbd286E262ddc68b553D899B93f526;\\n\\n    uint public constant BOOST_PORTION = 150;\\n    uint public constant BOOST_MAX = 250;\\n    uint private constant LAUNCH_TIMESTAMP = 1629784800;\\n\\n    IQore public constant qore = IQore(0xF70314eb9c7Fe7D88E6af5aa7F898b3A162dcd48);\\n    IQubitLocker public constant qubitLocker = IQubitLocker(0xB8243be1D145a528687479723B394485cE3cE773);\\n    IPriceCalculator public constant priceCalculator = IPriceCalculator(0x20E5E35ba29dC3B540a1aee781D0814D5c77Bce6);\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(address => QConstant.DistributionInfo) public distributions;\\n    mapping(address => mapping(address => QConstant.DistributionAccountInfo)) public accountDistributions;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier updateDistributionOf(address market) {\\n        QConstant.DistributionInfo storage dist = distributions[market];\\n        if (dist.accruedAt == 0) {\\n            dist.accruedAt = block.timestamp;\\n        }\\n\\n        uint timeElapsed = block.timestamp > dist.accruedAt ? block.timestamp.sub(dist.accruedAt) : 0;\\n        if (timeElapsed > 0) {\\n            if (dist.totalBoostedSupply > 0) {\\n                dist.accPerShareSupply = dist.accPerShareSupply.add(\\n                    dist.supplySpeed.mul(timeElapsed).mul(1e18).div(dist.totalBoostedSupply)\\n                );\\n            }\\n\\n            if (dist.totalBoostedBorrow > 0) {\\n                dist.accPerShareBorrow = dist.accPerShareBorrow.add(\\n                    dist.borrowSpeed.mul(timeElapsed).mul(1e18).div(dist.totalBoostedBorrow)\\n                );\\n            }\\n        }\\n        dist.accruedAt = block.timestamp;\\n        _;\\n    }\\n\\n    modifier onlyQore() {\\n        require(msg.sender == address(qore), \\\"QDistributor: caller is not Qore\\\");\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event QubitDistributionSpeedUpdated(address indexed qToken, uint supplySpeed, uint borrowSpeed);\\n    event QubitClaimed(address indexed user, uint amount);\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() external initializer {\\n        __WhitelistUpgradeable_init();\\n        __ReentrancyGuard_init();\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setQubitDistributionSpeed(address qToken, uint supplySpeed, uint borrowSpeed) external onlyOwner updateDistributionOf(qToken) {\\n        QConstant.DistributionInfo storage dist = distributions[qToken];\\n        dist.supplySpeed = supplySpeed;\\n        dist.borrowSpeed = borrowSpeed;\\n        emit QubitDistributionSpeedUpdated(qToken, supplySpeed, borrowSpeed);\\n    }\\n\\n    // For reward distribution to different network (such as Klaytn)\\n    function withdrawReward(address receiver, uint amount) external onlyOwner {\\n        QBT.safeTransfer(receiver, amount);\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function accruedQubit(address[] calldata markets, address account) external view override returns (uint) {\\n        uint amount = 0;\\n        for (uint i = 0; i < markets.length; i++) {\\n            amount = amount.add(_accruedQubit(markets[i], account));\\n        }\\n        return amount;\\n    }\\n\\n    function distributionInfoOf(address market) external view override returns (QConstant.DistributionInfo memory) {\\n        return distributions[market];\\n    }\\n\\n    function accountDistributionInfoOf(address market, address account) external view override returns (QConstant.DistributionAccountInfo memory) {\\n        return accountDistributions[market][account];\\n    }\\n\\n    function apyDistributionOf(address market, address account) external view override returns (QConstant.DistributionAPY memory) {\\n        (uint apySupplyQBT, uint apyBorrowQBT) = _calculateMarketDistributionAPY(market);\\n        (uint apyAccountSupplyQBT, uint apyAccountBorrowQBT) = _calculateAccountDistributionAPY(market, account);\\n        return QConstant.DistributionAPY(apySupplyQBT, apyBorrowQBT, apyAccountSupplyQBT, apyAccountBorrowQBT);\\n    }\\n\\n    function boostedRatioOf(address market, address account) external view override returns (uint boostedSupplyRatio, uint boostedBorrowRatio) {\\n        uint accountSupply = IQToken(market).balanceOf(account);\\n        uint accountBorrow = IQToken(market).borrowBalanceOf(account).mul(1e18).div(IQToken(market).getAccInterestIndex());\\n\\n        boostedSupplyRatio = accountSupply > 0 ? accountDistributions[market][account].boostedSupply.mul(1e18).div(accountSupply) : 0;\\n        boostedBorrowRatio = accountBorrow > 0 ? accountDistributions[market][account].boostedBorrow.mul(1e18).div(accountBorrow) : 0;\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function notifySupplyUpdated(address market, address user) external override nonReentrant onlyQore updateDistributionOf(market) {\\n        if (block.timestamp < LAUNCH_TIMESTAMP)\\n            return;\\n\\n        QConstant.DistributionInfo storage dist = distributions[market];\\n        QConstant.DistributionAccountInfo storage userInfo = accountDistributions[market][user];\\n\\n        if (userInfo.boostedSupply > 0) {\\n            uint accQubitPerShare = dist.accPerShareSupply.sub(userInfo.accPerShareSupply);\\n            userInfo.accruedQubit = userInfo.accruedQubit.add(accQubitPerShare.mul(userInfo.boostedSupply).div(1e18));\\n        }\\n        userInfo.accPerShareSupply = dist.accPerShareSupply;\\n\\n        uint boostedSupply = _calculateBoostedSupply(market, user);\\n        dist.totalBoostedSupply = dist.totalBoostedSupply.add(boostedSupply).sub(userInfo.boostedSupply);\\n        userInfo.boostedSupply = boostedSupply;\\n    }\\n\\n    function notifyBorrowUpdated(address market, address user) external override nonReentrant onlyQore updateDistributionOf(market) {\\n        if (block.timestamp < LAUNCH_TIMESTAMP)\\n            return;\\n\\n        QConstant.DistributionInfo storage dist = distributions[market];\\n        QConstant.DistributionAccountInfo storage userInfo = accountDistributions[market][user];\\n\\n        if (userInfo.boostedBorrow > 0) {\\n            uint accQubitPerShare = dist.accPerShareBorrow.sub(userInfo.accPerShareBorrow);\\n            userInfo.accruedQubit = userInfo.accruedQubit.add(accQubitPerShare.mul(userInfo.boostedBorrow).div(1e18));\\n        }\\n        userInfo.accPerShareBorrow = dist.accPerShareBorrow;\\n\\n        uint boostedBorrow = _calculateBoostedBorrow(market, user);\\n        dist.totalBoostedBorrow = dist.totalBoostedBorrow.add(boostedBorrow).sub(userInfo.boostedBorrow);\\n        userInfo.boostedBorrow = boostedBorrow;\\n    }\\n\\n    function notifyTransferred(address qToken, address sender, address receiver) external override nonReentrant onlyQore updateDistributionOf(qToken) {\\n        if (block.timestamp < LAUNCH_TIMESTAMP)\\n            return;\\n\\n        require(sender != receiver, \\\"QDistributor: invalid transfer\\\");\\n        QConstant.DistributionInfo storage dist = distributions[qToken];\\n        QConstant.DistributionAccountInfo storage senderInfo = accountDistributions[qToken][sender];\\n        QConstant.DistributionAccountInfo storage receiverInfo = accountDistributions[qToken][receiver];\\n\\n        if (senderInfo.boostedSupply > 0) {\\n            uint accQubitPerShare = dist.accPerShareSupply.sub(senderInfo.accPerShareSupply);\\n            senderInfo.accruedQubit = senderInfo.accruedQubit.add(\\n                accQubitPerShare.mul(senderInfo.boostedSupply).div(1e18)\\n            );\\n        }\\n        senderInfo.accPerShareSupply = dist.accPerShareSupply;\\n\\n        if (receiverInfo.boostedSupply > 0) {\\n            uint accQubitPerShare = dist.accPerShareSupply.sub(receiverInfo.accPerShareSupply);\\n            receiverInfo.accruedQubit = receiverInfo.accruedQubit.add(\\n                accQubitPerShare.mul(receiverInfo.boostedSupply).div(1e18)\\n            );\\n        }\\n        receiverInfo.accPerShareSupply = dist.accPerShareSupply;\\n\\n        uint boostedSenderSupply = _calculateBoostedSupply(qToken, sender);\\n        uint boostedReceiverSupply = _calculateBoostedSupply(qToken, receiver);\\n        dist.totalBoostedSupply = dist\\n            .totalBoostedSupply\\n            .add(boostedSenderSupply)\\n            .add(boostedReceiverSupply)\\n            .sub(senderInfo.boostedSupply)\\n            .sub(receiverInfo.boostedSupply);\\n        senderInfo.boostedSupply = boostedSenderSupply;\\n        receiverInfo.boostedSupply = boostedReceiverSupply;\\n    }\\n\\n    function claimQubit(address[] calldata markets, address account) external override onlyQore {\\n        uint amount = 0;\\n        uint userScore = qubitLocker.scoreOf(account);\\n        (uint totalScore, ) = qubitLocker.totalScore();\\n\\n        for (uint i = 0; i < markets.length; i++) {\\n            amount = amount.add(_claimQubit(markets[i], account, userScore, totalScore));\\n        }\\n\\n        amount = Math.min(amount, IBEP20(QBT).balanceOf(address(this)));\\n        QBT.safeTransfer(account, amount);\\n        emit QubitClaimed(account, amount);\\n    }\\n\\n    function kick(address user) external override nonReentrant {\\n        if (block.timestamp < LAUNCH_TIMESTAMP)\\n            return;\\n\\n        uint userScore = qubitLocker.scoreOf(user);\\n        require(userScore == 0, \\\"QDistributor: kick not allowed\\\");\\n        (uint totalScore, ) = qubitLocker.totalScore();\\n\\n        address[] memory markets = qore.allMarkets();\\n        for (uint i = 0; i < markets.length; i++) {\\n            address market = markets[i];\\n            QConstant.DistributionAccountInfo memory userInfo = accountDistributions[market][user];\\n            if (userInfo.boostedSupply > 0) _updateSupplyOf(market, user, userScore, totalScore);\\n            if (userInfo.boostedBorrow > 0) _updateBorrowOf(market, user, userScore, totalScore);\\n        }\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _accruedQubit(address market, address user) private view returns (uint) {\\n        QConstant.DistributionInfo memory dist = distributions[market];\\n        QConstant.DistributionAccountInfo memory userInfo = accountDistributions[market][user];\\n\\n        uint amount = userInfo.accruedQubit;\\n        uint accPerShareSupply = dist.accPerShareSupply;\\n        uint accPerShareBorrow = dist.accPerShareBorrow;\\n\\n        uint timeElapsed = block.timestamp > dist.accruedAt ? block.timestamp.sub(dist.accruedAt) : 0;\\n        if (\\n            timeElapsed > 0 ||\\n            (accPerShareSupply != userInfo.accPerShareSupply) ||\\n            (accPerShareBorrow != userInfo.accPerShareBorrow)\\n        ) {\\n            if (dist.totalBoostedSupply > 0) {\\n                accPerShareSupply = accPerShareSupply.add(\\n                    dist.supplySpeed.mul(timeElapsed).mul(1e18).div(dist.totalBoostedSupply)\\n                );\\n\\n                uint pendingQubit = userInfo.boostedSupply.mul(accPerShareSupply.sub(userInfo.accPerShareSupply)).div(\\n                    1e18\\n                );\\n                amount = amount.add(pendingQubit);\\n            }\\n\\n            if (dist.totalBoostedBorrow > 0) {\\n                accPerShareBorrow = accPerShareBorrow.add(\\n                    dist.borrowSpeed.mul(timeElapsed).mul(1e18).div(dist.totalBoostedBorrow)\\n                );\\n\\n                uint pendingQubit = userInfo.boostedBorrow.mul(accPerShareBorrow.sub(userInfo.accPerShareBorrow)).div(\\n                    1e18\\n                );\\n                amount = amount.add(pendingQubit);\\n            }\\n        }\\n        return amount;\\n    }\\n\\n    function _claimQubit(address market, address user, uint userScore, uint totalScore) private returns (uint amount) {\\n        QConstant.DistributionAccountInfo storage userInfo = accountDistributions[market][user];\\n\\n        if (userInfo.boostedSupply > 0) _updateSupplyOf(market, user, userScore, totalScore);\\n        if (userInfo.boostedBorrow > 0) _updateBorrowOf(market, user, userScore, totalScore);\\n\\n        amount = amount.add(userInfo.accruedQubit);\\n        userInfo.accruedQubit = 0;\\n\\n        return amount;\\n    }\\n\\n    function _calculateMarketDistributionAPY(address market) private view returns (uint apySupplyQBT, uint apyBorrowQBT) {\\n        // base supply QBT APY == average supply QBT APY * (Total balance / total Boosted balance)\\n        // base supply QBT APY == (qubitRate * 365 days * price Of Qubit) / (Total balance * exchangeRate * price of asset) * (Total balance / Total Boosted balance)\\n        // base supply QBT APY == (qubitRate * 365 days * price Of Qubit) / (Total boosted balance * exchangeRate * price of asset)\\n        uint numerSupply = distributions[market].supplySpeed.mul(365 days).mul(priceCalculator.priceOf(QBT));\\n        uint denomSupply = distributions[market].totalBoostedSupply.mul(IQToken(market).exchangeRate()).mul(priceCalculator.getUnderlyingPrice(market)).div(1e36);\\n        apySupplyQBT = denomSupply > 0 ? numerSupply.div(denomSupply) : 0;\\n\\n        // base borrow QBT APY == average borrow QBT APY * (Total balance / total Boosted balance)\\n        // base borrow QBT APY == (qubitRate * 365 days * price Of Qubit) / (Total balance * exchangeRate * price of asset) * (Total balance / Total Boosted balance)\\n        // base borrow QBT APY == (qubitRate * 365 days * price Of Qubit) / (Total boosted balance * exchangeRate * price of asset)\\n        uint numerBorrow = distributions[market].borrowSpeed.mul(365 days).mul(priceCalculator.priceOf(QBT));\\n        uint denomBorrow = distributions[market].totalBoostedBorrow.mul(IQToken(market).getAccInterestIndex()).mul(priceCalculator.getUnderlyingPrice(market)).div(1e36);\\n        apyBorrowQBT = denomBorrow > 0 ? numerBorrow.div(denomBorrow) : 0;\\n    }\\n\\n    function _calculateAccountDistributionAPY(address market, address account) private view returns (uint apyAccountSupplyQBT, uint apyAccountBorrowQBT) {\\n        if (account == address(0)) return (0, 0);\\n        (uint apySupplyQBT, uint apyBorrowQBT) = _calculateMarketDistributionAPY(market);\\n\\n        // user supply QBT APY == ((qubitRate * 365 days * price Of Qubit) / (Total boosted balance * exchangeRate * price of asset) ) * my boosted balance  / my balance\\n        uint accountSupply = IQToken(market).balanceOf(account);\\n        apyAccountSupplyQBT = accountSupply > 0 ? apySupplyQBT.mul(accountDistributions[market][account].boostedSupply).div(accountSupply) : 0;\\n\\n        // user borrow QBT APY == (qubitRate * 365 days * price Of Qubit) / (Total boosted balance * interestIndex * price of asset) * my boosted balance  / my balance\\n        uint accountBorrow = IQToken(market).borrowBalanceOf(account).mul(1e18).div(IQToken(market).getAccInterestIndex());\\n        apyAccountBorrowQBT = accountBorrow > 0 ? apyBorrowQBT.mul(accountDistributions[market][account].boostedBorrow).div(accountBorrow) : 0;\\n    }\\n\\n    function _calculateBoostedSupply(address market, address user) private view returns (uint) {\\n        uint defaultSupply = IQToken(market).balanceOf(user);\\n        uint boostedSupply = defaultSupply;\\n\\n        uint userScore = qubitLocker.scoreOf(user);\\n        (uint totalScore, ) = qubitLocker.totalScore();\\n        if (userScore > 0 && totalScore > 0) {\\n            uint scoreBoosted = IQToken(market).totalSupply().mul(userScore).div(totalScore).mul(BOOST_PORTION).div(\\n                100\\n            );\\n            boostedSupply = boostedSupply.add(scoreBoosted);\\n        }\\n        return Math.min(boostedSupply, defaultSupply.mul(BOOST_MAX).div(100));\\n    }\\n\\n    function _calculateBoostedBorrow(address market, address user) private view returns (uint) {\\n        uint accInterestIndex = IQToken(market).getAccInterestIndex();\\n        uint defaultBorrow = IQToken(market).borrowBalanceOf(user).mul(1e18).div(accInterestIndex);\\n        uint boostedBorrow = defaultBorrow;\\n\\n        uint userScore = qubitLocker.scoreOf(user);\\n        (uint totalScore, ) = qubitLocker.totalScore();\\n        if (userScore > 0 && totalScore > 0) {\\n            uint totalBorrow = IQToken(market).totalBorrow().mul(1e18).div(accInterestIndex);\\n            uint scoreBoosted = totalBorrow.mul(userScore).div(totalScore).mul(BOOST_PORTION).div(100);\\n            boostedBorrow = boostedBorrow.add(scoreBoosted);\\n        }\\n        return Math.min(boostedBorrow, defaultBorrow.mul(BOOST_MAX).div(100));\\n    }\\n\\n    function _calculateBoostedSupply(address market, address user, uint userScore, uint totalScore) private view returns (uint) {\\n        uint defaultSupply = IQToken(market).balanceOf(user);\\n        uint boostedSupply = defaultSupply;\\n\\n        if (userScore > 0 && totalScore > 0) {\\n            uint scoreBoosted = IQToken(market).totalSupply().mul(userScore).div(totalScore).mul(BOOST_PORTION).div(\\n                100\\n            );\\n            boostedSupply = boostedSupply.add(scoreBoosted);\\n        }\\n        return Math.min(boostedSupply, defaultSupply.mul(BOOST_MAX).div(100));\\n    }\\n\\n    function _calculateBoostedBorrow(address market, address user, uint userScore, uint totalScore) private view returns (uint) {\\n        uint accInterestIndex = IQToken(market).getAccInterestIndex();\\n        uint defaultBorrow = IQToken(market).borrowBalanceOf(user).mul(1e18).div(accInterestIndex);\\n        uint boostedBorrow = defaultBorrow;\\n\\n        if (userScore > 0 && totalScore > 0) {\\n            uint totalBorrow = IQToken(market).totalBorrow().mul(1e18).div(accInterestIndex);\\n            uint scoreBoosted = totalBorrow.mul(userScore).div(totalScore).mul(BOOST_PORTION).div(100);\\n            boostedBorrow = boostedBorrow.add(scoreBoosted);\\n        }\\n        return Math.min(boostedBorrow, defaultBorrow.mul(BOOST_MAX).div(100));\\n    }\\n\\n    function _updateSupplyOf(address market, address user, uint userScore, uint totalScore) private updateDistributionOf(market) {\\n        QConstant.DistributionInfo storage dist = distributions[market];\\n        QConstant.DistributionAccountInfo storage userInfo = accountDistributions[market][user];\\n\\n        if (userInfo.boostedSupply > 0) {\\n            uint accQubitPerShare = dist.accPerShareSupply.sub(userInfo.accPerShareSupply);\\n            userInfo.accruedQubit = userInfo.accruedQubit.add(accQubitPerShare.mul(userInfo.boostedSupply).div(1e18));\\n        }\\n        userInfo.accPerShareSupply = dist.accPerShareSupply;\\n\\n        uint boostedSupply = _calculateBoostedSupply(market, user, userScore, totalScore);\\n        dist.totalBoostedSupply = dist.totalBoostedSupply.add(boostedSupply).sub(userInfo.boostedSupply);\\n        userInfo.boostedSupply = boostedSupply;\\n    }\\n\\n    function _updateBorrowOf(address market, address user, uint userScore, uint totalScore) private updateDistributionOf(market) {\\n        QConstant.DistributionInfo storage dist = distributions[market];\\n        QConstant.DistributionAccountInfo storage userInfo = accountDistributions[market][user];\\n\\n        if (userInfo.boostedBorrow > 0) {\\n            uint accQubitPerShare = dist.accPerShareBorrow.sub(userInfo.accPerShareBorrow);\\n            userInfo.accruedQubit = userInfo.accruedQubit.add(accQubitPerShare.mul(userInfo.boostedBorrow).div(1e18));\\n        }\\n        userInfo.accPerShareBorrow = dist.accPerShareBorrow;\\n\\n        uint boostedBorrow = _calculateBoostedBorrow(market, user, userScore, totalScore);\\n        dist.totalBoostedBorrow = dist.totalBoostedBorrow.add(boostedBorrow).sub(userInfo.boostedBorrow);\\n        userInfo.boostedBorrow = boostedBorrow;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/markets/interest/RateModelSlope.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IRateModel.sol\\\";\\n\\ncontract RateModelSlope is IRateModel, OwnableUpgradeable {\\n    using SafeMath for uint;\\n\\n    uint private baseRatePerYear;\\n    uint private slopePerYearFirst;\\n    uint private slopePerYearSecond;\\n    uint private optimal;\\n\\n    function initialize(\\n        uint _baseRatePerYear,\\n        uint _slopePerYearFirst,\\n        uint _slopePerYearSecond,\\n        uint _optimal\\n    ) external initializer {\\n        __Ownable_init();\\n\\n        baseRatePerYear = _baseRatePerYear;\\n        slopePerYearFirst = _slopePerYearFirst;\\n        slopePerYearSecond = _slopePerYearSecond;\\n        optimal = _optimal;\\n    }\\n\\n    function utilizationRate(\\n        uint cash,\\n        uint borrows,\\n        uint reserves\\n    ) public pure returns (uint) {\\n        if (reserves >= cash.add(borrows)) return 0;\\n        return Math.min(borrows.mul(1e18).div(cash.add(borrows).sub(reserves)), 1e18);\\n    }\\n\\n    function getBorrowRate(\\n        uint cash,\\n        uint borrows,\\n        uint reserves\\n    ) public view override returns (uint) {\\n        uint utilization = utilizationRate(cash, borrows, reserves);\\n        if (optimal > 0 && utilization < optimal) {\\n            return baseRatePerYear.add(utilization.mul(slopePerYearFirst).div(optimal)).div(365 days);\\n        } else {\\n            uint ratio = utilization.sub(optimal).mul(1e18).div(uint(1e18).sub(optimal));\\n            return baseRatePerYear.add(slopePerYearFirst).add(ratio.mul(slopePerYearSecond).div(1e18)).div(365 days);\\n        }\\n    }\\n\\n    function getSupplyRate(\\n        uint cash,\\n        uint borrows,\\n        uint reserves,\\n        uint reserveFactor\\n    ) public view override returns (uint) {\\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\\n        uint borrowRate = getBorrowRate(cash, borrows, reserves);\\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/InterestRateModelHarness.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IRateModel.sol\\\";\\n\\ncontract InterestRateModelHarness is IRateModel {\\n    uint public constant opaqueBorrowFailureCode = 20;\\n    bool public failBorrowRate;\\n    uint public borrowRate;\\n\\n    constructor(uint borrowRate_) public {\\n        borrowRate = borrowRate_;\\n    }\\n\\n    function setFailBorrowRate(bool failBorrowRate_) public {\\n        failBorrowRate = failBorrowRate_;\\n    }\\n\\n    function setBorrowRate(uint borrowRate_) public {\\n        borrowRate = borrowRate_;\\n    }\\n\\n    function getBorrowRate(\\n        uint _cash,\\n        uint _borrows,\\n        uint _reserves\\n    ) public view override returns (uint) {\\n        _cash; // unused\\n        _borrows; // unused\\n        _reserves; // unused\\n        require(!failBorrowRate, \\\"INTEREST_RATE_MODEL_ERROR\\\");\\n        return borrowRate;\\n    }\\n\\n    function getSupplyRate(\\n        uint _cash,\\n        uint _borrows,\\n        uint _reserves,\\n        uint _reserveFactor\\n    ) external view override returns (uint) {\\n        _cash; // unused\\n        _borrows; // unused\\n        _reserves; // unused\\n        return borrowRate * (1 - _reserveFactor);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/markets/interest/RateModelLinear.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IRateModel.sol\\\";\\n\\ncontract RateModelLinear is IRateModel, OwnableUpgradeable {\\n    using SafeMath for uint;\\n\\n    uint private baseRatePerYear;\\n    uint private multiplierPerYear;\\n\\n    function initialize(uint _baseRatePerYear, uint _multiplierPerYear) external initializer {\\n        __Ownable_init();\\n        baseRatePerYear = _baseRatePerYear;\\n        multiplierPerYear = _multiplierPerYear;\\n    }\\n\\n    function utilizationRate(\\n        uint cash,\\n        uint borrows,\\n        uint reserves\\n    ) public pure returns (uint) {\\n        if (reserves >= cash.add(borrows)) return 0;\\n        return Math.min(borrows.mul(1e18).div(cash.add(borrows).sub(reserves)), 1e18);\\n    }\\n\\n    function getBorrowRate(\\n        uint cash,\\n        uint borrows,\\n        uint reserves\\n    ) public view override returns (uint) {\\n        uint utilization = utilizationRate(cash, borrows, reserves);\\n        return (utilization.mul(multiplierPerYear).div(1e18).add(baseRatePerYear)).div(365 days);\\n    }\\n\\n    function getSupplyRate(\\n        uint cash,\\n        uint borrows,\\n        uint reserves,\\n        uint reserveFactor\\n    ) public view override returns (uint) {\\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\\n        uint borrowRate = getBorrowRate(cash, borrows, reserves);\\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/dashboard/DashboardBSC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"../interfaces/IPriceCalculator.sol\\\";\\nimport \\\"../interfaces/IQToken.sol\\\";\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../interfaces/IDashboard.sol\\\";\\nimport \\\"../interfaces/IQubitLocker.sol\\\";\\nimport \\\"../interfaces/IBEP20.sol\\\";\\n\\n\\ncontract DashboardBSC is IDashboard, OwnableUpgradeable {\\n    using SafeMath for uint;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    address private constant QBT = 0x17B7163cf1Dbd286E262ddc68b553D899B93f526;\\n    IPriceCalculator public constant priceCalculator = IPriceCalculator(0x20E5E35ba29dC3B540a1aee781D0814D5c77Bce6);\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IQore public qore;\\n    IQubitLocker public qubitLocker;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() external initializer {\\n        __Ownable_init();\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setQore(address _qore) external onlyOwner {\\n        require(_qore != address(0), \\\"DashboardBSC: invalid qore address\\\");\\n        require(address(qore) == address(0), \\\"DashboardBSC: qore already set\\\");\\n        qore = IQore(_qore);\\n    }\\n\\n    function setLocker(address _qubitLocker) external onlyOwner {\\n        require(_qubitLocker != address(0), \\\"DashboardBSC: invalid locker address\\\");\\n        qubitLocker = IQubitLocker(_qubitLocker);\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    function qubitDataOf(address[] memory markets, address account) public view override returns (QubitData memory) {\\n        QubitData memory qubit;\\n        qubit.marketList = new MarketData[](markets.length);\\n        qubit.membershipList = new MembershipData[](markets.length);\\n\\n        if (account != address(0)) {\\n            qubit.accountAcc = accountAccDataOf(account);\\n            qubit.locker = lockerDataOf(account);\\n        }\\n\\n        for (uint i = 0; i < markets.length; i++) {\\n            qubit.marketList[i] = marketDataOf(markets[i]);\\n\\n            if (account != address(0)) {\\n                qubit.membershipList[i] = membershipDataOf(markets[i], account);\\n            }\\n        }\\n\\n        qubit.marketAverageBoostedRatio = _calculateAccMarketAverageBoostedRatio(markets);\\n        return qubit;\\n    }\\n\\n    function marketDataOf(address market) public view override returns (MarketData memory) {\\n        MarketData memory marketData;\\n        QConstant.DistributionAPY memory apyDistribution = qore.apyDistributionOf(market, address(0));\\n        QConstant.DistributionInfo memory distributionInfo = qore.distributionInfoOf(market);\\n        IQToken qToken = IQToken(market);\\n        marketData.qToken = market;\\n\\n        marketData.apySupply = qToken.supplyRatePerSec().mul(365 days);\\n        marketData.apyBorrow = qToken.borrowRatePerSec().mul(365 days);\\n        marketData.apySupplyQBT = apyDistribution.apySupplyQBT;\\n        marketData.apyBorrowQBT = apyDistribution.apyBorrowQBT;\\n\\n        marketData.totalSupply = qToken.totalSupply().mul(qToken.exchangeRate()).div(1e18);\\n        marketData.totalBorrows = qToken.totalBorrow();\\n        marketData.totalBoostedSupply = distributionInfo.totalBoostedSupply;\\n        marketData.totalBoostedBorrow = distributionInfo.totalBoostedBorrow;\\n\\n        marketData.cash = qToken.getCash();\\n        marketData.reserve = qToken.totalReserve();\\n        marketData.reserveFactor = qToken.reserveFactor();\\n        marketData.collateralFactor = qore.marketInfoOf(market).collateralFactor;\\n        marketData.exchangeRate = qToken.exchangeRate();\\n        marketData.borrowCap = qore.marketInfoOf(market).borrowCap;\\n        marketData.accInterestIndex = qToken.getAccInterestIndex();\\n        return marketData;\\n    }\\n\\n    function membershipDataOf(address market, address account) public view override returns (MembershipData memory) {\\n        MembershipData memory membershipData;\\n        QConstant.DistributionAPY memory apyDistribution = qore.apyDistributionOf(market, account);\\n        QConstant.DistributionAccountInfo memory accountDistributionInfo = qore.accountDistributionInfoOf(market, account);\\n\\n        membershipData.qToken = market;\\n        membershipData.membership = qore.checkMembership(account, market);\\n        membershipData.supply = IQToken(market).underlyingBalanceOf(account);\\n        membershipData.borrow = IQToken(market).borrowBalanceOf(account);\\n        membershipData.boostedSupply = accountDistributionInfo.boostedSupply;\\n        membershipData.boostedBorrow = accountDistributionInfo.boostedBorrow;\\n        membershipData.apyAccountSupplyQBT = apyDistribution.apyAccountSupplyQBT;\\n        membershipData.apyAccountBorrowQBT = apyDistribution.apyAccountBorrowQBT;\\n        return membershipData;\\n    }\\n\\n    function accountAccDataOf(address account) public view override returns (AccountAccData memory) {\\n        AccountAccData memory accData;\\n        accData.accruedQubit = qore.accruedQubit(account);\\n        (accData.collateralInUSD,, accData.borrowInUSD) = qore.accountLiquidityOf(account);\\n\\n        address[] memory markets = qore.allMarkets();\\n        uint[] memory prices = priceCalculator.getUnderlyingPrices(markets);\\n        for (uint i = 0; i < markets.length; i++) {\\n            accData.supplyInUSD = accData.supplyInUSD.add(IQToken(markets[i]).underlyingBalanceOf(account).mul(prices[i]).div(1e18));\\n        }\\n        uint totalValueInUSD = accData.supplyInUSD.add(accData.borrowInUSD);\\n        (accData.accApySupply, accData.accApySupplyQBT) = _calculateAccAccountSupplyAPYOf(account, markets, prices, totalValueInUSD);\\n        (accData.accApyBorrow, accData.accApyBorrowQBT) = _calculateAccAccountBorrowAPYOf(account, markets, prices, totalValueInUSD);\\n        accData.averageBoostedRatio = _calculateAccAccountAverageBoostedRatio(account, markets);\\n        return accData;\\n    }\\n\\n    function lockerDataOf(address account) public view override returns (LockerData memory) {\\n        LockerData memory lockerInfo;\\n\\n        lockerInfo.totalLocked = qubitLocker.totalBalance();\\n        lockerInfo.locked = qubitLocker.balanceOf(account);\\n\\n        (uint totalScore, ) = qubitLocker.totalScore();\\n        lockerInfo.totalScore = totalScore;\\n        lockerInfo.score = qubitLocker.scoreOf(account);\\n\\n        lockerInfo.available = qubitLocker.availableOf(account);\\n        lockerInfo.expiry = qubitLocker.expiryOf(account);\\n        return lockerInfo;\\n    }\\n\\n    function totalValueLockedOf(address[] memory markets) public view returns (uint totalSupplyInUSD) {\\n        uint[] memory prices = priceCalculator.getUnderlyingPrices(markets);\\n        for (uint i = 0; i < markets.length; i++) {\\n            uint supplyInUSD = IQToken(markets[i]).getCash().mul(IQToken(markets[i]).exchangeRate()).div(1e18);\\n            totalSupplyInUSD = totalSupplyInUSD.add(supplyInUSD.mul(prices[i]).div(1e18));\\n        }\\n        return totalSupplyInUSD;\\n    }\\n\\n    function totalCirculating() public view returns (uint) {\\n        return IBEP20(QBT).totalSupply()\\n                .sub(IBEP20(QBT).balanceOf(0xa7bc9a205A46017F47949F5Ee453cEBFcf42121b))      // reward Lock\\n                .sub(IBEP20(QBT).balanceOf(0xB224eD67C2F89Ae97758a9DB12163A6f30830EB2))      // developer's Supply Lock\\n                .sub(IBEP20(QBT).balanceOf(0x4c97c901B5147F8C1C7Ce3c5cF3eB83B44F244fE))      // MND Vault Lock\\n                .sub(IBEP20(QBT).balanceOf(0xB56290bEfc4216dc2A526a9022A76A1e4FDf122b))      // marketing Treasury\\n                .sub(IBEP20(QBT).balanceOf(0xAAf5d0dB947F835287b9432F677A51e9a1a01a35))      // security Treasury\\n                .sub(IBEP20(QBT).balanceOf(0xc7939B1Fa2E7662592b4d11dbE3C331bEE18FC85))      // Dev Treasury\\n//                .sub(qubitLocker.balanceOf(0x12C62464D8CF4a9Ca6f2EEAd1d7954A9fC21d053))      // QubitPool (lock forever)\\n                .sub(qubitLocker.totalBalance())                                             // QubitLocker\\n                .sub(IBEP20(QBT).balanceOf(0x67B806ab830801348ce719E0705cC2f2718117a1))      // reward Distributor (QDistributor)\\n                .sub(IBEP20(QBT).balanceOf(0xD1ad1943b70340783eD9814ffEdcAaAe459B6c39))      // PCB QBT-BNB pool reward lock\\n                .sub(IBEP20(QBT).balanceOf(0x89c527764f03BCb7dC469707B23b79C1D7Beb780));     // Orbit Bridge lock (displayed in Klaytn instead)\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _calculateAccAccountSupplyAPYOf(address account, address[] memory markets, uint[] memory prices, uint totalValueInUSD) private view returns (uint accApySupply, uint accApySupplyQBT) {\\n        for (uint i = 0; i < markets.length; i++) {\\n            QConstant.DistributionAPY memory apyDistribution = qore.apyDistributionOf(markets[i], account);\\n\\n            uint supplyInUSD = IQToken(markets[i]).underlyingBalanceOf(account).mul(prices[i]).div(1e18);\\n            accApySupply = accApySupply.add(supplyInUSD.mul(IQToken(markets[i]).supplyRatePerSec().mul(365 days)).div(1e18));\\n            accApySupplyQBT = accApySupplyQBT.add(supplyInUSD.mul(apyDistribution.apyAccountSupplyQBT).div(1e18));\\n        }\\n\\n        accApySupply = totalValueInUSD > 0 ? accApySupply.mul(1e18).div(totalValueInUSD) : 0;\\n        accApySupplyQBT = totalValueInUSD > 0 ? accApySupplyQBT.mul(1e18).div(totalValueInUSD) : 0;\\n    }\\n\\n    function _calculateAccAccountBorrowAPYOf(address account, address[] memory markets, uint[] memory prices, uint totalValueInUSD) private view returns (uint accApyBorrow, uint accApyBorrowQBT) {\\n        for (uint i = 0; i < markets.length; i++) {\\n            QConstant.DistributionAPY memory apyDistribution = qore.apyDistributionOf(markets[i], account);\\n\\n            uint borrowInUSD = IQToken(markets[i]).borrowBalanceOf(account).mul(prices[i]).div(1e18);\\n            accApyBorrow = accApyBorrow.add(borrowInUSD.mul(IQToken(markets[i]).borrowRatePerSec().mul(365 days)).div(1e18));\\n            accApyBorrowQBT = accApyBorrowQBT.add(borrowInUSD.mul(apyDistribution.apyAccountBorrowQBT).div(1e18));\\n        }\\n\\n        accApyBorrow = totalValueInUSD > 0 ? accApyBorrow.mul(1e18).div(totalValueInUSD) : 0;\\n        accApyBorrowQBT = totalValueInUSD > 0 ? accApyBorrowQBT.mul(1e18).div(totalValueInUSD) : 0;\\n    }\\n\\n    function _calculateAccAccountAverageBoostedRatio(address account, address[] memory markets) public view returns (uint averageBoostedRatio) {\\n        uint accBoostedCount = 0;\\n        for (uint i = 0; i < markets.length; i++) {\\n            (uint boostedSupplyRatio, uint boostedBorrowRatio) = qore.boostedRatioOf(markets[i], account);\\n\\n            if (boostedSupplyRatio > 0) {\\n                averageBoostedRatio = averageBoostedRatio.add(boostedSupplyRatio);\\n                accBoostedCount++;\\n            }\\n\\n            if (boostedBorrowRatio > 0) {\\n                averageBoostedRatio = averageBoostedRatio.add(boostedBorrowRatio);\\n                accBoostedCount++;\\n            }\\n        }\\n        return accBoostedCount > 0 ? averageBoostedRatio.div(accBoostedCount) : 0;\\n    }\\n\\n    function _calculateAccMarketAverageBoostedRatio(address[] memory markets) public view returns (uint averageBoostedRatio) {\\n        uint accValueInUSD = 0;\\n        uint accBoostedValueInUSD = 0;\\n\\n        uint[] memory prices = priceCalculator.getUnderlyingPrices(markets);\\n        for (uint i = 0; i < markets.length; i++) {\\n            QConstant.DistributionInfo memory distributionInfo = qore.distributionInfoOf(markets[i]);\\n\\n            accBoostedValueInUSD = accBoostedValueInUSD.add(distributionInfo.totalBoostedSupply.mul(IQToken(markets[i]).exchangeRate()).mul(prices[i]).div(1e36));\\n            accBoostedValueInUSD = accBoostedValueInUSD.add(distributionInfo.totalBoostedBorrow.mul(IQToken(markets[i]).getAccInterestIndex()).mul(prices[i]).div(1e36));\\n\\n            accValueInUSD = accValueInUSD.add(IQToken(markets[i]).totalSupply().mul(IQToken(markets[i]).exchangeRate()).mul(prices[i]).div(1e36));\\n            accValueInUSD = accValueInUSD.add(IQToken(markets[i]).totalBorrow().mul(prices[i]).div(1e18));\\n        }\\n        return accValueInUSD > 0 ? accBoostedValueInUSD.mul(1e18).div(accValueInUSD) : 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDashboard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../library/QConstant.sol\\\";\\n\\ninterface IDashboard {\\n    struct QubitData {\\n        MarketData[] marketList;\\n        MembershipData[] membershipList;\\n        AccountAccData accountAcc;\\n        LockerData locker;\\n        uint marketAverageBoostedRatio;\\n    }\\n\\n    struct MarketData {\\n        address qToken;\\n\\n        uint apySupply;\\n        uint apyBorrow;\\n        uint apySupplyQBT;\\n        uint apyBorrowQBT;\\n\\n        uint totalSupply;\\n        uint totalBorrows;\\n        uint totalBoostedSupply;\\n        uint totalBoostedBorrow;\\n\\n        uint cash;\\n        uint reserve;\\n        uint reserveFactor;\\n        uint collateralFactor;\\n        uint exchangeRate;\\n        uint borrowCap;\\n        uint accInterestIndex;\\n    }\\n\\n    struct MembershipData {\\n        address qToken;\\n        bool membership;\\n        uint supply;\\n        uint borrow;\\n        uint boostedSupply;\\n        uint boostedBorrow;\\n        uint apyAccountSupplyQBT;\\n        uint apyAccountBorrowQBT;\\n    }\\n\\n    struct AccountAccData {\\n        uint accruedQubit;\\n        uint collateralInUSD;\\n        uint supplyInUSD;\\n        uint borrowInUSD;\\n        uint accApySupply;\\n        uint accApyBorrow;\\n        uint accApySupplyQBT;\\n        uint accApyBorrowQBT;\\n        uint averageBoostedRatio;\\n    }\\n\\n    struct LockerData {\\n        uint totalLocked;\\n        uint locked;\\n        uint totalScore;\\n        uint score;\\n        uint available;\\n        uint expiry;\\n    }\\n\\n    function qubitDataOf(address[] memory markets, address account) external view returns (QubitData memory);\\n\\n    function marketDataOf(address market) external view returns (MarketData memory);\\n    function membershipDataOf(address market, address account) external view returns (MembershipData memory);\\n    function accountAccDataOf(address account) external view returns (AccountAccData memory);\\n    function lockerDataOf(address account) external view returns (LockerData memory);\\n}\\n\"\r\n    },\r\n    \"contracts/calculator/PriceCalculatorBSC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\\\";\\n\\nimport \\\"../interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../interfaces/IPriceCalculator.sol\\\";\\nimport \\\"../interfaces/IQToken.sol\\\";\\nimport \\\"../interfaces/IPancakePair.sol\\\";\\nimport \\\"../interfaces/IPancakeFactory.sol\\\";\\nimport \\\"../library/HomoraMath.sol\\\";\\n\\ncontract PriceCalculatorBSC is IPriceCalculator, OwnableUpgradeable {\\n    using SafeMath for uint;\\n    using HomoraMath for uint;\\n\\n    address public constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public constant MDX = 0x9C65AB58d8d978DB963e63f2bfB7121627e3a739;\\n    address public constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n\\n    IPancakeFactory private constant factory = IPancakeFactory(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73);\\n    IPancakeFactory private constant mdexFactory = IPancakeFactory(0x3CD1C46068dAEa5Ebb0d3f55F6915B10648062B8);\\n\\n    uint private constant THRESHOLD = 5 minutes;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    address public keeper;\\n    mapping(address => ReferenceData) public references;\\n    mapping(address => address) private tokenFeeds;\\n\\n    /* ========== Event ========== */\\n\\n    event MarketListed(address qToken);\\n    event MarketEntered(address qToken, address account);\\n    event MarketExited(address qToken, address account);\\n\\n    event CloseFactorUpdated(uint newCloseFactor);\\n    event CollateralFactorUpdated(address qToken, uint newCollateralFactor);\\n    event LiquidationIncentiveUpdated(uint newLiquidationIncentive);\\n    event BorrowCapUpdated(address indexed qToken, uint newBorrowCap);\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyKeeper() {\\n        require(msg.sender == keeper || msg.sender == owner(), \\\"Qore: caller is not the owner or keeper\\\");\\n        _;\\n    }\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() external initializer {\\n        __Ownable_init();\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setKeeper(address _keeper) external onlyKeeper {\\n        require(_keeper != address(0), \\\"PriceCalculatorBSC: invalid keeper address\\\");\\n        keeper = _keeper;\\n    }\\n\\n    function setTokenFeed(address asset, address feed) external onlyKeeper {\\n        tokenFeeds[asset] = feed;\\n    }\\n\\n    function setPrices(address[] memory assets, uint[] memory prices, uint timestamp) external onlyKeeper {\\n        require(timestamp <= block.timestamp && block.timestamp.sub(timestamp) <= THRESHOLD, \\\"PriceCalculator: invalid timestamp\\\");\\n\\n        for (uint i = 0; i < assets.length; i++) {\\n            references[assets[i]] = ReferenceData({lastData : prices[i], lastUpdated : block.timestamp});\\n        }\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function priceOf(address asset) public view override returns (uint priceInUSD) {\\n        if (asset == address(0)) {\\n            return priceOfBNB();\\n        }\\n        uint decimals = uint(IBEP20(asset).decimals());\\n        uint unitAmount = 10 ** decimals;\\n        return _oracleValueInUSDOf(asset, unitAmount, decimals);\\n    }\\n\\n    function pricesOf(address[] memory assets) public view override returns (uint[] memory) {\\n        uint[] memory prices = new uint[](assets.length);\\n        for (uint i = 0; i < assets.length; i++) {\\n            prices[i] = priceOf(assets[i]);\\n        }\\n        return prices;\\n    }\\n\\n    function getUnderlyingPrice(address qToken) public view override returns (uint) {\\n        return priceOf(IQToken(qToken).underlying());\\n    }\\n\\n    function getUnderlyingPrices(address[] memory qTokens) public view override returns (uint[] memory) {\\n        uint[] memory prices = new uint[](qTokens.length);\\n        for (uint i = 0; i < qTokens.length; i++) {\\n            prices[i] = priceOf(IQToken(qTokens[i]).underlying());\\n        }\\n        return prices;\\n    }\\n\\n    function priceOfBNB() public view returns (uint) {\\n        (, int price, , ,) = AggregatorV3Interface(tokenFeeds[WBNB]).latestRoundData();\\n        return uint(price).mul(1e10);\\n    }\\n\\n    function valueOfAsset(address asset, uint amount) public view override returns (uint valueInBNB, uint valueInUSD) {\\n        if (asset == address(0) || asset == WBNB) {\\n            return _oracleValueOf(asset, amount);\\n        } else if (keccak256(abi.encodePacked(IPancakePair(asset).symbol())) == keccak256(\\\"Cake-LP\\\")) {\\n            return _getPairPrice(asset, amount);\\n        } else {\\n            return _oracleValueOf(asset, amount);\\n        }\\n    }\\n\\n    function unsafeValueOfAsset(address asset, uint amount) public view override returns (uint valueInBNB, uint valueInUSD) {\\n        valueInBNB = 0;\\n        valueInUSD = 0;\\n\\n        if (asset == address(0) || asset == WBNB) {\\n            valueInBNB = amount;\\n            valueInUSD = amount.mul(priceOfBNB()).div(1e18);\\n        } else if (keccak256(abi.encodePacked(IPancakePair(asset).symbol())) == keccak256(\\\"Cake-LP\\\")) {\\n            if (IPancakePair(asset).totalSupply() == 0) return (0, 0);\\n\\n            (uint reserve0, uint reserve1,) = IPancakePair(asset).getReserves();\\n            if (IPancakePair(asset).token0() == WBNB) {\\n                valueInBNB = amount.mul(reserve0).mul(2).div(IPancakePair(asset).totalSupply());\\n                valueInUSD = valueInBNB.mul(priceOfBNB()).div(1e18);\\n            } else if (IPancakePair(asset).token1() == WBNB) {\\n                valueInBNB = amount.mul(reserve1).mul(2).div(IPancakePair(asset).totalSupply());\\n                valueInUSD = valueInBNB.mul(priceOfBNB()).div(1e18);\\n            } else {\\n                (uint tokenPriceInBNB,) = valueOfAsset(IPancakePair(asset).token0(), 10 ** uint(IBEP20(IPancakePair(asset).token0()).decimals()));\\n                if (tokenPriceInBNB == 0) {\\n                    (tokenPriceInBNB,) = valueOfAsset(IPancakePair(asset).token1(), 10 ** uint(IBEP20(IPancakePair(asset).token1()).decimals()));\\n                    if (IBEP20(IPancakePair(asset).token1()).decimals() < uint8(18)) {\\n                        reserve1 = reserve1.mul(10 ** uint(uint8(18) - IBEP20(IPancakePair(asset).token1()).decimals()));\\n                    }\\n                    valueInBNB = amount.mul(reserve1).mul(2).mul(tokenPriceInBNB).div(1e18).div(IPancakePair(asset).totalSupply());\\n                } else {\\n                    if (IBEP20(IPancakePair(asset).token0()).decimals() < uint8(18)) {\\n                        reserve0 = reserve0.mul(10 ** uint(uint8(18) - IBEP20(IPancakePair(asset).token0()).decimals()));\\n                    }\\n                    valueInBNB = amount.mul(reserve0).mul(2).mul(tokenPriceInBNB).div(1e18).div(IPancakePair(asset).totalSupply());\\n                }\\n                valueInUSD = valueInBNB.mul(priceOfBNB()).div(1e18);\\n            }\\n        } else if (asset == MDX) {\\n            address pair = mdexFactory.getPair(MDX, BUSD);\\n            if (IBEP20(MDX).balanceOf(pair) == 0) return (0, 0);\\n            (uint reserve0, uint reserve1,) = IPancakePair(pair).getReserves();\\n\\n            (,uint priceOfBUSD) = _oracleValueOf(BUSD, 1e18);\\n            if (IPancakePair(pair).token0() == BUSD) {\\n                valueInUSD = reserve0.mul(amount).div(reserve1).mul(priceOfBUSD).div(1e18);\\n            } else if (IPancakePair(pair).token1() == BUSD) {\\n                valueInUSD = reserve1.mul(amount).div(reserve0).mul(priceOfBUSD).div(1e18);\\n            } else {\\n                return (0, 0);\\n            }\\n            valueInBNB = valueInUSD.mul(1e18).div(priceOfBNB());\\n        } else {\\n            address pair = factory.getPair(asset, WBNB);\\n            if (IBEP20(asset).balanceOf(pair) == 0) return (0, 0);\\n            (uint reserve0, uint reserve1,) = IPancakePair(pair).getReserves();\\n\\n            if (IPancakePair(pair).token0() == WBNB) {\\n                valueInBNB = reserve0.mul(amount).div(reserve1);\\n            } else if (IPancakePair(pair).token1() == WBNB) {\\n                valueInBNB = reserve1.mul(amount).div(reserve0);\\n            } else {\\n                return (0, 0);\\n            }\\n            valueInUSD = valueInBNB.mul(priceOfBNB()).div(1e18);\\n        }\\n    }\\n\\n    /* ========== PRIVATE FUNCTIONS ========== */\\n\\n    function _getPairPrice(address pair, uint amount) private view returns (uint valueInBNB, uint valueInUSD) {\\n        address token0 = IPancakePair(pair).token0();\\n        address token1 = IPancakePair(pair).token1();\\n        uint totalSupply = IPancakePair(pair).totalSupply();\\n        (uint reserve0, uint reserve1,) = IPancakePair(pair).getReserves();\\n\\n        if (IBEP20(token0).decimals() < uint8(18)) {\\n            reserve0 = reserve0.mul(10 ** uint(uint8(18) - IBEP20(token0).decimals()));\\n        }\\n\\n        if (IBEP20(token1).decimals() < uint8(18)) {\\n            reserve1 = reserve1.mul(10 ** uint(uint8(18) - IBEP20(token1).decimals()));\\n        }\\n\\n        uint sqrtK = HomoraMath.sqrt(reserve0.mul(reserve1)).fdiv(totalSupply);\\n        (uint px0,) = _oracleValueOf(token0, 10 ** uint(IBEP20(token0).decimals()));\\n        (uint px1,) = _oracleValueOf(token1, 10 ** uint(IBEP20(token1).decimals()));\\n        uint fairPriceInBNB = sqrtK.mul(2).mul(HomoraMath.sqrt(px0)).div(2 ** 56).mul(HomoraMath.sqrt(px1)).div(2 ** 56);\\n\\n        valueInBNB = fairPriceInBNB.mul(amount).div(1e18);\\n        valueInUSD = valueInBNB.mul(priceOfBNB()).div(1e18);\\n    }\\n\\n    function _oracleValueOf(address asset, uint amount) private view returns (uint valueInBNB, uint valueInUSD) {\\n        valueInUSD = 0;\\n        uint assetDecimals = asset == address(0) ? 1e18 : 10 ** uint(IBEP20(asset).decimals());\\n        if (tokenFeeds[asset] != address(0)) {\\n            (, int price, , ,) = AggregatorV3Interface(tokenFeeds[asset]).latestRoundData();\\n            valueInUSD = uint(price).mul(1e10).mul(amount).div(assetDecimals);\\n        } else if (references[asset].lastUpdated > block.timestamp.sub(1 days)) {\\n            valueInUSD = references[asset].lastData.mul(amount).div(assetDecimals);\\n        }\\n        valueInBNB = valueInUSD.mul(1e18).div(priceOfBNB());\\n    }\\n\\n    function _oracleValueInUSDOf(address asset, uint amount, uint decimals) private view returns (uint valueInUSD) {\\n        valueInUSD = 0;\\n        uint assetDecimals = asset == address(0) ? 1e18 : 10 ** decimals;\\n        if (tokenFeeds[asset] != address(0)) {\\n            (, int price, , ,) = AggregatorV3Interface(tokenFeeds[asset]).latestRoundData();\\n            valueInUSD = uint(price).mul(1e10).mul(amount).div(assetDecimals);\\n        } else if (references[asset].lastUpdated > block.timestamp.sub(1 days)) {\\n            valueInUSD = references[asset].lastData.mul(amount).div(assetDecimals);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint);\\n\\n    // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n    // if they do not have data to report, instead of returning unset values\\n    // which could be misinterpreted as actual reported values.\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int answer,\\n            uint startedAt,\\n            uint updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int answer,\\n            uint startedAt,\\n            uint updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/library/HomoraMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary HomoraMath {\\n    using SafeMath for uint;\\n\\n    function divCeil(uint lhs, uint rhs) internal pure returns (uint) {\\n        return lhs.add(rhs).sub(1) / rhs;\\n    }\\n\\n    function fmul(uint lhs, uint rhs) internal pure returns (uint) {\\n        return lhs.mul(rhs) / (2**112);\\n    }\\n\\n    function fdiv(uint lhs, uint rhs) internal pure returns (uint) {\\n        return lhs.mul(2**112) / rhs;\\n    }\\n\\n    // implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\\n    // original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\\n    function sqrt(uint x) internal pure returns (uint) {\\n        if (x == 0) return 0;\\n        uint xx = x;\\n        uint r = 1;\\n\\n        if (xx >= 0x100000000000000000000000000000000) {\\n            xx >>= 128;\\n            r <<= 64;\\n        }\\n\\n        if (xx >= 0x10000000000000000) {\\n            xx >>= 64;\\n            r <<= 32;\\n        }\\n        if (xx >= 0x100000000) {\\n            xx >>= 32;\\n            r <<= 16;\\n        }\\n        if (xx >= 0x10000) {\\n            xx >>= 16;\\n            r <<= 8;\\n        }\\n        if (xx >= 0x100) {\\n            xx >>= 8;\\n            r <<= 4;\\n        }\\n        if (xx >= 0x10) {\\n            xx >>= 4;\\n            r <<= 2;\\n        }\\n        if (xx >= 0x8) {\\n            r <<= 1;\\n        }\\n\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\n        uint r1 = x / r;\\n        return (r < r1 ? r : r1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/QBridgeHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../interfaces/IQBridgeHandler.sol\\\";\\nimport \\\"../interfaces/IQBridgeDelegator.sol\\\";\\nimport \\\"../library/SafeToken.sol\\\";\\nimport \\\"./QBridgeToken.sol\\\";\\n\\n\\ncontract QBridgeHandler is IQBridgeHandler, OwnableUpgradeable {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    uint public constant OPTION_QUBIT_BNB_NONE = 100;\\n    uint public constant OPTION_QUBIT_BNB_0100 = 110;\\n    uint public constant OPTION_QUBIT_BNB_0050 = 105;\\n    uint public constant OPTION_BUNNY_XLP_0150 = 215;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    address public _bridgeAddress;\\n\\n    mapping(bytes32 => address) public resourceIDToTokenContractAddress; // resourceID => token contract address\\n    mapping(address => bytes32) public tokenContractAddressToResourceID; // token contract address => resourceID\\n\\n    mapping(address => bool) public burnList; // token contract address => is burnable\\n    mapping(address => bool) public contractWhitelist; // token contract address => is whitelisted\\n    mapping(uint => address) public delegators; // option => delegator contract address\\n    mapping(bytes32 => uint) public withdrawalFees; // resourceID => withdraw fee\\n    mapping(bytes32 => mapping(uint => uint)) public minAmounts; // [resourceID][option] => minDepositAmount\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize(address bridgeAddress) external initializer {\\n        __Ownable_init();\\n        _bridgeAddress = bridgeAddress;\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == _bridgeAddress, \\\"QBridgeHandler: caller is not the bridge contract\\\");\\n        _;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setResource(bytes32 resourceID, address contractAddress) external override onlyBridge {\\n        resourceIDToTokenContractAddress[resourceID] = contractAddress;\\n        tokenContractAddressToResourceID[contractAddress] = resourceID;\\n        contractWhitelist[contractAddress] = true;\\n    }\\n\\n    function setBurnable(address contractAddress) external override onlyBridge {\\n        require(contractWhitelist[contractAddress], \\\"QBridgeHandler: contract address is not whitelisted\\\");\\n        burnList[contractAddress] = true;\\n    }\\n\\n    function setDelegator(uint option, address newDelegator) external onlyOwner {\\n        delegators[option] = newDelegator;\\n    }\\n\\n    function setWithdrawalFee(bytes32 resourceID, uint withdrawalFee) external onlyOwner {\\n        withdrawalFees[resourceID] = withdrawalFee;\\n    }\\n\\n    function setMinDepositAmount(bytes32 resourceID, uint option, uint minAmount) external onlyOwner {\\n        minAmounts[resourceID][option] = minAmount;\\n    }\\n\\n    /**\\n        @notice A deposit is initiated by making a deposit in the Bridge contract.\\n        @param resourceID ResourceID used to find address of token to be used for deposit.\\n        @param depositer Address of account making the deposit in the Bridge contract.\\n        @param data passed into the function should be constructed as follows:\\n        option                                 uint256     bytes  0 - 32\\n        amount                                 uint256     bytes  32 - 64\\n     */\\n    function deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {\\n        uint option;\\n        uint amount;\\n        (option, amount) = abi.decode(data, (uint, uint));\\n\\n        address tokenAddress = resourceIDToTokenContractAddress[resourceID];\\n        require(contractWhitelist[tokenAddress], \\\"provided tokenAddress is not whitelisted\\\");\\n\\n        if (burnList[tokenAddress]) {\\n            require(amount >= withdrawalFees[resourceID], \\\"less than withdrawal fee\\\");\\n            QBridgeToken(tokenAddress).burnFrom(depositer, amount);\\n        } else {\\n            require(amount >= minAmounts[resourceID][option], \\\"less than minimum amount\\\");\\n            tokenAddress.safeTransferFrom(depositer, address(this), amount);\\n        }\\n    }\\n\\n    /**\\n        @notice Proposal execution should be initiated by a relayer on the deposit's destination chain.\\n        @param data passed into the function should be constructed as follows:\\n        option                                 uint256\\n        amount                                 uint256\\n        destinationRecipientAddress            address\\n     */\\n    function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\\n        uint option;\\n        uint amount;\\n        address recipientAddress;\\n        (option, amount, recipientAddress) = abi.decode(data, (uint, uint, address));\\n\\n        address tokenAddress = resourceIDToTokenContractAddress[resourceID];\\n\\n        require(contractWhitelist[tokenAddress], \\\"provided tokenAddress is not whitelisted\\\");\\n\\n        if (burnList[tokenAddress]) {\\n            address delegatorAddress = delegators[option];\\n            if (delegatorAddress == address(0)) {\\n                QBridgeToken(tokenAddress).mint(recipientAddress, amount);\\n            } else {\\n                QBridgeToken(tokenAddress).mint(delegatorAddress, amount);\\n                IQBridgeDelegator(delegatorAddress).delegate(tokenAddress, recipientAddress, option, amount);\\n            }\\n        } else {\\n            tokenAddress.safeTransfer(recipientAddress, amount.sub(withdrawalFees[resourceID]));\\n        }\\n    }\\n\\n    function withdraw(address tokenAddress, address recipient, uint amount) external override onlyBridge {\\n        tokenAddress.safeTransfer(recipient, amount);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQBridgeDelegator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface IQBridgeDelegator {\\n\\n    function delegate(address xToken, address account, uint option, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/QBridgeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"../library/BEP20Upgradeable.sol\\\";\\n\\n\\ncontract QBridgeToken is BEP20Upgradeable {\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(address => bool) private _minters;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyMinter() {\\n        require(isMinter(msg.sender), \\\"QBridgeToken: caller is not the minter\\\");\\n        _;\\n    }\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize(string memory name, string memory symbol, uint8 decimals) external initializer {\\n        __BEP20__init(name, symbol, decimals);\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setMinter(address minter, bool canMint) external onlyOwner {\\n        _minters[minter] = canMint;\\n    }\\n\\n    function mint(address _to, uint _amount) public onlyMinter {\\n        _mint(_to, _amount);\\n    }\\n\\n    function burnFrom(address account, uint amount) public onlyMinter {\\n        uint decreasedAllowance = allowance(account, msg.sender).sub(amount, \\\"BEP20: burn amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/library/BEP20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nabstract contract BEP20Upgradeable is IBEP20, OwnableUpgradeable {\\n    using SafeMath for uint;\\n\\n    mapping(address => uint) private _balances;\\n    mapping(address => mapping(address => uint)) private _allowances;\\n    uint private _totalSupply;\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    uint[50] private __gap;\\n\\n    /**\\n     * @dev sets initials supply and the owner\\n     */\\n    function __BEP20__init(\\n        string memory name,\\n        string memory symbol,\\n        uint8 decimals\\n    ) internal initializer {\\n        __Ownable_init();\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the bep token owner.\\n     */\\n    function getOwner() external view override returns (address) {\\n        return owner();\\n    }\\n\\n    /**\\n     * @dev Returns the token decimals.\\n     */\\n    function decimals() external view override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the token symbol.\\n     */\\n    function symbol() external view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the token name.\\n     */\\n    function name() external view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {BEP20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {BEP20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {BEP20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint amount) external override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {BEP20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view override returns (uint) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {BEP20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {BEP20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {BEP20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) external override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()].sub(amount, \\\"BEP20: transfer amount exceeds allowance\\\")\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {BEP20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {BEP20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].sub(subtractedValue, \\\"BEP20: decreased allowance below zero\\\")\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Burn `amount` tokens and decreasing the total supply.\\n     */\\n    function burn(uint amount) public returns (bool) {\\n        _burn(_msgSender(), amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) internal {\\n        require(sender != address(0), \\\"BEP20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"BEP20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"BEP20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint amount) internal {\\n        require(account != address(0), \\\"BEP20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint amount) internal {\\n        require(account != address(0), \\\"BEP20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"BEP20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint amount\\n    ) internal {\\n        require(owner != address(0), \\\"BEP20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"BEP20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint amount) internal {\\n        _burn(account, amount);\\n        _approve(\\n            account,\\n            _msgSender(),\\n            _allowances[account][_msgSender()].sub(amount, \\\"BEP20: burn amount exceeds allowance\\\")\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/TestXToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n\\nimport \\\"../library/BEP20Upgradeable.sol\\\";\\n\\ncontract TestXToken is BEP20Upgradeable {\\n    // STATE VARIABLES\\n    mapping(address => bool) private _minters;\\n    uint public ownerInt;\\n\\n    // MODIFIERS\\n    modifier onlyMinter() {\\n        require(isMinter(msg.sender), \\\"TestToken: caller is not the minter\\\");\\n        _;\\n    }\\n\\n    // INITIALIZER\\n    function initialize() external initializer {\\n        __BEP20__init(\\\"TestXToken Token\\\", \\\"xTST\\\", 18);\\n        _minters[owner()] = true;\\n        ownerInt = 0;\\n    }\\n\\n    // RESTRICTED FUNCTIONS\\n    function setOwnerInt(uint _ownerInt) external onlyOwner {\\n        ownerInt = _ownerInt;\\n    }\\n\\n    function multiplyOwnerInt(uint multiplier, uint plus) external onlyOwner {\\n        ownerInt = ownerInt.mul(multiplier).add(plus);\\n    }\\n\\n    function setMinter(address minter, bool canMint) external onlyOwner {\\n        _minters[minter] = canMint;\\n    }\\n\\n    function mint(address _to, uint _amount) public onlyMinter {\\n        _mint(_to, _amount);\\n    }\\n\\n\\n    // VIEWS\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/TestToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n\\nimport \\\"../library/BEP20Upgradeable.sol\\\";\\n\\ncontract TestToken is BEP20Upgradeable {\\n    // STATE VARIABLES\\n    mapping(address => bool) private _minters;\\n    uint public ownerInt;\\n\\n    // MODIFIERS\\n    modifier onlyMinter() {\\n        require(isMinter(msg.sender), \\\"TestToken: caller is not the minter\\\");\\n        _;\\n    }\\n\\n    // INITIALIZER\\n    function initialize() external initializer {\\n        __BEP20__init(\\\"TestToken Token\\\", \\\"TST\\\", 18);\\n        _minters[owner()] = true;\\n        ownerInt = 0;\\n    }\\n\\n    // RESTRICTED FUNCTIONS\\n    function setOwnerInt(uint _ownerInt) external onlyOwner {\\n        ownerInt = _ownerInt;\\n    }\\n\\n    function multiplyOwnerInt(uint multiplier, uint plus) external onlyOwner {\\n        ownerInt = ownerInt.mul(multiplier).add(plus);\\n    }\\n\\n    function setMinter(address minter, bool canMint) external onlyOwner {\\n        _minters[minter] = canMint;\\n    }\\n\\n    function mint(address _to, uint _amount) public {\\n        _mint(_to, _amount);\\n    }\\n\\n\\n    // VIEWS\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tester/QubitTokenTester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"../library/BEP20Upgradeable.sol\\\";\\n\\ncontract QubitTokenTester is BEP20Upgradeable {\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(address => bool) private _minters;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() external initializer {\\n        __BEP20__init(\\\"Qubit Token\\\", \\\"QBT\\\", 18);\\n        _minters[owner()] = true;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setMinter(address minter, bool canMint) external onlyOwner {\\n        _minters[minter] = canMint;\\n    }\\n\\n    function mint(address _to, uint _amount) public {\\n        _mint(_to, _amount);\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/QubitToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"./library/BEP20Upgradeable.sol\\\";\\n\\ncontract QubitToken is BEP20Upgradeable {\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(address => bool) private _minters;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyMinter() {\\n        require(isMinter(msg.sender), \\\"QBT: caller is not the minter\\\");\\n        _;\\n    }\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() external initializer {\\n        __BEP20__init(\\\"Qubit Token\\\", \\\"QBT\\\", 18);\\n        _minters[owner()] = true;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setMinter(address minter, bool canMint) external onlyOwner {\\n        _minters[minter] = canMint;\\n    }\\n\\n    function mint(address _to, uint _amount) public onlyMinter {\\n        _mint(_to, _amount);\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bridge/QBridgeDelegator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n      ___       ___       ___       ___       ___\\n     /\\\\  \\\\     /\\\\__\\\\     /\\\\  \\\\     /\\\\  \\\\     /\\\\  \\\\\\n    /::\\\\  \\\\   /:/ _/_   /::\\\\  \\\\   _\\\\:\\\\  \\\\    \\\\:\\\\  \\\\\\n    \\\\:\\\\:\\\\__\\\\ /:/_/\\\\__\\\\ /::\\\\:\\\\__\\\\ /\\\\/::\\\\__\\\\   /::\\\\__\\\\\\n     \\\\::/  / \\\\:\\\\/:/  / \\\\:\\\\::/  / \\\\::/\\\\/__/  /:/\\\\/__/\\n     /:/  /   \\\\::/  /   \\\\::/  /   \\\\:\\\\__\\\\    \\\\/__/\\n     \\\\/__/     \\\\/__/     \\\\/__/     \\\\/__/\\n\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2021 QubitFinance\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n* SOFTWARE.\\n*/\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../interfaces/IQBridgeHandler.sol\\\";\\nimport \\\"../interfaces/IQBridgeDelegator.sol\\\";\\nimport \\\"../interfaces/IQore.sol\\\";\\nimport \\\"../library/SafeToken.sol\\\";\\nimport \\\"./QBridgeToken.sol\\\";\\n\\n\\ncontract QBridgeDelegator is IQBridgeDelegator, OwnableUpgradeable {\\n    using SafeMath for uint;\\n    using SafeToken for address;\\n\\n    /* ========== CONSTANT VARIABLES ========== */\\n\\n    uint public constant OPTION_QUBIT_BNB_NONE = 100;\\n    uint public constant OPTION_QUBIT_BNB_0100 = 110;\\n    uint public constant OPTION_QUBIT_BNB_0050 = 105;\\n    uint public constant OPTION_BUNNY_XLP_0150 = 215;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    mapping(address => bool) public handlerWhitelist; // handler address => is whitelisted\\n    mapping(address => address) public marketAddress; // xToken address => market address\\n    IQore public qore;\\n\\n    /* ========== INITIALIZER ========== */\\n\\n    function initialize() external initializer {\\n        __Ownable_init();\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyBridgeHandler() {\\n        require(handlerWhitelist[msg.sender], \\\"QBridgeDelegator: caller is not the whitelisted handler contract\\\");\\n        _;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setQore(address _qore) external onlyOwner {\\n        require(_qore != address(0), \\\"QBridgeDelegator: invalid qore address\\\");\\n        require(address(qore) == address(0), \\\"QBridgeDelegator: qore already set\\\");\\n        qore = IQore(_qore);\\n    }\\n\\n    function setHandlerWhitelist(address _handler, bool option) external onlyOwner {\\n        handlerWhitelist[_handler] = option;\\n    }\\n\\n    function setMarket(address xToken, address market) external onlyOwner {\\n        require(xToken != address(0), \\\"QBridgeDelegator: invalid xToken address\\\");\\n        require(market != address(0), \\\"QBridgeDelegator: invalid market address\\\");\\n        marketAddress[xToken] = market;\\n    }\\n\\n    function approveTokenForMarket(address token, address market) external onlyOwner {\\n        require(token != address(0), \\\"QBridgeDelegator: invalid xToken address\\\");\\n        require(market != address(0), \\\"QBridgeDelegator: invalid market address\\\");\\n        QBridgeToken(token).approve(market, uint(- 1));\\n    }\\n\\n    /* ========== MUTATIVE  ========== */\\n\\n    function delegate(address xToken, address recipientAddress, uint option, uint amount) external override onlyBridgeHandler {\\n        if (option == OPTION_QUBIT_BNB_NONE) {\\n            qore.supplyAndBorrowBNB(recipientAddress, marketAddress[xToken], amount, 0);\\n        }\\n        else if (option == OPTION_QUBIT_BNB_0050) {\\n            qore.supplyAndBorrowBNB(recipientAddress, marketAddress[xToken], amount, 5e16);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWBNB.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IBEP20.sol\\\";\\n\\ninterface IWBNB is IBEP20 {\\n    function deposit() external payable;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"destinationDomainID\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"lowLevelData\",\"type\":\"bytes\"}],\"name\":\"FailedHandlerExecution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PauseChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"originDomainID\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"enum QBridge.ProposalStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"ProposalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"originDomainID\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"enum QBridge.ProposalStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"ProposalVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"RelayerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"RelayerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"RelayerThresholdChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_RELAYERS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RELAYER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"_depositCounts\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"addRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"originDomainID\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"cancelProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_domainID\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"combinedProposalId\",\"outputs\":[{\"internalType\":\"uint72\",\"name\":\"proposalID\",\"type\":\"uint72\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"destinationDomainID\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainID\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"originDomainID\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"revertOnFail\",\"type\":\"bool\"}],\"name\":\"executeProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expiry\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"originDomainID\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"getProposal\",\"outputs\":[{\"components\":[{\"internalType\":\"enum QBridge.ProposalStatus\",\"name\":\"_status\",\"type\":\"uint8\"},{\"internalType\":\"uint200\",\"name\":\"_yesVotes\",\"type\":\"uint200\"},{\"internalType\":\"uint8\",\"name\":\"_yesVotesTotal\",\"type\":\"uint8\"},{\"internalType\":\"uint40\",\"name\":\"_proposedBlock\",\"type\":\"uint40\"}],\"internalType\":\"struct QBridge.Proposal\",\"name\":\"proposal\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"hasVoted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRoleMemberIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_domainID\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_relayerThreshold\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"_fee\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"_expiry\",\"type\":\"uint40\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"isRelayer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPauseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handlerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"manualRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayerThreshold\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"removeRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"resourceIDToHandlerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handlerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"setBurnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_domainID\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"setDepositNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newFee\",\"type\":\"uint128\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newThreshold\",\"type\":\"uint8\"}],\"name\":\"setRelayerThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handlerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"setResource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRelayers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"originDomainID\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"voteProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"QBridge","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}