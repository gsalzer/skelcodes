{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.0;\r\n\r\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\ncontract MultiSigWallet {\r\n\t/*\r\n\t *  Events\r\n\t */\r\n\tevent Confirmation(address indexed sender, uint256 indexed transactionId);\r\n\tevent Revocation(address indexed sender, uint256 indexed transactionId);\r\n\tevent Submission(uint256 indexed transactionId);\r\n\tevent Execution(uint256 indexed transactionId);\r\n\tevent ExecutionFailure(uint256 indexed transactionId);\r\n\tevent Deposit(address indexed sender, uint256 value);\r\n\tevent OwnerAddition(address indexed owner);\r\n\tevent OwnerRemoval(address indexed owner);\r\n\tevent RequirementChange(uint256 required);\r\n\r\n\t/*\r\n\t *  Constants\r\n\t */\r\n\tuint256 public constant MAX_OWNER_COUNT = 50;\r\n\r\n\t/*\r\n\t *  Storage\r\n\t */\r\n\tmapping(uint256 => Transaction) public transactions;\r\n\tmapping(uint256 => mapping(address => bool)) public confirmations;\r\n\tmapping(address => bool) public isOwner;\r\n\taddress[] public owners;\r\n\tuint256 public required;\r\n\tuint256 public transactionCount;\r\n\r\n\tstruct Transaction {\r\n\t\taddress destination;\r\n\t\tuint256 value;\r\n\t\tbytes data;\r\n\t\tbool executed;\r\n\t}\r\n\r\n\t/*\r\n\t *  Modifiers\r\n\t */\r\n\tmodifier onlyWallet() {\r\n\t\trequire(msg.sender == address(this));\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier ownerDoesNotExist(address owner) {\r\n\t\trequire(!isOwner[owner]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier ownerExists(address owner) {\r\n\t\trequire(isOwner[owner]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier transactionExists(uint256 transactionId) {\r\n\t\trequire(transactions[transactionId].destination != address(0));\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier confirmed(uint256 transactionId, address owner) {\r\n\t\trequire(confirmations[transactionId][owner]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier notConfirmed(uint256 transactionId, address owner) {\r\n\t\trequire(!confirmations[transactionId][owner]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier notExecuted(uint256 transactionId) {\r\n\t\trequire(!transactions[transactionId].executed);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier notNull(address _address) {\r\n\t\trequire(_address != address(0));\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier validRequirement(uint256 ownerCount, uint256 _required) {\r\n\t\trequire(\r\n\t\t\townerCount <= MAX_OWNER_COUNT &&\r\n\t\t\t\t_required <= ownerCount &&\r\n\t\t\t\t_required != 0 &&\r\n\t\t\t\townerCount != 0\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\t/// @dev Fallback function allows to deposit ether.\r\n\tfunction() external payable {\r\n\t\tif (msg.value > 0) emit Deposit(msg.sender, msg.value);\r\n\t}\r\n\r\n\t/*\r\n\t * Public functions\r\n\t */\r\n\t/// @dev Contract constructor sets initial owners and required number of confirmations.\r\n\t/// @param _owners List of initial owners.\r\n\t/// @param _required Number of required confirmations.\r\n\tconstructor(address[] memory _owners, uint256 _required)\r\n\t\tpublic\r\n\t\tvalidRequirement(_owners.length, _required)\r\n\t{\r\n\t\tfor (uint256 i = 0; i < _owners.length; i++) {\r\n\t\t\trequire(!isOwner[_owners[i]] && _owners[i] != address(0));\r\n\t\t\tisOwner[_owners[i]] = true;\r\n\t\t}\r\n\t\towners = _owners;\r\n\t\trequired = _required;\r\n\t}\r\n\r\n\t/// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n\t/// @param owner Address of new owner.\r\n\tfunction addOwner(address owner)\r\n\t\tpublic\r\n\t\tonlyWallet\r\n\t\townerDoesNotExist(owner)\r\n\t\tnotNull(owner)\r\n\t\tvalidRequirement(owners.length + 1, required)\r\n\t{\r\n\t\tisOwner[owner] = true;\r\n\t\towners.push(owner);\r\n\t\temit OwnerAddition(owner);\r\n\t}\r\n\r\n\t/// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n\t/// @param owner Address of owner.\r\n\tfunction removeOwner(address owner) public onlyWallet ownerExists(owner) {\r\n\t\tisOwner[owner] = false;\r\n\t\tfor (uint256 i = 0; i < owners.length - 1; i++)\r\n\t\t\tif (owners[i] == owner) {\r\n\t\t\t\towners[i] = owners[owners.length - 1];\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\towners.length -= 1;\r\n\t\tif (required > owners.length) changeRequirement(owners.length);\r\n\t\temit OwnerRemoval(owner);\r\n\t}\r\n\r\n\t/// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n\t/// @param owner Address of owner to be replaced.\r\n\t/// @param newOwner Address of new owner.\r\n\tfunction replaceOwner(address owner, address newOwner)\r\n\t\tpublic\r\n\t\tonlyWallet\r\n\t\townerExists(owner)\r\n\t\townerDoesNotExist(newOwner)\r\n\t{\r\n\t\tfor (uint256 i = 0; i < owners.length; i++)\r\n\t\t\tif (owners[i] == owner) {\r\n\t\t\t\towners[i] = newOwner;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\tisOwner[owner] = false;\r\n\t\tisOwner[newOwner] = true;\r\n\t\temit OwnerRemoval(owner);\r\n\t\temit OwnerAddition(newOwner);\r\n\t}\r\n\r\n\t/// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n\t/// @param _required Number of required confirmations.\r\n\tfunction changeRequirement(uint256 _required)\r\n\t\tpublic\r\n\t\tonlyWallet\r\n\t\tvalidRequirement(owners.length, _required)\r\n\t{\r\n\t\trequired = _required;\r\n\t\temit RequirementChange(_required);\r\n\t}\r\n\r\n\t/// @dev Allows an owner to submit and confirm a transaction.\r\n\t/// @param destination Transaction target address.\r\n\t/// @param value Transaction ether value.\r\n\t/// @param data Transaction data payload.\r\n\t/// @return Returns transaction ID.\r\n\tfunction submitTransaction(\r\n\t\taddress destination,\r\n\t\tuint256 value,\r\n\t\tbytes memory data\r\n\t) public returns (uint256 transactionId) {\r\n\t\ttransactionId = addTransaction(destination, value, data);\r\n\t\tconfirmTransaction(transactionId);\r\n\t}\r\n\r\n\t/// @dev Allows an owner to confirm a transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\tfunction confirmTransaction(uint256 transactionId)\r\n\t\tpublic\r\n\t\townerExists(msg.sender)\r\n\t\ttransactionExists(transactionId)\r\n\t\tnotConfirmed(transactionId, msg.sender)\r\n\t{\r\n\t\tconfirmations[transactionId][msg.sender] = true;\r\n\t\temit Confirmation(msg.sender, transactionId);\r\n\t\texecuteTransaction(transactionId);\r\n\t}\r\n\r\n\t/// @dev Allows an owner to revoke a confirmation for a transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\tfunction revokeConfirmation(uint256 transactionId)\r\n\t\tpublic\r\n\t\townerExists(msg.sender)\r\n\t\tconfirmed(transactionId, msg.sender)\r\n\t\tnotExecuted(transactionId)\r\n\t{\r\n\t\tconfirmations[transactionId][msg.sender] = false;\r\n\t\temit Revocation(msg.sender, transactionId);\r\n\t}\r\n\r\n\t/// @dev Allows anyone to execute a confirmed transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\tfunction executeTransaction(uint256 transactionId)\r\n\t\tpublic\r\n\t\townerExists(msg.sender)\r\n\t\tconfirmed(transactionId, msg.sender)\r\n\t\tnotExecuted(transactionId)\r\n\t{\r\n\t\tif (isConfirmed(transactionId)) {\r\n\t\t\tTransaction storage txn = transactions[transactionId];\r\n\t\t\ttxn.executed = true;\r\n\t\t\tif (\r\n\t\t\t\texternal_call(\r\n\t\t\t\t\ttxn.destination,\r\n\t\t\t\t\ttxn.value,\r\n\t\t\t\t\ttxn.data.length,\r\n\t\t\t\t\ttxn.data\r\n\t\t\t\t)\r\n\t\t\t) emit Execution(transactionId);\r\n\t\t\telse {\r\n\t\t\t\temit ExecutionFailure(transactionId);\r\n\t\t\t\ttxn.executed = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// call has been separated into its own function in order to take advantage\r\n\t// of the Solidity's code generator to produce a loop that copies tx.data into memory.\r\n\tfunction external_call(\r\n\t\taddress destination,\r\n\t\tuint256 value,\r\n\t\tuint256 dataLength,\r\n\t\tbytes memory data\r\n\t) private returns (bool) {\r\n\t\tbool result;\r\n\t\tassembly {\r\n\t\t\tlet x := mload(0x40) // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\r\n\t\t\tlet d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n\t\t\tresult := call(\r\n\t\t\t\tsub(gas, 34710), // 34710 is the value that solidity is currently emitting\r\n\t\t\t\t// It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\r\n\t\t\t\t// callNewAccountGas (25000, in case the destination address does not exist and needs creating)\r\n\t\t\t\tdestination,\r\n\t\t\t\tvalue,\r\n\t\t\t\td,\r\n\t\t\t\tdataLength, // Size of the input (in bytes) - this is what fixes the padding problem\r\n\t\t\t\tx,\r\n\t\t\t\t0 // Output is ignored, therefore the output size is zero\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/// @dev Returns the confirmation status of a transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\t/// @return Confirmation status.\r\n\tfunction isConfirmed(uint256 transactionId) public view returns (bool) {\r\n\t\tuint256 count = 0;\r\n\t\tfor (uint256 i = 0; i < owners.length; i++) {\r\n\t\t\tif (confirmations[transactionId][owners[i]]) count += 1;\r\n\t\t\tif (count == required) return true;\r\n\t\t}\r\n\t}\r\n\r\n\t/*\r\n\t * Internal functions\r\n\t */\r\n\t/// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n\t/// @param destination Transaction target address.\r\n\t/// @param value Transaction ether value.\r\n\t/// @param data Transaction data payload.\r\n\t/// @return Returns transaction ID.\r\n\tfunction addTransaction(\r\n\t\taddress destination,\r\n\t\tuint256 value,\r\n\t\tbytes memory data\r\n\t) internal notNull(destination) returns (uint256 transactionId) {\r\n\t\ttransactionId = transactionCount;\r\n\t\ttransactions[transactionId] = Transaction({\r\n\t\t\tdestination: destination,\r\n\t\t\tvalue: value,\r\n\t\t\tdata: data,\r\n\t\t\texecuted: false\r\n\t\t});\r\n\t\ttransactionCount += 1;\r\n\t\temit Submission(transactionId);\r\n\t}\r\n\r\n\t/*\r\n\t * Web3 call functions\r\n\t */\r\n\t/// @dev Returns number of confirmations of a transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\t/// @return Number of confirmations.\r\n\tfunction getConfirmationCount(uint256 transactionId)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256 count)\r\n\t{\r\n\t\tfor (uint256 i = 0; i < owners.length; i++)\r\n\t\t\tif (confirmations[transactionId][owners[i]]) count += 1;\r\n\t}\r\n\r\n\t/// @dev Returns total number of transactions after filers are applied.\r\n\t/// @param pending Include pending transactions.\r\n\t/// @param executed Include executed transactions.\r\n\t/// @return Total number of transactions after filters are applied.\r\n\tfunction getTransactionCount(bool pending, bool executed)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256 count)\r\n\t{\r\n\t\tfor (uint256 i = 0; i < transactionCount; i++)\r\n\t\t\tif (\r\n\t\t\t\t(pending && !transactions[i].executed) ||\r\n\t\t\t\t(executed && transactions[i].executed)\r\n\t\t\t) count += 1;\r\n\t}\r\n\r\n\t/// @dev Returns list of owners.\r\n\t/// @return List of owner addresses.\r\n\tfunction getOwners() public view returns (address[] memory) {\r\n\t\treturn owners;\r\n\t}\r\n\r\n\t/// @dev Returns array with owner addresses, which confirmed transaction.\r\n\t/// @param transactionId Transaction ID.\r\n\t/// @return Returns array of owner addresses.\r\n\tfunction getConfirmations(uint256 transactionId)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (address[] memory _confirmations)\r\n\t{\r\n\t\taddress[] memory confirmationsTemp = new address[](owners.length);\r\n\t\tuint256 count = 0;\r\n\t\tuint256 i;\r\n\t\tfor (i = 0; i < owners.length; i++)\r\n\t\t\tif (confirmations[transactionId][owners[i]]) {\r\n\t\t\t\tconfirmationsTemp[count] = owners[i];\r\n\t\t\t\tcount += 1;\r\n\t\t\t}\r\n\t\t_confirmations = new address[](count);\r\n\t\tfor (i = 0; i < count; i++) _confirmations[i] = confirmationsTemp[i];\r\n\t}\r\n\r\n\t/// @dev Returns list of transaction IDs in defined range.\r\n\t/// @param from Index start position of transaction array.\r\n\t/// @param to Index end position of transaction array.\r\n\t/// @param pending Include pending transactions.\r\n\t/// @param executed Include executed transactions.\r\n\t/// @return Returns array of transaction IDs.\r\n\tfunction getTransactionIds(\r\n\t\tuint256 from,\r\n\t\tuint256 to,\r\n\t\tbool pending,\r\n\t\tbool executed\r\n\t) public view returns (uint256[] memory _transactionIds) {\r\n\t\tuint256[] memory transactionIdsTemp = new uint256[](transactionCount);\r\n\t\tuint256 count = 0;\r\n\t\tuint256 i;\r\n\t\tfor (i = 0; i < transactionCount; i++)\r\n\t\t\tif (\r\n\t\t\t\t(pending && !transactions[i].executed) ||\r\n\t\t\t\t(executed && transactions[i].executed)\r\n\t\t\t) {\r\n\t\t\t\ttransactionIdsTemp[count] = i;\r\n\t\t\t\tcount += 1;\r\n\t\t\t}\r\n\t\t_transactionIds = new uint256[](to - from);\r\n\t\tfor (i = from; i < to; i++)\r\n\t\t\t_transactionIds[i - from] = transactionIdsTemp[i];\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"revokeConfirmation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"confirmations\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pending\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmationCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"},{\"name\":\"pending\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionIds\",\"outputs\":[{\"name\":\"_transactionIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmations\",\"outputs\":[{\"name\":\"_confirmations\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transactionCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_required\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"submitTransaction\",\"outputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OWNER_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"replaceOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Revocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Submission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"ExecutionFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"RequirementChange\",\"type\":\"event\"}]","ContractName":"MultiSigWallet","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000005000000000000000000000000e2817d4af6f6cd8e580107f8594b11eb15dc8ccd000000000000000000000000c05ed3743d87bee34b76792d28347478015d775400000000000000000000000074c1213eda337e47fb7c72a55ab03eaa1e3c83660000000000000000000000009a2b676266ef3710e0271a93a1b4b9ef57a8b45f000000000000000000000000b6349a0cf54fa13bfa250e8d6a2d55f4f86be03d","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f8e421dfda19ada34bdb137dbd1e757ea686861dcb24f19ecc42ea5a2ed555c8"}]}