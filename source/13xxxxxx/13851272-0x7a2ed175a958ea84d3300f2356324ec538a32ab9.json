{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.12;\r\n\r\n/** \r\n * Utilities library\r\n */\r\nlibrary Utilities {\r\n\t// concat two bytes objects\r\n    function concat(bytes memory a, bytes memory b)\r\n            internal pure returns (bytes memory) {\r\n        return abi.encodePacked(a, b);\r\n    }\r\n\r\n    // convert address to bytes\r\n    function toBytes(address x) internal pure returns (bytes memory b) { \r\n\t\tb = new bytes(20); \r\n\t\r\n\t\tfor (uint i = 0; i < 20; i++) \r\n\t\t\tb[i] = byte(uint8(uint(x) / (2**(8*(19 - i))))); \r\n\t}\r\n\r\n\t// convert uint256 to bytes\r\n\tfunction toBytes(uint256 x) internal pure returns (bytes memory b) {\r\n    \tb = new bytes(32);\r\n    \tassembly { mstore(add(b, 32), x) }\r\n\t}\r\n}\r\n\r\n\r\ninterface DadaCollectible {\r\n    function DrawingPrintToAddress(uint256) external view returns (address);\r\n}\r\n\r\n/*\r\n * @title Contract that allows an owner of a Creep to scribe a message attached to the token.\r\n * There's no limit on the number of messages they can scribe or the length for a single message\r\n * Each message is an on-chain transaction requiring gas\r\n * @dev Conlan Rios\r\n * Modified by sparrow\r\n */\r\ncontract Scribe {\r\naddress creepsContract = 0x068696A3cf3c4676B65F1c9975dd094260109d02;\r\n//address creepsContract = 0xbc2Df256FA6FAd53BfBf0a054aBF43561AcAafe3;\r\n// A record event that emits each time an owner dictates a message\r\n\tevent Record (\r\n\t// the address of who dicated this document\r\n\taddress dictator,\r\n        // The Creep printIndex\r\n\tuint printIndex,\r\n        // The text of the dictation\r\n        string text\r\n    );\r\n    \r\n    uint256 creepOwner;\r\n\r\n\t// A recorded document which tracks the dictator, the text, and the timestamp of when it was created\r\n\tstruct Document {\r\n\t\t// the address of who dicated this document\r\n\t\taddress dictator;\r\n\t\t// the text of the dictation\r\n\t\tstring text;\r\n\t\t// the block time of the dictation\r\n\t\tuint creationTime;\r\n\t}\r\n\t\r\n\tfunction getOwner(uint256 printIndex) public view returns (address) {\r\n     return DadaCollectible(creepsContract).DrawingPrintToAddress(printIndex);\r\n     \r\n    }\r\n\r\n\t// Mapping of document keys to documents (keys are concated token address + tokenId)\r\n\tmapping (uint256 => Document[]) public documents;\r\n\t\r\n\t// Mapping of document keys to the count of dictated documents\r\n\tmapping (uint256 => uint) public documentsCount;\r\n\r\n\t// Function for dictating an owner message\r\n\tfunction dictate(uint256 printIndex, string memory _text) public {\r\n\t\t// check that the message sender owns the token \r\n\t\t// the function in DadaCollectible.sol that returns the owner address given a unique printIndex\r\n\t\t// is DrawingPrintToAddress\r\n\t\trequire(getOwner(printIndex) == msg.sender, \"Sender not authorized to dictate.\");\r\n\r\n\t\t// push a new document with the dictator address, message, and timestamp\r\n\t\tdocuments[printIndex].push(Document(msg.sender, _text, block.timestamp));\r\n\t\t// increase the documents counter for this key\r\n\t\tdocumentsCount[printIndex]++;\r\n\t\t// emit an event for this newly created record\r\n\t\temit Record(msg.sender, printIndex, _text);\r\n\t}\r\n\t\r\n\t// Function for getting the document key for a given printIndex\r\n\tfunction getDocumentKey(uint256 _printIndex) public pure returns (bytes memory) {\r\n\t\treturn Utilities.toBytes(_printIndex);\r\n\t}\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dictator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"printIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"text\",\"type\":\"string\"}],\"name\":\"Record\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"printIndex\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_text\",\"type\":\"string\"}],\"name\":\"dictate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"documents\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"dictator\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"text\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"creationTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"documentsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_printIndex\",\"type\":\"uint256\"}],\"name\":\"getDocumentKey\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"printIndex\",\"type\":\"uint256\"}],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Scribe","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://7e8650c1be4ad428a77297567cefee3e7f0ab291bc87343dfa6af7e6a300e727"}]}