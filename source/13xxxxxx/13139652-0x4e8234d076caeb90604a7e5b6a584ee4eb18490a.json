{"status":"1","message":"OK","result":[{"SourceCode":"{\"ERC721.sol\":{\"content\":\"pragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nabstract contract Context {\\n\\tfunction _msgSender() internal view virtual returns (address payable) {\\n\\t\\treturn msg.sender;\\n\\t}\\n\\n\\tfunction _msgData() internal view virtual returns (bytes memory) {\\n\\t\\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n\\t\\treturn msg.data;\\n\\t}\\n}\\n\\nlibrary Base64 {\\n\\tbytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n\\t/// @notice Encodes some bytes to the base64 representation\\n\\tfunction encode(bytes memory data) internal pure returns (string memory) {\\n\\t\\tuint256 len = data.length;\\n\\t\\tif (len == 0) return \\\"\\\";\\n\\n\\t\\t// multiply by 4/3 rounded up\\n\\t\\tuint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n\\t\\t// Add some extra buffer at the end\\n\\t\\tbytes memory result = new bytes(encodedLen + 32);\\n\\n\\t\\tbytes memory table = TABLE;\\n\\n\\t\\tassembly {\\n\\t\\t\\tlet tablePtr := add(table, 1)\\n\\t\\t\\tlet resultPtr := add(result, 32)\\n\\n\\t\\t\\tfor {\\n\\t\\t\\t\\tlet i := 0\\n\\t\\t\\t} lt(i, len) {\\n\\n\\t\\t\\t} {\\n\\t\\t\\t\\ti := add(i, 3)\\n\\t\\t\\t\\tlet input := and(mload(add(data, i)), 0xffffff)\\n\\n\\t\\t\\t\\tlet out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n\\t\\t\\t\\tout := shl(8, out)\\n\\t\\t\\t\\tout := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n\\t\\t\\t\\tout := shl(8, out)\\n\\t\\t\\t\\tout := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n\\t\\t\\t\\tout := shl(8, out)\\n\\t\\t\\t\\tout := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n\\t\\t\\t\\tout := shl(224, out)\\n\\n\\t\\t\\t\\tmstore(resultPtr, out)\\n\\n\\t\\t\\t\\tresultPtr := add(resultPtr, 4)\\n\\t\\t\\t}\\n\\n\\t\\t\\tswitch mod(len, 3)\\n\\t\\t\\tcase 1 {\\n\\t\\t\\t\\tmstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n\\t\\t\\t}\\n\\t\\t\\tcase 2 {\\n\\t\\t\\t\\tmstore(sub(resultPtr, 1), shl(248, 0x3d))\\n\\t\\t\\t}\\n\\n\\t\\t\\tmstore(result, encodedLen)\\n\\t\\t}\\n\\n\\t\\treturn string(result);\\n\\t}\\n}\\n\\ninterface LootInterface {\\n\\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\\n}\\n\\nabstract contract Ownable is Context {\\n\\taddress private _owner;\\n\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\t/**\\n\\t * @dev Initializes the contract setting the deployer as the initial owner.\\n\\t */\\n\\tconstructor () internal {\\n\\t\\t//address msgSender = _msgSender();\\n\\t\\t_owner = 0x8Ce045fEbF4772070F1e983241763306889D14d3;\\n\\t\\t//emit OwnershipTransferred(address(0), msgSender);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the address of the current owner.\\n\\t */\\n\\tfunction owner() public view virtual returns (address) {\\n\\t\\treturn _owner;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Throws if called by any account other than the owner.\\n\\t */\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Leaves the contract without owner. It will not be possible to call\\n\\t * `onlyOwner` functions anymore. Can only be called by the current owner.\\n\\t *\\n\\t * NOTE: Renouncing ownership will leave the contract without an owner,\\n\\t * thereby removing any functionality that is only available to the owner.\\n\\t */\\n\\tfunction renounceOwnership() public virtual onlyOwner {\\n\\t\\temit OwnershipTransferred(_owner, address(0));\\n\\t\\t_owner = address(0);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n\\t * Can only be called by the current owner.\\n\\t */\\n\\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\\n\\t\\trequire(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n\\t\\temit OwnershipTransferred(_owner, newOwner);\\n\\t\\t_owner = newOwner;\\n\\t}\\n}\\n\\nabstract contract ReentrancyGuard {\\n\\t// Booleans are more expensive than uint256 or any type that takes up a full\\n\\t// word because each write operation emits an extra SLOAD to first read the\\n\\t// slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n\\t// back. This is the compiler\\u0027s defense against contract upgrades and\\n\\t// pointer aliasing, and it cannot be disabled.\\n\\n\\t// The values being non-zero value makes deployment a bit more expensive,\\n\\t// but in exchange the refund on every call to nonReentrant will be lower in\\n\\t// amount. Since refunds are capped to a percentage of the total\\n\\t// transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n\\t// increase the likelihood of the full refund coming into effect.\\n\\tuint256 private constant _NOT_ENTERED = 1;\\n\\tuint256 private constant _ENTERED = 2;\\n\\n\\tuint256 private _status;\\n\\n\\tconstructor() {\\n\\t\\t_status = _NOT_ENTERED;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Prevents a contract from calling itself, directly or indirectly.\\n\\t * Calling a `nonReentrant` function from another `nonReentrant`\\n\\t * function is not supported. It is possible to prevent this from happening\\n\\t * by making the `nonReentrant` function external, and make it call a\\n\\t * `private` function that does the actual work.\\n\\t */\\n\\tmodifier nonReentrant() {\\n\\t\\t// On the first call to nonReentrant, _notEntered will be true\\n\\t\\trequire(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n\\t\\t// Any calls to nonReentrant after this point will fail\\n\\t\\t_status = _ENTERED;\\n\\n\\t\\t_;\\n\\n\\t\\t// By storing the original value once again, a refund is triggered (see\\n\\t\\t// https://eips.ethereum.org/EIPS/eip-2200)\\n\\t\\t_status = _NOT_ENTERED;\\n\\t}\\n}\\n\\ninterface IERC721Receiver {\\n\\t/**\\n\\t * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n\\t * by `operator` from `from`, this function is called.\\n\\t *\\n\\t * It must return its Solidity selector to confirm the token transfer.\\n\\t * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n\\t *\\n\\t * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n\\t */\\n\\tfunction onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\\nlibrary Strings {\\n\\t/**\\n\\t * @dev Converts a `uint256` to its ASCII `string` representation.\\n\\t */\\n\\tfunction toString(uint256 value) internal pure returns (string memory) {\\n\\t\\t// Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n\\t\\t// https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n\\t\\tif (value == 0) {\\n\\t\\t\\treturn \\\"0\\\";\\n\\t\\t}\\n\\t\\tuint256 temp = value;\\n\\t\\tuint256 digits;\\n\\t\\twhile (temp != 0) {\\n\\t\\t\\tdigits++;\\n\\t\\t\\ttemp /= 10;\\n\\t\\t}\\n\\t\\tbytes memory buffer = new bytes(digits);\\n\\t\\tuint256 index = digits - 1;\\n\\t\\ttemp = value;\\n\\t\\twhile (temp != 0) {\\n\\t\\t\\tbuffer[index--] = bytes1(uint8(48 + temp % 10));\\n\\t\\t\\ttemp /= 10;\\n\\t\\t}\\n\\t\\treturn string(buffer);\\n\\t}\\n}\\n\\nlibrary EnumerableMap {\\n\\t// To implement this library for multiple types with as little code\\n\\t// repetition as possible, we write it in terms of a generic Map type with\\n\\t// bytes32 keys and values.\\n\\t// The Map implementation uses private functions, and user-facing\\n\\t// implementations (such as Uint256ToAddressMap) are just wrappers around\\n\\t// the underlying Map.\\n\\t// This means that we can only create new EnumerableMaps for types that fit\\n\\t// in bytes32.\\n\\n\\tstruct MapEntry {\\n\\t\\tbytes32 _key;\\n\\t\\tbytes32 _value;\\n\\t}\\n\\n\\tstruct Map {\\n\\t\\t// Storage of map keys and values\\n\\t\\tMapEntry[] _entries;\\n\\n\\t\\t// Position of the entry defined by a key in the `entries` array, plus 1\\n\\t\\t// because index 0 means a key is not in the map.\\n\\t\\tmapping (bytes32 =\\u003e uint256) _indexes;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Adds a key-value pair to a map, or updates the value for an existing\\n\\t * key. O(1).\\n\\t *\\n\\t * Returns true if the key was added to the map, that is if it was not\\n\\t * already present.\\n\\t */\\n\\tfunction _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\n\\t\\t// We read and store the key\\u0027s index to prevent multiple reads from the same storage slot\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\n\\t\\tif (keyIndex == 0) { // Equivalent to !contains(map, key)\\n\\t\\t\\tmap._entries.push(MapEntry({ _key: key, _value: value }));\\n\\t\\t\\t// The entry is stored at length-1, but we add 1 to all indexes\\n\\t\\t\\t// and use 0 as a sentinel value\\n\\t\\t\\tmap._indexes[key] = map._entries.length;\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tmap._entries[keyIndex - 1]._value = value;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Removes a key-value pair from a map. O(1).\\n\\t *\\n\\t * Returns true if the key was removed from the map, that is if it was present.\\n\\t */\\n\\tfunction _remove(Map storage map, bytes32 key) private returns (bool) {\\n\\t\\t// We read and store the key\\u0027s index to prevent multiple reads from the same storage slot\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\n\\t\\tif (keyIndex != 0) { // Equivalent to contains(map, key)\\n\\t\\t\\t// To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\\n\\t\\t\\t// in the array, and then remove the last entry (sometimes called as \\u0027swap and pop\\u0027).\\n\\t\\t\\t// This modifies the order of the array, as noted in {at}.\\n\\n\\t\\t\\tuint256 toDeleteIndex = keyIndex - 1;\\n\\t\\t\\tuint256 lastIndex = map._entries.length - 1;\\n\\n\\t\\t\\t// When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n\\t\\t\\t// so rarely, we still do the swap anyway to avoid the gas cost of adding an \\u0027if\\u0027 statement.\\n\\n\\t\\t\\tMapEntry storage lastEntry = map._entries[lastIndex];\\n\\n\\t\\t\\t// Move the last entry to the index where the entry to delete is\\n\\t\\t\\tmap._entries[toDeleteIndex] = lastEntry;\\n\\t\\t\\t// Update the index for the moved entry\\n\\t\\t\\tmap._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n\\t\\t\\t// Delete the slot where the moved entry was stored\\n\\t\\t\\tmap._entries.pop();\\n\\n\\t\\t\\t// Delete the index for the deleted slot\\n\\t\\t\\tdelete map._indexes[key];\\n\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns true if the key is in the map. O(1).\\n\\t */\\n\\tfunction _contains(Map storage map, bytes32 key) private view returns (bool) {\\n\\t\\treturn map._indexes[key] != 0;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the number of key-value pairs in the map. O(1).\\n\\t */\\n\\tfunction _length(Map storage map) private view returns (uint256) {\\n\\t\\treturn map._entries.length;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n\\t *\\n\\t * Note that there are no guarantees on the ordering of entries inside the\\n\\t * array, and it may change when more entries are added or removed.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `index` must be strictly less than {length}.\\n\\t */\\n\\tfunction _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n\\t\\trequire(map._entries.length \\u003e index, \\\"EnumerableMap: index out of bounds\\\");\\n\\n\\t\\tMapEntry storage entry = map._entries[index];\\n\\t\\treturn (entry._key, entry._value);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Tries to returns the value associated with `key`.  O(1).\\n\\t * Does not revert if `key` is not in the map.\\n\\t */\\n\\tfunction _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\t\\tif (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\\n\\t\\treturn (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the value associated with `key`.  O(1).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `key` must be in the map.\\n\\t */\\n\\tfunction _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\t\\trequire(keyIndex != 0, \\\"EnumerableMap: nonexistent key\\\"); // Equivalent to contains(map, key)\\n\\t\\treturn map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n\\t *\\n\\t * CAUTION: This function is deprecated because it requires allocating memory for the error\\n\\t * message unnecessarily. For custom revert reasons use {_tryGet}.\\n\\t */\\n\\tfunction _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\n\\t\\tuint256 keyIndex = map._indexes[key];\\n\\t\\trequire(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\\n\\t\\treturn map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n\\t}\\n\\n\\t// UintToAddressMap\\n\\n\\tstruct UintToAddressMap {\\n\\t\\tMap _inner;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Adds a key-value pair to a map, or updates the value for an existing\\n\\t * key. O(1).\\n\\t *\\n\\t * Returns true if the key was added to the map, that is if it was not\\n\\t * already present.\\n\\t */\\n\\tfunction set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n\\t\\treturn _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Removes a value from a set. O(1).\\n\\t *\\n\\t * Returns true if the key was removed from the map, that is if it was present.\\n\\t */\\n\\tfunction remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n\\t\\treturn _remove(map._inner, bytes32(key));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns true if the key is in the map. O(1).\\n\\t */\\n\\tfunction contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n\\t\\treturn _contains(map._inner, bytes32(key));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the number of elements in the map. O(1).\\n\\t */\\n\\tfunction length(UintToAddressMap storage map) internal view returns (uint256) {\\n\\t\\treturn _length(map._inner);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the element stored at position `index` in the set. O(1).\\n\\t * Note that there are no guarantees on the ordering of values inside the\\n\\t * array, and it may change when more values are added or removed.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `index` must be strictly less than {length}.\\n\\t */\\n\\tfunction at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n\\t\\t(bytes32 key, bytes32 value) = _at(map._inner, index);\\n\\t\\treturn (uint256(key), address(uint160(uint256(value))));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Tries to returns the value associated with `key`.  O(1).\\n\\t * Does not revert if `key` is not in the map.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n\\t\\t(bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\\n\\t\\treturn (success, address(uint160(uint256(value))));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the value associated with `key`.  O(1).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `key` must be in the map.\\n\\t */\\n\\tfunction get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n\\t\\treturn address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n\\t *\\n\\t * CAUTION: This function is deprecated because it requires allocating memory for the error\\n\\t * message unnecessarily. For custom revert reasons use {tryGet}.\\n\\t */\\n\\tfunction get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\n\\t\\treturn address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\\n\\t}\\n}\\n\\nlibrary EnumerableSet {\\n\\t// To implement this library for multiple types with as little code\\n\\t// repetition as possible, we write it in terms of a generic Set type with\\n\\t// bytes32 values.\\n\\t// The Set implementation uses private functions, and user-facing\\n\\t// implementations (such as AddressSet) are just wrappers around the\\n\\t// underlying Set.\\n\\t// This means that we can only create new EnumerableSets for types that fit\\n\\t// in bytes32.\\n\\n\\tstruct Set {\\n\\t\\t// Storage of set values\\n\\t\\tbytes32[] _values;\\n\\n\\t\\t// Position of the value in the `values` array, plus 1 because index 0\\n\\t\\t// means a value is not in the set.\\n\\t\\tmapping (bytes32 =\\u003e uint256) _indexes;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Add a value to a set. O(1).\\n\\t *\\n\\t * Returns true if the value was added to the set, that is if it was not\\n\\t * already present.\\n\\t */\\n\\tfunction _add(Set storage set, bytes32 value) private returns (bool) {\\n\\t\\tif (!_contains(set, value)) {\\n\\t\\t\\tset._values.push(value);\\n\\t\\t\\t// The value is stored at length-1, but we add 1 to all indexes\\n\\t\\t\\t// and use 0 as a sentinel value\\n\\t\\t\\tset._indexes[value] = set._values.length;\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Removes a value from a set. O(1).\\n\\t *\\n\\t * Returns true if the value was removed from the set, that is if it was\\n\\t * present.\\n\\t */\\n\\tfunction _remove(Set storage set, bytes32 value) private returns (bool) {\\n\\t\\t// We read and store the value\\u0027s index to prevent multiple reads from the same storage slot\\n\\t\\tuint256 valueIndex = set._indexes[value];\\n\\n\\t\\tif (valueIndex != 0) { // Equivalent to contains(set, value)\\n\\t\\t\\t// To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n\\t\\t\\t// the array, and then remove the last element (sometimes called as \\u0027swap and pop\\u0027).\\n\\t\\t\\t// This modifies the order of the array, as noted in {at}.\\n\\n\\t\\t\\tuint256 toDeleteIndex = valueIndex - 1;\\n\\t\\t\\tuint256 lastIndex = set._values.length - 1;\\n\\n\\t\\t\\t// When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n\\t\\t\\t// so rarely, we still do the swap anyway to avoid the gas cost of adding an \\u0027if\\u0027 statement.\\n\\n\\t\\t\\tbytes32 lastvalue = set._values[lastIndex];\\n\\n\\t\\t\\t// Move the last value to the index where the value to delete is\\n\\t\\t\\tset._values[toDeleteIndex] = lastvalue;\\n\\t\\t\\t// Update the index for the moved value\\n\\t\\t\\tset._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n\\t\\t\\t// Delete the slot where the moved value was stored\\n\\t\\t\\tset._values.pop();\\n\\n\\t\\t\\t// Delete the index for the deleted slot\\n\\t\\t\\tdelete set._indexes[value];\\n\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns true if the value is in the set. O(1).\\n\\t */\\n\\tfunction _contains(Set storage set, bytes32 value) private view returns (bool) {\\n\\t\\treturn set._indexes[value] != 0;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the number of values on the set. O(1).\\n\\t */\\n\\tfunction _length(Set storage set) private view returns (uint256) {\\n\\t\\treturn set._values.length;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the value stored at position `index` in the set. O(1).\\n\\t *\\n\\t * Note that there are no guarantees on the ordering of values inside the\\n\\t * array, and it may change when more values are added or removed.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `index` must be strictly less than {length}.\\n\\t */\\n\\tfunction _at(Set storage set, uint256 index) private view returns (bytes32) {\\n\\t\\trequire(set._values.length \\u003e index, \\\"EnumerableSet: index out of bounds\\\");\\n\\t\\treturn set._values[index];\\n\\t}\\n\\n\\t// Bytes32Set\\n\\n\\tstruct Bytes32Set {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Add a value to a set. O(1).\\n\\t *\\n\\t * Returns true if the value was added to the set, that is if it was not\\n\\t * already present.\\n\\t */\\n\\tfunction add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, value);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Removes a value from a set. O(1).\\n\\t *\\n\\t * Returns true if the value was removed from the set, that is if it was\\n\\t * present.\\n\\t */\\n\\tfunction remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, value);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns true if the value is in the set. O(1).\\n\\t */\\n\\tfunction contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, value);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the number of values in the set. O(1).\\n\\t */\\n\\tfunction length(Bytes32Set storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the value stored at position `index` in the set. O(1).\\n\\t *\\n\\t * Note that there are no guarantees on the ordering of values inside the\\n\\t * array, and it may change when more values are added or removed.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `index` must be strictly less than {length}.\\n\\t */\\n\\tfunction at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n\\t\\treturn _at(set._inner, index);\\n\\t}\\n\\n\\t// AddressSet\\n\\n\\tstruct AddressSet {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Add a value to a set. O(1).\\n\\t *\\n\\t * Returns true if the value was added to the set, that is if it was not\\n\\t * already present.\\n\\t */\\n\\tfunction add(AddressSet storage set, address value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Removes a value from a set. O(1).\\n\\t *\\n\\t * Returns true if the value was removed from the set, that is if it was\\n\\t * present.\\n\\t */\\n\\tfunction remove(AddressSet storage set, address value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns true if the value is in the set. O(1).\\n\\t */\\n\\tfunction contains(AddressSet storage set, address value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, bytes32(uint256(uint160(value))));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the number of values in the set. O(1).\\n\\t */\\n\\tfunction length(AddressSet storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the value stored at position `index` in the set. O(1).\\n\\t *\\n\\t * Note that there are no guarantees on the ordering of values inside the\\n\\t * array, and it may change when more values are added or removed.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `index` must be strictly less than {length}.\\n\\t */\\n\\tfunction at(AddressSet storage set, uint256 index) internal view returns (address) {\\n\\t\\treturn address(uint160(uint256(_at(set._inner, index))));\\n\\t}\\n\\n\\n\\t// UintSet\\n\\n\\tstruct UintSet {\\n\\t\\tSet _inner;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Add a value to a set. O(1).\\n\\t *\\n\\t * Returns true if the value was added to the set, that is if it was not\\n\\t * already present.\\n\\t */\\n\\tfunction add(UintSet storage set, uint256 value) internal returns (bool) {\\n\\t\\treturn _add(set._inner, bytes32(value));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Removes a value from a set. O(1).\\n\\t *\\n\\t * Returns true if the value was removed from the set, that is if it was\\n\\t * present.\\n\\t */\\n\\tfunction remove(UintSet storage set, uint256 value) internal returns (bool) {\\n\\t\\treturn _remove(set._inner, bytes32(value));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns true if the value is in the set. O(1).\\n\\t */\\n\\tfunction contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n\\t\\treturn _contains(set._inner, bytes32(value));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the number of values on the set. O(1).\\n\\t */\\n\\tfunction length(UintSet storage set) internal view returns (uint256) {\\n\\t\\treturn _length(set._inner);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the value stored at position `index` in the set. O(1).\\n\\t *\\n\\t * Note that there are no guarantees on the ordering of values inside the\\n\\t * array, and it may change when more values are added or removed.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `index` must be strictly less than {length}.\\n\\t */\\n\\tfunction at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n\\t\\treturn uint256(_at(set._inner, index));\\n\\t}\\n}\\n\\nlibrary Address {\\n\\t/**\\n\\t * @dev Returns true if `account` is a contract.\\n\\t *\\n\\t * [IMPORTANT]\\n\\t * ====\\n\\t * It is unsafe to assume that an address for which this function returns\\n\\t * false is an externally-owned account (EOA) and not a contract.\\n\\t *\\n\\t * Among others, `isContract` will return false for the following\\n\\t * types of addresses:\\n\\t *\\n\\t *  - an externally-owned account\\n\\t *  - a contract in construction\\n\\t *  - an address where a contract will be created\\n\\t *  - an address where a contract lived, but was destroyed\\n\\t * ====\\n\\t */\\n\\tfunction isContract(address account) internal view returns (bool) {\\n\\t\\t// This method relies on extcodesize, which returns 0 for contracts in\\n\\t\\t// construction, since the code is only stored at the end of the\\n\\t\\t// constructor execution.\\n\\n\\t\\tuint256 size;\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\n\\t\\tassembly { size := extcodesize(account) }\\n\\t\\treturn size \\u003e 0;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n\\t * `recipient`, forwarding all available gas and reverting on errors.\\n\\t *\\n\\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n\\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n\\t * imposed by `transfer`, making them unable to receive funds via\\n\\t * `transfer`. {sendValue} removes this limitation.\\n\\t *\\n\\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n\\t *\\n\\t * IMPORTANT: because control is transferred to `recipient`, care must be\\n\\t * taken to not create reentrancy vulnerabilities. Consider using\\n\\t * {ReentrancyGuard} or the\\n\\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n\\t */\\n\\tfunction sendValue(address payable recipient, uint256 amount) internal {\\n\\t\\trequire(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n\\t\\t// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n\\t\\t(bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n\\t\\trequire(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Performs a Solidity function call using a low level `call`. A\\n\\t * plain`call` is an unsafe replacement for a function call: use this\\n\\t * function instead.\\n\\t *\\n\\t * If `target` reverts with a revert reason, it is bubbled up by this\\n\\t * function (like regular Solidity function calls).\\n\\t *\\n\\t * Returns the raw returned data. To convert to the expected return value,\\n\\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `target` must be a contract.\\n\\t * - calling `target` with `data` must not revert.\\n\\t *\\n\\t * _Available since v3.1._\\n\\t */\\n\\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n\\t\\treturn functionCall(target, data, \\\"Address: low-level call failed\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n\\t * `errorMessage` as a fallback revert reason when `target` reverts.\\n\\t *\\n\\t * _Available since v3.1._\\n\\t */\\n\\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n\\t\\treturn functionCallWithValue(target, data, 0, errorMessage);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n\\t * but also transferring `value` wei to `target`.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the calling contract must have an ETH balance of at least `value`.\\n\\t * - the called Solidity function must be `payable`.\\n\\t *\\n\\t * _Available since v3.1._\\n\\t */\\n\\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n\\t\\treturn functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n\\t * with `errorMessage` as a fallback revert reason when `target` reverts.\\n\\t *\\n\\t * _Available since v3.1._\\n\\t */\\n\\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n\\t\\trequire(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n\\t\\trequire(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n\\t\\t// solhint-disable-next-line avoid-low-level-calls\\n\\t\\t(bool success, bytes memory returndata) = target.call{ value: value }(data);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n\\t * but performing a static call.\\n\\t *\\n\\t * _Available since v3.3._\\n\\t */\\n\\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n\\t\\treturn functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n\\t * but performing a static call.\\n\\t *\\n\\t * _Available since v3.3._\\n\\t */\\n\\tfunction functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n\\t\\trequire(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n\\t\\t// solhint-disable-next-line avoid-low-level-calls\\n\\t\\t(bool success, bytes memory returndata) = target.staticcall(data);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n\\t * but performing a delegate call.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n\\t\\treturn functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n\\t * but performing a delegate call.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n\\t\\trequire(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n\\t\\t// solhint-disable-next-line avoid-low-level-calls\\n\\t\\t(bool success, bytes memory returndata) = target.delegatecall(data);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\tfunction _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n\\t\\tif (success) {\\n\\t\\t\\treturn returndata;\\n\\t\\t} else {\\n\\t\\t\\t// Look for revert reason and bubble it up if present\\n\\t\\t\\tif (returndata.length \\u003e 0) {\\n\\t\\t\\t\\t// The easiest way to bubble the revert reason is using memory via assembly\\n\\n\\t\\t\\t\\t// solhint-disable-next-line no-inline-assembly\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tlet returndata_size := mload(returndata)\\n\\t\\t\\t\\t\\trevert(add(32, returndata), returndata_size)\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trevert(errorMessage);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nlibrary SafeMath {\\n\\t/**\\n\\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tuint256 c = a + b;\\n\\t\\tif (c \\u003c a) return (false, 0);\\n\\t\\treturn (true, c);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tif (b \\u003e a) return (false, 0);\\n\\t\\treturn (true, a - b);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\t// Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n\\t\\t// benefit is lost if \\u0027b\\u0027 is also tested.\\n\\t\\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n\\t\\tif (a == 0) return (true, 0);\\n\\t\\tuint256 c = a * b;\\n\\t\\tif (c / a != b) return (false, 0);\\n\\t\\treturn (true, c);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tif (b == 0) return (false, 0);\\n\\t\\treturn (true, a / b);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n\\t\\tif (b == 0) return (false, 0);\\n\\t\\treturn (true, a % b);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the addition of two unsigned integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `+` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Addition cannot overflow.\\n\\t */\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tuint256 c = a + b;\\n\\t\\trequire(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the subtraction of two unsigned integers, reverting on\\n\\t * overflow (when the result is negative).\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `-` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Subtraction cannot overflow.\\n\\t */\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n\\t\\treturn a - b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the multiplication of two unsigned integers, reverting on\\n\\t * overflow.\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `*` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Multiplication cannot overflow.\\n\\t */\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tif (a == 0) return 0;\\n\\t\\tuint256 c = a * b;\\n\\t\\trequire(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the integer division of two unsigned integers, reverting on\\n\\t * division by zero. The result is rounded towards zero.\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n\\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t * uses an invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n\\t\\treturn a / b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n\\t * reverting when dividing by zero.\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t * invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\n\\t\\treturn a % b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n\\t * overflow (when the result is negative).\\n\\t *\\n\\t * CAUTION: This function is deprecated because it requires allocating memory for the error\\n\\t * message unnecessarily. For custom revert reasons use {trySub}.\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `-` operator.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - Subtraction cannot overflow.\\n\\t */\\n\\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003c= a, errorMessage);\\n\\t\\treturn a - b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n\\t * division by zero. The result is rounded towards zero.\\n\\t *\\n\\t * CAUTION: This function is deprecated because it requires allocating memory for the error\\n\\t * message unnecessarily. For custom revert reasons use {tryDiv}.\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n\\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t * uses an invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, errorMessage);\\n\\t\\treturn a / b;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n\\t * reverting with custom message when dividing by zero.\\n\\t *\\n\\t * CAUTION: This function is deprecated because it requires allocating memory for the error\\n\\t * message unnecessarily. For custom revert reasons use {tryMod}.\\n\\t *\\n\\t * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t * invalid opcode to revert (consuming all remaining gas).\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The divisor cannot be zero.\\n\\t */\\n\\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\trequire(b \\u003e 0, errorMessage);\\n\\t\\treturn a % b;\\n\\t}\\n}\\n\\ninterface IERC165 {\\n\\t/**\\n\\t * @dev Returns true if this contract implements the interface defined by\\n\\t * `interfaceId`. See the corresponding\\n\\t * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n\\t * to learn more about how these ids are created.\\n\\t *\\n\\t * This function call must use less than 30 000 gas.\\n\\t */\\n\\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\nabstract contract ERC165 is IERC165 {\\n\\t/*\\n\\t * bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027)) == 0x01ffc9a7\\n\\t */\\n\\tbytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n\\t/**\\n\\t * @dev Mapping of interface ids to whether or not it\\u0027s supported.\\n\\t */\\n\\tmapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\n\\n\\tconstructor () internal {\\n\\t\\t// Derived contracts need only register support for their own interfaces,\\n\\t\\t// we register support for ERC165 itself here\\n\\t\\t_registerInterface(_INTERFACE_ID_ERC165);\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC165-supportsInterface}.\\n\\t *\\n\\t * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n\\t */\\n\\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n\\t\\treturn _supportedInterfaces[interfaceId];\\n\\t}\\n\\n\\t/**\\n\\t * @dev Registers the contract as an implementer of the interface defined by\\n\\t * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n\\t * registering its interface id is not required.\\n\\t *\\n\\t * See {IERC165-supportsInterface}.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n\\t */\\n\\tfunction _registerInterface(bytes4 interfaceId) internal virtual {\\n\\t\\trequire(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n\\t\\t_supportedInterfaces[interfaceId] = true;\\n\\t}\\n}\\n\\ninterface IERC721 is IERC165 {\\n\\t/**\\n\\t * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n\\t */\\n\\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n\\t/**\\n\\t * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n\\t */\\n\\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n\\t/**\\n\\t * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n\\t */\\n\\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n\\t/**\\n\\t * @dev Returns the number of tokens in ``owner``\\u0027s account.\\n\\t */\\n\\tfunction balanceOf(address owner) external view returns (uint256 balance);\\n\\n\\t/**\\n\\t * @dev Returns the owner of the `tokenId` token.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `tokenId` must exist.\\n\\t */\\n\\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n\\t/**\\n\\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n\\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `from` cannot be the zero address.\\n\\t * - `to` cannot be the zero address.\\n\\t * - `tokenId` token must exist and be owned by `from`.\\n\\t * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n\\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n\\t/**\\n\\t * @dev Transfers `tokenId` token from `from` to `to`.\\n\\t *\\n\\t * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `from` cannot be the zero address.\\n\\t * - `to` cannot be the zero address.\\n\\t * - `tokenId` token must be owned by `from`.\\n\\t * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction transferFrom(address from, address to, uint256 tokenId) external;\\n\\n\\t/**\\n\\t * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n\\t * The approval is cleared when the token is transferred.\\n\\t *\\n\\t * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The caller must own the token or be an approved operator.\\n\\t * - `tokenId` must exist.\\n\\t *\\n\\t * Emits an {Approval} event.\\n\\t */\\n\\tfunction approve(address to, uint256 tokenId) external;\\n\\n\\t/**\\n\\t * @dev Returns the account approved for `tokenId` token.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `tokenId` must exist.\\n\\t */\\n\\tfunction getApproved(uint256 tokenId) external view returns (address operator);\\n\\n\\t/**\\n\\t * @dev Approve or remove `operator` as an operator for the caller.\\n\\t * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - The `operator` cannot be the caller.\\n\\t *\\n\\t * Emits an {ApprovalForAll} event.\\n\\t */\\n\\tfunction setApprovalForAll(address operator, bool _approved) external;\\n\\n\\t/**\\n\\t * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n\\t *\\n\\t * See {setApprovalForAll}\\n\\t */\\n\\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n\\t/**\\n\\t  * @dev Safely transfers `tokenId` token from `from` to `to`.\\n\\t  *\\n\\t  * Requirements:\\n\\t  *\\n\\t  * - `from` cannot be the zero address.\\n\\t  * - `to` cannot be the zero address.\\n\\t  * - `tokenId` token must exist and be owned by `from`.\\n\\t  * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n\\t  * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n\\t  *\\n\\t  * Emits a {Transfer} event.\\n\\t  */\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\\ninterface IERC721Enumerable is IERC721 {\\n\\n\\t/**\\n\\t * @dev Returns the total amount of tokens stored by the contract.\\n\\t */\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n\\t * Use along with {balanceOf} to enumerate all of ``owner``\\u0027s tokens.\\n\\t */\\n\\tfunction tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n\\t/**\\n\\t * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n\\t * Use along with {totalSupply} to enumerate all tokens.\\n\\t */\\n\\tfunction tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\\ninterface IERC721Metadata is IERC721 {\\n\\n\\t/**\\n\\t * @dev Returns the token collection name.\\n\\t */\\n\\tfunction name() external view returns (string memory);\\n\\n\\t/**\\n\\t * @dev Returns the token collection symbol.\\n\\t */\\n\\tfunction symbol() external view returns (string memory);\\n\\n\\t/**\\n\\t * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n\\t */\\n\\tfunction tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n\\tusing SafeMath for uint256;\\n\\tusing Address for address;\\n\\tusing EnumerableSet for EnumerableSet.UintSet;\\n\\tusing EnumerableMap for EnumerableMap.UintToAddressMap;\\n\\tusing Strings for uint256;\\n\\n\\t// Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n\\t// which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n\\tbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n\\t// Mapping from holder address to their (enumerable) set of owned tokens\\n\\tmapping (address =\\u003e EnumerableSet.UintSet) private _holderTokens;\\n\\n\\t// Enumerable mapping from token ids to their owners\\n\\tEnumerableMap.UintToAddressMap private _tokenOwners;\\n\\n\\t// Mapping from token ID to approved address\\n\\tmapping (uint256 =\\u003e address) private _tokenApprovals;\\n\\n\\t// Mapping from owner to operator approvals\\n\\tmapping (address =\\u003e mapping (address =\\u003e bool)) private _operatorApprovals;\\n\\n\\t// Token name\\n\\tstring private _name;\\n\\n\\t// Token symbol\\n\\tstring private _symbol;\\n\\n\\t// Optional mapping for token URIs\\n\\tmapping (uint256 =\\u003e string) private _tokenURIs;\\n\\n\\t// Base URI\\n\\tstring private _baseURI;\\n\\n\\t/*\\n\\t *     bytes4(keccak256(\\u0027balanceOf(address)\\u0027)) == 0x70a08231\\n\\t *     bytes4(keccak256(\\u0027ownerOf(uint256)\\u0027)) == 0x6352211e\\n\\t *     bytes4(keccak256(\\u0027approve(address,uint256)\\u0027)) == 0x095ea7b3\\n\\t *     bytes4(keccak256(\\u0027getApproved(uint256)\\u0027)) == 0x081812fc\\n\\t *     bytes4(keccak256(\\u0027setApprovalForAll(address,bool)\\u0027)) == 0xa22cb465\\n\\t *     bytes4(keccak256(\\u0027isApprovedForAll(address,address)\\u0027)) == 0xe985e9c5\\n\\t *     bytes4(keccak256(\\u0027transferFrom(address,address,uint256)\\u0027)) == 0x23b872dd\\n\\t *     bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256)\\u0027)) == 0x42842e0e\\n\\t *     bytes4(keccak256(\\u0027safeTransferFrom(address,address,uint256,bytes)\\u0027)) == 0xb88d4fde\\n\\t *\\n\\t *     =\\u003e 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n\\t *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n\\t */\\n\\tbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n\\t/*\\n\\t *     bytes4(keccak256(\\u0027name()\\u0027)) == 0x06fdde03\\n\\t *     bytes4(keccak256(\\u0027symbol()\\u0027)) == 0x95d89b41\\n\\t *     bytes4(keccak256(\\u0027tokenURI(uint256)\\u0027)) == 0xc87b56dd\\n\\t *\\n\\t *     =\\u003e 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n\\t */\\n\\tbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n\\t/*\\n\\t *     bytes4(keccak256(\\u0027totalSupply()\\u0027)) == 0x18160ddd\\n\\t *     bytes4(keccak256(\\u0027tokenOfOwnerByIndex(address,uint256)\\u0027)) == 0x2f745c59\\n\\t *     bytes4(keccak256(\\u0027tokenByIndex(uint256)\\u0027)) == 0x4f6ccce7\\n\\t *\\n\\t *     =\\u003e 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n\\t */\\n\\tbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n\\t/**\\n\\t * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n\\t */\\n\\tconstructor (string memory name_, string memory symbol_) public {\\n\\t\\t_name = name_;\\n\\t\\t_symbol = symbol_;\\n\\n\\t\\t// register the supported interfaces to conform to ERC721 via ERC165\\n\\t\\t_registerInterface(_INTERFACE_ID_ERC721);\\n\\t\\t_registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n\\t\\t_registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721-balanceOf}.\\n\\t */\\n\\tfunction balanceOf(address owner) public view virtual override returns (uint256) {\\n\\t\\trequire(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n\\t\\treturn _holderTokens[owner].length();\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721-ownerOf}.\\n\\t */\\n\\tfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n\\t\\treturn _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721Metadata-name}.\\n\\t */\\n\\tfunction name() public view virtual override returns (string memory) {\\n\\t\\treturn _name;\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721Metadata-symbol}.\\n\\t */\\n\\tfunction symbol() public view virtual override returns (string memory) {\\n\\t\\treturn _symbol;\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721Metadata-tokenURI}.\\n\\t */\\n\\tfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n\\t\\trequire(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n\\t\\tstring memory _tokenURI = _tokenURIs[tokenId];\\n\\t\\tstring memory base = baseURI();\\n\\n\\t\\t// If there is no base URI, return the token URI.\\n\\t\\tif (bytes(base).length == 0) {\\n\\t\\t\\treturn _tokenURI;\\n\\t\\t}\\n\\t\\t// If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n\\t\\tif (bytes(_tokenURI).length \\u003e 0) {\\n\\t\\t\\treturn string(abi.encodePacked(base, _tokenURI));\\n\\t\\t}\\n\\t\\t// If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\\n\\t\\treturn string(abi.encodePacked(base, tokenId.toString()));\\n\\t}\\n\\n\\t/**\\n\\t* @dev Returns the base URI set via {_setBaseURI}. This will be\\n\\t* automatically added as a prefix in {tokenURI} to each token\\u0027s URI, or\\n\\t* to the token ID if no specific URI is set for that token ID.\\n\\t*/\\n\\tfunction baseURI() public view virtual returns (string memory) {\\n\\t\\treturn _baseURI;\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n\\t */\\n\\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n\\t\\treturn _holderTokens[owner].at(index);\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721Enumerable-totalSupply}.\\n\\t */\\n\\tfunction totalSupply() public view virtual override returns (uint256) {\\n\\t\\t// _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\n\\t\\treturn _tokenOwners.length();\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721Enumerable-tokenByIndex}.\\n\\t */\\n\\tfunction tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n\\t\\t(uint256 tokenId, ) = _tokenOwners.at(index);\\n\\t\\treturn tokenId;\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721-approve}.\\n\\t */\\n\\tfunction approve(address to, uint256 tokenId) public virtual override {\\n\\t\\taddress owner = ERC721.ownerOf(tokenId);\\n\\t\\trequire(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n\\t\\trequire(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\\n\\t\\t\\t\\\"ERC721: approve caller is not owner nor approved for all\\\"\\n\\t\\t);\\n\\n\\t\\t_approve(to, tokenId);\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721-getApproved}.\\n\\t */\\n\\tfunction getApproved(uint256 tokenId) public view virtual override returns (address) {\\n\\t\\trequire(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n\\t\\treturn _tokenApprovals[tokenId];\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721-setApprovalForAll}.\\n\\t */\\n\\tfunction setApprovalForAll(address operator, bool approved) public virtual override {\\n\\t\\trequire(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n\\t\\t_operatorApprovals[_msgSender()][operator] = approved;\\n\\t\\temit ApprovalForAll(_msgSender(), operator, approved);\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721-isApprovedForAll}.\\n\\t */\\n\\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n\\t\\treturn _operatorApprovals[owner][operator];\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721-transferFrom}.\\n\\t */\\n\\tfunction transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n\\t\\t//solhint-disable-next-line max-line-length\\n\\t\\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n\\t\\t_transfer(from, to, tokenId);\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721-safeTransferFrom}.\\n\\t */\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n\\t\\tsafeTransferFrom(from, to, tokenId, \\\"\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC721-safeTransferFrom}.\\n\\t */\\n\\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n\\t\\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\t\\t_safeTransfer(from, to, tokenId, _data);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n\\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n\\t *\\n\\t * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n\\t *\\n\\t * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n\\t * implement alternative mechanisms to perform token transfer, such as signature-based.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `from` cannot be the zero address.\\n\\t * - `to` cannot be the zero address.\\n\\t * - `tokenId` token must exist and be owned by `from`.\\n\\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n\\t\\t_transfer(from, to, tokenId);\\n\\t\\trequire(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns whether `tokenId` exists.\\n\\t *\\n\\t * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n\\t *\\n\\t * Tokens start existing when they are minted (`_mint`),\\n\\t * and stop existing when they are burned (`_burn`).\\n\\t */\\n\\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\\n\\t\\treturn _tokenOwners.contains(tokenId);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `tokenId` must exist.\\n\\t */\\n\\tfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n\\t\\trequire(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n\\t\\taddress owner = ERC721.ownerOf(tokenId);\\n\\t\\treturn (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Safely mints `tokenId` and transfers it to `to`.\\n\\t *\\n\\t * Requirements:\\n\\t d*\\n\\t * - `tokenId` must not exist.\\n\\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction _safeMint(address to, uint256 tokenId) internal virtual {\\n\\t\\t_safeMint(to, tokenId, \\\"\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n\\t * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n\\t */\\n\\tfunction _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n\\t\\t_mint(to, tokenId);\\n\\t\\trequire(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Mints `tokenId` and transfers it to `to`.\\n\\t *\\n\\t * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `tokenId` must not exist.\\n\\t * - `to` cannot be the zero address.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction _mint(address to, uint256 tokenId) internal virtual {\\n\\t\\trequire(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n\\t\\trequire(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n\\t\\t_beforeTokenTransfer(address(0), to, tokenId);\\n\\n\\t\\t_holderTokens[to].add(tokenId);\\n\\n\\t\\t_tokenOwners.set(tokenId, to);\\n\\n\\t\\temit Transfer(address(0), to, tokenId);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Destroys `tokenId`.\\n\\t * The approval is cleared when the token is burned.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `tokenId` must exist.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction _burn(uint256 tokenId) internal virtual {\\n\\t\\taddress owner = ERC721.ownerOf(tokenId); // internal owner\\n\\n\\t\\t_beforeTokenTransfer(owner, address(0), tokenId);\\n\\n\\t\\t// Clear approvals\\n\\t\\t_approve(address(0), tokenId);\\n\\n\\t\\t// Clear metadata (if any)\\n\\t\\tif (bytes(_tokenURIs[tokenId]).length != 0) {\\n\\t\\t\\tdelete _tokenURIs[tokenId];\\n\\t\\t}\\n\\n\\t\\t_holderTokens[owner].remove(tokenId);\\n\\n\\t\\t_tokenOwners.remove(tokenId);\\n\\n\\t\\temit Transfer(owner, address(0), tokenId);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Transfers `tokenId` from `from` to `to`.\\n\\t *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `to` cannot be the zero address.\\n\\t * - `tokenId` token must be owned by `from`.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction _transfer(address from, address to, uint256 tokenId) internal virtual {\\n\\t\\trequire(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\"); // internal owner\\n\\t\\trequire(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n\\t\\t_beforeTokenTransfer(from, to, tokenId);\\n\\n\\t\\t// Clear approvals from the previous owner\\n\\t\\t_approve(address(0), tokenId);\\n\\n\\t\\t_holderTokens[from].remove(tokenId);\\n\\t\\t_holderTokens[to].add(tokenId);\\n\\n\\t\\t_tokenOwners.set(tokenId, to);\\n\\n\\t\\temit Transfer(from, to, tokenId);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `tokenId` must exist.\\n\\t */\\n\\tfunction _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n\\t\\trequire(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n\\t\\t_tokenURIs[tokenId] = _tokenURI;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Internal function to set the base URI for all token IDs. It is\\n\\t * automatically added as a prefix to the value returned in {tokenURI},\\n\\t * or to the token ID if {tokenURI} is empty.\\n\\t */\\n\\tfunction _setBaseURI(string memory baseURI_) internal virtual {\\n\\t\\t_baseURI = baseURI_;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n\\t * The call is not executed if the target address is not a contract.\\n\\t *\\n\\t * @param from address representing the previous owner of the given token ID\\n\\t * @param to target address that will receive the tokens\\n\\t * @param tokenId uint256 ID of the token to be transferred\\n\\t * @param _data bytes optional data to send along with the call\\n\\t * @return bool whether the call correctly returned the expected magic value\\n\\t */\\n\\tfunction _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n\\tprivate returns (bool)\\n\\t{\\n\\t\\tif (!to.isContract()) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tbytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n\\t\\t\\t\\tIERC721Receiver(to).onERC721Received.selector,\\n\\t\\t\\t\\t_msgSender(),\\n\\t\\t\\t\\tfrom,\\n\\t\\t\\t\\ttokenId,\\n\\t\\t\\t\\t_data\\n\\t\\t\\t), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n\\t\\tbytes4 retval = abi.decode(returndata, (bytes4));\\n\\t\\treturn (retval == _ERC721_RECEIVED);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Approve `to` to operate on `tokenId`\\n\\t *\\n\\t * Emits an {Approval} event.\\n\\t */\\n\\tfunction _approve(address to, uint256 tokenId) internal virtual {\\n\\t\\t_tokenApprovals[tokenId] = to;\\n\\t\\temit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\\n\\t}\\n\\n\\t/**\\n\\t * @dev Hook that is called before any token transfer. This includes minting\\n\\t * and burning.\\n\\t *\\n\\t * Calling conditions:\\n\\t *\\n\\t * - When `from` and `to` are both non-zero, ``from``\\u0027s `tokenId` will be\\n\\t * transferred to `to`.\\n\\t * - When `from` is zero, `tokenId` will be minted for `to`.\\n\\t * - When `to` is zero, ``from``\\u0027s `tokenId` will be burned.\\n\\t * - `from` cannot be the zero address.\\n\\t * - `to` cannot be the zero address.\\n\\t *\\n\\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n\\t */\\n\\tfunction _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\"},\"NFT.sol\":{\"content\":\"pragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n//SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"./ERC721.sol\\\";\\n\\ncontract Mounts is ERC721, ReentrancyGuard, Ownable {\\n\\tusing SafeMath for uint256;\\n\\n\\tconstructor() ERC721(\\\"Mounts (for Adventurers)\\\", \\\"MOUNT\\\") {}\\n\\taddress public lootAddress = 0xFF9C1b15B16263C61d017ee9F65C50e4AE0113D7;\\n\\tLootInterface lootContract = LootInterface(lootAddress);\\n\\n\\tstring public PROVENANCE = \\\"\\\";\\n\\n\\tuint256 public maxSupply = 8000;\\n\\tuint256 public currentSupply = 0;\\n\\n\\tuint256 public lootersPrice = 10000000000000000; // 0.01 ETH\\n\\tuint256 public publicPrice = 20000000000000000; // 0.02 ETH\\n\\n\\tstring[] private creature = [\\n\\t\\t\\\"Horse\\\", \\\"Horse\\\", \\\"Horse\\\",\\n\\t\\t\\\"Dragon\\\",\\n\\t\\t\\\"Gryffin\\\", \\\"Gryffin\\\",\\n\\t\\t\\\"Camel\\\", \\\"Camel\\\", \\\"Camel\\\",\\n\\t\\t\\\"Poney\\\", \\\"Poney\\\", \\\"Poney\\\",\\n\\t\\t\\\"Elephant\\\", \\\"Elephant\\\",\\n\\t\\t\\\"Hound\\\", \\\"Hound\\\", \\\"Hound\\\",\\n\\t\\t\\\"Shark\\\", \\\"Shark\\\",\\n\\t\\t\\\"Hippogryff\\\", \\\"Hippogryff\\\",\\n\\t\\t\\\"Bull\\\", \\\"Bull\\\", \\\"Bull\\\",\\n\\t\\t\\\"Bear\\\", \\\"Bear\\\", \\\"Bear\\\",\\n\\t\\t\\\"Ostrich\\\", \\\"Ostrich\\\",\\n\\t\\t\\\"Donkey\\\", \\\"Donkey\\\"\\n\\t];\\n\\tstring[] private creaturePrefix = [\\\"Black\\\", \\\"White\\\", \\\"Blue\\\", \\\"Red\\\", \\\"Green\\\", \\\"Silver\\\", \\\"Golden\\\", \\\"Courageous\\\", \\\"Divine\\\", \\\"Holy\\\", \\\"Demonic\\\", \\\"Young\\\", \\\"Ancient\\\", \\\"Docile\\\", \\\"Proud\\\", \\\"Bold\\\", \\\"Quirky\\\", \\\"Brave\\\", \\\"Rash\\\", \\\"Impish\\\", \\\"Quiet\\\", \\\"Lonely\\\", \\\"Ice\\\", \\\"Fire\\\"];\\n\\n\\tstring[] private saddle = [\\\"saddle\\\"];\\n\\tstring[] private saddlePrefix = [\\\"General purpose\\\", \\\"Dressage\\\", \\\"Jumping\\\", \\\"Hunting\\\", \\\"Racing\\\", \\\"Double\\\", \\\"Endurance\\\", \\\"Roping\\\", \\\"Leather\\\"];\\n\\n\\tstring[] private equipment = [\\\"Helmet\\\", \\\"Armor\\\", \\\"Collar\\\", \\\"Harness\\\"];\\n\\tstring[] private equipmentPrefix = [\\\"Ancient\\\", \\\"Golden\\\", \\\"Heavy\\\", \\\"Light\\\", \\\"Dragonskin\\\", \\\"Chain\\\", \\\"Ornate\\\", \\\"Spiky\\\", \\\"Holy\\\", \\\"Silver\\\", \\\"Great\\\", \\\"Bronze\\\", \\\"Iron\\\", \\\"Platinum\\\", \\\"Unholy\\\"];\\n\\n\\tstring[] private inventory = [\\\"pouch\\\", \\\"bag\\\", \\\"satchel\\\", \\\"purse\\\", \\\"saddlebag\\\", \\\"basket\\\", \\\"seat bag\\\", \\\"wedge pack\\\"];\\n\\tstring[] private inventoryPrefix = [\\\"Large\\\", \\\"Small\\\", \\\"Medium\\\", \\\"Bountiful\\\", \\\"Empty\\\"];\\n\\n\\tfunction getCreature(uint256 tokenId) public view returns (string memory) {\\n\\t\\treturn pluck(tokenId, \\\"Creature\\\", creature, creaturePrefix);\\n\\t}\\n\\n\\tfunction getSaddle(uint256 tokenId) public view returns (string memory) {\\n\\t\\treturn pluck(tokenId, \\\"Saddle\\\", saddle, saddlePrefix);\\n\\t}\\n\\n\\tfunction getEquipment(uint256 tokenId) public view returns (string memory) {\\n\\t\\treturn pluck(tokenId, \\\"Equipment\\\", equipment, equipmentPrefix);\\n\\t}\\n\\n\\tfunction getInventory(uint256 tokenId) public view returns (string memory) {\\n\\t\\treturn pluck(tokenId, \\\"Inventory\\\", inventory, inventoryPrefix);\\n\\t}\\n\\n\\tfunction getFullDescription(uint256 tokenId) public view returns (string memory) {\\n\\t\\treturn string(abi.encodePacked(\\n\\t\\t\\tgetCreature(tokenId), \\\" + \\\",\\n\\t\\t\\tgetSaddle(tokenId), \\\" + \\\",\\n\\t\\t\\tgetEquipment(tokenId), \\\" + \\\",\\n\\t\\t\\tgetInventory(tokenId)\\n\\t\\t));\\n\\t}\\n\\n\\tfunction random(string memory input) public pure returns (uint256) {\\n\\t\\treturn uint256(keccak256(abi.encodePacked(input))) % 31;\\n\\t}\\n\\n\\tfunction pluckRoll(uint256 tokenId, string memory keyPrefix) internal pure returns (string memory) {\\n\\t\\tuint256 roll1 = random(string(abi.encodePacked(keyPrefix, toString(tokenId), \\\"1\\\")));\\n\\t\\tuint256 min = roll1;\\n\\t\\tuint256 roll2 = random(string(abi.encodePacked(keyPrefix, toString(tokenId), \\\"2\\\")));\\n\\t\\tmin = min \\u003e roll2 ? roll2 : min;\\n\\t\\tuint256 roll3 = random(string(abi.encodePacked(keyPrefix, toString(tokenId), \\\"3\\\")));\\n\\t\\tmin = min \\u003e roll3 ? roll3 : min;\\n\\t\\tuint256 roll4 = random(string(abi.encodePacked(keyPrefix, toString(tokenId), \\\"4\\\")));\\n\\t\\tmin = min \\u003e roll4 ? roll4 : min;\\n\\n\\t\\t// get 3 highest dice rolls\\n\\t\\tuint256 stat = roll1 * roll2 * roll3 + roll4 + roll3 - min;\\n\\n\\t\\tstring memory output = string(abi.encodePacked(toString(stat)));\\n\\n\\t\\treturn output;\\n\\t}\\n\\n\\tfunction pluck(\\n\\t\\tuint256 tokenId,\\n\\t\\tstring memory keyPrefix,\\n\\t\\tstring[] memory sourceArray,\\n\\t\\tstring[] memory prefixes\\n\\t) internal view returns (string memory) {\\n\\t\\tuint256 randA = random(\\n\\t\\t\\tstring(abi.encodePacked(keyPrefix, toString(tokenId*7)))\\n\\t\\t);\\n\\t\\tuint256 randB = random(\\n\\t\\t\\tstring(abi.encodePacked(keyPrefix, toString(tokenId*4)))\\n\\t\\t);\\n\\n\\t\\tstring memory output = sourceArray[randA % sourceArray.length];\\n\\t\\toutput = string(\\n\\t\\t\\tabi.encodePacked(prefixes[randB % prefixes.length], \\\" \\\", output)\\n\\t\\t);\\n\\n\\t\\tstring memory actual = string(abi.encodePacked(output));\\n\\t\\treturn actual;\\n\\t}\\n\\n\\tfunction withdraw() public onlyOwner {\\n\\t\\tuint balance = address(this).balance;\\n\\t\\tmsg.sender.transfer(balance);\\n\\t}\\n\\n\\tfunction deposit() public payable onlyOwner {}\\n\\n\\n\\tfunction setLootersPrice(uint256 newPrice) public onlyOwner {\\n\\t\\tlootersPrice = newPrice;\\n\\t}\\n\\n\\tfunction setPublicPrice(uint256 newPrice) public onlyOwner {\\n\\t\\tpublicPrice = newPrice;\\n\\t}\\n\\n\\tfunction setBaseURI(string memory baseURI) public onlyOwner {\\n\\t\\t_setBaseURI(baseURI);\\n\\t}\\n\\n\\tfunction setProvenance(string memory prov) public onlyOwner {\\n\\t\\tPROVENANCE = prov;\\n\\t}\\n\\n\\t// Loot owners minting\\n\\tfunction mintWithLoot(uint lootId) public payable nonReentrant {\\n\\t\\trequire(lootContract.ownerOf(lootId) == msg.sender, \\\"This Loot is not owned by the minter\\\");\\n\\t\\trequire(lootersPrice \\u003c= msg.value, \\\"Not enough Ether sent\\\");\\n\\t\\trequire(currentSupply \\u003c maxSupply, \\\"All mounts are minted\\\");\\n\\t\\t_safeMint(msg.sender, currentSupply);\\n\\t\\tcurrentSupply += 1;\\n\\t}\\n\\n\\t// Public minting\\n\\tfunction mint() public payable nonReentrant {\\n\\t\\trequire(publicPrice \\u003c= msg.value, \\\"Not enough Ether sent\\\");\\n\\t\\trequire(currentSupply \\u003c maxSupply, \\\"All mounts are minted\\\");\\n\\n\\t\\t_safeMint(msg.sender, currentSupply);\\n\\t\\tcurrentSupply += 1;\\n\\t}\\n\\n\\tfunction toString(uint256 value) internal pure returns (string memory) {\\n\\t\\tif (value == 0) {\\n\\t\\t\\treturn \\\"0\\\";\\n\\t\\t}\\n\\t\\tuint256 temp = value;\\n\\t\\tuint256 digits;\\n\\t\\twhile (temp != 0) {\\n\\t\\t\\tdigits++;\\n\\t\\t\\ttemp /= 10;\\n\\t\\t}\\n\\t\\tbytes memory buffer = new bytes(digits);\\n\\t\\twhile (value != 0) {\\n\\t\\t\\tdigits -= 1;\\n\\t\\t\\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n\\t\\t\\tvalue /= 10;\\n\\t\\t}\\n\\t\\treturn string(buffer);\\n\\t}\\n\\n\\tfunction tokenURI(uint256 tokenId) override public view returns (string memory) {\\n\\t\\tstring[9] memory parts;\\n\\t\\tparts[0] = \\u0027\\u003csvg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 350 350\\\"\\u003e\\u003cstyle\\u003e.base { fill: white; font-family: serif; font-size: 14px; }\\u003c/style\\u003e\\u003crect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"black\\\" /\\u003e\\u003ctext x=\\\"10\\\" y=\\\"20\\\" class=\\\"base\\\"\\u003e\\u0027;\\n\\n\\t\\tparts[1] = getCreature(tokenId);\\n\\n\\t\\tparts[2] = \\u0027\\u003c/text\\u003e\\u003ctext x=\\\"10\\\" y=\\\"40\\\" class=\\\"base\\\"\\u003e\\u0027;\\n\\n\\t\\tparts[3] = getSaddle(tokenId);\\n\\n\\t\\tparts[4] = \\u0027\\u003c/text\\u003e\\u003ctext x=\\\"10\\\" y=\\\"60\\\" class=\\\"base\\\"\\u003e\\u0027;\\n\\n\\t\\tparts[5] = getEquipment(tokenId);\\n\\n\\t\\tparts[6] = \\u0027\\u003c/text\\u003e\\u003ctext x=\\\"10\\\" y=\\\"80\\\" class=\\\"base\\\"\\u003e\\u0027;\\n\\n\\t\\tparts[7] = getInventory(tokenId);\\n\\n\\t\\tparts[8] = \\u0027\\u003c/text\\u003e\\u003c/svg\\u003e\\u0027;\\n\\n\\t\\tstring memory output = string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3], parts[4], parts[5], parts[6], parts[7], parts[8]));\\n\\t\\t//output = string(abi.encodePacked(output, parts[9], parts[10], parts[11], parts[12], parts[13], parts[14], parts[15], parts[16]));\\n\\n\\t\\tstring memory json = Base64.encode(bytes(string(abi.encodePacked(\\u0027{\\\"name\\\": \\\"Mount #\\u0027, toString(tokenId), \\u0027\\\", \\\"description\\\": \\\"Welcome, weary traveler ! Which mounts will you pick to help you wander from realms to realms ?\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,\\u0027, Base64.encode(bytes(output)), \\u0027\\\"}\\u0027))));\\n\\t\\toutput = string(abi.encodePacked(\\u0027data:application/json;base64,\\u0027, json));\\n\\n\\t\\treturn output;\\n\\t}\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PROVENANCE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCreature\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getEquipment\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getFullDescription\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getInventory\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getSaddle\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lootAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lootersPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lootId\",\"type\":\"uint256\"}],\"name\":\"mintWithLoot\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"input\",\"type\":\"string\"}],\"name\":\"random\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setLootersPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"prov\",\"type\":\"string\"}],\"name\":\"setProvenance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setPublicPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Mounts","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fece8027ee660ad05a7cf5e4a20196c33b8cbd333abfe43bf4569b5d94180fca"}]}