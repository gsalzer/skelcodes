{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: 0BSD\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface ERC20 {\r\n    function transfer(address to, uint tokens) external;\r\n    function transferFrom(address from, address to, uint tokens) external;\r\n}\r\n\r\ncontract TangleV1 {\r\n\r\n    uint8 public decimals;\r\n    uint public totalSupply;\r\n    string public name;\r\n    string public symbol;\r\n    mapping (address => uint256) private balances;\r\n    mapping (address => mapping (address => uint)) private allowed;\r\n\r\n    mapping(uint => uint) public tax;\r\n    address public gamemaster;\r\n    address public liquidityAddress;\r\n    uint public totalPieces;\r\n    uint public piecesPerUnit;\r\n    uint public minHoldAmount;\r\n    mapping(uint => uint) public rewardMax;\r\n    mapping(uint => uint) public rewardConst;\r\n    mapping(uint => uint) public rewardsLastRewardChange;\r\n    mapping(uint => uint) public timeFromInitToLastRewardChange;\r\n    uint public distributionRewardThreshold;\r\n    mapping(address => bool) public hasReceivedPieces;\r\n    mapping(uint => mapping(address => uint)) public rewardableEvents;\r\n    mapping(uint => uint) public totalRewardableEvents;\r\n    mapping(uint => uint) public startTime;\r\n    mapping(uint => mapping(address => uint)) public emissionInit; \r\n    mapping(address => uint) public totalBuyVolume;\r\n    mapping(address => uint) public totalSellVolume;\r\n    address public owner;\r\n\r\n    constructor() {\r\n        name = \"TangleV1\";\r\n        symbol = \"TNGL\";\r\n        decimals = 9;\r\n        totalSupply = 1e9 * 1*10**(decimals);\r\n        totalPieces = type(uint128).max - (type(uint128).max % totalSupply);\r\n        piecesPerUnit = totalPieces / totalSupply;\r\n        balances[msg.sender] = totalPieces;\r\n        gamemaster = msg.sender;\r\n        owner = msg.sender;\r\n        minHoldAmount = 1;\r\n        distributionRewardThreshold = 1e9;\r\n\r\n        // INITIAL REWARDCONST MAP {\r\n            rewardConst[0] = 300000; // Market Maker\r\n            rewardConst[1] = 300000; // Distributor\r\n            rewardConst[2] = 300000; // Staker\r\n        // }\r\n\r\n        // INITIAL TAX MAP {\r\n            tax[100] =  5e9;  // Transfer Multiplier\r\n            tax[101] =  1e11; // Transfer Divisor\r\n            tax[200] =  1e9;  // Market Maker Transfer Multiplier\r\n            tax[201] =  1e11; // Market Maker Transfer Divisor\r\n            tax[210] = 10e9;  // Market Maker Withdraw Multiplier\r\n            tax[211] =  1e11; // Market Maker Withdraw Divisor\r\n            tax[220] =  4e9;  // Market Maker To Distributor Multiplier\r\n            tax[221] =  1e11; // Market Maker To Distributor Divisor\r\n            tax[230] =  4e9;  // Market Maker To Staker Multiplier\r\n            tax[231] =  1e11; // Market Maker To Staker Divisor\r\n            tax[240] =  1e9;  // Market Maker To Reflect Multiplier\r\n            tax[241] =  1e11; // Market Maker To Reflect Divisor\r\n            tax[250] =  1e9;  // Market Maker To Gamemaster Multiplier\r\n            tax[251] =  1e11; // Market Maker To Gamemaster Divisor\r\n            tax[300] =  1e9;  // Distributor Transfer Multiplier\r\n            tax[301] =  1e11; // Distributor Transfer Divisor\r\n            tax[310] = 10e9;  // Distributor Withdraw Multiplier\r\n            tax[311] =  1e11; // Distributor Withdraw Divisor\r\n            tax[320] =  4e9;  // Distributor To Market Maker Multiplier\r\n            tax[321] =  1e11; // Distributor To Market Maker Divisor\r\n            tax[330] =  4e9;  // Distributor To Staker Multiplier\r\n            tax[331] =  1e11; // Distributor To Staker Divisor\r\n            tax[340] =  1e9;  // Distributor To Reflect Multiplier\r\n            tax[341] =  1e11; // Distributor To Reflect Divisor\r\n            tax[350] =  1e9;  // Distributor To Gamemaster Multiplier\r\n            tax[351] =  1e11; // Distributor To Gamemaster Divisor\r\n            tax[400] =  1e9;  // Staker Transfer Multiplier\r\n            tax[401] =  1e11; // Staker Transfer Divisor\r\n            tax[410] = 10e9;  // Staker Withdraw Multiplier\r\n            tax[411] =  1e11; // Staker Withdraw Divisor\r\n            tax[420] =  4e9;  // Staker To Market Maker Multiplier\r\n            tax[421] =  1e11; // Staker To Market Maker Divisor\r\n            tax[430] =  4e9;  // Staker To Distributor Multiplier\r\n            tax[431] =  1e11; // Staker To Distributor Divisor\r\n            tax[440] =  1e9;  // Staker To Reflect Multiplier\r\n            tax[441] =  1e11; // Staker To Reflect Divisor\r\n            tax[450] =  1e9;  // Staker To Gamemaster Multiplier\r\n            tax[451] =  1e11; // Staker To Gamemaster Divisor\r\n            tax[500] =  1e9;  // Reflect Transfer Multiplier\r\n            tax[501] =  1e11; // Reflect Transfer Divisor\r\n            tax[600] =  1e9;  // Gamemaster Transfer Multiplier\r\n            tax[601] =  1e11; // Gamemaster Transfer Divisor\r\n        // }\r\n\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner] / piecesPerUnit;\r\n    }\r\n\r\n    function allowance(address _owner, address spender) public view returns (uint256) {\r\n        return allowed[_owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint value) public returns (bool) {\r\n        value = enforceMinHold(msg.sender, value);\r\n        uint pieceValue = value * piecesPerUnit;\r\n        balances[msg.sender] -= pieceValue;\r\n        balances[to] += pieceValue - taxify(pieceValue, 10);\r\n        balances[address(this)] += taxify(pieceValue, 20) + taxify(pieceValue, 30) + taxify(pieceValue, 40);\r\n        balances[gamemaster] += taxify(pieceValue, 60);\r\n        for (uint i = 0; i < 3; i++) { changeRewardMax(i, rewardMax[i] + taxify(pieceValue, 20 + i * 10)); }\r\n        reflect(taxify(pieceValue, 50));\r\n        distributionCheck(msg.sender, to, value);\r\n        if (msg.sender == liquidityAddress)\r\n            adjustMarketMakerRewardableEvents(to, pieceValue, false);\r\n        if (to == liquidityAddress)\r\n            adjustMarketMakerRewardableEvents(msg.sender, pieceValue, true);\r\n        emit Transfer(msg.sender, to, value - taxify(value, 10));\r\n        emit Tax(taxify(value, 10));\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        value = enforceMinHold(from, value);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender] - value;\r\n        uint pieceValue = value * piecesPerUnit;\r\n        balances[from] -= pieceValue;\r\n        balances[to] += pieceValue - taxify(pieceValue, 10);\r\n        balances[address(this)] += taxify(pieceValue, 20) + taxify(pieceValue, 30) + taxify(pieceValue, 40);\r\n        balances[gamemaster] += taxify(pieceValue, 60);\r\n        for (uint i = 0; i < 3; i++) { changeRewardMax(i, rewardMax[i] + taxify(pieceValue, 20 + i * 10)); }\r\n        reflect(taxify(pieceValue, 50));\r\n        distributionCheck(from, to, value);\r\n        if (from == liquidityAddress)\r\n            adjustMarketMakerRewardableEvents(to, pieceValue, false);\r\n        if (to == liquidityAddress)\r\n            adjustMarketMakerRewardableEvents(from, pieceValue, true);\r\n        emit Transfer(from, to, value - taxify(value, 10));\r\n        emit Tax(taxify(value, 10));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        allowed[msg.sender][spender] = allowed[msg.sender][spender] + addedValue;\r\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        allowed[msg.sender][spender] = allowed[msg.sender][spender] - subtractedValue;\r\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function taxify(uint value, uint id) internal view returns (uint) {\r\n        return value * tax[id * 10] / tax[id * 10 + 1];\r\n    }\r\n    \r\n    function reflect(uint reflectAmount) internal {\r\n        uint FTPXA = totalSupply * piecesPerUnit - balances[liquidityAddress];\r\n        uint FFTPXARA = FTPXA - reflectAmount;\r\n        piecesPerUnit = piecesPerUnit * FFTPXARA / FTPXA;\r\n        if (piecesPerUnit < 1) \r\n            piecesPerUnit = 1;\r\n        balances[liquidityAddress] = balances[liquidityAddress] * FFTPXARA / FTPXA;\r\n    }\r\n    \r\n    function enforceMinHold(address sender, uint value) internal view returns (uint) {\r\n        if (balances[sender] / piecesPerUnit - value < minHoldAmount && sender != liquidityAddress)\r\n            value = balances[sender] / piecesPerUnit - minHoldAmount;\r\n        return value;\r\n    }\r\n    \r\n    function rewardTheoretical(uint id) public view returns (uint) {\r\n        if (startTime[id] == 0) return 0;\r\n        return rewardMax[id] - (rewardMax[id] - rewardsLastRewardChange[id]) * rewardConst[id] / (block.timestamp - startTime[id] + rewardConst[id] - timeFromInitToLastRewardChange[id]);\r\n    }\r\n    \r\n    function changeRewardMax(uint id, uint newRewardMax) internal {\r\n        if (startTime[id] > 0) {\r\n            rewardsLastRewardChange[id] = rewardTheoretical(id);\r\n            timeFromInitToLastRewardChange[id] = block.timestamp - startTime[id];\r\n        }\r\n        rewardMax[id] = newRewardMax;\r\n    }\r\n    \r\n    function distributionCheck(address sender, address receiver, uint value) internal {\r\n        if (hasReceivedPieces[receiver] == false && value >= distributionRewardThreshold && sender != liquidityAddress && receiver != liquidityAddress) {\r\n            if (startTime[1] == 0)\r\n                startTime[1] = block.timestamp;\r\n            if (getAvailableRewards(1, msg.sender) > 0) withdrawRewards(1);\r\n            emissionInit[1][msg.sender] = rewardTheoretical(1);\r\n            rewardableEvents[1][sender] += 1;\r\n            totalRewardableEvents[1] += 1;\r\n            hasReceivedPieces[receiver] = true;\r\n        }\r\n    }\r\n    \r\n    function withdrawRewards(uint id) public {\r\n        uint availableRewards = rewardableEvents[id][msg.sender] * (rewardTheoretical(id) - emissionInit[id][msg.sender]) / totalRewardableEvents[id];\r\n        emissionInit[id][msg.sender] = rewardTheoretical(id);\r\n        uint id2 = (id + 2) * 10;\r\n        balances[msg.sender] += availableRewards - taxify(availableRewards, id2 + 1);\r\n        balances[gamemaster] += taxify(availableRewards, id2 + 5);\r\n        balances[address(this)] -= availableRewards - taxify(availableRewards, id2 + 2) - taxify(availableRewards, id2 + 3);\r\n        for (uint i = 0; i < 2; i++) { changeRewardMax(id != i * 2 ? i * 2 : 1, rewardMax[id] + taxify(availableRewards, id2 + 2 + i)); }\r\n        reflect(taxify(availableRewards, id2 + 4));\r\n    }\r\n    \r\n    function withdrawAllRewards() public {\r\n        if (getAvailableRewards(0, msg.sender) > 0) withdrawRewards(0);\r\n        if (getAvailableRewards(1, msg.sender) > 0) withdrawRewards(1);\r\n        if (getAvailableRewards(2, msg.sender) > 0) withdrawRewards(2);\r\n        return;\r\n    }\r\n    \r\n    function getAvailableRewards(uint id, address _address) public view returns (uint) {\r\n        if (totalRewardableEvents[id] == 0 || rewardableEvents[id][_address] == 0) return 0;\r\n        uint availableRewards = rewardableEvents[id][_address] * (rewardTheoretical(id) - emissionInit[id][_address]) / totalRewardableEvents[id];\r\n        return (availableRewards - taxify(availableRewards, (id + 2) * 10 + 1)) / piecesPerUnit;\r\n    }\r\n    \r\n    function getAllAvailableRewards(address _address) public view returns(uint, uint, uint, uint) {\r\n        return (getAvailableRewards(0, _address), getAvailableRewards(1, _address), getAvailableRewards(2, _address), getAvailableRewards(0, _address) + getAvailableRewards(1, _address) + getAvailableRewards(2, _address));\r\n    }\r\n    \r\n    function stake(uint amount) public {\r\n        require(rewardableEvents[2][msg.sender] == 0, \"staking position already exists\");\r\n        ERC20(liquidityAddress).transferFrom(msg.sender, address(this), amount);\r\n        if (startTime[2] == 0)\r\n            startTime[2] = block.timestamp;\r\n        emissionInit[2][msg.sender] = rewardTheoretical(2);\r\n        totalRewardableEvents[2] += amount;\r\n        rewardableEvents[2][msg.sender] = amount;\r\n    }\r\n    \r\n    function unstake() public {\r\n        require(rewardableEvents[2][msg.sender] > 0, \"no current staking position\");\r\n        if (getAvailableRewards(2, msg.sender) > 0) withdrawRewards(2);\r\n        ERC20(liquidityAddress).transfer(msg.sender, rewardableEvents[2][msg.sender]);\r\n        totalRewardableEvents[2] -= rewardableEvents[2][msg.sender];\r\n        rewardableEvents[2][msg.sender] = 0;\r\n    }\r\n    \r\n    function updatePosition(uint amount) public {\r\n        unstake();\r\n        stake(amount);\r\n    }\r\n    \r\n    function adjustMarketMakerRewardableEvents(address _address, uint adjustmentAmount, bool buyOrSell) internal {\r\n        if (!buyOrSell)\r\n            totalBuyVolume[_address] += adjustmentAmount;\r\n        if (buyOrSell)\r\n            totalSellVolume[_address] += adjustmentAmount;\r\n        uint totalBuySellVolumeDiff;\r\n        if (totalSellVolume[_address] > totalBuyVolume[_address]) {\r\n            totalBuySellVolumeDiff = totalSellVolume[_address] - totalBuyVolume[_address];\r\n        }\r\n        if (totalBuyVolume[_address] > totalSellVolume[_address]) {\r\n            totalBuySellVolumeDiff = totalBuyVolume[_address] - totalSellVolume[_address];\r\n        }\r\n        uint balancedBuySellVolume = totalBuyVolume[_address] + totalSellVolume[_address] - totalBuySellVolumeDiff;\r\n        if (balancedBuySellVolume > rewardableEvents[0][_address]) {\r\n            uint eventDiff = balancedBuySellVolume - rewardableEvents[0][_address];\r\n            if (startTime[0] == 0)\r\n                startTime[0] = block.timestamp;\r\n            if (getAvailableRewards(0, msg.sender) > 0) withdrawRewards(0);\r\n            emissionInit[0][msg.sender] = rewardTheoretical(0);\r\n            rewardableEvents[0][_address] += eventDiff;\r\n            totalRewardableEvents[0] += eventDiff;\r\n        } else if (rewardableEvents[0][_address] > balancedBuySellVolume) {\r\n            uint eventDiff = rewardableEvents[0][_address] - balancedBuySellVolume;\r\n            if (getAvailableRewards(0, msg.sender) > 0) withdrawRewards(0);\r\n            emissionInit[0][msg.sender] = rewardTheoretical(0);\r\n            rewardableEvents[0][_address] -= eventDiff;\r\n            totalRewardableEvents[0] -= eventDiff;\r\n        }\r\n    }\r\n    \r\n    function changeMinHoldAmount(uint newMinHoldAmount) public {\r\n        require(msg.sender == owner, \"not owner\");\r\n        minHoldAmount = newMinHoldAmount;\r\n    }\r\n    \r\n    function changeTaxDetail(uint id, uint value) public {\r\n        require(msg.sender == owner, \"not owner\");\r\n        tax[id] = value;\r\n    }\r\n    \r\n    function changeRewardConstant(uint newRewardConstant, uint id) public {\r\n        require(msg.sender == owner, \"not owner\");\r\n        rewardConst[id] = newRewardConstant;\r\n    }\r\n    \r\n    function changeLiquidityAddress(address newLiquidityAddress) public {\r\n        require(msg.sender == owner, \"not owner\");\r\n        liquidityAddress = newLiquidityAddress;\r\n        for (uint i = 0; i < 3; i++) { rewardableEvents[i][liquidityAddress] = 0; }\r\n    }\r\n    \r\n    function changeOwner(address newOwner) public {\r\n        require(msg.sender == owner, \"not owner\");\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function donate(uint id, uint value) public {\r\n        uint pieceValue = value * piecesPerUnit;\r\n        balances[msg.sender] -= pieceValue;\r\n        balances[address(this)] += pieceValue;\r\n        changeRewardMax(id, rewardMax[id] + pieceValue);\r\n    }\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Tax(uint tokens);\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Tax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLiquidityAddress\",\"type\":\"address\"}],\"name\":\"changeLiquidityAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinHoldAmount\",\"type\":\"uint256\"}],\"name\":\"changeMinHoldAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRewardConstant\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"changeRewardConstant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"changeTaxDetail\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionRewardThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"emissionInit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gamemaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAllAvailableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAvailableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasReceivedPieces\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minHoldAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"piecesPerUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardConst\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"rewardTheoretical\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardableEvents\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardsLastRewardChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timeFromInitToLastRewardChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBuyVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPieces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalRewardableEvents\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalSellVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updatePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"withdrawRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TangleV1","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"99999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f2b2641ca3a2cfb4ac62365fcea06ba274634225c5f3113b7eaff495f6f69e4e"}]}