{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/implementation/Lockable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\\n */\\ncontract Lockable {\\n    bool private _notEntered;\\n\\n    constructor() {\\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\\n        // refund coming into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\\n     * function that does the actual state modification.\\n     */\\n    modifier nonReentrant() {\\n        _preEntranceCheck();\\n        _preEntranceSet();\\n        _;\\n        _postEntranceReset();\\n    }\\n\\n    /**\\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\\n     */\\n    modifier nonReentrantView() {\\n        _preEntranceCheck();\\n        _;\\n    }\\n\\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\\n    // then call `_postEntranceReset()`.\\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\\n    function _preEntranceCheck() internal view {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n\\n    function _preEntranceSet() internal {\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n    }\\n\\n    function _postEntranceReset() internal {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/implementation/MultiCaller.sol\": {\r\n      \"content\": \"// This contract is taken from Uniswaps's multi call implementation (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol)\\n// and was modified to be solidity 0.8 compatible. Additionally, the method was restricted to only work with msg.value\\n// set to 0 to avoid any nasty attack vectors on function calls that use value sent with deposits.\\npragma solidity ^0.8.0;\\n\\n/// @title MultiCaller\\n/// @notice Enables calling multiple methods in a single call to the contract\\ncontract MultiCaller {\\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results) {\\n        require(msg.value == 0, \\\"Only multicall with 0 value\\\");\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n\\n            if (!success) {\\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\n                if (result.length < 68) revert();\\n                assembly {\\n                    result := add(result, 0x04)\\n                }\\n                revert(abi.decode(result, (string)));\\n            }\\n\\n            results[i] = result;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain-oracle/GovernorHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"../common/implementation/Lockable.sol\\\";\\nimport \\\"../common/implementation/MultiCaller.sol\\\";\\nimport \\\"./interfaces/ParentMessengerInterface.sol\\\";\\nimport \\\"./GovernorSpoke.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Cross-chain Oracle L1 Governor Hub.\\n * @notice Governance relayer contract to be deployed on Ethereum that receives messages from the owner (Governor) and\\n * sends them to spoke contracts on child chains.\\n */\\n\\ncontract GovernorHub is Ownable, Lockable, MultiCaller {\\n    // Associates chain ID with ParentMessenger contract to use to send governance actions to that chain's GovernorSpoke\\n    // contract.\\n    mapping(uint256 => ParentMessengerInterface) public messengers;\\n\\n    event RelayedGovernanceRequest(\\n        uint256 indexed chainId,\\n        address indexed messenger,\\n        GovernorSpoke.Call[] calls,\\n        bytes dataSentToChild\\n    );\\n    event SetParentMessenger(uint256 indexed chainId, address indexed parentMessenger);\\n\\n    /**\\n     * @notice Set new ParentMessenger contract for chainId.\\n     * @param chainId child network that messenger contract will communicate with.\\n     * @param messenger ParentMessenger contract that sends messages to ChildMessenger on network with ID `chainId`.\\n     * @dev Only callable by the owner (presumably the Ethereum Governor contract).\\n     */\\n    function setMessenger(uint256 chainId, ParentMessengerInterface messenger) public nonReentrant() onlyOwner {\\n        messengers[chainId] = messenger;\\n        emit SetParentMessenger(chainId, address(messenger));\\n    }\\n\\n    /**\\n     * @notice This should be called in order to relay a governance request to the `GovernorSpoke` contract deployed to\\n     * the child chain associated with `chainId`.\\n     * @param chainId network that messenger contract will communicate with\\n     * @param calls the calls to be made by the GovernorSpoke. Should encode a `to` and `data` prop for each call.\\n     * @dev Only callable by the owner (presumably the UMA DVM Governor contract, on L1 Ethereum).\\n     */\\n    function relayGovernance(uint256 chainId, GovernorSpoke.Call[] memory calls) external nonReentrant() onlyOwner {\\n        bytes memory dataSentToChild = abi.encode(calls);\\n        messengers[chainId].sendMessageToChild(dataSentToChild);\\n        emit RelayedGovernanceRequest(chainId, address(messengers[chainId]), calls, dataSentToChild);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain-oracle/GovernorSpoke.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/ChildMessengerConsumerInterface.sol\\\";\\nimport \\\"../common/implementation/Lockable.sol\\\";\\nimport \\\"./SpokeBase.sol\\\";\\n\\n/**\\n * @title Cross-chain Oracle L2 Governor Spoke.\\n * @notice Governor contract deployed on L2 that receives governance actions from Ethereum.\\n */\\ncontract GovernorSpoke is Lockable, SpokeBase, ChildMessengerConsumerInterface {\\n    struct Call {\\n        address to;\\n        bytes data;\\n    }\\n\\n    constructor(address _finderAddress) SpokeBase(_finderAddress) {}\\n\\n    event ExecutedGovernanceTransaction(address indexed to, bytes data);\\n\\n    /**\\n     * @notice Executes governance transaction created on Ethereum.\\n     * @dev Can only be called by ChildMessenger contract that wants to execute governance action on this child chain\\n     * that originated from DVM voters on root chain. ChildMessenger should only receive communication from\\n     * ParentMessenger on mainnet. See the SpokeBase for the onlyMessenger modifier.\\n\\n     * @param data Contains the target address and the encoded function selector + ABI encoded params to include in\\n     * delegated transaction.\\n     */\\n    function processMessageFromParent(bytes memory data) public override nonReentrant() onlyMessenger() {\\n        Call[] memory calls = abi.decode(data, (Call[]));\\n\\n        for (uint256 i = 0; i < calls.length; i++) {\\n            (address to, bytes memory inputData) = (calls[i].to, calls[i].data);\\n            require(_executeCall(to, inputData), \\\"execute call failed\\\");\\n            emit ExecutedGovernanceTransaction(to, inputData);\\n        }\\n    }\\n\\n    // Note: this snippet of code is copied from Governor.sol.\\n    function _executeCall(address to, bytes memory data) private returns (bool) {\\n        // Note: this snippet of code is copied from Governor.sol and modified to not include any \\\"value\\\" field.\\n        // solhint-disable-next-line no-inline-assembly\\n\\n        bool success;\\n        assembly {\\n            let inputData := add(data, 0x20)\\n            let inputDataSize := mload(data)\\n            // Hardcode value to be 0 for relayed governance calls in order to avoid addressing complexity of bridging\\n            // value cross-chain.\\n            success := call(gas(), to, 0, inputData, inputDataSize, 0, 0)\\n        }\\n        return success;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain-oracle/SpokeBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"../oracle/interfaces/FinderInterface.sol\\\";\\n\\nimport \\\"./interfaces/ChildMessengerInterface.sol\\\";\\n\\nimport \\\"../oracle/implementation/Constants.sol\\\";\\n\\n/**\\n * @title Cross-chain Oracle L2 Spoke Base.\\n * @notice Provides access control to Governance and Oracle spoke L2 contracts.\\n */\\n\\ncontract SpokeBase {\\n    FinderInterface private finder;\\n\\n    constructor(address _finderAddress) {\\n        finder = FinderInterface(_finderAddress);\\n    }\\n\\n    modifier onlyMessenger() {\\n        require(msg.sender == address(getChildMessenger()), \\\"Caller must be messenger\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns the child messenger address set in the finder.\\n     * @return ChildMessengerInterface instance of child messenger deployed on L2.\\n     */\\n    function getChildMessenger() public view returns (ChildMessengerInterface) {\\n        return ChildMessengerInterface(finder.getImplementationAddress(OracleInterfaces.ChildMessenger));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain-oracle/interfaces/ChildMessengerConsumerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\ninterface ChildMessengerConsumerInterface {\\n    // Called on L2 by child messenger.\\n    function processMessageFromParent(bytes memory data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain-oracle/interfaces/ChildMessengerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\ninterface ChildMessengerInterface {\\n    // Should send cross-chain message to Parent messenger contract or revert.\\n    function sendMessageToParent(bytes memory data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain-oracle/interfaces/ParentMessengerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\ninterface ParentMessengerInterface {\\n    // Should send cross-chain message to Child messenger contract or revert.\\n    function sendMessageToChild(bytes memory data) external;\\n\\n    // Informs Hub how much msg.value they need to include to call `sendMessageToChild`.\\n    function getL1CallValue() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/implementation/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Stores common interface names used throughout the DVM by registration in the Finder.\\n */\\nlibrary OracleInterfaces {\\n    bytes32 public constant Oracle = \\\"Oracle\\\";\\n    bytes32 public constant IdentifierWhitelist = \\\"IdentifierWhitelist\\\";\\n    bytes32 public constant Store = \\\"Store\\\";\\n    bytes32 public constant FinancialContractsAdmin = \\\"FinancialContractsAdmin\\\";\\n    bytes32 public constant Registry = \\\"Registry\\\";\\n    bytes32 public constant CollateralWhitelist = \\\"CollateralWhitelist\\\";\\n    bytes32 public constant OptimisticOracle = \\\"OptimisticOracle\\\";\\n    bytes32 public constant Bridge = \\\"Bridge\\\";\\n    bytes32 public constant GenericHandler = \\\"GenericHandler\\\";\\n    bytes32 public constant SkinnyOptimisticOracle = \\\"SkinnyOptimisticOracle\\\";\\n    bytes32 public constant ChildMessenger = \\\"ChildMessenger\\\";\\n    bytes32 public constant OracleHub = \\\"OracleHub\\\";\\n    bytes32 public constant OracleSpoke = \\\"OracleSpoke\\\";\\n}\\n\\n/**\\n * @title Commonly re-used values for contracts associated with the OptimisticOracle.\\n */\\nlibrary OptimisticOracleConstraints {\\n    // Any price request submitted to the OptimisticOracle must contain ancillary data no larger than this value.\\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` constant value otherwise it is possible\\n    // that a price can be requested to the OptimisticOracle successfully, but cannot be resolved by the DVM which\\n    // refuses to accept a price request made with ancillary data length over a certain size.\\n    uint256 public constant ancillaryBytesLimit = 8192;\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/FinderInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Provides addresses of the live contracts implementing certain interfaces.\\n * @dev Examples are the Oracle or Store interfaces.\\n */\\ninterface FinderInterface {\\n    /**\\n     * @notice Updates the address of the contract that implements `interfaceName`.\\n     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\\n     * @param implementationAddress address of the deployed contract that implements the interface.\\n     */\\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\\n\\n    /**\\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\\n     * @param interfaceName queried interface.\\n     * @return implementationAddress address of the deployed contract that implements the interface.\\n     */\\n    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"messenger\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct GovernorSpoke.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"dataSentToChild\",\"type\":\"bytes\"}],\"name\":\"RelayedGovernanceRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"parentMessenger\",\"type\":\"address\"}],\"name\":\"SetParentMessenger\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"messengers\",\"outputs\":[{\"internalType\":\"contract ParentMessengerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct GovernorSpoke.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"relayGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"contract ParentMessengerInterface\",\"name\":\"messenger\",\"type\":\"address\"}],\"name\":\"setMessenger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GovernorHub","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}