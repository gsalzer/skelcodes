{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SwitchTicketFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/ISwitchTicketFactory.sol';\\nimport './interfaces/ISwitchTreasury.sol';\\nimport './libraries/TransferHelper.sol';\\nimport './modules/UserTokenLimit.sol';\\nimport './modules/ReentrancyGuard.sol';\\nimport './modules/Pausable.sol';\\nimport './modules/Initializable.sol';\\nimport './SwitchTicket.sol';\\n\\ncontract SwitchTicketFactory is UserTokenLimit, Pausable, ReentrancyGuard, Initializable {\\n    address public weth;\\n    address public treasury;\\n    address public oldTicketFactory;\\n    string public prefixSymbol;\\n    string public prefixName;\\n    address[] public tickets;\\n    address[] public tokens;\\n    mapping(address => address) public tokenMap;\\n    mapping(address => bool) public tokenStatus;\\n    mapping(address => bool) public tokenExistence;\\n    mapping(address => bool) public ticketExistence;\\n    bool public enableTokenList;\\n\\n    struct TokenMapData {\\n        address token;\\n        address ticket;\\n    }\\n\\n    event TokenStatusChanged(address indexed token, bool enabled);\\n    event TicketCreated(address indexed token, address indexed ticket, string symbol, string name);\\n    event Deposited(address indexed _token, address indexed _ticket, address from, address to, uint value);\\n    event Withdrawed(address indexed _token, address indexed _ticket, address from, address to, uint _value);\\n    event TreasuryChanged(address indexed user, address indexed _old, address indexed _new);\\n    event PrefixChanged(address indexed user, string _prefixSymbol, string _prefixName);\\n    event OldTicketFactoryChanged(address indexed user, address indexed _old, address indexed _new);\\n    event EnableTokenListChanged(address indexed user, bool indexed _old, bool indexed _new);\\n\\n    receive() external payable {\\n    }\\n\\n    function initialize(address _weth) external initializer {\\n        require(_weth != address(0), 'SwitchTicketFactory: ZERO_ADDRESS');\\n        owner = msg.sender;\\n        weth = _weth;\\n    }\\n\\n    function pause() external onlyManager whenNotPaused {\\n        _pause();\\n    }\\n\\n    function unpause() external onlyManager whenPaused {\\n        _unpause();\\n    }\\n\\n    function countTicket() public view returns (uint) {\\n        return tickets.length;\\n    }\\n\\n    function countToken() public view returns (uint) {\\n        return tokens.length;\\n    }\\n\\n    function configure(address _treasury, bool _value, string calldata _prefixSymbol, string calldata _prefixName) external onlyDev {\\n        require(_treasury != address(0), 'SwitchTicketFactory: ZERO_ADDRESS');\\n        emit TreasuryChanged(msg.sender, treasury, _treasury);\\n        emit PrefixChanged(msg.sender, _prefixSymbol, _prefixName);\\n        treasury = _treasury;\\n        enableTokenList = _value;\\n        prefixSymbol = _prefixSymbol;\\n        prefixName = _prefixName;\\n    }\\n\\n    function setTreasury(address _treasury) external onlyDev {\\n        require(_treasury != address(0), 'SwitchTicketFactory: ZERO_ADDRESS');\\n        emit TreasuryChanged(msg.sender, treasury, _treasury);\\n        treasury = _treasury;\\n    }\\n\\n    function setPrefix(string calldata _prefixSymbol, string calldata _prefixName) external onlyDev {\\n        emit PrefixChanged(msg.sender, _prefixSymbol, _prefixName);\\n        prefixSymbol = _prefixSymbol;\\n        prefixName = _prefixName;\\n    }\\n\\n    function setOldTicketFactory(address _oldTicketFactory) external onlyDev {\\n        require(oldTicketFactory != _oldTicketFactory && _oldTicketFactory != address(this), 'SwitchTicketFactory: INVALID_PARAM');\\n        emit OldTicketFactoryChanged(msg.sender, oldTicketFactory, _oldTicketFactory);\\n        oldTicketFactory = _oldTicketFactory;\\n    }\\n\\n    function getTokenMap(address _token) public view returns (address) {\\n        if (_token == address(0)) {\\n            _token = weth;\\n        }\\n        address res = tokenMap[_token];\\n        if(res == address(0) && oldTicketFactory != address(0)) {\\n            res = ISwitchTicketFactory(oldTicketFactory).getTokenMap(_token);\\n        }\\n        return res;\\n    }\\n\\n    function isTicket(address _ticket) public view returns (bool) {\\n        bool res = ticketExistence[_ticket];\\n        if(res == false && oldTicketFactory != address(0)) {\\n            res = ISwitchTicketFactory(oldTicketFactory).isTicket(_ticket);\\n        }\\n        return res;\\n    }\\n\\n    function enableToken(bool _value) external onlyDev {\\n        emit EnableTokenListChanged(msg.sender, enableTokenList, _value);\\n        enableTokenList = _value;\\n    }\\n\\n    function setToken(address _token, bool _value) public onlyDev {\\n        if(tokenExistence[_token] == false) {\\n            tokens.push(_token);\\n            tokenExistence[_token] = true;\\n        }\\n        tokenStatus[_token] = _value;\\n        emit TokenStatusChanged(_token, _value);\\n    }\\n\\n    function setTokens(address[] memory _tokens, bool[] memory _values) external onlyDev {\\n        require(_tokens.length == _values.length, 'SwitchTicketFactory: INVALID_PARAM');\\n        for (uint i; i < _tokens.length; i++) {\\n            setToken(_tokens[i], _values[i]);\\n        }\\n    }\\n\\n    function canCreateTicket(address _token) public view returns (bool) {\\n        if(_token == address(0)) {\\n            _token = weth;\\n        }\\n        if(enableTokenList) {\\n            if(tokenMap[_token] == address(0) && tokenStatus[_token]) {\\n                return true;\\n            }\\n        } else {\\n            if(tokenMap[_token] == address(0)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function createTicket(address _token) public returns (address ticket) {\\n        if(_token == address(0)) {\\n            _token = weth;\\n        }\\n        if(enableTokenList) {\\n            require(tokenStatus[_token], \\\"SwitchTicketFactory: TOKEN_FORBIDDEN\\\");\\n        }\\n        require(tokenMap[_token] == address(0), 'SwitchTicketFactory: EXISTS');\\n        {\\n            // check is compatible or not\\n            IERC20(_token).decimals();\\n            IERC20(_token).totalSupply();\\n            IERC20(_token).name();\\n            IERC20(_token).symbol();\\n        }\\n\\n        bytes memory bytecode = type(SwitchTicket).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(_token));\\n        \\n        assembly {\\n            ticket := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n\\n        string memory _symbol = stringConcat(prefixSymbol, IERC20(_token).symbol());\\n        string memory _name = stringConcat(prefixName, IERC20(_token).name());\\n        SwitchTicket(ticket).initialize(treasury, _token, _symbol, _name);\\n        tokenMap[_token] = ticket;\\n        tokenMap[ticket] = _token;\\n        ticketExistence[ticket] = true;\\n        tickets.push(ticket);\\n        emit TicketCreated(_token, ticket, _symbol, _name);\\n        return ticket;\\n    }\\n\\n    function deposit(address _token, uint _value, address _to) external payable nonReentrant whenNotPaused returns (address) {\\n        require(_value > 0, 'SwitchTicketFactory: ZERO');\\n        if(canCreateTicket(_token)) {\\n            createTicket(_token);\\n        }\\n        bool isETH;\\n        if(_token == address(0)) {\\n            isETH = true;\\n            _token = weth;\\n        }\\n        address ticket = tokenMap[_token];\\n        require(ticket != address(0), 'SwitchTicketFactory: TICKET_NONEXISTS');\\n        \\n        uint depositAmount;\\n        if (isETH) {\\n            _value = msg.value;\\n            depositAmount = ISwitchTreasury(treasury).deposit{value: msg.value}(msg.sender, address(0), _value);\\n        } else {\\n            depositAmount = ISwitchTreasury(treasury).deposit(msg.sender, _token, _value);\\n        }\\n        require(depositAmount == _value, \\\"SwitchTicketFactory: TREASURY_DEPOSIT_FAIL\\\");\\n  \\n        ISwitchTreasury(treasury).mint(ticket, _to, _value);\\n        emit Deposited(_token, ticket, msg.sender, _to, _value);\\n        return ticket;\\n    }\\n\\n    function queryWithdrawInfo(address _user, address _ticket) public view returns (uint balance, uint amount) {\\n        address _token = tokenMap[_ticket];\\n        balance = IERC20(_ticket).balanceOf(_user);\\n        amount = ISwitchTreasury(treasury).queryWithdraw(address(this), _token);\\n        if(amount < balance) {\\n            amount = balance;\\n        }\\n        amount = getUserLimit(_user, _token, amount);\\n        return (balance, amount);\\n    }\\n\\n    function queryWithdraw(address _user, address _ticket) public view returns (uint) {\\n        (uint balance, uint amount) = queryWithdrawInfo(_user, _ticket);\\n        if(amount < balance) {\\n            balance = amount;\\n        }\\n        return balance;\\n    }\\n\\n    function withdrawAdv(bool isETH, address _to, address _ticket, uint _value) public nonReentrant whenNotPaused returns (bool) {\\n        require(_value > 0, 'SwitchTicketFactory: ZERO');\\n        address _token = tokenMap[_ticket];\\n        require(_token != address(0), 'SwitchTicketFactory: NOTFOUND_TICKET');\\n        require(queryWithdraw(msg.sender, _ticket) >= _value, 'SwitchTicketFactory: INSUFFICIENT_BALANCE');\\n\\n        _updateUserTokenLimit(_token, _value);\\n        emit Withdrawed(_token, _ticket, msg.sender, _to, _value);\\n        \\n        ISwitchTreasury(treasury).burn(_ticket, msg.sender, _value);\\n        ISwitchTreasury(treasury).withdraw(isETH, _to, _token, _value);\\n        return true;\\n    }\\n\\n    function withdraw(address _to, address _ticket, uint _value) external whenNotPaused returns (bool) {\\n        address _token = tokenMap[_ticket];\\n        bool isETH;\\n        if(_token == weth) {\\n            isETH = true;\\n        }\\n        return withdrawAdv(isETH, _to, _ticket, _value);\\n    }\\n\\n    function getTokenMapData(address _ticket) public view returns (TokenMapData memory){\\n        return TokenMapData({\\n            token: tokenMap[_ticket],\\n            ticket: _ticket\\n        });\\n    }\\n\\n    function iterateTokenMapData(uint _start, uint _end) external view returns (TokenMapData[] memory result){\\n        require(_start <= _end && _start >= 0 && _end >= 0, \\\"SwitchTicketFactory: INVAID_PARAMTERS\\\");\\n        uint count = countTicket();\\n        if (_end > count) _end = count;\\n        count = _end - _start;\\n        result = new TokenMapData[](count);\\n        if (count == 0) return result;\\n        uint index = 0;\\n        for(uint i = _start;i < _end;i++) {\\n            address _ticket = tickets[i];\\n            result[index] = getTokenMapData(_ticket);\\n            index++;\\n        }\\n        return result;\\n    }\\n\\n    function stringConcat(string memory _a, string memory _b) public returns (string memory){\\n        bytes memory _ba = bytes(_a);\\n        bytes memory _bb = bytes(_b);\\n        string memory ret = new string(_ba.length + _bb.length);\\n        bytes memory bret = bytes(ret);\\n        uint k = 0;\\n        for (uint i = 0; i < _ba.length; i++) bret[k++] = _ba[i];\\n        for (uint i = 0; i < _bb.length; i++) bret[k++] = _bb[i];\\n        return string(ret);\\n   }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwitchTicketFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\ninterface ISwitchTicketFactory {\\n    function treasury() external view returns (address);\\n    function getTokenMap(address _token) external view returns (address);\\n    function isTicket(address _ticket) external view returns (bool);\\n    function deposit(address _token, uint _value, address _to) external payable returns (address);\\n    function queryWithdrawInfo(address _user, address _ticket) external view returns (uint balance, uint amount);\\n    function queryWithdraw(address _user, address _ticket) external view returns (uint);\\n    function withdraw(bool isETH, address _to, address _ticket, uint _value) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISwitchTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\ninterface ISwitchTreasury {\\n    function tokenBalanceOf(address _token) external returns (uint);\\n    function mint(address _token, address _to, uint _value) external returns (uint);\\n    function burn(address _token, address _from, uint _value) external returns (uint);\\n    function deposit(address _from, address _token, uint _value) external payable returns (uint);\\n    function queryWithdraw(address _user, address _token) external view returns (uint);\\n    function withdraw(bool _isETH, address _to, address _token, uint _value) external returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/UserTokenLimit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.6;\\n\\nimport '../libraries/SafeMath.sol';\\nimport '../modules/Configable.sol';\\n\\ncontract UserTokenLimit is Configable {\\n    using SafeMath for uint;\\n\\n    struct TokenLimit {\\n        bool enabled;\\n        uint blocks;\\n        uint amount;\\n    }\\n    //key:(token)\\n    mapping(address => TokenLimit) public tokenLimits;\\n\\n    struct UserLimit {\\n        uint lastBlock;\\n        uint consumption;\\n    }\\n    //key:(white user, token)\\n    mapping(address => mapping(address => UserLimit)) public userLimits;\\n\\n    function setTokenLimit(address _token, bool _enabled, uint _blocks, uint _amount) public onlyManager {\\n        TokenLimit storage limit = tokenLimits[_token];\\n        limit.enabled = _enabled;\\n        limit.blocks = _blocks;\\n        limit.amount = _amount;\\n    }\\n\\n    function setTokenLimits(address[] memory _token, bool[] memory _enabled, uint[] memory _blocks, uint[] memory _amount) external onlyManager {\\n        require(\\n            _token.length == _enabled.length \\n            && _enabled.length == _blocks.length \\n            && _blocks.length == _amount.length \\n            , \\\"UserTokenLimit: INVALID_PARAM\\\"\\n        );\\n        for (uint i; i < _token.length; i++) {\\n            setTokenLimit(_token[i], _enabled[i], _blocks[i], _amount[i]);\\n        }\\n    }\\n\\n    function setTokenLimitEnable(address _token, bool _enabled) public onlyManager {\\n        TokenLimit storage limit = tokenLimits[_token];\\n        limit.enabled = _enabled;\\n    }\\n\\n    function setTokenLimitEnables(address[] memory _token, bool[] memory _enabled) external onlyManager {\\n        require(\\n            _token.length == _enabled.length \\n            , \\\"UserTokenLimit: INVALID_PARAM\\\"\\n        );\\n        for (uint i; i < _token.length; i++) {\\n            setTokenLimitEnable(_token[i], _enabled[i]);\\n        }\\n    }\\n\\n    function getUserLimit(address _user, address _token, uint _value) public view returns (uint) {\\n        TokenLimit memory tokenLimit = tokenLimits[_token];\\n        if (tokenLimit.enabled == false) {\\n            return _value;\\n        }\\n        \\n        if(_value > tokenLimit.amount) {\\n            _value = tokenLimit.amount;\\n        }\\n\\n        UserLimit memory limit = userLimits[_user][_token];\\n        if (block.number.sub(limit.lastBlock) >= tokenLimit.blocks) {\\n            return _value;\\n        }\\n\\n        if (limit.consumption.add(_value) > tokenLimit.amount) {\\n            _value = tokenLimit.amount.sub(limit.consumption);\\n        }\\n        return _value;\\n    }\\n\\n    function _updateUserTokenLimit(address _token, uint _value) internal {\\n        TokenLimit memory tokenLimit = tokenLimits[_token];\\n        if(tokenLimit.enabled == false) {\\n            return;\\n        }\\n\\n        UserLimit storage limit = userLimits[msg.sender][_token];\\n        if(block.number.sub(limit.lastBlock) > tokenLimit.blocks) {\\n            limit.consumption = 0;\\n        }\\n        limit.lastBlock = block.number;\\n        limit.consumption = limit.consumption.add(_value);\\n    }\\n}\"\r\n    },\r\n    \"contracts/modules/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 0;\\n    uint256 private constant _ENTERED = 1;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused();\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused();\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused();\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/SwitchTicket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\nimport './modules/SwitchERC20.sol';\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function withdraw(uint) external;\\n}\\n\\ncontract SwitchTicket is SwitchERC20 {\\n    bool initialized;\\n    uint public constant version = 1;\\n    address public token;\\n    address public owner;\\n\\n    event OwnerChanged(address indexed _user, address indexed _old, address indexed _new);\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, 'SwitchTicket: FORBIDDEN');\\n        _;\\n    }\\n \\n    function initialize(address _owner, address _token, string calldata _symbol, string calldata _name) external {\\n        require(!initialized, 'SwitchTicket: initialized');\\n        initialized = true;\\n        owner = _owner;\\n        token = _token;\\n        symbol = _symbol;\\n        name = _name;\\n        decimals = SwitchERC20(_token).decimals();\\n    }\\n\\n    function changeOwner(address _user) external onlyOwner {\\n        require(owner != _user, 'SwitchTicket: NO CHANGE');\\n        emit OwnerChanged(msg.sender, owner, _user);\\n        owner = _user;\\n    }\\n\\n    function mint(address to, uint value) external onlyOwner returns (bool) {\\n        _mint(to, value);\\n        return true;\\n    }\\n\\n    function burn(address from, uint value) external onlyOwner returns (bool) {\\n        _burn(from, value);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/modules/Configable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.6;\\n\\ninterface IConfig {\\n    function dev() external view returns (address);\\n    function admin() external view returns (address);\\n}\\n\\ncontract Configable {\\n    address public config;\\n    address public owner;\\n\\n    event ConfigChanged(address indexed _user, address indexed _old, address indexed _new);\\n    event OwnerChanged(address indexed _user, address indexed _old, address indexed _new);\\n \\n    function setupConfig(address _config) external onlyOwner {\\n        emit ConfigChanged(msg.sender, config, _config);\\n        config = _config;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, 'OWNER FORBIDDEN');\\n        _;\\n    }\\n\\n    function admin() public view returns(address) {\\n        if(config != address(0)) {\\n            return IConfig(config).admin();\\n        }\\n        return owner;\\n    }\\n\\n    function dev() public view returns(address) {\\n        if(config != address(0)) {\\n            return IConfig(config).dev();\\n        }\\n        return owner;\\n    }\\n\\n    function changeOwner(address _user) external onlyOwner {\\n        require(owner != _user, 'Owner: NO CHANGE');\\n        emit OwnerChanged(msg.sender, owner, _user);\\n        owner = _user;\\n    }\\n    \\n    modifier onlyDev() {\\n        require(msg.sender == dev() || msg.sender == owner, 'dev FORBIDDEN');\\n        _;\\n    }\\n    \\n    modifier onlyAdmin() {\\n        require(msg.sender == admin(), 'admin FORBIDDEN');\\n        _;\\n    }\\n  \\n    modifier onlyManager() {\\n        require(msg.sender == dev() || msg.sender == admin() || msg.sender == owner, 'manager FORBIDDEN');\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/modules/SwitchERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\nimport '../libraries/SafeMath.sol';\\n\\ncontract SwitchERC20 {\\n    using SafeMath for uint;\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n    uint  public totalSupply;\\n    \\n    mapping(address => uint) public balanceOf;\\n    mapping(address => mapping(address => uint)) public allowance;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint) public nonces;\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    constructor() public {\\n        uint _chainId;\\n        assembly {\\n            _chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n                keccak256(bytes(name)),\\n                keccak256(bytes('1')),\\n                _chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(address to, uint value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint value) internal {\\n         _transfer(from, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint value) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(address from, address to, uint value) private {\\n        require(balanceOf[from] >= value, 'SwitchERC20: INSUFFICIENT_BALANCE');\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        if (to == address(0)) { // burn\\n            totalSupply = totalSupply.sub(value);\\n        }\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint value) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint(-1)) {\\n            require(allowance[from][msg.sender] >= value, 'SwitchERC20: INSUFFICIENT_ALLOWANCE');\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\\n        require(deadline >= block.timestamp, 'SwitchERC20: EXPIRED');\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'SwitchERC20: INVALID_SIGNATURE');\\n        _approve(owner, spender, value);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"ConfigChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_ticket\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_old\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_new\",\"type\":\"bool\"}],\"name\":\"EnableTokenListChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"OldTicketFactoryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_prefixSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_prefixName\",\"type\":\"string\"}],\"name\":\"PrefixChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ticket\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"TicketCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"TokenStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"TreasuryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_ticket\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Withdrawed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"canCreateTicket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"_prefixSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_prefixName\",\"type\":\"string\"}],\"name\":\"configure\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"createTicket\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ticket\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"enableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTokenList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getTokenMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ticket\",\"type\":\"address\"}],\"name\":\"getTokenMapData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ticket\",\"type\":\"address\"}],\"internalType\":\"struct SwitchTicketFactory.TokenMapData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getUserLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ticket\",\"type\":\"address\"}],\"name\":\"isTicket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"iterateTokenMapData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ticket\",\"type\":\"address\"}],\"internalType\":\"struct SwitchTicketFactory.TokenMapData[]\",\"name\":\"result\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldTicketFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prefixName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prefixSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ticket\",\"type\":\"address\"}],\"name\":\"queryWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ticket\",\"type\":\"address\"}],\"name\":\"queryWithdrawInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldTicketFactory\",\"type\":\"address\"}],\"name\":\"setOldTicketFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_prefixSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_prefixName\",\"type\":\"string\"}],\"name\":\"setPrefix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_blocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setTokenLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setTokenLimitEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_token\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_enabled\",\"type\":\"bool[]\"}],\"name\":\"setTokenLimitEnables\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_token\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_enabled\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_blocks\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"setTokenLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_values\",\"type\":\"bool[]\"}],\"name\":\"setTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_config\",\"type\":\"address\"}],\"name\":\"setupConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_a\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_b\",\"type\":\"string\"}],\"name\":\"stringConcat\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ticketExistence\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tickets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenExistence\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"consumption\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ticket\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isETH\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ticket\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawAdv\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SwitchTicketFactory","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}