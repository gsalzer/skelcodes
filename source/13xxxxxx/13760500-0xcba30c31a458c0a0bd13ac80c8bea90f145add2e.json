{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Convex.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.9;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/ITrigger.sol\\\";\\nimport \\\"./interfaces/IConvexBooster.sol\\\";\\n\\ninterface ICrvToken is IERC20 {\\n  function minter() external view returns (address);\\n}\\n\\ninterface ICrvBase {\\n  function get_virtual_price() external view returns (uint256);\\n}\\n\\ninterface ICrvMeta {\\n  function balances(uint256 index) external view returns (uint256);\\n\\n  function base_pool() external view returns (address);\\n\\n  function coins(uint256 index) external view returns (address);\\n\\n  function get_virtual_price() external view returns (uint256);\\n}\\n\\n/**\\n * @notice Defines a trigger that is toggled if any of the following conditions occur:\\n *   1. Convex token total supply does not equal the Curve gauge balanceOf the Convex staker\\n *   2. Virtual price of an underlying Curve pool (whether base pool or meta pool) drops significantly\\n *   3. Internal token balances tracked by an underlying Curve pool (whether base pool or meta pool) are\\n *      significantly lower than the true balances\\n *\\n * @dev This abstract contract requires a few functions to be implemented. These are methods used to\\n * abstract calls to Curve pools which have different function signature that return the same data\\n */\\nabstract contract Convex is ITrigger {\\n  // --- Parameters ---\\n  uint256 public constant scale = 1000; // scale used to define percentages, percentages are defined as tolerance / scale\\n  uint256 public constant virtualPriceTol = scale - 500; // toggle if virtual price drops by >50%\\n  uint256 public constant balanceTol = scale - 500; // toggle if true balances are >50% lower than internally tracked balances\\n  address public constant convex = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31; // Convex deposit contract (booster)\\n\\n  uint256 public immutable convexPoolId; // Convex deposit contract (booster) pool id\\n  address public immutable convexToken; // Convex receipt token minted on deposits\\n  address public immutable staker; // Convex contract that manages staking\\n  address public immutable gauge; // Curve gauge that Convex deposits into\\n\\n  address public immutable curveMetaPool; // Curve meta pool\\n  address public immutable curveBasePool; // Base Curve pool\\n\\n  address public immutable metaToken0; // meta pool token 0\\n  address public immutable metaToken1; // meta pool token 1\\n\\n  address public immutable baseToken0; // base pool token 0\\n  address public immutable baseToken1; // base pool token 1\\n  address public immutable baseToken2; // base pool token 2\\n\\n  uint256 public lastVpBasePool; // last virtual price read from base pool\\n  uint256 public lastVpMetaPool; // last virtual price read from meta pool\\n\\n  // --- Methods to implement ---\\n  // Gets the address of the coin at the specified index in the base pool\\n  function basePoolCoins(uint256 index) internal view virtual returns (address);\\n\\n  // Gets the the base pool's internal balance of the token at the specified index\\n  function basePoolBalances(uint256 index) internal view virtual returns (uint256);\\n\\n  // --- Core trigger logic ---\\n\\n  /**\\n   * @param _convexPoolId TODO\\n   * @dev For definitions of other constructor parameters, see ITrigger.sol\\n   */\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    string memory _description,\\n    uint256[] memory _platformIds,\\n    address _recipient,\\n    uint256 _convexPoolId\\n  ) ITrigger(_name, _symbol, _description, _platformIds, _recipient) {\\n    // Get addresses from the pool ID\\n    (address _curveLpToken, address _convexToken, address _gauge, , , ) = IConvexBooster(convex).poolInfo(\\n      _convexPoolId\\n    );\\n    staker = IConvexBooster(convex).staker();\\n    convexPoolId = _convexPoolId;\\n    convexToken = _convexToken;\\n    gauge = _gauge;\\n\\n    curveMetaPool = ICrvToken(_curveLpToken).minter();\\n    curveBasePool = ICrvMeta(curveMetaPool).base_pool();\\n\\n    metaToken0 = ICrvMeta(curveMetaPool).coins(0);\\n    metaToken1 = ICrvMeta(curveMetaPool).coins(1);\\n\\n    baseToken0 = basePoolCoins(0);\\n    baseToken1 = basePoolCoins(1);\\n    baseToken2 = basePoolCoins(2);\\n\\n    // Get virtual prices\\n    lastVpMetaPool = ICrvMeta(curveMetaPool).get_virtual_price();\\n    lastVpBasePool = ICrvBase(curveBasePool).get_virtual_price();\\n  }\\n\\n  function checkTriggerCondition() internal override returns (bool) {\\n    // In other trigger contracts we check all conditions, save them to storage, and return the result.\\n    // This is convenient because it ensures we have the data that caused the trigger saved into\\n    // the state, but this is just convenient and not a requirement. We do not follow that pattern\\n    // here because certain trigger conditions can cause this method to revert if we tried that\\n    // (and a revert means the trigger can never toggle). Instead, we check conditions one at a\\n    // time, and return immediately if a trigger condition is met.\\n    //\\n    // Specifically, imagine the failure case where the base pool is hacked, and the attacker is\\n    // able to mint 2^128 LP tokens for themself. When this trigger contract calls get_virtual_price()\\n    // on the meta pool, it will revert. This revert happens as follows:\\n    //   1. The base pool will have a virtual price close to zero (or zero, depending on the new\\n    //      total supply). This value is the vp_rate variable in the meta pool's get_virtual_price() method\\n    //   2. This virtual price is passed into the self._xp() method, which multiplies this by\\n    //      the metacurrency token balance then divides by PRECISION. If virtual price is too\\n    //      small relative to the PRECISION, the integer division is floored, returning zero.\\n    //   3. This xp value of zero is passed into self._get_D(), and is used in division. We of\\n    //      course cannot divide by zero, so the call reverts\\n    //\\n    // Given this potential failure mode, we check trigger conditions as follows:\\n    //   1. First we do the balance checks since that check cannot revert\\n    //   2. Next we check the virtual price of that base pool. This can still revert if the balance of\\n    //      a token is too low, resulting in a zero value for xp leading to division by zero, but\\n    //      because we already checked that balances are not too low this should be safe.\\n    //      NOTE: There is a potential edge case where a token balance decrease is less than our 50%\\n    //      threshold so the balance trigger condition is not toggled, BUT the balance is low enough\\n    //      that xp is still floored to zero during integer division, resulting in a revert. In a\\n    //      properly functioning curve market, get_virtual_price() should never revert. Therefore,\\n    //      all external calls are wrapped in a try/catch, and if the call reverts then something is\\n    //      wrong with the underlying protocol and we toggle the trigger\\n    //   3. Lastly we check the virtual price of the meta pool for similar reasons to above\\n    //\\n    // For try/catch blocks, we return early if the trigger condition was met. If it wasn't, we\\n    // save off the new state variable. This can result in \\\"inconsistent\\\" states after a trigger\\n    // occurs. For example, if the first check is ok, but the second check fails, the final state\\n    // of this contract will have the new state from the first check, but the prior state from the\\n    // second (failed) check (i.e. not the most recent check that triggered the). This is a bit\\n    // awkward, but ultimatly is not a problem\\n\\n    // Verify supply of Convex receipt tokens is equal to the amount of curve receipt tokens Convex\\n    // can claim. Convex receipt tokens are minted 1:1 with deposited funds, so this protects\\n    // against e.g. \\\"infinite mint\\\" type bugs, where an attacker is able to mint themselves more\\n    // Convex receipt tokens than what they should receive.\\n    if (IERC20(convexToken).totalSupply() != IERC20(gauge).balanceOf(staker)) return true;\\n\\n    // Internal balance vs. true balance checks\\n    if (checkCurveBaseBalances() || checkCurveMetaBalances()) return true;\\n\\n    // Base pool virtual price check\\n    try ICrvBase(curveBasePool).get_virtual_price() returns (uint256 _newVpBasePool) {\\n      bool _triggerVpBasePool = _newVpBasePool < ((lastVpBasePool * virtualPriceTol) / scale);\\n      if (_triggerVpBasePool) return true;\\n      lastVpBasePool = _newVpBasePool; // if not triggered, save off the virtual price for the next call\\n    } catch {\\n      return true;\\n    }\\n\\n    // Meta pool virtual price check\\n    try ICrvMeta(curveMetaPool).get_virtual_price() returns (uint256 _newVpMetaPool) {\\n      bool _triggerVpMetaPool = _newVpMetaPool < ((lastVpMetaPool * virtualPriceTol) / scale);\\n      if (_triggerVpMetaPool) return true;\\n      lastVpMetaPool = _newVpMetaPool; // if not triggered, save off the virtual price for the next call\\n    } catch {\\n      return true;\\n    }\\n\\n    // Trigger condition has not occured\\n    return false;\\n  }\\n\\n  /**\\n   * @dev Checks if the Curve base pool internal balances are significantly lower than the true balances\\n   * @return True if balances are out of tolerance and trigger should be toggled\\n   */\\n  function checkCurveBaseBalances() internal view returns (bool) {\\n    return\\n      (IERC20(baseToken0).balanceOf(curveBasePool) < ((basePoolBalances(0) * balanceTol) / scale)) ||\\n      (IERC20(baseToken1).balanceOf(curveBasePool) < ((basePoolBalances(1) * balanceTol) / scale)) ||\\n      (IERC20(baseToken2).balanceOf(curveBasePool) < ((basePoolBalances(2) * balanceTol) / scale));\\n  }\\n\\n  /**\\n   * @dev Checks if the Curve meta pool internal balances are significantly lower than the true balances\\n   * @return True if balances are out of tolerance and trigger should be toggled\\n   */\\n  function checkCurveMetaBalances() internal view returns (bool) {\\n    return\\n      (IERC20(metaToken0).balanceOf(curveMetaPool) < ((ICrvMeta(curveMetaPool).balances(0) * balanceTol) / scale)) ||\\n      (IERC20(metaToken1).balanceOf(curveMetaPool) < ((ICrvMeta(curveMetaPool).balances(1) * balanceTol) / scale));\\n  }\\n}\\n\\n/**\\n * @notice Trigger for the Convex USDP pool\\n */\\ncontract ConvexUSDP is Convex {\\n  bytes4 internal constant basePoolCoinsSelector = 0xc6610657; // bytes4(keccak256(\\\"coins(uint256)\\\"))\\n  bytes4 internal constant basePoolBalancesSelector = 0x4903b0d1; // bytes4(keccak256(\\\"balances(uint256)\\\"))\\n\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    string memory _description,\\n    uint256[] memory _platformIds,\\n    address _recipient,\\n    uint256 _convexPoolId\\n  ) Convex(_name, _symbol, _description, _platformIds, _recipient, _convexPoolId) {}\\n\\n  function basePoolCoins(uint256 index) internal view override returns (address) {\\n    (bool ok, bytes memory ret) = curveBasePool.staticcall(abi.encodeWithSelector(basePoolCoinsSelector, index));\\n    require(ok, \\\"coins call reverted\\\");\\n    return abi.decode(ret, (address));\\n  }\\n\\n  function basePoolBalances(uint256 index) internal view override returns (uint256) {\\n    (bool ok, bytes memory ret) = curveBasePool.staticcall(abi.encodeWithSelector(basePoolBalancesSelector, index));\\n    require(ok, \\\"balances call reverted\\\");\\n    return abi.decode(ret, (uint256));\\n  }\\n}\\n\\n/**\\n * @notice Trigger for the Convex tBTC pool\\n */\\ncontract ConvexTBTC is Convex {\\n  bytes4 internal constant basePoolCoinsSelector = 0x23746eb8; // bytes4(keccak256(\\\"coins(int128)\\\"))\\n  bytes4 internal constant basePoolBalancesSelector = 0x065a80d8; // bytes4(keccak256(\\\"balances(int128)\\\"))\\n\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    string memory _description,\\n    uint256[] memory _platformIds,\\n    address _recipient,\\n    uint256 _convexPoolId\\n  ) Convex(_name, _symbol, _description, _platformIds, _recipient, _convexPoolId) {}\\n\\n  function basePoolCoins(uint256 index) internal view override returns (address) {\\n    (bool ok, bytes memory ret) = curveBasePool.staticcall(abi.encodeWithSelector(basePoolCoinsSelector, index));\\n    require(ok, \\\"coins call reverted\\\");\\n    return abi.decode(ret, (address));\\n  }\\n\\n  function basePoolBalances(uint256 index) internal view override returns (uint256) {\\n    (bool ok, bytes memory ret) = curveBasePool.staticcall(abi.encodeWithSelector(basePoolBalancesSelector, index));\\n    require(ok, \\\"coins call reverted\\\");\\n    return abi.decode(ret, (uint256));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITrigger.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\n/**\\n * @notice Abstract contract for creating or interacting with a Trigger contract\\n * @dev All trigger contracts created must inerit from this contract and conform to this interface\\n */\\nabstract contract ITrigger {\\n  /// @notice Trigger name, analgous to an ERC-20 token's name\\n  string public name;\\n\\n  /// @notice Trigger symbol, analgous to an ERC-20 token's symbol\\n  string public symbol;\\n\\n  /// @notice Trigger description\\n  string public description;\\n\\n  /// @notice Array of IDs of platforms covered by this trigger\\n  uint256[] public platformIds;\\n\\n  /// @notice Returns address of recipient who receives subsidies for creating a protection market using this trigger\\n  address public immutable recipient;\\n\\n  /// @notice Returns true if trigger condition has been met\\n  bool public isTriggered;\\n\\n  /// @notice Emitted when the trigger is activated\\n  event TriggerActivated();\\n\\n  /**\\n   * @notice Returns array of IDs, where each ID corresponds to a platform covered by this trigger\\n   * @dev See documentation for mapping of ID numbers to platforms\\n   */\\n  function getPlatformIds() external view returns (uint256[] memory) {\\n    return platformIds;\\n  }\\n\\n  /**\\n   * @dev Executes trigger-specific logic to check if market has been triggered\\n   * @return True if trigger condition occured, false otherwise\\n   */\\n  function checkTriggerCondition() internal virtual returns (bool);\\n\\n  /**\\n   * @notice Checks trigger condition, sets isTriggered flag to true if condition is met, and returns the trigger status\\n   * @return True if trigger condition occured, false otherwise\\n   */\\n  function checkAndToggleTrigger() external returns (bool) {\\n    // Return true if trigger already toggled\\n    if (isTriggered) return true;\\n\\n    // Return false if market has not been triggered\\n    if (!checkTriggerCondition()) return false;\\n\\n    // Otherwise, market has been triggered\\n    emit TriggerActivated();\\n    isTriggered = true;\\n    return isTriggered;\\n  }\\n\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    string memory _description,\\n    uint256[] memory _platformIds,\\n    address _recipient\\n  ) {\\n    name = _name;\\n    description = _description;\\n    symbol = _symbol;\\n    platformIds = _platformIds;\\n    recipient = _recipient;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IConvexBooster.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.9;\\n\\ninterface IConvexBooster {\\n  function staker() external view returns (address);\\n\\n  function poolInfo(uint256)\\n    external\\n    view\\n    returns (\\n      address, // lptoken\\n      address, // token\\n      address, // gauge\\n      address, // crvRewards\\n      address, // stash\\n      bool // shutdown\\n    );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"_platformIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_convexPoolId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TriggerActivated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"balanceTol\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseToken0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseToken1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseToken2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkAndToggleTrigger\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexPoolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveBasePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveMetaPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTriggered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastVpBasePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastVpMetaPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metaToken0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metaToken1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"platformIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"virtualPriceTol\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ConvexUSDP","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000002c00000000000000000000000000e5cd30d22069f785a65e4db31e3d4c7527e64b6000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000019436f6e76657820437572766520555344502054726967676572000000000000000000000000000000000000000000000000000000000000000000000000000014636f6e7665784375727665555344502d54524947000000000000000000000000000000000000000000000000000000000000000000000000000000000000014c5472696767657273207768656e20746865204375727665206261736520706f6f6c206f72204375727665206d65746120706f6f6c2773207669727475616c20707269636520646563726561736573206279206d6f7265207468616e20353025206265747765656e20636f6e736563757469766520636865636b732c206f722074686520696e7465726e616c2062616c616e63657320747261636b656420696e20746865204375727665206261736520706f6f6c206f72204375727665206d65746120706f6f6c20617265206d6f7265207468616e20353025206c6f776572207468616e2074686520747275652062616c616e6365732c206f7220746865206e756d626572206f6620436f6e766578207265636569707420746f6b656e7320646f6573206e6f74206d617463682074686520616d6f756e7420636c61696d61626c652066726f6d204375727665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000c","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}