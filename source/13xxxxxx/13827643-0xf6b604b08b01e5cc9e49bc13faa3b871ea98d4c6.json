{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n ____              _                               _                  \r\n|  _ \\ _   _ _ __ | | ____      _____  __ _ _ __  | |_ ___  _ __  ___ \r\n| |_) | | | | '_ \\| |/ /\\ \\ /\\ / / _ \\/ _` | '__| | __/ _ \\| '_ \\/ __|\r\n|  __/| |_| | | | |   <  \\ V  V /  __/ (_| | |    | || (_) | |_) \\__ \\\r\n|_|    \\__,_|_| |_|_|\\_\\  \\_/\\_/ \\___|\\__,_|_|     \\__\\___/| .__/|___/\r\n                                                           |_|    \r\n*/\r\npragma solidity 0.8.10;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\ninterface CryptopunksInterface {\r\n    function punkIndexToAddress(uint index) external view returns(address);\r\n}\r\n\r\ninterface WrappedPunksInterface {\r\n    function ownerOf(uint index) external view returns(address);\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\ncontract PunkwearTops is IERC721 {\r\n\r\n    event Mint(uint indexed index, address indexed minter, uint createdVia);\r\n\r\n    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    bool public metadataIsLocked;\r\n\r\n\r\n    // Hash of the 10k tops image (run `openssl dgst -sha256 10k_tops.png`) \r\n    bytes public constant contentHash = \"0x31a9260a4f3b032c13a9b9c11164dcd8ade0f23a70ffcf3f98d1fc9b09e98522\";\r\n\r\n    bytes32 internal _setOfIds;\r\n    bytes32 internal constant mask = hex\"0000000000000000000000000000000000000000000000000000000000003fff\";\r\n    uint public constant TOKEN_LIMIT = 10000;\r\n    uint public constant SALE_LIMIT = 9250;\r\n    uint public constant DEV_MAX = 750;\r\n    uint public devMints;\r\n    uint public constant MAX_MINTS_PER_CALL = 20;\r\n\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n    mapping (uint256 => address) internal idToOwner;\r\n    bool[10000] public punkIDsUsed;\r\n    mapping (uint256 => address) internal idToApproval;\r\n    mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n    mapping(address => uint256[]) internal ownerToIds;\r\n    mapping(uint256 => uint256) internal idToOwnerIndex;\r\n\r\n    string internal _name = \"Punkwear Tops\";\r\n    string internal _symbol = \"PWT\";\r\n    string public baseURI = \"https://www.punkwear.xyz/metadata/\";\r\n    string public _contractURI = \"ipfs://QmaZYMyb5dfajhSEL4BpzmVXyqgWqrELDL9jBmV77unb5b\";\r\n\r\n    uint internal numTokens;\r\n\r\n    // Cryptopunks contract\r\n    address internal punksContract = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\r\n    // Wrapped Cryptopunks contract\r\n    address internal wrappedPunksContract = 0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6;\r\n\r\n    address payable public owner;\r\n    uint public constant price = 0.04 ether;\r\n\r\n    //// Random index assignment\r\n    uint internal nonce = 0;\r\n    uint[TOKEN_LIMIT] internal indices;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner.\");\r\n        _;\r\n    }\r\n\r\n    modifier canOperate(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender], \"Cannot operate.\");\r\n        _;\r\n    }\r\n\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(\r\n            tokenOwner == msg.sender\r\n            || idToApproval[_tokenId] == msg.sender\r\n            || ownerToOperators[tokenOwner][msg.sender], \"Cannot transfer.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier validNFToken(uint256 _tokenId) {\r\n        require(idToOwner[_tokenId] != address(0), \"Invalid token.\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n        supportedInterfaces[0x780e9d63] = true; // ERC721 Enumerable\r\n        supportedInterfaces[0x5b5e139f] = true; // ERC721 Metadata\r\n\t    owner = payable(msg.sender);\r\n    }\r\n\r\n    //////////////////////////\r\n    //// ERC 721 and 165  ////\r\n    //////////////////////////\r\n\r\n    function isContract(address _addr) internal view returns (bool addressCheck) {\r\n        addressCheck = _addr.code.length > 0;\r\n    }\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external view override returns (bool) {\r\n        return supportedInterfaces[_interfaceID];\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external override {\r\n        _safeTransferFrom(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external override {\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external override canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from, \"Wrong from address.\");\r\n        require(_to != address(0), \"Cannot send to 0x0.\");\r\n        _transfer(_to, _tokenId);\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId) external override canOperate(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(_approved != tokenOwner);\r\n        idToApproval[_tokenId] = _approved;\r\n        emit Approval(tokenOwner, _approved, _tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external override {\r\n        ownerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function balanceOf(address _owner) external view override returns (uint256) {\r\n        require(_owner != address(0));\r\n        return ownerToIds[_owner].length;\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) external view override returns (address _owner) {\r\n        require(idToOwner[_tokenId] != address(0));\r\n        _owner = idToOwner[_tokenId];\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) external view override validNFToken(_tokenId) returns (address) {\r\n        return idToApproval[_tokenId];\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) external override view returns (bool) {\r\n        return ownerToOperators[_owner][_operator];\r\n    }\r\n\r\n    function _transfer(address _to, uint256 _tokenId) internal {\r\n        address from = idToOwner[_tokenId];\r\n        _clearApproval(_tokenId);\r\n\r\n        _removeNFToken(from, _tokenId);\r\n        _addNFToken(_to, _tokenId);\r\n\r\n        emit Transfer(from, _to, _tokenId);\r\n    }\r\n\r\n    function randomIndex() internal returns (uint) {\r\n        uint totalSize = TOKEN_LIMIT - numTokens;\r\n        //I know it's pseudorandom but because the metadata is not public, it's ok.\r\n        //However, because the team can mint too, it's important that they get random ones (any manipulation would be obvious)\r\n        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\r\n        uint value = 0;\r\n        if (indices[index] != 0) {\r\n            value = indices[index];\r\n        } else {\r\n            value = index;\r\n        }\r\n\r\n        // Move last value to selected position\r\n        if (indices[totalSize - 1] == 0) {\r\n            // Array position not initialized, so use position\r\n            indices[index] = totalSize - 1;\r\n        } else {\r\n            // Array position holds a value so use that\r\n            indices[index] = indices[totalSize - 1];\r\n        }\r\n        nonce++;\r\n        \r\n        return value;\r\n    }\r\n    \r\n    function getBoolean(uint256 _packedBools, uint256 _boolNumber) public pure returns(bool) {\r\n        uint256 flag = (_packedBools >> _boolNumber) & uint256(1);\r\n        return (flag == 1 ? true : false);\r\n    }\r\n    \r\n    function mintWithPunks(bytes32[] memory _allIds, uint256 _numberOfPunks, uint256 _areWrappedBools, uint256 _additionalMints) external payable {\r\n        require(numTokens + _additionalMints + _numberOfPunks <= SALE_LIMIT, \"Qty would exceed max supply\");\r\n        for (uint i=0;i<_numberOfPunks;i++) {\r\n            if (i%18 == 0) {\r\n                _setOfIds = _allIds[i/18];\r\n            }\r\n        //Uncompress punk ids and read them one by one\r\n            uint _punkId = uint16(bytes2((_setOfIds & mask) << 240));\r\n            require(_punkId >= 0 && _punkId < 10000, \"Invalid punk index.\");\r\n            require(!punkIDsUsed[_punkId], \"Already minted with this punk\");\r\n            punkIDsUsed[_punkId] = true;\r\n            if (!getBoolean(_areWrappedBools,i)) {\r\n                require(CryptopunksInterface(punksContract).punkIndexToAddress(_punkId) == msg.sender, \"Not the owner of this punk.\");\r\n            } else {\r\n                require(WrappedPunksInterface(wrappedPunksContract).ownerOf(_punkId) == msg.sender, \"Not the owner of this punk.\");\r\n            }\r\n            _mint(msg.sender, _punkId);\r\n            _setOfIds >>= 14;\r\n        }\r\n        if (_additionalMints>0) {\r\n            mint(_additionalMints);\r\n        }\r\n    }\r\n\r\n    function mint(uint _quantity) public payable {\r\n        require(numTokens + _quantity <= SALE_LIMIT, \"Qty would exceed max supply\");\r\n        require(_quantity <= MAX_MINTS_PER_CALL,\"Max \");\r\n        require(msg.value == price*_quantity, \"Incorrect funds\");\r\n        for (uint i;i<_quantity;i++) {\r\n            _mint(msg.sender, 10000);\r\n        }\r\n    }\r\n\r\n    function _mint(address _to, uint createdVia) internal returns (uint) {\r\n        require(_to != address(0), \"Cannot mint to 0x0.\");\r\n        require(numTokens < TOKEN_LIMIT, \"Token limit reached.\");\r\n        \r\n        uint id = randomIndex();\r\n        numTokens = numTokens + 1;\r\n        _addNFToken(_to, id);\r\n\r\n        emit Mint(id, _to, createdVia);\r\n        emit Transfer(address(0), _to, id);\r\n        \r\n        return id;\r\n    }\r\n\r\n    function _addNFToken(address _to, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == address(0), \"Cannot add, already owned.\");\r\n        idToOwner[_tokenId] = _to;\r\n\r\n        ownerToIds[_to].push(_tokenId);\r\n        idToOwnerIndex[_tokenId] = ownerToIds[_to].length-1;\r\n    }\r\n\r\n    function _removeNFToken(address _from, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == _from, \"Incorrect owner.\");\r\n        delete idToOwner[_tokenId];\r\n\r\n        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownerToIds[_from].length-1;\r\n\r\n        if (lastTokenIndex != tokenToRemoveIndex) {\r\n            uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n            ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n            idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n        }\r\n\r\n        ownerToIds[_from].pop();\r\n    }\r\n\r\n\r\n    function _safeTransferFrom(address _from,  address _to,  uint256 _tokenId,  bytes memory _data) private canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from, \"Incorrect owner.\");\r\n        require(_to != address(0));\r\n\r\n        _transfer(_to, _tokenId);\r\n\r\n        if (isContract(_to)) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n            require(retval == MAGIC_ON_ERC721_RECEIVED);\r\n        }\r\n    }\r\n\r\n    function _clearApproval(uint256 _tokenId) private {\r\n        if (idToApproval[_tokenId] != address(0)) {\r\n            delete idToApproval[_tokenId];\r\n        }\r\n    }\r\n\r\n\r\n    function devMint(uint quantity, address recipient) external onlyOwner {\r\n        require(devMints + quantity <= DEV_MAX);\r\n        devMints = devMints + quantity;\r\n        for (uint i; i < quantity; i++) {\r\n            _mint(recipient, 10000);\r\n        }\r\n    }\r\n\r\n    \r\n    //// Enumerable\r\n    function totalSupply() public view returns (uint256) {\r\n        return numTokens;\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\r\n        require(_index < ownerToIds[_owner].length);\r\n        return ownerToIds[_owner][_index];\r\n    }\r\n\r\n\r\n    //// Metadata\r\n\r\n    function lockMetadata() external onlyOwner {\r\n        metadataIsLocked = true;\r\n    }\r\n\r\n\r\n    function setContractURI(string memory _newContractURI) external onlyOwner {\r\n        require(!metadataIsLocked,\"Metadata is locked\");\r\n        _contractURI = _newContractURI;\r\n    }\r\n\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) external view validNFToken(_tokenId) returns (string memory) {\r\n        return string(abi.encodePacked(baseURI, uint2str(_tokenId)));\r\n    }\r\n    \r\n    function setBaseURI(string memory newBaseURI) external onlyOwner {\r\n        require(!metadataIsLocked,\"Metadata is locked\");\r\n        baseURI = newBaseURI;\r\n    }\r\n    \r\n    function uint2str(uint256 _i) internal pure returns (string memory str) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 tmp = _i;\r\n        uint256 length;\r\n        while (tmp != 0) {\r\n            length++;\r\n            tmp /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint256 k = length;\r\n        tmp = _i;\r\n        while (tmp != 0) {\r\n            bstr[--k] = bytes1(uint8(48 + tmp % 10));\r\n            tmp /= 10;\r\n        }\r\n        str = string(bstr);\r\n    }\r\n\r\n    function contractURI() external view returns (string memory) {\r\n        return _contractURI;\r\n    }\r\n\r\n    function withdraw() external onlyOwner {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"createdVia\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEV_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_MINTS_PER_CALL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SALE_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contentHash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"devMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_packedBools\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_boolNumber\",\"type\":\"uint256\"}],\"name\":\"getBoolean\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadataIsLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_allIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_numberOfPunks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_areWrappedBools\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_additionalMints\",\"type\":\"uint256\"}],\"name\":\"mintWithPunks\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"punkIDsUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newContractURI\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PunkwearTops","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f2b1692aa156922c86ed9a53f54a774771f475a374ff907bc3895c905732f820"}]}