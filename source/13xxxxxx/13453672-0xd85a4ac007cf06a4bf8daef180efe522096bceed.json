{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(),\"Not Owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0),\"Zero address not allowed\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ninterface ISwapFactory {\r\n    function swap(address tokenA, address tokenB, uint256 amount, address user, uint256 crossOrderType, uint256 dexId, uint256 deadline) \r\n    external payable returns (bool);\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface IUni {\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external payable\r\n    returns (uint[] memory amounts);\r\n    \r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) \r\n    external \r\n    returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n}\r\n\r\ninterface IReimbursement {\r\n    function getLicenseeFee(address licenseeVault, address projectContract) external view returns(uint256); // return fee percentage with 2 decimals\r\n    function getVaultOwner(address vault) external view returns(address);\r\n    // returns address of fee receiver or address(0) if licensee can't receive the fee (fee should be returns to user)\r\n    function requestReimbursement(address user, uint256 feeAmount, address licenseeVault) external returns(address);\r\n}\r\n\r\ncontract Degen is Ownable {\r\n    using TransferHelper for address;\r\n    enum OrderType {EthForTokens, TokensForEth, TokensForTokens, EthForEth}\r\n    \r\n    IUni public Uni = IUni(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); //mainnet network address for uniswap (valid for Ropsten as well)\r\n    IUni public Sushi = IUni(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // Mainnet network address for sushiswap\r\n    //address public _sushi = address(0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506); // Ropsten network address for sushiswap\r\n    //address public USDT = address(0x47A530f3Fa882502344DC491549cA9c058dbC7Da); // Ropsten test net USDT test token\r\n    address public USDT = address(0xdAC17F958D2ee523a2206206994597C13D831ec7); // USDT Token Address\r\n    address public system;\r\n    uint256 public processingFee = 0 ;\r\n    \r\n    uint256 private deadlineLimit = 20*60;      // 20 minutes by default \r\n    \r\n    uint256 private collectedFees = 1; // amount of collected fee (starts from 1 to avoid additional gas usage)\r\n    address public feeReceiver; // address which receive the fee (by default is validator)\r\n\r\n\r\n    IReimbursement public reimbursementContract;      // reimbursement contract address\r\n\r\n    address public companyVault;    // the vault address of our company registered in reimbursement contract\r\n\r\n    ISwapFactory public swapFactory;\r\n   \r\n    modifier onlySystem() {\r\n        require(msg.sender == system || owner() == msg.sender,\"Caller is not the system\");\r\n        _;\r\n    }\r\n    \r\n    constructor(address _swapFactory, address _system) \r\n    {\r\n        swapFactory = ISwapFactory(_swapFactory);\r\n        system = _system;\r\n    }\r\n    \r\n\r\n    function setCompanyVault(address _comapnyVault) external onlyOwner {\r\n        companyVault = _comapnyVault;\r\n    }\r\n\r\n    function setReimbursementContract(address _reimbursementContarct) external onlyOwner {\r\n        reimbursementContract = IReimbursement(_reimbursementContarct);\r\n    }\r\n\r\n    function setProcessingFee(uint256 _processingFees) external onlySystem {\r\n        processingFee = _processingFees;\r\n    }\r\n\r\n    function setSwapFactory(address _swapFactory) external onlyOwner {\r\n        swapFactory = ISwapFactory(_swapFactory);\r\n    }\r\n    \r\n    function setSystem(address _system) external onlyOwner {\r\n        system = _system;\r\n    }\r\n    \r\n    function setFeeReceiver(address _addr) external onlyOwner {\r\n        feeReceiver = _addr;\r\n    }\r\n    \r\n    function getDeadlineLimit() public view returns(uint256) {\r\n        return deadlineLimit;\r\n    }\r\n    \r\n    function setDeadlineLimit(uint256 limit) external onlyOwner {\r\n        deadlineLimit = limit;\r\n    }\r\n\r\n    // get amount of collected fees that can be claimed\r\n    function getColletedFees() external view returns (uint256) {\r\n        // collectedFees starts from 1 to avoid additional gas usage to initiate storage (when collectedFees = 0)\r\n        return collectedFees - 1;\r\n    }\r\n\r\n    // claim fees by feeReceiver\r\n    function claimFee() external returns (uint256 feeAmount) {\r\n        require(msg.sender == feeReceiver, \"This fee can be claimed only by fee receiver!!\");\r\n        feeAmount = collectedFees - 1;\r\n        collectedFees = 1;        \r\n        TransferHelper.safeTransferETH(msg.sender, feeAmount);\r\n    }\r\n    \r\n    \r\n    // Call function processFee() at the end of main function for correct gas usage calculation.\r\n    // txGas - is gasleft() on start of calling contract. Put `uint256 txGas = gasleft();` as a first command in function\r\n    // feeAmount - fee amount that user paid\r\n    // processing - processing fee (for cross-chain swaping)\r\n    // licenseeVault - address that licensee received on registration and should provide when users comes from their site\r\n    // user - address of user who has to get reimbursement (usually msg.sender)\r\n\r\n    function processFee(uint256 txGas, uint256 feeAmount, uint256 processing, address licenseeVault, address user) internal {\r\n        if (address(reimbursementContract) == address(0)) {\r\n            payable(user).transfer(feeAmount); // return fee to sender if no reimbursement contract\r\n            return;\r\n        }\r\n        \r\n        uint256 licenseeFeeAmount;\r\n        if (licenseeVault != address(0)) {\r\n            uint256 companyFeeRate = reimbursementContract.getLicenseeFee(companyVault, address(this));\r\n            uint256 licenseeFeeRate = reimbursementContract.getLicenseeFee(licenseeVault, address(this));\r\n            if (licenseeFeeRate != 0)\r\n                licenseeFeeAmount = (feeAmount * licenseeFeeRate)/(licenseeFeeRate + companyFeeRate);\r\n            if (licenseeFeeAmount != 0) {\r\n                address licenseeFeeTo = reimbursementContract.requestReimbursement(user, licenseeFeeAmount, licenseeVault);\r\n                if (licenseeFeeTo == address(0)) {\r\n                    payable(user).transfer(licenseeFeeAmount);    // refund to user\r\n                } else {\r\n                    payable(licenseeFeeTo).transfer(licenseeFeeAmount);  // transfer to fee receiver\r\n                }\r\n            }\r\n        }\r\n        feeAmount -= licenseeFeeAmount; // company's part of fee\r\n        collectedFees += feeAmount; \r\n        \r\n        if (processing != 0) \r\n            payable(system).transfer(processing);  // transfer to fee receiver\r\n        \r\n        txGas -= gasleft(); // get gas amount that was spent on Licensee fee\r\n        txGas = txGas * tx.gasprice;\r\n        // request reimbursement for user\r\n        reimbursementContract.requestReimbursement(user, feeAmount+txGas+processing, companyVault);\r\n    }\r\n    \r\n    \r\n    function _swap( \r\n        OrderType orderType, \r\n        address[] memory path, \r\n        uint256 assetInOffered,\r\n        uint256 minExpectedAmount, \r\n        address to,\r\n        uint256 dexId,\r\n        uint256 deadline\r\n    ) internal returns(uint256 amountOut) {\r\n         \r\n        require(dexId < 2, \"Invalid DEX Id!\");\r\n        require(deadline >= block.timestamp, \"EXPIRED: Deadline for transaction already passed.\");\r\n\r\n       if(dexId == 0){\r\n            uint[] memory swapResult;\r\n            if(orderType == OrderType.EthForTokens) {\r\n                 path[0] = Uni.WETH();\r\n                 swapResult = Uni.swapExactETHForTokens{value:assetInOffered}(0, path, to,block.timestamp);\r\n            }\r\n            else if (orderType == OrderType.TokensForEth) {\r\n                path[path.length-1] = Uni.WETH();\r\n                TransferHelper.safeApprove(path[0], address(Uni), assetInOffered);\r\n                swapResult = Uni.swapExactTokensForETH(assetInOffered, 0, path,to, block.timestamp);\r\n            }\r\n            else if (orderType == OrderType.TokensForTokens) {\r\n                TransferHelper.safeApprove(path[0], address(Uni), assetInOffered);\r\n                swapResult = Uni.swapExactTokensForTokens(assetInOffered, minExpectedAmount, path, to, block.timestamp);\r\n            }\r\n            amountOut = swapResult[swapResult.length - 1];\r\n        } else if(dexId == 1) {\r\n            uint[] memory swapResult;\r\n            if(orderType == OrderType.EthForTokens) {\r\n                 path[0] = Sushi.WETH();\r\n                 swapResult = Sushi.swapExactETHForTokens{value:assetInOffered}(minExpectedAmount, path, to, block.timestamp);\r\n            }\r\n            else if (orderType == OrderType.TokensForEth) {\r\n                path[path.length-1] = Sushi.WETH();\r\n                TransferHelper.safeApprove(path[0], address(Sushi), assetInOffered);\r\n                swapResult = Sushi.swapExactTokensForETH(assetInOffered, minExpectedAmount, path, to, block.timestamp);\r\n            }\r\n            else if (orderType == OrderType.TokensForTokens) {\r\n                TransferHelper.safeApprove(path[0], address(Sushi), assetInOffered);\r\n                swapResult = Sushi.swapExactTokensForTokens(assetInOffered, minExpectedAmount, path, to, block.timestamp);\r\n            }\r\n            amountOut = swapResult[swapResult.length - 1];\r\n        }\r\n    }\r\n    \r\n    function executeSwap(\r\n        OrderType orderType, \r\n        address[] memory path, \r\n        uint256 assetInOffered, \r\n        uint256 fees, \r\n        uint256 minExpectedAmount,\r\n        address licenseeVault,\r\n        uint256 dexId,\r\n        uint256 deadline\r\n    ) external payable {\r\n        uint256 gasA = gasleft();\r\n        uint256 receivedFees = 0;\r\n        if(deadline == 0) {\r\n            deadline = block.timestamp + deadlineLimit;\r\n        }\r\n        \r\n        if(orderType == OrderType.EthForTokens){\r\n            require(msg.value >= (assetInOffered + fees), \"Payment = assetInOffered + fees\");\r\n            receivedFees = receivedFees + msg.value - assetInOffered;\r\n        } else {\r\n            require(msg.value >= fees, \"fees not received\");\r\n            receivedFees = receivedFees + msg.value;\r\n            TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), assetInOffered);\r\n        }\r\n        \r\n        _swap(orderType, path, assetInOffered, minExpectedAmount, msg.sender, dexId, deadline);\r\n   \r\n        processFee(gasA, receivedFees, 0, licenseeVault, msg.sender);\r\n    }\r\n    \r\n    function executeCrossExchange(\r\n        address[] memory path, \r\n        OrderType orderType,\r\n        uint256 crossOrderType,\r\n        uint256 assetInOffered,\r\n        uint256 fees, \r\n        uint256 minExpectedAmount,\r\n        address licenseeVault,\r\n        uint256[3] memory dexId_deadline // dexId_deadline[0] - native swap dexId, dexId_deadline[1] - foreign swap dexId, dexId_deadline[2] - deadline\r\n    ) public payable {\r\n        uint256[2] memory feesPrice;\r\n        feesPrice[0] = gasleft();       // equivalent to gasA\r\n        feesPrice[1] = 0;               // processing fees\r\n        \r\n        if (dexId_deadline[2] == 0) {   // if deadline == 0, set deadline to deadlineLimit\r\n            dexId_deadline[2] = block.timestamp + deadlineLimit;\r\n        }\r\n\r\n        if(orderType == OrderType.EthForTokens){\r\n            require(msg.value >= (assetInOffered + fees + processingFee), \"Payment = assetInOffered + fees + processingFee\");\r\n            feesPrice[1] = msg.value - assetInOffered - fees;\r\n        } else {\r\n            require(msg.value >= (fees + processingFee), \"fees not received\");\r\n            feesPrice[1] = msg.value - fees;\r\n            TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), assetInOffered);\r\n        }\r\n        \r\n        if(path[0] == USDT) {\r\n            TransferHelper.safeApprove(USDT, address(swapFactory), assetInOffered);\r\n            swapFactory.swap(USDT, path[path.length-1], assetInOffered, msg.sender, crossOrderType, dexId_deadline[1], dexId_deadline[2]);\r\n        }\r\n        else {\r\n            address tokenB = path[path.length-1];\r\n            path[path.length-1] = USDT;\r\n            uint256 minAmountExpected = _swap(orderType, path, assetInOffered, minExpectedAmount, address(this), dexId_deadline[0], dexId_deadline[2]);\r\n                \r\n            TransferHelper.safeApprove(USDT, address(swapFactory),minAmountExpected);\r\n            swapFactory.swap(USDT, tokenB, minAmountExpected, msg.sender, crossOrderType, dexId_deadline[1], dexId_deadline[2]);\r\n        }        \r\n\r\n        processFee(feesPrice[0], fees, feesPrice[1], licenseeVault, msg.sender);\r\n    }\r\n\r\n    function callbackCrossExchange( \r\n        uint256 orderType, \r\n        address[] memory path, \r\n        uint256 assetInOffered, \r\n        address user,\r\n        uint256 dexId,\r\n        uint256 deadline\r\n    ) public returns(bool) {\r\n        require(msg.sender == address(swapFactory) , \"Degen : caller is not SwapFactory\");\r\n        if(deadline==0) {\r\n            deadline = block.timestamp + deadlineLimit;\r\n        }\r\n        _swap(OrderType(orderType), path, assetInOffered, uint256(0), user, dexId, deadline);\r\n        return true;\r\n    }\r\n\r\n    // user has to approve 1Inch router contract to transfer `assetInOffered` before calling this function \r\n    // when call `swap` API of 1Inch, you have to set:\r\n    // `fromTokenAddress` - token user want to swap (if user swap ETH use address: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n    // `toTokenAddress ` - token user want to receive\r\n    // `amount` - amount of tokens user want to swap\r\n    // `fromAddress` - the user's address. MAY NOT WORK\r\n    // `slippage` - from user's setting\r\n    function executeSwap1Inch(\r\n        address[2] memory path, // path[0] - from token, path[1] - to token\r\n        OrderType orderType, \r\n        uint256 assetInOffered, // token amount or value of ETH (Form API response).\r\n        uint256 fees, \r\n        address licenseeVault,\r\n        address to, // 1Inch router. Form API response.\r\n        bytes memory data   // Form API response.\r\n    ) external payable {\r\n        uint256 gasA = gasleft();\r\n        uint256 receivedFees;\r\n        uint256 value;\r\n        \r\n        if(orderType == OrderType.EthForTokens){\r\n            require(msg.value >= (assetInOffered + fees), \"Payment = assetInOffered + fees\");\r\n            receivedFees = msg.value - assetInOffered;\r\n            value = assetInOffered;\r\n        } else {\r\n            require(msg.value >= fees, \"fees not received\");\r\n            receivedFees = msg.value;\r\n            TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), assetInOffered);\r\n            TransferHelper.safeApprove(path[0],to,assetInOffered);\r\n        }\r\n        \r\n        callTo(to, value, data);\r\n   \r\n        processFee(gasA, receivedFees, 0, licenseeVault, msg.sender);\r\n    }\r\n    \r\n    // user has to approve 1Inch router contract to transfer `assetInOffered` before calling this function \r\n    // when call `swap` API of 1Inch, you have to set:\r\n    // `fromTokenAddress` - token user want to swap (if user swap ETH use address: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n    // `toTokenAddress ` - token user want to receive\r\n    // `amount` - amount of tokens user want to swap\r\n    // `fromAddress` - the user's address\r\n    // `slippage` - from user's setting\r\n    // `destReceiver` - Degen contract address\r\n    function executeCrossExchange1Inch(\r\n        address[2] memory path, // path[0] - from token, path[1] - to token\r\n        OrderType crossOrderType, \r\n        uint256 assetInOffered, // token amount or value of ETH (Form API response).\r\n        uint256 fees, \r\n        address licenseeVault,\r\n        address to, // 1Inch router. Form API response.\r\n        bytes memory data,   // Form API response.\r\n        uint256 toDEX,  // destination dex that will be used on foreign chain.\r\n        uint256 deadline\r\n    ) external payable {\r\n        uint256 gasA = gasleft();\r\n        uint256 _crossOrderType = uint256(crossOrderType);\r\n        uint256 value;\r\n        \r\n        if(deadline==0) {\r\n            deadline = block.timestamp + deadlineLimit;\r\n        }\r\n        \r\n        if(crossOrderType == OrderType.EthForTokens || crossOrderType == OrderType.EthForEth){\r\n            require(msg.value >= (assetInOffered + fees), \"Payment = assetInOffered + fees\");\r\n            fees = msg.value - assetInOffered;\r\n            value = assetInOffered;\r\n        } else {\r\n            require(msg.value >= fees, \"fees not received\");\r\n            fees = msg.value;\r\n            TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), assetInOffered);\r\n            TransferHelper.safeApprove(path[0],to,assetInOffered);\r\n        }\r\n               \r\n        uint256 balanceUSDT = IERC20(USDT).balanceOf(address(this));\r\n        callTo(to, value, data);\r\n        balanceUSDT = IERC20(USDT).balanceOf(address(this)) - balanceUSDT;  // USDT amount that received from 1Inch swap\r\n        TransferHelper.safeApprove(USDT, address(swapFactory), balanceUSDT);\r\n        \r\n        swapFactory.swap(USDT, path[1], balanceUSDT, msg.sender, _crossOrderType, toDEX, deadline);\r\n\r\n        processFee(gasA, fees, 0, licenseeVault, msg.sender);\r\n    }\r\n\r\n    function callTo(address to, uint256 value, bytes memory data) internal {\r\n        (bool success,) = to.call{value: value}(data);\r\n        require(success, \"call to contract error\");\r\n    }\r\n\r\n    // If someone accidentally transfer tokens to this contract, the owner will be able to rescue it and refund sender.\r\n    function rescueTokens(address _token) external onlyOwner {\r\n        if (address(0) == _token) {\r\n            payable(msg.sender).transfer(address(this).balance);\r\n        } else {\r\n            uint256 available = IERC20(_token).balanceOf(address(this));\r\n            TransferHelper.safeTransfer(_token, msg.sender, available);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_system\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Sushi\",\"outputs\":[{\"internalType\":\"contract IUni\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Uni\",\"outputs\":[{\"internalType\":\"contract IUni\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderType\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"assetInOffered\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dexId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"callbackCrossExchange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companyVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"enum Degen.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"crossOrderType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetInOffered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minExpectedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"licenseeVault\",\"type\":\"address\"},{\"internalType\":\"uint256[3]\",\"name\":\"dexId_deadline\",\"type\":\"uint256[3]\"}],\"name\":\"executeCrossExchange\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"path\",\"type\":\"address[2]\"},{\"internalType\":\"enum Degen.OrderType\",\"name\":\"crossOrderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"assetInOffered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"licenseeVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"toDEX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"executeCrossExchange1Inch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum Degen.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"assetInOffered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minExpectedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"licenseeVault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dexId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"executeSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"path\",\"type\":\"address[2]\"},{\"internalType\":\"enum Degen.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"assetInOffered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"licenseeVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeSwap1Inch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getColletedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDeadlineLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reimbursementContract\",\"outputs\":[{\"internalType\":\"contract IReimbursement\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comapnyVault\",\"type\":\"address\"}],\"name\":\"setCompanyVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setDeadlineLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_processingFees\",\"type\":\"uint256\"}],\"name\":\"setProcessingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reimbursementContarct\",\"type\":\"address\"}],\"name\":\"setReimbursementContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapFactory\",\"type\":\"address\"}],\"name\":\"setSwapFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_system\",\"type\":\"address\"}],\"name\":\"setSystem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFactory\",\"outputs\":[{\"internalType\":\"contract ISwapFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"system\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Degen","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005eb3a5b2f0017debf5307f279eef58d3461b124000000000000000000000000036155633f72e34f855f128e7ef5beb214b7c27f5","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6b5958ec2644c0c188a957520a1ebbc050e5468d0ffde221f19c36e3be9a064e"}]}