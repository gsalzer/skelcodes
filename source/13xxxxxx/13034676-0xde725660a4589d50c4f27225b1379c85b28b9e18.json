{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/constants/CAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\naddress constant LENDINGPOOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\\naddress constant LENDINGPOOL_ADDRESSES_PROVIDER = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;\\naddress constant PROTOCOL_DATA_PROVIDER = 0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d;\\n\"\r\n    },\r\n    \"contracts/constants/CAaveServices.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\naddress constant GELATO = 0x3CACa7b48D0573D793d3b0279b5F0029180E83b6;\\nstring constant OK = \\\"OK\\\";\\n\"\r\n    },\r\n    \"contracts/constants/CProtectionAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nuint256 constant DISCREPANCY_BPS_CAP = 500; // 5%\\nuint256 constant SLIPPAGE_BPS_CAP = 500; // 5%\\nuint256 constant TEN_THOUSAND_BPS = 1e4; // 100%\\n\"\r\n    },\r\n    \"contracts/functions/FProtection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {ILendingPool} from \\\"../interfaces/aave/ILendingPool.sol\\\";\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"../interfaces/aave/ILendingPoolAddressesProvider.sol\\\";\\nimport {\\n    IProtocolDataProvider\\n} from \\\"../interfaces/aave/IProtocolDataProvider.sol\\\";\\nimport {IPriceOracle} from \\\"../interfaces/aave/IPriceOracle.sol\\\";\\nimport {\\n    IProtectionAction\\n} from \\\"../interfaces/services/actions/IProtectionAction.sol\\\";\\nimport {PROTOCOL_DATA_PROVIDER} from \\\"../constants/CAave.sol\\\";\\nimport {TEN_THOUSAND_BPS} from \\\"../constants/CProtectionAction.sol\\\";\\nimport {\\n    ProtectionDataCompute,\\n    RepayAndFlashBorrowData,\\n    RepayAndFlashBorrowResult\\n} from \\\"../structs/SProtection.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {_qmul, _wdiv, _wmul} from \\\"../vendor/DSMath.sol\\\";\\n\\nfunction _getRepayAndFlashBorrowAmt(\\n    RepayAndFlashBorrowData memory _rAndWAmtData,\\n    ILendingPool _lendingPool,\\n    ILendingPoolAddressesProvider _lendingPoolAddressesProvider\\n) view returns (RepayAndFlashBorrowResult memory) {\\n    ProtectionDataCompute memory protectionDataCompute;\\n\\n    protectionDataCompute.onBehalfOf = _rAndWAmtData.user;\\n    protectionDataCompute.colToken = _rAndWAmtData.colToken;\\n    protectionDataCompute.debtToken = _rAndWAmtData.debtToken;\\n    protectionDataCompute.wantedHealthFactor = _rAndWAmtData.wantedHealthFactor;\\n\\n    uint256 currenthealthFactor;\\n    (\\n        protectionDataCompute.totalCollateralETH,\\n        protectionDataCompute.totalBorrowsETH,\\n        ,\\n        protectionDataCompute.currentLiquidationThreshold,\\n        ,\\n        currenthealthFactor\\n    ) = _lendingPool.getUserAccountData(_rAndWAmtData.user);\\n\\n    uint256[] memory pricesInETH;\\n    {\\n        address[] memory assets = new address[](2);\\n        assets[0] = _rAndWAmtData.colToken;\\n        assets[1] = _rAndWAmtData.debtToken;\\n        // index 0 is colToken to Eth price, and index 1 is debtToken to Eth price\\n        pricesInETH = IPriceOracle(\\n            _lendingPoolAddressesProvider.getPriceOracle()\\n        ).getAssetsPrices(assets);\\n\\n        protectionDataCompute.colPrice = pricesInETH[0];\\n        protectionDataCompute.debtPrice = pricesInETH[1];\\n    }\\n\\n    (\\n        ,\\n        ,\\n        protectionDataCompute.colLiquidationThreshold,\\n        ,\\n        ,\\n        ,\\n        ,\\n        ,\\n        ,\\n\\n    ) = IProtocolDataProvider(PROTOCOL_DATA_PROVIDER)\\n        .getReserveConfigurationData(_rAndWAmtData.colToken);\\n\\n    protectionDataCompute.protectionFeeInETH = _rAndWAmtData.protectionFeeInETH;\\n    protectionDataCompute.flashloanPremiumBps = _lendingPool\\n        .FLASHLOAN_PREMIUM_TOTAL();\\n\\n    return\\n        _amountToPaybackAndFlashBorrow(_rAndWAmtData.id, protectionDataCompute);\\n}\\n\\nfunction _amountToPaybackAndFlashBorrow(\\n    bytes32 _id,\\n    ProtectionDataCompute memory _protectionDataCompute\\n) view returns (RepayAndFlashBorrowResult memory) {\\n    uint256 intermediateValue = _wdiv(\\n        ((_wmul(\\n            _protectionDataCompute.wantedHealthFactor,\\n            _protectionDataCompute.totalBorrowsETH\\n        ) -\\n            (\\n                _qmul(\\n                    _protectionDataCompute.totalCollateralETH,\\n                    _protectionDataCompute.currentLiquidationThreshold\\n                )\\n            )) +\\n            _qmul(\\n                _protectionDataCompute.protectionFeeInETH,\\n                _protectionDataCompute.colLiquidationThreshold\\n            )),\\n        _protectionDataCompute.wantedHealthFactor -\\n            _qmul(\\n                _protectionDataCompute.colLiquidationThreshold,\\n                (TEN_THOUSAND_BPS + _protectionDataCompute.flashloanPremiumBps)\\n            ) *\\n            1e14\\n    );\\n\\n    uint256 colTokenDecimals = ERC20(_protectionDataCompute.colToken)\\n        .decimals();\\n    uint256 debtTokenDecimals = ERC20(_protectionDataCompute.debtToken)\\n        .decimals();\\n\\n    return\\n        RepayAndFlashBorrowResult(\\n            _id,\\n            _tokenToTokenPrecision(\\n                _wdiv(intermediateValue, _protectionDataCompute.colPrice),\\n                18,\\n                colTokenDecimals\\n            ),\\n            _tokenToTokenPrecision(\\n                _wdiv(intermediateValue, _protectionDataCompute.debtPrice),\\n                18,\\n                debtTokenDecimals\\n            ),\\n            \\\"OK\\\"\\n        );\\n}\\n\\nfunction _tokenToTokenPrecision(\\n    uint256 _amount,\\n    uint256 _oldPrecision,\\n    uint256 _newPrecision\\n) pure returns (uint256) {\\n    return\\n        _oldPrecision > _newPrecision\\n            ? _amount / (10**(_oldPrecision - _newPrecision))\\n            : _amount * (10**(_newPrecision - _oldPrecision));\\n}\\n\\nfunction _convertEthToToken(\\n    ILendingPoolAddressesProvider _lendingPoolAddressesProvider,\\n    address _token,\\n    uint256 _amount\\n) view returns (uint256) {\\n    address[] memory assets = new address[](1);\\n    assets[0] = _token;\\n    return\\n        _tokenToTokenPrecision(\\n            _wdiv(\\n                _amount,\\n                (\\n                    IPriceOracle(_lendingPoolAddressesProvider.getPriceOracle())\\n                        .getAssetsPrices(assets)\\n                )[0]\\n            ),\\n            18,\\n            ERC20(_token).decimals()\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/functions/FProtectionResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {ILendingPool} from \\\"../interfaces/aave/ILendingPool.sol\\\";\\nimport {LENDINGPOOL} from \\\"../constants/CAave.sol\\\";\\nimport {_wdiv, _wmul} from \\\"../vendor/DSMath.sol\\\";\\n\\n// Formula to get slippage from HealthFactor\\n/// @dev _currentHealthFactor current health factor\\n/// @dev _totalNormalizedCollateralInEth current total amount of Col x liquidation threshold\\n/// @dev _expectedTotalBorrowInEth expected total amount of Debt in Eth after protection\\nfunction getSlippageInETH(\\n    uint256 _currentHealthFactor,\\n    uint256 _totalNormalizedCollateralInEth,\\n    uint256 _expectedTotalBorrowInEth\\n) pure returns (uint256) {\\n    return\\n        _wdiv(\\n            _totalNormalizedCollateralInEth -\\n                _wmul(_currentHealthFactor, _expectedTotalBorrowInEth),\\n            _currentHealthFactor\\n        );\\n}\\n\\nfunction _isPositionUnsafe(address _user, uint256 _minimumHF)\\n    view\\n    returns (bool)\\n{\\n    (, , , , , uint256 currenthealthFactor) = ILendingPool(LENDINGPOOL)\\n        .getUserAccountData(_user);\\n    return currenthealthFactor < _minimumHF;\\n}\\n\\nfunction _isAllowed(\\n    address _aToken,\\n    address _user,\\n    address _spender,\\n    uint256 _allowedAmt\\n) view returns (bool) {\\n    return\\n        IERC20(_aToken).balanceOf(_user) >= _allowedAmt &&\\n        IERC20(_aToken).allowance(_user, _spender) >= _allowedAmt;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/ILendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"./ILendingPoolAddressesProvider.sol\\\";\\nimport {DataTypes} from \\\"../../structs/SAave.sol\\\";\\n\\ninterface ILendingPool {\\n    /**\\n     * @dev Emitted on deposit()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address initiating the deposit\\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\\n     * @param amount The amount deposited\\n     * @param referral The referral code used\\n     **/\\n    event Deposit(\\n        address indexed reserve,\\n        address user,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint16 indexed referral\\n    );\\n\\n    /**\\n     * @dev Emitted on withdraw()\\n     * @param reserve The address of the underlyng asset being withdrawn\\n     * @param user The address initiating the withdrawal, owner of aTokens\\n     * @param to Address that will receive the underlying\\n     * @param amount The amount to be withdrawn\\n     **/\\n    event Withdraw(\\n        address indexed reserve,\\n        address indexed user,\\n        address indexed to,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\\n     * @param reserve The address of the underlying asset being borrowed\\n     * @param user The address of the user initiating the borrow(),\\n     * receiving the funds on borrow() or just\\n     * initiator of the transaction on flashLoan()\\n     * @param onBehalfOf The address that will be getting the debt\\n     * @param amount The amount borrowed out\\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\\n     * @param borrowRate The numeric rate at which the user has borrowed\\n     * @param referral The referral code used\\n     **/\\n    event Borrow(\\n        address indexed reserve,\\n        address user,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint256 borrowRateMode,\\n        uint256 borrowRate,\\n        uint16 indexed referral\\n    );\\n\\n    /**\\n     * @dev Emitted on repay()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The beneficiary of the repayment, getting his debt reduced\\n     * @param repayer The address of the user initiating the repay(), providing the funds\\n     * @param amount The amount repaid\\n     **/\\n    event Repay(\\n        address indexed reserve,\\n        address indexed user,\\n        address indexed repayer,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted on swapBorrowRateMode()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user swapping his rate mode\\n     * @param rateMode The rate mode that the user wants to swap to\\n     **/\\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\\n\\n    /**\\n     * @dev Emitted on setUserUseReserveAsCollateral()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user enabling the usage as collateral\\n     **/\\n    event ReserveUsedAsCollateralEnabled(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted on setUserUseReserveAsCollateral()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user enabling the usage as collateral\\n     **/\\n    event ReserveUsedAsCollateralDisabled(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted on rebalanceStableBorrowRate()\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param user The address of the user for which the rebalance has been executed\\n     **/\\n    event RebalanceStableBorrowRate(\\n        address indexed reserve,\\n        address indexed user\\n    );\\n\\n    /**\\n     * @dev Emitted on flashLoan()\\n     * @param target The address of the flash loan receiver contract\\n     * @param initiator The address initiating the flash loan\\n     * @param asset The address of the asset being flash borrowed\\n     * @param amount The amount flash borrowed\\n     * @param premium The fee flash borrowed\\n     * @param referralCode The referral code used\\n     **/\\n    event FlashLoan(\\n        address indexed target,\\n        address indexed initiator,\\n        address indexed asset,\\n        uint256 amount,\\n        uint256 premium,\\n        uint16 referralCode\\n    );\\n\\n    /**\\n     * @dev Emitted when the pause is triggered.\\n     */\\n    event Paused();\\n\\n    /**\\n     * @dev Emitted when the pause is lifted.\\n     */\\n    event Unpaused();\\n\\n    /**\\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\\n     * LendingPoolCollateral manager using a DELEGATECALL\\n     * This allows to have the events in the generated ABI for LendingPool.\\n     * @param collateralAsset The address of the underlying asset used as collateral,\\n     * to receive as result of the liquidation\\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the\\n     * liquidation\\n     * @param user The address of the borrower getting liquidated\\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\\n     * @param liquidator The address of the liquidator\\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens,\\n     * `false` if he wants\\n     * to receive the underlying collateral asset directly\\n     **/\\n    event LiquidationCall(\\n        address indexed collateralAsset,\\n        address indexed debtAsset,\\n        address indexed user,\\n        uint256 debtToCover,\\n        uint256 liquidatedCollateralAmount,\\n        address liquidator,\\n        bool receiveAToken\\n    );\\n\\n    /**\\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\\n     * in the ReserveLogic library and emitted in the updateInterestRates() function.\\n     * Since the function is internal, the event will actually be fired by the LendingPool contract.\\n     * The event is therefore replicated here so it\\n     * gets added to the LendingPool ABI\\n     * @param reserve The address of the underlying asset of the reserve\\n     * @param liquidityRate The new liquidity rate\\n     * @param stableBorrowRate The new stable borrow rate\\n     * @param variableBorrowRate The new variable borrow rate\\n     * @param liquidityIndex The new liquidity index\\n     * @param variableBorrowIndex The new variable borrow index\\n     **/\\n    event ReserveDataUpdated(\\n        address indexed reserve,\\n        uint256 liquidityRate,\\n        uint256 stableBorrowRate,\\n        uint256 variableBorrowRate,\\n        uint256 liquidityIndex,\\n        uint256 variableBorrowIndex\\n    );\\n\\n    /**\\n     * @dev Deposits an `amount` of underlying asset into the reserve,\\n     * receiving in return overlying aTokens.\\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n     * @param asset The address of the underlying asset to deposit\\n     * @param amount The amount to be deposited\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n     * wants to receive them on his own wallet,\\n     * or a different address if the beneficiary of aTokens\\n     *   is a different wallet\\n     * @param referralCode Code used to register the integrator originating the operation,\\n     * for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     **/\\n    function deposit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @dev Withdraws an `amount` of underlying asset from the reserve,\\n     * burning the equivalent aTokens owned\\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n     * @param asset The address of the underlying asset to withdraw\\n     * @param amount The underlying amount to be withdrawn\\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n     * @param to Address that will receive the underlying, same as msg.sender if the user\\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n     *   different wallet\\n     * @return The final amount withdrawn\\n     **/\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset,\\n     * provided that the borrower\\n     * already deposited enough collateral, or he was given enough allowance by a credit\\n     * delegator on the\\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address,\\n     * receiving the 100 USDC in his wallet\\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\n     * @param asset The address of the underlying asset to borrow\\n     * @param amount The amount to be borrowed\\n     * @param interestRateMode The interest rate mode at which the user wants to borrow:\\n     * - 1 for Stable,\\n     * - 2 for Variable\\n     * @param referralCode Code used to register the integrator originating the operation,\\n     * for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     * @param onBehalfOf Address of the user who will receive the debt.\\n     * Should be the address of the borrower itself\\n     * calling the function if he wants to borrow against his own collateral,\\n     * or the address of the credit delegator\\n     * if he has been given credit delegation allowance\\n     **/\\n    function borrow(\\n        address asset,\\n        uint256 amount,\\n        uint256 interestRateMode,\\n        uint16 referralCode,\\n        address onBehalfOf\\n    ) external;\\n\\n    /**\\n     * @notice Repays a borrowed `amount` on a specific reserve,\\n     * burning the equivalent debt tokens owned\\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt\\n     * tokens of the `onBehalfOf` address\\n     * @param asset The address of the borrowed underlying asset previously borrowed\\n     * @param amount The amount to repay\\n     * - Send the value type(uint256).max in order to repay the whole debt\\n     * for `asset` on the specific `debtMode`\\n     * @param rateMode The interest rate mode at of the debt the user wants to repay:\\n     * - 1 for Stable,\\n     * - 2 for Variable\\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed.\\n     * Should be the address of the user calling the function\\n     * if he wants to reduce/remove his own debt, or the address of any other\\n     * other borrower whose debt should be removed\\n     * @return The final amount repaid\\n     **/\\n    function repay(\\n        address asset,\\n        uint256 amount,\\n        uint256 rateMode,\\n        address onBehalfOf\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\\n     * @param asset The address of the underlying asset borrowed\\n     * @param rateMode The rate mode that the user wants to swap to\\n     **/\\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\\n\\n    /**\\n     * @dev Rebalances the stable interest rate of a user to\\n     * the current stable rate defined on the reserve.\\n     * - Users can be rebalanced if the following conditions are satisfied:\\n     *     1. Usage ratio is above 95%\\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate,\\n     *        which means that too much has been\\n     *        borrowed at a stable rate and depositors are not earning enough\\n     * @param asset The address of the underlying asset borrowed\\n     * @param user The address of the user to be rebalanced\\n     **/\\n    function rebalanceStableBorrowRate(address asset, address user) external;\\n\\n    /**\\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\\n     * @param asset The address of the underlying asset deposited\\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral,\\n     * `false` otherwise\\n     **/\\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\\n        external;\\n\\n    /**\\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\n     * - The caller (liquidator) covers `debtToCover` amount of debt\\n     * of the user getting liquidated, and receives\\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\n     * @param collateralAsset The address of the underlying asset used as collateral,\\n     * to receive as result of the liquidation\\n     * @param debtAsset The address of the underlying borrowed asset\\n     * to be repaid with the liquidation\\n     * @param user The address of the borrower getting liquidated\\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens,\\n     * `false` if he wants\\n     * to receive the underlying collateral asset directly\\n     **/\\n    function liquidationCall(\\n        address collateralAsset,\\n        address debtAsset,\\n        address user,\\n        uint256 debtToCover,\\n        bool receiveAToken\\n    ) external;\\n\\n    /**\\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\\n     * as long as the amount taken plus a fee is returned.\\n     * IMPORTANT There are security concerns for developers\\n     * of flashloan receiver contracts that must be kept into consideration.\\n     * For further details please visit https://developers.aave.com\\n     * @param receiverAddress The address of the contract receiving the funds,\\n     * implementing the IFlashLoanReceiver interface\\n     * @param assets The addresses of the assets being flash-borrowed\\n     * @param amounts The amounts amounts being flash-borrowed\\n     * @param modes Types of the debt to open if the flash loan is not returned:\\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\\n     *   1 -> Open debt at stable rate for the value of the amount\\n     *        flash-borrowed to the `onBehalfOf` address\\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed\\n     *        to the `onBehalfOf` address\\n     * @param onBehalfOf The address  that will receive the debt in\\n     * the case of using on `modes` 1 or 2\\n     * @param params Variadic packed params to pass to the receiver as extra information\\n     * @param referralCode Code used to register the integrator originating the operation,\\n     * for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     **/\\n    function flashLoan(\\n        address receiverAddress,\\n        address[] calldata assets,\\n        uint256[] calldata amounts,\\n        uint256[] calldata modes,\\n        address onBehalfOf,\\n        bytes calldata params,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @dev Returns the user account data across all the reserves\\n     * @param user The address of the user\\n     * @return totalCollateralETH the total collateral in ETH of the user\\n     * @return totalDebtETH the total debt in ETH of the user\\n     * @return availableBorrowsETH the borrowing power left of the user\\n     * @return currentLiquidationThreshold the liquidation threshold of the user\\n     * @return ltv the loan to value of the user\\n     * @return healthFactor the current health factor of the user\\n     **/\\n    function getUserAccountData(address user)\\n        external\\n        view\\n        returns (\\n            uint256 totalCollateralETH,\\n            uint256 totalDebtETH,\\n            uint256 availableBorrowsETH,\\n            uint256 currentLiquidationThreshold,\\n            uint256 ltv,\\n            uint256 healthFactor\\n        );\\n\\n    function initReserve(\\n        address reserve,\\n        address aTokenAddress,\\n        address stableDebtAddress,\\n        address variableDebtAddress,\\n        address interestRateStrategyAddress\\n    ) external;\\n\\n    function setReserveInterestRateStrategyAddress(\\n        address reserve,\\n        address rateStrategyAddress\\n    ) external;\\n\\n    function setConfiguration(address reserve, uint256 configuration) external;\\n\\n    /**\\n     * @dev Returns the configuration of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The configuration of the reserve\\n     **/\\n    function getConfiguration(address asset)\\n        external\\n        view\\n        returns (DataTypes.ReserveConfigurationMap memory);\\n\\n    /**\\n     * @dev Returns the configuration of the user across all the reserves\\n     * @param user The user address\\n     * @return The configuration of the user\\n     **/\\n    function getUserConfiguration(address user)\\n        external\\n        view\\n        returns (DataTypes.UserConfigurationMap memory);\\n\\n    /**\\n     * @dev Returns the normalized income normalized income of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The reserve's normalized income\\n     */\\n    function getReserveNormalizedIncome(address asset)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Returns the normalized variable debt per unit of asset\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The reserve normalized variable debt\\n     */\\n    function getReserveNormalizedVariableDebt(address asset)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Returns the state and configuration of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The state of the reserve\\n     **/\\n    function getReserveData(address asset)\\n        external\\n        view\\n        returns (DataTypes.ReserveData memory);\\n\\n    function finalizeTransfer(\\n        address asset,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 balanceFromAfter,\\n        uint256 balanceToBefore\\n    ) external;\\n\\n    function getReservesList() external view returns (address[] memory);\\n\\n    function getAddressesProvider()\\n        external\\n        view\\n        returns (ILendingPoolAddressesProvider);\\n\\n    function setPause(bool val) external;\\n\\n    function paused() external view returns (bool);\\n\\n    /// solhint-disable-next-line func-name-mixedcase\\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/ILendingPoolAddressesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\n/**\\n * @title LendingPoolAddressesProvider contract\\n * @dev Main registry of addresses part of or connected to the protocol,\\n * including permissioned roles\\n * - Acting also as factory of proxies and admin of those,\\n *   so with right to change its implementations\\n * - Owned by the Aave Governance\\n * @author Aave\\n **/\\ninterface ILendingPoolAddressesProvider {\\n    event MarketIdSet(string newMarketId);\\n    event LendingPoolUpdated(address indexed newAddress);\\n    event ConfigurationAdminUpdated(address indexed newAddress);\\n    event EmergencyAdminUpdated(address indexed newAddress);\\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\\n    event PriceOracleUpdated(address indexed newAddress);\\n    event LendingRateOracleUpdated(address indexed newAddress);\\n    event ProxyCreated(bytes32 id, address indexed newAddress);\\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\\n\\n    function getMarketId() external view returns (string memory);\\n\\n    function setMarketId(string calldata marketId) external;\\n\\n    function setAddress(bytes32 id, address newAddress) external;\\n\\n    function setAddressAsProxy(bytes32 id, address impl) external;\\n\\n    function getAddress(bytes32 id) external view returns (address);\\n\\n    function getLendingPool() external view returns (address);\\n\\n    function setLendingPoolImpl(address pool) external;\\n\\n    function getLendingPoolConfigurator() external view returns (address);\\n\\n    function setLendingPoolConfiguratorImpl(address configurator) external;\\n\\n    function getLendingPoolCollateralManager() external view returns (address);\\n\\n    function setLendingPoolCollateralManager(address manager) external;\\n\\n    function getPoolAdmin() external view returns (address);\\n\\n    function setPoolAdmin(address admin) external;\\n\\n    function getEmergencyAdmin() external view returns (address);\\n\\n    function setEmergencyAdmin(address admin) external;\\n\\n    function getPriceOracle() external view returns (address);\\n\\n    function setPriceOracle(address priceOracle) external;\\n\\n    function getLendingRateOracle() external view returns (address);\\n\\n    function setLendingRateOracle(address lendingRateOracle) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ninterface IPriceOracle {\\n    function getAssetPrice(address _asset) external view returns (uint256);\\n\\n    function getAssetsPrices(address[] calldata _assets)\\n        external\\n        view\\n        returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/aave/IProtocolDataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ninterface IProtocolDataProvider {\\n    function getReserveConfigurationData(address asset)\\n        external\\n        view\\n        returns (\\n            uint256 decimals,\\n            uint256 ltv,\\n            uint256 liquidationThreshold,\\n            uint256 liquidationBonus,\\n            uint256 reserveFactor,\\n            bool usageAsCollateralEnabled,\\n            bool borrowingEnabled,\\n            bool stableBorrowRateEnabled,\\n            bool isActive,\\n            bool isFrozen\\n        );\\n\\n    function getUserReserveData(address asset, address user)\\n        external\\n        view\\n        returns (\\n            uint256 currentATokenBalance,\\n            uint256 currentStableDebt,\\n            uint256 currentVariableDebt,\\n            uint256 principalStableDebt,\\n            uint256 scaledVariableDebt,\\n            uint256 stableBorrowRate,\\n            uint256 liquidityRate,\\n            uint40 stableRateLastUpdated,\\n            bool usageAsCollateralEnabled\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/services/actions/IAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ninterface IAction {\\n    function exec(\\n        bytes32 _taskHash,\\n        bytes memory _data,\\n        bytes memory _offChainData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/services/actions/IProtectionAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {IAction} from \\\"./IAction.sol\\\";\\n\\ninterface IProtectionAction is IAction {\\n    /// sohint-disable-next-line func-name-mixedcase\\n    function slippageInBps() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/GelatoString.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: UNLICENSED\\\"\\npragma solidity 0.8.7;\\n\\nlibrary GelatoString {\\n    function startsWithOK(string memory _str) internal pure returns (bool) {\\n        if (\\n            bytes(_str).length >= 2 &&\\n            bytes(_str)[0] == \\\"O\\\" &&\\n            bytes(_str)[1] == \\\"K\\\"\\n        ) return true;\\n        return false;\\n    }\\n\\n    function revertWithInfo(string memory _error, string memory _tracingInfo)\\n        internal\\n        pure\\n    {\\n        revert(string(abi.encodePacked(_tracingInfo, _error)));\\n    }\\n\\n    function prefix(string memory _second, string memory _first)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(_first, _second));\\n    }\\n\\n    function suffix(string memory _first, string memory _second)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(_first, _second));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/services/aave/resolver/ProtectionResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport {GelatoString} from \\\"../../../lib/GelatoString.sol\\\";\\nimport {ILendingPool} from \\\"../../../interfaces/aave/ILendingPool.sol\\\";\\nimport {\\n    ILendingPoolAddressesProvider\\n} from \\\"../../../interfaces/aave/ILendingPoolAddressesProvider.sol\\\";\\nimport {\\n    IProtocolDataProvider\\n} from \\\"../../../interfaces/aave/IProtocolDataProvider.sol\\\";\\nimport {\\n    IProtectionAction\\n} from \\\"../../../interfaces/services/actions/IProtectionAction.sol\\\";\\nimport {\\n    LENDINGPOOL,\\n    LENDINGPOOL_ADDRESSES_PROVIDER,\\n    PROTOCOL_DATA_PROVIDER\\n} from \\\"../../../constants/CAave.sol\\\";\\nimport {OK} from \\\"../../../constants/CAaveServices.sol\\\";\\nimport {\\n    RepayAndFlashBorrowData,\\n    RepayAndFlashBorrowResult,\\n    CanExecResult,\\n    CanExecData\\n} from \\\"../../../structs/SProtection.sol\\\";\\nimport {_getRepayAndFlashBorrowAmt} from \\\"../../../functions/FProtection.sol\\\";\\nimport {\\n    _isPositionUnsafe,\\n    _isAllowed\\n} from \\\"../../../functions/FProtectionResolver.sol\\\";\\n\\ncontract ProtectionResolver {\\n    using GelatoString for string;\\n    IProtectionAction public immutable protectionAction;\\n\\n    constructor(IProtectionAction _protectionAction) {\\n        protectionAction = _protectionAction;\\n    }\\n\\n    function multiRepayAndFlashBorrowAmt(\\n        RepayAndFlashBorrowData[] calldata _listRAndWAmt\\n    ) external view returns (RepayAndFlashBorrowResult[] memory) {\\n        RepayAndFlashBorrowResult[]\\n            memory results = new RepayAndFlashBorrowResult[](\\n                _listRAndWAmt.length\\n            );\\n\\n        for (uint256 i = 0; i < _listRAndWAmt.length; i++) {\\n            try this.getRepayAndFlashBorrowAmt(_listRAndWAmt[i]) returns (\\n                RepayAndFlashBorrowResult memory rAndWResult\\n            ) {\\n                results[i] = rAndWResult;\\n            } catch Error(string memory error) {\\n                results[i] = RepayAndFlashBorrowResult({\\n                    id: _listRAndWAmt[i].id,\\n                    amtToFlashBorrow: 0,\\n                    amtOfDebtToRepay: 0,\\n                    message: error.prefix(\\n                        \\\"ProtectionResolver.getRepayAndFlashBorrowAmt failed:\\\"\\n                    )\\n                });\\n            } catch {\\n                results[i] = RepayAndFlashBorrowResult({\\n                    id: _listRAndWAmt[i].id,\\n                    amtToFlashBorrow: 0,\\n                    amtOfDebtToRepay: 0,\\n                    message: \\\"ProtectionResolver.getRepayAndFlashBorrowAmt failed:undefined\\\"\\n                });\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\n    // solhint-disable-next-line function-max-lines\\n    function getRepayAndFlashBorrowAmt(\\n        RepayAndFlashBorrowData calldata _rAndWAmtData\\n    ) external view returns (RepayAndFlashBorrowResult memory) {\\n        return\\n            _getRepayAndFlashBorrowAmt(\\n                _rAndWAmtData,\\n                ILendingPool(LENDINGPOOL),\\n                ILendingPoolAddressesProvider(LENDINGPOOL_ADDRESSES_PROVIDER)\\n            );\\n    }\\n\\n    function multiCanExecute(CanExecData[] calldata _canExecDatas)\\n        external\\n        view\\n        returns (CanExecResult[] memory)\\n    {\\n        CanExecResult[] memory results = new CanExecResult[](\\n            _canExecDatas.length\\n        );\\n\\n        for (uint256 i = 0; i < _canExecDatas.length; i++) {\\n            try this.canExecute(_canExecDatas[i]) returns (\\n                CanExecResult memory canExecResult\\n            ) {\\n                results[i] = canExecResult;\\n            } catch Error(string memory error) {\\n                results[i] = CanExecResult({\\n                    id: _canExecDatas[i].id,\\n                    isPositionUnSafe: false,\\n                    isATokenAllowed: false,\\n                    message: error.prefix(\\n                        \\\"ProtectionResolver.canExecute failed:\\\"\\n                    )\\n                });\\n            } catch {\\n                results[i] = CanExecResult({\\n                    id: _canExecDatas[i].id,\\n                    isPositionUnSafe: false,\\n                    isATokenAllowed: false,\\n                    message: \\\"ProtectionResolver.canExecute failed:undefined\\\"\\n                });\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\n    function canExecute(CanExecData calldata _canExecData)\\n        external\\n        view\\n        returns (CanExecResult memory result)\\n    {\\n        (uint256 currentATokenBalance, , , , , , , , ) = IProtocolDataProvider(\\n            PROTOCOL_DATA_PROVIDER\\n        ).getUserReserveData(_canExecData.colToken, _canExecData.user);\\n\\n        result.id = _canExecData.id;\\n        result.isPositionUnSafe = _isPositionUnsafe(\\n            _canExecData.user,\\n            _canExecData.minimumHF\\n        );\\n        result.isATokenAllowed = _isAllowed(\\n            ILendingPool(LENDINGPOOL)\\n                .getReserveData(_canExecData.colToken)\\n                .aTokenAddress,\\n            _canExecData.user,\\n            _canExecData.spender,\\n            currentATokenBalance\\n        );\\n        result.message = OK;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/structs/SAave.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\nlibrary DataTypes {\\n    // refer to the whitepaper,\\n    // section 1.1 basic concepts for a formal description of these properties.\\n    struct ReserveData {\\n        //stores the reserve configuration\\n        ReserveConfigurationMap configuration;\\n        //the liquidity index. Expressed in ray\\n        uint128 liquidityIndex;\\n        //variable borrow index. Expressed in ray\\n        uint128 variableBorrowIndex;\\n        //the current supply rate. Expressed in ray\\n        uint128 currentLiquidityRate;\\n        //the current variable borrow rate. Expressed in ray\\n        uint128 currentVariableBorrowRate;\\n        //the current stable borrow rate. Expressed in ray\\n        uint128 currentStableBorrowRate;\\n        uint40 lastUpdateTimestamp;\\n        //tokens addresses\\n        address aTokenAddress;\\n        address stableDebtTokenAddress;\\n        address variableDebtTokenAddress;\\n        //address of the interest rate strategy\\n        address interestRateStrategyAddress;\\n        //the id of the reserve. Represents the position in the list of the active reserves\\n        uint8 id;\\n    }\\n\\n    struct ReserveConfigurationMap {\\n        //bit 0-15: LTV\\n        //bit 16-31: Liq. threshold\\n        //bit 32-47: Liq. bonus\\n        //bit 48-55: Decimals\\n        //bit 56: Reserve is active\\n        //bit 57: reserve is frozen\\n        //bit 58: borrowing is enabled\\n        //bit 59: stable rate borrowing enabled\\n        //bit 60-63: reserved\\n        //bit 64-79: reserve factor\\n        uint256 data;\\n    }\\n\\n    struct UserConfigurationMap {\\n        uint256 data;\\n    }\\n\\n    enum InterestRateMode {\\n        NONE,\\n        STABLE,\\n        VARIABLE\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/structs/SProtection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.7;\\n\\nstruct ProtectionPayload {\\n    bytes32 taskHash;\\n    address colToken;\\n    address debtToken;\\n    uint256 rateMode;\\n    uint256 amtToFlashBorrow;\\n    uint256 amtOfDebtToRepay;\\n    uint256 minimumHealthFactor;\\n    uint256 wantedHealthFactor;\\n    address onBehalfOf;\\n    uint256 protectionFeeInETH;\\n    address[] swapActions;\\n    bytes[] swapDatas;\\n}\\n\\nstruct ExecutionData {\\n    address user;\\n    address action;\\n    uint256 subBlockNumber;\\n    bytes data;\\n    bytes offChainData;\\n    bool isPermanent;\\n}\\n\\nstruct ProtectionDataCompute {\\n    address colToken;\\n    address debtToken;\\n    uint256 totalCollateralETH;\\n    uint256 totalBorrowsETH;\\n    uint256 currentLiquidationThreshold;\\n    uint256 colLiquidationThreshold;\\n    uint256 wantedHealthFactor;\\n    uint256 colPrice;\\n    uint256 debtPrice;\\n    address onBehalfOf;\\n    uint256 protectionFeeInETH;\\n    uint256 flashloanPremiumBps;\\n}\\n\\nstruct FlashLoanData {\\n    address[] assets;\\n    uint256[] amounts;\\n    uint256[] premiums;\\n    bytes params;\\n}\\n\\nstruct FlashLoanParamsData {\\n    uint256 minimumHealthFactor;\\n    bytes32 taskHash;\\n    address debtToken;\\n    uint256 amtOfDebtToRepay;\\n    uint256 rateMode;\\n    address onBehalfOf;\\n    uint256 protectionFeeInETH;\\n    address[] swapActions;\\n    bytes[] swapDatas;\\n}\\n\\nstruct RepayAndFlashBorrowData {\\n    bytes32 id;\\n    address user;\\n    address colToken;\\n    address debtToken;\\n    uint256 wantedHealthFactor;\\n    uint256 protectionFeeInETH;\\n}\\n\\nstruct RepayAndFlashBorrowResult {\\n    bytes32 id;\\n    uint256 amtToFlashBorrow;\\n    uint256 amtOfDebtToRepay;\\n    string message;\\n}\\n\\nstruct CanExecData {\\n    bytes32 id;\\n    address user;\\n    uint256 minimumHF;\\n    address colToken;\\n    address spender;\\n}\\n\\nstruct CanExecResult {\\n    bytes32 id;\\n    bool isPositionUnSafe;\\n    bool isATokenAllowed;\\n    string message;\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/DSMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\n// solhint-disable\\nfunction _add(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n}\\n\\nfunction _sub(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n}\\n\\nfunction _mul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n}\\n\\nfunction _min(uint256 x, uint256 y) pure returns (uint256 z) {\\n    return x <= y ? x : y;\\n}\\n\\nfunction _max(uint256 x, uint256 y) pure returns (uint256 z) {\\n    return x >= y ? x : y;\\n}\\n\\nfunction _imin(int256 x, int256 y) pure returns (int256 z) {\\n    return x <= y ? x : y;\\n}\\n\\nfunction _imax(int256 x, int256 y) pure returns (int256 z) {\\n    return x >= y ? x : y;\\n}\\n\\nuint256 constant WAD = 10**18;\\nuint256 constant RAY = 10**27;\\nuint256 constant QUA = 10**4;\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction _wmul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, y), WAD / 2) / WAD;\\n}\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction _rmul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, y), RAY / 2) / RAY;\\n}\\n\\n//rounds to zero if x*y < WAD / 2\\nfunction _wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, WAD), y / 2) / y;\\n}\\n\\n//rounds to zero if x*y < RAY / 2\\nfunction _rdiv(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, RAY), y / 2) / y;\\n}\\n\\n// This famous algorithm is called \\\"exponentiation by squaring\\\"\\n// and calculates x^n with x as fixed-point and n as regular unsigned.\\n//\\n// It's O(log n), instead of O(n) for naive repeated multiplication.\\n//\\n// These facts are why it works:\\n//\\n//  If n is even, then x^n = (x^2)^(n/2).\\n//  If n is odd,  then x^n = x * x^(n-1),\\n//   and applying the equation for even x gives\\n//    x^n = x * (x^2)^((n-1) / 2).\\n//\\n//  Also, EVM division is flooring and\\n//    floor[(n-1) / 2] = floor[n / 2].\\n//\\nfunction _rpow(uint256 x, uint256 n) pure returns (uint256 z) {\\n    z = n % 2 != 0 ? x : RAY;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n        x = _rmul(x, x);\\n\\n        if (n % 2 != 0) {\\n            z = _rmul(z, x);\\n        }\\n    }\\n}\\n\\n//rounds to zero if x*y < QUA / 2\\nfunction _qmul(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, y), QUA / 2) / QUA;\\n}\\n\\n//rounds to zero if x*y < QUA / 2\\nfunction _qdiv(uint256 x, uint256 y) pure returns (uint256 z) {\\n    z = _add(_mul(x, QUA), y / 2) / y;\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IProtectionAction\",\"name\":\"_protectionAction\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumHF\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"colToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"internalType\":\"struct CanExecData\",\"name\":\"_canExecData\",\"type\":\"tuple\"}],\"name\":\"canExecute\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isPositionUnSafe\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isATokenAllowed\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"internalType\":\"struct CanExecResult\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"colToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"debtToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantedHealthFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protectionFeeInETH\",\"type\":\"uint256\"}],\"internalType\":\"struct RepayAndFlashBorrowData\",\"name\":\"_rAndWAmtData\",\"type\":\"tuple\"}],\"name\":\"getRepayAndFlashBorrowAmt\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amtToFlashBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amtOfDebtToRepay\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"internalType\":\"struct RepayAndFlashBorrowResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumHF\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"colToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"internalType\":\"struct CanExecData[]\",\"name\":\"_canExecDatas\",\"type\":\"tuple[]\"}],\"name\":\"multiCanExecute\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isPositionUnSafe\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isATokenAllowed\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"internalType\":\"struct CanExecResult[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"colToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"debtToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wantedHealthFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protectionFeeInETH\",\"type\":\"uint256\"}],\"internalType\":\"struct RepayAndFlashBorrowData[]\",\"name\":\"_listRAndWAmt\",\"type\":\"tuple[]\"}],\"name\":\"multiRepayAndFlashBorrowAmt\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amtToFlashBorrow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amtOfDebtToRepay\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"internalType\":\"struct RepayAndFlashBorrowResult[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protectionAction\",\"outputs\":[{\"internalType\":\"contract IProtectionAction\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ProtectionResolver","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"00000000000000000000000083c403ecc6393036d8e4e059ff18fabbc7c68c8f","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}