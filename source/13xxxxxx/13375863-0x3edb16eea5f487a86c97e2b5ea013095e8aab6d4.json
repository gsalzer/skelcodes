{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.8.0;\r\n\r\n// SPDX-License-Identifier: MIT\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract PropertySniper is Ownable {\r\n    // Structs for gas optimization\r\n    struct Subscription {\r\n        uint256 price;\r\n        uint256 time;\r\n    }\r\n\r\n    struct User {\r\n        uint256 end_of_subscription;\r\n    }\r\n\r\n    uint256 constant private DAY_SECONDS = 86400;\r\n    uint private currentPrice = 100;\r\n    address payable public treasury;\r\n    uint maxNumberOfUsers = 25;\r\n    uint whitelistCount;\r\n\r\n    mapping(address => User) private users;\r\n    mapping(address => bool) private whitelisted;\r\n    mapping(uint => Subscription) private subscriptionOptions;\r\n    address[] currentlySubscribedAddresses;\r\n    bool activeSale = false;\r\n    \r\n\r\n    constructor() {\r\n        subscriptionOptions[0] = Subscription(200000000000000000, 14 * DAY_SECONDS);\r\n        subscriptionOptions[1] = Subscription(350000000000000000, 30 * DAY_SECONDS);\r\n        subscriptionOptions[2] = Subscription(850000000000000000, 90 * DAY_SECONDS);\r\n        subscriptionOptions[3] = Subscription(2650000000000000000, 365 * DAY_SECONDS);\r\n    }\r\n\r\n    function setTreasury(address payable _treasury) external onlyOwner {\r\n        treasury = _treasury;\r\n    }\r\n\r\n    function setBasePrice(uint256 _index, uint256 _price) external onlyOwner {\r\n        subscriptionOptions[_index].price = _price;\r\n    }\r\n\r\n    function getSubscriptionLength(uint256 _index) external view returns(uint256) {\r\n        return subscriptionOptions[_index].time;\r\n    }\r\n\r\n    function setSubscriptionLength(uint256 _index, uint256 _timeInDays) external onlyOwner {\r\n        subscriptionOptions[_index].time = _timeInDays * DAY_SECONDS;\r\n    }\r\n\r\n    function subscribe(address payable _referrer, uint256 _subscriptionIndex) external payable {\r\n        require(treasury != address(0), \"Treasury not set yet.\");\r\n        require(subscriptionOptions[_subscriptionIndex].price * currentPrice / 100 == msg.value, \"Incorrect Ether value.\");\r\n        require(activeSale, \"Sale is not active. Check Discord or Twitter for updates.\");\r\n        \r\n        if(!whitelisted[msg.sender]) {\r\n            require(updateAndReturnNumberOfSubscribers() < maxNumberOfUsers, \"Max number of users reached.\");\r\n        }\r\n        \r\n        User storage user = users[msg.sender];\r\n\r\n        if (user.end_of_subscription == 0) {\r\n            users[msg.sender] = User(block.timestamp + subscriptionOptions[_subscriptionIndex].time);\r\n            whitelistCount++;\r\n            currentlySubscribedAddresses.push(msg.sender);\r\n        } else if (getTimeUntilSubscriptionExpired(msg.sender) <= 0) {\r\n            user.end_of_subscription = block.timestamp + subscriptionOptions[_subscriptionIndex].time;\r\n            whitelistCount++;\r\n            currentlySubscribedAddresses.push(msg.sender);\r\n        } else {\r\n            user.end_of_subscription += subscriptionOptions[_subscriptionIndex].time;\r\n        }\r\n\r\n        // Whitelist the user\r\n        whitelisted[msg.sender] = true;\r\n\r\n        // Never hold Ether in the contract. Directly transfer 5% to the referrer, 95% to the treasury wallet.\r\n        if (_referrer == address(0)) {\r\n            treasury.transfer(msg.value);\r\n        } else {\r\n            _referrer.transfer(msg.value * 5 / 100);\r\n            treasury.transfer(msg.value * 95 / 100);\r\n        }\r\n    }\r\n\r\n    function getAllSubscriptionPlans() external view returns(Subscription[] memory) {\r\n        Subscription[] memory subscriptionArray = new Subscription[](4);\r\n        for(uint i = 0; i < 4; i++) {\r\n            subscriptionArray[i] = subscriptionOptions[i];\r\n        }\r\n        return subscriptionArray;\r\n    }\r\n\r\n    function discount(uint _amountAsAPercent) external onlyOwner {\r\n        currentPrice = 100 - _amountAsAPercent;\r\n    }\r\n    \r\n    function getCurrentPrice() internal view returns(uint) {\r\n        return currentPrice;\r\n    }\r\n    \r\n    function getSubscriptionPlanPrice(uint _index) external view returns(uint256) {\r\n        return subscriptionOptions[_index].price * currentPrice / 100;\r\n    }\r\n\r\n    function setMaxNumberOfUsers(uint _numberOfUsers) external onlyOwner {\r\n        maxNumberOfUsers = _numberOfUsers;\r\n    }\r\n    \r\n    function getMaxNumberOfUsers() external view returns(uint) {\r\n        return maxNumberOfUsers;\r\n    }\r\n    \r\n    function addUserToWhitelist(address _address, uint _subscriptionLengthInSeconds) external onlyOwner {\r\n        // Add or overwrite key value pair\r\n        if (block.timestamp <= users[_address].end_of_subscription) {\r\n            users[_address].end_of_subscription += _subscriptionLengthInSeconds;\r\n        } else if (users[_address].end_of_subscription != 0){\r\n            users[_address].end_of_subscription = block.timestamp + _subscriptionLengthInSeconds;\r\n        } else {\r\n            users[_address] = User(block.timestamp + _subscriptionLengthInSeconds);\r\n        }\r\n        currentlySubscribedAddresses.push(_address);\r\n        whitelisted[_address] = true;\r\n        whitelistCount++;\r\n    }\r\n    \r\n    function getTimeUntilSubscriptionExpired(address _address) public view returns(int256) {\r\n        return int256(users[_address].end_of_subscription) - int256(block.timestamp);\r\n    }\r\n    \r\n    function updateAndReturnNumberOfSubscribers() public returns(uint) {\r\n        uint index = 0;\r\n        while (index < currentlySubscribedAddresses.length) {\r\n            while (index < currentlySubscribedAddresses.length && getTimeUntilSubscriptionExpired(currentlySubscribedAddresses[index]) <= 0) {\r\n                efficientRemove(index);\r\n            }\r\n            index++;\r\n        }\r\n        return currentlySubscribedAddresses.length;\r\n    }\r\n    \r\n    function efficientRemove(uint _index) internal {\r\n        require(_index < currentlySubscribedAddresses.length);\r\n        users[currentlySubscribedAddresses[_index]].end_of_subscription = 0;\r\n        whitelisted[currentlySubscribedAddresses[_index]] = false;\r\n        currentlySubscribedAddresses[_index] = currentlySubscribedAddresses[currentlySubscribedAddresses.length - 1];\r\n        currentlySubscribedAddresses.pop();\r\n        whitelistCount--;\r\n    }\r\n    \r\n    function getWhitelistedAddresses() external view returns(address[] memory) {\r\n        return currentlySubscribedAddresses;\r\n    }\r\n    \r\n    function removeAddressFromWhitelist(address _address) external onlyOwner {\r\n        for (uint i = 0; i < currentlySubscribedAddresses.length; i++) {\r\n            if (currentlySubscribedAddresses[i] == _address) {\r\n                efficientRemove(i);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getActiveSale() external view returns(bool) {\r\n        return activeSale;\r\n    }\r\n    \r\n    function setActiveSale(bool _activeSale) external onlyOwner {\r\n        activeSale = _activeSale;\r\n    }\r\n\r\n    function getNumberOfWhitelistedUsers() external view returns(uint) {\r\n        return whitelistCount;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subscriptionLengthInSeconds\",\"type\":\"uint256\"}],\"name\":\"addUserToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountAsAPercent\",\"type\":\"uint256\"}],\"name\":\"discount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllSubscriptionPlans\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct PropertySniper.Subscription[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxNumberOfUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfWhitelistedUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getSubscriptionLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getSubscriptionPlanPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTimeUntilSubscriptionExpired\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhitelistedAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_activeSale\",\"type\":\"bool\"}],\"name\":\"setActiveSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setBasePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfUsers\",\"type\":\"uint256\"}],\"name\":\"setMaxNumberOfUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeInDays\",\"type\":\"uint256\"}],\"name\":\"setSubscriptionLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subscriptionIndex\",\"type\":\"uint256\"}],\"name\":\"subscribe\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateAndReturnNumberOfSubscribers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PropertySniper","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://305ffcab8ad77c8afd8ff094d11d40772cd4e078d139f10f67e8b0e462ef05bb"}]}