{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/solvers/MultiWing4D.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 David Huber (@cxkoda)\\n// All Rights Reserved\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"./AttractorSolver4D.sol\\\";\\n\\n/**\\n * @notice Pure-Solidity, numerical solution of chaotic, four-dimensional\\n * Huang system with multiple wings of differential equations.\\n * @dev This implements all the necessary algorithms needed for the numerical\\n * treatment of the equations and the 2D projection of the data. See also\\n * `IAttractorSolver` and `AttractorSolver` for more context.\\n * @author David Huber (@cxkoda)\\n */\\ncontract MultiWing4D is AttractorSolver4D {\\n    /**\\n     * @notice The parameters of the dynamical system and some handy constants.\\n     * @dev Unfortunately, we have to write them out to be usable in inline\\n     * assembly. The occasionally added, negligible term is to make the number\\n     * dividable without rest - otherwise there will be conversion issues.\\n     */\\n    int256 private constant ALPHA = 6 * 2**96;\\n    int256 private constant BETA = 11 * 2**96;\\n    int256 private constant GAMMA = 5 * 2**96;\\n\\n    // -------------------------\\n    //\\n    //  Base Interface\\n    //\\n    // -------------------------\\n\\n    /**\\n     * @notice See `IAttractorSolver.getSystemType`.\\n     */\\n    function getSystemType() public pure override returns (string memory) {\\n        return \\\"Huang Multi-Wing\\\";\\n    }\\n\\n    /**\\n     * @notice See `IAttractorSolver.getSystemType`.\\n     * @dev The random range was manually tuned such that the system consistenly\\n     * reaches the attractor.\\n     */\\n    function getRandomStartingPoint(uint256 randomSeed)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (StartingPoint memory startingPoint)\\n    {\\n        startingPoint.startingPoint = new int256[](DIM);\\n        int256 randNumber;\\n        int256 unperturbed = 10 * ONE;\\n        int256 range = 1 * ONE;\\n\\n        (randomSeed, randNumber) = _random(randomSeed, range);\\n        startingPoint.startingPoint[0] = unperturbed + randNumber;\\n\\n        (randomSeed, randNumber) = _random(randomSeed, range);\\n        startingPoint.startingPoint[1] = unperturbed + randNumber;\\n\\n        (randomSeed, randNumber) = _random(randomSeed, range);\\n        startingPoint.startingPoint[2] = randNumber;\\n\\n        (randomSeed, randNumber) = _random(randomSeed, range);\\n        startingPoint.startingPoint[3] = randNumber;\\n    }\\n\\n    /**\\n     * @notice See `AttractorSolver3D._getDefaultProjectionScale`.\\n     */\\n    function _getDefaultProjectionScale()\\n        internal\\n        pure\\n        override\\n        returns (int256)\\n    {\\n        return 27*ONE/10;\\n    }\\n\\n    /**\\n     * @notice See `AttractorSolver3D._getDefaultProjectionOffset`.\\n     */\\n    function _getDefaultProjectionOffset()\\n        internal\\n        pure\\n        override\\n        returns (int256[] memory offset)\\n    {\\n        offset = new int256[](DIM);\\n    }\\n\\n    // -------------------------\\n    //\\n    //  Number Crunching\\n    //\\n    // -------------------------\\n\\n    /**\\n     * @dev The following the heart-piece of every attractor solver.\\n     * Here the system of ODEs (in the form `u' = f(u)`) will be solved\\n     * numerically using the explicit, classical Runge-Kutta 4 method (aka RK4).\\n     * Such a high order scheme is needed to maintain numerical stability while\\n     * reducing the amount of timesteps needed to obtain a solution for the\\n     * considered systems. Before storing the results, points and tangents are\\n     * projected to 2D.\\n     * Warning: The returns are given as fixed-point numbers with reduced\\n     * precision (6) and width (16 bit). See `AttractorSolution` and\\n     * `AttractorSolver`.\\n     * @return points contains every `skip` point of the numerical solution. It\\n     * includes the starting point at the first position.\\n     * @return tangents contains the tangents (i.e. the ODEs RHS) at the\\n     * position of `points`.\\n     */\\n    function _solve(\\n        SolverParameters memory solverParameters,\\n        StartingPoint4D memory startingPoint,\\n        ProjectionParameters4D memory projectionParameters\\n    )\\n        internal\\n        pure\\n        override\\n        returns (bytes memory points, bytes memory tangents)\\n    {\\n        // Some handy aliases\\n        uint256 numberOfIterations = solverParameters.numberOfIterations;\\n        uint256 dt = solverParameters.dt;\\n        uint8 skip = solverParameters.skip;\\n\\n        assembly {\\n            // Allocate space for the results\\n            // 2 bytes (16-bit) * 2 coordinates * amount of pairs in storage\\n            let length := mul(4, add(1, div(numberOfIterations, skip)))\\n\\n            function allocate(size_) -> ptr {\\n                // Get free memory pointer\\n                ptr := mload(0x40)\\n                // Set allocation length\\n                mstore(ptr, size_)\\n\\n                // Actually allocate 2 * 32B more:\\n                // Dynamic array length info (32B) and some free buffer space at\\n                // the end (such that we can safely write over array boundaries)\\n                mstore(0x40, add(ptr, add(size_, 0x40)))\\n            }\\n            points := allocate(length)\\n            tangents := allocate(length)\\n        }\\n\\n        // Temporary space to store the current point and tangent\\n        int256[DIM] memory point = startingPoint.startingPoint;\\n        int256[DIM] memory tangent;\\n\\n        // Temporary space for the weighted sum of intermediate RHS evaluations\\n        // needed for Runge-Kutta schemes.\\n        int256[DIM] memory rhsSum;\\n\\n        // Parental Advisory: Explicit Yul Content\\n        // You and people around you may be exposed to content that you find\\n        // objectionable and/or offensive.\\n        // All stunts were performed by trained professionals, don't try this\\n        // at home. The producer of this code is not responsible for any\\n        // personal injury or damage.\\n        assembly {\\n            /**\\n             * @notice Reduce accuracy and range of number and stores it in a\\n             * buffer.\\n             * @dev Used to store simulation results in `points` and `tangents`\\n             *  as pairs of 16-bit numbers in row-major order. See also\\n             * `AttractorSolution`.\\n             */\\n            function storeData(bufferPos_, x_, y_) -> newBufferPos {\\n                // First we reduce the accuracy of the x coordinate for storing.\\n                // This not necessary for y because we will overwrite the extra\\n                // bits later anyways.\\n                x_ := sar(PRECISION_REDUCTION_SAR, x_)\\n\\n                // Stack both numbers together, shift them all the way\\n                // to the left and write them to the buffer directly as 32B\\n                // chunks to save gas.\\n                // Because this operation could easily write over buffer\\n                // bounds, we added some extra space at the end earlier.\\n                mstore(\\n                    bufferPos_,\\n                    or(shl(240, x_), shr(16, shl(RANGE_REDUCTION_SHL, y_)))\\n                )\\n\\n                newBufferPos := add(bufferPos_, 4)\\n            }\\n\\n            /**\\n             * @notice Compute the projected x-coordinate of a 3D point.\\n             * @dev It implements the linear algebra calculation\\n             * `parameters_.axis1 * (point_ - parameters_.offset)`,\\n             * with `*` being the scalar product.\\n             */\\n            function projectPointX(point_, parameters_) -> x {\\n                let axis1 := mload(parameters_)\\n                let offset_ := mload(add(parameters_, 0x40))\\n                {\\n                    let component := sub(mload(point_), mload(offset_))\\n                    x := mul(component, mload(axis1))\\n                }\\n                {\\n                    let component := sub(\\n                        mload(add(point_, 0x20)),\\n                        mload(add(offset_, 0x20))\\n                    )\\n                    x := add(x, mul(component, mload(add(axis1, 0x20))))\\n                }\\n                {\\n                    let component := sub(\\n                        mload(add(point_, 0x40)),\\n                        mload(add(offset_, 0x40))\\n                    )\\n                    x := add(x, mul(component, mload(add(axis1, 0x40))))\\n                }\\n                {\\n                    let component := sub(\\n                        mload(add(point_, 0x60)),\\n                        mload(add(offset_, 0x60))\\n                    )\\n                    x := add(x, mul(component, mload(add(axis1, 0x60))))\\n                }\\n                x := sar(PRECISION, x)\\n            }\\n\\n            /**\\n             * @notice Compute the projected y-coordinate of a 3D point.\\n             * @dev It implements the linear algebra calculation\\n             * `parameters_.axis2 * (point_ - parameters_.offset)`,\\n             * with `*` being the scalar product.\\n             */\\n            function projectPointY(point_, parameters_) -> y {\\n                let axis2 := mload(add(parameters_, 0x20))\\n                let offset_ := mload(add(parameters_, 0x40))\\n                {\\n                    let component := sub(mload(point_), mload(offset_))\\n                    y := mul(component, mload(axis2))\\n                }\\n                {\\n                    let component := sub(\\n                        mload(add(point_, 0x20)),\\n                        mload(add(offset_, 0x20))\\n                    )\\n                    y := add(y, mul(component, mload(add(axis2, 0x20))))\\n                }\\n                {\\n                    let component := sub(\\n                        mload(add(point_, 0x40)),\\n                        mload(add(offset_, 0x40))\\n                    )\\n                    y := add(y, mul(component, mload(add(axis2, 0x40))))\\n                }\\n                {\\n                    let component := sub(\\n                        mload(add(point_, 0x60)),\\n                        mload(add(offset_, 0x60))\\n                    )\\n                    y := add(y, mul(component, mload(add(axis2, 0x60))))\\n                }\\n                y := sar(PRECISION, y)\\n            }\\n\\n            /**\\n             * @notice Compute the projected x-coordinate of a 3D tangent.\\n             * @dev It implements the linear algebra calculation\\n             * `parameters_.axis1 * point_`, with `*` being the scalar product.\\n             * The offset must not to be considered for directions.\\n             */\\n            function projectDirectionX(direction, parameters_) -> x {\\n                let axis1 := mload(parameters_)\\n                let offset_ := mload(add(parameters_, 0x40))\\n                x := mul(mload(direction), mload(axis1))\\n                x := add(\\n                    x,\\n                    mul(mload(add(direction, 0x20)), mload(add(axis1, 0x20)))\\n                )\\n                x := add(\\n                    x,\\n                    mul(mload(add(direction, 0x40)), mload(add(axis1, 0x40)))\\n                )\\n                x := add(\\n                    x,\\n                    mul(mload(add(direction, 0x60)), mload(add(axis1, 0x60)))\\n                )\\n                x := sar(PRECISION, x)\\n            }\\n\\n            /**\\n             * @notice Compute the projected y-coordinate of a 3D tangent.\\n             * @dev It implements the linear algebra calculation\\n             * `parameters_.axis2 * point_`, with `*` being the scalar product.\\n             * The offset must not to be considered for directions.\\n             */\\n            function projectDirectionY(direction, parameters_) -> y {\\n                let axis2 := mload(add(parameters_, 0x20))\\n                let offset_ := mload(add(parameters_, 0x40))\\n                y := mul(mload(direction), mload(axis2))\\n                y := add(\\n                    y,\\n                    mul(mload(add(direction, 0x20)), mload(add(axis2, 0x20)))\\n                )\\n                y := add(\\n                    y,\\n                    mul(mload(add(direction, 0x40)), mload(add(axis2, 0x40)))\\n                )\\n                y := add(\\n                    y,\\n                    mul(mload(add(direction, 0x60)), mload(add(axis2, 0x60)))\\n                )\\n                y := sar(PRECISION, y)\\n            }\\n\\n            // -------------------------\\n            //\\n            //  The actual work\\n            //\\n            // -------------------------\\n\\n            // Store the starting point\\n            {\\n                let x := projectPointX(point, projectionParameters)\\n                let y := projectPointY(point, projectionParameters)\\n                let tmp := storeData(add(points, 0x20), x, y)\\n            }\\n\\n            // Rolling pointers to the current location in the output buffers\\n            let posPoints := add(points, 0x24)\\n            let posTangents := add(tangents, 0x20)\\n\\n            // Loop over the amount of timesteps that need to be done\\n            for {\\n                let iter := 0\\n            } lt(iter, numberOfIterations) {\\n                iter := add(iter, 1)\\n            } {\\n                // The following updates the system's state by performing\\n                // as single time step according to the RK4 scheme. It is\\n                // generally used to solve systems of ODEs in the form of\\n                // `u' = f(u)`, where `f` is aka right-hand-side (rhs).\\n                //\\n                // The scheme can be summarized as follows:\\n                // rhs0 = f(uOld)\\n                // rhs1 = f(uOld + dt/2 * rhs0)\\n                // rhs2 = f(uOld + dt/2 * rhs1)\\n                // rhs3 = f(uOld + dt * rhs2)\\n                // rhsSum = rhs0 + 2 * rhs1 + 2 * rhs2 + rhs3\\n                // uNew = uOld + dt/6 * rhsSum\\n                //\\n                // A lot of code is repeatedly inlined for better efficiency.\\n                {\\n                    // Compute intermediate steps and weighted rhs sum\\n                    {\\n                        let dxdt\\n                        let dydt\\n                        let dzdt\\n                        let dwdt\\n\\n                        // RK4 intermediate step 0\\n                        {\\n                            // Load the current point aka `uOld`.\\n                            let x := mload(point)\\n                            let y := mload(add(point, 0x20))\\n                            let z := mload(add(point, 0x40))\\n                            let w := mload(add(point, 0x60))\\n\\n                            // Compute the rhs for the current intermediate step\\n                            // x' = a (y - x)\\n                            dxdt := sar(PRECISION, mul(ALPHA, sub(y, x)))\\n                            // y' = w + x z\\n                            dydt := add(w, sar(PRECISION, mul(x, z)))\\n                            // z' = b - x y\\n                            dzdt := sub(BETA, sar(PRECISION, mul(x, y)))\\n                            // w' = y z - c w\\n                            dwdt := sar(\\n                                PRECISION,\\n                                sub(mul(y, z), mul(GAMMA, w))\\n                            )\\n\\n                            // Initialise the `rhsSum` with the current `rhs0`\\n                            mstore(rhsSum, dxdt)\\n                            mstore(add(rhsSum, 0x20), dydt)\\n                            mstore(add(rhsSum, 0x40), dzdt)\\n                            mstore(add(rhsSum, 0x60), dwdt)\\n\\n                            // Since the rhs f(uOld) will be used to compute a\\n                            // tangent later, we'll store it here to prevent\\n                            // an unnecessay recompuation.\\n                            mstore(tangent, dxdt)\\n                            mstore(add(tangent, 0x20), dydt)\\n                            mstore(add(tangent, 0x40), dzdt)\\n                            mstore(add(tangent, 0x60), dwdt)\\n                        }\\n\\n                        // RK4 intermediate step 1\\n                        {\\n                            // Load the current point aka `uOld`.\\n                            let x := mload(point)\\n                            let y := mload(add(point, 0x20))\\n                            let z := mload(add(point, 0x40))\\n                            let w := mload(add(point, 0x60))\\n\\n                            // Compute the current intermediate state.\\n                            // Precision + 1 for dt / 2\\n                            x := add(x, sar(PRECISION_PLUS_1, mul(dxdt, dt)))\\n                            y := add(y, sar(PRECISION_PLUS_1, mul(dydt, dt)))\\n                            z := add(z, sar(PRECISION_PLUS_1, mul(dzdt, dt)))\\n                            w := add(w, sar(PRECISION_PLUS_1, mul(dwdt, dt)))\\n\\n                            // Compute the rhs for the current intermediate step\\n                            // x' = a (y - x)\\n                            dxdt := sar(PRECISION, mul(ALPHA, sub(y, x)))\\n                            // y' = w + x z\\n                            dydt := add(w, sar(PRECISION, mul(x, z)))\\n                            // z' = b - x y\\n                            dzdt := sub(BETA, sar(PRECISION, mul(x, y)))\\n                            // w' = y z - c w\\n                            dwdt := sar(\\n                                PRECISION,\\n                                sub(mul(y, z), mul(GAMMA, w))\\n                            )\\n\\n                            // Add `rhs1` to the `rhsSum`.\\n                            // shl for adding it twice.\\n                            mstore(rhsSum, add(mload(rhsSum), shl(1, dxdt)))\\n                            mstore(\\n                                add(rhsSum, 0x20),\\n                                add(mload(add(rhsSum, 0x20)), shl(1, dydt))\\n                            )\\n                            mstore(\\n                                add(rhsSum, 0x40),\\n                                add(mload(add(rhsSum, 0x40)), shl(1, dzdt))\\n                            )\\n                            mstore(\\n                                add(rhsSum, 0x60),\\n                                add(mload(add(rhsSum, 0x60)), shl(1, dwdt))\\n                            )\\n                        }\\n\\n                        // RK4 intermediate step 2\\n                        {\\n                            // Load the current point aka `uOld`.\\n                            let x := mload(point)\\n                            let y := mload(add(point, 0x20))\\n                            let z := mload(add(point, 0x40))\\n                            let w := mload(add(point, 0x60))\\n\\n                            // Compute the current intermediate state.\\n                            // Precision + 1 for dt / 2\\n                            x := add(x, sar(PRECISION_PLUS_1, mul(dxdt, dt)))\\n                            y := add(y, sar(PRECISION_PLUS_1, mul(dydt, dt)))\\n                            z := add(z, sar(PRECISION_PLUS_1, mul(dzdt, dt)))\\n                            w := add(w, sar(PRECISION_PLUS_1, mul(dwdt, dt)))\\n\\n                            // Compute the rhs for the current intermediate step\\n                            // x' = a (y - x)\\n                            dxdt := sar(PRECISION, mul(ALPHA, sub(y, x)))\\n                            // y' = w + x z\\n                            dydt := add(w, sar(PRECISION, mul(x, z)))\\n                            // z' = b - x y\\n                            dzdt := sub(BETA, sar(PRECISION, mul(x, y)))\\n                            // w' = y z - c w\\n                            dwdt := sar(\\n                                PRECISION,\\n                                sub(mul(y, z), mul(GAMMA, w))\\n                            )\\n\\n                            // Add `rhs2` to the `rhsSum`.\\n                            // shl for adding it twice.\\n                            mstore(rhsSum, add(mload(rhsSum), shl(1, dxdt)))\\n                            mstore(\\n                                add(rhsSum, 0x20),\\n                                add(mload(add(rhsSum, 0x20)), shl(1, dydt))\\n                            )\\n                            mstore(\\n                                add(rhsSum, 0x40),\\n                                add(mload(add(rhsSum, 0x40)), shl(1, dzdt))\\n                            )\\n                            mstore(\\n                                add(rhsSum, 0x60),\\n                                add(mload(add(rhsSum, 0x60)), shl(1, dwdt))\\n                            )\\n                        }\\n\\n                        // RK4 intermediate step 3\\n                        {\\n                            // Load the current point aka `uOld`.\\n                            let x := mload(point)\\n                            let y := mload(add(point, 0x20))\\n                            let z := mload(add(point, 0x40))\\n                            let w := mload(add(point, 0x60))\\n\\n                            // Compute the current intermediate state.\\n                            x := add(x, sar(PRECISION, mul(dxdt, dt)))\\n                            y := add(y, sar(PRECISION, mul(dydt, dt)))\\n                            z := add(z, sar(PRECISION, mul(dzdt, dt)))\\n                            w := add(w, sar(PRECISION, mul(dwdt, dt)))\\n\\n                            // Compute the rhs for the current intermediate step\\n                            // x' = a (y - x)\\n                            dxdt := sar(PRECISION, mul(ALPHA, sub(y, x)))\\n                            // y' = w + x z\\n                            dydt := add(w, sar(PRECISION, mul(x, z)))\\n                            // z' = b - x y\\n                            dzdt := sub(BETA, sar(PRECISION, mul(x, y)))\\n                            // w' = y z - c w\\n                            dwdt := sar(\\n                                PRECISION,\\n                                sub(mul(y, z), mul(GAMMA, w))\\n                            )\\n\\n                            // Add `rhs3` to the `rhsSum`.\\n                            mstore(rhsSum, add(mload(rhsSum), dxdt))\\n                            mstore(\\n                                add(rhsSum, 0x20),\\n                                add(mload(add(rhsSum, 0x20)), dydt)\\n                            )\\n                            mstore(\\n                                add(rhsSum, 0x40),\\n                                add(mload(add(rhsSum, 0x40)), dzdt)\\n                            )\\n                            mstore(\\n                                add(rhsSum, 0x60),\\n                                add(mload(add(rhsSum, 0x60)), dwdt)\\n                            )\\n                        }\\n                    }\\n\\n                    // Compute the new point aka `uNew`.\\n                    {\\n                        // Unfortunately, we cannot pull this outside the loop\\n                        // because tthe stack will be too deep.\\n                        let dtSixth := div(dt, 6)\\n\\n                        // Load the current point aka `uOld`.\\n                        let x := mload(point)\\n                        let y := mload(add(point, 0x20))\\n                        let z := mload(add(point, 0x40))\\n                        let w := mload(add(point, 0x60))\\n\\n                        // Compute `uNew = dt/6 * rhsSum`\\n                        x := add(x, sar(PRECISION, mul(mload(rhsSum), dtSixth)))\\n                        y := add(\\n                            y,\\n                            sar(\\n                                PRECISION,\\n                                mul(mload(add(rhsSum, 0x20)), dtSixth)\\n                            )\\n                        )\\n                        z := add(\\n                            z,\\n                            sar(\\n                                PRECISION,\\n                                mul(mload(add(rhsSum, 0x40)), dtSixth)\\n                            )\\n                        )\\n                        w := add(\\n                            w,\\n                            sar(\\n                                PRECISION,\\n                                mul(mload(add(rhsSum, 0x60)), dtSixth)\\n                            )\\n                        )\\n\\n                        // Update the point / state of the system.\\n                        mstore(point, x)\\n                        mstore(add(point, 0x20), y)\\n                        mstore(add(point, 0x40), z)\\n                        mstore(add(point, 0x60), w)\\n                    }\\n                }\\n\\n                // Check if we are at a step where we have to store the point\\n                // to the results.\\n                if eq(addmod(iter, 1, skip), 0) {\\n                    // If so, project and store the 2D data\\n                    let x := projectPointX(point, projectionParameters)\\n                    let y := projectPointY(point, projectionParameters)\\n                    posPoints := storeData(posPoints, x, y)\\n                }\\n\\n                // Check if we are at a step where we have to store the tangent\\n                // to the results. This is not the same as for points since\\n                // tangents corresponds to `f(uOld)`. The two are seperated by\\n                // one iteration.\\n                if eq(mod(iter, skip), 0) {\\n                    // Tangent will be used by renders to generate cubic Bezier\\n                    // curves. Following the rhs by `dtTangent = skip * dt / 3`\\n                    // yields optimal results for this.\\n                    let dtTangent := div(mul(skip, dt), 3)\\n\\n                    let x := sar(\\n                        PRECISION,\\n                        mul(\\n                            dtTangent,\\n                            projectDirectionX(tangent, projectionParameters)\\n                        )\\n                    )\\n                    let y := sar(\\n                        PRECISION,\\n                        mul(\\n                            dtTangent,\\n                            projectDirectionY(tangent, projectionParameters)\\n                        )\\n                    )\\n                    posTangents := storeData(posTangents, x, y)\\n                }\\n            }\\n\\n            // Using a `skip` that divides `numberOfIterations` without rest\\n            // results in tangents being one entry short at the end.\\n            // Let's compute and add this one manually.\\n            if eq(mod(numberOfIterations, skip), 0) {\\n                {\\n                    let dxdt\\n                    let dydt\\n                    let dzdt\\n                    let dwdt\\n\\n                    // Compute the tangent aka in analogy to the in the 0th\\n                    // intermediate step of the RK4 scheme\\n                    // I am sure you know the drill by now.\\n                    {\\n                        let x := mload(point)\\n                        let y := mload(add(point, 0x20))\\n                        let z := mload(add(point, 0x40))\\n                        let w := mload(add(point, 0x60))\\n\\n                        // x' = a (y - x)\\n                        dxdt := sar(PRECISION, mul(ALPHA, sub(y, x)))\\n                        // y' = w + x z\\n                        dydt := add(w, sar(PRECISION, mul(x, z)))\\n                        // z' = b - x y\\n                        dzdt := sub(BETA, sar(PRECISION, mul(x, y)))\\n                        // w' = y z - c w\\n                        dwdt := sar(PRECISION, sub(mul(y, z), mul(GAMMA, w)))\\n                        // x' = sigma * (y - x)\\n\\n                        mstore(tangent, dxdt)\\n                        mstore(add(tangent, 0x20), dydt)\\n                        mstore(add(tangent, 0x40), dzdt)\\n                        mstore(add(tangent, 0x60), dwdt)\\n                    }\\n\\n                    // Project and store the tangent. Same as at the end of the\\n                    // main loop, see above.\\n                    {\\n                        let dtTangent := div(mul(skip, dt), 3)\\n\\n                        let x := sar(\\n                            PRECISION,\\n                            mul(\\n                                dtTangent,\\n                                projectDirectionX(tangent, projectionParameters)\\n                            )\\n                        )\\n                        let y := sar(\\n                            PRECISION,\\n                            mul(\\n                                dtTangent,\\n                                projectDirectionY(tangent, projectionParameters)\\n                            )\\n                        )\\n                        posTangents := storeData(posTangents, x, y)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/solvers/AttractorSolver4D.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 David Huber (@cxkoda)\\n// All Rights Reserved\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"./AttractorSolver.sol\\\";\\nimport \\\"../utils/MathHelpers.sol\\\";\\n\\n/**\\n * @notice Base class for four-dimensional attractor simulators.\\n * @dev Partial specialisation of `AttractorSolver` for four-dimensional\\n * systems.\\n * @author David Huber (@cxkoda)\\n */\\nabstract contract AttractorSolver4D is AttractorSolver {\\n    uint8 internal constant DIM = 4;\\n\\n    /**\\n     * @notice Four-dimensional starting point (see `StartingPoint`).\\n     * @dev This type will be used internally for the 3D solvers.\\n     */\\n    struct StartingPoint4D {\\n        int256[DIM] startingPoint;\\n    }\\n\\n    /**\\n     * @notice Four-dimensional projection parameters point (see\\n     * `ProjectionParameters`).\\n     * @dev This type will be used internally for the 3D solvers.\\n     */\\n    struct ProjectionParameters4D {\\n        int256[DIM] axis1;\\n        int256[DIM] axis2;\\n        int256[DIM] offset;\\n    }\\n\\n    /**\\n     * @notice See `IAttractorSolver.getDimensionality`.\\n     */\\n    function getDimensionality() public pure virtual override returns (uint8) {\\n        return DIM;\\n    }\\n\\n    /**\\n     * @notice Converts dynamic to static arrays.\\n     * @dev Converts only arrays with length `DIM`\\n     */\\n    function _convertDynamicToStaticArray(int256[] memory input)\\n        internal\\n        pure\\n        returns (int256[DIM] memory output)\\n    {\\n        require(input.length == DIM);\\n        for (uint256 dim = 0; dim < DIM; ++dim) {\\n            output[dim] = input[dim];\\n        }\\n    }\\n\\n    /**\\n     * @notice Converts dynamic to static arrays.\\n     * @dev Only applicable to arrays with length `DIM`\\n     */\\n    function _parseStartingPoint(StartingPoint memory startingPoint_)\\n        internal\\n        pure\\n        returns (StartingPoint4D memory startingPoint)\\n    {\\n        startingPoint.startingPoint = _convertDynamicToStaticArray(\\n            startingPoint_.startingPoint\\n        );\\n    }\\n\\n    /**\\n     * @dev Converts dynamical length projections parameters to static ones\\n     * for internal use.\\n     */\\n    function _parseProjectionParameters(\\n        ProjectionParameters memory projectionParameters_\\n    )\\n        internal\\n        pure\\n        returns (ProjectionParameters4D memory projectionParameters)\\n    {\\n        require(isValidProjectionParameters(projectionParameters_));\\n        projectionParameters.axis1 = _convertDynamicToStaticArray(\\n            projectionParameters_.axis1\\n        );\\n        projectionParameters.axis2 = _convertDynamicToStaticArray(\\n            projectionParameters_.axis2\\n        );\\n        projectionParameters.offset = _convertDynamicToStaticArray(\\n            projectionParameters_.offset\\n        );\\n    }\\n\\n    /**\\n     * @notice See `IAttractorSolver.getDefaultProjectionParameters`.\\n     * @dev The implementation relies on spherical Fibonacci lattices from\\n     * `MathHelpers` to compute the direction of the axes. Their normalisation\\n     * and offset is delegated to specialisations of `_getDefaultProjectionScale`\\n     * and `_getDefaultProjectionOffset` depending on the system.\\n     */\\n    function getDefaultProjectionParameters(uint256 editionId)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (ProjectionParameters memory projectionParameters)\\n    {\\n        projectionParameters.offset = _getDefaultProjectionOffset();\\n\\n        projectionParameters.axis1 = new int256[](DIM);\\n        projectionParameters.axis2 = new int256[](DIM);\\n\\n        // Make some chaos\\n        uint256 fiboIdx = ((editionId / 4) * 7 + 13) % 32;\\n\\n        (int256[3] memory axis1, int256[3] memory axis2) = MathHelpers\\n            .getFibonacciSphericalAxes(fiboIdx, 32);\\n\\n        int256 scale = _getDefaultProjectionScale();\\n        // Apply length and store back\\n        for (uint8 dim; dim < 3; dim++) {\\n            uint256 coord = dim + editionId;\\n            projectionParameters.axis1[coord % DIM] = (scale * axis1[dim])/ONE;\\n            projectionParameters.axis2[coord % DIM] = (scale * axis2[dim])/ONE;\\n        }\\n    }\\n\\n    /**\\n     * @notice See `IAttractorSolver.computeSolution`.\\n     */\\n    function computeSolution(\\n        SolverParameters calldata solverParameters,\\n        StartingPoint calldata startingPoint,\\n        ProjectionParameters calldata projectionParameters\\n    )\\n        external\\n        pure\\n        override\\n        onlyValidProjectionParameters(projectionParameters)\\n        returns (AttractorSolution memory solution)\\n    {\\n        // Delegate and repack the solution\\n        (solution.points, solution.tangents) = _solve(\\n            solverParameters,\\n            _parseStartingPoint(startingPoint),\\n            _parseProjectionParameters(projectionParameters)\\n        );\\n        // Compute the timestep between points in the output considering that\\n        // not all simulated points will be stored.\\n        solution.dt = solverParameters.dt * solverParameters.skip;\\n    }\\n\\n    /**\\n     * @dev The simulaton routine to be implemented for the individual systems.\\n     * This intermediate interface was introduced to make variables more\\n     * easility accessibly in assembly code.\\n     */\\n    function _solve(\\n        SolverParameters memory solverParameters,\\n        StartingPoint4D memory startingPoint,\\n        ProjectionParameters4D memory projectionParameters\\n    )\\n        internal\\n        pure\\n        virtual\\n        returns (bytes memory points, bytes memory tangents);\\n\\n    /**\\n     * @dev Retuns the default length of the projection axes for the\\n     * respective system.\\n     * Attention: Here we use integers instead of fixed-point numbers for\\n     * simplicity.\\n     */\\n    function _getDefaultProjectionScale()\\n        internal\\n        pure\\n        virtual\\n        returns (int256);\\n\\n    /**\\n     * @dev Returns the default offset of the projection for the respective\\n     * system.\\n     */\\n    function _getDefaultProjectionOffset()\\n        internal\\n        pure\\n        virtual\\n        returns (int256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/solvers/AttractorSolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 David Huber (@cxkoda)\\n// All Rights Reserved\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"./IAttractorSolver.sol\\\";\\n\\n/**\\n * @notice Base class for attractor simulators.\\n * @dev The contract implements some convenient routines shared across\\n * different AttractorSolvers.\\n * @author David Huber (@cxkoda)\\n */\\nabstract contract AttractorSolver is IAttractorSolver {\\n    /**\\n     * @notice The fixed-number precision used throughout this project.\\n     */\\n    uint8 public constant PRECISION = 96;\\n    uint8 internal constant PRECISION_PLUS_1 = 97;\\n    int256 internal constant ONE = 2**96;\\n\\n    /**\\n     * @dev The simulation results (see `AttractorSolution`) will be stored as\\n     * 16-bit fixed-point values with precision 6. This implies a right shift\\n     * of internally used (higher-precision) values by 96-6=90.\\n     * Reducing the width to 16-bit at a precision of 6 futher means that the \\n     * left 256-96-10=150 bits of the original (256 bit) number will be dropped.\\n     */\\n    uint256 internal constant PRECISION_REDUCTION_SAR = 90;\\n    uint256 internal constant RANGE_REDUCTION_SHL = 150;\\n\\n    /**\\n     * @notice See `IAttractorSolver.getFixedPointPrecision`.\\n     */\\n    function getFixedPointPrecision() external pure override returns (uint8) {\\n        return PRECISION;\\n    }\\n\\n    /**\\n     * @notice See `IAttractorSolver.isValidProjectionParameters`\\n     * @dev Performs a simple dimensionality check.\\n     */\\n    function isValidProjectionParameters(\\n        ProjectionParameters memory projectionParameters\\n    ) public pure override returns (bool) {\\n        return\\n            (projectionParameters.axis1.length == getDimensionality()) &&\\n            (projectionParameters.axis2.length == getDimensionality()) &&\\n            (projectionParameters.offset.length == getDimensionality());\\n    }\\n\\n    /**\\n     * @dev Modifier checking for `isValidProjectionParameters`.\\n     */\\n    modifier onlyValidProjectionParameters(\\n        ProjectionParameters memory projectionParameters\\n    ) {\\n        require(\\n            isValidProjectionParameters(projectionParameters),\\n            \\\"Invalid Projection Parameters\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Compute a random number in a given `range` around zero.\\n     * @dev Computes deterministic PRNs based on a given input `seed`. The\\n     * values are distributed quasi-equally in the interval `[-range, range]`.\\n     * @return newSeed To be used in the next function call.\\n     */\\n    function _random(uint256 seed, int256 range)\\n        internal\\n        pure\\n        returns (uint256 newSeed, int256 randomNumber)\\n    {\\n        newSeed = uint256(keccak256(abi.encode(seed)));\\n        randomNumber = int256(newSeed);\\n        assembly {\\n            randomNumber := sub(mod(newSeed, shl(1, range)), range)\\n        }\\n    }\\n\\n    /**\\n     * @notice See `IAttractorSolver.getDimensionality`.\\n     */\\n    function getDimensionality() public pure virtual override returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/MathHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 David Huber (@cxkoda)\\n// All Rights Reserved\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @notice A point on the sphere with unit radius.\\n * @dev Since we will be interested in 3D points in the end, it makes more\\n * sense to just store trigonimetric values (and don't spend the effort\\n * to invert to the actual angles).\\n */\\nstruct SphericalPoint {\\n    int256 sinAzimuth;\\n    int256 cosAzimuth;\\n    int256 sinAltitude;\\n    int256 cosAltitude;\\n}\\n\\n/**\\n * @notice Some special math functions used for `Strange Attractors`.\\n * @dev The functions use fixed-point number with the same precision (96) as\\n * the numerical solvers (see also `IAttractorSolver`).\\n * @author David Huber (@cxkoda)\\n */\\nlibrary MathHelpers {\\n    uint8 public constant PRECISION = 96;\\n\\n    /**\\n     * @dev Some handy constants.\\n     */\\n    int256 private constant ONE = 2**96;\\n    int256 public constant PI = 248902613312231085230521944622;\\n    int256 public constant PI_2 = 497805226624462170461043889244;\\n    int256 public constant MINUS_PI_2 = -497805226624462170461043889244;\\n    int256 public constant PI_0_5 = 124451306656115542615260972311;\\n\\n    /**\\n     * @notice Taylor series coefficients for sin around 0.\\n     */\\n    int256 private constant COEFFICIENTS_SIN_1 = 2**96;\\n    int256 private constant COEFFICIENTS_SIN_3 = -(2**96 + 2) / 6;\\n    int256 private constant COEFFICIENTS_SIN_5 = (2**96 - 16) / 120;\\n    int256 private constant COEFFICIENTS_SIN_7 = -(2**96 + 944) / 5040;\\n    int256 private constant COEFFICIENTS_SIN_9 = (2**96 - 205696) / 362880;\\n    int256 private constant COEFFICIENTS_SIN_11 =\\n        -(2**96 + 34993664) / 39916800;\\n\\n    /**\\n     * @notice A pure solidity approximation of the sine function.\\n     * @dev The implementation uses a broken Taylor series approximation to\\n     * compute values. The absolute error is <1e-3.\\n     */\\n    function sin(int256 x) public pure returns (int256 result) {\\n        assembly {\\n            // We remap the x to the range [-pi, pi] first, since the Taylor\\n            // series is most accurate there.\\n\\n            // Attention: smod(-10, 2) = -10 but smod(-10, -2) = 0\\n            // We therefore shift the numbers to the positive side first\\n            x := add(smod(x, MINUS_PI_2), PI_2)\\n\\n            // Restrict to the range [-pi, pi]\\n            x := sub(addmod(x, PI, PI_2), PI)\\n\\n            let x2 := sar(PRECISION, mul(x, x))\\n            result := sar(\\n                PRECISION,\\n                mul(\\n                    x,\\n                    add(\\n                        COEFFICIENTS_SIN_1,\\n                        sar(\\n                            PRECISION,\\n                            mul(\\n                                x2,\\n                                add(\\n                                    COEFFICIENTS_SIN_3,\\n                                    sar(\\n                                        PRECISION,\\n                                        mul(\\n                                            x2,\\n                                            add(\\n                                                COEFFICIENTS_SIN_5,\\n                                                sar(\\n                                                    PRECISION,\\n                                                    mul(\\n                                                        x2,\\n                                                        add(\\n                                                            COEFFICIENTS_SIN_7,\\n                                                            sar(\\n                                                                PRECISION,\\n                                                                mul(\\n                                                                    x2,\\n                                                                    add(\\n                                                                        COEFFICIENTS_SIN_9,\\n                                                                        sar(\\n                                                                            PRECISION,\\n                                                                            mul(\\n                                                                                x2,\\n                                                                                COEFFICIENTS_SIN_11\\n                                                                            )\\n                                                                        )\\n                                                                    )\\n                                                                )\\n                                                            )\\n                                                        )\\n                                                    )\\n                                                )\\n                                            )\\n                                        )\\n                                    )\\n                                )\\n                            )\\n                        )\\n                    )\\n                )\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @notice Taylor series coefficients for cos around 0.\\n     */\\n    int256 private constant COEFFICIENTS_COS_2 = -(2**96 / 2);\\n    int256 private constant COEFFICIENTS_COS_4 = (2**96 - 16) / 24;\\n    int256 private constant COEFFICIENTS_COS_6 = -(2**96 + 224) / 720;\\n    int256 private constant COEFFICIENTS_COS_8 = (2**96 - 4096) / 40320;\\n    int256 private constant COEFFICIENTS_COS_10 = -(2**96 + 2334464) / 3628800;\\n    int256 private constant COEFFICIENTS_COS_12 =\\n        (2**96 - 204507136) / 479001600;\\n\\n    /**\\n     * @notice A pure solidity approximation of the cosine function.\\n     * @dev The implementation uses a broken Taylor series approximation to\\n     * compute values. The absolute error is <1e-3.\\n     */\\n    function cos(int256 x) public pure returns (int256 result) {\\n        assembly {\\n            // We remap the x to the range [-pi, pi] first, since the Taylor\\n            // series is most accurate there.\\n\\n            // Attention: smod(-10, 2) = -10 but smod(-10, -2) = 0\\n            // We therefore shift the numbers to the positive side first\\n            x := add(smod(x, MINUS_PI_2), PI_2)\\n\\n            // Restrict to the range [-pi, pi]\\n            x := sub(addmod(x, PI, PI_2), PI)\\n\\n            let x2 := sar(PRECISION, mul(x, x))\\n\\n            result := add(\\n                ONE,\\n                sar(\\n                    PRECISION,\\n                    mul(\\n                        x2,\\n                        add(\\n                            COEFFICIENTS_COS_2,\\n                            sar(\\n                                PRECISION,\\n                                mul(\\n                                    x2,\\n                                    add(\\n                                        COEFFICIENTS_COS_4,\\n                                        sar(\\n                                            PRECISION,\\n                                            mul(\\n                                                x2,\\n                                                add(\\n                                                    COEFFICIENTS_COS_6,\\n                                                    sar(\\n                                                        PRECISION,\\n                                                        mul(\\n                                                            x2,\\n                                                            add(\\n                                                                COEFFICIENTS_COS_8,\\n                                                                sar(\\n                                                                    PRECISION,\\n                                                                    mul(\\n                                                                        x2,\\n                                                                        add(\\n                                                                            COEFFICIENTS_COS_10,\\n                                                                            sar(\\n                                                                                PRECISION,\\n                                                                                mul(\\n                                                                                    x2,\\n                                                                                    COEFFICIENTS_COS_12\\n                                                                                )\\n                                                                            )\\n                                                                        )\\n                                                                    )\\n                                                                )\\n                                                            )\\n                                                        )\\n                                                    )\\n                                                )\\n                                            )\\n                                        )\\n                                    )\\n                                )\\n                            )\\n                        )\\n                    )\\n                )\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @notice A pure solidity approximation of the square root function.\\n     * @dev The implementation uses the Babylonian method with a fixed amount of\\n     *  steps (for a predictable gas). The approximation is optimised for values\\n     * in the range of[0,1]. The absolute error is <1e-3.\\n     */\\n    function sqrt(int256 x) public pure returns (int256 result) {\\n        require(x >= 0, \\\"Sqrt is only defined for positive numbers\\\");\\n        assembly {\\n            result := x\\n            result := sar(1, add(div(shl(PRECISION, x), result), result))\\n            result := sar(1, add(div(shl(PRECISION, x), result), result))\\n            result := sar(1, add(div(shl(PRECISION, x), result), result))\\n            result := sar(1, add(div(shl(PRECISION, x), result), result))\\n            result := sar(1, add(div(shl(PRECISION, x), result), result))\\n            result := sar(1, add(div(shl(PRECISION, x), result), result))\\n            result := sar(1, add(div(shl(PRECISION, x), result), result))\\n        }\\n    }\\n\\n    int256 private constant GOLDEN_RATIO = 128193859814280023944822833248;\\n\\n    /**\\n     * @notice Computes quasi-equidistant points on a unit-sphere.\\n     * @dev The function employs Fibonacci lattices remapped to the unit-sphere\\n     * to compute `numPoints` different points in spherical coordinates. It\\n     * should be noted that we use the angle convention `altitude`(=theta) in\\n     * [-pi/2, pi/2].\\n     */\\n    function getFibonacciLatticeOnSphere(uint256 idx, uint256 numPoints)\\n        internal\\n        pure\\n        returns (SphericalPoint memory sphericalPoint)\\n    {\\n        require(idx >= 0 && idx < numPoints, \\\"Index out of range\\\");\\n        sphericalPoint.sinAltitude =\\n            (2 * ONE * int256(idx)) /\\n            int256(numPoints) -\\n            ONE;\\n\\n        {\\n            int256 sinAltitude2 = sphericalPoint.sinAltitude;\\n            assembly {\\n                sinAltitude2 := sar(PRECISION, mul(sinAltitude2, sinAltitude2))\\n            }\\n            sphericalPoint.cosAltitude = sqrt(ONE - sinAltitude2);\\n        }\\n\\n        {\\n            int256 azimuth;\\n            assembly {\\n                azimuth := smod(\\n                    div(shl(PRECISION, mul(PI_2, idx)), GOLDEN_RATIO),\\n                    PI_2\\n                )\\n            }\\n            sphericalPoint.cosAzimuth = cos(azimuth);\\n            sphericalPoint.sinAzimuth = sin(azimuth);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes projection axes for different directions.\\n     * @dev Uses the directions provided by `getFibonacciLatticeOnSphere` to\\n     * compute two normalised, orthogonal axes. The are computed by rotating the\\n     * x-z projection plane first by `altitude` around -x and then by `azimuth`\\n     * around +z.\\n     */\\n    function getFibonacciSphericalAxes(uint256 idx, uint256 numPoints)\\n        external\\n        pure\\n        returns (int256[3] memory axis1, int256[3] memory axis2)\\n    {\\n        SphericalPoint memory sphericalPoint = getFibonacciLatticeOnSphere(\\n            idx,\\n            numPoints\\n        );\\n\\n        axis1 = [sphericalPoint.cosAzimuth, sphericalPoint.sinAzimuth, 0];\\n        axis2 = [\\n            -sphericalPoint.sinAzimuth * sphericalPoint.sinAltitude,\\n            sphericalPoint.cosAzimuth * sphericalPoint.sinAltitude,\\n            sphericalPoint.cosAltitude\\n        ];\\n\\n        assembly {\\n            let pos := axis2\\n            mstore(pos, sar(PRECISION, mload(pos)))\\n            pos := add(pos, 0x20)\\n            mstore(pos, sar(PRECISION, mload(pos)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/solvers/IAttractorSolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 David Huber (@cxkoda)\\n// All Rights Reserved\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"./AttractorSolution.sol\\\";\\n\\n/**\\n * @notice Parameters going to the numerical ODE solver.\\n * @param numberOfIterations Total number of iterations.\\n * @param dt Timestep increment in each iteration\\n * @param skip Amount of iterations between storing two points.\\n * @dev `numberOfIterations` has to be dividable without rest by `skip`.\\n */\\nstruct SolverParameters {\\n    uint256 numberOfIterations;\\n    uint256 dt;\\n    uint8 skip;\\n}\\n\\n/**\\n * @notice Parameters going to the projection routines.\\n * @dev The lengths of all fields have to match the dimensionality of the\\n * considered system.\\n * @param axis1 First projection axis (horizontal image coordinate)\\n * @param axis2 Second projection axis (vertical image coordinate)\\n * @param offset Offset applied before projecting.\\n */\\nstruct ProjectionParameters {\\n    int256[] axis1;\\n    int256[] axis2;\\n    int256[] offset;\\n}\\n\\n/**\\n * @notice Starting point for the numerical simulation\\n * @dev The length of the starting point has to match the dimensionality of the\\n * considered system.\\n * I agree, this struct looks kinda dumb, but I really like speaking types.\\n * So as long as we don't have typedefs for non-elementary types, we are stuck\\n * with this cruelty.\\n */\\nstruct StartingPoint {\\n    int256[] startingPoint;\\n}\\n\\n/**\\n * @notice Interface for simulators of chaotic systems.\\n * @dev Implementations of this interface will contain the mathematical\\n * description of the underlying differential equations, deal with its numerical\\n * solution and the 2D projection of the results.\\n * Implementations will internally use fixed-point numbers with a precision of\\n * 96 bits by convention.\\n * @author David Huber (@cxkoda)\\n */\\ninterface IAttractorSolver {\\n    /**\\n     * @notice Simulates the evolution of a chaotic system.\\n     * @dev This is the core piece of this class that performs everything\\n     * at once. All relevant algorithm for the evaluation of the ODEs\\n     * the numerical scheme, the projection and storage are contained within\\n     * this method for performance reasons.\\n     * @return An `AttractorSolution` containing already projected 2D points\\n     * and tangents to them.\\n     */\\n    function computeSolution(\\n        SolverParameters calldata,\\n        StartingPoint calldata,\\n        ProjectionParameters calldata\\n    ) external pure returns (AttractorSolution memory);\\n\\n    /**\\n     * @notice Generates a random starting point for the system.\\n     */\\n    function getRandomStartingPoint(uint256 randomSeed)\\n        external\\n        view\\n        returns (StartingPoint memory);\\n\\n    /**\\n     * @notice Generates the default projection for a given edition of the\\n     * system.\\n     */\\n    function getDefaultProjectionParameters(uint256 editionId)\\n        external\\n        view\\n        returns (ProjectionParameters memory);\\n\\n    /**\\n     * @notice Returns the type/name of the dynamical system.\\n     */\\n    function getSystemType() external pure returns (string memory);\\n\\n    /**\\n     * @notice Returns the dimensionality of the dynamical system (number of\\n     * ODEs).\\n     */\\n    function getDimensionality() external pure returns (uint8);\\n\\n    /**\\n     * @notice Returns the precision of the internally used fixed-point numbers.\\n     * @dev The solvers operate on fixed-point numbers with a given PRECISION,\\n     * i.e. the amount of bits reserved for decimal places.\\n     * By convention, this method will return 96 throughout the project.\\n     */\\n    function getFixedPointPrecision() external pure returns (uint8);\\n\\n    /**\\n     * @notice Checks if given `ProjectionParameters` are valid`\\n     */\\n    function isValidProjectionParameters(ProjectionParameters memory)\\n        external\\n        pure\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/solvers/AttractorSolution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 David Huber (@cxkoda)\\n// All Rights Reserved\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @notice The data struct that will be passed from the solver to the renderer.\\n * @dev `points` and `tangents` both contain pairs of 16-bit fixed-point numbers\\n * with a PRECISION of 6 in row-major order.`dt` is given in the fixed-point\\n * respresentation used by the solvers and corresponds to the time step between \\n * the datapoints.\\n */\\nstruct AttractorSolution {\\n    bytes points;\\n    bytes tangents;\\n    uint256 dt;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/utils/MathHelpers.sol\": {\r\n        \"MathHelpers\": \"0x0a5f4954dae545b6353cad8c6a29c357a6159a3f\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"numberOfIterations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dt\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"skip\",\"type\":\"uint8\"}],\"internalType\":\"struct SolverParameters\",\"name\":\"solverParameters\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"startingPoint\",\"type\":\"int256[]\"}],\"internalType\":\"struct StartingPoint\",\"name\":\"startingPoint\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"axis1\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"axis2\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"offset\",\"type\":\"int256[]\"}],\"internalType\":\"struct ProjectionParameters\",\"name\":\"projectionParameters\",\"type\":\"tuple\"}],\"name\":\"computeSolution\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"points\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"tangents\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"dt\",\"type\":\"uint256\"}],\"internalType\":\"struct AttractorSolution\",\"name\":\"solution\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"editionId\",\"type\":\"uint256\"}],\"name\":\"getDefaultProjectionParameters\",\"outputs\":[{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"axis1\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"axis2\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"offset\",\"type\":\"int256[]\"}],\"internalType\":\"struct ProjectionParameters\",\"name\":\"projectionParameters\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDimensionality\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFixedPointPrecision\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"randomSeed\",\"type\":\"uint256\"}],\"name\":\"getRandomStartingPoint\",\"outputs\":[{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"startingPoint\",\"type\":\"int256[]\"}],\"internalType\":\"struct StartingPoint\",\"name\":\"startingPoint\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSystemType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"axis1\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"axis2\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"offset\",\"type\":\"int256[]\"}],\"internalType\":\"struct ProjectionParameters\",\"name\":\"projectionParameters\",\"type\":\"tuple\"}],\"name\":\"isValidProjectionParameters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"MultiWing4D","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}