{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: Apache-2.0\r\n// VolumeFi Software, Inc.\r\n\r\npragma solidity ^0.7.6;\r\npragma abicoder v2;\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\ninterface INonfungiblePositionManager {\r\n    struct MintParams {\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        address recipient;\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct IncreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct DecreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint128 liquidity;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct CollectParams {\r\n        uint256 tokenId;\r\n        address recipient;\r\n        uint128 amount0Max;\r\n        uint128 amount1Max;\r\n    }\r\n\r\n    function mint(MintParams calldata params)\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 tokenId,\r\n            uint128 liquidity,\r\n            uint256 amount0,\r\n            uint256 amount1\r\n        );\r\n\r\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\r\n        external\r\n        payable\r\n        returns (\r\n            uint128 liquidity,\r\n            uint256 amount0,\r\n            uint256 amount1\r\n        );\r\n\r\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\r\n        external\r\n        payable\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function collect(CollectParams calldata params)\r\n        external\r\n        payable\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function burn(uint256 tokenId) external payable;\r\n\r\n    function positions(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (\r\n            uint96 nonce,\r\n            address operator,\r\n            address token0,\r\n            address token1,\r\n            uint24 fee,\r\n            int24 tickLower,\r\n            int24 tickUpper,\r\n            uint128 liquidity,\r\n            uint256 feeGrowthInside0LastX128,\r\n            uint256 feeGrowthInside1LastX128,\r\n            uint128 tokensOwed0,\r\n            uint128 tokensOwed1\r\n        );\r\n}\r\n\r\ninterface ISwapRouter {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    function exactInputSingle(ExactInputSingleParams calldata params)\r\n        external\r\n        payable\r\n        returns (uint256 amountOut);\r\n}\r\n\r\ninterface IUniswapV3Factory {\r\n    function getPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external view returns (address pool);\r\n}\r\n\r\ninterface IUniswapV3Pool {\r\n    function slot0()\r\n        external\r\n        view\r\n        returns (\r\n            uint160 sqrtPriceX96,\r\n            int24 tick,\r\n            uint16 observationIndex,\r\n            uint16 observationCardinality,\r\n            uint16 observationCardinalityNext,\r\n            uint8 feeProtocol,\r\n            bool unlocked\r\n        );\r\n}\r\n\r\nlibrary Address {\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"R2\");//\"Address: low-level call failed\"\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"R3\"//\"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"R4\"//\"insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"R5\");//\"Address: call to non-contract\"\r\n\r\n        (bool success, bytes memory returndata) =\r\n            target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"R6\"//\"approve non-zero to non-zero\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata =\r\n            address(token).functionCall(\r\n                data,\r\n                \"R7\"//\"SafeERC20: low-level call failed\"\r\n            );\r\n        if (returndata.length > 0) {\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"R8\"//\"ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nlibrary FixedPoint96 {\r\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\r\n}\r\n\r\nlibrary FullMath {\r\n    function mulDiv(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        uint256 prod0; // Least significant 256 bits of the product\r\n        uint256 prod1; // Most significant 256 bits of the product\r\n        assembly {\r\n            let mm := mulmod(a, b, not(0))\r\n            prod0 := mul(a, b)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        if (prod1 == 0) {\r\n            require(denominator > 0);\r\n            assembly {\r\n                result := div(prod0, denominator)\r\n            }\r\n            return result;\r\n        }\r\n\r\n        require(denominator > prod1);\r\n\r\n        uint256 remainder;\r\n        assembly {\r\n            remainder := mulmod(a, b, denominator)\r\n        }\r\n        assembly {\r\n            prod1 := sub(prod1, gt(remainder, prod0))\r\n            prod0 := sub(prod0, remainder)\r\n        }\r\n\r\n        uint256 twos = -denominator & denominator;\r\n\r\n        assembly {\r\n            denominator := div(denominator, twos)\r\n        }\r\n\r\n        assembly {\r\n            prod0 := div(prod0, twos)\r\n        }\r\n\r\n        assembly {\r\n            twos := add(div(sub(0, twos), twos), 1)\r\n        }\r\n        prod0 |= prod1 * twos;\r\n\r\n        uint256 inv = (3 * denominator) ^ 2;\r\n\r\n        inv *= 2 - denominator * inv; // inverse mod 2**8\r\n        inv *= 2 - denominator * inv; // inverse mod 2**16\r\n        inv *= 2 - denominator * inv; // inverse mod 2**32\r\n        inv *= 2 - denominator * inv; // inverse mod 2**64\r\n        inv *= 2 - denominator * inv; // inverse mod 2**128\r\n        inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n        result = prod0 * inv;\r\n        return result;\r\n    }\r\n}\r\n\r\nlibrary TickMath {\r\n    int24 internal constant MIN_TICK = -887272;\r\n    int24 internal constant MAX_TICK = -MIN_TICK;\r\n\r\n    function getSqrtRatioAtTick(int24 tick)\r\n        internal\r\n        pure\r\n        returns (uint160 sqrtPriceX96)\r\n    {\r\n        uint256 absTick =\r\n            tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\r\n        require(absTick <= uint256(MAX_TICK), \"T\");\r\n\r\n        uint256 ratio =\r\n            absTick & 0x1 != 0\r\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\r\n                : 0x100000000000000000000000000000000;\r\n        if (absTick & 0x2 != 0)\r\n            ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\r\n        if (absTick & 0x4 != 0)\r\n            ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\r\n        if (absTick & 0x8 != 0)\r\n            ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\r\n        if (absTick & 0x10 != 0)\r\n            ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\r\n        if (absTick & 0x20 != 0)\r\n            ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\r\n        if (absTick & 0x40 != 0)\r\n            ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\r\n        if (absTick & 0x80 != 0)\r\n            ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\r\n        if (absTick & 0x100 != 0)\r\n            ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\r\n        if (absTick & 0x200 != 0)\r\n            ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\r\n        if (absTick & 0x400 != 0)\r\n            ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\r\n        if (absTick & 0x800 != 0)\r\n            ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\r\n        if (absTick & 0x1000 != 0)\r\n            ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\r\n        if (absTick & 0x2000 != 0)\r\n            ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\r\n        if (absTick & 0x4000 != 0)\r\n            ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\r\n        if (absTick & 0x8000 != 0)\r\n            ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\r\n        if (absTick & 0x10000 != 0)\r\n            ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\r\n        if (absTick & 0x20000 != 0)\r\n            ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\r\n        if (absTick & 0x40000 != 0)\r\n            ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\r\n        if (absTick & 0x80000 != 0)\r\n            ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\r\n\r\n        if (tick > 0) ratio = type(uint256).max / ratio;\r\n\r\n        sqrtPriceX96 = uint160(\r\n            (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\r\n        );\r\n    }\r\n}\r\n\r\nlibrary LiquidityAmounts {\r\n    function toUint128(uint256 x) private pure returns (uint128 y) {\r\n        require((y = uint128(x)) == x);\r\n    }\r\n\r\n    function getLiquidityForAmount0(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n        uint256 intermediate =\r\n            FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\r\n        return\r\n            toUint128(\r\n                FullMath.mulDiv(\r\n                    amount0,\r\n                    intermediate,\r\n                    sqrtRatioBX96 - sqrtRatioAX96\r\n                )\r\n            );\r\n    }\r\n\r\n    function getLiquidityForAmount1(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount1\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n        return\r\n            toUint128(\r\n                FullMath.mulDiv(\r\n                    amount1,\r\n                    FixedPoint96.Q96,\r\n                    sqrtRatioBX96 - sqrtRatioAX96\r\n                )\r\n            );\r\n    }\r\n\r\n    function getLiquidityForAmounts(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\r\n            liquidity = getLiquidityForAmount0(\r\n                sqrtRatioAX96,\r\n                sqrtRatioBX96,\r\n                amount0\r\n            );\r\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\r\n            uint128 liquidity0 =\r\n                getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\r\n            uint128 liquidity1 =\r\n                getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\r\n\r\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\r\n        } else {\r\n            liquidity = getLiquidityForAmount1(\r\n                sqrtRatioAX96,\r\n                sqrtRatioBX96,\r\n                amount1\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\ninterface ICellarPoolShare is IERC20 {\r\n    struct MintParams {\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        address recipient;\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct MintResult {\r\n        uint256 tokenId;\r\n        uint128 liquidity;\r\n        uint256 amount0;\r\n        uint256 amount1;\r\n    }\r\n\r\n    struct CellarAddParams {\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        address recipient;\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct CellarRemoveParams {\r\n        uint256 tokenAmount;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        address recipient;\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct CellarTickInfo {\r\n        uint184 tokenId;\r\n        int24 tickUpper;\r\n        int24 tickLower;\r\n        uint24 weight;\r\n    }\r\n\r\n    struct UintPair {\r\n        uint256 a;\r\n        uint256 b;\r\n    }\r\n\r\n    event AddedLiquidity(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        uint128 liquidity,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    );\r\n\r\n    event RemovedLiquidity(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        uint128 liquidity,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    );\r\n\r\n    function addLiquidityForUniV3(CellarAddParams calldata cellarParams)\r\n        external;\r\n\r\n    function addLiquidityEthForUniV3(CellarAddParams calldata cellarParams)\r\n        external\r\n        payable;\r\n\r\n    function removeLiquidityFromUniV3(CellarRemoveParams calldata cellarParams)\r\n        external;\r\n\r\n    function removeLiquidityEthFromUniV3(\r\n        CellarRemoveParams calldata cellarParams\r\n    ) external;\r\n\r\n    function reinvest() external;\r\n\r\n    function setValidator(address _validator, bool value) external;\r\n\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    function setFee(uint16 newFee) external;\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256) external;\r\n}\r\n\r\ncontract BlockLock {\r\n    // how many blocks are the functions locked for\r\n    uint256 private constant BLOCK_LOCK_COUNT = 1;\r\n    // last block for which this address is timelocked\r\n    mapping(address => uint256) public lastLockedBlock;\r\n\r\n    function lock(address _address) internal {\r\n        lastLockedBlock[_address] = block.number + BLOCK_LOCK_COUNT;\r\n    }\r\n\r\n    modifier notLocked(address lockedAddress) {\r\n        require(lastLockedBlock[lockedAddress] <= block.number, \"R30\");//\"Locked\"\r\n        _;\r\n    }\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n    function latestAnswer() external view returns(int256);\r\n}\r\n\r\ncontract CellarPoolShareLimitETHUSDT is ICellarPoolShare, BlockLock {\r\n    using SafeERC20 for IERC20;\r\n\r\n    address constant NONFUNGIBLEPOSITIONMANAGER =\r\n        0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\r\n\r\n    address constant UNISWAPV3FACTORY =\r\n        0x1F98431c8aD98523631AE4a59f267346ea31F984;\r\n\r\n    address constant SWAPROUTER =\r\n        0xE592427A0AEce92De3Edee1F18E0157C05861564;\r\n\r\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    uint16 constant FEEDOMINATOR = 10000;\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    mapping(address => bool) public validator;\r\n    uint256 private _totalSupply;\r\n    address private _owner;\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    address public immutable token0;\r\n    address public immutable token1;\r\n    uint24 public immutable feeLevel;\r\n    CellarTickInfo[] public cellarTickInfo;\r\n    bool private _isEntered;\r\n    uint16 public fee = 1000;\r\n    AggregatorV3Interface public constant priceFeed = AggregatorV3Interface(0xEe9F2375b4bdF6387aa8265dD4FB8F16512A1d46);\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        address _token0,\r\n        address _token1,\r\n        uint24 _feeLevel,\r\n        CellarTickInfo[] memory _cellarTickInfo\r\n    ) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        require(_token0 < _token1, \"R9\");//\"Tokens are not sorted\"\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n        feeLevel = _feeLevel;\r\n        for (uint256 i = 0; i < _cellarTickInfo.length; i++) {\r\n            require(_cellarTickInfo[i].weight > 0, \"R10\");//\"Weight cannot be zero\"\r\n            require(_cellarTickInfo[i].tokenId == 0, \"R11\");//\"tokenId is not empty\"\r\n            if (i > 0) {\r\n                require(_cellarTickInfo[i].tickUpper <= _cellarTickInfo[i - 1].tickLower, \"R12\");//\"Wrong tick tier\"\r\n            }\r\n            cellarTickInfo.push(\r\n                CellarTickInfo({\r\n                    tokenId: 0,\r\n                    tickUpper: _cellarTickInfo[i].tickUpper,\r\n                    tickLower: _cellarTickInfo[i].tickLower,\r\n                    weight: _cellarTickInfo[i].weight\r\n                })\r\n            );\r\n        }\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyValidator() {\r\n        require(validator[msg.sender], \"R13\");//\"Not validator\"\r\n        _;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(!_isEntered, \"R14\");//\"reentrant call\"\r\n        _isEntered = true;\r\n        _;\r\n        _isEntered = false;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance >= amount, \"R15\");//\"transfer exceeds allowance\"\r\n        _approve(sender, msg.sender, currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n    function totalPrice(uint256 amount0, uint256 amount1) internal view returns (uint256 total) {\r\n        // WETH + USDT\r\n        uint256 price = uint256(priceFeed.latestAnswer());\r\n        total = amount0 * 10 ** 6 / price + amount1;\r\n    }\r\n\r\n    function addLiquidityForUniV3(CellarAddParams calldata cellarParams)\r\n        external\r\n        override\r\n        notLocked(msg.sender)\r\n    {\r\n        lock(msg.sender);\r\n        require(block.timestamp <= cellarParams.deadline);\r\n        IERC20(token0).safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            cellarParams.amount0Desired\r\n        );\r\n\r\n        IERC20(token1).safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            cellarParams.amount1Desired\r\n        );\r\n\r\n        (\r\n            uint256 inAmount0,\r\n            uint256 inAmount1,\r\n            uint128 liquidityBefore,\r\n            uint128 liquiditySum\r\n        ) = _addLiquidity(cellarParams);\r\n\r\n        uint256 prevTotalSupply = _totalSupply;\r\n\r\n        if (liquidityBefore == 0) {\r\n            _mint(msg.sender, liquiditySum);\r\n        } else {\r\n            _mint(\r\n                msg.sender,\r\n                FullMath.mulDiv(liquiditySum, _totalSupply, liquidityBefore)\r\n            );\r\n        }\r\n        require(inAmount0 >= cellarParams.amount0Min, \"R16\");//\"Less than Amount0Min\"\r\n        require(inAmount1 >= cellarParams.amount1Min, \"R17\");//\"Less than Amount1Min\"\r\n        // check limitation\r\n        uint256 increasedSupply = _totalSupply - prevTotalSupply;\r\n        if (increasedSupply > 0) {\r\n            uint256 inPrice = totalPrice(inAmount0, inAmount1);\r\n            uint256 userPrice = FullMath.mulDiv(inPrice, _balances[msg.sender], increasedSupply);\r\n            require(userPrice <= 10000 * 10 ** 6, \"R31\"); // \"More than 10000 USD\"\r\n            uint256 total = FullMath.mulDiv(inPrice, _totalSupply, increasedSupply);\r\n            require(total <= 500000 * 10 ** 6, \"R32\"); // \"More than 500000 USD\"\r\n        }\r\n        //\r\n        if (cellarParams.amount0Desired > inAmount0) {\r\n            IERC20(token0).safeTransfer(\r\n                msg.sender,\r\n                cellarParams.amount0Desired - inAmount0\r\n            );\r\n        }\r\n        if (cellarParams.amount1Desired > inAmount1) {\r\n            IERC20(token1).safeTransfer(\r\n                msg.sender,\r\n                cellarParams.amount1Desired - inAmount1\r\n            );\r\n        }\r\n        emit AddedLiquidity(token0, token1, liquiditySum, inAmount0, inAmount1);\r\n    }\r\n\r\n    function addLiquidityEthForUniV3(CellarAddParams calldata cellarParams)\r\n        external\r\n        payable\r\n        override\r\n        nonReentrant\r\n        notLocked(msg.sender)\r\n    {\r\n        lock(msg.sender);\r\n        require(block.timestamp <= cellarParams.deadline);\r\n        if (token0 == WETH) {\r\n            if (msg.value > cellarParams.amount0Desired) {\r\n                payable(msg.sender).transfer(\r\n                    msg.value - cellarParams.amount0Desired\r\n                );\r\n            } else {\r\n                require(\r\n                    msg.value == cellarParams.amount0Desired,\r\n                    \"R18\"//\"Eth not enough\"\r\n                );\r\n            }\r\n            IWETH(WETH).deposit{value: cellarParams.amount0Desired}();\r\n            IERC20(token1).safeTransferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                cellarParams.amount1Desired\r\n            );\r\n        } else {\r\n            require(token1 == WETH, \"R19\");//\"Not Eth Pair\"\r\n            if (msg.value > cellarParams.amount1Desired) {\r\n                payable(msg.sender).transfer(\r\n                    msg.value - cellarParams.amount1Desired\r\n                );\r\n            } else {\r\n                require(\r\n                    msg.value == cellarParams.amount1Desired,\r\n                    \"R18\"\r\n                );\r\n            }\r\n            IWETH(WETH).deposit{value: cellarParams.amount1Desired}();\r\n            IERC20(token0).safeTransferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                cellarParams.amount0Desired\r\n            );\r\n        }\r\n\r\n        (\r\n            uint256 inAmount0,\r\n            uint256 inAmount1,\r\n            uint128 liquidityBefore,\r\n            uint128 liquiditySum\r\n        ) = _addLiquidity(cellarParams);\r\n\r\n        uint256 prevTotalSupply = _totalSupply;\r\n\r\n        if (liquidityBefore == 0) {\r\n            _mint(msg.sender, liquiditySum);\r\n        } else {\r\n            _mint(\r\n                msg.sender,\r\n                FullMath.mulDiv(liquiditySum, _totalSupply, liquidityBefore)\r\n            );\r\n        }\r\n\r\n        require(inAmount0 >= cellarParams.amount0Min, \"R16\");\r\n        require(inAmount1 >= cellarParams.amount1Min, \"R17\");\r\n        // check limitation\r\n        uint256 increasedSupply = _totalSupply - prevTotalSupply;\r\n        if (increasedSupply > 0) {\r\n            uint256 inPrice = totalPrice(inAmount0, inAmount1);\r\n            uint256 userPrice = FullMath.mulDiv(inPrice, _balances[msg.sender], increasedSupply);\r\n            require(userPrice <= 10000 * 10 ** 6, \"R31\"); // \"More than 10000 USD\"\r\n            uint256 total = FullMath.mulDiv(inPrice, _totalSupply, increasedSupply);\r\n            require(total <= 500000 * 10 ** 6, \"R32\"); // \"More than 500000 USD\"\r\n        }\r\n        //\r\n        uint256 retAmount0 = cellarParams.amount0Desired - inAmount0;\r\n        uint256 retAmount1 = cellarParams.amount1Desired - inAmount1;\r\n\r\n        if (retAmount0 > 0) {\r\n            if (token0 == WETH) {\r\n                IWETH(WETH).withdraw(retAmount0);\r\n                msg.sender.transfer(retAmount0);\r\n            } else {\r\n                IERC20(token0).safeTransfer(msg.sender, retAmount0);\r\n            }\r\n        }\r\n        if (retAmount1 > 0) {\r\n            if (token1 == WETH) {\r\n                IWETH(WETH).withdraw(retAmount1);\r\n                msg.sender.transfer(retAmount1);\r\n            } else {\r\n                IERC20(token1).safeTransfer(msg.sender, retAmount1);\r\n            }\r\n        }\r\n        emit AddedLiquidity(token0, token1, liquiditySum, inAmount0, inAmount1);\r\n    }\r\n\r\n    function removeLiquidityEthFromUniV3(\r\n        CellarRemoveParams calldata cellarParams\r\n    ) external override nonReentrant notLocked(msg.sender) {\r\n        lock(msg.sender);\r\n        require(block.timestamp <= cellarParams.deadline);\r\n        (uint256 outAmount0, uint256 outAmount1, uint128 liquiditySum) =\r\n            _removeLiquidity(cellarParams);\r\n        _burn(msg.sender, cellarParams.tokenAmount);\r\n\r\n        require(outAmount0 >= cellarParams.amount0Min, \"R16\");\r\n        require(outAmount1 >= cellarParams.amount1Min, \"R17\");\r\n\r\n        if (token0 == WETH) {\r\n            IWETH(WETH).withdraw(outAmount0);\r\n            msg.sender.transfer(outAmount0);\r\n            IERC20(token1).safeTransfer(msg.sender, outAmount1);\r\n        } else {\r\n            require(token1 == WETH, \"R19\");\r\n            IWETH(WETH).withdraw(outAmount1);\r\n            msg.sender.transfer(outAmount1);\r\n            IERC20(token0).safeTransfer(msg.sender, outAmount0);\r\n        }\r\n        emit RemovedLiquidity(\r\n            token0,\r\n            token1,\r\n            liquiditySum,\r\n            outAmount0,\r\n            outAmount1\r\n        );\r\n    }\r\n\r\n    function removeLiquidityFromUniV3(CellarRemoveParams calldata cellarParams)\r\n        external\r\n        override\r\n        notLocked(msg.sender)\r\n    {\r\n        lock(msg.sender);\r\n        require(block.timestamp <= cellarParams.deadline);\r\n        (uint256 outAmount0, uint256 outAmount1, uint128 liquiditySum) =\r\n            _removeLiquidity(cellarParams);\r\n        _burn(msg.sender, cellarParams.tokenAmount);\r\n\r\n        require(outAmount0 >= cellarParams.amount0Min, \"R16\");\r\n        require(outAmount1 >= cellarParams.amount1Min, \"R17\");\r\n\r\n        IERC20(token0).safeTransfer(msg.sender, outAmount0);\r\n        IERC20(token1).safeTransfer(msg.sender, outAmount1);\r\n        emit RemovedLiquidity(\r\n            token0,\r\n            token1,\r\n            liquiditySum,\r\n            outAmount0,\r\n            outAmount1\r\n        );\r\n    }\r\n\r\n    function invest() private {\r\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\r\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\r\n\r\n        (uint256 inAmount0, uint256 inAmount1, , ) =\r\n            _addLiquidity(\r\n                CellarAddParams({\r\n                    amount0Desired: balance0,\r\n                    amount1Desired: balance1,\r\n                    amount0Min: 0,\r\n                    amount1Min: 0,\r\n                    recipient: address(this),\r\n                    deadline: type(uint256).max\r\n                })\r\n            );\r\n        balance0 -= inAmount0;\r\n        balance1 -= inAmount1;\r\n        (uint160 sqrtPriceX96, , , , , , ) =\r\n            IUniswapV3Pool(\r\n                IUniswapV3Factory(UNISWAPV3FACTORY).getPool(\r\n                    token0,\r\n                    token1,\r\n                    feeLevel\r\n                )\r\n            )\r\n                .slot0();\r\n        if (balance0 * inAmount1 > balance1 * inAmount0 || (inAmount0 == 0 && inAmount1 == 0 && balance0 > balance1)) {\r\n            uint256 swapAmount = (balance0 * inAmount1 - balance1 * inAmount0)\r\n                /\r\n                (FullMath.mulDiv(\r\n                    FullMath.mulDiv(\r\n                        inAmount0,\r\n                        sqrtPriceX96,\r\n                        FixedPoint96.Q96),\r\n                    sqrtPriceX96,\r\n                    FixedPoint96.Q96)\r\n                + inAmount1);\r\n            if (inAmount0 == 0 && inAmount1 == 0) {\r\n                swapAmount = balance0 / 2;\r\n            }\r\n            IERC20(token0).safeApprove(SWAPROUTER, swapAmount);\r\n            try ISwapRouter(SWAPROUTER).exactInputSingle(\r\n                ISwapRouter.ExactInputSingleParams({\r\n                    tokenIn: token0,\r\n                    tokenOut: token1,\r\n                    fee: feeLevel,\r\n                    recipient: address(this),\r\n                    deadline: type(uint256).max,\r\n                    amountIn: swapAmount,\r\n                    amountOutMinimum: 0,\r\n                    sqrtPriceLimitX96: 0\r\n                })\r\n            ) {} catch {}\r\n            IERC20(token0).safeApprove(SWAPROUTER, 0);\r\n        }\r\n        if (balance0 * inAmount1 < balance1 * inAmount0 || (inAmount0 == 0 && inAmount1 == 0 && balance0 < balance1)) {\r\n            uint256 swapAmount = (balance1 * inAmount0 - balance0 * inAmount1)\r\n                /\r\n                (FullMath.mulDiv(\r\n                    FullMath.mulDiv(\r\n                        inAmount1,\r\n                        FixedPoint96.Q96,\r\n                        sqrtPriceX96),\r\n                    FixedPoint96.Q96,\r\n                    sqrtPriceX96)\r\n                + inAmount0);\r\n            if (inAmount0 == 0 && inAmount1 == 0) {\r\n                swapAmount = balance1 / 2;\r\n            }\r\n            IERC20(token1).safeApprove(SWAPROUTER, swapAmount);\r\n            try ISwapRouter(SWAPROUTER).exactInputSingle(\r\n                ISwapRouter.ExactInputSingleParams({\r\n                    tokenIn: token1,\r\n                    tokenOut: token0,\r\n                    fee: feeLevel,\r\n                    recipient: address(this),\r\n                    deadline: type(uint256).max,\r\n                    amountIn: swapAmount,\r\n                    amountOutMinimum: 0,\r\n                    sqrtPriceLimitX96: 0\r\n                })\r\n            ) {} catch {}\r\n            IERC20(token1).safeApprove(SWAPROUTER, 0);\r\n        }\r\n\r\n        balance0 = IERC20(token0).balanceOf(address(this));\r\n        balance1 = IERC20(token1).balanceOf(address(this));\r\n        _addLiquidity(\r\n            CellarAddParams({\r\n                amount0Desired: balance0,\r\n                amount1Desired: balance1,\r\n                amount0Min: 0,\r\n                amount1Min: 0,\r\n                recipient: address(this),\r\n                deadline: type(uint256).max\r\n            })\r\n        );\r\n    }\r\n\r\n    function reinvest() external override onlyValidator notLocked(msg.sender) {\r\n        CellarTickInfo[] memory _cellarTickInfo = cellarTickInfo;\r\n        uint256 weightSum;\r\n        uint256 balance0;\r\n        uint256 balance1;\r\n        for (uint256 index = 0; index < _cellarTickInfo.length; index++) {\r\n            require(_cellarTickInfo[index].tokenId != 0, \"R20\");//\"NFLP doesnot exist\"\r\n            weightSum += _cellarTickInfo[index].weight;\r\n            (uint256 amount0, uint256 amount1) =\r\n                INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER).collect(\r\n                    INonfungiblePositionManager.CollectParams({\r\n                        tokenId: _cellarTickInfo[index].tokenId,\r\n                        recipient: address(this),\r\n                        amount0Max: type(uint128).max,\r\n                        amount1Max: type(uint128).max\r\n                    })\r\n                );\r\n            balance0 += amount0;\r\n            balance1 += amount1;\r\n        }\r\n        uint256 fee0 = (balance0 * fee) / FEEDOMINATOR;\r\n        uint256 fee1 = (balance1 * fee) / FEEDOMINATOR;\r\n        if (fee0 > 0) {\r\n            IERC20(token0).safeTransfer(_owner, fee0);\r\n        }\r\n        if (fee1 > 0) {\r\n            IERC20(token1).safeTransfer(_owner, fee1);\r\n        }\r\n\r\n        invest();\r\n    }\r\n\r\n    function rebalance(CellarTickInfo[] memory _cellarTickInfo) external notLocked(msg.sender) {\r\n        require(msg.sender == _owner, \"R21\");//\"Not owner\"\r\n        CellarRemoveParams memory removeParams =\r\n            CellarRemoveParams({\r\n                tokenAmount: _totalSupply,\r\n                amount0Min: 0,\r\n                amount1Min: 0,\r\n                recipient: address(this),\r\n                deadline: type(uint256).max\r\n            });\r\n        _removeLiquidity(removeParams);\r\n        CellarTickInfo[] memory _oldCellarTickInfo = cellarTickInfo;\r\n        for (uint256 i = 0; i < _oldCellarTickInfo.length; i++) {\r\n            INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER).burn(\r\n                _oldCellarTickInfo[i].tokenId\r\n            );\r\n        }\r\n        delete cellarTickInfo;\r\n        for (uint256 i = 0; i < _cellarTickInfo.length; i++) {\r\n            require(_cellarTickInfo[i].tickUpper > _cellarTickInfo[i].tickLower, \"R12\");\r\n            if (i > 0) {\r\n                require(_cellarTickInfo[i].tickUpper <= _cellarTickInfo[i - 1].tickLower, \"R12\");\r\n            }\r\n            require(_cellarTickInfo[i].weight > 0, \"R10\");\r\n            require(_cellarTickInfo[i].tokenId == 0, \"R11\");\r\n            cellarTickInfo.push(_cellarTickInfo[i]);\r\n        }\r\n\r\n        invest();\r\n    }\r\n\r\n    function setValidator(address _validator, bool value) external override {\r\n        require(msg.sender == _owner, \"R21\");\r\n        validator[_validator] = value;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external override {\r\n        require(msg.sender == _owner, \"R21\");\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function setFee(uint16 newFee) external override {\r\n        require(msg.sender == _owner, \"R21\");\r\n        fee = newFee;\r\n    }\r\n\r\n    function owner() external view override returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function name() external view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external pure override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address owner_, address spender)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner_][spender];\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal {\r\n        require(sender != address(0), \"R22\");//\"transfer from zero address\"\r\n        require(recipient != address(0), \"R23\");//\"transfer to zero address\"\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"R24\");//\"transfer exceeds balance\"\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"R25\");//\"mint to zero address\"\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"R26\");//\"burn from zero address\"\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"R27\");//\"burn exceeds balance\"\r\n        _balances[account] = accountBalance - amount;\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner_,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal {\r\n        require(owner_ != address(0), \"R28\");//\"approve from zero address\"\r\n        require(spender != address(0), \"R29\");//\"approve to zero address\"\r\n\r\n        _allowances[owner_][spender] = amount;\r\n        emit Approval(owner_, spender, amount);\r\n    }\r\n\r\n    function _getWeightInfo(CellarTickInfo[] memory _cellarTickInfo)\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 weightSum0,\r\n            uint256 weightSum1,\r\n            uint128 liquidityBefore,\r\n            uint256[] memory weight0,\r\n            uint256[] memory weight1\r\n        )\r\n    {\r\n        weight0 = new uint256[](_cellarTickInfo.length);\r\n        weight1 = new uint256[](_cellarTickInfo.length);\r\n        (uint160 sqrtPriceX96, int24 currentTick, , , , , ) =\r\n            IUniswapV3Pool(\r\n                IUniswapV3Factory(UNISWAPV3FACTORY).getPool(\r\n                    token0,\r\n                    token1,\r\n                    feeLevel\r\n                )\r\n            )\r\n                .slot0();\r\n        UintPair memory sqrtPrice0;\r\n\r\n        uint256 weight00;\r\n        uint256 weight10;\r\n\r\n        sqrtPrice0.a = TickMath.getSqrtRatioAtTick(\r\n            _cellarTickInfo[0].tickLower\r\n        );\r\n        sqrtPrice0.b = TickMath.getSqrtRatioAtTick(\r\n            _cellarTickInfo[0].tickUpper\r\n        );\r\n\r\n        weight00 = _cellarTickInfo[0].weight;\r\n\r\n        weight10 = _cellarTickInfo[_cellarTickInfo.length - 1].weight;\r\n        for (uint16 i = 0; i < _cellarTickInfo.length; i++) {\r\n            if (_cellarTickInfo[i].tokenId > 0) {\r\n                (, , , , , , , uint128 liquidity, , , , ) =\r\n                    INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER)\r\n                        .positions(_cellarTickInfo[i].tokenId);\r\n                liquidityBefore += liquidity;\r\n            }\r\n\r\n            UintPair memory sqrtCurrentTickPriceX96;\r\n            sqrtCurrentTickPriceX96.a = TickMath.getSqrtRatioAtTick(\r\n                _cellarTickInfo[i].tickLower\r\n            );\r\n            sqrtCurrentTickPriceX96.b = TickMath.getSqrtRatioAtTick(\r\n                _cellarTickInfo[i].tickUpper\r\n            );\r\n\r\n            if (currentTick <= _cellarTickInfo[i].tickLower) {\r\n                weight0[i] =\r\n                    (FullMath.mulDiv(\r\n                        FullMath.mulDiv(\r\n                            FullMath.mulDiv(\r\n                                sqrtPrice0.a,\r\n                                sqrtPrice0.b,\r\n                                sqrtPrice0.b - sqrtPrice0.a\r\n                            ),\r\n                            sqrtCurrentTickPriceX96.b -\r\n                                sqrtCurrentTickPriceX96.a,\r\n                            sqrtCurrentTickPriceX96.b\r\n                        ),\r\n                        FixedPoint96.Q96,\r\n                        sqrtCurrentTickPriceX96.a\r\n                    ) * _cellarTickInfo[i].weight) /\r\n                    weight00;\r\n                weightSum0 += weight0[i];\r\n            } else if (currentTick >= _cellarTickInfo[i].tickUpper) {\r\n                weight1[i] =\r\n                    (FullMath.mulDiv(\r\n                        sqrtCurrentTickPriceX96.b - sqrtCurrentTickPriceX96.a,\r\n                        FixedPoint96.Q96,\r\n                        sqrtPrice0.b - sqrtPrice0.a\r\n                    ) * _cellarTickInfo[i].weight) /\r\n                    weight10;\r\n                weightSum1 += weight1[i];\r\n            } else {\r\n                weight0[i] =\r\n                    (FullMath.mulDiv(\r\n                        FullMath.mulDiv(\r\n                            FullMath.mulDiv(\r\n                                sqrtPrice0.a,\r\n                                sqrtPrice0.b,\r\n                                sqrtPrice0.b - sqrtPrice0.a\r\n                            ),\r\n                            sqrtCurrentTickPriceX96.b - sqrtPriceX96,\r\n                            sqrtCurrentTickPriceX96.b\r\n                        ),\r\n                        FixedPoint96.Q96,\r\n                        sqrtPriceX96\r\n                    ) * _cellarTickInfo[i].weight) /\r\n                    weight00;\r\n\r\n                weight1[i] =\r\n                    (FullMath.mulDiv(\r\n                        sqrtPriceX96 - sqrtCurrentTickPriceX96.a,\r\n                        FixedPoint96.Q96,\r\n                        sqrtPrice0.b - sqrtPrice0.a\r\n                    ) * _cellarTickInfo[i].weight) /\r\n                    weight10;\r\n                weightSum0 += weight0[i];\r\n                weightSum1 += weight1[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    function _modifyWeightInfo(\r\n        CellarTickInfo[] memory _cellarTickInfo,\r\n        uint256 amount0Desired,\r\n        uint256 amount1Desired,\r\n        uint256 weightSum0,\r\n        uint256 weightSum1,\r\n        uint256[] memory weight0,\r\n        uint256[] memory weight1\r\n    ) internal view returns (uint256 newWeightSum0, uint256 newWeightSum1) {\r\n        if (_cellarTickInfo.length == 1) {\r\n            return (weightSum0, weightSum1);\r\n        }\r\n\r\n        UintPair memory liquidity;\r\n        (uint160 sqrtPriceX96, , , , , , ) =\r\n            IUniswapV3Pool(\r\n                IUniswapV3Factory(UNISWAPV3FACTORY).getPool(\r\n                    token0,\r\n                    token1,\r\n                    feeLevel\r\n                )\r\n            )\r\n                .slot0();\r\n        liquidity.a = LiquidityAmounts.getLiquidityForAmounts(\r\n            sqrtPriceX96,\r\n            TickMath.getSqrtRatioAtTick(_cellarTickInfo[0].tickLower),\r\n            TickMath.getSqrtRatioAtTick(_cellarTickInfo[0].tickUpper),\r\n            FullMath.mulDiv(amount0Desired, weight0[0], weightSum0),\r\n            FullMath.mulDiv(amount1Desired, weight1[0], weightSum1)\r\n        );\r\n        uint256 tickLength = _cellarTickInfo.length - 1;\r\n        liquidity.b = LiquidityAmounts.getLiquidityForAmounts(\r\n            sqrtPriceX96,\r\n            TickMath.getSqrtRatioAtTick(_cellarTickInfo[tickLength].tickLower),\r\n            TickMath.getSqrtRatioAtTick(_cellarTickInfo[tickLength].tickUpper),\r\n            FullMath.mulDiv(amount0Desired, weight0[tickLength], weightSum0),\r\n            FullMath.mulDiv(amount1Desired, weight1[tickLength], weightSum1)\r\n        );\r\n\r\n        if (\r\n            liquidity.a * _cellarTickInfo[tickLength].weight >\r\n            liquidity.b * _cellarTickInfo[0].weight\r\n        ) {\r\n            if (liquidity.b * _cellarTickInfo[0].weight > 0) {\r\n                newWeightSum0 = FullMath.mulDiv(\r\n                    weightSum0,\r\n                    liquidity.a * _cellarTickInfo[tickLength].weight,\r\n                    liquidity.b * _cellarTickInfo[0].weight\r\n                );\r\n            }\r\n            else {\r\n                newWeightSum0 = 0;\r\n            }\r\n            newWeightSum1 = weightSum1;\r\n        } else {\r\n            newWeightSum0 = weightSum0;\r\n            if (liquidity.a * _cellarTickInfo[tickLength].weight > 0) {\r\n                newWeightSum1 = FullMath.mulDiv(\r\n                    weightSum1,\r\n                    liquidity.b * _cellarTickInfo[0].weight,\r\n                    liquidity.a * _cellarTickInfo[tickLength].weight\r\n                );\r\n            }\r\n            else {\r\n                newWeightSum1 = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _addLiquidity(CellarAddParams memory cellarParams)\r\n        internal\r\n        returns (\r\n            uint256 inAmount0,\r\n            uint256 inAmount1,\r\n            uint128 liquidityBefore,\r\n            uint128 liquiditySum\r\n        )\r\n    {\r\n        CellarTickInfo[] memory _cellarTickInfo = cellarTickInfo;\r\n        IERC20(token0).safeApprove(\r\n            NONFUNGIBLEPOSITIONMANAGER,\r\n            cellarParams.amount0Desired\r\n        );\r\n        IERC20(token1).safeApprove(\r\n            NONFUNGIBLEPOSITIONMANAGER,\r\n            cellarParams.amount1Desired\r\n        );\r\n\r\n        uint256 weightSum0;\r\n        uint256 weightSum1;\r\n        uint256[] memory weight0 = new uint256[](_cellarTickInfo.length);\r\n        uint256[] memory weight1 = new uint256[](_cellarTickInfo.length);\r\n\r\n        (\r\n            weightSum0,\r\n            weightSum1,\r\n            liquidityBefore,\r\n            weight0,\r\n            weight1\r\n        ) = _getWeightInfo(_cellarTickInfo);\r\n        if (weightSum0 > 0 && weightSum1 > 0) {\r\n            (weightSum0, weightSum1) = _modifyWeightInfo(\r\n                _cellarTickInfo,\r\n                cellarParams.amount0Desired,\r\n                cellarParams.amount1Desired,\r\n                weightSum0,\r\n                weightSum1,\r\n                weight0,\r\n                weight1\r\n            );\r\n        }\r\n\r\n        for (uint16 i = 0; i < _cellarTickInfo.length; i++) {\r\n            INonfungiblePositionManager.MintParams memory mintParams =\r\n                INonfungiblePositionManager.MintParams({\r\n                    token0: token0,\r\n                    token1: token1,\r\n                    fee: feeLevel,\r\n                    tickLower: _cellarTickInfo[i].tickLower,\r\n                    tickUpper: _cellarTickInfo[i].tickUpper,\r\n                    amount0Desired: 0,\r\n                    amount1Desired: 0,\r\n                    amount0Min: 0,\r\n                    amount1Min: 0,\r\n                    recipient: address(this),\r\n                    deadline: cellarParams.deadline\r\n                });\r\n\r\n                INonfungiblePositionManager.IncreaseLiquidityParams\r\n                    memory increaseLiquidityParams\r\n             =\r\n                INonfungiblePositionManager.IncreaseLiquidityParams({\r\n                    tokenId: _cellarTickInfo[i].tokenId,\r\n                    amount0Desired: 0,\r\n                    amount1Desired: 0,\r\n                    amount0Min: 0,\r\n                    amount1Min: 0,\r\n                    deadline: cellarParams.deadline\r\n                });\r\n            if (weightSum0 > 0) {\r\n                mintParams.amount0Desired = FullMath.mulDiv(\r\n                    cellarParams.amount0Desired,\r\n                    weight0[i],\r\n                    weightSum0\r\n                );\r\n                increaseLiquidityParams.amount0Desired = mintParams\r\n                    .amount0Desired;\r\n                mintParams.amount0Min = FullMath.mulDiv(\r\n                    cellarParams.amount0Min,\r\n                    weight0[i],\r\n                    weightSum0\r\n                );\r\n                increaseLiquidityParams.amount0Min = mintParams.amount0Min;\r\n            }\r\n            if (weightSum1 > 0) {\r\n                mintParams.amount1Desired = FullMath.mulDiv(\r\n                    cellarParams.amount1Desired,\r\n                    weight1[i],\r\n                    weightSum1\r\n                );\r\n                increaseLiquidityParams.amount1Desired = mintParams\r\n                    .amount1Desired;\r\n                mintParams.amount1Min = FullMath.mulDiv(\r\n                    cellarParams.amount1Min,\r\n                    weight1[i],\r\n                    weightSum1\r\n                );\r\n                increaseLiquidityParams.amount1Min = mintParams.amount1Min;\r\n            }\r\n            if (\r\n                mintParams.amount0Desired > 0 || mintParams.amount1Desired > 0\r\n            ) {\r\n                MintResult memory mintResult;\r\n                if (_cellarTickInfo[i].tokenId == 0) {\r\n\r\n                    try INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER)\r\n                        .mint(mintParams) returns (uint256 r1, uint128 r2, uint256 r3, uint256 r4) {\r\n                        mintResult.tokenId = r1;\r\n                        mintResult.liquidity = r2;\r\n                        mintResult.amount0 = r3;\r\n                        mintResult.amount1 = r4;\r\n                    } catch {}\r\n\r\n                    cellarTickInfo[i].tokenId = uint184(mintResult.tokenId);\r\n\r\n                    inAmount0 += mintResult.amount0;\r\n                    inAmount1 += mintResult.amount1;\r\n                    liquiditySum += mintResult.liquidity;\r\n                } else {\r\n                    try INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER)\r\n                        .increaseLiquidity(increaseLiquidityParams) returns (uint128 r1, uint256 r2, uint256 r3) {\r\n                        mintResult.liquidity = r1;\r\n                        mintResult.amount0 = r2;\r\n                        mintResult.amount1 = r3;\r\n                    } catch {}\r\n                    inAmount0 += mintResult.amount0;\r\n                    inAmount1 += mintResult.amount1;\r\n                    liquiditySum += mintResult.liquidity;\r\n                }\r\n            }\r\n        }\r\n        IERC20(token0).safeApprove(NONFUNGIBLEPOSITIONMANAGER, 0);\r\n        IERC20(token1).safeApprove(NONFUNGIBLEPOSITIONMANAGER, 0);\r\n    }\r\n\r\n    function _removeLiquidity(CellarRemoveParams memory cellarParams)\r\n        internal\r\n        returns (\r\n            uint256 outAmount0,\r\n            uint256 outAmount1,\r\n            uint128 liquiditySum\r\n        )\r\n    {\r\n        CellarTickInfo[] memory _cellarTickInfo = cellarTickInfo;\r\n        uint256 fee0;\r\n        uint256 fee1;\r\n        for (uint16 i = 0; i < _cellarTickInfo.length; i++) {\r\n            (, , , , , , , uint128 liquidity, , , , ) =\r\n                INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER)\r\n                    .positions(_cellarTickInfo[i].tokenId);\r\n            uint128 outLiquidity =\r\n                uint128(\r\n                    FullMath.mulDiv(\r\n                        liquidity,\r\n                        cellarParams.tokenAmount,\r\n                        _totalSupply\r\n                    )\r\n                );\r\n\r\n                INonfungiblePositionManager.DecreaseLiquidityParams\r\n                    memory decreaseLiquidityParams\r\n             =\r\n                INonfungiblePositionManager.DecreaseLiquidityParams({\r\n                    tokenId: _cellarTickInfo[i].tokenId,\r\n                    liquidity: outLiquidity,\r\n                    amount0Min: 0,\r\n                    amount1Min: 0,\r\n                    deadline: cellarParams.deadline\r\n                });\r\n            (uint256 amount0, uint256 amount1) =\r\n                INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER)\r\n                    .decreaseLiquidity(decreaseLiquidityParams);\r\n            (uint256 collectAmount0, uint256 collectAmount1) =\r\n                INonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER).collect(\r\n                    INonfungiblePositionManager.CollectParams({\r\n                        tokenId: _cellarTickInfo[i].tokenId,\r\n                        recipient: address(this),\r\n                        amount0Max: type(uint128).max,\r\n                        amount1Max: type(uint128).max\r\n                    })\r\n                );\r\n            fee0 += collectAmount0 - amount0;\r\n            fee1 += collectAmount1 - amount1;\r\n            outAmount0 += amount0;\r\n            outAmount1 += amount1;\r\n            liquiditySum += outLiquidity;\r\n        }\r\n        fee0 = (fee0 * fee) / FEEDOMINATOR;\r\n        fee1 = (fee1 * fee) / FEEDOMINATOR;\r\n        if (fee0 > 0) {\r\n            IERC20(token0).safeTransfer(_owner, fee0);\r\n        }\r\n        if (fee1 > 0) {\r\n            IERC20(token1).safeTransfer(_owner, fee1);\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    receive() external payable {}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"_feeLevel\",\"type\":\"uint24\"},{\"components\":[{\"internalType\":\"uint184\",\"name\":\"tokenId\",\"type\":\"uint184\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"weight\",\"type\":\"uint24\"}],\"internalType\":\"struct ICellarPoolShare.CellarTickInfo[]\",\"name\":\"_cellarTickInfo\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"AddedLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"RemovedLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount0Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ICellarPoolShare.CellarAddParams\",\"name\":\"cellarParams\",\"type\":\"tuple\"}],\"name\":\"addLiquidityEthForUniV3\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount0Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ICellarPoolShare.CellarAddParams\",\"name\":\"cellarParams\",\"type\":\"tuple\"}],\"name\":\"addLiquidityForUniV3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cellarTickInfo\",\"outputs\":[{\"internalType\":\"uint184\",\"name\":\"tokenId\",\"type\":\"uint184\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"weight\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLevel\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastLockedBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint184\",\"name\":\"tokenId\",\"type\":\"uint184\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"weight\",\"type\":\"uint24\"}],\"internalType\":\"struct ICellarPoolShare.CellarTickInfo[]\",\"name\":\"_cellarTickInfo\",\"type\":\"tuple[]\"}],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ICellarPoolShare.CellarRemoveParams\",\"name\":\"cellarParams\",\"type\":\"tuple\"}],\"name\":\"removeLiquidityEthFromUniV3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ICellarPoolShare.CellarRemoveParams\",\"name\":\"cellarParams\",\"type\":\"tuple\"}],\"name\":\"removeLiquidityFromUniV3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newFee\",\"type\":\"uint16\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"validator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CellarPoolShareLimitETHUSDT","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000000000000000000000000000000000000000000bb80000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000002743656c6c617220506f6f6c205368617265204c696d697465642054657374204554482055534454000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004435053540000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd40e0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffccbb00000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://bba34a499884730da9683b8a49a98ca73c9d7d1434d2761008625fe6694c9f69"}]}