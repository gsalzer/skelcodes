{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/MuonV02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./SchnorrSECP256K1.sol\\\";\\n\\ncontract MuonV02 is Ownable {\\n\\n    event Transaction(bytes reqId, address[] groups);\\n\\n    SchnorrSECP256K1 schnorr;\\n\\n    struct PublicKey {\\n        uint256 x;\\n        uint8 parity;\\n    }\\n\\n    struct SchnorrSign {\\n        uint256 signature;\\n        address owner;\\n        address nonce;\\n    }\\n\\n    mapping(address => PublicKey) public groupsPubKey;\\n\\n    constructor(address _schnorrLib, address _groupAddress, uint256 _groupPubKeyX, uint8 _groupPubKeyYParity){\\n        schnorr = SchnorrSECP256K1(_schnorrLib);\\n        addGroupPublicKey(_groupAddress, _groupPubKeyX, _groupPubKeyYParity);\\n    }\\n\\n    function verify(bytes calldata _reqId, uint256 _hash, SchnorrSign[] calldata _sigs) public returns (bool) \\n    {\\n        require(_sigs.length > 0, '!_sigs');\\n\\n        PublicKey memory pub;\\n        address[] memory groups = new address[](_sigs.length);\\n        for(uint i=0 ; i<_sigs.length; i++){\\n            pub = groupsPubKey[_sigs[i].owner];\\n            if(pub.x == 0)\\n                return false;\\n            if(!schnorr.verifySignature(pub.x, pub.parity, _sigs[i].signature, _hash, _sigs[i].nonce) || (i>0 && _sigs[i].owner <= groups[i-1]))\\n                return false;\\n            groups[i] = _sigs[i].owner;\\n        }\\n        emit Transaction(_reqId, groups);\\n        return true;\\n    }\\n\\n    function addGroupPublicKey(address _address, uint256 _pubX, uint8 _pubYParity) public onlyOwner {\\n        schnorr.validatePubKey(_pubX);\\n        groupsPubKey[_address] = PublicKey(_pubX, _pubYParity);\\n    }\\n\\n    function removeGroupPublicKey(address _groupAddress) public onlyOwner {\\n        delete groupsPubKey[_groupAddress];\\n    }\\n\\n    function setLibAddress(address _schnorrLib) public onlyOwner {\\n        schnorr = SchnorrSECP256K1(_schnorrLib);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/SchnorrSECP256K1.sol\": {\r\n      \"content\": \"pragma solidity  >=0.7.0 <0.9.0;\\n\\ncontract SchnorrSECP256K1 {\\n  // See https://en.bitcoin.it/wiki/Secp256k1 for this constant.\\n  uint256 constant public Q = // Group order of secp256k1\\n    // solium-disable-next-line indentation\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\\n  // solium-disable-next-line zeppelin/no-arithmetic-operations\\n  uint256 constant public HALF_Q = (Q >> 1) + 1;\\n\\n  /** **************************************************************************\\n      @notice verifySignature returns true iff passed a valid Schnorr signature.\\n      @dev See https://en.wikipedia.org/wiki/Schnorr_signature for reference.\\n      @dev In what follows, let d be your secret key, PK be your public key,\\n      PKx be the x ordinate of your public key, and PKyp be the parity bit for\\n      the y ordinate (i.e., 0 if PKy is even, 1 if odd.)\\n      **************************************************************************\\n      @dev TO CREATE A VALID SIGNATURE FOR THIS METHOD\\n      @dev First PKx must be less than HALF_Q. Then follow these instructions\\n           (see evm/test/schnorr_test.js, for an example of carrying them out):\\n      @dev 1. Hash the target message to a uint256, called msgHash here, using\\n              keccak256\\n      @dev 2. Pick k uniformly and cryptographically securely randomly from\\n              {0,...,Q-1}. It is critical that k remains confidential, as your\\n              private key can be reconstructed from k and the signature.\\n      @dev 3. Compute k*g in the secp256k1 group, where g is the group\\n              generator. (This is the same as computing the public key from the\\n              secret key k. But it's OK if k*g's x ordinate is greater than\\n              HALF_Q.)\\n      @dev 4. Compute the ethereum address for k*g. This is the lower 160 bits\\n              of the keccak hash of the concatenated affine coordinates of k*g,\\n              as 32-byte big-endians. (For instance, you could pass k to\\n              ethereumjs-utils's privateToAddress to compute this, though that\\n              should be strictly a development convenience, not for handling\\n              live secrets, unless you've locked your javascript environment\\n              down very carefully.) Call this address\\n              nonceTimesGeneratorAddress.\\n      @dev 5. Compute e=uint256(keccak256(PKx as a 32-byte big-endian\\n                                        ‖ PKyp as a single byte\\n                                        ‖ msgHash\\n                                        ‖ nonceTimesGeneratorAddress))\\n              This value e is called \\\"msgChallenge\\\" in verifySignature's source\\n              code below. Here \\\"‖\\\" means concatenation of the listed byte\\n              arrays.\\n      @dev 6. Let x be your secret key. Compute s = (k - d * e) % Q. Add Q to\\n              it, if it's negative. This is your signature. (d is your secret\\n              key.)\\n      **************************************************************************\\n      @dev TO VERIFY A SIGNATURE\\n      @dev Given a signature (s, e) of msgHash, constructed as above, compute\\n      S=e*PK+s*generator in the secp256k1 group law, and then the ethereum\\n      address of S, as described in step 4. Call that\\n      nonceTimesGeneratorAddress. Then call the verifySignature method as:\\n      @dev    verifySignature(PKx, PKyp, s, msgHash,\\n                              nonceTimesGeneratorAddress)\\n      **************************************************************************\\n      @dev This signging scheme deviates slightly from the classical Schnorr\\n      signature, in that the address of k*g is used in place of k*g itself,\\n      both when calculating e and when verifying sum S as described in the\\n      verification paragraph above. This reduces the difficulty of\\n      brute-forcing a signature by trying random secp256k1 points in place of\\n      k*g in the signature verification process from 256 bits to 160 bits.\\n      However, the difficulty of cracking the public key using \\\"baby-step,\\n      giant-step\\\" is only 128 bits, so this weakening constitutes no compromise\\n      in the security of the signatures or the key.\\n      @dev The constraint signingPubKeyX < HALF_Q comes from Eq. (281), p. 24\\n      of Yellow Paper version 78d7b9a. ecrecover only accepts \\\"s\\\" inputs less\\n      than HALF_Q, to protect against a signature- malleability vulnerability in\\n      ECDSA. Schnorr does not have this vulnerability, but we must account for\\n      ecrecover's defense anyway. And since we are abusing ecrecover by putting\\n      signingPubKeyX in ecrecover's \\\"s\\\" argument the constraint applies to\\n      signingPubKeyX, even though it represents a value in the base field, and\\n      has no natural relationship to the order of the curve's cyclic group.\\n      **************************************************************************\\n      @param signingPubKeyX is the x ordinate of the public key. This must be\\n             less than HALF_Q. \\n      @param pubKeyYParity is 0 if the y ordinate of the public key is even, 1 \\n             if it's odd.\\n      @param signature is the actual signature, described as s in the above\\n             instructions.\\n      @param msgHash is a 256-bit hash of the message being signed.\\n      @param nonceTimesGeneratorAddress is the ethereum address of k*g in the\\n             above instructions\\n      **************************************************************************\\n      @return True if passed a valid signature, false otherwise. */\\n  function verifySignature(\\n    uint256 signingPubKeyX,\\n    uint8 pubKeyYParity,\\n    uint256 signature,\\n    uint256 msgHash,\\n    address nonceTimesGeneratorAddress) external pure returns (bool) {\\n    require(signingPubKeyX < HALF_Q, \\\"Public-key x >= HALF_Q\\\");\\n    // Avoid signature malleability from multiple representations for ℤ/Qℤ elts\\n    require(signature < Q, \\\"signature must be reduced modulo Q\\\");\\n\\n    // Forbid trivial inputs, to avoid ecrecover edge cases. The main thing to\\n    // avoid is something which causes ecrecover to return 0x0: then trivial\\n    // signatures could be constructed with the nonceTimesGeneratorAddress input\\n    // set to 0x0.\\n    //\\n    // solium-disable-next-line indentation\\n    require(nonceTimesGeneratorAddress != address(0) && signingPubKeyX > 0 &&\\n      signature > 0 && msgHash > 0, \\\"no zero inputs allowed\\\");\\n\\n    // solium-disable-next-line indentation\\n    uint256 msgChallenge = // \\\"e\\\"\\n      // solium-disable-next-line indentation\\n      uint256(keccak256(abi.encodePacked(nonceTimesGeneratorAddress, msgHash)));\\n\\n    // Verify msgChallenge * signingPubKey + signature * generator ==\\n    //        nonce * generator\\n    //\\n    // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\\n    // The point corresponding to the address returned by\\n    // ecrecover(-s*r,v,r,e*r) is (r⁻¹ mod Q)*(e*r*R-(-s)*r*g)=e*R+s*g, where R\\n    // is the (v,r) point. See https://crypto.stackexchange.com/a/18106\\n    //\\n    // solium-disable-next-line indentation\\n    address recoveredAddress = ecrecover(\\n      // solium-disable-next-line zeppelin/no-arithmetic-operations\\n      bytes32(Q - mulmod(signingPubKeyX, signature, Q)),\\n      // https://ethereum.github.io/yellowpaper/paper.pdf p. 24, \\\"The\\n      // value 27 represents an even y value and 28 represents an odd\\n      // y value.\\\"\\n      (pubKeyYParity == 0) ? 27 : 28,\\n      bytes32(signingPubKeyX),\\n      bytes32(mulmod(msgChallenge, signingPubKeyX, Q)));\\n    return nonceTimesGeneratorAddress == recoveredAddress;\\n  }\\n\\n  function validatePubKey (uint256 signingPubKeyX) external pure {\\n    require(signingPubKeyX < HALF_Q, \\\"Public-key x >= HALF_Q\\\");\\n  }\\n}\\n\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_schnorrLib\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_groupAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_groupPubKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_groupPubKeyYParity\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"reqId\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"groups\",\"type\":\"address[]\"}],\"name\":\"Transaction\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pubX\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_pubYParity\",\"type\":\"uint8\"}],\"name\":\"addGroupPublicKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"groupsPubKey\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"parity\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_groupAddress\",\"type\":\"address\"}],\"name\":\"removeGroupPublicKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_schnorrLib\",\"type\":\"address\"}],\"name\":\"setLibAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_reqId\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_hash\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"signature\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nonce\",\"type\":\"address\"}],\"internalType\":\"struct MuonV02.SchnorrSign[]\",\"name\":\"_sigs\",\"type\":\"tuple[]\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MuonV02","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000043a544dd24cb10975b7de1deec49e77f652dac66000000000000000000000000464b7df5f9171d5a27a22ca8ea20bfb59b83cfc2723485167650fce02741e1d89aaa51e09b3af91e1b4a7e2c4bb42765d9828ede0000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}