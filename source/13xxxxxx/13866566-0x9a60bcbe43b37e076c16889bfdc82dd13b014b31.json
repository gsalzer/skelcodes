{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libs/MarginalFunctionality.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\nimport \\\"../PriceOracleInterface.sol\\\";\\n\\nlibrary MarginalFunctionality {\\n\\n    // We have the following approach: when liability is created we store\\n    // timestamp and size of liability. If the subsequent trade will deepen\\n    // this liability or won't fully cover it timestamp will not change.\\n    // However once outstandingAmount is covered we check whether balance on\\n    // that asset is positive or not. If not, liability still in the place but\\n    // time counter is dropped and timestamp set to `now`.\\n    struct Liability {\\n        address asset;\\n        uint64 timestamp;\\n        uint192 outstandingAmount;\\n    }\\n\\n    enum PositionState {\\n        POSITIVE,\\n        NEGATIVE, // weighted position below 0\\n        OVERDUE,  // liability is not returned for too long\\n        NOPRICE,  // some assets has no price or expired\\n        INCORRECT // some of the basic requirements are not met: too many liabilities, no locked stake, etc\\n    }\\n\\n    struct Position {\\n        PositionState state;\\n        int256 weightedPosition; // sum of weighted collateral minus liabilities\\n        int256 totalPosition; // sum of unweighted (total) collateral minus liabilities\\n        int256 totalLiabilities; // total liabilities value\\n    }\\n\\n    // Constants from Exchange contract used for calculations\\n    struct UsedConstants {\\n        address user;\\n        address _oracleAddress;\\n        address _orionTokenAddress;\\n        uint64 positionOverdue;\\n        uint64 priceOverdue;\\n        uint8 stakeRisk;\\n        uint8 liquidationPremium;\\n    }\\n\\n\\n    /**\\n     * @dev method to multiply numbers with uint8 based percent numbers\\n     */\\n    function uint8Percent(int192 _a, uint8 b) internal pure returns (int192 c) {\\n        int a = int256(_a);\\n        int d = 255;\\n        c = int192((a>65536) ? (a/d)*b : a*b/d );\\n    }\\n\\n    /**\\n     * @dev method to fetch asset prices in ORN tokens\\n     */\\n    function getAssetPrice(address asset, address oracle) internal view returns (uint64 price, uint64 timestamp) {\\n        PriceOracleInterface.PriceDataOut memory assetPriceData = PriceOracleInterface(oracle).assetPrices(asset);\\n        (price, timestamp) = (assetPriceData.price, assetPriceData.timestamp);\\n    }\\n\\n    /**\\n     * @dev method to calc weighted and absolute collateral value\\n     * @notice it only count for assets in collateralAssets list, all other\\n               assets will add 0 to position.\\n     * @return outdated whether any price is outdated\\n     * @return weightedPosition in ORN\\n     * @return totalPosition in ORN\\n     */\\n    function calcAssets(\\n        address[] storage collateralAssets,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => uint8) storage assetRisks,\\n        address user,\\n        address orionTokenAddress,\\n        address oracleAddress,\\n        uint64 priceOverdue\\n    ) internal view returns (bool outdated, int192 weightedPosition, int192 totalPosition) {\\n        uint256 collateralAssetsLength = collateralAssets.length;\\n        for(uint256 i = 0; i < collateralAssetsLength; i++) {\\n            address asset = collateralAssets[i];\\n            if(assetBalances[user][asset]<0)\\n                continue; // will be calculated in calcLiabilities\\n            (uint64 price, uint64 timestamp) = (1e8, 0xfffffff000000000);\\n\\n            if(asset != orionTokenAddress) {\\n                (price, timestamp) = getAssetPrice(asset, oracleAddress);\\n            }\\n\\n            // balance: i192, price u64 => balance*price fits i256\\n            // since generally balance <= N*maxInt112 (where N is number operations with it),\\n            // assetValue <= N*maxInt112*maxUInt64/1e8.\\n            // That is if N<= 2**17 *1e8 = 1.3e13  we can neglect overflows here\\n\\n            uint8 specificRisk = assetRisks[asset];\\n            int192 balance = assetBalances[user][asset];\\n            int256 _assetValue = int256(balance)*price/1e8;\\n            int192 assetValue = int192(_assetValue);\\n\\n            // Overflows logic holds here as well, except that N is the number of\\n            // operations for all assets\\n\\n            if(assetValue>0) {\\n                weightedPosition += uint8Percent(assetValue, specificRisk);\\n                totalPosition += assetValue;\\n                outdated = outdated || ((timestamp + priceOverdue) < block.timestamp);\\n            }\\n\\n        }\\n\\n        return (outdated, weightedPosition, totalPosition);\\n    }\\n\\n    /**\\n     * @dev method to calc liabilities\\n     * @return outdated whether any price is outdated\\n     * @return overdue whether any liability is overdue\\n     * @return weightedPosition weightedLiability == totalLiability in ORN\\n     * @return totalPosition totalLiability in ORN\\n     */\\n    function calcLiabilities(\\n        mapping(address => Liability[]) storage liabilities,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        address user,\\n        address oracleAddress,\\n        uint64 positionOverdue,\\n        uint64 priceOverdue\\n    ) internal view returns  (bool outdated, bool overdue, int192 weightedPosition, int192 totalPosition) {\\n        uint256 liabilitiesLength = liabilities[user].length;\\n\\n        for(uint256 i = 0; i < liabilitiesLength; i++) {\\n            Liability storage liability = liabilities[user][i];\\n            int192 balance = assetBalances[user][liability.asset];\\n            (uint64 price, uint64 timestamp) = getAssetPrice(liability.asset, oracleAddress);\\n            // balance: i192, price u64 => balance*price fits i256\\n            // since generally balance <= N*maxInt112 (where N is number operations with it),\\n            // assetValue <= N*maxInt112*maxUInt64/1e8.\\n            // That is if N<= 2**17 *1e8 = 1.3e13  we can neglect overflows here\\n\\n            int192 liabilityValue = int192(int256(balance) * price / 1e8);\\n            weightedPosition += liabilityValue; //already negative since balance is negative\\n            totalPosition += liabilityValue;\\n            overdue = overdue || ((liability.timestamp + positionOverdue) < block.timestamp);\\n            outdated = outdated || ((timestamp + priceOverdue) < block.timestamp);\\n        }\\n\\n        return (outdated, overdue, weightedPosition, totalPosition);\\n    }\\n\\n    /**\\n     * @dev method to calc Position\\n     * @return result position structure\\n     */\\n    function calcPosition(\\n        address[] storage collateralAssets,\\n        mapping(address => Liability[]) storage liabilities,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => uint8) storage assetRisks,\\n        UsedConstants memory constants\\n    ) public view returns (Position memory result) {\\n\\n        (bool outdatedPrice, int192 weightedPosition, int192 totalPosition) =\\n        calcAssets(\\n            collateralAssets,\\n            assetBalances,\\n            assetRisks,\\n            constants.user,\\n            constants._orionTokenAddress,\\n            constants._oracleAddress,\\n            constants.priceOverdue\\n        );\\n\\n        (bool _outdatedPrice, bool overdue, int192 _weightedPosition, int192 _totalPosition) =\\n        calcLiabilities(\\n            liabilities,\\n            assetBalances,\\n            constants.user,\\n            constants._oracleAddress,\\n            constants.positionOverdue,\\n            constants.priceOverdue\\n        );\\n\\n        weightedPosition += _weightedPosition;\\n        totalPosition += _totalPosition;\\n        outdatedPrice = outdatedPrice || _outdatedPrice;\\n        if(_totalPosition<0) {\\n            result.totalLiabilities = _totalPosition;\\n        }\\n        if(weightedPosition<0) {\\n            result.state = PositionState.NEGATIVE;\\n        }\\n        if(outdatedPrice) {\\n            result.state = PositionState.NOPRICE;\\n        }\\n        if(overdue) {\\n            result.state = PositionState.OVERDUE;\\n        }\\n        result.weightedPosition = weightedPosition;\\n        result.totalPosition = totalPosition;\\n    }\\n\\n    /**\\n     * @dev method removes liability\\n     */\\n    function removeLiability(\\n        address user,\\n        address asset,\\n        mapping(address => Liability[]) storage liabilities\\n    ) public {\\n        uint256 length = liabilities[user].length;\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            if (liabilities[user][i].asset == asset) {\\n                if (length>1) {\\n                    liabilities[user][i] = liabilities[user][length - 1];\\n                }\\n                liabilities[user].pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev method update liability\\n     * @notice implement logic for outstandingAmount (see Liability description)\\n     */\\n    function updateLiability(address user,\\n        address asset,\\n        mapping(address => Liability[]) storage liabilities,\\n        uint112 depositAmount,\\n        int192 currentBalance\\n    ) internal {\\n        if(currentBalance>=0) {\\n            removeLiability(user,asset,liabilities);\\n        } else {\\n            uint256 i;\\n            uint256 liabilitiesLength=liabilities[user].length;\\n            for(; i<liabilitiesLength-1; i++) {\\n                if(liabilities[user][i].asset == asset)\\n                    break;\\n            }\\n            Liability storage liability = liabilities[user][i];\\n            if(depositAmount>=liability.outstandingAmount) {\\n                liability.outstandingAmount = uint192(-currentBalance);\\n                liability.timestamp = uint64(block.timestamp);\\n            } else {\\n                liability.outstandingAmount -= depositAmount;\\n            }\\n        }\\n    }\\n\\n\\n    /**\\n     * @dev partially liquidate, that is cover some asset liability to get\\n            ORN from misbehavior broker\\n     */\\n    function partiallyLiquidate(address[] storage collateralAssets,\\n        mapping(address => Liability[]) storage liabilities,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        mapping(address => uint8) storage assetRisks,\\n        UsedConstants memory constants,\\n        address redeemedAsset,\\n        uint112 amount) public {\\n        //Note: constants.user - is broker who will be liquidated\\n        Position memory initialPosition = calcPosition(collateralAssets,\\n            liabilities,\\n            assetBalances,\\n            assetRisks,\\n            constants);\\n        require(initialPosition.state == PositionState.NEGATIVE ||\\n            initialPosition.state == PositionState.OVERDUE  , \\\"E7\\\");\\n        address liquidator = msg.sender;\\n        require(assetBalances[liquidator][redeemedAsset]>=amount,\\\"E8\\\");\\n        require(assetBalances[constants.user][redeemedAsset]<0,\\\"E15\\\");\\n        assetBalances[liquidator][redeemedAsset] -= amount;\\n        assetBalances[constants.user][redeemedAsset] += amount;\\n\\n        if(assetBalances[constants.user][redeemedAsset] >= 0)\\n            removeLiability(constants.user, redeemedAsset, liabilities);\\n\\n        (uint64 price, uint64 timestamp) = getAssetPrice(redeemedAsset, constants._oracleAddress);\\n        require((timestamp + constants.priceOverdue) > block.timestamp, \\\"E9\\\"); //Price is outdated\\n\\n        reimburseLiquidator(\\n            amount,\\n            price,\\n            liquidator,\\n            assetBalances,\\n            constants.liquidationPremium,\\n            constants.user,\\n            constants._orionTokenAddress\\n        );\\n\\n        Position memory finalPosition = calcPosition(collateralAssets,\\n            liabilities,\\n            assetBalances,\\n            assetRisks,\\n            constants);\\n        require( int(finalPosition.state)<3 && //POSITIVE,NEGATIVE or OVERDUE\\n            (finalPosition.weightedPosition>initialPosition.weightedPosition),\\n            \\\"E10\\\");//Incorrect state position after liquidation\\n        if(finalPosition.state == PositionState.POSITIVE)\\n            require (finalPosition.weightedPosition<10e8,\\\"Can not liquidate to very positive state\\\");\\n\\n    }\\n\\n    /**\\n     * @dev reimburse liquidator with ORN: first from stake, than from broker balance\\n     */\\n    function reimburseLiquidator(\\n        uint112 amount,\\n        uint64 price,\\n        address liquidator,\\n        mapping(address => mapping(address => int192)) storage assetBalances,\\n        uint8 liquidationPremium,\\n        address user,\\n        address orionTokenAddress\\n    ) internal {\\n        int192 _orionAmount = int192(int256(amount)*price/1e8);\\n        _orionAmount += uint8Percent(_orionAmount, liquidationPremium); //Liquidation premium\\n        // There is only 100m Orion tokens, fits i64\\n        require(_orionAmount == int64(_orionAmount), \\\"E11\\\");\\n        int192 onBalanceOrion = assetBalances[user][orionTokenAddress];\\n\\n        require(onBalanceOrion >= _orionAmount, \\\"E10\\\");\\n        assetBalances[user][orionTokenAddress] -= _orionAmount;\\n        assetBalances[liquidator][orionTokenAddress] += _orionAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PriceOracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./PriceOracleDataTypes.sol\\\";\\n\\ninterface PriceOracleInterface is PriceOracleDataTypes {\\n    function assetPrices(address) external view returns (PriceDataOut memory);\\n    function givePrices(address[] calldata assetAddresses) external view returns (PriceDataOut[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/PriceOracleDataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\n\\ninterface PriceOracleDataTypes {\\n    struct PriceDataOut {\\n        uint64 price;\\n        uint64 timestamp;\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[]","ContractName":"MarginalFunctionality","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}