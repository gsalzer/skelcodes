{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocol/lendingpool/LendingPoolCompatible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../../interfaces/ILendingPoolAaveCompatible.sol';\\nimport './LendingPool.sol';\\n\\n/// @dev LendingPoolCompatible is a wrapper for backward compatibility with AAVE due to modified referral field format.\\ncontract LendingPoolCompatible is LendingPool, ILendingPoolAaveCompatible {\\n  function deposit(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    uint16 referral\\n  ) external override {\\n    super.deposit(asset, amount, onBehalfOf, uint256(referral));\\n  }\\n\\n  function borrow(\\n    address,\\n    uint256,\\n    uint256,\\n    uint16,\\n    address\\n  ) external override {\\n    _delegate(_extension);\\n  }\\n\\n  function flashLoan(\\n    address,\\n    address[] calldata,\\n    uint256[] calldata,\\n    uint256[] calldata,\\n    address,\\n    bytes calldata,\\n    uint16\\n  ) external override {\\n    _delegate(_extension);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPoolAaveCompatible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\n/// @dev ILendingPoolAaveCompatible uses uint16 referral for full backward compatibility with AAVE\\ninterface ILendingPoolAaveCompatible {\\n  function deposit(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    uint16 referral\\n  ) external;\\n\\n  function borrow(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode,\\n    uint16 referral,\\n    address onBehalfOf\\n  ) external;\\n\\n  function flashLoan(\\n    address receiverAddress,\\n    address[] calldata assets,\\n    uint256[] calldata amounts,\\n    uint256[] calldata modes,\\n    address onBehalfOf,\\n    bytes calldata params,\\n    uint16 referral\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/lendingpool/LendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport '../../dependencies/openzeppelin/contracts/SafeERC20.sol';\\nimport '../../dependencies/openzeppelin/contracts/Address.sol';\\nimport '../../access/interfaces/IMarketAccessController.sol';\\nimport '../../access/AccessHelper.sol';\\nimport '../../interfaces/IDepositToken.sol';\\nimport '../../interfaces/IVariableDebtToken.sol';\\nimport '../../interfaces/ILendingPool.sol';\\nimport '../../interfaces/ILendingPoolForTokens.sol';\\nimport '../../flashloan/interfaces/IFlashLoanReceiver.sol';\\nimport '../../interfaces/IStableDebtToken.sol';\\nimport '../../tools/upgradeability/Delegator.sol';\\nimport '../../tools/Errors.sol';\\nimport '../../tools/math/WadRayMath.sol';\\nimport '../libraries/helpers/Helpers.sol';\\nimport '../libraries/logic/GenericLogic.sol';\\nimport '../libraries/logic/ValidationLogic.sol';\\nimport '../libraries/logic/ReserveLogic.sol';\\nimport '../libraries/types/DataTypes.sol';\\nimport './LendingPoolBase.sol';\\n\\n/**\\n * @title LendingPool contract\\n * @dev Main point of interaction with a protocol's market\\n * - Users can:\\n *   # Deposit\\n *   # Withdraw\\n *   # Borrow\\n *   # Repay\\n *   # Swap their loans between variable and stable rate\\n *   # Enable/disable their deposits as collateral rebalance stable rate borrow positions\\n *   # Liquidate positions\\n *   # Execute Flash Loans\\n **/\\ncontract LendingPool is LendingPoolBase, ILendingPool, Delegator, ILendingPoolForTokens {\\n  using SafeERC20 for IERC20;\\n  using WadRayMath for uint256;\\n  using AccessHelper for IMarketAccessController;\\n  using ReserveLogic for DataTypes.ReserveData;\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n  using UserConfiguration for DataTypes.UserConfigurationMap;\\n\\n  uint256 private constant POOL_REVISION = 0x1;\\n\\n  function getRevision() internal pure virtual override returns (uint256) {\\n    return POOL_REVISION;\\n  }\\n\\n  function initialize(IMarketAccessController provider) public initializer(POOL_REVISION) {\\n    _addressesProvider = provider;\\n    _maxStableRateBorrowSizePct = 25 * PercentageMath.PCT;\\n    _flashLoanPremiumPct = 9 * PercentageMath.BP;\\n  }\\n\\n  // solhint-disable-next-line payable-fallback\\n  fallback() external {\\n    // all IManagedLendingPool etc functions should be delegated to the extension\\n    _delegate(_extension);\\n  }\\n\\n  function deposit(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    uint256 referral\\n  ) public override whenNotPaused noReentryOrFlashloanFeature(FEATURE_FLASHLOAN_DEPOSIT) {\\n    DataTypes.ReserveData storage reserve = _reserves[asset];\\n\\n    ValidationLogic.validateDeposit(reserve, amount);\\n\\n    address depositToken = reserve.depositTokenAddress;\\n\\n    uint256 liquidityIndex = reserve.updateStateForDeposit(asset);\\n    reserve.updateInterestRates(asset, depositToken, amount, 0);\\n\\n    IERC20(asset).safeTransferFrom(msg.sender, depositToken, amount);\\n\\n    bool isFirstDeposit = IDepositToken(depositToken).mint(onBehalfOf, amount, liquidityIndex, false);\\n\\n    if (isFirstDeposit) {\\n      _usersConfig[onBehalfOf].setUsingAsCollateral(reserve.id);\\n      emit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\\n    }\\n\\n    emit Deposit(asset, msg.sender, onBehalfOf, amount, referral);\\n  }\\n\\n  function withdraw(\\n    address asset,\\n    uint256 amountToWithdraw,\\n    address to\\n  ) external override whenNotPaused noReentryOrFlashloanFeature(FEATURE_FLASHLOAN_WITHDRAW) returns (uint256) {\\n    DataTypes.ReserveData storage reserve = _reserves[asset];\\n\\n    address depositToken = reserve.depositTokenAddress;\\n    uint256 liquidityIndex = reserve.updateStateForDeposit(asset);\\n\\n    uint256 userBalance = IDepositToken(depositToken).scaledBalanceOf(msg.sender);\\n    userBalance = userBalance.rayMul(liquidityIndex);\\n\\n    if (amountToWithdraw == type(uint256).max) {\\n      amountToWithdraw = userBalance;\\n    }\\n\\n    ValidationLogic.validateWithdraw(\\n      asset,\\n      amountToWithdraw,\\n      userBalance,\\n      _reserves,\\n      _usersConfig[msg.sender],\\n      _reservesList,\\n      _addressesProvider.getPriceOracle()\\n    );\\n\\n    reserve.updateInterestRates(asset, depositToken, 0, amountToWithdraw);\\n\\n    if (amountToWithdraw == userBalance) {\\n      _usersConfig[msg.sender].unsetUsingAsCollateral(reserve.id);\\n      emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\\n    }\\n\\n    IDepositToken(depositToken).burn(msg.sender, to, amountToWithdraw, liquidityIndex);\\n\\n    emit Withdraw(asset, msg.sender, to, amountToWithdraw);\\n\\n    return amountToWithdraw;\\n  }\\n\\n  function borrow(\\n    address,\\n    uint256,\\n    uint256,\\n    uint256,\\n    address\\n  ) external override {\\n    // for compatibility with ILendingPool\\n    _delegate(_extension);\\n  }\\n\\n  function repay(\\n    address asset,\\n    uint256 amount,\\n    uint256 rateMode,\\n    address onBehalfOf\\n  ) external override whenNotPaused noReentryOrFlashloanFeature(FEATURE_FLASHLOAN_REPAY) returns (uint256) {\\n    DataTypes.ReserveData storage reserve = _reserves[asset];\\n\\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(onBehalfOf, reserve);\\n\\n    DataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode);\\n\\n    ValidationLogic.validateRepay(reserve, amount, interestRateMode, onBehalfOf, stableDebt, variableDebt);\\n\\n    uint256 paybackAmount = interestRateMode == DataTypes.InterestRateMode.STABLE ? stableDebt : variableDebt;\\n\\n    if (amount < paybackAmount) {\\n      paybackAmount = amount;\\n    }\\n\\n    reserve.updateState(asset);\\n\\n    if (interestRateMode == DataTypes.InterestRateMode.STABLE) {\\n      IStableDebtToken(reserve.stableDebtTokenAddress).burn(onBehalfOf, paybackAmount);\\n    } else {\\n      IVariableDebtToken(reserve.variableDebtTokenAddress).burn(onBehalfOf, paybackAmount, reserve.variableBorrowIndex);\\n    }\\n\\n    address depositToken = reserve.depositTokenAddress;\\n    reserve.updateInterestRates(asset, depositToken, paybackAmount, 0);\\n\\n    if (stableDebt + variableDebt <= paybackAmount) {\\n      _usersConfig[onBehalfOf].unsetBorrowing(reserve.id);\\n    }\\n\\n    IERC20(asset).safeTransferFrom(msg.sender, depositToken, paybackAmount);\\n\\n    emit Repay(asset, onBehalfOf, msg.sender, paybackAmount);\\n\\n    return paybackAmount;\\n  }\\n\\n  function swapBorrowRateMode(address asset, uint256 rateMode) external override whenNotPaused noReentryOrFlashloan {\\n    DataTypes.ReserveData storage reserve = _reserves[asset];\\n\\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(msg.sender, reserve);\\n\\n    DataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode);\\n\\n    ValidationLogic.validateSwapRateMode(reserve, _usersConfig[msg.sender], stableDebt, variableDebt, interestRateMode);\\n\\n    reserve.updateState(asset);\\n\\n    if (interestRateMode == DataTypes.InterestRateMode.STABLE) {\\n      IStableDebtToken(reserve.stableDebtTokenAddress).burn(msg.sender, stableDebt);\\n      IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\\n        msg.sender,\\n        msg.sender,\\n        stableDebt,\\n        reserve.variableBorrowIndex\\n      );\\n    } else {\\n      IVariableDebtToken(reserve.variableDebtTokenAddress).burn(msg.sender, variableDebt, reserve.variableBorrowIndex);\\n      IStableDebtToken(reserve.stableDebtTokenAddress).mint(\\n        msg.sender,\\n        msg.sender,\\n        variableDebt,\\n        reserve.currentStableBorrowRate\\n      );\\n    }\\n\\n    reserve.updateInterestRates(asset, reserve.depositTokenAddress, 0, 0);\\n\\n    emit Swap(asset, msg.sender, rateMode);\\n  }\\n\\n  function rebalanceStableBorrowRate(address asset, address user) external override whenNotPaused noReentryOrFlashloan {\\n    DataTypes.ReserveData storage reserve = _reserves[asset];\\n\\n    IERC20 stableDebtToken = IERC20(reserve.stableDebtTokenAddress);\\n    uint256 stableDebt = IERC20(stableDebtToken).balanceOf(user);\\n    address depositToken = reserve.depositTokenAddress;\\n\\n    ValidationLogic.validateRebalanceStableBorrowRate(reserve, asset, stableDebtToken, depositToken);\\n\\n    reserve.updateState(asset);\\n\\n    IStableDebtToken(address(stableDebtToken)).burn(user, stableDebt);\\n    IStableDebtToken(address(stableDebtToken)).mint(user, user, stableDebt, reserve.currentStableBorrowRate);\\n\\n    reserve.updateInterestRates(asset, depositToken, 0, 0);\\n\\n    emit RebalanceStableBorrowRate(asset, user);\\n  }\\n\\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external override whenNotPaused {\\n    DataTypes.ReserveData storage reserve = _reserves[asset];\\n\\n    ValidationLogic.validateSetUseReserveAsCollateral(\\n      reserve,\\n      asset,\\n      useAsCollateral,\\n      _reserves,\\n      _usersConfig[msg.sender],\\n      _reservesList,\\n      _addressesProvider.getPriceOracle()\\n    );\\n\\n    if (useAsCollateral) {\\n      _usersConfig[msg.sender].setUsingAsCollateral(reserve.id);\\n      emit ReserveUsedAsCollateralEnabled(asset, msg.sender);\\n    } else {\\n      _usersConfig[msg.sender].unsetUsingAsCollateral(reserve.id);\\n      emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\\n    }\\n  }\\n\\n  function liquidationCall(\\n    address,\\n    address,\\n    address,\\n    uint256,\\n    bool\\n  ) external override {\\n    // for compatibility with ILendingPool\\n    _delegate(_extension);\\n  }\\n\\n  function flashLoan(\\n    address,\\n    address[] calldata,\\n    uint256[] calldata,\\n    uint256[] calldata,\\n    address,\\n    bytes calldata,\\n    uint256\\n  ) external override {\\n    // for compatibility with ILendingPool\\n    _delegate(_extension);\\n  }\\n\\n  function getReserveData(address asset)\\n    external\\n    view\\n    override(ILendingPool, ILendingPoolForTokens)\\n    returns (DataTypes.ReserveData memory)\\n  {\\n    return _reserves[asset];\\n  }\\n\\n  function getUserAccountData(address user)\\n    external\\n    view\\n    override\\n    returns (\\n      uint256 totalCollateralETH,\\n      uint256 totalDebtETH,\\n      uint256 availableBorrowsETH,\\n      uint256 currentLiquidationThreshold,\\n      uint256 ltv,\\n      uint256 healthFactor\\n    )\\n  {\\n    (totalCollateralETH, totalDebtETH, ltv, currentLiquidationThreshold, healthFactor) = GenericLogic\\n      .calculateUserAccountData(\\n        user,\\n        _reserves,\\n        _usersConfig[user],\\n        _reservesList,\\n        _addressesProvider.getPriceOracle()\\n      );\\n\\n    availableBorrowsETH = GenericLogic.calculateAvailableBorrowsETH(totalCollateralETH, totalDebtETH, ltv);\\n  }\\n\\n  function getConfiguration(address asset)\\n    external\\n    view\\n    override(ILendingPool, ILendingPoolForTokens)\\n    returns (DataTypes.ReserveConfigurationMap memory)\\n  {\\n    return _reserves[asset].configuration;\\n  }\\n\\n  function getUserConfiguration(address user) external view override returns (DataTypes.UserConfigurationMap memory) {\\n    return _usersConfig[user];\\n  }\\n\\n  function getReserveNormalizedIncome(address asset)\\n    external\\n    view\\n    virtual\\n    override(ILendingPool, ILendingPoolForTokens)\\n    returns (uint256)\\n  {\\n    return _reserves[asset].getNormalizedIncome(asset);\\n  }\\n\\n  function getReserveNormalizedVariableDebt(address asset)\\n    external\\n    view\\n    override(ILendingPool, ILendingPoolForTokens)\\n    returns (uint256)\\n  {\\n    return _reserves[asset].getNormalizedDebt();\\n  }\\n\\n  function getReservesList() external view override(ILendingPool, ILendingPoolForTokens) returns (address[] memory) {\\n    address[] memory _activeReserves = new address[](_reservesCount);\\n\\n    for (uint256 i = 0; i < _reservesCount; i++) {\\n      _activeReserves[i] = _reservesList[i];\\n    }\\n    return _activeReserves;\\n  }\\n\\n  function getAccessController() external view override returns (IMarketAccessController) {\\n    return _addressesProvider;\\n  }\\n\\n  /// @dev Returns the percentage of available liquidity that can be borrowed at once at stable rate\\n  // solhint-disable-next-line func-name-mixedcase\\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() public view returns (uint256) {\\n    return _maxStableRateBorrowSizePct;\\n  }\\n\\n  /// @dev Returns the fee of flash loans - backward compatible\\n  // solhint-disable-next-line func-name-mixedcase\\n  function FLASHLOAN_PREMIUM_TOTAL() public view returns (uint256) {\\n    return _flashLoanPremiumPct;\\n  }\\n\\n  function getFlashloanPremiumPct() public view override returns (uint16) {\\n    return _flashLoanPremiumPct;\\n  }\\n\\n  function getAddressesProvider() external view override returns (address) {\\n    return address(_addressesProvider);\\n  }\\n\\n  /// @dev Returns the address of the LendingPoolExtension\\n  function getLendingPoolExtension() external view returns (address) {\\n    return _extension;\\n  }\\n\\n  /// @dev Updates the address of the LendingPoolExtension\\n  function setLendingPoolExtension(address extension) external onlyConfiguratorOrAdmin {\\n    require(Address.isContract(extension), Errors.VL_CONTRACT_REQUIRED);\\n    _extension = extension;\\n    emit LendingPoolExtensionUpdated(extension);\\n  }\\n\\n  function finalizeTransfer(\\n    address asset,\\n    address from,\\n    address to,\\n    bool lastBalanceFrom,\\n    bool firstBalanceTo\\n  ) external override whenNotPaused {\\n    DataTypes.ReserveData storage reserve = _reserves[asset];\\n    require(msg.sender == reserve.depositTokenAddress, Errors.LP_CALLER_MUST_BE_DEPOSIT_TOKEN);\\n\\n    DataTypes.UserConfigurationMap storage fromConfig = _usersConfig[from];\\n    ValidationLogic.validateTransfer(\\n      asset,\\n      from,\\n      _reserves,\\n      fromConfig,\\n      _reservesList,\\n      _addressesProvider.getPriceOracle()\\n    );\\n\\n    if (from != to) {\\n      if (lastBalanceFrom) {\\n        fromConfig.unsetUsingAsCollateral(reserve.id);\\n        emit ReserveUsedAsCollateralDisabled(asset, from);\\n      }\\n\\n      if (firstBalanceTo) {\\n        DataTypes.UserConfigurationMap storage toConfig = _usersConfig[to];\\n        toConfig.setUsingAsCollateral(reserve.id);\\n        emit ReserveUsedAsCollateralEnabled(asset, to);\\n      }\\n    }\\n  }\\n\\n  function setReservePaused(address asset, bool paused) external override {\\n    DataTypes.ReserveData storage reserve = _reserves[asset];\\n    if (msg.sender != reserve.depositTokenAddress) {\\n      _onlyEmergencyAdmin();\\n      require(reserve.depositTokenAddress != address(0), Errors.VL_UNKNOWN_RESERVE);\\n    }\\n    DataTypes.ReserveConfigurationMap memory config = reserve.configuration;\\n    config.setFrozen(paused);\\n    reserve.configuration = config;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP excluding events to avoid linearization issues.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport './IERC20.sol';\\nimport './Address.sol';\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = address(token).call(data);\\n    require(success, 'SafeERC20: low-level call failed');\\n\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n// solhint-disable no-inline-assembly, avoid-low-level-calls\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    uint256 size;\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  bytes32 private constant accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n  function isExternallyOwned(address account) internal view returns (bool) {\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    uint256 size;\\n    assembly {\\n      codehash := extcodehash(account)\\n      size := extcodesize(account)\\n    }\\n    return codehash == accountHash && size == 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using {ReentrancyGuard}.\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain `call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data.\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCall(target, data, 'Address: low-level call failed');\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, 'Address: insufficient balance for call');\\n    require(isContract(target), 'Address: call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, 'Address: low-level static call failed');\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), 'Address: static call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, 'Address: low-level delegate call failed');\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(isContract(target), 'Address: delegate call to non-contract');\\n\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n   * revert reason using the provided one.\\n   *\\n   * _Available since v4.3._\\n   */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/access/interfaces/IMarketAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport './IAccessController.sol';\\n\\n/// @dev Main registry of addresses part of or connected to the protocol, including permissioned roles. Also acts a proxy factory.\\ninterface IMarketAccessController is IAccessController {\\n  function getMarketId() external view returns (string memory);\\n\\n  function getLendingPool() external view returns (address);\\n\\n  function getPriceOracle() external view returns (address);\\n\\n  function getLendingRateOracle() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/access/AccessHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport './interfaces/IRemoteAccessBitmask.sol';\\n\\n/// @dev Helper/wrapper around IRemoteAccessBitmask\\nlibrary AccessHelper {\\n  function getAcl(IRemoteAccessBitmask remote, address subject) internal view returns (uint256) {\\n    return remote.queryAccessControlMask(subject, ~uint256(0));\\n  }\\n\\n  function queryAcl(\\n    IRemoteAccessBitmask remote,\\n    address subject,\\n    uint256 filterMask\\n  ) internal view returns (uint256) {\\n    return remote.queryAccessControlMask(subject, filterMask);\\n  }\\n\\n  function hasAnyOf(\\n    IRemoteAccessBitmask remote,\\n    address subject,\\n    uint256 flags\\n  ) internal view returns (bool) {\\n    uint256 found = queryAcl(remote, subject, flags);\\n    return found & flags != 0;\\n  }\\n\\n  function hasAny(IRemoteAccessBitmask remote, address subject) internal view returns (bool) {\\n    return remote.queryAccessControlMask(subject, 0) != 0;\\n  }\\n\\n  function hasNone(IRemoteAccessBitmask remote, address subject) internal view returns (bool) {\\n    return remote.queryAccessControlMask(subject, 0) == 0;\\n  }\\n\\n  function requireAnyOf(\\n    IRemoteAccessBitmask remote,\\n    address subject,\\n    uint256 flags,\\n    string memory text\\n  ) internal view {\\n    require(hasAnyOf(remote, subject, flags), text);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDepositToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport './IScaledBalanceToken.sol';\\nimport './IPoolToken.sol';\\n\\ninterface IDepositToken is IERC20, IPoolToken, IScaledBalanceToken {\\n  /**\\n   * @dev Emitted on mint\\n   * @param account The receiver of minted tokens\\n   * @param value The amount minted\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event Mint(address indexed account, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Mints `amount` depositTokens to `user`\\n   * @param user The address receiving the minted tokens\\n   * @param amount The amount of tokens getting minted\\n   * @param index The new liquidity index of the reserve\\n   * @param repayOverdraft Enables to use this amount cover an overdraft\\n   * @return `true` if the the previous balance of the user was 0\\n   */\\n  function mint(\\n    address user,\\n    uint256 amount,\\n    uint256 index,\\n    bool repayOverdraft\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted on burn\\n   * @param account The owner of tokens burned\\n   * @param target The receiver of the underlying\\n   * @param value The amount burned\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event Burn(address indexed account, address indexed target, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Emitted on transfer\\n   * @param from The sender\\n   * @param to The recipient\\n   * @param value The amount transferred\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Burns depositTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\\n   * @param user The owner of the depositTokens, getting them burned\\n   * @param receiverOfUnderlying The address that will receive the underlying\\n   * @param amount The amount being burned\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  function burn(\\n    address user,\\n    address receiverOfUnderlying,\\n    uint256 amount,\\n    uint256 index\\n  ) external;\\n\\n  /**\\n   * @dev Mints depositTokens to the reserve treasury\\n   * @param amount The amount of tokens getting minted\\n   * @param index The new liquidity index of the reserve\\n   */\\n  function mintToTreasury(uint256 amount, uint256 index) external;\\n\\n  /**\\n   * @dev Transfers depositTokens in the event of a borrow being liquidated, in case the liquidators reclaims the depositToken\\n   * @param from The address getting liquidated, current owner of the depositTokens\\n   * @param to The recipient\\n   * @param value The amount of tokens getting transferred\\n   * @param index The liquidity index of the reserve\\n   * @param transferUnderlying is true when the underlying should be, otherwise the depositToken\\n   * @return true when transferUnderlying is false and the recipient had zero balance\\n   **/\\n  function transferOnLiquidation(\\n    address from,\\n    address to,\\n    uint256 value,\\n    uint256 index,\\n    bool transferUnderlying\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\\n   * assets in borrow(), withdraw() and flashLoan()\\n   * @param user The recipient of the underlying\\n   * @param amount The amount getting transferred\\n   * @return The amount transferred\\n   **/\\n  function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\\n\\n  function collateralBalanceOf(address) external view returns (uint256);\\n\\n  /**\\n   * @dev Emitted on use of overdraft (by liquidation)\\n   * @param account The receiver of overdraft (user with shortage)\\n   * @param value The amount received\\n   * @param index The liquidity index of the reserve\\n   **/\\n  event OverdraftApplied(address indexed account, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Emitted on return of overdraft allowance when it was fully or partially used\\n   * @param provider The provider of overdraft\\n   * @param recipient The receiver of overdraft\\n   * @param overdraft The amount overdraft that was covered by the provider\\n   * @param index The liquidity index of the reserve\\n   **/\\n  event OverdraftCovered(address indexed provider, address indexed recipient, uint256 overdraft, uint256 index);\\n\\n  event SubBalanceProvided(address indexed provider, address indexed recipient, uint256 amount, uint256 index);\\n  event SubBalanceReturned(address indexed provider, address indexed recipient, uint256 amount, uint256 index);\\n  event SubBalanceLocked(address indexed provider, uint256 amount, uint256 index);\\n  event SubBalanceUnlocked(address indexed provider, uint256 amount, uint256 index);\\n\\n  function updateTreasury() external;\\n\\n  function addSubBalanceOperator(address addr) external;\\n\\n  function addStakeOperator(address addr) external;\\n\\n  function removeSubBalanceOperator(address addr) external;\\n\\n  function provideSubBalance(\\n    address provider,\\n    address recipient,\\n    uint256 scaledAmount\\n  ) external;\\n\\n  function returnSubBalance(\\n    address provider,\\n    address recipient,\\n    uint256 scaledAmount,\\n    bool preferOverdraft\\n  ) external returns (uint256 coveredOverdraft);\\n\\n  function lockSubBalance(address provider, uint256 scaledAmount) external;\\n\\n  function unlockSubBalance(\\n    address provider,\\n    uint256 scaledAmount,\\n    address transferTo\\n  ) external;\\n\\n  function replaceSubBalance(\\n    address prevProvider,\\n    address recipient,\\n    uint256 prevScaledAmount,\\n    address newProvider,\\n    uint256 newScaledAmount\\n  ) external returns (uint256 coveredOverdraftByPrevProvider);\\n\\n  function transferLockedBalance(\\n    address from,\\n    address to,\\n    uint256 scaledAmount\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVariableDebtToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport './IScaledBalanceToken.sol';\\nimport '../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport './IPoolToken.sol';\\n\\n/// @dev Defines the basic interface for a variable debt token.\\ninterface IVariableDebtToken is IPoolToken, IScaledBalanceToken {\\n  /**\\n   * @dev Emitted after the mint action\\n   * @param from The address performing the mint\\n   * @param onBehalfOf The address of the user on which behalf minting has been performed\\n   * @param value The amount to be minted\\n   * @param index The last index of the reserve\\n   **/\\n  event Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index);\\n\\n  /// @dev Mints debt token to the `onBehalfOf` address. Returns `true` when balance of the `onBehalfOf` was 0\\n  function mint(\\n    address user,\\n    address onBehalfOf,\\n    uint256 amount,\\n    uint256 index\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when variable debt is burnt\\n   * @param user The user which debt has been burned\\n   * @param amount The amount of debt being burned\\n   * @param index The index of the user\\n   **/\\n  event Burn(address indexed user, uint256 amount, uint256 index);\\n\\n  /// @dev Burns user variable debt\\n  function burn(\\n    address user,\\n    uint256 amount,\\n    uint256 index\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../protocol/libraries/types/DataTypes.sol';\\nimport './ILendingPoolEvents.sol';\\n\\ninterface ILendingPool is ILendingPoolEvents {\\n  /**\\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying depositTokens.\\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n   * @param asset The address of the underlying asset to deposit\\n   * @param amount The amount to be deposited\\n   * @param onBehalfOf The address that will receive the depositTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of depositTokens\\n   *   is a different wallet\\n   * @param referral Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   **/\\n  function deposit(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    uint256 referral\\n  ) external;\\n\\n  /**\\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent depositTokens owned\\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n   * @param asset The address of the underlying asset to withdraw\\n   * @param amount The underlying amount to be withdrawn\\n   *   - Send the value type(uint256).max in order to withdraw the whole depositToken balance\\n   * @param to Address that will receive the underlying, same as msg.sender if the user\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n   *   different wallet\\n   * @return The final amount withdrawn\\n   **/\\n  function withdraw(\\n    address asset,\\n    uint256 amount,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\n   * @param asset The address of the underlying asset to borrow\\n   * @param amount The amount to be borrowed\\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\\n   * @param referral Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\n   * if he has been given credit delegation allowance\\n   **/\\n  function borrow(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode,\\n    uint256 referral,\\n    address onBehalfOf\\n  ) external;\\n\\n  /**\\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\n   * @param amount The amount to repay\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\n   * other borrower whose debt should be removed\\n   * @return The final amount repaid\\n   **/\\n  function repay(\\n    address asset,\\n    uint256 amount,\\n    uint256 rateMode,\\n    address onBehalfOf\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\\n   * @param asset The address of the underlying asset borrowed\\n   * @param rateMode The rate mode that the user wants to swap to\\n   **/\\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\\n\\n  /**\\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\\n   * - Users can be rebalanced if the following conditions are satisfied:\\n   *     1. Usage ratio is above 95%\\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\\n   *        borrowed at a stable rate and depositors are not earning enough\\n   * @param asset The address of the underlying asset borrowed\\n   * @param user The address of the user to be rebalanced\\n   **/\\n  function rebalanceStableBorrowRate(address asset, address user) external;\\n\\n  /**\\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\\n   * @param asset The address of the underlying asset deposited\\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\\n   **/\\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\\n\\n  /**\\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n   * @param user The address of the borrower getting liquidated\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n   * @param receiveDeposit `true` if the liquidators wants to receive the collateral depositTokens, `false` if he wants\\n   * to receive the underlying collateral asset directly\\n   **/\\n  function liquidationCall(\\n    address collateralAsset,\\n    address debtAsset,\\n    address user,\\n    uint256 debtToCover,\\n    bool receiveDeposit\\n  ) external;\\n\\n  /**\\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\\n   * as long as the amount taken plus a fee is returned.\\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\\n   * For further details please visit https://developers.aave.com\\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\\n   * @param assets The addresses of the assets being flash-borrowed\\n   * @param amounts The amounts amounts being flash-borrowed\\n   * @param modes Types of the debt to open if the flash loan is not returned:\\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\\n   * @param params Variadic packed params to pass to the receiver as extra information\\n   * @param referral Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   **/\\n  function flashLoan(\\n    address receiverAddress,\\n    address[] calldata assets,\\n    uint256[] calldata amounts,\\n    uint256[] calldata modes,\\n    address onBehalfOf,\\n    bytes calldata params,\\n    uint256 referral\\n  ) external;\\n\\n  /**\\n   * @dev Returns the user account data across all the reserves\\n   * @param user The address of the user\\n   * @return totalCollateralETH the total collateral in ETH of the user\\n   * @return totalDebtETH the total debt in ETH of the user\\n   * @return availableBorrowsETH the borrowing power left of the user\\n   * @return currentLiquidationThreshold the liquidation threshold of the user\\n   * @return ltv the loan to value of the user\\n   * @return healthFactor the current health factor of the user\\n   **/\\n  function getUserAccountData(address user)\\n    external\\n    view\\n    returns (\\n      uint256 totalCollateralETH,\\n      uint256 totalDebtETH,\\n      uint256 availableBorrowsETH,\\n      uint256 currentLiquidationThreshold,\\n      uint256 ltv,\\n      uint256 healthFactor\\n    );\\n\\n  /**\\n   * @dev Returns the configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The configuration of the reserve\\n   **/\\n  function getConfiguration(address asset)\\n    external\\n    view\\n    returns (DataTypes.ReserveConfigurationMap memory);\\n\\n  /**\\n   * @dev Returns the configuration of the user across all the reserves\\n   * @param user The user address\\n   * @return The configuration of the user\\n   **/\\n  function getUserConfiguration(address user)\\n    external\\n    view\\n    returns (DataTypes.UserConfigurationMap memory);\\n\\n  /**\\n   * @dev Returns the normalized income normalized income of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve's normalized income\\n   */\\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the normalized variable debt per unit of asset\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve normalized variable debt\\n   */\\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the state and configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The state of the reserve\\n   **/\\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\n\\n  function getReservesList() external view returns (address[] memory);\\n\\n  function getAddressesProvider() external view returns (address);\\n\\n  function getFlashloanPremiumPct() external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPoolForTokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../access/interfaces/IMarketAccessController.sol';\\nimport '../protocol/libraries/types/DataTypes.sol';\\n\\ninterface ILendingPoolForTokens {\\n  /**\\n   * @dev Validates and finalizes an depositToken transfer\\n   * - Only callable by the overlying depositToken of the `asset`\\n   * @param asset The address of the underlying asset of the depositToken\\n   * @param from The user from which the depositToken are transferred\\n   * @param to The user receiving the depositToken\\n   * @param lastBalanceFrom True when from's balance was non-zero and became zero\\n   * @param firstBalanceTo True when to's balance was zero and became non-zero\\n   */\\n  function finalizeTransfer(\\n    address asset,\\n    address from,\\n    address to,\\n    bool lastBalanceFrom,\\n    bool firstBalanceTo\\n  ) external;\\n\\n  function getAccessController() external view returns (IMarketAccessController);\\n\\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\\n\\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\\n\\n  function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\\n\\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\n\\n  function getReservesList() external view returns (address[] memory);\\n\\n  function setReservePaused(address asset, bool paused) external;\\n}\\n\"\r\n    },\r\n    \"contracts/flashloan/interfaces/IFlashLoanReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../../interfaces/IFlashLoanAddressProvider.sol';\\nimport '../../interfaces/ILendingPool.sol';\\n\\n// solhint-disable func-name-mixedcase\\n/**\\n * @title IFlashLoanReceiver interface\\n * @notice Interface for the Aave fee IFlashLoanReceiver.\\n * @author Aave\\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\\n **/\\ninterface IFlashLoanReceiver {\\n  function executeOperation(\\n    address[] calldata assets,\\n    uint256[] calldata amounts,\\n    uint256[] calldata premiums,\\n    address initiator,\\n    bytes calldata params\\n  ) external returns (bool);\\n\\n  function ADDRESS_PROVIDER() external view returns (IFlashLoanAddressProvider);\\n\\n  function LENDING_POOL() external view returns (ILendingPool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStableDebtToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport './IBalanceHook.sol';\\nimport '../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport './IPoolToken.sol';\\n\\n/// @dev Defines the interface for the stable debt token\\ninterface IStableDebtToken is IPoolToken {\\n  /**\\n   * @dev Emitted when new stable debt is minted\\n   * @param user The address of the user who triggered the minting\\n   * @param onBehalfOf The recipient of stable debt tokens\\n   * @param amount The amount minted\\n   * @param currentBalance The current balance of the user\\n   * @param balanceIncrease The increase in balance since the last action of the user\\n   * @param newRate The rate of the debt after the minting\\n   * @param avgStableRate The new average stable rate after the minting\\n   * @param newTotalSupply The new total supply of the stable debt token after the action\\n   **/\\n  event Mint(\\n    address indexed user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    uint256 currentBalance,\\n    uint256 balanceIncrease,\\n    uint256 newRate,\\n    uint256 avgStableRate,\\n    uint256 newTotalSupply\\n  );\\n\\n  /**\\n   * @dev Emitted when new stable debt is burned\\n   * @param user The address of the user\\n   * @param amount The amount being burned\\n   * @param currentBalance The current balance of the user\\n   * @param balanceIncrease The the increase in balance since the last action of the user\\n   * @param avgStableRate The new average stable rate after the burning\\n   * @param newTotalSupply The new total supply of the stable debt token after the action\\n   **/\\n  event Burn(\\n    address indexed user,\\n    uint256 amount,\\n    uint256 currentBalance,\\n    uint256 balanceIncrease,\\n    uint256 avgStableRate,\\n    uint256 newTotalSupply\\n  );\\n\\n  /**\\n   * @dev Mints debt token to the `onBehalfOf` address.\\n   * - The resulting rate is the weighted average between the rate of the new debt\\n   * and the rate of the previous debt\\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\\n   * of credit delegate, or same as `onBehalfOf` otherwise\\n   * @param onBehalfOf The address receiving the debt tokens\\n   * @param amount The amount of debt tokens to mint\\n   * @param rate The rate of the debt being minted\\n   **/\\n  function mint(\\n    address user,\\n    address onBehalfOf,\\n    uint256 amount,\\n    uint256 rate\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Burns debt of `user`\\n   * - The resulting rate is the weighted average between the rate of the new debt\\n   * and the rate of the previous debt\\n   * @param user The address of the user getting his debt burned\\n   * @param amount The amount of debt tokens getting burned\\n   **/\\n  function burn(address user, uint256 amount) external;\\n\\n  /// @dev Returns the average rate of all the stable rate loans\\n  function getAverageStableRate() external view returns (uint256);\\n\\n  /// @dev Returns the stable rate of the user debt\\n  function getUserStableRate(address user) external view returns (uint256);\\n\\n  /// @dev Returns the timestamp of the last update of the user\\n  function getUserLastUpdated(address user) external view returns (uint40);\\n\\n  /// @dev Returns the principal, the total supply and the average stable rate\\n  function getSupplyData()\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint40\\n    );\\n\\n  /// @dev Returns the timestamp of the last update of the total supply\\n  function getTotalSupplyLastUpdated() external view returns (uint40);\\n\\n  /// @dev Returns the total supply and the average stable rate\\n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\\n\\n  /// @dev Returns the principal debt balance of the user\\n  function principalBalanceOf(address user) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/tools/upgradeability/Delegator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\n/// @dev Provides delegation of calls with proper forwarding of return values and bubbling of failures. Based on OpenZeppelin Proxy.\\nabstract contract Delegator {\\n  /**\\n   * @dev Delegates execution to an implementation contract.\\n   * This is a low level function that doesn't return to its internal call site.\\n   * It will return to the external caller whatever the implementation returns.\\n   * @param implementation Address to delegate.\\n   */\\n  function _delegate(address implementation) internal {\\n    require(implementation != address(0));\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      // Copy msg.data. We take full control of memory in this inline assembly\\n      // block because it will not return to Solidity code. We overwrite the\\n      // Solidity scratch pad at memory position 0.\\n      calldatacopy(0, 0, calldatasize())\\n\\n      // Call the implementation.\\n      // out and outsize are 0 because we don't know the size yet.\\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n      // Copy the returned data.\\n      returndatacopy(0, 0, returndatasize())\\n\\n      switch result\\n      // delegatecall returns 0 on error.\\n      case 0 {\\n        revert(0, returndatasize())\\n      }\\n      default {\\n        return(0, returndatasize())\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/tools/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Errors library\\n * @notice Defines the error messages emitted by the different contracts\\n * @dev Error messages prefix glossary:\\n *  - VL = ValidationLogic\\n *  - MATH = Math libraries\\n *  - CT = Common errors between tokens (DepositToken, VariableDebtToken and StableDebtToken)\\n *  - AT = DepositToken\\n *  - SDT = StableDebtToken\\n *  - VDT = VariableDebtToken\\n *  - LP = LendingPool\\n *  - LPAPR = AddressesProviderRegistry\\n *  - LPC = LendingPoolConfiguration\\n *  - RL = ReserveLogic\\n *  - LPCM = LendingPoolExtension\\n *  - ST = Stake\\n */\\nlibrary Errors {\\n  //contract specific errors\\n  string public constant VL_INVALID_AMOUNT = '1'; // Amount must be greater than 0\\n  string public constant VL_NO_ACTIVE_RESERVE = '2'; // Action requires an active reserve\\n  string public constant VL_RESERVE_FROZEN = '3'; // Action cannot be performed because the reserve is frozen\\n  string public constant VL_UNKNOWN_RESERVE = '4'; // Action requires an active reserve\\n  string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = '5'; // User cannot withdraw more than the available balance (above min limit)\\n  string public constant VL_TRANSFER_NOT_ALLOWED = '6'; // Transfer cannot be allowed.\\n  string public constant VL_BORROWING_NOT_ENABLED = '7'; // Borrowing is not enabled\\n  string public constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = '8'; // Invalid interest rate mode selected\\n  string public constant VL_COLLATERAL_BALANCE_IS_0 = '9'; // The collateral balance is 0\\n  string public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '10'; // Health factor is lesser than the liquidation threshold\\n  string public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = '11'; // There is not enough collateral to cover a new borrow\\n  string public constant VL_STABLE_BORROWING_NOT_ENABLED = '12'; // stable borrowing not enabled\\n  string public constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = '13'; // collateral is (mostly) the same currency that is being borrowed\\n  string public constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '14'; // The requested amount is exceeds max size of a stable loan\\n  string public constant VL_NO_DEBT_OF_SELECTED_TYPE = '15'; // to repay a debt, user needs to specify a correct debt type (variable or stable)\\n  string public constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '16'; // To repay on behalf of an user an explicit amount to repay is needed\\n  string public constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = '17'; // User does not have a stable rate loan in progress on this reserve\\n  string public constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = '18'; // User does not have a variable rate loan in progress on this reserve\\n  string public constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = '19'; // The collateral balance needs to be greater than 0\\n  string public constant VL_DEPOSIT_ALREADY_IN_USE = '20'; // User deposit is already being used as collateral\\n  string public constant VL_RESERVE_MUST_BE_COLLATERAL = '21'; // This reserve must be enabled as collateral\\n  string public constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '22'; // Interest rate rebalance conditions were not met\\n  string public constant AT_OVERDRAFT_DISABLED = '23'; // User doesn't accept allocation of overdraft\\n  string public constant VL_INVALID_SUB_BALANCE_ARGS = '24';\\n  string public constant AT_INVALID_SLASH_DESTINATION = '25';\\n\\n  string public constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = '27'; // The caller of the function is not the lending pool configurator\\n\\n  string public constant LENDING_POOL_REQUIRED = '28'; // The caller of this function must be a lending pool\\n  string public constant CALLER_NOT_LENDING_POOL = '29'; // The caller of this function must be a lending pool\\n  string public constant AT_SUB_BALANCE_RESTIRCTED_FUNCTION = '30'; // The caller of this function must be a lending pool or a sub-balance operator\\n\\n  string public constant RL_RESERVE_ALREADY_INITIALIZED = '32'; // Reserve has already been initialized\\n  string public constant CALLER_NOT_POOL_ADMIN = '33'; // The caller must be the pool admin\\n  string public constant LPC_RESERVE_LIQUIDITY_NOT_0 = '34'; // The liquidity of the reserve needs to be 0\\n\\n  string public constant LPAPR_PROVIDER_NOT_REGISTERED = '41'; // Provider is not registered\\n  string public constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '42'; // Health factor is not below the threshold\\n  string public constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = '43'; // The collateral chosen cannot be liquidated\\n  string public constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '44'; // User did not borrow the specified currency\\n  string public constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = '45'; // There isn't enough liquidity available to liquidate\\n\\n  string public constant MATH_MULTIPLICATION_OVERFLOW = '48';\\n  string public constant MATH_ADDITION_OVERFLOW = '49';\\n  string public constant MATH_DIVISION_BY_ZERO = '50';\\n  string public constant RL_LIQUIDITY_INDEX_OVERFLOW = '51'; //  Liquidity index overflows uint128\\n  string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = '52'; //  Variable borrow index overflows uint128\\n  string public constant RL_LIQUIDITY_RATE_OVERFLOW = '53'; //  Liquidity rate overflows uint128\\n  string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = '54'; //  Variable borrow rate overflows uint128\\n  string public constant RL_STABLE_BORROW_RATE_OVERFLOW = '55'; //  Stable borrow rate overflows uint128\\n  string public constant CT_INVALID_MINT_AMOUNT = '56'; //invalid amount to mint\\n  string public constant CALLER_NOT_STAKE_ADMIN = '57';\\n  string public constant CT_INVALID_BURN_AMOUNT = '58'; //invalid amount to burn\\n  string public constant BORROW_ALLOWANCE_NOT_ENOUGH = '59'; // User borrows on behalf, but allowance are too small\\n  string public constant CALLER_NOT_LIQUIDITY_CONTROLLER = '60';\\n  string public constant CALLER_NOT_REF_ADMIN = '61';\\n  string public constant VL_INSUFFICIENT_REWARD_AVAILABLE = '62';\\n  string public constant LP_CALLER_MUST_BE_DEPOSIT_TOKEN = '63';\\n  string public constant LP_IS_PAUSED = '64'; // Pool is paused\\n  string public constant LP_NO_MORE_RESERVES_ALLOWED = '65';\\n  string public constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = '66';\\n  string public constant RC_INVALID_LTV = '67';\\n  string public constant RC_INVALID_LIQ_THRESHOLD = '68';\\n  string public constant RC_INVALID_LIQ_BONUS = '69';\\n  string public constant RC_INVALID_DECIMALS = '70';\\n  string public constant RC_INVALID_RESERVE_FACTOR = '71';\\n  string public constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = '72';\\n  string public constant VL_INCONSISTENT_FLASHLOAN_PARAMS = '73';\\n  string public constant VL_TREASURY_REQUIRED = '74';\\n  string public constant LPC_INVALID_CONFIGURATION = '75'; // Invalid risk parameters for the reserve\\n  string public constant CALLER_NOT_EMERGENCY_ADMIN = '76'; // The caller must be the emergency admin\\n  string public constant UL_INVALID_INDEX = '77';\\n  string public constant VL_CONTRACT_REQUIRED = '78';\\n  string public constant SDT_STABLE_DEBT_OVERFLOW = '79';\\n  string public constant SDT_BURN_EXCEEDS_BALANCE = '80';\\n  string public constant CALLER_NOT_REWARD_CONFIG_ADMIN = '81'; // The caller of this function must be a reward admin\\n  string public constant LP_INVALID_PERCENTAGE = '82'; // Percentage can't be more than 100%\\n  string public constant LP_IS_NOT_TRUSTED_FLASHLOAN = '83';\\n  string public constant CALLER_NOT_SWEEP_ADMIN = '84';\\n  string public constant LP_TOO_MANY_NESTED_CALLS = '85';\\n  string public constant LP_RESTRICTED_FEATURE = '86';\\n  string public constant LP_TOO_MANY_FLASHLOAN_CALLS = '87';\\n  string public constant RW_BASELINE_EXCEEDED = '88';\\n  string public constant CALLER_NOT_REWARD_RATE_ADMIN = '89';\\n  string public constant CALLER_NOT_REWARD_CONTROLLER = '90';\\n  string public constant RW_REWARD_PAUSED = '91';\\n  string public constant CALLER_NOT_TEAM_MANAGER = '92';\\n  string public constant STK_REDEEM_PAUSED = '93';\\n  string public constant STK_INSUFFICIENT_COOLDOWN = '94';\\n  string public constant STK_UNSTAKE_WINDOW_FINISHED = '95';\\n  string public constant STK_INVALID_BALANCE_ON_COOLDOWN = '96';\\n  string public constant STK_EXCESSIVE_SLASH_PCT = '97';\\n  string public constant STK_WRONG_COOLDOWN_OR_UNSTAKE = '98';\\n  string public constant STK_PAUSED = '99';\\n\\n  string public constant TXT_OWNABLE_CALLER_NOT_OWNER = 'Ownable: caller is not the owner';\\n  string public constant TXT_CALLER_NOT_PROXY_OWNER = 'ProxyOwner: caller is not the owner';\\n  string public constant TXT_ACCESS_RESTRICTED = 'RESTRICTED';\\n}\\n\"\r\n    },\r\n    \"contracts/tools/math/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../Errors.sol';\\n\\n/// @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\nlibrary WadRayMath {\\n  uint256 internal constant WAD = 1e18;\\n  uint256 internal constant halfWAD = WAD / 2;\\n\\n  uint256 internal constant RAY = 1e27;\\n  uint256 internal constant halfRAY = RAY / 2;\\n\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n  /// @return One ray, 1e27\\n  function ray() internal pure returns (uint256) {\\n    return RAY;\\n  }\\n\\n  /// @return One wad, 1e18\\n  function wad() internal pure returns (uint256) {\\n    return WAD;\\n  }\\n\\n  /// @return Half ray, 1e27/2\\n  function halfRay() internal pure returns (uint256) {\\n    return halfRAY;\\n  }\\n\\n  /// @return Half ray, 1e18/2\\n  function halfWad() internal pure returns (uint256) {\\n    return halfWAD;\\n  }\\n\\n  /// @dev Multiplies two wad, rounding half up to the nearest wad\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    require(a <= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * b + halfWAD) / WAD;\\n  }\\n\\n  /// @dev Divides two wad, rounding half up to the nearest wad\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\\n    uint256 halfB = b / 2;\\n\\n    require(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * WAD + halfB) / b;\\n  }\\n\\n  /// @dev Multiplies two ray, rounding half up to the nearest ray\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n\\n    require(a <= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * b + halfRAY) / RAY;\\n  }\\n\\n  /// @dev Divides two ray, rounding half up to the nearest ray\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\\n    uint256 halfB = b / 2;\\n\\n    require(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * RAY + halfB) / b;\\n  }\\n\\n  /// @dev Casts ray down to wad\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\\n    uint256 result = halfRatio + a;\\n\\n    require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW);\\n\\n    return result / WAD_RAY_RATIO;\\n  }\\n\\n  /// @dev Converts wad up to ray\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\n    uint256 result = a * WAD_RAY_RATIO;\\n\\n    require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/helpers/Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../../../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport '../types/DataTypes.sol';\\n\\nlibrary Helpers {\\n  /// @dev Fetches the user current stable and variable debt balances\\n  function getUserCurrentDebt(address user, DataTypes.ReserveData storage reserve)\\n    internal\\n    view\\n    returns (uint256, uint256)\\n  {\\n    return (\\n      IERC20(reserve.stableDebtTokenAddress).balanceOf(user),\\n      IERC20(reserve.variableDebtTokenAddress).balanceOf(user)\\n    );\\n  }\\n\\n  function getUserCurrentDebtMemory(address user, DataTypes.ReserveData memory reserve)\\n    internal\\n    view\\n    returns (uint256, uint256)\\n  {\\n    return (\\n      IERC20(reserve.stableDebtTokenAddress).balanceOf(user),\\n      IERC20(reserve.variableDebtTokenAddress).balanceOf(user)\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/logic/GenericLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../../../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport './ReserveLogic.sol';\\nimport '../configuration/ReserveConfiguration.sol';\\nimport '../configuration/UserConfiguration.sol';\\nimport '../../../tools/math/WadRayMath.sol';\\nimport '../../../tools/math/PercentageMath.sol';\\nimport '../../../interfaces/IPriceOracleGetter.sol';\\nimport '../types/DataTypes.sol';\\n\\n/// @title Implements protocol-level logic to calculate and validate the state of a user\\nlibrary GenericLogic {\\n  using ReserveLogic for DataTypes.ReserveData;\\n  using WadRayMath for uint256;\\n  using PercentageMath for uint256;\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n  using UserConfiguration for DataTypes.UserConfigurationMap;\\n\\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\\n\\n  struct BalanceDecreaseAllowedLocalVars {\\n    uint256 decimals;\\n    uint256 liquidationThreshold;\\n    uint256 totalCollateralInETH;\\n    uint256 totalDebtInETH;\\n    uint256 avgLiquidationThreshold;\\n    uint256 amountToDecreaseInETH;\\n    uint256 collateralBalanceAfterDecrease;\\n    uint256 liquidationThresholdAfterDecrease;\\n    uint256 healthFactorAfterDecrease;\\n    bool reserveUsageAsCollateralEnabled;\\n  }\\n\\n  /**\\n   * @dev Checks if a specific balance decrease is allowed\\n   * (i.e. doesn't bring the user borrow position health factor under HEALTH_FACTOR_LIQUIDATION_THRESHOLD)\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param user The address of the user\\n   * @param amount The amount to decrease\\n   * @param reservesData The data of all the reserves\\n   * @param userConfig The user configuration\\n   * @param reserves The list of all the active reserves\\n   * @param oracle The address of the oracle contract\\n   * @return true if the decrease of the balance is allowed\\n   **/\\n  function balanceDecreaseAllowed(\\n    address asset,\\n    address user,\\n    uint256 amount,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    DataTypes.UserConfigurationMap memory userConfig,\\n    mapping(uint256 => address) storage reserves,\\n    address oracle\\n  ) internal view returns (bool) {\\n    if (!userConfig.isBorrowingAny() || !userConfig.isUsingAsCollateral(reservesData[asset].id)) {\\n      return true;\\n    }\\n\\n    BalanceDecreaseAllowedLocalVars memory vars;\\n\\n    (, vars.liquidationThreshold, , vars.decimals, ) = reservesData[asset].configuration.getParams();\\n\\n    if (vars.liquidationThreshold == 0) {\\n      return true;\\n    }\\n\\n    (vars.totalCollateralInETH, vars.totalDebtInETH, , vars.avgLiquidationThreshold, ) = calculateUserAccountData(\\n      user,\\n      reservesData,\\n      userConfig,\\n      reserves,\\n      oracle\\n    );\\n\\n    if (vars.totalDebtInETH == 0) {\\n      return true;\\n    }\\n\\n    vars.amountToDecreaseInETH = (IPriceOracleGetter(oracle).getAssetPrice(asset) * amount) / (10**vars.decimals);\\n    vars.collateralBalanceAfterDecrease = vars.totalCollateralInETH - vars.amountToDecreaseInETH;\\n\\n    //if there is a borrow, there can't be 0 collateral\\n    if (vars.collateralBalanceAfterDecrease == 0) {\\n      return false;\\n    }\\n\\n    vars.liquidationThresholdAfterDecrease =\\n      ((vars.totalCollateralInETH * vars.avgLiquidationThreshold) -\\n        (vars.amountToDecreaseInETH * vars.liquidationThreshold)) /\\n      vars.collateralBalanceAfterDecrease;\\n\\n    uint256 healthFactorAfterDecrease = calculateHealthFactorFromBalances(\\n      vars.collateralBalanceAfterDecrease,\\n      vars.totalDebtInETH,\\n      vars.liquidationThresholdAfterDecrease\\n    );\\n\\n    return healthFactorAfterDecrease >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\\n  }\\n\\n  struct CalculateUserAccountDataVars {\\n    uint256 i;\\n    uint256 reserveUnitPrice;\\n    uint256 tokenUnit;\\n    uint256 compoundedLiquidityBalance;\\n    uint256 compoundedBorrowBalance;\\n    uint256 decimals;\\n    uint256 ltv;\\n    uint256 liquidationThreshold;\\n    uint256 healthFactor;\\n    uint256 totalCollateralInETH;\\n    uint256 totalDebtInETH;\\n    uint256 avgLtv;\\n    uint256 avgLiquidationThreshold;\\n    uint256 reservesLength;\\n    bool healthFactorBelowThreshold;\\n    address currentReserveAddress;\\n    bool usageAsCollateralEnabled;\\n    bool userUsesReserveAsCollateral;\\n  }\\n\\n  /**\\n   * @dev Calculates the user data across the reserves.\\n   * this includes the total liquidity/collateral/borrow balances in ETH,\\n   * the average Loan To Value, the average Liquidation Ratio, and the Health factor.\\n   * @param user The address of the user\\n   * @param reservesData Data of all the reserves\\n   * @param userConfig The configuration of the user\\n   * @param reserves The list of the available reserves\\n   * @param oracle The price oracle address\\n   * @return The total collateral and total debt of the user in ETH, the avg ltv, liquidation threshold and the HF\\n   **/\\n  function calculateUserAccountData(\\n    address user,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    DataTypes.UserConfigurationMap memory userConfig,\\n    mapping(uint256 => address) storage reserves,\\n    address oracle\\n  )\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    if (userConfig.isEmpty()) {\\n      return (0, 0, 0, 0, ~uint256(0));\\n    }\\n\\n    CalculateUserAccountDataVars memory vars;\\n    for (\\n      uint256 scanData = userConfig.data;\\n      scanData > 0;\\n      (vars.i, scanData) = (vars.i + 1, scanData >> UserConfiguration.SHIFT_STEP)\\n    ) {\\n      if (scanData & UserConfiguration.ANY_MASK == 0) {\\n        continue;\\n      }\\n\\n      vars.currentReserveAddress = reserves[vars.i];\\n      DataTypes.ReserveData storage currentReserve = reservesData[vars.currentReserveAddress];\\n\\n      (vars.ltv, vars.liquidationThreshold, , vars.decimals, ) = currentReserve.configuration.getParams();\\n\\n      vars.tokenUnit = 10**vars.decimals;\\n      vars.reserveUnitPrice = IPriceOracleGetter(oracle).getAssetPrice(vars.currentReserveAddress);\\n\\n      if (vars.liquidationThreshold != 0 && userConfig.isUsingAsCollateral(vars.i)) {\\n        vars.compoundedLiquidityBalance = IDepositToken(currentReserve.depositTokenAddress).collateralBalanceOf(user);\\n\\n        uint256 liquidityBalanceETH = (vars.reserveUnitPrice * vars.compoundedLiquidityBalance) / vars.tokenUnit;\\n\\n        vars.totalCollateralInETH += liquidityBalanceETH;\\n        vars.avgLtv += liquidityBalanceETH * vars.ltv;\\n        vars.avgLiquidationThreshold += liquidityBalanceETH * vars.liquidationThreshold;\\n      }\\n\\n      if (userConfig.isBorrowing(vars.i)) {\\n        vars.compoundedBorrowBalance =\\n          IERC20(currentReserve.stableDebtTokenAddress).balanceOf(user) +\\n          IERC20(currentReserve.variableDebtTokenAddress).balanceOf(user);\\n\\n        vars.totalDebtInETH += (vars.reserveUnitPrice * vars.compoundedBorrowBalance) / vars.tokenUnit;\\n      }\\n    }\\n\\n    if (vars.totalCollateralInETH > 0) {\\n      vars.avgLtv /= vars.totalCollateralInETH;\\n      vars.avgLiquidationThreshold /= vars.totalCollateralInETH;\\n    } else {\\n      (vars.avgLtv, vars.avgLiquidationThreshold) = (0, 0);\\n    }\\n\\n    vars.healthFactor = calculateHealthFactorFromBalances(\\n      vars.totalCollateralInETH,\\n      vars.totalDebtInETH,\\n      vars.avgLiquidationThreshold\\n    );\\n    return (\\n      vars.totalCollateralInETH,\\n      vars.totalDebtInETH,\\n      vars.avgLtv,\\n      vars.avgLiquidationThreshold,\\n      vars.healthFactor\\n    );\\n  }\\n\\n  /**\\n   * @dev Calculates the health factor from the corresponding balances\\n   * @param totalCollateralInETH The total collateral in ETH\\n   * @param totalDebtInETH The total debt in ETH\\n   * @param liquidationThreshold The avg liquidation threshold\\n   * @return The health factor calculated from the balances provided\\n   **/\\n  function calculateHealthFactorFromBalances(\\n    uint256 totalCollateralInETH,\\n    uint256 totalDebtInETH,\\n    uint256 liquidationThreshold\\n  ) internal pure returns (uint256) {\\n    if (totalDebtInETH == 0) return ~uint256(0);\\n\\n    return (totalCollateralInETH.percentMul(liquidationThreshold)).wadDiv(totalDebtInETH);\\n  }\\n\\n  /**\\n   * @dev Calculates the equivalent amount in ETH that an user can borrow, depending on the available collateral and the\\n   * average Loan To Value\\n   * @param totalCollateralInETH The total collateral in ETH\\n   * @param totalDebtInETH The total borrow balance\\n   * @param ltv The average loan to value\\n   * @return the amount available to borrow in ETH for the user\\n   **/\\n\\n  function calculateAvailableBorrowsETH(\\n    uint256 totalCollateralInETH,\\n    uint256 totalDebtInETH,\\n    uint256 ltv\\n  ) internal pure returns (uint256) {\\n    uint256 availableBorrowsETH = totalCollateralInETH.percentMul(ltv);\\n\\n    if (availableBorrowsETH < totalDebtInETH) {\\n      return 0;\\n    }\\n\\n    availableBorrowsETH = availableBorrowsETH - totalDebtInETH;\\n    return availableBorrowsETH;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/logic/ValidationLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../../../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport './ReserveLogic.sol';\\nimport './GenericLogic.sol';\\nimport '../../../tools/math/WadRayMath.sol';\\nimport '../../../tools/math/PercentageMath.sol';\\nimport '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\\nimport '../configuration/ReserveConfiguration.sol';\\nimport '../configuration/UserConfiguration.sol';\\nimport '../../../tools/Errors.sol';\\nimport '../helpers/Helpers.sol';\\nimport '../../../interfaces/IReserveRateStrategy.sol';\\nimport '../types/DataTypes.sol';\\n\\n/**\\n * @title ReserveLogic library\\n * @author Aave\\n * @notice Implements functions to validate the different actions of the protocol\\n */\\nlibrary ValidationLogic {\\n  using ReserveLogic for DataTypes.ReserveData;\\n  using WadRayMath for uint256;\\n  using PercentageMath for uint256;\\n  using SafeERC20 for IERC20;\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n  using UserConfiguration for DataTypes.UserConfigurationMap;\\n\\n  uint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 4000;\\n  uint256 public constant REBALANCE_UP_USAGE_RATIO_THRESHOLD = 0.95 * 1e27; //usage ratio of 95%\\n\\n  /**\\n   * @dev Validates a deposit action\\n   * @param reserve The reserve object on which the user is depositing\\n   * @param amount The amount to be deposited\\n   */\\n  function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) internal view {\\n    (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\\n\\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\\n  }\\n\\n  /**\\n   * @dev Validates a withdraw action\\n   * @param reserveAddress The address of the reserve\\n   * @param amount The amount to be withdrawn\\n   * @param userBalance The balance of the user\\n   * @param reservesData The reserves state\\n   * @param userConfig The user configuration\\n   * @param reserves The addresses of the reserves\\n   * @param oracle The price oracle\\n   */\\n  function validateWithdraw(\\n    address reserveAddress,\\n    uint256 amount,\\n    uint256 userBalance,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    DataTypes.UserConfigurationMap storage userConfig,\\n    mapping(uint256 => address) storage reserves,\\n    address oracle\\n  ) internal view {\\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\\n    require(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\\n    (bool isActive, , , ) = reservesData[reserveAddress].configuration.getFlags();\\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n\\n    require(\\n      GenericLogic.balanceDecreaseAllowed(\\n        reserveAddress,\\n        msg.sender,\\n        amount,\\n        reservesData,\\n        userConfig,\\n        reserves,\\n        oracle\\n      ),\\n      Errors.VL_TRANSFER_NOT_ALLOWED\\n    );\\n  }\\n\\n  struct ValidateBorrowLocalVars {\\n    uint256 currentLtv;\\n    uint256 currentLiquidationThreshold;\\n    uint256 amountOfCollateralNeededETH;\\n    uint256 userCollateralBalanceETH;\\n    uint256 userBorrowBalanceETH;\\n    uint256 availableLiquidity;\\n    uint256 healthFactor;\\n    bool isActive;\\n    bool isFrozen;\\n    bool borrowingEnabled;\\n    bool stableRateBorrowingEnabled;\\n  }\\n\\n  /**\\n   * @dev Validates a borrow action\\n   * @param asset The address of the asset to borrow\\n   * @param reserve The reserve state from which the user is borrowing\\n   * @param userAddress The address of the user\\n   * @param amount The amount to be borrowed\\n   * @param amountInETH The amount to be borrowed, in ETH\\n   * @param interestRateMode The interest rate mode at which the user is borrowing\\n   * @param maxStableLoanPercent The max amount of the liquidity that can be borrowed at stable rate, in percentage\\n   * @param reservesData The state of all the reserves\\n   * @param userConfig The state of the user for the specific reserve\\n   * @param reserves The addresses of all the active reserves\\n   * @param oracle The price oracle\\n   */\\n\\n  function validateBorrow(\\n    address asset,\\n    DataTypes.ReserveData storage reserve,\\n    address userAddress,\\n    uint256 amount,\\n    uint256 amountInETH,\\n    uint256 interestRateMode,\\n    uint256 maxStableLoanPercent,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    DataTypes.UserConfigurationMap storage userConfig,\\n    mapping(uint256 => address) storage reserves,\\n    address oracle\\n  ) internal view {\\n    ValidateBorrowLocalVars memory vars;\\n\\n    (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserve\\n      .configuration\\n      .getFlags();\\n\\n    require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n    require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\\n\\n    require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\\n\\n    //validate interest rate mode\\n    require(\\n      uint256(DataTypes.InterestRateMode.VARIABLE) == interestRateMode ||\\n        uint256(DataTypes.InterestRateMode.STABLE) == interestRateMode,\\n      Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED\\n    );\\n\\n    (\\n      vars.userCollateralBalanceETH,\\n      vars.userBorrowBalanceETH,\\n      vars.currentLtv,\\n      vars.currentLiquidationThreshold,\\n      vars.healthFactor\\n    ) = GenericLogic.calculateUserAccountData(userAddress, reservesData, userConfig, reserves, oracle);\\n\\n    require(vars.userCollateralBalanceETH > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\\n\\n    require(\\n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\\n    );\\n\\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\\n    vars.amountOfCollateralNeededETH = (vars.userBorrowBalanceETH + amountInETH).percentDiv(vars.currentLtv); //LTV is calculated in percentage\\n\\n    require(\\n      vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\\n      Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW\\n    );\\n\\n    /**\\n     * Following conditions need to be met if the user is borrowing at a stable rate:\\n     * 1. Reserve must be enabled for stable rate borrowing\\n     * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\\n     *    they are borrowing, to prevent abuses.\\n     * 3. Users will be able to borrow only a portion of the total available liquidity\\n     **/\\n\\n    if (interestRateMode == uint256(DataTypes.InterestRateMode.STABLE)) {\\n      //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\\n\\n      require(vars.stableRateBorrowingEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED);\\n\\n      require(\\n        !userConfig.isUsingAsCollateral(reserve.id) ||\\n          reserve.configuration.getLtv() == 0 ||\\n          amount > IDepositToken(reserve.depositTokenAddress).collateralBalanceOf(userAddress),\\n        Errors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY\\n      );\\n\\n      vars.availableLiquidity = IERC20(asset).balanceOf(reserve.depositTokenAddress);\\n\\n      //calculate the max available loan size in stable rate mode as a percentage of the\\n      //available liquidity\\n      uint256 maxLoanSizeStable = vars.availableLiquidity.percentMul(maxStableLoanPercent);\\n\\n      require(amount <= maxLoanSizeStable, Errors.VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE);\\n    }\\n  }\\n\\n  /**\\n   * @dev Validates a repay action\\n   * @param reserve The reserve state from which the user is repaying\\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\\n   * @param onBehalfOf The address of the user msg.sender is repaying for\\n   * @param stableDebt The borrow balance of the user\\n   * @param variableDebt The borrow balance of the user\\n   */\\n  function validateRepay(\\n    DataTypes.ReserveData storage reserve,\\n    uint256 amountSent,\\n    DataTypes.InterestRateMode rateMode,\\n    address onBehalfOf,\\n    uint256 stableDebt,\\n    uint256 variableDebt\\n  ) internal view {\\n    bool isActive = reserve.configuration.getActive();\\n\\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n\\n    require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\\n\\n    require(\\n      (stableDebt > 0 && DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE) ||\\n        (variableDebt > 0 && DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.VARIABLE),\\n      Errors.VL_NO_DEBT_OF_SELECTED_TYPE\\n    );\\n\\n    require(amountSent != ~uint256(0) || msg.sender == onBehalfOf, Errors.VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF);\\n  }\\n\\n  /**\\n   * @dev Validates a swap of borrow rate mode.\\n   * @param reserve The reserve state on which the user is swapping the rate\\n   * @param userConfig The user reserves configuration\\n   * @param stableDebt The stable debt of the user\\n   * @param variableDebt The variable debt of the user\\n   * @param currentRateMode The rate mode of the borrow\\n   */\\n  function validateSwapRateMode(\\n    DataTypes.ReserveData storage reserve,\\n    DataTypes.UserConfigurationMap storage userConfig,\\n    uint256 stableDebt,\\n    uint256 variableDebt,\\n    DataTypes.InterestRateMode currentRateMode\\n  ) internal view {\\n    (bool isActive, bool isFrozen, , bool stableRateEnabled) = reserve.configuration.getFlags();\\n\\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\\n\\n    if (currentRateMode == DataTypes.InterestRateMode.STABLE) {\\n      require(stableDebt > 0, Errors.VL_NO_STABLE_RATE_LOAN_IN_RESERVE);\\n    } else if (currentRateMode == DataTypes.InterestRateMode.VARIABLE) {\\n      require(variableDebt > 0, Errors.VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE);\\n      /**\\n       * user wants to swap to stable, before swapping we need to ensure that\\n       * 1. stable borrow rate is enabled on the reserve\\n       * 2. user is not trying to abuse the reserve by depositing\\n       * more collateral than he is borrowing, artificially lowering\\n       * the interest rate, borrowing at variable, and switching to stable\\n       **/\\n      require(stableRateEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED);\\n\\n      require(\\n        !userConfig.isUsingAsCollateral(reserve.id) ||\\n          reserve.configuration.getLtv() == 0 ||\\n          (stableDebt + variableDebt) > IDepositToken(reserve.depositTokenAddress).collateralBalanceOf(msg.sender),\\n        Errors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY\\n      );\\n    } else {\\n      revert(Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED);\\n    }\\n  }\\n\\n  /**\\n   * @dev Validates a stable borrow rate rebalance action\\n   * @param reserve The reserve state on which the user is getting rebalanced\\n   * @param reserveAddress The address of the reserve\\n   * @param stableDebtToken The stable debt token instance\\n   * @param depositTokenAddress The address of the depositToken contract\\n   */\\n  function validateRebalanceStableBorrowRate(\\n    DataTypes.ReserveData storage reserve,\\n    address reserveAddress,\\n    IERC20 stableDebtToken,\\n    address depositTokenAddress\\n  ) internal view {\\n    (bool isActive, , , ) = reserve.configuration.getFlags();\\n\\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n\\n    uint256 usageRatio = stableDebtToken.totalSupply() + IERC20(reserve.variableDebtTokenAddress).totalSupply(); /* totalDebt */\\n    if (usageRatio != 0) {\\n      uint256 availableLiquidity = IERC20(reserveAddress).balanceOf(depositTokenAddress);\\n      usageRatio = usageRatio.wadToRay().wadDiv(\\n        availableLiquidity +\\n          /* totalDebt */\\n          usageRatio\\n      );\\n    }\\n\\n    //if the liquidity rate is below REBALANCE_UP_THRESHOLD of the max variable APR at 95% usage,\\n    //then we allow rebalancing of the stable rate positions.\\n\\n    uint256 currentLiquidityRate = reserve.currentLiquidityRate;\\n    uint256 maxVariableBorrowRate = IReserveRateStrategy(reserve.strategy).getMaxVariableBorrowRate();\\n\\n    require(\\n      usageRatio >= REBALANCE_UP_USAGE_RATIO_THRESHOLD &&\\n        currentLiquidityRate <= maxVariableBorrowRate.percentMul(REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD),\\n      Errors.LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET\\n    );\\n  }\\n\\n  /**\\n   * @dev Validates the action of setting an asset as collateral\\n   * @param reserve The state of the reserve that the user is enabling or disabling as collateral\\n   * @param reserveAddress The address of the reserve\\n   * @param reservesData The data of all the reserves\\n   * @param userConfig The state of the user for the specific reserve\\n   * @param reserves The addresses of all the active reserves\\n   * @param oracle The price oracle\\n   */\\n  function validateSetUseReserveAsCollateral(\\n    DataTypes.ReserveData storage reserve,\\n    address reserveAddress,\\n    bool useAsCollateral,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    DataTypes.UserConfigurationMap storage userConfig,\\n    mapping(uint256 => address) storage reserves,\\n    address oracle\\n  ) internal view {\\n    uint256 underlyingBalance = IDepositToken(reserve.depositTokenAddress).collateralBalanceOf(msg.sender);\\n\\n    require(underlyingBalance > 0, Errors.VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0);\\n\\n    if (!useAsCollateral) {\\n      require(!reserve.configuration.isExternalStrategy(), Errors.VL_RESERVE_MUST_BE_COLLATERAL);\\n\\n      require(\\n        GenericLogic.balanceDecreaseAllowed(\\n          reserveAddress,\\n          msg.sender,\\n          underlyingBalance,\\n          reservesData,\\n          userConfig,\\n          reserves,\\n          oracle\\n        ),\\n        Errors.VL_DEPOSIT_ALREADY_IN_USE\\n      );\\n    } else {\\n      require(reserve.configuration.getLtv() > 0, Errors.VL_RESERVE_MUST_BE_COLLATERAL);\\n    }\\n  }\\n\\n  /**\\n   * @dev Validates a flashloan action\\n   * @param assets The assets being flashborrowed\\n   * @param amounts The amounts for each asset being borrowed\\n   **/\\n  function validateFlashloan(address[] memory assets, uint256[] memory amounts) internal pure {\\n    require(assets.length == amounts.length, Errors.VL_INCONSISTENT_FLASHLOAN_PARAMS);\\n  }\\n\\n  /**\\n   * @dev Validates the liquidation action\\n   * @param collateralReserve The reserve data of the collateral\\n   * @param principalReserve The reserve data of the principal\\n   * @param userConfig The user configuration\\n   * @param userHealthFactor The user's health factor\\n   * @param userStableDebt Total stable debt balance of the user\\n   * @param userVariableDebt Total variable debt balance of the user\\n   **/\\n  function validateLiquidationCall(\\n    DataTypes.ReserveData storage collateralReserve,\\n    DataTypes.ReserveData storage principalReserve,\\n    DataTypes.UserConfigurationMap storage userConfig,\\n    uint256 userHealthFactor,\\n    uint256 userStableDebt,\\n    uint256 userVariableDebt\\n  ) internal view {\\n    require(\\n      collateralReserve.configuration.getActive() && principalReserve.configuration.getActive(),\\n      Errors.VL_NO_ACTIVE_RESERVE\\n    );\\n\\n    require(\\n      userHealthFactor < GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\\n      Errors.LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD\\n    );\\n\\n    //if collateral isn't enabled as collateral by user, it cannot be liquidated\\n    require(\\n      collateralReserve.configuration.getLiquidationThreshold() > 0 &&\\n        userConfig.isUsingAsCollateral(collateralReserve.id),\\n      Errors.LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED\\n    );\\n\\n    require(userStableDebt != 0 || userVariableDebt != 0, Errors.LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER);\\n  }\\n\\n  /**\\n   * @dev Validates an depositToken transfer\\n   * @param from The user from which the depositTokens are being transferred\\n   * @param reservesData The state of all the reserves\\n   * @param userConfig The state of the user for the specific reserve\\n   * @param reserves The addresses of all the active reserves\\n   * @param oracle The price oracle\\n   */\\n  function validateTransfer(\\n    address asset,\\n    address from,\\n    mapping(address => DataTypes.ReserveData) storage reservesData,\\n    DataTypes.UserConfigurationMap storage userConfig,\\n    mapping(uint256 => address) storage reserves,\\n    address oracle\\n  ) internal view {\\n    if (!userConfig.isBorrowingAny() || !userConfig.isUsingAsCollateral(reservesData[asset].id)) {\\n      return;\\n    }\\n\\n    (, , , , uint256 healthFactor) = GenericLogic.calculateUserAccountData(\\n      from,\\n      reservesData,\\n      userConfig,\\n      reserves,\\n      oracle\\n    );\\n\\n    require(healthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD, Errors.VL_TRANSFER_NOT_ALLOWED);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/logic/ReserveLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../../../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\\nimport '../../../interfaces/IDepositToken.sol';\\nimport '../../../interfaces/IStableDebtToken.sol';\\nimport '../../../interfaces/IVariableDebtToken.sol';\\nimport '../../../interfaces/IReserveRateStrategy.sol';\\nimport '../../../interfaces/IReserveDelegatedStrategy.sol';\\nimport '../configuration/ReserveConfiguration.sol';\\nimport '../../../tools/math/InterestMath.sol';\\nimport '../../../tools/math/WadRayMath.sol';\\nimport '../../../tools/math/PercentageMath.sol';\\nimport '../../../tools/Errors.sol';\\nimport '../types/DataTypes.sol';\\n\\n/**\\n * @title ReserveLogic library\\n * @notice Implements the logic to update the reserves state\\n */\\nlibrary ReserveLogic {\\n  using WadRayMath for uint256;\\n  using PercentageMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  uint256 private constant externalPastLimit = 10 minutes;\\n\\n  /**\\n   * @dev Emitted when the state of a reserve is updated\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param liquidityRate The new liquidity rate\\n   * @param stableBorrowRate The new stable borrow rate\\n   * @param variableBorrowRate The new variable borrow rate\\n   * @param liquidityIndex The new liquidity index\\n   * @param variableBorrowIndex The new variable borrow index\\n   **/\\n  event ReserveDataUpdated(\\n    address indexed asset,\\n    uint256 liquidityRate,\\n    uint256 stableBorrowRate,\\n    uint256 variableBorrowRate,\\n    uint256 liquidityIndex,\\n    uint256 variableBorrowIndex\\n  );\\n\\n  using ReserveLogic for DataTypes.ReserveData;\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n\\n  /**\\n   * @dev Returns the ongoing normalized income for the reserve\\n   * A value of 1e27 means there is no income. As time passes, the income is accrued\\n   * A value of 2*1e27 means for each unit of asset one unit of income has been accrued\\n   * @param reserve The reserve object\\n   * @return the normalized income. expressed in ray\\n   **/\\n  function getNormalizedIncome(DataTypes.ReserveData storage reserve, address asset) internal view returns (uint256) {\\n    uint40 timestamp = reserve.lastUpdateTimestamp;\\n\\n    if (timestamp == uint40(block.timestamp)) {\\n      //if the index was updated in the same block, no need to perform any calculation\\n      return reserve.liquidityIndex;\\n    }\\n\\n    if (reserve.configuration.isExternalStrategy()) {\\n      return IReserveDelegatedStrategy(reserve.strategy).getDelegatedDepositIndex(asset);\\n    }\\n\\n    return InterestMath.calculateLinearInterest(reserve.currentLiquidityRate, timestamp).rayMul(reserve.liquidityIndex);\\n  }\\n\\n  /**\\n   * @dev Returns the ongoing normalized variable debt for the reserve\\n   * A value of 1e27 means there is no debt. As time passes, the income is accrued\\n   * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\\n   * @param reserve The reserve object\\n   * @return The normalized variable debt. expressed in ray\\n   **/\\n  function getNormalizedDebt(DataTypes.ReserveData storage reserve) internal view returns (uint256) {\\n    uint40 timestamp = reserve.lastUpdateTimestamp;\\n\\n    if (timestamp == uint40(block.timestamp) || reserve.configuration.isExternalStrategy()) {\\n      //if the index was updated in the same block or is external, no need to perform any calculation\\n      return reserve.variableBorrowIndex;\\n    }\\n\\n    uint256 cumulated = InterestMath.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp).rayMul(\\n      reserve.variableBorrowIndex\\n    );\\n\\n    return cumulated;\\n  }\\n\\n  /**\\n   * @dev Updates the liquidity cumulative index and the variable borrow index.\\n   * @param reserve the reserve object\\n   **/\\n  function updateStateForDeposit(DataTypes.ReserveData storage reserve, address asset) internal returns (uint256) {\\n    if (reserve.configuration.isExternalStrategy()) {\\n      return _updateExternalIndexes(reserve, asset);\\n    }\\n    return _updateState(reserve);\\n  }\\n\\n  /**\\n   * @dev Updates the liquidity cumulative index and the variable borrow index.\\n   * @param reserve the reserve object\\n   **/\\n  function updateState(DataTypes.ReserveData storage reserve, address asset) internal {\\n    if (reserve.configuration.isExternalStrategy()) {\\n      if (reserve.lastUpdateTimestamp < uint40(block.timestamp)) {\\n        _updateExternalIndexes(reserve, asset);\\n      }\\n    } else {\\n      _updateState(reserve);\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates the liquidity cumulative index and the variable borrow index.\\n   * @param reserve the reserve object\\n   **/\\n  function _updateState(DataTypes.ReserveData storage reserve) private returns (uint256) {\\n    uint256 scaledVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress).scaledTotalSupply();\\n    uint256 previousVariableBorrowIndex = reserve.variableBorrowIndex;\\n    uint256 previousLiquidityIndex = reserve.liquidityIndex;\\n    uint40 lastUpdatedTimestamp = reserve.lastUpdateTimestamp;\\n\\n    (uint256 newLiquidityIndex, uint256 newVariableBorrowIndex) = _updateIndexes(\\n      reserve,\\n      scaledVariableDebt,\\n      previousLiquidityIndex,\\n      previousVariableBorrowIndex,\\n      lastUpdatedTimestamp\\n    );\\n\\n    _mintToTreasury(\\n      reserve,\\n      scaledVariableDebt,\\n      previousVariableBorrowIndex,\\n      newLiquidityIndex,\\n      newVariableBorrowIndex,\\n      lastUpdatedTimestamp\\n    );\\n\\n    return newLiquidityIndex;\\n  }\\n\\n  /**\\n   * @dev Accumulates a predefined amount of asset to the reserve as a fixed, instantaneous income. Used for example to accumulate\\n   * the flashloan fee to the reserve, and spread it between all the depositors\\n   * @param reserve The reserve object\\n   * @param totalLiquidity The total liquidity available in the reserve\\n   * @param amount The amount to accomulate\\n   **/\\n  function cumulateToLiquidityIndex(\\n    DataTypes.ReserveData storage reserve,\\n    uint256 totalLiquidity,\\n    uint256 amount\\n  ) internal {\\n    uint256 result = WadRayMath.RAY + amount.wadToRay().wadDiv(totalLiquidity);\\n\\n    result = result.rayMul(reserve.liquidityIndex);\\n    require(result <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\\n\\n    reserve.liquidityIndex = uint128(result);\\n  }\\n\\n  /**\\n   * @dev Initializes a reserve\\n   **/\\n  function init(DataTypes.ReserveData storage reserve, DataTypes.InitReserveData calldata data) internal {\\n    require(reserve.depositTokenAddress == address(0), Errors.RL_RESERVE_ALREADY_INITIALIZED);\\n\\n    reserve.liquidityIndex = uint128(WadRayMath.RAY);\\n    reserve.variableBorrowIndex = uint128(WadRayMath.RAY);\\n    reserve.depositTokenAddress = data.depositTokenAddress;\\n    reserve.stableDebtTokenAddress = data.stableDebtAddress;\\n    reserve.variableDebtTokenAddress = data.variableDebtAddress;\\n    reserve.strategy = data.strategy;\\n    {\\n      DataTypes.ReserveConfigurationMap memory cfg = reserve.configuration;\\n      cfg.setExternalStrategy(data.externalStrategy);\\n      reserve.configuration = cfg;\\n    }\\n  }\\n\\n  struct UpdateInterestRatesLocalVars {\\n    uint256 availableLiquidity;\\n    uint256 totalStableDebt;\\n    uint256 newLiquidityRate;\\n    uint256 newStableRate;\\n    uint256 newVariableRate;\\n    uint256 avgStableRate;\\n    uint256 totalVariableDebt;\\n  }\\n\\n  /**\\n   * @dev Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate\\n   * @param reserve The address of the reserve to be updated\\n   * @param liquidityAdded The amount of liquidity added to the protocol (deposit or repay)\\n   * @param liquidityTaken The amount of liquidity taken from the protocol (redeem or borrow)\\n   **/\\n  function updateInterestRates(\\n    DataTypes.ReserveData storage reserve,\\n    address reserveAddress,\\n    address depositToken,\\n    uint256 liquidityAdded,\\n    uint256 liquidityTaken\\n  ) internal {\\n    if (!reserve.configuration.isExternalStrategy()) {\\n      _updateInterestRates(reserve, reserveAddress, depositToken, liquidityAdded, liquidityTaken);\\n    }\\n    // // There is no need to be exactly at external's asset rate when we don't send or receive funds\\n    // else if (reserve.lastUpdateTimestamp < uint40(block.timestamp) || liquidityAdded != 0 || liquidityTaken != 0) {\\n    //   _updateExternalRates(reserve, reserveAddress);\\n    // }\\n  }\\n\\n  function _updateInterestRates(\\n    DataTypes.ReserveData storage reserve,\\n    address reserveAddress,\\n    address depositToken,\\n    uint256 liquidityAdded,\\n    uint256 liquidityTaken\\n  ) private {\\n    UpdateInterestRatesLocalVars memory vars;\\n\\n    (vars.totalStableDebt, vars.avgStableRate) = IStableDebtToken(reserve.stableDebtTokenAddress)\\n      .getTotalSupplyAndAvgRate();\\n\\n    //calculates the total variable debt locally using the scaled total supply instead\\n    //of totalSupply(), as it's noticeably cheaper. Also, the index has been\\n    //updated by the previous updateState() call\\n    vars.totalVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress).scaledTotalSupply().rayMul(\\n      reserve.variableBorrowIndex\\n    );\\n\\n    (vars.newLiquidityRate, vars.newStableRate, vars.newVariableRate) = IReserveRateStrategy(reserve.strategy)\\n      .calculateInterestRates(\\n        reserveAddress,\\n        depositToken,\\n        liquidityAdded,\\n        liquidityTaken,\\n        vars.totalStableDebt,\\n        vars.totalVariableDebt,\\n        vars.avgStableRate,\\n        reserve.configuration.getReserveFactor()\\n      );\\n    require(vars.newLiquidityRate <= type(uint128).max, Errors.RL_LIQUIDITY_RATE_OVERFLOW);\\n    require(vars.newStableRate <= type(uint128).max, Errors.RL_STABLE_BORROW_RATE_OVERFLOW);\\n    require(vars.newVariableRate <= type(uint128).max, Errors.RL_VARIABLE_BORROW_RATE_OVERFLOW);\\n\\n    reserve.currentLiquidityRate = uint128(vars.newLiquidityRate);\\n    reserve.currentStableBorrowRate = uint128(vars.newStableRate);\\n    reserve.currentVariableBorrowRate = uint128(vars.newVariableRate);\\n\\n    emit ReserveDataUpdated(\\n      reserveAddress,\\n      vars.newLiquidityRate,\\n      vars.newStableRate,\\n      vars.newVariableRate,\\n      reserve.liquidityIndex,\\n      reserve.variableBorrowIndex\\n    );\\n  }\\n\\n  struct MintToTreasuryLocalVars {\\n    uint256 currentStableDebt;\\n    uint256 principalStableDebt;\\n    uint256 previousStableDebt;\\n    uint256 currentVariableDebt;\\n    uint256 previousVariableDebt;\\n    uint256 avgStableRate;\\n    uint256 cumulatedStableInterest;\\n    uint256 totalDebtAccrued;\\n    uint256 amountToMint;\\n    uint256 reserveFactor;\\n    uint40 stableSupplyUpdatedTimestamp;\\n  }\\n\\n  /**\\n   * @dev Mints part of the repaid interest to the reserve treasury as a function of the reserveFactor for the\\n   * specific asset.\\n   * @param reserve The reserve reserve to be updated\\n   * @param scaledVariableDebt The current scaled total variable debt\\n   * @param previousVariableBorrowIndex The variable borrow index before the last accumulation of the interest\\n   * @param newLiquidityIndex The new liquidity index\\n   * @param newVariableBorrowIndex The variable borrow index after the last accumulation of the interest\\n   **/\\n  function _mintToTreasury(\\n    DataTypes.ReserveData storage reserve,\\n    uint256 scaledVariableDebt,\\n    uint256 previousVariableBorrowIndex,\\n    uint256 newLiquidityIndex,\\n    uint256 newVariableBorrowIndex,\\n    uint40 timestamp\\n  ) private {\\n    MintToTreasuryLocalVars memory vars;\\n\\n    vars.reserveFactor = reserve.configuration.getReserveFactor();\\n\\n    if (vars.reserveFactor == 0) {\\n      return;\\n    }\\n\\n    //fetching the principal, total stable debt and the avg stable rate\\n    (\\n      vars.principalStableDebt,\\n      vars.currentStableDebt,\\n      vars.avgStableRate,\\n      vars.stableSupplyUpdatedTimestamp\\n    ) = IStableDebtToken(reserve.stableDebtTokenAddress).getSupplyData();\\n\\n    //calculate the last principal variable debt\\n    vars.previousVariableDebt = scaledVariableDebt.rayMul(previousVariableBorrowIndex);\\n\\n    //calculate the new total supply after accumulation of the index\\n    vars.currentVariableDebt = scaledVariableDebt.rayMul(newVariableBorrowIndex);\\n\\n    //calculate the stable debt until the last timestamp update\\n    vars.cumulatedStableInterest = InterestMath.calculateCompoundedInterest(\\n      vars.avgStableRate,\\n      vars.stableSupplyUpdatedTimestamp,\\n      timestamp\\n    );\\n\\n    vars.previousStableDebt = vars.principalStableDebt.rayMul(vars.cumulatedStableInterest);\\n\\n    //debt accrued is the sum of the current debt minus the sum of the debt at the last update\\n    vars.totalDebtAccrued =\\n      (vars.currentVariableDebt + vars.currentStableDebt) -\\n      (vars.previousVariableDebt + vars.previousStableDebt);\\n\\n    vars.amountToMint = vars.totalDebtAccrued.percentMul(vars.reserveFactor);\\n\\n    if (vars.amountToMint != 0) {\\n      IDepositToken(reserve.depositTokenAddress).mintToTreasury(vars.amountToMint, newLiquidityIndex);\\n    }\\n  }\\n\\n  /**\\n   * @dev Updates the reserve indexes and the timestamp of the update\\n   * @param reserve The reserve reserve to be updated\\n   * @param scaledVariableDebt The scaled variable debt\\n   * @param liquidityIndex The last stored liquidity index\\n   * @param variableBorrowIndex The last stored variable borrow index\\n   **/\\n  function _updateIndexes(\\n    DataTypes.ReserveData storage reserve,\\n    uint256 scaledVariableDebt,\\n    uint256 liquidityIndex,\\n    uint256 variableBorrowIndex,\\n    uint40 timestamp\\n  ) private returns (uint256, uint256) {\\n    uint256 currentLiquidityRate = reserve.currentLiquidityRate;\\n\\n    uint256 newLiquidityIndex = liquidityIndex;\\n    uint256 newVariableBorrowIndex = variableBorrowIndex;\\n\\n    //only cumulating if there is any income being produced\\n    if (currentLiquidityRate > 0) {\\n      uint256 cumulatedLiquidityInterest = InterestMath.calculateLinearInterest(currentLiquidityRate, timestamp);\\n      newLiquidityIndex = cumulatedLiquidityInterest.rayMul(liquidityIndex);\\n      require(newLiquidityIndex <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\\n\\n      reserve.liquidityIndex = uint128(newLiquidityIndex);\\n\\n      //as the liquidity rate might come only from stable rate loans, we need to ensure\\n      //that there is actual variable debt before accumulating\\n      if (scaledVariableDebt != 0) {\\n        uint256 cumulatedVariableBorrowInterest = InterestMath.calculateCompoundedInterest(\\n          reserve.currentVariableBorrowRate,\\n          timestamp\\n        );\\n        newVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(variableBorrowIndex);\\n        require(newVariableBorrowIndex <= type(uint128).max, Errors.RL_VARIABLE_BORROW_INDEX_OVERFLOW);\\n        reserve.variableBorrowIndex = uint128(newVariableBorrowIndex);\\n      }\\n    }\\n\\n    reserve.lastUpdateTimestamp = uint40(block.timestamp);\\n    return (newLiquidityIndex, newVariableBorrowIndex);\\n  }\\n\\n  function _updateExternalIndexes(DataTypes.ReserveData storage reserve, address asset) private returns (uint256) {\\n    IReserveDelegatedStrategy.DelegatedState memory state = IReserveDelegatedStrategy(reserve.strategy)\\n      .getDelegatedState(asset, reserve.lastUpdateTimestamp);\\n    require(state.lastUpdateTimestamp <= block.timestamp);\\n\\n    if (state.lastUpdateTimestamp == reserve.lastUpdateTimestamp) {\\n      if (state.liquidityIndex == reserve.liquidityIndex) {\\n        return state.liquidityIndex;\\n      }\\n    } else {\\n      require(state.lastUpdateTimestamp > reserve.lastUpdateTimestamp);\\n      reserve.lastUpdateTimestamp = state.lastUpdateTimestamp;\\n    }\\n\\n    reserve.variableBorrowIndex = state.variableBorrowIndex;\\n    reserve.currentLiquidityRate = state.liquidityRate;\\n    reserve.currentVariableBorrowRate = state.variableBorrowRate;\\n    reserve.currentStableBorrowRate = state.stableBorrowRate;\\n    reserve.liquidityIndex = state.liquidityIndex;\\n\\n    return state.liquidityIndex;\\n  }\\n\\n  // function _updateExternalRates(DataTypes.ReserveData storage reserve, address asset) private {\\n  //   // nothing to do - all was updated inside _updateExternalIndexes\\n  // }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/types/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nlibrary DataTypes {\\n  struct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128 liquidityIndex;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128 currentLiquidityRate;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    //the current stable borrow rate. Expressed in ray\\n    uint128 currentStableBorrowRate;\\n    uint40 lastUpdateTimestamp;\\n    //tokens addresses\\n    address depositTokenAddress;\\n    address stableDebtTokenAddress;\\n    address variableDebtTokenAddress;\\n    //address of the reserve strategy\\n    address strategy;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint8 id;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: Reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60-63: reserved\\n    //bit 64-79: reserve factor\\n    //bit 80: strategy is external\\n    uint256 data;\\n  }\\n\\n  struct UserConfigurationMap {\\n    uint256 data;\\n  }\\n\\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\\n\\n  struct InitReserveData {\\n    address asset;\\n    address depositTokenAddress;\\n    address stableDebtAddress;\\n    address variableDebtAddress;\\n    address strategy;\\n    bool externalStrategy;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/lendingpool/LendingPoolBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../../access/interfaces/IMarketAccessController.sol';\\nimport '../../access/AccessHelper.sol';\\nimport '../../access/AccessFlags.sol';\\nimport '../../interfaces/IEmergencyAccess.sol';\\nimport '../../tools/Errors.sol';\\nimport './LendingPoolStorage.sol';\\n\\nabstract contract LendingPoolBase is IEmergencyAccess, LendingPoolStorage {\\n  using AccessHelper for IMarketAccessController;\\n\\n  function _whenNotPaused() private view {\\n    require(!_paused, Errors.LP_IS_PAUSED);\\n  }\\n\\n  modifier whenNotPaused() {\\n    _whenNotPaused();\\n    _;\\n  }\\n\\n  function _onlyLendingPoolConfigurator() private view {\\n    _addressesProvider.requireAnyOf(\\n      msg.sender,\\n      AccessFlags.LENDING_POOL_CONFIGURATOR,\\n      Errors.LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR\\n    );\\n  }\\n\\n  modifier onlyLendingPoolConfigurator() {\\n    // This trick makes generated code smaller when modifier is applied multiple times.\\n    _onlyLendingPoolConfigurator();\\n    _;\\n  }\\n\\n  function _onlyConfiguratorOrAdmin() private view {\\n    _addressesProvider.requireAnyOf(\\n      msg.sender,\\n      AccessFlags.POOL_ADMIN | AccessFlags.LENDING_POOL_CONFIGURATOR,\\n      Errors.CALLER_NOT_POOL_ADMIN\\n    );\\n  }\\n\\n  modifier onlyConfiguratorOrAdmin() {\\n    _onlyConfiguratorOrAdmin();\\n    _;\\n  }\\n\\n  function _notNestedCall() private view {\\n    require(_nestedCalls == 0, Errors.LP_TOO_MANY_NESTED_CALLS);\\n  }\\n\\n  modifier noReentry() {\\n    _notNestedCall();\\n    _nestedCalls++;\\n    _;\\n    _nestedCalls--;\\n  }\\n\\n  function _noReentryOrFlashloan() private view {\\n    _notNestedCall();\\n    require(_flashloanCalls == 0, Errors.LP_TOO_MANY_FLASHLOAN_CALLS);\\n  }\\n\\n  modifier noReentryOrFlashloan() {\\n    _noReentryOrFlashloan();\\n    _nestedCalls++;\\n    _;\\n    _nestedCalls--;\\n  }\\n\\n  function _noReentryOrFlashloanFeature(uint16 featureFlag) private view {\\n    _notNestedCall();\\n    require(featureFlag & _disabledFeatures == 0 || _flashloanCalls == 0, Errors.LP_TOO_MANY_FLASHLOAN_CALLS);\\n  }\\n\\n  modifier noReentryOrFlashloanFeature(uint16 featureFlag) {\\n    _noReentryOrFlashloanFeature(featureFlag);\\n    _nestedCalls++;\\n    _;\\n    _nestedCalls--;\\n  }\\n\\n  function _onlyEmergencyAdmin() internal view {\\n    _addressesProvider.requireAnyOf(msg.sender, AccessFlags.EMERGENCY_ADMIN, Errors.CALLER_NOT_EMERGENCY_ADMIN);\\n  }\\n\\n  function setPaused(bool val) external override {\\n    _onlyEmergencyAdmin();\\n    _paused = val;\\n    emit EmergencyPaused(msg.sender, val);\\n  }\\n\\n  function isPaused() external view override returns (bool) {\\n    return _paused;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/access/interfaces/IAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport './IRemoteAccessBitmask.sol';\\nimport '../../tools/upgradeability/IProxy.sol';\\n\\n/// @dev Main registry of permissions and addresses\\ninterface IAccessController is IRemoteAccessBitmask {\\n  function getAddress(uint256 id) external view returns (address);\\n\\n  function createProxy(\\n    address admin,\\n    address impl,\\n    bytes calldata params\\n  ) external returns (IProxy);\\n}\\n\"\r\n    },\r\n    \"contracts/access/interfaces/IRemoteAccessBitmask.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\ninterface IRemoteAccessBitmask {\\n  /**\\n   * @dev Returns access flags granted to the given address and limited by the filterMask. filterMask == 0 has a special meaning.\\n   * @param addr an to get access perfmissions for\\n   * @param filterMask limits a subset of flags to be checked.\\n   * NB! When filterMask == 0 then zero is returned no flags granted, or an unspecified non-zero value otherwise.\\n   * @return Access flags currently granted\\n   */\\n  function queryAccessControlMask(address addr, uint256 filterMask) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/tools/upgradeability/IProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\ninterface IProxy {\\n  function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IScaledBalanceToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\ninterface IScaledBalanceToken {\\n  /**\\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\\n   * @param user The user whose balance is calculated\\n   * @return The scaled balance of the user\\n   **/\\n  function scaledBalanceOf(address user) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the scaled balance of the user and the scaled total supply.\\n   * @param user The address of the user\\n   * @return The scaled balance of the user\\n   * @return The scaled balance and the scaled total supply\\n   **/\\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\\n\\n  /**\\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\\n   * @return The scaled total supply\\n   **/\\n  function scaledTotalSupply() external view returns (uint256);\\n\\n  function getScaleIndex() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport './IDerivedToken.sol';\\n\\n// solhint-disable func-name-mixedcase\\ninterface IPoolToken is IDerivedToken {\\n  function POOL() external view returns (address);\\n\\n  function updatePool() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDerivedToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\n// solhint-disable func-name-mixedcase\\ninterface IDerivedToken {\\n  /**\\n   * @dev Returns the address of the underlying asset of this token (E.g. WETH for agWETH)\\n   **/\\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPoolEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../access/interfaces/IMarketAccessController.sol';\\nimport '../protocol/libraries/types/DataTypes.sol';\\n\\ninterface ILendingPoolEvents {\\n  /// @dev Emitted on deposit()\\n  event Deposit(\\n    address indexed reserve,\\n    address user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    uint256 indexed referral\\n  );\\n\\n  /// @dev Emitted on withdraw()\\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\\n\\n  /// @dev Emitted on borrow() and flashLoan() when debt needs to be opened\\n  event Borrow(\\n    address indexed reserve,\\n    address user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    uint256 borrowRateMode,\\n    uint256 borrowRate,\\n    uint256 indexed referral\\n  );\\n\\n  /// @dev Emitted on repay()\\n  event Repay(\\n    address indexed reserve,\\n    address indexed user,\\n    address indexed repayer,\\n    uint256 amount\\n  );\\n\\n  /// @dev Emitted on swapBorrowRateMode()\\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\\n\\n  /// @dev Emitted on setUserUseReserveAsCollateral()\\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\\n\\n  /// @dev Emitted on setUserUseReserveAsCollateral()\\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\\n\\n  /// @dev Emitted on rebalanceStableBorrowRate()\\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\\n\\n  /// @dev Emitted on flashLoan()\\n  event FlashLoan(\\n    address indexed target,\\n    address indexed initiator,\\n    address indexed asset,\\n    uint256 amount,\\n    uint256 premium,\\n    uint256 referral\\n  );\\n\\n  /// @dev Emitted when a borrower is liquidated.\\n  event LiquidationCall(\\n    address indexed collateralAsset,\\n    address indexed debtAsset,\\n    address indexed user,\\n    uint256 debtToCover,\\n    uint256 liquidatedCollateralAmount,\\n    address liquidator,\\n    bool receiveDeposit\\n  );\\n\\n  /// @dev Emitted when the state of a reserve is updated.\\n  event ReserveDataUpdated(\\n    address indexed underlying,\\n    uint256 liquidityRate,\\n    uint256 stableBorrowRate,\\n    uint256 variableBorrowRate,\\n    uint256 liquidityIndex,\\n    uint256 variableBorrowIndex\\n  );\\n\\n  event LendingPoolExtensionUpdated(address extension);\\n\\n  event DisabledFeaturesUpdated(uint16 disabledFeatures);\\n\\n  event FlashLoanPremiumUpdated(uint16 premium);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFlashLoanAddressProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport './IPoolAddressProvider.sol';\\n\\ninterface IFlashLoanAddressProvider is IPoolAddressProvider {}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolAddressProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport './IPriceOracleProvider.sol';\\n\\ninterface IPoolAddressProvider is IPriceOracleProvider {\\n  function getLendingPool() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceOracleProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\ninterface IPriceOracleProvider {\\n  function getPriceOracle() external view returns (address);\\n\\n  function getLendingRateOracle() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBalanceHook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\ninterface IBalanceHook {\\n  function handleBalanceUpdate(\\n    address token,\\n    address holder,\\n    uint256 oldBalance,\\n    uint256 newBalance,\\n    uint256 providerSupply\\n  ) external;\\n\\n  function handleScaledBalanceUpdate(\\n    address token,\\n    address holder,\\n    uint256 oldBalance,\\n    uint256 newBalance,\\n    uint256 providerSupply,\\n    uint256 scaleRay\\n  ) external;\\n\\n  function isScaledBalanceUpdateNeeded() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/configuration/ReserveConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../../../tools/Errors.sol';\\nimport '../types/DataTypes.sol';\\n\\n/// @dev ReserveConfiguration library, implements the bitmap logic to handle the reserve configuration\\nlibrary ReserveConfiguration {\\n  uint256 private constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\\n  uint256 private constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\\n  uint256 private constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\\n  uint256 private constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\\n  uint256 private constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 private constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 private constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 private constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 private constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 private constant STRATEGY_TYPE_MASK =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n\\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\\n  uint256 private constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\\n  uint256 private constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\\n  uint256 private constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\\n  uint256 private constant RESERVE_FACTOR_START_BIT_POSITION = 64;\\n\\n  uint256 private constant MAX_VALID_LTV = 65535;\\n  uint256 private constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\\n  uint256 private constant MAX_VALID_LIQUIDATION_BONUS = 65535;\\n  uint256 private constant MAX_VALID_DECIMALS = 255;\\n  uint256 private constant MAX_VALID_RESERVE_FACTOR = 65535;\\n\\n  /// @dev Sets the Loan to Value of the reserve\\n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\\n    require(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV);\\n\\n    self.data = (self.data & LTV_MASK) | ltv;\\n  }\\n\\n  /// @dev Gets the Loan to Value of the reserve\\n  function getLtv(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return self.data & ~LTV_MASK;\\n  }\\n\\n  function setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold) internal pure {\\n    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD);\\n\\n    self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\\n  }\\n\\n  function getLiquidationThreshold(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\\n  }\\n\\n  function setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus) internal pure {\\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS);\\n\\n    self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\\n  }\\n\\n  function getLiquidationBonus(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\\n  }\\n\\n  function setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals) internal pure {\\n    require(decimals <= MAX_VALID_DECIMALS, Errors.RC_INVALID_DECIMALS);\\n\\n    self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\\n  }\\n\\n  function getDecimals(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\\n  }\\n\\n  function getDecimalsMemory(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint8) {\\n    return uint8((self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION);\\n  }\\n\\n  function _setFlag(\\n    DataTypes.ReserveConfigurationMap memory self,\\n    uint256 mask,\\n    bool value\\n  ) internal pure {\\n    if (value) {\\n      self.data |= ~mask;\\n    } else {\\n      self.data &= mask;\\n    }\\n  }\\n\\n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\\n    _setFlag(self, ACTIVE_MASK, active);\\n  }\\n\\n  function getActive(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~ACTIVE_MASK) != 0;\\n  }\\n\\n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\\n    _setFlag(self, FROZEN_MASK, frozen);\\n  }\\n\\n  function getFrozen(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~FROZEN_MASK) != 0;\\n  }\\n\\n  function getFrozenMemory(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\\n    return (self.data & ~FROZEN_MASK) != 0;\\n  }\\n\\n  function setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {\\n    _setFlag(self, BORROWING_MASK, enabled);\\n  }\\n\\n  function getBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~BORROWING_MASK) != 0;\\n  }\\n\\n  function setStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {\\n    _setFlag(self, STABLE_BORROWING_MASK, enabled);\\n  }\\n\\n  function getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~STABLE_BORROWING_MASK) != 0;\\n  }\\n\\n  function setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor) internal pure {\\n    require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.RC_INVALID_RESERVE_FACTOR);\\n\\n    self.data = (self.data & RESERVE_FACTOR_MASK) | (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\\n  }\\n\\n  function getReserveFactor(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\\n  }\\n\\n  /// @dev Returns flags: active, frozen, borrowing enabled, stableRateBorrowing enabled\\n  function getFlags(DataTypes.ReserveConfigurationMap storage self)\\n    internal\\n    view\\n    returns (\\n      bool,\\n      bool,\\n      bool,\\n      bool\\n    )\\n  {\\n    return _getFlags(self.data);\\n  }\\n\\n  function getFlagsMemory(DataTypes.ReserveConfigurationMap memory self)\\n    internal\\n    pure\\n    returns (\\n      bool active,\\n      bool frozen,\\n      bool borrowEnable,\\n      bool stableBorrowEnable\\n    )\\n  {\\n    return _getFlags(self.data);\\n  }\\n\\n  function _getFlags(uint256 data)\\n    private\\n    pure\\n    returns (\\n      bool,\\n      bool,\\n      bool,\\n      bool\\n    )\\n  {\\n    return (\\n      (data & ~ACTIVE_MASK) != 0,\\n      (data & ~FROZEN_MASK) != 0,\\n      (data & ~BORROWING_MASK) != 0,\\n      (data & ~STABLE_BORROWING_MASK) != 0\\n    );\\n  }\\n\\n  /// @dev Paramters of the reserve: ltv, liquidation threshold, liquidation bonus, the reserve decimals\\n  function getParams(DataTypes.ReserveConfigurationMap storage self)\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    return _getParams(self.data);\\n  }\\n\\n  /// @dev Paramters of the reserve: ltv, liquidation threshold, liquidation bonus, the reserve decimals\\n  function getParamsMemory(DataTypes.ReserveConfigurationMap memory self)\\n    internal\\n    pure\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    return _getParams(self.data);\\n  }\\n\\n  function _getParams(uint256 dataLocal)\\n    private\\n    pure\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    return (\\n      dataLocal & ~LTV_MASK,\\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\\n    );\\n  }\\n\\n  function isExternalStrategyMemory(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\\n    return (self.data & ~STRATEGY_TYPE_MASK) != 0;\\n  }\\n\\n  function isExternalStrategy(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~STRATEGY_TYPE_MASK) != 0;\\n  }\\n\\n  function setExternalStrategy(DataTypes.ReserveConfigurationMap memory self, bool isExternal) internal pure {\\n    _setFlag(self, STRATEGY_TYPE_MASK, isExternal);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/configuration/UserConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../../../tools/Errors.sol';\\nimport '../types/DataTypes.sol';\\n\\n/// @dev Implements the bitmap logic to handle the user configuration\\nlibrary UserConfiguration {\\n  uint256 private constant ANY_BORROWING_MASK = 0x5555555555555555555555555555555555555555555555555555555555555555;\\n  uint256 private constant BORROW_BIT_MASK = 1;\\n  uint256 private constant COLLATERAL_BIT_MASK = 2;\\n  uint256 internal constant ANY_MASK = BORROW_BIT_MASK | COLLATERAL_BIT_MASK;\\n  uint256 internal constant SHIFT_STEP = 2;\\n\\n  function setBorrowing(DataTypes.UserConfigurationMap storage self, uint256 reserveIndex) internal {\\n    self.data |= BORROW_BIT_MASK << (reserveIndex << 1);\\n  }\\n\\n  function unsetBorrowing(DataTypes.UserConfigurationMap storage self, uint256 reserveIndex) internal {\\n    self.data &= ~(BORROW_BIT_MASK << (reserveIndex << 1));\\n  }\\n\\n  function setUsingAsCollateral(DataTypes.UserConfigurationMap storage self, uint256 reserveIndex) internal {\\n    self.data |= COLLATERAL_BIT_MASK << (reserveIndex << 1);\\n  }\\n\\n  function unsetUsingAsCollateral(DataTypes.UserConfigurationMap storage self, uint256 reserveIndex) internal {\\n    self.data &= ~(COLLATERAL_BIT_MASK << (reserveIndex << 1));\\n  }\\n\\n  /// @dev Returns true if the user is using the reserve for borrowing\\n  function isBorrowing(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex) internal pure returns (bool) {\\n    return (self.data >> (reserveIndex << 1)) & BORROW_BIT_MASK != 0;\\n  }\\n\\n  /// @dev Returns true if the user is using the reserve as collateral\\n  function isUsingAsCollateral(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return (self.data >> (reserveIndex << 1)) & COLLATERAL_BIT_MASK != 0;\\n  }\\n\\n  /// @dev Returns true if the user is borrowing from any reserve\\n  function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\\n    return self.data & ANY_BORROWING_MASK != 0;\\n  }\\n\\n  /// @dev Returns true if the user is not using any reserve\\n  function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\\n    return self.data == 0;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/tools/math/PercentageMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../Errors.sol';\\n\\n/// @dev Percentages are defined in basis points. The precision is indicated by ONE. Operations are rounded half up.\\nlibrary PercentageMath {\\n  uint16 public constant BP = 1; // basis point\\n  uint16 public constant PCT = 100 * BP; // basis points per percentage point\\n  uint16 public constant ONE = 100 * PCT; // basis points per 1 (100%)\\n  uint16 public constant HALF_ONE = ONE / 2;\\n  // deprecated\\n  uint256 public constant PERCENTAGE_FACTOR = ONE; //percentage plus two decimals\\n\\n  /**\\n   * @dev Executes a percentage multiplication\\n   * @param value The value of which the percentage needs to be calculated\\n   * @param factor Basis points of the value to be calculated\\n   * @return The percentage of value\\n   **/\\n  function percentMul(uint256 value, uint256 factor) internal pure returns (uint256) {\\n    if (value == 0 || factor == 0) {\\n      return 0;\\n    }\\n\\n    require(value <= (type(uint256).max - HALF_ONE) / factor, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (value * factor + HALF_ONE) / ONE;\\n  }\\n\\n  /**\\n   * @dev Executes a percentage division\\n   * @param value The value of which the percentage needs to be calculated\\n   * @param factor Basis points of the value to be calculated\\n   * @return The value divided the percentage\\n   **/\\n  function percentDiv(uint256 value, uint256 factor) internal pure returns (uint256) {\\n    require(factor != 0, Errors.MATH_DIVISION_BY_ZERO);\\n    uint256 halfFactor = factor >> 1;\\n\\n    require(value <= (type(uint256).max - halfFactor) / ONE, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (value * ONE + halfFactor) / factor;\\n  }\\n\\n  function percentOf(uint256 value, uint256 base) internal pure returns (uint256) {\\n    require(base != 0, Errors.MATH_DIVISION_BY_ZERO);\\n    if (value == 0) {\\n      return 0;\\n    }\\n\\n    require(value <= (type(uint256).max - HALF_ONE) / ONE, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (value * ONE + (base >> 1)) / base;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceOracleGetter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nenum SourceType {\\n  AggregatorOrStatic,\\n  UniswapV2Pair\\n}\\n\\ninterface IPriceOracleEvents {\\n  event AssetPriceUpdated(address asset, uint256 price, uint256 timestamp);\\n  event EthPriceUpdated(uint256 price, uint256 timestamp);\\n  event DerivedAssetSourceUpdated(\\n    address indexed asset,\\n    uint256 index,\\n    address indexed underlyingSource,\\n    uint256 underlyingPrice,\\n    uint256 timestamp,\\n    SourceType sourceType\\n  );\\n}\\n\\n/// @dev Interface for a price oracle.\\ninterface IPriceOracleGetter is IPriceOracleEvents {\\n  /// @dev returns the asset price in ETH\\n  function getAssetPrice(address asset) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReserveRateStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport './IReserveStrategy.sol';\\n\\n/// @dev Strategy to control a lending pool reserve\\ninterface IReserveRateStrategy is IReserveStrategy {\\n  function baseVariableBorrowRate() external view returns (uint256);\\n\\n  function getMaxVariableBorrowRate() external view returns (uint256);\\n\\n  function calculateInterestRates(\\n    address reserve,\\n    address depositToken,\\n    uint256 liquidityAdded,\\n    uint256 liquidityTaken,\\n    uint256 totalStableDebt,\\n    uint256 totalVariableDebt,\\n    uint256 averageStableBorrowRate,\\n    uint256 reserveFactor\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 liquidityRate,\\n      uint256 stableBorrowRate,\\n      uint256 variableBorrowRate\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReserveDelegatedStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport './IReserveStrategy.sol';\\nimport './IUnderlyingStrategy.sol';\\n\\n/// @dev Interface to access the interest rate of an external asset\\ninterface IReserveDelegatedStrategy is IReserveStrategy, IUnderlyingStrategy {\\n  /// @dev all indexes and rates are expressed in ray\\n  struct DelegatedState {\\n    uint128 liquidityIndex;\\n    uint128 variableBorrowIndex;\\n    uint128 liquidityRate;\\n    uint128 variableBorrowRate;\\n    uint128 stableBorrowRate;\\n    uint40 lastUpdateTimestamp;\\n  }\\n\\n  function getDelegatedState(address underlyingToken, uint40 lastUpdateTimestamp)\\n    external\\n    returns (DelegatedState memory);\\n\\n  function getDelegatedDepositIndex(address underlyingToken) external view returns (uint256 liquidityIndex);\\n\\n  function getStrategyName() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/tools/math/InterestMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport './WadRayMath.sol';\\n\\nlibrary InterestMath {\\n  using WadRayMath for uint256;\\n\\n  /// @dev Ignoring leap years\\n  uint256 internal constant SECONDS_PER_YEAR = 365 days;\\n  uint256 internal constant MILLIS_PER_YEAR = SECONDS_PER_YEAR * 1000;\\n\\n  /**\\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\\n   * @param rate The annual interest rate, in ray\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n   * @return The interest rate linearly accumulated during the timeDelta, in ray\\n   **/\\n  function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {\\n    return WadRayMath.RAY + (rate * (block.timestamp - lastUpdateTimestamp)) / SECONDS_PER_YEAR;\\n  }\\n\\n  /**\\n   * @dev Function to calculate the interest using a compounded interest rate formula\\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\\n   *\\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\\n   *\\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\\n   *\\n   * @param rate The interest rate, in ray\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n   * @return The interest rate compounded during the timeDelta, in ray\\n   **/\\n  function calculateCompoundedInterest(\\n    uint256 rate,\\n    uint40 lastUpdateTimestamp,\\n    uint256 currentTimestamp\\n  ) internal pure returns (uint256) {\\n    uint256 exp = currentTimestamp - lastUpdateTimestamp;\\n\\n    if (exp == 0) {\\n      return WadRayMath.ray();\\n    }\\n\\n    uint256 expMinusOne = exp - 1;\\n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\\n\\n    uint256 ratePerSecond = rate / SECONDS_PER_YEAR;\\n\\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\\n\\n    uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\\n    uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\\n\\n    return WadRayMath.RAY + exp * ratePerSecond + secondTerm + thirdTerm;\\n  }\\n\\n  /**\\n   * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\\n   * @param rate The interest rate (in ray)\\n   * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\\n   **/\\n  function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp) internal view returns (uint256) {\\n    return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReserveStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\ninterface IReserveStrategy {\\n  function isDelegatedReserve() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUnderlyingStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\ninterface IUnderlyingStrategy {\\n  function getUnderlying(address asset) external view returns (address);\\n\\n  function delegatedWithdrawUnderlying(\\n    address asset,\\n    uint256 amount,\\n    address to\\n  ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/access/AccessFlags.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nlibrary AccessFlags {\\n  // roles that can be assigned to multiple addresses - use range [0..15]\\n  uint256 public constant EMERGENCY_ADMIN = 1 << 0;\\n  uint256 public constant POOL_ADMIN = 1 << 1;\\n  uint256 public constant TREASURY_ADMIN = 1 << 2;\\n  uint256 public constant REWARD_CONFIG_ADMIN = 1 << 3;\\n  uint256 public constant REWARD_RATE_ADMIN = 1 << 4;\\n  uint256 public constant STAKE_ADMIN = 1 << 5;\\n  uint256 public constant REFERRAL_ADMIN = 1 << 6;\\n  uint256 public constant LENDING_RATE_ADMIN = 1 << 7;\\n  uint256 public constant SWEEP_ADMIN = 1 << 8;\\n  uint256 public constant ORACLE_ADMIN = 1 << 9;\\n\\n  uint256 public constant ROLES = (uint256(1) << 16) - 1;\\n\\n  // singletons - use range [16..64] - can ONLY be assigned to a single address\\n  uint256 public constant SINGLETONS = ((uint256(1) << 64) - 1) & ~ROLES;\\n\\n  // proxied singletons\\n  uint256 public constant LENDING_POOL = 1 << 16;\\n  uint256 public constant LENDING_POOL_CONFIGURATOR = 1 << 17;\\n  uint256 public constant LIQUIDITY_CONTROLLER = 1 << 18;\\n  uint256 public constant TREASURY = 1 << 19;\\n  uint256 public constant REWARD_TOKEN = 1 << 20;\\n  uint256 public constant REWARD_STAKE_TOKEN = 1 << 21;\\n  uint256 public constant REWARD_CONTROLLER = 1 << 22;\\n  uint256 public constant REWARD_CONFIGURATOR = 1 << 23;\\n  uint256 public constant STAKE_CONFIGURATOR = 1 << 24;\\n  uint256 public constant REFERRAL_REGISTRY = 1 << 25;\\n\\n  uint256 public constant PROXIES = ((uint256(1) << 26) - 1) & ~ROLES;\\n\\n  // non-proxied singletons, numbered down from 31 (as JS has problems with bitmasks over 31 bits)\\n  uint256 public constant WETH_GATEWAY = 1 << 27;\\n  uint256 public constant DATA_HELPER = 1 << 28;\\n  uint256 public constant PRICE_ORACLE = 1 << 29;\\n  uint256 public constant LENDING_RATE_ORACLE = 1 << 30;\\n\\n  // any other roles - use range [64..]\\n  // these roles can be assigned to multiple addresses\\n\\n  uint256 public constant TRUSTED_FLASHLOAN = 1 << 66;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEmergencyAccess.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\ninterface IEmergencyAccess {\\n  function setPaused(bool paused) external;\\n\\n  function isPaused() external view returns (bool);\\n\\n  event EmergencyPaused(address indexed by, bool paused);\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/lendingpool/LendingPoolStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\nimport '../../tools/upgradeability/VersionedInitializable.sol';\\nimport '../../access/interfaces/IMarketAccessController.sol';\\nimport '../libraries/types/DataTypes.sol';\\n\\nabstract contract LendingPoolStorage is VersionedInitializable {\\n  IMarketAccessController internal _addressesProvider;\\n  address internal _extension;\\n\\n  mapping(address => DataTypes.ReserveData) internal _reserves;\\n  mapping(address => DataTypes.UserConfigurationMap) internal _usersConfig;\\n\\n  // the list of the available reserves, structured as a mapping for gas savings reasons\\n  mapping(uint256 => address) internal _reservesList;\\n\\n  uint16 internal _maxStableRateBorrowSizePct;\\n\\n  uint16 internal _flashLoanPremiumPct;\\n\\n  uint16 internal constant FEATURE_LIQUIDATION = 1 << 0;\\n  uint16 internal constant FEATURE_FLASHLOAN = 1 << 1;\\n  uint16 internal constant FEATURE_FLASHLOAN_DEPOSIT = 1 << 2;\\n  uint16 internal constant FEATURE_FLASHLOAN_WITHDRAW = 1 << 3;\\n  uint16 internal constant FEATURE_FLASHLOAN_BORROW = 1 << 4;\\n  uint16 internal constant FEATURE_FLASHLOAN_REPAY = 1 << 5;\\n  uint16 internal _disabledFeatures;\\n\\n  uint8 internal _reservesCount;\\n\\n  uint8 internal constant _maxNumberOfReserves = 128;\\n\\n  uint8 internal _flashloanCalls;\\n  uint8 internal _nestedCalls;\\n\\n  bool internal _paused;\\n\\n  mapping(address => address[]) internal _indirectUnderlying;\\n}\\n\"\r\n    },\r\n    \"contracts/tools/upgradeability/VersionedInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title VersionedInitializable\\n *\\n * @dev Helper contract to implement versioned initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` or `initializerRunAlways` modifier.\\n * The revision number should be defined as a private constant, returned by getRevision() and used by initializer() modifier.\\n *\\n * ATTN: There is a built-in protection from implementation self-destruct exploits. This protection\\n * prevents initializers from being called on an implementation inself, but only on proxied contracts.\\n * To override this protection, call _unsafeResetVersionedInitializers() from a constructor.\\n *\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an initializable contract, as well\\n * as extending an initializable contract via inheritance.\\n *\\n * ATTN: When used with inheritance, parent initializers with `initializer` modifier are prevented by calling twice,\\n * but can only be called in child-to-parent sequence.\\n *\\n * WARNING: When used with inheritance, parent initializers with `initializerRunAlways` modifier\\n * are NOT protected from multiple calls by another initializer.\\n */\\nabstract contract VersionedInitializable {\\n  uint256 private constant BLOCK_REVISION = type(uint256).max;\\n  // This revision number is applied to implementations\\n  uint256 private constant IMPL_REVISION = BLOCK_REVISION - 1;\\n\\n  /// @dev Indicates that the contract has been initialized. The default value blocks initializers from being called on an implementation.\\n  uint256 private lastInitializedRevision = IMPL_REVISION;\\n\\n  /// @dev Indicates that the contract is in the process of being initialized.\\n  uint256 private lastInitializingRevision = 0;\\n\\n  /**\\n   * @dev There is a built-in protection from self-destruct of implementation exploits. This protection\\n   * prevents initializers from being called on an implementation inself, but only on proxied contracts.\\n   * Function _unsafeResetVersionedInitializers() can be called from a constructor to disable this protection.\\n   * It must be called before any initializers, otherwise it will fail.\\n   */\\n  function _unsafeResetVersionedInitializers() internal {\\n    require(isConstructor(), 'only for constructor');\\n\\n    if (lastInitializedRevision == IMPL_REVISION) {\\n      lastInitializedRevision = 0;\\n    } else {\\n      require(lastInitializedRevision == 0, 'can only be called before initializer(s)');\\n    }\\n  }\\n\\n  /// @dev Modifier to use in the initializer function of a contract.\\n  modifier initializer(uint256 localRevision) {\\n    (uint256 topRevision, bool initializing, bool skip) = _preInitializer(localRevision);\\n\\n    if (!skip) {\\n      lastInitializingRevision = localRevision;\\n      _;\\n      lastInitializedRevision = localRevision;\\n    }\\n\\n    if (!initializing) {\\n      lastInitializedRevision = topRevision;\\n      lastInitializingRevision = 0;\\n    }\\n  }\\n\\n  modifier initializerRunAlways(uint256 localRevision) {\\n    (uint256 topRevision, bool initializing, bool skip) = _preInitializer(localRevision);\\n\\n    if (!skip) {\\n      lastInitializingRevision = localRevision;\\n    }\\n    _;\\n    if (!skip) {\\n      lastInitializedRevision = localRevision;\\n    }\\n\\n    if (!initializing) {\\n      lastInitializedRevision = topRevision;\\n      lastInitializingRevision = 0;\\n    }\\n  }\\n\\n  function _preInitializer(uint256 localRevision)\\n    private\\n    returns (\\n      uint256 topRevision,\\n      bool initializing,\\n      bool skip\\n    )\\n  {\\n    topRevision = getRevision();\\n    require(topRevision < IMPL_REVISION, 'invalid contract revision');\\n\\n    require(localRevision > 0, 'incorrect initializer revision');\\n    require(localRevision <= topRevision, 'inconsistent contract revision');\\n\\n    if (lastInitializedRevision < IMPL_REVISION) {\\n      // normal initialization\\n      initializing = lastInitializingRevision > 0 && lastInitializedRevision < topRevision;\\n      require(initializing || isConstructor() || topRevision > lastInitializedRevision, 'already initialized');\\n    } else {\\n      // by default, initialization of implementation is only allowed inside a constructor\\n      require(lastInitializedRevision == IMPL_REVISION && isConstructor(), 'initializer blocked');\\n\\n      // enable normal use of initializers inside a constructor\\n      lastInitializedRevision = 0;\\n      // but make sure to block initializers afterwards\\n      topRevision = BLOCK_REVISION;\\n\\n      initializing = lastInitializingRevision > 0;\\n    }\\n\\n    if (initializing) {\\n      require(lastInitializingRevision > localRevision, 'incorrect order of initializers');\\n    }\\n\\n    if (localRevision <= lastInitializedRevision) {\\n      // prevent calling of parent's initializer when it was called before\\n      if (initializing) {\\n        // Can't set zero yet, as it is not a top-level call, otherwise `initializing` will become false.\\n        // Further calls will fail with the `incorrect order` assertion above.\\n        lastInitializingRevision = 1;\\n      }\\n      return (topRevision, initializing, true);\\n    }\\n    return (topRevision, initializing, false);\\n  }\\n\\n  function isRevisionInitialized(uint256 localRevision) internal view returns (bool) {\\n    return lastInitializedRevision >= localRevision;\\n  }\\n\\n  // solhint-disable-next-line func-name-mixedcase\\n  function REVISION() public pure returns (uint256) {\\n    return getRevision();\\n  }\\n\\n  /**\\n   * @dev returns the revision number (< type(uint256).max - 1) of the contract.\\n   * The number should be defined as a private constant.\\n   **/\\n  function getRevision() internal pure virtual returns (uint256);\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    uint256 cs;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      cs := extcodesize(address())\\n    }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[4] private ______gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowRateMode\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"referral\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"referral\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"disabledFeatures\",\"type\":\"uint16\"}],\"name\":\"DisabledFeaturesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"EmergencyPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referral\",\"type\":\"uint256\"}],\"name\":\"FlashLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"premium\",\"type\":\"uint16\"}],\"name\":\"FlashLoanPremiumUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"extension\",\"type\":\"address\"}],\"name\":\"LendingPoolExtensionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"debtAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtToCover\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidatedCollateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"receiveDeposit\",\"type\":\"bool\"}],\"name\":\"LiquidationCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RebalanceStableBorrowRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"repayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Repay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stableBorrowRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"variableBorrowRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"variableBorrowIndex\",\"type\":\"uint256\"}],\"name\":\"ReserveDataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ReserveUsedAsCollateralDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ReserveUsedAsCollateralEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateMode\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"FLASHLOAN_PREMIUM_TOTAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_STABLE_RATE_BORROW_SIZE_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REVISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referral\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"referral\",\"type\":\"uint16\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"lastBalanceFrom\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"firstBalanceTo\",\"type\":\"bool\"}],\"name\":\"finalizeTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"flashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"flashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAccessController\",\"outputs\":[{\"internalType\":\"contract IMarketAccessController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddressesProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getConfiguration\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.ReserveConfigurationMap\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFlashloanPremiumPct\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLendingPoolExtension\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getReserveData\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.ReserveConfigurationMap\",\"name\":\"configuration\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"liquidityIndex\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"variableBorrowIndex\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentLiquidityRate\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentVariableBorrowRate\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"currentStableBorrowRate\",\"type\":\"uint128\"},{\"internalType\":\"uint40\",\"name\":\"lastUpdateTimestamp\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"depositTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stableDebtTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"variableDebtTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"internalType\":\"struct DataTypes.ReserveData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getReserveNormalizedIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getReserveNormalizedVariableDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReservesList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserAccountData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCollateralETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebtETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableBorrowsETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentLiquidationThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ltv\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"healthFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserConfiguration\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.UserConfigurationMap\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarketAccessController\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"liquidationCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"rebalanceStableBorrowRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateMode\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"}],\"name\":\"repay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"extension\",\"type\":\"address\"}],\"name\":\"setLendingPoolExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"setReservePaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useAsCollateral\",\"type\":\"bool\"}],\"name\":\"setUserUseReserveAsCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rateMode\",\"type\":\"uint256\"}],\"name\":\"swapBorrowRateMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LendingPoolCompatible","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}