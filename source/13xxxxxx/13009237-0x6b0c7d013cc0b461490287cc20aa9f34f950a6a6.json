{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.16;\r\n\r\n\r\n// Copied from compound/EIP20Interface\r\n/**\r\n * @title ERC 20 Token Standard Interface\r\n *  https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface EIP20Interface {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n      * @notice Get the total number of tokens in circulation\r\n      * @return The supply of tokens\r\n      */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets the balance of the specified address\r\n     * @param owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      * @return Whether or not the transfer succeeded\r\n      */\r\n    function transfer(address dst, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `src` to `dst`\r\n      * @param src The address of the source account\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      * @return Whether or not the transfer succeeded\r\n      */\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Approve `spender` to transfer up to `amount` from `src`\r\n      * @dev This will overwrite the approval amount for `spender`\r\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @param amount The number of tokens that are approved (-1 means infinite)\r\n      * @return Whether or not the approval succeeded\r\n      */\r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Get the current allowance from `owner` for `spender`\r\n      * @param owner The address of the account which owns the tokens to be spent\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @return The number of tokens allowed to be spent (-1 means infinite)\r\n      */\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n\r\n// Copied from compound/EIP20NonStandardInterface\r\n/**\r\n * @title EIP20NonStandardInterface\r\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\r\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n */\r\ninterface EIP20NonStandardInterface {\r\n\r\n    /**\r\n     * @notice Get the total number of tokens in circulation\r\n     * @return The supply of tokens\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets the balance of the specified address\r\n     * @param owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    ///\r\n    /// !!!!!!!!!!!!!!\r\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\r\n    /// !!!!!!!!!!!!!!\r\n    ///\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      */\r\n    function transfer(address dst, uint256 amount) external;\r\n\r\n    ///\r\n    /// !!!!!!!!!!!!!!\r\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\r\n    /// !!!!!!!!!!!!!!\r\n    ///\r\n\r\n    /**\r\n      * @notice Transfer `amount` tokens from `src` to `dst`\r\n      * @param src The address of the source account\r\n      * @param dst The address of the destination account\r\n      * @param amount The number of tokens to transfer\r\n      */\r\n    function transferFrom(address src, address dst, uint256 amount) external;\r\n\r\n    /**\r\n      * @notice Approve `spender` to transfer up to `amount` from `src`\r\n      * @dev This will overwrite the approval amount for `spender`\r\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @param amount The number of tokens that are approved\r\n      * @return Whether or not the approval succeeded\r\n      */\r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    /**\r\n      * @notice Get the current allowance from `owner` for `spender`\r\n      * @param owner The address of the account which owns the tokens to be spent\r\n      * @param spender The address of the account which may transfer tokens\r\n      * @return The number of tokens allowed to be spent\r\n      */\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n\r\n// Copied from Compound/ExponentialNoError\r\n/**\r\n * @title Exponential module for storing fixed-precision decimals\r\n * @author DeFil\r\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\r\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\r\n *         `Exp({mantissa: 5100000000000000000})`.\r\n */\r\ncontract ExponentialNoError {\r\n    uint constant expScale = 1e18;\r\n    uint constant doubleScale = 1e36;\r\n    uint constant halfExpScale = expScale/2;\r\n    uint constant mantissaOne = expScale;\r\n\r\n    struct Exp {\r\n        uint mantissa;\r\n    }\r\n\r\n    struct Double {\r\n        uint mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Truncates the given exp to a whole number value.\r\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\r\n     */\r\n    function truncate(Exp memory exp) pure internal returns (uint) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / expScale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\r\n     */\r\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\r\n        Exp memory product = mul_(a, scalar);\r\n        return truncate(product);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\r\n     */\r\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\r\n        Exp memory product = mul_(a, scalar);\r\n        return add_(truncate(product), addend);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is less than second Exp.\r\n     */\r\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa < right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp <= right Exp.\r\n     */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp > right Exp.\r\n     */\r\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\r\n        return left.mantissa > right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if Exp is exactly zero\r\n     */\r\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n\r\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\r\n        require(n < 2**224, errorMessage);\r\n        return uint224(n);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function add_(uint a, uint b) pure internal returns (uint) {\r\n        return add_(a, b, \"addition overflow\");\r\n    }\r\n\r\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\r\n    }\r\n\r\n    function sub_(uint a, uint b) pure internal returns (uint) {\r\n        return sub_(a, b, \"subtraction underflow\");\r\n    }\r\n\r\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\r\n    }\r\n\r\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / expScale;\r\n    }\r\n\r\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\r\n    }\r\n\r\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: mul_(a.mantissa, b)});\r\n    }\r\n\r\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\r\n        return mul_(a, b.mantissa) / doubleScale;\r\n    }\r\n\r\n    function mul_(uint a, uint b) pure internal returns (uint) {\r\n        return mul_(a, b, \"multiplication overflow\");\r\n    }\r\n\r\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        require(c / a == b, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\r\n        return Exp({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, expScale), b.mantissa);\r\n    }\r\n\r\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\r\n    }\r\n\r\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(a.mantissa, b)});\r\n    }\r\n\r\n    function div_(uint a, Double memory b) pure internal returns (uint) {\r\n        return div_(mul_(a, doubleScale), b.mantissa);\r\n    }\r\n\r\n    function div_(uint a, uint b) pure internal returns (uint) {\r\n        return div_(a, b, \"divide by zero\");\r\n    }\r\n\r\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\r\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\r\n    }\r\n}\r\n\r\ninterface Distributor {\r\n    // The asset to be distributed\r\n    function asset() external view returns (address);\r\n\r\n    // Return the accrued amount of account based on stored data\r\n    function accruedStored(address account) external view returns (uint);\r\n\r\n    // Accrue and distribute for caller, but not actually transfer assets to the caller\r\n    // returns the new accrued amount\r\n    function accrue() external returns (uint);\r\n\r\n    // Claim asset, transfer the given amount assets to receiver\r\n    function claim(address receiver, uint amount) external returns (uint);\r\n}\r\n\r\ncontract Redistributor is Distributor, ExponentialNoError {\r\n    /**\r\n     * @notice The superior Distributor contract\r\n     */\r\n    Distributor public superior;\r\n\r\n    // The accrued amount of this address in superior Distributor\r\n    uint public superiorAccruedAmount;\r\n\r\n    // The initial accrual index\r\n    uint internal constant initialAccruedIndex = 1e36;\r\n\r\n    // The last accrued block number\r\n    uint public accrualBlockNumber;\r\n\r\n    // The last accrued index\r\n    uint public globalAccruedIndex;\r\n\r\n    // Total count of shares.\r\n    uint internal totalShares;\r\n\r\n    struct AccountState {\r\n        /// @notice The share of account\r\n        uint share;\r\n        // The last accrued index of account\r\n        uint accruedIndex;\r\n        /// @notice The accrued but not yet transferred to account\r\n        uint accruedAmount;\r\n    }\r\n\r\n    // The AccountState for each account\r\n    mapping(address => AccountState) internal accountStates;\r\n\r\n    /*** Events ***/\r\n    // Emitted when dfl is accrued\r\n    event Accrued(uint amount, uint globalAccruedIndex);\r\n\r\n    // Emitted when distribute to a account\r\n    event Distributed(address account, uint amount, uint accruedIndex);\r\n\r\n    // Emitted when account claims asset\r\n    event Claimed(address account, address receiver, uint amount);\r\n\r\n    // Emitted when account transfer asset\r\n    event Transferred(address from, address to, uint amount);\r\n\r\n    constructor(Distributor superior_) public {\r\n        // set superior\r\n        superior = superior_;\r\n        // init accrued index\r\n        globalAccruedIndex = initialAccruedIndex;\r\n    }\r\n\r\n    function asset() external view returns (address) {\r\n        return superior.asset();\r\n    }\r\n\r\n    // Return the accrued amount of account based on stored data\r\n    function accruedStored(address account) external view returns(uint) {\r\n        uint storedGlobalAccruedIndex;\r\n        if (totalShares == 0) {\r\n            storedGlobalAccruedIndex = globalAccruedIndex;\r\n        } else {\r\n            uint superiorAccruedStored = superior.accruedStored(address(this));\r\n            uint delta = sub_(superiorAccruedStored, superiorAccruedAmount);\r\n\r\n            Double memory ratio = fraction(delta, totalShares);\r\n            Double memory doubleGlobalAccruedIndex = add_(Double({mantissa: globalAccruedIndex}), ratio);\r\n            storedGlobalAccruedIndex = doubleGlobalAccruedIndex.mantissa;\r\n        }\r\n\r\n        (, uint instantAccountAccruedAmount) = accruedStoredInternal(account, storedGlobalAccruedIndex);\r\n        return instantAccountAccruedAmount;\r\n    }\r\n\r\n    // Return the accrued amount of account based on stored data\r\n    function accruedStoredInternal(address account, uint withGlobalAccruedIndex) internal view returns(uint, uint) {\r\n        AccountState memory state = accountStates[account];\r\n\r\n        Double memory doubleGlobalAccruedIndex = Double({mantissa: withGlobalAccruedIndex});\r\n        Double memory doubleAccountAccruedIndex = Double({mantissa: state.accruedIndex});\r\n        if (doubleAccountAccruedIndex.mantissa == 0 && doubleGlobalAccruedIndex.mantissa > 0) {\r\n            doubleAccountAccruedIndex.mantissa = initialAccruedIndex;\r\n        }\r\n\r\n        Double memory deltaIndex = sub_(doubleGlobalAccruedIndex, doubleAccountAccruedIndex);\r\n        uint delta = mul_(state.share, deltaIndex);\r\n\r\n        return (delta, add_(state.accruedAmount, delta));\r\n    }\r\n\r\n    function accrueInternal() internal {\r\n        uint blockNumber = getBlockNumber();\r\n        if (accrualBlockNumber == blockNumber) {\r\n            return;\r\n        }\r\n\r\n        uint newSuperiorAccruedAmount = superior.accrue();\r\n        if (totalShares == 0) {\r\n            accrualBlockNumber = blockNumber;\r\n            return;\r\n        }\r\n\r\n        uint delta = sub_(newSuperiorAccruedAmount, superiorAccruedAmount);\r\n\r\n        Double memory ratio = fraction(delta, totalShares);\r\n        Double memory doubleAccruedIndex = add_(Double({mantissa: globalAccruedIndex}), ratio);\r\n\r\n        // update globalAccruedIndex\r\n        globalAccruedIndex = doubleAccruedIndex.mantissa;\r\n        superiorAccruedAmount = newSuperiorAccruedAmount;\r\n        accrualBlockNumber = blockNumber;\r\n\r\n        emit Accrued(delta, doubleAccruedIndex.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @notice accrue and returns accrued stored of msg.sender\r\n     */\r\n    function accrue() external returns (uint) {\r\n        accrueInternal();\r\n\r\n        (, uint instantAccountAccruedAmount) = accruedStoredInternal(msg.sender, globalAccruedIndex);\r\n        return instantAccountAccruedAmount;\r\n    }\r\n\r\n    function distributeInternal(address account) internal {\r\n        (uint delta, uint instantAccruedAmount) = accruedStoredInternal(account, globalAccruedIndex);\r\n\r\n        AccountState storage state = accountStates[account];\r\n        state.accruedIndex = globalAccruedIndex;\r\n        state.accruedAmount = instantAccruedAmount;\r\n\r\n        // emit Distributed event\r\n        emit Distributed(account, delta, globalAccruedIndex);\r\n    }\r\n\r\n    function claim(address receiver, uint amount) external returns (uint) {\r\n        address account = msg.sender;\r\n\r\n        // keep fresh\r\n        accrueInternal();\r\n        distributeInternal(account);\r\n\r\n        AccountState storage state = accountStates[account];\r\n        require(amount <= state.accruedAmount, \"claim: insufficient value\");\r\n\r\n        // claim from superior\r\n        require(superior.claim(receiver, amount) == amount, \"claim: amount mismatch\");\r\n\r\n        // update storage\r\n        state.accruedAmount = sub_(state.accruedAmount, amount);\r\n        superiorAccruedAmount = sub_(superiorAccruedAmount, amount);\r\n\r\n        emit Claimed(account, receiver, amount);\r\n\r\n        return amount;\r\n    }\r\n\r\n    function claimAll() external {\r\n        address account = msg.sender;\r\n\r\n        // accrue and distribute\r\n        accrueInternal();\r\n        distributeInternal(account);\r\n\r\n        AccountState storage state = accountStates[account];\r\n        uint amount = state.accruedAmount;\r\n\r\n        // claim from superior\r\n        require(superior.claim(account, amount) == amount, \"claim: amount mismatch\");\r\n\r\n        // update storage\r\n        state.accruedAmount = 0;\r\n        superiorAccruedAmount = sub_(superiorAccruedAmount, amount);\r\n\r\n        emit Claimed(account, account, amount);\r\n    }\r\n\r\n    function transfer(address to, uint amount) external {\r\n        address from = msg.sender;\r\n\r\n        // keep fresh\r\n        accrueInternal();\r\n        distributeInternal(from);\r\n\r\n        AccountState storage fromState = accountStates[from];\r\n        uint actualAmount = amount;\r\n        if (actualAmount == 0) {\r\n            actualAmount = fromState.accruedAmount;\r\n        }\r\n        require(fromState.accruedAmount >= actualAmount, \"transfer: insufficient value\");\r\n\r\n        AccountState storage toState = accountStates[to];\r\n\r\n        // update storage\r\n        fromState.accruedAmount = sub_(fromState.accruedAmount, actualAmount);\r\n        toState.accruedAmount = add_(toState.accruedAmount, actualAmount);\r\n\r\n        emit Transferred(from, to, actualAmount);\r\n    }\r\n\r\n    function getBlockNumber() public view returns (uint) {\r\n        return block.number;\r\n    }\r\n}\r\n\r\ncontract Staking is Redistributor {\r\n    // The token to deposit\r\n    address public property;\r\n\r\n    /*** Events ***/\r\n    // Event emitted when new property tokens is deposited\r\n    event Deposit(address account, uint amount);\r\n\r\n    // Event emitted when new property tokens is withdrawed\r\n    event Withdraw(address account, uint amount);\r\n\r\n    constructor(address property_, Distributor superior_) Redistributor(superior_) public {\r\n        property = property_;\r\n    }\r\n\r\n    function totalDeposits() external view returns (uint) {\r\n        return totalShares;\r\n    }\r\n\r\n    function accountState(address account) external view returns (uint, uint, uint) {\r\n        AccountState memory state = accountStates[account];\r\n        return (state.share, state.accruedIndex, state.accruedAmount);\r\n    }\r\n\r\n    // Deposit property tokens\r\n    function deposit(uint amount) external returns (uint) {\r\n        address account = msg.sender;\r\n\r\n        // accrue & distribute\r\n        accrueInternal();\r\n        distributeInternal(account);\r\n\r\n        // transfer property token in\r\n        uint actualAmount = doTransferIn(account, amount);\r\n\r\n        // update storage\r\n        AccountState storage state = accountStates[account];\r\n        totalShares = add_(totalShares, actualAmount);\r\n        state.share = add_(state.share, actualAmount);\r\n\r\n        emit Deposit(account, actualAmount);\r\n\r\n        return actualAmount;\r\n    }\r\n\r\n    // Withdraw property tokens\r\n    function withdraw(uint amount) external returns (uint) {\r\n        address account = msg.sender;\r\n        AccountState storage state = accountStates[account];\r\n        require(state.share >= amount, \"withdraw: insufficient value\");\r\n\r\n        // accrue & distribute\r\n        accrueInternal();\r\n        distributeInternal(account);\r\n\r\n        // decrease total deposits\r\n        totalShares = sub_(totalShares, amount);\r\n        state.share = sub_(state.share, amount);\r\n\r\n        // transfer property tokens back to account\r\n        doTransferOut(account, amount);\r\n\r\n        emit Withdraw(account, amount);\r\n\r\n        return amount;\r\n    }\r\n\r\n    /*** Safe Token ***/\r\n\r\n    /**\r\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\r\n     *      This will revert due to insufficient balance or insufficient allowance.\r\n     *      This function returns the actual amount received,\r\n     *      which may be less than `amount` if there is a fee attached to the transfer.\r\n     *\r\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\r\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n     */\r\n    function doTransferIn(address from, uint amount) internal returns (uint) {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(property);\r\n        uint balanceBefore = EIP20Interface(property).balanceOf(address(this));\r\n        token.transferFrom(from, address(this), amount);\r\n\r\n        bool success;\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                       // This is a non-standard ERC-20\r\n                    success := not(0)          // set success to true\r\n                }\r\n                case 32 {                      // This is a compliant ERC-20\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)        // Set `success = returndata` of external call\r\n                }\r\n                default {                      // This is an excessively non-compliant ERC-20, revert.\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\r\n\r\n        // Calculate the amount that was *actually* transferred\r\n        uint balanceAfter = EIP20Interface(property).balanceOf(address(this));\r\n        require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\r\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\r\n    }\r\n\r\n    /**\r\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\r\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\r\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\r\n     *      it is >= amount, this should not revert in normal conditions.\r\n     *\r\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\r\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n     */\r\n    function doTransferOut(address to, uint amount) internal {\r\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(property);\r\n        token.transfer(to, amount);\r\n\r\n        bool success;\r\n        assembly {\r\n            switch returndatasize()\r\n                case 0 {                      // This is a non-standard ERC-20\r\n                    success := not(0)          // set success to true\r\n                }\r\n                case 32 {                     // This is a complaint ERC-20\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)        // Set `success = returndata` of external call\r\n                }\r\n                default {                     // This is an excessively non-compliant ERC-20, revert.\r\n                    revert(0, 0)\r\n                }\r\n        }\r\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"property_\",\"type\":\"address\"},{\"internalType\":\"contract Distributor\",\"name\":\"superior_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"globalAccruedIndex\",\"type\":\"uint256\"}],\"name\":\"Accrued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accruedIndex\",\"type\":\"uint256\"}],\"name\":\"Distributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"accountState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accrualBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"accrue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"accruedStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalAccruedIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"property\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superior\",\"outputs\":[{\"internalType\":\"contract Distributor\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superiorAccruedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Staking","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d372a3221021df72eda38f77117d3a95f057e163000000000000000000000000e67ae15cbb7f6b009f12c4c8999ca3ff4c39463d","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://dcfe5fda2275a269dd33b870b306cbd34d53a4b91a877aa06f4f15c5b2272b1e"}]}