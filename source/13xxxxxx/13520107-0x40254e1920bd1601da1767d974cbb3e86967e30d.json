{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.17;\r\n\r\n/**\r\n * @title Avastar Data Types\r\n * @author Cliff Hall\r\n */\r\ncontract AvastarTypes {\r\n\r\n    enum Generation {\r\n        ONE,\r\n        TWO,\r\n        THREE,\r\n        FOUR,\r\n        FIVE\r\n    }\r\n\r\n    enum Series {\r\n        PROMO,\r\n        ONE,\r\n        TWO,\r\n        THREE,\r\n        FOUR,\r\n        FIVE\r\n    }\r\n\r\n    enum Wave {\r\n        PRIME,\r\n        REPLICANT\r\n    }\r\n\r\n    enum Gene {\r\n        SKIN_TONE,\r\n        HAIR_COLOR,\r\n        EYE_COLOR,\r\n        BG_COLOR,\r\n        BACKDROP,\r\n        EARS,\r\n        FACE,\r\n        NOSE,\r\n        MOUTH,\r\n        FACIAL_FEATURE,\r\n        EYES,\r\n        HAIR_STYLE\r\n    }\r\n\r\n    enum Gender {\r\n        ANY,\r\n        MALE,\r\n        FEMALE\r\n    }\r\n\r\n    enum Rarity {\r\n        COMMON,\r\n        UNCOMMON,\r\n        RARE,\r\n        EPIC,\r\n        LEGENDARY\r\n    }\r\n\r\n    struct Trait {\r\n        uint256 id;\r\n        Generation generation;\r\n        Gender gender;\r\n        Gene gene;\r\n        Rarity rarity;\r\n        uint8 variation;\r\n        Series[] series;\r\n        string name;\r\n        string svg;\r\n\r\n    }\r\n\r\n    struct Prime {\r\n        uint256 id;\r\n        uint256 serial;\r\n        uint256 traits;\r\n        bool[12] replicated;\r\n        Generation generation;\r\n        Series series;\r\n        Gender gender;\r\n        uint8 ranking;\r\n    }\r\n\r\n    struct Replicant {\r\n        uint256 id;\r\n        uint256 serial;\r\n        uint256 traits;\r\n        Generation generation;\r\n        Gender gender;\r\n        uint8 ranking;\r\n    }\r\n\r\n    struct Avastar {\r\n        uint256 id;\r\n        uint256 serial;\r\n        uint256 traits;\r\n        Generation generation;\r\n        Wave wave;\r\n    }\r\n\r\n    struct Attribution {\r\n        Generation generation;\r\n        string artist;\r\n        string infoURI;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/IAvastarTeleporter.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n/**\r\n * @title AvastarTeleporter Interface\r\n * @author Cliff Hall\r\n * @notice Declared as abstract contract rather than interface as it must inherit for enum types.\r\n * Used by AvastarMinter contract to interact with subset of AvastarTeleporter contract functions.\r\n */\r\ncontract IAvastarTeleporter is AvastarTypes {\r\n\r\n    /**\r\n     * @notice Acknowledge contract is `AvastarTeleporter`\r\n     * @return always true if the contract is in fact `AvastarTeleporter`\r\n     */\r\n    function isAvastarTeleporter() external pure returns (bool);\r\n\r\n    /**\r\n     * @notice Get token URI for a given Avastar Token ID.\r\n     * Reverts if given token id is not a valid Avastar Token ID.\r\n     * @param _tokenId the Token ID of a previously minted Avastar Prime or Replicant\r\n     * @return uri the off-chain URI to the JSON metadata for the given Avastar\r\n     */\r\n    function tokenURI(uint _tokenId)\r\n    external view\r\n    returns (string memory uri);\r\n\r\n    /**\r\n     * @notice Get an Avastar's Wave by token ID.\r\n     * @param _tokenId the token id of the given Avastar\r\n     * @return wave the Avastar's wave (Prime/Replicant)\r\n     */\r\n    function getAvastarWaveByTokenId(uint256 _tokenId)\r\n    external view\r\n    returns (Wave wave);\r\n\r\n    /**\r\n     * @notice Get the Avastar Prime metadata associated with a given Token ID.\r\n     * @param _tokenId the Token ID of the specified Prime\r\n     * @return tokenId the Prime's token ID\r\n     * @return serial the Prime's serial\r\n     * @return traits the Prime's trait hash\r\n     * @return generation the Prime's generation\r\n     * @return series the Prime's series\r\n     * @return gender the Prime's gender\r\n     * @return ranking the Prime's ranking\r\n     */\r\n    function getPrimeByTokenId(uint256 _tokenId)\r\n    external view\r\n    returns (\r\n        uint256 tokenId,\r\n        uint256 serial,\r\n        uint256 traits,\r\n        Generation generation,\r\n        Series series,\r\n        Gender gender,\r\n        uint8 ranking\r\n    );\r\n\r\n    /**\r\n     * @notice Get the Avastar Replicant metadata associated with a given Token ID\r\n     * @param _tokenId the token ID of the specified Replicant\r\n     * @return tokenId the Replicant's token ID\r\n     * @return serial the Replicant's serial\r\n     * @return traits the Replicant's trait hash\r\n     * @return generation the Replicant's generation\r\n     * @return gender the Replicant's gender\r\n     * @return ranking the Replicant's ranking\r\n     */\r\n    function getReplicantByTokenId(uint256 _tokenId)\r\n    external view\r\n    returns (\r\n        uint256 tokenId,\r\n        uint256 serial,\r\n        uint256 traits,\r\n        Generation generation,\r\n        Gender gender,\r\n        uint8 ranking\r\n    );\r\n\r\n    /**\r\n     * @notice Retrieve a Trait's info by ID.\r\n     * @param _traitId the ID of the Trait to retrieve\r\n     * @return id the ID of the trait\r\n     * @return generation generation of the trait\r\n     * @return series list of series the trait may appear in\r\n     * @return gender gender(s) the trait is valid for\r\n     * @return gene gene the trait belongs to\r\n     * @return variation variation of the gene the trait represents\r\n     * @return rarity the rarity level of this trait\r\n     * @return name name of the trait\r\n     */\r\n    function getTraitInfoById(uint256 _traitId)\r\n    external view\r\n    returns (\r\n        uint256 id,\r\n        Generation generation,\r\n        Series[] memory series,\r\n        Gender gender,\r\n        Gene gene,\r\n        Rarity rarity,\r\n        uint8 variation,\r\n        string memory name\r\n    );\r\n\r\n\r\n    /**\r\n     * @notice Retrieve a Trait's name by ID.\r\n     * @param _traitId the ID of the Trait to retrieve\r\n     * @return name name of the trait\r\n     */\r\n    function getTraitNameById(uint256 _traitId)\r\n    external view\r\n    returns (string memory name);\r\n\r\n    /**\r\n     * @notice Get Trait ID by Generation, Gene, and Variation.\r\n     * @param _generation the generation the trait belongs to\r\n     * @param _gene gene the trait belongs to\r\n     * @param _variation the variation of the gene\r\n     * @return traitId the ID of the specified trait\r\n     */\r\n    function getTraitIdByGenerationGeneAndVariation(\r\n        Generation _generation,\r\n        Gene _gene,\r\n        uint8 _variation\r\n    )\r\n    external view\r\n    returns (uint256 traitId);\r\n\r\n    /**\r\n     * @notice Get the artist Attribution for a given Generation, combined into a single string.\r\n     * @param _generation the generation to retrieve artist attribution for\r\n     * @return attribution a single string with the artist and artist info URI\r\n     */\r\n    function getAttributionByGeneration(Generation _generation)\r\n    external view\r\n    returns (\r\n        string memory attribution\r\n    );\r\n\r\n    /**\r\n     * @notice Mint an Avastar Prime\r\n     * Only invokable by minter role, when contract is not paused.\r\n     * If successful, emits a `NewPrime` event.\r\n     * @param _owner the address of the new Avastar's owner\r\n     * @param _traits the new Prime's trait hash\r\n     * @param _generation the new Prime's generation\r\n     * @return _series the new Prime's series\r\n     * @param _gender the new Prime's gender\r\n     * @param _ranking the new Prime's rarity ranking\r\n     * @return tokenId the newly minted Prime's token ID\r\n     * @return serial the newly minted Prime's serial\r\n     */\r\n    function mintPrime(\r\n        address _owner,\r\n        uint256 _traits,\r\n        Generation _generation,\r\n        Series _series,\r\n        Gender _gender,\r\n        uint8 _ranking\r\n    )\r\n    external\r\n    returns (uint256, uint256);\r\n\r\n    /**\r\n     * @notice Mint an Avastar Replicant.\r\n     * Only invokable by minter role, when contract is not paused.\r\n     * If successful, emits a `NewReplicant` event.\r\n     * @param _owner the address of the new Avastar's owner\r\n     * @param _traits the new Replicant's trait hash\r\n     * @param _generation the new Replicant's generation\r\n     * @param _gender the new Replicant's gender\r\n     * @param _ranking the new Replicant's rarity ranking\r\n     * @return tokenId the newly minted Replicant's token ID\r\n     * @return serial the newly minted Replicant's serial\r\n     */\r\n    function mintReplicant(\r\n        address _owner,\r\n        uint256 _traits,\r\n        Generation _generation,\r\n        Gender _gender,\r\n        uint8 _ranking\r\n    )\r\n    external\r\n    returns (uint256, uint256);\r\n\r\n    /**\r\n     * Gets the owner of the specified token ID.\r\n     * @param tokenId the token ID to search for the owner of\r\n     * @return owner the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @notice Gets the total amount of tokens stored by the contract.\r\n     * @return count total number of tokens\r\n     */\r\n    function totalSupply() public view returns (uint256 count);\r\n}\r\n\r\n// File: contracts/AvastarBase.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n/**\r\n * @title Avastar Base\r\n * @author Cliff Hall\r\n * @notice Utilities used by descendant contracts\r\n */\r\ncontract AvastarBase {\r\n\r\n    /**\r\n     * @notice Convert a `uint` value to a `string`\r\n     * via OraclizeAPI - MIT licence\r\n     * https://github.com/provable-things/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol#L896\r\n     * @param _i the `uint` value to be converted\r\n     * @return result the `string` representation of the given `uint` value\r\n     */\r\n    function uintToStr(uint _i)\r\n    internal pure\r\n    returns (string memory result) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        result = string(bstr);\r\n    }\r\n\r\n    /**\r\n     * @notice Concatenate two strings\r\n     * @param _a the first string\r\n     * @param _b the second string\r\n     * @return result the concatenation of `_a` and `_b`\r\n     */\r\n    function strConcat(string memory _a, string memory _b)\r\n    internal pure\r\n    returns(string memory result) {\r\n        result = string(abi.encodePacked(bytes(_a), bytes(_b)));\r\n    }\r\n\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Roles.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/AccessControl.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n/**\r\n * @title Access Control\r\n * @author Cliff Hall\r\n * @notice Role-based access control and contract upgrade functionality.\r\n */\r\ncontract AccessControl {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint16;\r\n    using Roles for Roles.Role;\r\n\r\n    Roles.Role private admins;\r\n    Roles.Role private minters;\r\n    Roles.Role private owners;\r\n\r\n    /**\r\n     * @notice Sets `msg.sender` as system admin by default.\r\n     * Starts paused. System admin must unpause, and add other roles after deployment.\r\n     */\r\n    constructor() public {\r\n        admins.add(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Emitted when contract is paused by system administrator.\r\n     */\r\n    event ContractPaused();\r\n\r\n    /**\r\n     * @notice Emitted when contract is unpaused by system administrator.\r\n     */\r\n    event ContractUnpaused();\r\n\r\n    /**\r\n     * @notice Emitted when contract is upgraded by system administrator.\r\n     * @param newContract address of the new version of the contract.\r\n     */\r\n    event ContractUpgrade(address newContract);\r\n\r\n\r\n    bool public paused = true;\r\n    bool public upgraded = false;\r\n    address public newContractAddress;\r\n\r\n    /**\r\n     * @notice Modifier to scope access to minters\r\n     */\r\n    modifier onlyMinter() {\r\n        require(minters.has(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to scope access to owners\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owners.has(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to scope access to system administrators\r\n     */\r\n    modifier onlySysAdmin() {\r\n        require(admins.has(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier to make a function callable only when the contract not upgraded.\r\n     */\r\n    modifier whenNotUpgraded() {\r\n        require(!upgraded);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Called by a system administrator to  mark the smart contract as upgraded,\r\n     * in case there is a serious breaking bug. This method stores the new contract\r\n     * address and emits an event to that effect. Clients of the contract should\r\n     * update to the new contract address upon receiving this event. This contract will\r\n     * remain paused indefinitely after such an upgrade.\r\n     * @param _newAddress address of new contract\r\n     */\r\n    function upgradeContract(address _newAddress) external onlySysAdmin whenPaused whenNotUpgraded {\r\n        require(_newAddress != address(0));\r\n        upgraded = true;\r\n        newContractAddress = _newAddress;\r\n        emit ContractUpgrade(_newAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Called by a system administrator to add a minter.\r\n     * Reverts if `_minterAddress` already has minter role\r\n     * @param _minterAddress approved minter\r\n     */\r\n    function addMinter(address _minterAddress) external onlySysAdmin {\r\n        minters.add(_minterAddress);\r\n        require(minters.has(_minterAddress));\r\n    }\r\n\r\n    /**\r\n     * @notice Called by a system administrator to add an owner.\r\n     * Reverts if `_ownerAddress` already has owner role\r\n     * @param _ownerAddress approved owner\r\n     * @return added boolean indicating whether the role was granted\r\n     */\r\n    function addOwner(address _ownerAddress) external onlySysAdmin {\r\n        owners.add(_ownerAddress);\r\n        require(owners.has(_ownerAddress));\r\n    }\r\n\r\n    /**\r\n     * @notice Called by a system administrator to add another system admin.\r\n     * Reverts if `_sysAdminAddress` already has sysAdmin role\r\n     * @param _sysAdminAddress approved owner\r\n     */\r\n    function addSysAdmin(address _sysAdminAddress) external onlySysAdmin {\r\n        admins.add(_sysAdminAddress);\r\n        require(admins.has(_sysAdminAddress));\r\n    }\r\n\r\n    /**\r\n     * @notice Called by an owner to remove all roles from an address.\r\n     * Reverts if address had no roles to be removed.\r\n     * @param _address address having its roles stripped\r\n     */\r\n    function stripRoles(address _address) external onlyOwner {\r\n        require(msg.sender != _address);\r\n        bool stripped = false;\r\n        if (admins.has(_address)) {\r\n            admins.remove(_address);\r\n            stripped = true;\r\n        }\r\n        if (minters.has(_address)) {\r\n            minters.remove(_address);\r\n            stripped = true;\r\n        }\r\n        if (owners.has(_address)) {\r\n            owners.remove(_address);\r\n            stripped = true;\r\n        }\r\n        require(stripped == true);\r\n    }\r\n\r\n    /**\r\n     * @notice Called by a system administrator to pause, triggers stopped state\r\n     */\r\n    function pause() external onlySysAdmin whenNotPaused {\r\n        paused = true;\r\n        emit ContractPaused();\r\n    }\r\n\r\n    /**\r\n     * @notice Called by a system administrator to un-pause, returns to normal state\r\n     */\r\n    function unpause() external onlySysAdmin whenPaused whenNotUpgraded {\r\n        paused = false;\r\n        emit ContractUnpaused();\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/AvastarMetadata.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Avastar Metadata Generator\r\n * @author Cliff Hall\r\n * @notice Generate Avastar metadata from on-chain data.\r\n * Refers to the `AvastarTeleporter` for raw data to generate\r\n * the human and machine readable metadata for a given Avastar token Id.\r\n */\r\ncontract AvastarMetadata is AvastarBase, AvastarTypes, AccessControl {\r\n\r\n    string public constant INVALID_TOKEN_ID = \"Invalid Token ID\";\r\n\r\n    /**\r\n     * @notice Event emitted when AvastarTeleporter contract is set\r\n     * @param contractAddress the address of the AvastarTeleporter contract\r\n     */\r\n    event TeleporterContractSet(address contractAddress);\r\n\r\n    /**\r\n     * @notice Event emitted when TokenURI base changes\r\n     * @param tokenUriBase the base URI for tokenURI calls\r\n     */\r\n    event TokenUriBaseSet(string tokenUriBase);\r\n\r\n    /**\r\n     * @notice Event emitted when the `mediaUriBase` is set.\r\n     * Only emitted when the `mediaUriBase` is set after contract deployment.\r\n     * @param mediaUriBase the new URI\r\n     */\r\n    event MediaUriBaseSet(string mediaUriBase);\r\n\r\n    /**\r\n     * @notice Event emitted when the `viewUriBase` is set.\r\n     * Only emitted when the `viewUriBase` is set after contract deployment.\r\n     * @param viewUriBase the new URI\r\n     */\r\n    event ViewUriBaseSet(string viewUriBase);\r\n\r\n    /**\r\n     * @notice Address of the AvastarTeleporter contract\r\n     */\r\n    IAvastarTeleporter private teleporterContract ;\r\n\r\n    /**\r\n     * @notice The base URI for an Avastar's off-chain metadata\r\n     */\r\n    string internal tokenUriBase;\r\n\r\n    /**\r\n     * @notice Base URI for an Avastar's off-chain image\r\n     */\r\n    string private mediaUriBase;\r\n\r\n    /**\r\n     * @notice Base URI to view an Avastar on the Avastars website\r\n     */\r\n    string private viewUriBase;\r\n\r\n    /**\r\n     * @notice Set the address of the `AvastarTeleporter` contract.\r\n     * Only invokable by system admin role, when contract is paused and not upgraded.\r\n     * To be used if the Teleporter contract has to be upgraded and a new instance deployed.\r\n     * If successful, emits an `TeleporterContractSet` event.\r\n     * @param _address address of `AvastarTeleporter` contract\r\n     */\r\n    function setTeleporterContract(address _address) external onlySysAdmin whenPaused whenNotUpgraded {\r\n\r\n        // Cast the candidate contract to the IAvastarTeleporter interface\r\n        IAvastarTeleporter candidateContract = IAvastarTeleporter(_address);\r\n\r\n        // Verify that we have the appropriate address\r\n        require(candidateContract.isAvastarTeleporter());\r\n\r\n        // Set the contract address\r\n        teleporterContract = IAvastarTeleporter(_address);\r\n\r\n        // Emit the event\r\n        emit TeleporterContractSet(_address);\r\n    }\r\n\r\n    /**\r\n     * @notice Acknowledge contract is `AvastarMetadata`\r\n     * @return always true\r\n     */\r\n    function isAvastarMetadata() external pure returns (bool) {return true;}\r\n\r\n    /**\r\n     * @notice Set the base URI for creating `tokenURI` for each Avastar.\r\n     * Only invokable by system admin role, when contract is paused and not upgraded.\r\n     * If successful, emits an `TokenUriBaseSet` event.\r\n     * @param _tokenUriBase base for the ERC721 tokenURI\r\n     */\r\n    function setTokenUriBase(string calldata _tokenUriBase)\r\n    external onlySysAdmin whenPaused whenNotUpgraded\r\n    {\r\n        // Set the base for metadata tokenURI\r\n        tokenUriBase = _tokenUriBase;\r\n\r\n        // Emit the event\r\n        emit TokenUriBaseSet(_tokenUriBase);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the base URI for the image of each Avastar.\r\n     * Only invokable by system admin role, when contract is paused and not upgraded.\r\n     * If successful, emits an `MediaUriBaseSet` event.\r\n     * @param _mediaUriBase base for the mediaURI shown in metadata for each Avastar\r\n     */\r\n    function setMediaUriBase(string calldata _mediaUriBase)\r\n    external onlySysAdmin whenPaused whenNotUpgraded\r\n    {\r\n        // Set the base for metadata tokenURI\r\n        mediaUriBase = _mediaUriBase;\r\n\r\n        // Emit the event\r\n        emit MediaUriBaseSet(_mediaUriBase);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the base URI for the image of each Avastar.\r\n     * Only invokable by system admin role, when contract is paused and not upgraded.\r\n     * If successful, emits an `MediaUriBaseSet` event.\r\n     * @param _viewUriBase base URI for viewing an Avastar on the Avastars website\r\n     */\r\n    function setViewUriBase(string calldata _viewUriBase)\r\n    external onlySysAdmin whenPaused whenNotUpgraded\r\n    {\r\n        // Set the base for metadata tokenURI\r\n        viewUriBase = _viewUriBase;\r\n\r\n        // Emit the event\r\n        emit ViewUriBaseSet(_viewUriBase);\r\n    }\r\n\r\n    /**\r\n     * @notice Get view URI for a given Avastar Token ID.\r\n     * @param _tokenId the Token ID of a previously minted Avastar Prime or Replicant\r\n     * @return uri the off-chain URI to view the Avastar on the Avastars website\r\n     */\r\n    function viewURI(uint _tokenId)\r\n    public view\r\n    returns (string memory uri)\r\n    {\r\n        require(_tokenId < teleporterContract.totalSupply(), INVALID_TOKEN_ID);\r\n        uri = strConcat(viewUriBase, uintToStr(_tokenId));\r\n    }\r\n\r\n    /**\r\n     * @notice Get media URI for a given Avastar Token ID.\r\n     * @param _tokenId the Token ID of a previously minted Avastar Prime or Replicant\r\n     * @return uri the off-chain URI to the Avastar image\r\n     */\r\n    function mediaURI(uint _tokenId)\r\n    public view\r\n    returns (string memory uri)\r\n    {\r\n        require(_tokenId < teleporterContract.totalSupply(), INVALID_TOKEN_ID);\r\n        uri = strConcat(mediaUriBase, uintToStr(_tokenId));\r\n    }\r\n\r\n    /**\r\n     * @notice Get token URI for a given Avastar Token ID.\r\n     * @param _tokenId the Token ID of a previously minted Avastar Prime or Replicant\r\n     * @return uri the Avastar's off-chain JSON metadata URI\r\n     */\r\n    function tokenURI(uint _tokenId)\r\n    external view\r\n    returns (string memory uri)\r\n    {\r\n        require(_tokenId < teleporterContract.totalSupply(), INVALID_TOKEN_ID);\r\n        uri = strConcat(tokenUriBase, uintToStr(_tokenId));\r\n    }\r\n\r\n    /**\r\n     * @notice Get human-readable metadata for a given Avastar by Token ID.\r\n     * @param _tokenId the token id of the given Avastar\r\n     * @return metadata the Avastar's human-readable metadata\r\n     */\r\n    function getAvastarMetadata(uint256 _tokenId)\r\n    external view\r\n    returns (string memory metadata) {\r\n\r\n        require(_tokenId < teleporterContract.totalSupply(), INVALID_TOKEN_ID);\r\n\r\n        uint256 id;\r\n        uint256 serial;\r\n        uint256 traits;\r\n        Generation generation;\r\n        Wave wave;\r\n        Series series;\r\n        Gender gender;\r\n        uint8 ranking;\r\n        string memory attribution;\r\n\r\n        // Get the Avastar\r\n        wave = teleporterContract.getAvastarWaveByTokenId(_tokenId);\r\n\r\n        // Get Prime or Replicant info depending on Avastar's Wave\r\n        if (wave == Wave.PRIME) {\r\n            (id, serial, traits, generation, series, gender, ranking) = teleporterContract.getPrimeByTokenId(_tokenId);\r\n        } else {\r\n            (id, serial, traits, generation, gender, ranking)  = teleporterContract.getReplicantByTokenId(_tokenId);\r\n        }\r\n\r\n        // Get artist attribution\r\n        attribution = teleporterContract.getAttributionByGeneration(generation);\r\n        attribution = strConcat('Original art by: ', attribution);\r\n\r\n        // Name\r\n        metadata = strConcat('{\\n  \"name\": \"Avastar #', uintToStr(uint256(id)));\r\n        metadata = strConcat(metadata, '\",\\n');\r\n\r\n        // Description: Generation\r\n        metadata = strConcat(metadata, '  \"description\": \"Generation ');\r\n        metadata = strConcat(metadata, uintToStr(uint8(generation) + 1));\r\n\r\n        // Description: Series (if 1-5)\r\n        if (wave == Wave.PRIME && series != Series.PROMO) {\r\n            metadata = strConcat(metadata, ' Series ');\r\n            metadata = strConcat(metadata, uintToStr(uint8(series)));\r\n        }\r\n\r\n        // Description: Gender\r\n        if (gender == Gender.MALE) {\r\n            metadata = strConcat(metadata, ' Male ');\r\n        }\r\n        else if (gender == Gender.FEMALE) {\r\n            metadata = strConcat(metadata, ' Female ');\r\n        }\r\n        else {\r\n            metadata = strConcat(metadata, ' Non-Binary ');\r\n        }\r\n\r\n        // Description: Founder, Exclusive, Prime, or Replicant\r\n        if (wave == Wave.PRIME && series == Series.PROMO) {\r\n            metadata = strConcat(metadata, (serial <100) ? 'Founder. ' : 'Exclusive. ');\r\n        } else {\r\n            metadata = strConcat(metadata, (wave == Wave.PRIME) ? 'Prime. ' : 'Replicant. ');\r\n        }\r\n        metadata = strConcat(metadata, attribution);\r\n        metadata = strConcat(metadata, '\",\\n');\r\n\r\n        // View URI\r\n        metadata = strConcat(metadata, '  \"external_url\": \"');\r\n        metadata = strConcat(metadata, viewURI(_tokenId));\r\n        metadata = strConcat(metadata, '\",\\n');\r\n\r\n        // Media URI\r\n        metadata = strConcat(metadata, '  \"image\": \"');\r\n        metadata = strConcat(metadata, mediaURI(_tokenId));\r\n        metadata = strConcat(metadata, '\",\\n');\r\n\r\n        // Attributes (ala OpenSea)\r\n        metadata = strConcat(metadata, '  \"attributes\": [\\n');\r\n\r\n        // Gender\r\n        metadata = strConcat(metadata, '    {\\n');\r\n        metadata = strConcat(metadata, '      \"trait_type\": \"gender\",\\n');\r\n        metadata = strConcat(metadata, '      \"value\": \"');\r\n        \r\n        if (gender == Gender.MALE) {\r\n            metadata = strConcat(metadata, 'male\"');\r\n        }\r\n        else if (gender == Gender.FEMALE) {\r\n            metadata = strConcat(metadata, 'female\"');\r\n        }\r\n        else {\r\n            metadata = strConcat(metadata, 'non-binary\"');\r\n        }\r\n\r\n        metadata = strConcat(metadata, '\\n    },\\n');\r\n\r\n        // Wave\r\n        metadata = strConcat(metadata, '    {\\n');\r\n        metadata = strConcat(metadata, '      \"trait_type\": \"wave\",\\n');\r\n        metadata = strConcat(metadata, '      \"value\": \"');\r\n        metadata = strConcat(metadata, (wave == Wave.PRIME) ? 'prime\"' : 'replicant\"');\r\n        metadata = strConcat(metadata, '\\n    },\\n');\r\n\r\n        // Generation\r\n        metadata = strConcat(metadata, '    {\\n');\r\n        metadata = strConcat(metadata, '      \"display_type\": \"number\",\\n');\r\n        metadata = strConcat(metadata, '      \"trait_type\": \"generation\",\\n');\r\n        metadata = strConcat(metadata, '      \"value\": ');\r\n        metadata = strConcat(metadata, uintToStr(uint8(generation) + 1));\r\n        metadata = strConcat(metadata, '\\n    },\\n');\r\n\r\n        // Series\r\n        if (wave == Wave.PRIME) {\r\n            metadata = strConcat(metadata, '    {\\n');\r\n            metadata = strConcat(metadata, '      \"display_type\": \"number\",\\n');\r\n            metadata = strConcat(metadata, '      \"trait_type\": \"series\",\\n');\r\n            metadata = strConcat(metadata, '      \"value\": ');\r\n            metadata = strConcat(metadata, uintToStr(uint8(series)));\r\n            metadata = strConcat(metadata, '\\n    },\\n');\r\n        }\r\n\r\n        // Serial\r\n        metadata = strConcat(metadata, '    {\\n');\r\n        metadata = strConcat(metadata, '      \"display_type\": \"number\",\\n');\r\n        metadata = strConcat(metadata, '      \"trait_type\": \"serial\",\\n');\r\n        metadata = strConcat(metadata, '      \"value\": ');\r\n        metadata = strConcat(metadata, uintToStr(serial));\r\n        metadata = strConcat(metadata, '\\n    },\\n');\r\n\r\n        // Ranking\r\n        metadata = strConcat(metadata, '    {\\n');\r\n        metadata = strConcat(metadata, '      \"display_type\": \"number\",\\n');\r\n        metadata = strConcat(metadata, '      \"trait_type\": \"ranking\",\\n');\r\n        metadata = strConcat(metadata, '      \"value\": ');\r\n        metadata = strConcat(metadata, uintToStr(ranking));\r\n        metadata = strConcat(metadata, '\\n    },\\n');\r\n\r\n        // Level\r\n        metadata = strConcat(metadata, '    {\\n');\r\n        metadata = strConcat(metadata, '      \"trait_type\": \"level\",\\n');\r\n        metadata = strConcat(metadata, '      \"value\": \"');\r\n        metadata = strConcat(metadata, getRankingLevel(ranking));\r\n        metadata = strConcat(metadata, '\"\\n    },\\n');\r\n\r\n        // Traits\r\n        metadata = strConcat(metadata, assembleTraitMetadata(generation, traits));\r\n\r\n        // Finish JSON object\r\n        metadata = strConcat(metadata, '  ]\\n}');\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Get the rarity level for a given Avastar Rank\r\n     * @param ranking the ranking level (1-100)\r\n     * @return level the rarity level (Common, Uncommon, Rare, Epic, Legendary)\r\n     */\r\n    function getRankingLevel(uint8 ranking)\r\n    internal pure\r\n    returns (string memory level) {\r\n        require(ranking >0 && ranking <=100);\r\n        uint8[4] memory breaks = [33, 41, 50, 60];\r\n        if (ranking < breaks[0]) {level = \"Common\";}\r\n        else if (ranking < breaks[1]) {level = \"Uncommon\";}\r\n        else if (ranking < breaks[2]) {level = \"Rare\";}\r\n        else if (ranking < breaks[3]) {level = \"Epic\";}\r\n        else {level = \"Legendary\";}\r\n    }\r\n\r\n    /**\r\n     * @notice Assemble the human-readable metadata for a given Trait hash.\r\n     * Used internally by\r\n     * @param _generation the generation the Avastar belongs to\r\n     * @param _traitHash the Avastar's trait hash\r\n     * @return metdata the JSON trait metadata for the Avastar\r\n     */\r\n    function assembleTraitMetadata(Generation _generation, uint256 _traitHash)\r\n    internal view\r\n    returns (string memory metadata)\r\n    {\r\n        require(_traitHash > 0);\r\n        uint256 slotConst = 256;\r\n        uint256 slotMask = 255;\r\n        uint256 bitMask;\r\n        uint256 slottedValue;\r\n        uint256 slotMultiplier;\r\n        uint256 variation;\r\n        uint256 traitId;\r\n\r\n        // Iterate trait hash by Gene and assemble trait attribute data\r\n        for (uint8 slot = 0; slot <= uint8(Gene.HAIR_STYLE); slot++){\r\n            slotMultiplier = uint256(slotConst**slot);  // Create slot multiplier\r\n            bitMask = slotMask * slotMultiplier;        // Create bit mask for slot\r\n            slottedValue = _traitHash & bitMask;        // Extract slotted value from hash\r\n            if (slottedValue > 0) {\r\n                variation = (slot > 0)                  // Extract variation from slotted value\r\n                ? slottedValue / slotMultiplier\r\n                : slottedValue;\r\n                if (variation > 0) {\r\n                    traitId = teleporterContract.getTraitIdByGenerationGeneAndVariation(_generation, Gene(slot), uint8(variation));\r\n                    metadata = strConcat(metadata, '    {\\n');\r\n                    metadata = strConcat(metadata, '      \"trait_type\": \"');\r\n                    if (slot == uint8(Gene.SKIN_TONE)) {\r\n                        metadata = strConcat(metadata, 'skin_tone');\r\n                    } else if (slot == uint8(Gene.HAIR_COLOR)) {\r\n                        metadata = strConcat(metadata, 'hair_color');\r\n                    } else if (slot == uint8(Gene.EYE_COLOR)) {\r\n                        metadata = strConcat(metadata, 'eye_color');\r\n                    } else if (slot == uint8(Gene.BG_COLOR)) {\r\n                        metadata = strConcat(metadata, 'background_color');\r\n                    } else if (slot == uint8(Gene.BACKDROP)) {\r\n                        metadata = strConcat(metadata, 'backdrop');\r\n                    } else if (slot == uint8(Gene.EARS)) {\r\n                        metadata = strConcat(metadata, 'ears');\r\n                    } else if (slot == uint8(Gene.FACE)) {\r\n                        metadata = strConcat(metadata, 'face');\r\n                    } else if (slot == uint8(Gene.NOSE)) {\r\n                        metadata = strConcat(metadata, 'nose');\r\n                    } else if (slot == uint8(Gene.MOUTH)) {\r\n                        metadata = strConcat(metadata, 'mouth');\r\n                    } else if (slot == uint8(Gene.FACIAL_FEATURE)) {\r\n                        metadata = strConcat(metadata, 'facial_feature');\r\n                    } else if (slot == uint8(Gene.EYES)) {\r\n                        metadata = strConcat(metadata, 'eyes');\r\n                    } else if (slot == uint8(Gene.HAIR_STYLE)) {\r\n                        metadata = strConcat(metadata, 'hair_style');\r\n                    }\r\n                    metadata = strConcat(metadata, '\",\\n');\r\n                    metadata = strConcat(metadata, '      \"value\": \"');\r\n                    metadata = strConcat(metadata, teleporterContract.getTraitNameById(traitId));\r\n                    metadata = strConcat(metadata, '\"\\n    }');\r\n                    if (slot < uint8(Gene.HAIR_STYLE))  metadata = strConcat(metadata, ',');\r\n                    metadata = strConcat(metadata, '\\n');\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[],\"name\":\"ContractPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ContractUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"mediaUriBase\",\"type\":\"string\"}],\"name\":\"MediaUriBaseSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"TeleporterContractSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenUriBase\",\"type\":\"string\"}],\"name\":\"TokenUriBaseSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"viewUriBase\",\"type\":\"string\"}],\"name\":\"ViewUriBaseSet\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"INVALID_TOKEN_ID\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minterAddress\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sysAdminAddress\",\"type\":\"address\"}],\"name\":\"addSysAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAvastarMetadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAvastarMetadata\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"mediaURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_mediaUriBase\",\"type\":\"string\"}],\"name\":\"setMediaUriBase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setTeleporterContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenUriBase\",\"type\":\"string\"}],\"name\":\"setTokenUriBase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_viewUriBase\",\"type\":\"string\"}],\"name\":\"setViewUriBase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"stripRoles\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"upgradeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgraded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"viewURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AvastarMetadata","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://92fb3bb5a877ca7faa6e4f373e0b47745ac26c0dacf4a791528c104a2134edb6"}]}