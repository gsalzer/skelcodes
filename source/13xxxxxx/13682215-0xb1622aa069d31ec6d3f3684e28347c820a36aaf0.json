{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/balances.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\nabstract contract ERC20 {\\n    function balanceOf(address account) public view virtual returns (uint256);\\n}\\n\\ncontract Balances {\\n    \\n    struct Balance {\\n        address user;\\n        address token;\\n        uint256 amount;\\n    }\\n    \\n    /* public functions */\\n    \\n    /* Check the ERC20 token balances of a wallet for multiple tokens and addresses.\\n     Returns array of token balances in wei units. */\\n    function tokenBalances(address[] calldata users,  address[] calldata tokens) external view returns (Balance[] memory balances) {\\n        balances = new Balance[](users.length * tokens.length);\\n        \\n        uint idx = 0;\\n        \\n        for(uint i = 0; i < tokens.length; i++) {\\n            \\n            for (uint j = 0; j < users.length; j++) {\\n                \\n                balances[idx].user = users[j];\\n                balances[idx].token = tokens[i];\\n                \\n                if(tokens[i] != address(0x0)) { \\n                    balances[idx].amount = tokenBalance(users[j], tokens[i]); // check token balance and catch errors\\n                } else {\\n                    balances[idx].amount = users[j].balance; // ETH balance    \\n                }\\n                idx++;\\n            }\\n        }    \\n        return balances;\\n    }\\n    \\n    \\n    /* Private functions */\\n    \\n    \\n    /* Check the token balance of a wallet in a token contract.\\n    Returns 0 on a bad token contract   */\\n    function tokenBalance(address user, address token) internal view returns (uint) {\\n        if(isAContract(token)) {\\n            return ERC20(token).balanceOf(user);\\n        } else {\\n            return 0; // not a valid contract, return 0 instead of error\\n        }\\n    }\\n    \\n    // check if contract (token, exchange) is actually a smart contract and not a 'regular' address\\n    function isAContract(address contractAddr) internal view returns (bool) {\\n        uint256 codeSize;\\n        assembly { codeSize := extcodesize(contractAddr) } // contract code size\\n        return codeSize > 0;\\n        // Might not be 100% foolproof, but reliable enough for an early return in 'view' functions \\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"tokenBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Balances.Balance[]\",\"name\":\"balances\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Balances","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}