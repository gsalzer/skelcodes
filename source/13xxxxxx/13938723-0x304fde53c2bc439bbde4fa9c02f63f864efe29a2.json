{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.10;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n  function balanceOf(address who) external view returns (uint256);\\n  function transfer(address to, uint256 value) external returns (bool);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\\n  function approve(address spender, uint256 value) external returns (bool);\\n}\"},\"IGatherToken.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity \\u003e=0.4.26;\\n\\ninterface IGatherToken {\\n  function unpauseTransfer() external;\\n  function pauseTransfer() external;\\n  function transferPaused() external returns (bool);\\n\\n  function owner() external returns (address);\\n  function transferOwnership(address newOwner) external;\\n\\n  function totalSupply() external view returns (uint256);\\n  function balanceOf(address who) external view returns (uint256);\\n  function transfer(address to, uint256 value) external returns (bool);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\\n  function approve(address spender, uint256 value) external returns (bool);\\n}\"},\"IUniswapV2Router01.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity \\u003e=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\"},\"IUniswapV2Router02.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity \\u003e=0.6.2;\\n\\nimport \\u0027./IUniswapV2Router01.sol\\u0027;\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"},\"WithdrawLP.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.10;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IGatherToken.sol\\\";\\nimport \\\"./IUniswapV2Router02.sol\\\";\\n\\ncontract WithdrawLP {\\n  IUniswapV2Router02 public constant uniswapRouterV2 = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n  IERC20 public constant lpToken = IERC20(0xb38bE7fD90669abCDfb314dBDDF6143AA88D3110);\\n  IGatherToken public constant gatherToken = IGatherToken(0xc3771d47E2Ab5A519E2917E61e23078d0C05Ed7f);\\n  address public constant gatherTokenController = 0x3b0C627f65ca4EEDf6f84FD6802506E710ddbe8B;\\n  address public owner;\\n\\n  constructor() {\\n    owner = msg.sender;\\n  }\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == owner, \\\"Caller is not the owner\\\");\\n    _;\\n  }\\n\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    require(newOwner != address(0));\\n    owner = newOwner;\\n  }\\n\\n  function transferOwnershipOfGatherToken(address to) public onlyOwner {\\n    require(to != address(0));\\n    gatherToken.transferOwnership(to);\\n    require(gatherToken.owner() == to, \\\"Failed in transferring ownership of gather token\\\");\\n  }\\n\\n  function withdrawToken(address tokenAddress, address to, uint256 amount) public onlyOwner returns (bool) {\\n    require(to != address(0));\\n    require(amount != 0);\\n    IERC20 token = IERC20(tokenAddress);\\n    return token.transfer(to, amount);\\n  }\\n\\n  function withdrawLP(uint256 amount, address to) public onlyOwner returns (uint256 amountA, uint256 amountB) {\\n    require(to != address(0));\\n    require(amount != 0);\\n    \\n    // Make sure that the LP token amount is in custody before calling withdraw on router\\n    uint256 lpBalance = lpToken.balanceOf(address(this));\\n    require(lpBalance \\u003e= amount, \\\"Insufficient balance of LP token\\\");\\n\\n    // Approve lp token to router address\\n    lpToken.approve(address(uniswapRouterV2), amount);\\n\\n    // Unpause gather token\\n    gatherToken.unpauseTransfer();\\n\\n    // withdraw LP\\n    address GTH = address(gatherToken);\\n    address WETH = uniswapRouterV2.WETH();\\n    (amountA, amountB) = uniswapRouterV2.removeLiquidity(\\n      GTH,\\n      WETH,\\n      amount,\\n      0,\\n      0,\\n      to,\\n      block.timestamp\\n    );\\n\\n    // Paurse gather token\\n    gatherToken.pauseTransfer();\\n\\n    // return ownership to old gather token controller\\n    transferOwnershipOfGatherToken(gatherTokenController);\\n  }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"gatherToken\",\"outputs\":[{\"internalType\":\"contract IGatherToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gatherTokenController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnershipOfGatherToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouterV2\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"WithdrawLP","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://2fe31291f1d72caee884c6fd74f07b95006d168b9ff937b22a773e1283237134"}]}