{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC1155 is IERC165{\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n    event TransferBatch(address indexed operator,address indexed from,address indexed to,uint256[] ids,uint256[] values);\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n    event URI(string value, uint256 indexed id);\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view  returns (uint256[] memory);\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from,address to,uint256 id,uint256 amount,bytes calldata data) external;\r\n    function safeBatchTransferFrom(address from,address to,uint256[] calldata ids,uint256[] calldata amounts,bytes calldata data) external;\r\n}\r\n\r\n\r\ninterface IERC1155Receiver is IERC165 {\r\n    function onERC1155Received(address operator,address from,uint256 id,uint256 value,bytes calldata data) external returns (bytes4);\r\n    function onERC1155BatchReceived(address operator,address from,uint256[] calldata ids,uint256[] calldata values,bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract AAACryptoAccessories is IERC1155 {\r\n    using Address for address;\r\n\r\n    mapping(address => uint256) private counts;\r\n    mapping(uint256 => mapping(address => uint256)) private _balances;\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    string private _defaultUri;\r\n    string public name;\r\n    string public symbol;\r\n\r\n    address private _owner;\r\n    address private _owner1;\r\n    address private _owner2;\r\n    address private first25;\r\n    address[] private _whiteListedAddresses;\r\n\r\n    uint private _price;\r\n    uint private _minted;\r\n    uint private _saleEnable = 0;\r\n    uint private _presaleEnable = 0;\r\n    \r\n    uint private TOTAL_TOKENS = 500;\r\n    uint private MAX_TOKENS_PER_ADDR1LIST = 2;\r\n    uint private MAX_TOKENS_PER_ADDR2LIST = 1;\r\n    \r\n    mapping(address => uint256) private whitelist1;\r\n    mapping(address => uint256) private whitelist2;\r\n    \r\n    \r\n    constructor( ) {\r\n        name = \"Utopia Pass\";\r\n        symbol = \"UP\";\r\n        \r\n        _setOwner(msg.sender);\r\n        _owner1 = 0xDcb879cA3483A8505A20eb4d2853c6620D65613c;\r\n        _owner2 = 0xEcC487709fE85fa8391c29c4f8F76e4738452687; \r\n        first25 = 0xDcb879cA3483A8505A20eb4d2853c6620D65613c; \r\n        _defaultUri=\"ipfs://ipfs/some_CID_/\";\r\n        \r\n        _price = 0.25 ether;\r\n        //reserve 25 tokens for addr first25, line 159\r\n        _mint(first25, 1, 25, \"\");\r\n        \r\n        _whiteListedAddresses = \r\n        [\r\n            0x3b10256766A47d39D3ED484cF7C6c10987d0F33a,\r\n            0x3b10256766A47d39D3ED484cF7C6c10987d0F33a,\r\n            0xe9099FfeecA205007e5E34269093496723f51931,\r\n            0x32d74c620Da3DB24747F453c5d01c87a83462139,\r\n            0x37660b87525559598c053f0f5b4c93C44Ec35E13,\r\n            0x05Ae78DD0DFDCB23f1B09186D07f0BD3dFcBa4F2,\r\n            0x0d9D145c19E9C1a25a8F48a1Ca786c3306Ca2C4A,\r\n            0x2b1f45DD72b278A829f0d047eB7Ed8A64EC80D92,\r\n            0xee183D9E1e2D133648829b37f5a0aB6436628C55,\r\n            0xE484a9d4E2b4Ecd2375EE77872241801dfC2aB4e,\r\n            0x619d70d46b64239bf5060bc12011F4b47d2aC825,\r\n            0x1d16F4dE6e3d0700ee9820772C0653C0F0A45ca2,\r\n            0x7255FE6f25ecaED72E85338c131D0daA60724Ecc,\r\n            0x373EBaf766B3cC6AA5f3758e73b1EbE47ff51caD,\r\n            0xb2B66dEE9aFbfAF5f58fBD856be93e872D0C93af,\r\n            0xe690246B2d5EA702c7bEF844f8e5dD73694405Ca,\r\n            0x83656f67BeEa8F4Df00a5089Aa82b41Bc11cdCE9,\r\n            0x09678D7f6187Ce98a2333F509D9fa8F9bCaA2C5E,\r\n            0x1094bBE0BB8cbFA94d549DF5ce122020F6add50A,\r\n            0x387Fd01eb7B7Fd5B99A5f5b8419148288d3898a4,\r\n            0x8150c915503aD4ED19c89145B5cec16b838aD902,\r\n            0x3808fD269346976fDb5753ba25761899EAaA8C0A,\r\n            0xadAE7d61F8Da4E626493646Ea14fd713045E6d1f,\r\n            0x2b43aeC1A9aF8E63E56f9B56E4Ab37348bFad139,\r\n            0x3ECB064c3b116Fe3C60Fd3950C68DeC7CF8A7cfc,\r\n            0xE2efacc45cb0e006172c91dd3FcD9A60Dd4AE0D5,\r\n            0xD5FcCFe43D2d3A84f4cc8864b88A202D9d8cF69d,\r\n            0x99BF3b218bEE3aA3c8b90d727EB9057c4B224251,\r\n            0xdea5f0ced7F50e0A2b37C7Ad9df0e2eD368739D4,\r\n            0xB4282b8B6feafAd7A4731Cb377340C2a519d770b,\r\n            0xc955Ce75796eF64eB1F09e9eff4481c8968C9346,\r\n            0x9B03891a8251c448B6C5D55556c43c3E0C64b924,\r\n            0xC3096eACEd76Bf8140920Cfc532191a818FAcB45,\r\n            0x5d8aA9Df3696f30817C20F515DA0D5e0aB98E7f2,\r\n            0x09209A7BA708da2111f971ad6800386F68441754,\r\n            0xdfDC3d90E83Ad1e283265E9206d2aCB15EF87f74,\r\n            0xeC88381602b2ea9BfC959984f0F33495282bFf0B,\r\n            0x987994601E75C643eE13CaA861975524c2EaF7aC,\r\n            0xC87f562f77Ef747e232D89ba952570F59C298A2B,\r\n            0x344bA2F42077B7206ed62cE745fd15477Bdf1795,\r\n            0xa1CFaE3082b21009495fAA57455Ee69A696dA4dD,\r\n            0x7704B95D00e01016bE164a32ad37a20Ae8234b89,\r\n            0xF8298fCFA36981DD5aE401fD1d880B16464C5860,\r\n            0xB8E75Ec8021759919819240d62ed89028f3e4B9D,\r\n            0x99BF3b218bEE3aA3c8b90d727EB9057c4B224251,\r\n            0x191EB06b656AF55004a02d9e207b5C379978200A,\r\n            0x4d4f7453F3a6139B24386d844785e6b4C01871A3,\r\n            0xe50E67bDB542340647Af845e94E1F6926b24c181,\r\n            0x849E0998e3276753bb3a90884480D7154e42Fb61,\r\n            0x8a94cC6Cf58d6318Cc7834a1195C85c013C08DB9,\r\n            0x57E2d6B9c4548eF6E44A05828fF1D369DE3F9dFc,\r\n            0xD79A5d91b4510cd26103591F83Ccb2268715F664,\r\n            0x4ee470c6f6A678adF8ddD5879Fd85A0d9cbD386b,\r\n            0x360f58916AbB5cc07b5512B5a6dF50Eb603Aa4A4,\r\n            0xb47C91f55896fe899393f9A7ecFD6A4426bb0AbF,\r\n            0x4edbfC403139860085a8a68e716ef9c2a0ec8471,\r\n            0x909D001fa57D69595abFf923355f0bA3D3a2a0B9\r\n        ];\r\n        _addToWhitelist1(_whiteListedAddresses);\r\n    }\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    function addToWhitelist(address[] memory newusers, uint numeration) external { // numeration of whitelist\r\n        for(uint256 i=0; i < newusers.length; i++){\r\n            if (numeration == 1) {\r\n                require(whitelist2[newusers[i]] == 0, \"Whitelist: the user is already on the whitelist2\"); // \r\n                whitelist1[newusers[i]] = 1;\r\n            } else if (numeration == 2) {\r\n                require(whitelist1[newusers[i]] == 0, \"Whitelist: the user is already on the whitelist1\");\r\n                whitelist2[newusers[i]] = 1; \r\n            }\r\n        }\r\n    }\r\n\r\n    function _addToWhitelist1(address[] memory newusers) internal { // numeration of whitelist\r\n        for(uint256 i=0; i < newusers.length; i++){\r\n            whitelist1[newusers[i]] = 1;\r\n        }\r\n    }\r\n\r\n    function removeFromWhitelist(address[] memory newusers, uint numeration) external { // numeration of whitelist\r\n        for(uint256 i=0; i < newusers.length; i++){\r\n            if (numeration == 1) {\r\n                whitelist1[newusers[i]] = 0;\r\n            } else if (numeration == 2) {\r\n                whitelist2[newusers[i]] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier saleEnabled() {\r\n        require(_saleEnable == 1, \"Sale is disabled\");\r\n        _;\r\n    }\r\n    modifier presaleEnabled() {\r\n        require(_presaleEnable == 1, \"PreSale is disabled\");\r\n        _;\r\n    }\r\n    \r\n    function enableSale() external onlyOwner{\r\n        _saleEnable = 1;\r\n    }\r\n\r\n    function disableSale() external onlyOwner{\r\n        _saleEnable = 0;\r\n    }\r\n    \r\n    function enablePresale() external onlyOwner{\r\n        _presaleEnable = 1;\r\n    }\r\n\r\n    function disablePresale() external onlyOwner{\r\n        _presaleEnable = 0;\r\n    }\r\n    \r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n    \r\n    function mint(\r\n        address _to,\r\n        uint256 _quantity\r\n    ) public payable saleEnabled {\r\n        require( _price * _quantity <= msg.value, \"Need more money to buy tokens\");\r\n        require( _minted + _quantity <= TOTAL_TOKENS, \"Max tokens reached\");    \r\n        \r\n        if (whitelist1[_to] == 1) {\r\n            require( _balances[1][_to] + _quantity <= MAX_TOKENS_PER_ADDR1LIST, \"Max tokens per address reached\");\r\n        } else if (whitelist2[_to] == 1) {\r\n            require( _balances[1][_to] + _quantity <= MAX_TOKENS_PER_ADDR2LIST, \"Max tokens per address reached\");\r\n        }\r\n        \r\n        _mint(_to, 1, _quantity, \"\");\r\n        \r\n        uint256 half_amount = msg.value / 2;\r\n        payable(_owner1).transfer(half_amount);\r\n        payable(_owner2).transfer(half_amount);\r\n    }\r\n  \r\n    function mintPresale(\r\n        address _to,\r\n        uint256 _quantity\r\n    ) public payable presaleEnabled {\r\n        require( _price * _quantity <= msg.value, \"Need more money to buy tokens\");\r\n        require( _minted + _quantity <= TOTAL_TOKENS, \"Max tokens reached\");          \r\n        require(whitelist1[_to] == 1 || whitelist2[_to] == 1, \"Address not allowed to buy\" );\r\n        \r\n        if (whitelist1[_to] == 1) {\r\n            require( _balances[1][_to] + _quantity <= MAX_TOKENS_PER_ADDR1LIST, \"Max tokens per address reached, 2/2\");\r\n        } else if (whitelist2[_to] == 1) {\r\n            require( _balances[1][_to] + _quantity <= MAX_TOKENS_PER_ADDR2LIST, \"Max tokens per address reached, 1/1\");\r\n        }\r\n        \r\n        _mint(_to, 1, _quantity, \"\");\r\n        \r\n        uint256 half_amount = msg.value / 2;\r\n        payable(_owner1).transfer(half_amount);\r\n        payable(_owner2).transfer(half_amount);\r\n    }\r\n\r\n    function _mint(\r\n        address account,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(account != address(0), \"ERC1155: mint to the zero address\");\r\n        address operator = account;\r\n        _balances[id][account] += amount;\r\n        _minted = _minted + amount;\r\n\r\n        emit TransferSingle(operator, address(0), account, id, amount);\r\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\r\n    }\r\n\r\n    function setDefaultUri(string memory _uri) public onlyOwner{\r\n        _defaultUri = _uri;\r\n    }\r\n    \r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()) ,\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n        _safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()) ,\r\n            \"ERC1155: transfer caller is not owner nor approved\"\r\n        );\r\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n\r\n        if (whitelist1[to] == 1) {\r\n            require( _balances[id][to] + amount <= MAX_TOKENS_PER_ADDR1LIST, \"Max tokens per address reached\");\r\n        } else if (whitelist2[to] == 1) {\r\n            require( _balances[id][to] + amount <= MAX_TOKENS_PER_ADDR2LIST, \"Max tokens per address reached\");\r\n        }\r\n\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n        \r\n        _balances[id][to] += amount;\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n\r\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\r\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\r\n        return _balances[id][account];\r\n    }\r\n\r\n    function uri() public view  returns (string memory){\r\n        return _defaultUri;\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256) {\r\n        return _minted;\r\n    }\r\n  \r\n    function _safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n\r\n            if (whitelist1[to] == 1) {\r\n                require( _balances[id][to] + amount <= MAX_TOKENS_PER_ADDR1LIST, \"Max tokens per address reached\");\r\n            } else if (whitelist2[to] == 1) {\r\n                require( _balances[id][to] + amount <= MAX_TOKENS_PER_ADDR2LIST, \"Max tokens per address reached\");\r\n            }    \r\n            \r\n            _balances[id][to] += amount;\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\r\n    }\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\r\n                bytes4 response\r\n            ) {\r\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"newusers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"numeration\",\"type\":\"uint256\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disablePresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enablePresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"mintPresale\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"newusers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"numeration\",\"type\":\"uint256\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setDefaultUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"AAACryptoAccessories","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3ce035409135a0855f050abd5be5bd99062667a59764e1f39349d1732207341c"}]}