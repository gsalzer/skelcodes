{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, throws on overflow.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface ChromaInterface {\r\n    function transmutePlotToNFTs(\r\n        address _recipient,\r\n        uint256 _plotId,\r\n        uint256 _count\r\n    ) external returns (bool);\r\n\r\n    function transmutePlotToERC20(\r\n        address _recipient,\r\n        uint256 _plotId,\r\n        uint256 _count\r\n    ) external returns (bool);\r\n\r\n    function toHex(uint256 _id) external view returns (string memory);\r\n}\r\n\r\ncontract ChromaticPlot is IERC721 {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Event emitted when minting a new NFT. \"createdVia\" is the index of the Cryptopunk/Autoglyph that was used to mint, or 0 if not applicable.\r\n     */\r\n    event Mint(uint256 indexed index, address indexed minter, bool isDevMint);\r\n\r\n    /**\r\n     * Event emitted when the public sale begins.\r\n     */\r\n    event ReleaseBegins(\r\n        uint256 price,\r\n        uint256 minPrice,\r\n        uint256 startTime,\r\n        uint256 duration,\r\n        uint256 quantity\r\n    );\r\n\r\n    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    uint256 public constant MAX_MINT_QUANTIY = 32;\r\n    uint256 public constant TOKEN_LIMIT = 65536;\r\n    uint256 public constant TOTAL_SALE_LIMIT = 32768;\r\n\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n    mapping(uint256 => address) public idToOwner;\r\n    mapping(uint256 => address) internal idToApproval;\r\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\r\n    mapping(address => uint256[]) public ownerToIds;\r\n    mapping(uint256 => uint256) public idToOwnerIndex;\r\n\r\n    string internal nftName = \"Chromatic Plot\";\r\n    string internal nftSymbol = unicode\"â–¦\";\r\n\r\n    uint256 public numTokens = 0;\r\n    uint256 public numSales = 0;\r\n\r\n    address public chroma;\r\n\r\n    bool public publicSale = false;\r\n    uint256 public minPrice;\r\n    uint256 private price;\r\n    uint256 public saleStartTime;\r\n    uint256 public saleDuration;\r\n    uint256 public saleCount;\r\n\r\n    //// Random index assignment\r\n    uint256 internal nonce = 0;\r\n    uint256[TOKEN_LIMIT] internal indices;\r\n\r\n    bool private reentrancyLock = false;\r\n\r\n    /* Prevent a contract function from being reentrant-called. */\r\n    modifier reentrancyGuard() {\r\n        if (reentrancyLock) {\r\n            revert();\r\n        }\r\n        reentrancyLock = true;\r\n        _;\r\n        reentrancyLock = false;\r\n    }\r\n\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(\r\n            tokenOwner == msg.sender ||\r\n                idToApproval[_tokenId] == msg.sender ||\r\n                ownerToOperators[tokenOwner][msg.sender],\r\n            \"Cannot transfer.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier canOperate(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(\r\n            tokenOwner == msg.sender ||\r\n                ownerToOperators[tokenOwner][msg.sender],\r\n            \"Cannot operate.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier validNFToken(uint256 _tokenId) {\r\n        require(idToOwner[_tokenId] != address(0), \"Invalid token.\");\r\n        _;\r\n    }\r\n\r\n    constructor(address payable _adminAddress, address _chroma) {\r\n        adminAddress = _adminAddress;\r\n        chroma = _chroma;\r\n\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n        supportedInterfaces[0x780e9d63] = true; // ERC721 Enumerable\r\n        supportedInterfaces[0x5b5e139f] = true; // ERC721 Metadata\r\n    }\r\n\r\n    function startRelease(\r\n        uint256 _price,\r\n        uint256 _minPrice,\r\n        uint256 _saleDuration,\r\n        uint256 _quantity\r\n    ) external onlyAdmin {\r\n        require(!publicSale);\r\n        require(\r\n            saleCount + _quantity <= TOTAL_SALE_LIMIT,\r\n            \"Exceeds total sale limit.\"\r\n        );\r\n        minPrice = _minPrice;\r\n        price = _price;\r\n        saleDuration = _saleDuration;\r\n        saleStartTime = block.timestamp;\r\n        publicSale = true;\r\n        saleCount = numSales + _quantity;\r\n        emit ReleaseBegins(\r\n            _price,\r\n            _minPrice,\r\n            saleStartTime,\r\n            saleDuration,\r\n            _quantity\r\n        );\r\n    }\r\n\r\n    function interruptRelease() external onlyAdmin {\r\n        publicSale = false;\r\n        saleCount = numSales;\r\n    }\r\n\r\n    function mintsRemaining() external view returns (uint256) {\r\n        return saleCount.sub(numSales);\r\n    }\r\n\r\n    function randomIndex() internal returns (uint256) {\r\n        uint256 totalSize = TOKEN_LIMIT - numTokens;\r\n        uint256 index = uint256(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    nonce,\r\n                    msg.sender,\r\n                    block.difficulty,\r\n                    block.timestamp\r\n                )\r\n            )\r\n        ) % totalSize;\r\n        uint256 value = 0;\r\n        if (indices[index] != 0) {\r\n            value = indices[index];\r\n        } else {\r\n            value = index;\r\n        }\r\n\r\n        // Move last value to selected position\r\n        if (indices[totalSize - 1] == 0) {\r\n            // Array position not initialized, so use position\r\n            indices[index] = totalSize - 1;\r\n        } else {\r\n            // Array position holds a value so use that\r\n            indices[index] = indices[totalSize - 1];\r\n        }\r\n        nonce++;\r\n        return value;\r\n    }\r\n\r\n    // Calculate the mint price\r\n    function getPrice() public view returns (uint256) {\r\n        require(publicSale, \"Sale not started.\");\r\n        uint256 elapsed = block.timestamp.sub(saleStartTime);\r\n        if (elapsed >= saleDuration) {\r\n            return minPrice;\r\n        } else {\r\n            return\r\n                saleDuration.sub(elapsed).mul(price).div(saleDuration) >\r\n                    minPrice\r\n                    ? saleDuration.sub(elapsed).mul(price).div(saleDuration)\r\n                    : minPrice;\r\n        }\r\n    }\r\n\r\n    function mint(uint256 _quantity) external payable reentrancyGuard {\r\n        require(publicSale, \"Sale not started.\");\r\n        require(\r\n            numSales + _quantity <= saleCount,\r\n            \"Exceeds current sale limit.\"\r\n        );\r\n        require(\r\n            _quantity > 0 && _quantity <= MAX_MINT_QUANTIY,\r\n            \"Invalid quantity.\"\r\n        );\r\n        uint256 salePrice = getPrice();\r\n        require(\r\n            msg.value >= salePrice.mul(_quantity),\r\n            \"Insufficient funds to purchase.\"\r\n        );\r\n        if (msg.value > salePrice.mul(_quantity)) {\r\n            msg.sender.transfer(msg.value.sub(salePrice.mul(_quantity)));\r\n        }\r\n        adminAddress.transfer(salePrice.mul(_quantity));\r\n        numSales = numSales + _quantity;\r\n        for (uint256 i = 0; i < _quantity; i++) {\r\n            _mint(msg.sender, false);\r\n        }\r\n    }\r\n\r\n    function devMint(uint256 quantity, address recipient) external onlyAdmin {\r\n        for (uint256 i = 0; i < quantity; i++) {\r\n            _mint(recipient, true);\r\n        }\r\n    }\r\n\r\n    function _mint(address _to, bool _isDevMint) internal returns (uint256) {\r\n        require(_to != address(0), \"Cannot mint to 0x0.\");\r\n        uint256 id = randomIndex();\r\n        numTokens = numTokens + 1;\r\n        _addNFToken(_to, id);\r\n        emit Mint(id, _to, _isDevMint);\r\n        emit Transfer(address(0), _to, id);\r\n        return id;\r\n    }\r\n\r\n    function _addNFToken(address _to, uint256 _tokenId) internal {\r\n        idToOwner[_tokenId] = _to;\r\n        ownerToIds[_to].push(_tokenId);\r\n        idToOwnerIndex[_tokenId] = ownerToIds[_to].length.sub(1);\r\n    }\r\n\r\n    function _removeNFToken(address _from, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == _from, \"Incorrect owner.\");\r\n        delete idToOwner[_tokenId];\r\n\r\n        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownerToIds[_from].length.sub(1);\r\n\r\n        if (lastTokenIndex != tokenToRemoveIndex) {\r\n            uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n            ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n            idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n        }\r\n\r\n        ownerToIds[_from].pop();\r\n    }\r\n\r\n    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\r\n        return ownerToIds[_owner].length;\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes memory _data\r\n    ) private canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from, \"Incorrect owner.\");\r\n        require(_to != address(0));\r\n\r\n        _transfer(_to, _tokenId);\r\n\r\n        if (isContract(_to)) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(\r\n                msg.sender,\r\n                _from,\r\n                _tokenId,\r\n                _data\r\n            );\r\n            require(retval == MAGIC_ON_ERC721_RECEIVED);\r\n        }\r\n    }\r\n\r\n    function _clearApproval(uint256 _tokenId) private {\r\n        if (idToApproval[_tokenId] != address(0)) {\r\n            delete idToApproval[_tokenId];\r\n        }\r\n    }\r\n\r\n    //////////////////////////\r\n    ////    Enumerable    ////\r\n    //////////////////////////\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return numTokens;\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(_index < ownerToIds[_owner].length);\r\n        return ownerToIds[_owner][_index];\r\n    }\r\n\r\n    //////////////////////////\r\n    ////  Administration  ////\r\n    //////////////////////////\r\n    address payable public adminAddress;\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == adminAddress, \"Only admin.\");\r\n        _;\r\n    }\r\n\r\n    function setAdmin(address payable _newAdmin) external onlyAdmin {\r\n        adminAddress = _newAdmin;\r\n    }\r\n\r\n    //////////////////////////\r\n    //// ERC 721 and 165  ////\r\n    //////////////////////////\r\n    function isContract(address _addr)\r\n        internal\r\n        view\r\n        returns (bool addressCheck)\r\n    {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        } // solhint-disable-line\r\n        addressCheck = size > 0;\r\n    }\r\n\r\n    function supportsInterface(bytes4 _interfaceID)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return supportedInterfaces[_interfaceID];\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external override {\r\n        _safeTransferFrom(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external override {\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external override canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from, \"Wrong from address.\");\r\n        require(_to != address(0), \"Cannot send to 0x0.\");\r\n        _transfer(_to, _tokenId);\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId)\r\n        external\r\n        override\r\n        canOperate(_tokenId)\r\n        validNFToken(_tokenId)\r\n    {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(_approved != tokenOwner);\r\n        idToApproval[_tokenId] = _approved;\r\n        emit Approval(tokenOwner, _approved, _tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved)\r\n        external\r\n        override\r\n    {\r\n        ownerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function balanceOf(address _owner)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(_owner != address(0));\r\n        return _getOwnerNFTCount(_owner);\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId)\r\n        external\r\n        view\r\n        override\r\n        returns (address _owner)\r\n    {\r\n        require(idToOwner[_tokenId] != address(0));\r\n        _owner = idToOwner[_tokenId];\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId)\r\n        external\r\n        view\r\n        override\r\n        validNFToken(_tokenId)\r\n        returns (address)\r\n    {\r\n        return idToApproval[_tokenId];\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return ownerToOperators[_owner][_operator];\r\n    }\r\n\r\n    function _transfer(address _to, uint256 _tokenId) internal {\r\n        address from = idToOwner[_tokenId];\r\n        _clearApproval(_tokenId);\r\n\r\n        _removeNFToken(from, _tokenId);\r\n        _addNFToken(_to, _tokenId);\r\n\r\n        emit Transfer(from, _to, _tokenId);\r\n    }\r\n\r\n    //////////////////////////\r\n    ////   Transmutation  ////\r\n    //////////////////////////\r\n\r\n    event TransmutationToNFT(uint256 indexed plotId, uint256 count);\r\n    event TransmutationToERC20(uint256 indexed plotId, uint256 count);\r\n\r\n    mapping(uint256 => address) public idToTransmuter;\r\n    mapping(address => uint256[]) public transmuterToIds;\r\n    mapping(uint256 => uint256) public idToTransmuterIndex;\r\n\r\n    function _addToTransmutations(address _to, uint256 _tokenId) internal {\r\n        idToTransmuter[_tokenId] = _to;\r\n        transmuterToIds[_to].push(_tokenId);\r\n        idToTransmuterIndex[_tokenId] = transmuterToIds[_to].length.sub(1);\r\n    }\r\n\r\n\r\n    function transmuteChromaNFT(uint256 _plotId, uint256 _count) external {\r\n        require(\r\n            idToOwner[_plotId] == msg.sender ||\r\n                idToTransmuter[_plotId] == msg.sender,\r\n            \"No access rights to transmute.\"\r\n        );\r\n        require(_count > 0, \"count must be greater than 0\");\r\n        emit TransmutationToNFT(_plotId, _count);\r\n\r\n        if (idToOwner[_plotId] == msg.sender) {\r\n            _clearApproval(_plotId);\r\n            _removeNFToken(msg.sender, _plotId);\r\n            idToTransmuter[_plotId] = msg.sender;\r\n            _addToTransmutations(msg.sender, _plotId);\r\n            emit Transfer(msg.sender, address(0), _plotId);\r\n        }\r\n        bool complete = ChromaInterface(chroma).transmutePlotToNFTs(\r\n            msg.sender,\r\n            _plotId,\r\n            _count\r\n        );\r\n    }\r\n    \r\n\r\n    function transmuteChromaERC20(uint256 _plotId, uint256 _count) external {\r\n        require(\r\n            idToOwner[_plotId] == msg.sender ||\r\n                idToTransmuter[_plotId] == msg.sender,\r\n            \"No access rights to transmute.\"\r\n        );\r\n        require(_count > 0, \"count must be greater than 0\");\r\n        emit TransmutationToERC20(_plotId, _count);\r\n\r\n        if (idToOwner[_plotId] == msg.sender) {\r\n            _clearApproval(_plotId);\r\n            _removeNFToken(msg.sender, _plotId);\r\n            idToTransmuter[_plotId] = msg.sender;\r\n            _addToTransmutations(msg.sender, _plotId);\r\n            emit Transfer(msg.sender, address(0), _plotId);\r\n        }\r\n        bool complete = ChromaInterface(chroma).transmutePlotToERC20(\r\n            msg.sender,\r\n            _plotId,\r\n            _count\r\n        );\r\n    }\r\n\r\n    function getOwnedTokenIds(address owner)\r\n        public\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256 length = ownerToIds[owner].length;\r\n        uint256[] memory owned = new uint256[](length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            owned[i] = ownerToIds[owner][i];\r\n        }\r\n        return owned;\r\n    }\r\n\r\n    function getOwnedTokenIdsSegment(\r\n        address owner,\r\n        uint256 startIndex,\r\n        uint256 count\r\n    ) public view returns (uint256[] memory) {\r\n        uint256[] memory owned = new uint256[](count);\r\n        for (uint256 i = startIndex; i < startIndex + count; i++) {\r\n            owned[i - startIndex] = ownerToIds[owner][i];\r\n        }\r\n        return owned;\r\n    }\r\n\r\n    function getTransmutingTokenIds(address owner)\r\n        public\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256 length = transmuterToIds[owner].length;\r\n        uint256[] memory transmuting = new uint256[](length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            transmuting[i] = transmuterToIds[owner][i];\r\n        }\r\n        return transmuting;\r\n    }\r\n\r\n    function toHexDigit(uint8 d) internal pure returns (bytes1) {\r\n        if (0 <= d && d <= 9) {\r\n            return bytes1(uint8(bytes1(\"0\")) + d);\r\n        } else if (10 <= uint8(d) && uint8(d) <= 15) {\r\n            return bytes1(uint8(bytes1(\"a\")) + d - 10);\r\n        }\r\n        revert();\r\n    }\r\n\r\n    function toHexString(uint256 a) public pure returns (string memory) {\r\n        uint256 count = 2;\r\n        uint256 b = a;\r\n        bytes memory res = new bytes(count);\r\n        for (uint256 i = 0; i < count; ++i) {\r\n            b = a % 16;\r\n            res[count - i - 1] = toHexDigit(uint8(b));\r\n            a /= 16;\r\n        }\r\n        return string(res);\r\n    }\r\n\r\n    function toHex(\r\n        uint256 _red,\r\n        uint256 _green,\r\n        uint256 _blue\r\n    ) public pure returns (string memory) {\r\n        string memory r = toHexString(_red);\r\n        string memory g = toHexString(_green);\r\n        string memory b = toHexString(_blue);\r\n        return string(abi.encodePacked(r, g, b));\r\n    }\r\n\r\n    function getData(uint256 _plotId) public pure returns (string[][] memory) {\r\n        string[][] memory plot = new string[][](16);\r\n        uint256 red = _plotId.div(256);\r\n        uint256 green = _plotId.mod(256);\r\n\r\n        uint256 blue = 0;\r\n        for (uint256 y = 0; y < 16; y++) {\r\n            string[] memory row = new string[](16);\r\n            for (uint256 x = 0; x < 16; x++) {\r\n                row[x] = toHex(red, green, blue);\r\n                blue = blue + 1;\r\n            }\r\n            plot[y] = row;\r\n        }\r\n        return plot;\r\n    }\r\n\r\n    //////////////////////////\r\n    ////     Metadata     ////\r\n    //////////////////////////\r\n\r\n    /**\r\n     * @dev Returns a descriptive name for a collection of NFTokens.\r\n     * @return _name Representing name.\r\n     */\r\n    function name() external view returns (string memory _name) {\r\n        _name = nftName;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an abbreviated name for NFTokens.\r\n     * @return _symbol Representing symbol.\r\n     */\r\n    function symbol() external view returns (string memory _symbol) {\r\n        _symbol = nftSymbol;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_adminAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chroma\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isDevMint\",\"type\":\"bool\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"ReleaseBegins\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"plotId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"TransmutationToERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"plotId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"TransmutationToNFT\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_MINT_QUANTIY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_SALE_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chroma\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"devMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_plotId\",\"type\":\"uint256\"}],\"name\":\"getData\",\"outputs\":[{\"internalType\":\"string[][]\",\"name\":\"\",\"type\":\"string[][]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getOwnedTokenIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getOwnedTokenIdsSegment\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getTransmutingTokenIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToOwnerIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToTransmuter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToTransmuterIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interruptRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintsRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numSales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerToIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_saleDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"startRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_red\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_green\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blue\",\"type\":\"uint256\"}],\"name\":\"toHex\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"toHexString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_plotId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"transmuteChromaERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_plotId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"transmuteChromaNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transmuterToIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ChromaticPlot","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000016203cc705ef183c8b9415013f84b8172f8f7f2400000000000000000000000098eb14b70cc1438c319ce55779c246d52e96e38f","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://05258afec242d627e3f7cd921cffa7cf8927af273409f280e2c29383e95bef32"}]}